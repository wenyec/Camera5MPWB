   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"sensor.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  23              	SensorRead2B.clone.1:
  24              	.LFB14:
  25              		.file 1 "../sensor.c"
   1:../sensor.c   **** /*
   2:../sensor.c   ****  ## Cypress FX3 Camera Kit source file (sensor.c)
   3:../sensor.c   ****  ## ===========================
   4:../sensor.c   ****  ##
   5:../sensor.c   ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../sensor.c   ****  ##  All Rights Reserved
   7:../sensor.c   ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../sensor.c   ****  ##
   9:../sensor.c   ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../sensor.c   ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../sensor.c   ****  ##
  12:../sensor.c   ****  ##  Use of this file is governed
  13:../sensor.c   ****  ##  by the license agreement included in the file
  14:../sensor.c   ****  ##
  15:../sensor.c   ****  ##     <install>/license/license.txt
  16:../sensor.c   ****  ##
  17:../sensor.c   ****  ##  where <install> is the Cypress software
  18:../sensor.c   ****  ##  installation root directory path.
  19:../sensor.c   ****  ##
  20:../sensor.c   ****  ## ===========================
  21:../sensor.c   ****  */
  22:../sensor.c   **** 
  23:../sensor.c   **** /* This file implements the I2C based driver for an image sensor that uses I2C
  24:../sensor.c   ****  for control in the FX3 HD 720p camera kit.
  25:../sensor.c   ****  */
  26:../sensor.c   **** 
  27:../sensor.c   **** #include <cyu3system.h>
  28:../sensor.c   **** #include <cyu3os.h>
  29:../sensor.c   **** #include <cyu3dma.h>
  30:../sensor.c   **** #include <cyu3error.h>
  31:../sensor.c   **** #include <cyu3uart.h>
  32:../sensor.c   **** #include <cyu3i2c.h>
  33:../sensor.c   **** #include <cyu3types.h>
  34:../sensor.c   **** #include <cyu3gpio.h>
  35:../sensor.c   **** #include <cyu3utils.h>
  36:../sensor.c   **** #include "sensor.h"
  37:../sensor.c   **** #include "uvc.h"
  38:../sensor.c   **** 
  39:../sensor.c   **** /* This function inserts a delay between successful I2C transfers to prevent
  40:../sensor.c   ****  false errors due to the slave being busy.
  41:../sensor.c   ****  */
  42:../sensor.c   **** static void SensorI2CAccessDelay(CyU3PReturnStatus_t status) {
  43:../sensor.c   **** 	/* Add a 10us delay if the I2C operation that preceded this call was successful. */
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
  45:../sensor.c   **** 	{
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
  47:../sensor.c   **** 	}
  48:../sensor.c   **** 	else //if I2C operation is not success reconfig the I2C
  49:../sensor.c   **** 	{
  50:../sensor.c   **** //		CyFxUVCApplnI2CInit ();
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
  52:../sensor.c   **** 	}
  53:../sensor.c   **** }
  54:../sensor.c   **** 
  55:../sensor.c   **** /* Write to an I2C slave with two bytes of data. */
  56:../sensor.c   **** CyU3PReturnStatus_t SensorWrite2B(
  57:../sensor.c   **** 	uint8_t slaveAddr,
  58:../sensor.c   **** 	uint8_t highAddr,
  59:../sensor.c   **** 	uint8_t lowAddr, 
  60:../sensor.c   **** 	uint8_t highData, 
  61:../sensor.c   **** 	uint8_t lowData) {
  62:../sensor.c   **** 	
  63:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  64:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
  65:../sensor.c   **** 	uint8_t buf[2];
  66:../sensor.c   **** 
  67:../sensor.c   **** 	/* Validate the I2C slave address. */
  68:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
  69:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
  70:../sensor.c   **** 		return 1;
  71:../sensor.c   **** 	}
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
  73:../sensor.c   **** 	preamble.buffer[1] = highAddr;
  74:../sensor.c   **** 	preamble.buffer[2] = lowAddr;
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
  77:../sensor.c   **** 	buf[0] = highData;
  78:../sensor.c   **** 
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
  80:../sensor.c   **** #ifdef DbgInfo
  81:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(0) %d %d %d\r\n", lowAddr, buf[0], lowData); //additional debug
  82:../sensor.c   **** #endif
  83:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
  84:../sensor.c   **** 
  85:../sensor.c   **** 	buf[0] = lowData;								/****************** data block *****************************************/
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
  87:../sensor.c   **** 	preamble.length = 1;
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
  89:../sensor.c   **** #ifdef DbgInfo
  90:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
  91:../sensor.c   **** #endif
  92:../sensor.c   **** 	/* Set the parameters for the I2C API access and then call the write API. */
  93:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
  94:../sensor.c   **** 	return apiRetStatus;
  95:../sensor.c   **** }
  96:../sensor.c   **** 
  97:../sensor.c   **** /* Write to an I2C slave with two bytes of data for 5MP camera. */
  98:../sensor.c   **** CyU3PReturnStatus_t SensorWrite2B2(
  99:../sensor.c   **** 	uint8_t slaveAddr,
 100:../sensor.c   **** 	uint8_t highAddr,
 101:../sensor.c   **** 	uint8_t lowAddr,
 102:../sensor.c   **** 	uint8_t highData,
 103:../sensor.c   **** 	uint8_t lowData) {
 104:../sensor.c   **** 
 105:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 106:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 107:../sensor.c   **** 	uint8_t buf[2];
 108:../sensor.c   **** 
 109:../sensor.c   **** 	/* Validate the I2C slave address. */
 110:../sensor.c   **** 	//if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 111:../sensor.c   **** 	//	CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 112:../sensor.c   **** 	//	return 1;
 113:../sensor.c   **** 	//}
 114:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 115:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 116:../sensor.c   **** 	//preamble.buffer[2] = lowAddr;
 117:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 118:../sensor.c   **** 	preamble.length = 2; /*  Three byte preamble. */
 119:../sensor.c   **** 	buf[0] = highData;
 120:../sensor.c   **** 
 121:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 122:../sensor.c   **** //#ifdef DbgInfo
 123:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(0) %d %d %d\r\n", lowAddr, buf[0], lowData); //additional debug
 124:../sensor.c   **** //#endif
 125:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 126:../sensor.c   **** 
 127:../sensor.c   **** 	buf[0] = lowData;								/****************** data block *****************************************/
 128:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 129:../sensor.c   **** 	preamble.length = 1;
 130:../sensor.c   **** 	//apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 131:../sensor.c   **** #ifdef DbgInfo
 132:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 133:../sensor.c   **** #endif
 134:../sensor.c   **** 	/* Set the parameters for the I2C API access and then call the write API. */
 135:../sensor.c   **** 	//SensorI2CAccessDelay(apiRetStatus);
 136:../sensor.c   **** 	return apiRetStatus;
 137:../sensor.c   **** }
 138:../sensor.c   **** 
 139:../sensor.c   **** CyU3PReturnStatus_t SensorWrite(uint8_t slaveAddr, uint8_t highAddr,
 140:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 141:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 142:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 143:../sensor.c   **** 
 144:../sensor.c   **** 	/* Validate the I2C slave address. */
 145:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 146:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 147:../sensor.c   **** 		return 1;
 148:../sensor.c   **** 	}
 149:../sensor.c   **** 
 150:../sensor.c   **** 	if (count > 64) {
 151:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 152:../sensor.c   **** 		return 1;
 153:../sensor.c   **** 	}
 154:../sensor.c   **** 
 155:../sensor.c   **** 	/* Set up the I2C control parameters and invoke the write API. */
 156:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 157:../sensor.c   **** 	preamble.buffer[1] = 0xab;//highAddr;
 158:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 159:../sensor.c   **** 	preamble.length = 3;
 160:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 161:../sensor.c   **** 
 162:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, count, 0);
 163:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 164:../sensor.c   **** 
 165:../sensor.c   **** 	return apiRetStatus;
 166:../sensor.c   **** }
 167:../sensor.c   **** 
 168:../sensor.c   **** CyU3PReturnStatus_t SensorRead2B(
  26              		.loc 1 168 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 16
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 12
  34 0004 1CD04DE2 		sub	sp, sp, #28
  35              	.LCFI1:
  36              		.cfi_def_cfa_offset 40
 169:../sensor.c   **** 		uint8_t slaveAddr, 
 170:../sensor.c   **** 		uint8_t highAddr,
 171:../sensor.c   **** 		uint8_t lowAddr, 
 172:../sensor.c   **** 		uint8_t RegAdd,
 173:../sensor.c   **** 		uint8_t *buf) {
 174:../sensor.c   **** 	
 175:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 176:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 177:../sensor.c   **** 
 178:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 179:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 180:../sensor.c   **** 		return 1;
 181:../sensor.c   **** 	}
 182:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 183:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
  37              		.loc 1 183 0
  38 0008 0D00CDE5 		strb	r0, [sp, #13]
 184:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
  39              		.loc 1 184 0
  40 000c 0E10CDE5 		strb	r1, [sp, #14]
 182:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
  41              		.loc 1 182 0
  42 0010 70E0A0E3 		mov	lr, #112
  43              		.cfi_offset 14, -4
  44              		.cfi_offset 5, -8
  45              		.cfi_offset 4, -12
 185:../sensor.c   **** 	preamble.length = 3;
 186:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 187:../sensor.c   **** 	buf[0] = RegAdd;
  46              		.loc 1 187 0
  47 0014 0020C3E5 		strb	r2, [r3, #0]
 188:../sensor.c   **** #ifdef DbgInfo
 189:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(0) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 190:../sensor.c   **** #endif
 191:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
  48              		.loc 1 191 0
  49 0018 0310A0E1 		mov	r1, r3
  50              	.LVL1:
  51 001c 0120A0E3 		mov	r2, #1
  52              	.LVL2:
 186:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
  53              		.loc 1 186 0
  54 0020 00C0A0E3 		mov	ip, #0	@ movhi
 168:../sensor.c   **** CyU3PReturnStatus_t SensorRead2B(
  55              		.loc 1 168 0
  56 0024 0340A0E1 		mov	r4, r3
  57              		.loc 1 191 0
  58 0028 0C008DE2 		add	r0, sp, #12
  59              	.LVL3:
  60 002c 0030A0E3 		mov	r3, #0
  61              	.LVL4:
 185:../sensor.c   **** 	preamble.length = 3;
  62              		.loc 1 185 0
  63 0030 0350A0E3 		mov	r5, #3
 182:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
  64              		.loc 1 182 0
  65 0034 0CE0CDE5 		strb	lr, [sp, #12]
 185:../sensor.c   **** 	preamble.length = 3;
  66              		.loc 1 185 0
  67 0038 1450CDE5 		strb	r5, [sp, #20]
 186:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
  68              		.loc 1 186 0
  69 003c B6C1CDE1 		strh	ip, [sp, #22]	@ movhi
  70              		.loc 1 191 0
  71 0040 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
  72              	.LVL5:
 192:../sensor.c   **** 	/*** test I2C bus ready ****/
 193:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
  73              		.loc 1 193 0
  74 0044 002050E2 		subs	r2, r0, #0
  75 0048 1D00001A 		bne	.L7
  76              	.LVL6:
  77              	.LBB6:
  78              	.LBB7:
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
  79              		.loc 1 46 0
  80 004c 7D0EA0E3 		mov	r0, #2000
  81              	.LVL7:
  82 0050 FEFFFFEB 		bl	CyU3PBusyWait
  83              	.LVL8:
  84              	.L3:
  85              	.LBE7:
  86              	.LBE6:
 194:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 195:../sensor.c   **** 	}
 196:../sensor.c   **** 
 197:../sensor.c   **** #ifdef DbgInfo
 198:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 199:../sensor.c   **** #endif
 200:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 201:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 202:../sensor.c   **** 	preamble.length = 1;
  87              		.loc 1 202 0
  88 0054 01C0A0E3 		mov	ip, #1
 201:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
  89              		.loc 1 201 0
  90 0058 71E0A0E3 		mov	lr, #113
 203:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
  91              		.loc 1 203 0
  92 005c 0050A0E3 		mov	r5, #0	@ movhi
 204:../sensor.c   **** 
 205:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, 1, 0);//send data block read one byte
  93              		.loc 1 205 0
  94 0060 0C008DE2 		add	r0, sp, #12
  95 0064 0410A0E1 		mov	r1, r4
  96 0068 0C20A0E1 		mov	r2, ip
  97 006c 0030A0E3 		mov	r3, #0
 203:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
  98              		.loc 1 203 0
  99 0070 B651CDE1 		strh	r5, [sp, #22]	@ movhi
 201:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 100              		.loc 1 201 0
 101 0074 0CE0CDE5 		strb	lr, [sp, #12]
 202:../sensor.c   **** 	preamble.length = 1;
 102              		.loc 1 202 0
 103 0078 14C0CDE5 		strb	ip, [sp, #20]
 104              		.loc 1 205 0
 105 007c FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 106              	.LVL9:
 206:../sensor.c   **** 	/*** test I2C bus ready ****/
 207:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 107              		.loc 1 207 0
 108 0080 005050E2 		subs	r5, r0, #0
 109 0084 0400001A 		bne	.L8
 110              	.LVL10:
 111              	.LBB9:
 112              	.LBB10:
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 113              		.loc 1 46 0
 114 0088 7D0EA0E3 		mov	r0, #2000
 115              	.LVL11:
 116 008c FEFFFFEB 		bl	CyU3PBusyWait
 117              	.LVL12:
 118              	.L5:
 119              	.LBE10:
 120              	.LBE9:
 208:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 209:../sensor.c   **** 	}
 210:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 211:../sensor.c   **** #ifdef DbgInfo
 212:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(2) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]); //additional de
 213:../sensor.c   **** #endif
 214:../sensor.c   **** 	return apiRetStatus;
 215:../sensor.c   **** }
 121              		.loc 1 215 0
 122 0090 0500A0E1 		mov	r0, r5
 123 0094 1CD08DE2 		add	sp, sp, #28
 124 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 125              	.L8:
 208:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 126              		.loc 1 208 0
 127 009c 01C0D4E5 		ldrb	ip, [r4, #1]	@ zero_extendqisi2
 128 00a0 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 129 00a4 3C109FE5 		ldr	r1, .L9
 130 00a8 0520A0E1 		mov	r2, r5
 131 00ac 0400A0E3 		mov	r0, #4
 132 00b0 00C08DE5 		str	ip, [sp, #0]
 133 00b4 FEFFFFEB 		bl	CyU3PDebugPrint
 134              	.LVL13:
 135              	.LBB12:
 136              	.LBB11:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 137              		.loc 1 51 0
 138 00b8 FA0FA0E3 		mov	r0, #1000
 139 00bc FEFFFFEB 		bl	CyU3PBusyWait
 140 00c0 F2FFFFEA 		b	.L5
 141              	.LVL14:
 142              	.L7:
 143              	.LBE11:
 144              	.LBE12:
 194:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 145              		.loc 1 194 0
 146 00c4 01C0D4E5 		ldrb	ip, [r4, #1]	@ zero_extendqisi2
 147 00c8 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 148 00cc 18109FE5 		ldr	r1, .L9+4
 149 00d0 0400A0E3 		mov	r0, #4
 150              	.LVL15:
 151 00d4 00C08DE5 		str	ip, [sp, #0]
 152 00d8 FEFFFFEB 		bl	CyU3PDebugPrint
 153              	.LVL16:
 154              	.LBB13:
 155              	.LBB8:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 156              		.loc 1 51 0
 157 00dc FA0FA0E3 		mov	r0, #1000
 158 00e0 FEFFFFEB 		bl	CyU3PBusyWait
 159 00e4 DAFFFFEA 		b	.L3
 160              	.L10:
 161              		.align	2
 162              	.L9:
 163 00e8 1C000000 		.word	.LC1
 164 00ec 00000000 		.word	.LC0
 165              	.LBE8:
 166              	.LBE13:
 167              		.cfi_endproc
 168              	.LFE14:
 170              		.align	2
 171              		.global	SensorWrite2B
 173              	SensorWrite2B:
 174              	.LFB1:
  61:../sensor.c   **** 	uint8_t lowData) {
 175              		.loc 1 61 0
 176              		.cfi_startproc
 177              		@ args = 4, pretend = 0, frame = 16
 178              		@ frame_needed = 0, uses_anonymous_args = 0
 179              	.LVL17:
 180 00f0 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 181              	.LCFI2:
 182              		.cfi_def_cfa_offset 20
  68:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 183              		.loc 1 68 0
 184 00f4 A00050E3 		cmp	r0, #160
 185 00f8 70005013 		cmpne	r0, #112
  61:../sensor.c   **** 	uint8_t lowData) {
 186              		.loc 1 61 0
 187 00fc 14D04DE2 		sub	sp, sp, #20
 188              	.LCFI3:
 189              		.cfi_def_cfa_offset 40
  61:../sensor.c   **** 	uint8_t lowData) {
 190              		.loc 1 61 0
 191 0100 00C0A0E1 		mov	ip, r0
  68:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 192              		.loc 1 68 0
 193 0104 00E0A003 		moveq	lr, #0
 194 0108 01E0A013 		movne	lr, #1
 195              		.cfi_offset 14, -4
 196              		.cfi_offset 7, -8
 197              		.cfi_offset 6, -12
 198              		.cfi_offset 5, -16
 199              		.cfi_offset 4, -20
  61:../sensor.c   **** 	uint8_t lowData) {
 200              		.loc 1 61 0
 201 010c 0170A0E1 		mov	r7, r1
 202 0110 0260A0E1 		mov	r6, r2
 203 0114 0350A0E1 		mov	r5, r3
 204 0118 2840DDE5 		ldrb	r4, [sp, #40]	@ zero_extendqisi2
  68:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 205              		.loc 1 68 0
 206 011c 2000001A 		bne	.L17
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 207              		.loc 1 79 0
 208 0120 0E30A0E1 		mov	r3, lr
 209              	.LVL18:
 210 0124 0C108DE2 		add	r1, sp, #12
 211              	.LVL19:
 212 0128 0120A0E3 		mov	r2, #1
 213              	.LVL20:
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 214              		.loc 1 72 0
 215 012c 00C0CDE5 		strb	ip, [sp, #0]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 216              		.loc 1 79 0
 217 0130 0D00A0E1 		mov	r0, sp
 218              	.LVL21:
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 219              		.loc 1 76 0
 220 0134 03C0A0E3 		mov	ip, #3
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 221              		.loc 1 75 0
 222 0138 BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 223              		.loc 1 76 0
 224 013c 08C0CDE5 		strb	ip, [sp, #8]
  73:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 225              		.loc 1 73 0
 226 0140 0170CDE5 		strb	r7, [sp, #1]
  74:../sensor.c   **** 	preamble.buffer[2] = lowAddr;
 227              		.loc 1 74 0
 228 0144 0260CDE5 		strb	r6, [sp, #2]
  77:../sensor.c   **** 	buf[0] = highData;
 229              		.loc 1 77 0
 230 0148 0C50CDE5 		strb	r5, [sp, #12]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 231              		.loc 1 79 0
 232 014c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 233              	.LVL22:
 234              	.LBB18:
 235              	.LBB19:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 236              		.loc 1 44 0
 237 0150 000050E3 		cmp	r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 238              		.loc 1 46 0
 239 0154 7D0EA003 		moveq	r0, #2000
 240              	.LVL23:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 241              		.loc 1 51 0
 242 0158 FA0FA013 		movne	r0, #1000
 243 015c FEFFFFEB 		bl	CyU3PBusyWait
 244              	.LBE19:
 245              	.LBE18:
  87:../sensor.c   **** 	preamble.length = 1;
 246              		.loc 1 87 0
 247 0160 01C0A0E3 		mov	ip, #1
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 248              		.loc 1 86 0
 249 0164 00E0A0E3 		mov	lr, #0	@ movhi
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 250              		.loc 1 88 0
 251 0168 0D00A0E1 		mov	r0, sp
 252 016c 0C108DE2 		add	r1, sp, #12
 253 0170 0C20A0E1 		mov	r2, ip
 254 0174 0030A0E3 		mov	r3, #0
  85:../sensor.c   **** 	buf[0] = lowData;								/****************** data block *****************************************/
 255              		.loc 1 85 0
 256 0178 0C40CDE5 		strb	r4, [sp, #12]
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 257              		.loc 1 86 0
 258 017c BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  87:../sensor.c   **** 	preamble.length = 1;
 259              		.loc 1 87 0
 260 0180 08C0CDE5 		strb	ip, [sp, #8]
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 261              		.loc 1 88 0
 262 0184 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 263              	.LVL24:
 264              	.LBB20:
 265              	.LBB21:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 266              		.loc 1 44 0
 267 0188 004050E2 		subs	r4, r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 268              		.loc 1 46 0
 269 018c 7D0EA003 		moveq	r0, #2000
 270              	.LVL25:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 271              		.loc 1 51 0
 272 0190 FA0FA013 		movne	r0, #1000
 273 0194 FEFFFFEB 		bl	CyU3PBusyWait
 274              	.LVL26:
 275              	.L13:
 276              	.LBE21:
 277              	.LBE20:
  95:../sensor.c   **** }
 278              		.loc 1 95 0
 279 0198 0400A0E1 		mov	r0, r4
 280 019c 14D08DE2 		add	sp, sp, #20
 281 01a0 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 282              	.LVL27:
 283              	.L17:
  69:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 284              		.loc 1 69 0
 285 01a4 0400A0E3 		mov	r0, #4
 286              	.LVL28:
 287 01a8 08109FE5 		ldr	r1, .L18
 288              	.LVL29:
 289 01ac FEFFFFEB 		bl	CyU3PDebugPrint
 290              	.LVL30:
  70:../sensor.c   **** 		return 1;
 291              		.loc 1 70 0
 292 01b0 0140A0E3 		mov	r4, #1
 293 01b4 F7FFFFEA 		b	.L13
 294              	.L19:
 295              		.align	2
 296              	.L18:
 297 01b8 38000000 		.word	.LC2
 298              		.cfi_endproc
 299              	.LFE1:
 301              		.align	2
 302              		.global	SensorWrite2B2
 304              	SensorWrite2B2:
 305              	.LFB2:
 103:../sensor.c   **** 	uint8_t lowData) {
 306              		.loc 1 103 0
 307              		.cfi_startproc
 308              		@ args = 4, pretend = 0, frame = 16
 309              		@ frame_needed = 0, uses_anonymous_args = 0
 310              	.LVL31:
 311 01bc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 312              	.LCFI4:
 313              		.cfi_def_cfa_offset 16
 314 01c0 18D04DE2 		sub	sp, sp, #24
 315              	.LCFI5:
 316              		.cfi_def_cfa_offset 40
 118:../sensor.c   **** 	preamble.length = 2; /*  Three byte preamble. */
 317              		.loc 1 118 0
 318 01c4 02C0A0E3 		mov	ip, #2
 103:../sensor.c   **** 	uint8_t lowData) {
 319              		.loc 1 103 0
 320 01c8 0260A0E1 		mov	r6, r2
 321              		.cfi_offset 14, -4
 322              		.cfi_offset 6, -8
 323              		.cfi_offset 5, -12
 324              		.cfi_offset 4, -16
 114:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 325              		.loc 1 114 0
 326 01cc 0800CDE5 		strb	r0, [sp, #8]
 115:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 327              		.loc 1 115 0
 328 01d0 0910CDE5 		strb	r1, [sp, #9]
 119:../sensor.c   **** 	buf[0] = highData;
 329              		.loc 1 119 0
 330 01d4 1430CDE5 		strb	r3, [sp, #20]
 121:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 331              		.loc 1 121 0
 332 01d8 14108DE2 		add	r1, sp, #20
 333              	.LVL32:
 334 01dc 0120A0E3 		mov	r2, #1
 335              	.LVL33:
 336 01e0 0030A0E3 		mov	r3, #0
 337              	.LVL34:
 338 01e4 08008DE2 		add	r0, sp, #8
 339              	.LVL35:
 117:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 340              		.loc 1 117 0
 341 01e8 0040A0E3 		mov	r4, #0	@ movhi
 118:../sensor.c   **** 	preamble.length = 2; /*  Three byte preamble. */
 342              		.loc 1 118 0
 343 01ec 10C0CDE5 		strb	ip, [sp, #16]
 103:../sensor.c   **** 	uint8_t lowData) {
 344              		.loc 1 103 0
 345 01f0 2850DDE5 		ldrb	r5, [sp, #40]	@ zero_extendqisi2
 117:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 346              		.loc 1 117 0
 347 01f4 B241CDE1 		strh	r4, [sp, #18]	@ movhi
 121:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 348              		.loc 1 121 0
 349 01f8 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 350              	.LVL36:
 123:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(0) %d %d %d\r\n", lowAddr, buf[0], lowData); //additional debug
 351              		.loc 1 123 0
 352 01fc 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 353 0200 2C109FE5 		ldr	r1, .L23
 354 0204 0620A0E1 		mov	r2, r6
 355 0208 00508DE5 		str	r5, [sp, #0]
 121:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 356              		.loc 1 121 0
 357 020c 0040A0E1 		mov	r4, r0
 358              	.LVL37:
 123:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor write2B(0) %d %d %d\r\n", lowAddr, buf[0], lowData); //additional debug
 359              		.loc 1 123 0
 360 0210 0400A0E3 		mov	r0, #4
 361              	.LVL38:
 362 0214 FEFFFFEB 		bl	CyU3PDebugPrint
 363              	.LVL39:
 364              	.LBB24:
 365              	.LBB25:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 366              		.loc 1 44 0
 367 0218 000054E3 		cmp	r4, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 368              		.loc 1 46 0
 369 021c 7D0EA003 		moveq	r0, #2000
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 370              		.loc 1 51 0
 371 0220 FA0FA013 		movne	r0, #1000
 372 0224 FEFFFFEB 		bl	CyU3PBusyWait
 373              	.LBE25:
 374              	.LBE24:
 137:../sensor.c   **** }
 375              		.loc 1 137 0
 376 0228 0400A0E1 		mov	r0, r4
 377 022c 18D08DE2 		add	sp, sp, #24
 378 0230 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 379              	.L24:
 380              		.align	2
 381              	.L23:
 382 0234 5C000000 		.word	.LC3
 383              		.cfi_endproc
 384              	.LFE2:
 386              		.align	2
 387              		.global	SensorWrite
 389              	SensorWrite:
 390              	.LFB3:
 140:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 391              		.loc 1 140 0
 392              		.cfi_startproc
 393              		@ args = 4, pretend = 0, frame = 16
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395              	.LVL40:
 145:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 396              		.loc 1 145 0
 397 0238 A00050E3 		cmp	r0, #160
 398 023c 70005013 		cmpne	r0, #112
 140:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 399              		.loc 1 140 0
 400 0240 10402DE9 		stmfd	sp!, {r4, lr}
 401              	.LCFI6:
 402              		.cfi_def_cfa_offset 8
 403 0244 00C0A0E1 		mov	ip, r0
 404 0248 10D04DE2 		sub	sp, sp, #16
 405              	.LCFI7:
 406              		.cfi_def_cfa_offset 24
 145:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_WR) && (slaveAddr != I2C_MEMORY_ADDR_WR)) {
 407              		.loc 1 145 0
 408 024c 00E0A003 		moveq	lr, #0
 409 0250 01E0A013 		movne	lr, #1
 410              		.cfi_offset 14, -4
 411              		.cfi_offset 4, -8
 412 0254 1A00001A 		bne	.L30
 150:../sensor.c   **** 	if (count > 64) {
 413              		.loc 1 150 0
 414 0258 400053E3 		cmp	r3, #64
 415 025c 1300008A 		bhi	.L31
 156:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 416              		.loc 1 156 0
 417 0260 04C0CDE5 		strb	ip, [sp, #4]
 157:../sensor.c   **** 	preamble.buffer[1] = 0xab;//highAddr;
 418              		.loc 1 157 0
 419 0264 54C0E0E3 		mvn	ip, #84
 162:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, count, 0);
 420              		.loc 1 162 0
 421 0268 0320A0E1 		mov	r2, r3
 422              	.LVL41:
 157:../sensor.c   **** 	preamble.buffer[1] = 0xab;//highAddr;
 423              		.loc 1 157 0
 424 026c 05C0CDE5 		strb	ip, [sp, #5]
 158:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 425              		.loc 1 158 0
 426 0270 3240E0E3 		mvn	r4, #50
 159:../sensor.c   **** 	preamble.length = 3;
 427              		.loc 1 159 0
 428 0274 03C0A0E3 		mov	ip, #3
 162:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, count, 0);
 429              		.loc 1 162 0
 430 0278 04008DE2 		add	r0, sp, #4
 431              	.LVL42:
 432 027c 18109DE5 		ldr	r1, [sp, #24]
 433              	.LVL43:
 434 0280 0E30A0E1 		mov	r3, lr
 435              	.LVL44:
 158:../sensor.c   **** 	preamble.buffer[2] = 0xcd;//lowAddr;
 436              		.loc 1 158 0
 437 0284 0640CDE5 		strb	r4, [sp, #6]
 159:../sensor.c   **** 	preamble.length = 3;
 438              		.loc 1 159 0
 439 0288 0CC0CDE5 		strb	ip, [sp, #12]
 160:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 440              		.loc 1 160 0
 441 028c BEE0CDE1 		strh	lr, [sp, #14]	@ movhi
 162:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, count, 0);
 442              		.loc 1 162 0
 443 0290 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 444              	.LVL45:
 445              	.LBB28:
 446              	.LBB29:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 447              		.loc 1 44 0
 448 0294 004050E2 		subs	r4, r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 449              		.loc 1 46 0
 450 0298 7D0EA003 		moveq	r0, #2000
 451              	.LVL46:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 452              		.loc 1 51 0
 453 029c FA0FA013 		movne	r0, #1000
 454 02a0 FEFFFFEB 		bl	CyU3PBusyWait
 455              	.LVL47:
 456              	.L27:
 457              	.LBE29:
 458              	.LBE28:
 166:../sensor.c   **** }
 459              		.loc 1 166 0
 460 02a4 0400A0E1 		mov	r0, r4
 461 02a8 10D08DE2 		add	sp, sp, #16
 462 02ac 1080BDE8 		ldmfd	sp!, {r4, pc}
 463              	.LVL48:
 464              	.L31:
 151:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 465              		.loc 1 151 0
 466 02b0 0400A0E3 		mov	r0, #4
 467              	.LVL49:
 468 02b4 1C109FE5 		ldr	r1, .L32
 469              	.LVL50:
 470 02b8 FEFFFFEB 		bl	CyU3PDebugPrint
 471              	.LVL51:
 152:../sensor.c   **** 		return 1;
 472              		.loc 1 152 0
 473 02bc 0140A0E3 		mov	r4, #1
 474 02c0 F7FFFFEA 		b	.L27
 475              	.LVL52:
 476              	.L30:
 146:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 477              		.loc 1 146 0
 478 02c4 0400A0E3 		mov	r0, #4
 479              	.LVL53:
 480 02c8 0C109FE5 		ldr	r1, .L32+4
 481              	.LVL54:
 482 02cc FEFFFFEB 		bl	CyU3PDebugPrint
 483              	.LVL55:
 147:../sensor.c   **** 		return 1;
 484              		.loc 1 147 0
 485 02d0 0140A0E3 		mov	r4, #1
 486 02d4 F2FFFFEA 		b	.L27
 487              	.L33:
 488              		.align	2
 489              	.L32:
 490 02d8 7C000000 		.word	.LC4
 491 02dc 38000000 		.word	.LC2
 492              		.cfi_endproc
 493              	.LFE3:
 495              		.align	2
 496              		.global	SensorRead2B
 498              	SensorRead2B:
 499              	.LFB4:
 173:../sensor.c   **** 		uint8_t *buf) {
 500              		.loc 1 173 0
 501              		.cfi_startproc
 502              		@ args = 4, pretend = 0, frame = 16
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              	.LVL56:
 505 02e0 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 506              	.LCFI8:
 507              		.cfi_def_cfa_offset 20
 178:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 508              		.loc 1 178 0
 509 02e4 A10050E3 		cmp	r0, #161
 510 02e8 71005013 		cmpne	r0, #113
 173:../sensor.c   **** 		uint8_t *buf) {
 511              		.loc 1 173 0
 512 02ec 1CD04DE2 		sub	sp, sp, #28
 513              	.LCFI9:
 514              		.cfi_def_cfa_offset 48
 173:../sensor.c   **** 		uint8_t *buf) {
 515              		.loc 1 173 0
 516 02f0 0040A0E1 		mov	r4, r0
 517              		.cfi_offset 14, -4
 518              		.cfi_offset 7, -8
 519              		.cfi_offset 6, -12
 520              		.cfi_offset 5, -16
 521              		.cfi_offset 4, -20
 178:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 522              		.loc 1 178 0
 523 02f4 00C0A003 		moveq	ip, #0
 524 02f8 01C0A013 		movne	ip, #1
 173:../sensor.c   **** 		uint8_t *buf) {
 525              		.loc 1 173 0
 526 02fc 0160A0E1 		mov	r6, r1
 527 0300 02E0A0E1 		mov	lr, r2
 528 0304 30509DE5 		ldr	r5, [sp, #48]
 178:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 529              		.loc 1 178 0
 530 0308 2100001A 		bne	.L40
 187:../sensor.c   **** 	buf[0] = RegAdd;
 531              		.loc 1 187 0
 532 030c 0030C5E5 		strb	r3, [r5, #0]
 182:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 533              		.loc 1 182 0
 534 0310 0170C0E3 		bic	r7, r0, #1
 191:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 535              		.loc 1 191 0
 536 0314 0120A0E3 		mov	r2, #1
 537              	.LVL57:
 184:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 538              		.loc 1 184 0
 539 0318 0EE0CDE5 		strb	lr, [sp, #14]
 191:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 540              		.loc 1 191 0
 541 031c 0C008DE2 		add	r0, sp, #12
 542              	.LVL58:
 185:../sensor.c   **** 	preamble.length = 3;
 543              		.loc 1 185 0
 544 0320 03E0A0E3 		mov	lr, #3
 191:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 545              		.loc 1 191 0
 546 0324 0510A0E1 		mov	r1, r5
 547              	.LVL59:
 548 0328 0C30A0E1 		mov	r3, ip
 549              	.LVL60:
 182:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 550              		.loc 1 182 0
 551 032c 0C70CDE5 		strb	r7, [sp, #12]
 183:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 552              		.loc 1 183 0
 553 0330 0D60CDE5 		strb	r6, [sp, #13]
 185:../sensor.c   **** 	preamble.length = 3;
 554              		.loc 1 185 0
 555 0334 14E0CDE5 		strb	lr, [sp, #20]
 186:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 556              		.loc 1 186 0
 557 0338 B6C1CDE1 		strh	ip, [sp, #22]	@ movhi
 191:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 558              		.loc 1 191 0
 559 033c FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 560              	.LVL61:
 193:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 561              		.loc 1 193 0
 562 0340 002050E2 		subs	r2, r0, #0
 563 0344 1700001A 		bne	.L41
 564              	.LVL62:
 565              	.LBB34:
 566              	.LBB35:
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 567              		.loc 1 46 0
 568 0348 7D0EA0E3 		mov	r0, #2000
 569              	.LVL63:
 570 034c FEFFFFEB 		bl	CyU3PBusyWait
 571              	.LVL64:
 572              	.L38:
 573              	.LBE35:
 574              	.LBE34:
 202:../sensor.c   **** 	preamble.length = 1;
 575              		.loc 1 202 0
 576 0350 01E0A0E3 		mov	lr, #1
 201:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 577              		.loc 1 201 0
 578 0354 0C40CDE5 		strb	r4, [sp, #12]
 205:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, 1, 0);//send data block read one byte
 579              		.loc 1 205 0
 580 0358 0C008DE2 		add	r0, sp, #12
 203:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 581              		.loc 1 203 0
 582 035c 0040A0E3 		mov	r4, #0	@ movhi
 205:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, 1, 0);//send data block read one byte
 583              		.loc 1 205 0
 584 0360 0510A0E1 		mov	r1, r5
 585 0364 0E20A0E1 		mov	r2, lr
 586 0368 0030A0E3 		mov	r3, #0
 203:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 587              		.loc 1 203 0
 588 036c B641CDE1 		strh	r4, [sp, #22]	@ movhi
 202:../sensor.c   **** 	preamble.length = 1;
 589              		.loc 1 202 0
 590 0370 14E0CDE5 		strb	lr, [sp, #20]
 205:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, 1, 0);//send data block read one byte
 591              		.loc 1 205 0
 592 0374 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 593              	.LVL65:
 207:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 594              		.loc 1 207 0
 595 0378 004050E2 		subs	r4, r0, #0
 596 037c 1200001A 		bne	.L42
 597              	.LVL66:
 598              	.LBB37:
 599              	.LBB38:
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 600              		.loc 1 46 0
 601 0380 7D0EA0E3 		mov	r0, #2000
 602              	.LVL67:
 603 0384 FEFFFFEB 		bl	CyU3PBusyWait
 604              	.LVL68:
 605              	.L36:
 606              	.LBE38:
 607              	.LBE37:
 608              		.loc 1 215 0
 609 0388 0400A0E1 		mov	r0, r4
 610 038c 1CD08DE2 		add	sp, sp, #28
 611 0390 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 612              	.LVL69:
 613              	.L40:
 179:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 614              		.loc 1 179 0
 615 0394 0400A0E3 		mov	r0, #4
 616              	.LVL70:
 617 0398 54109FE5 		ldr	r1, .L43
 618              	.LVL71:
 619 039c FEFFFFEB 		bl	CyU3PDebugPrint
 620              	.LVL72:
 180:../sensor.c   **** 		return 1;
 621              		.loc 1 180 0
 622 03a0 0140A0E3 		mov	r4, #1
 623 03a4 F7FFFFEA 		b	.L36
 624              	.LVL73:
 625              	.L41:
 194:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 626              		.loc 1 194 0
 627 03a8 01C0D5E5 		ldrb	ip, [r5, #1]	@ zero_extendqisi2
 628 03ac 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 629 03b0 40109FE5 		ldr	r1, .L43+4
 630 03b4 0400A0E3 		mov	r0, #4
 631              	.LVL74:
 632 03b8 00C08DE5 		str	ip, [sp, #0]
 633 03bc FEFFFFEB 		bl	CyU3PDebugPrint
 634              	.LVL75:
 635              	.LBB40:
 636              	.LBB36:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 637              		.loc 1 51 0
 638 03c0 FA0FA0E3 		mov	r0, #1000
 639 03c4 FEFFFFEB 		bl	CyU3PBusyWait
 640 03c8 E0FFFFEA 		b	.L38
 641              	.LVL76:
 642              	.L42:
 643              	.LBE36:
 644              	.LBE40:
 208:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 645              		.loc 1 208 0
 646 03cc 01C0D5E5 		ldrb	ip, [r5, #1]	@ zero_extendqisi2
 647 03d0 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 648 03d4 20109FE5 		ldr	r1, .L43+8
 649 03d8 0420A0E1 		mov	r2, r4
 650 03dc 0400A0E3 		mov	r0, #4
 651              	.LVL77:
 652 03e0 00C08DE5 		str	ip, [sp, #0]
 653 03e4 FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL78:
 655              	.LBB41:
 656              	.LBB39:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 657              		.loc 1 51 0
 658 03e8 FA0FA0E3 		mov	r0, #1000
 659 03ec FEFFFFEB 		bl	CyU3PBusyWait
 660 03f0 E4FFFFEA 		b	.L36
 661              	.L44:
 662              		.align	2
 663              	.L43:
 664 03f4 38000000 		.word	.LC2
 665 03f8 00000000 		.word	.LC0
 666 03fc 1C000000 		.word	.LC1
 667              	.LBE39:
 668              	.LBE41:
 669              		.cfi_endproc
 670              	.LFE4:
 672              		.align	2
 673              		.global	SensorRead2B2
 675              	SensorRead2B2:
 676              	.LFB5:
 216:../sensor.c   **** 
 217:../sensor.c   **** CyU3PReturnStatus_t SensorRead2B2(
 218:../sensor.c   **** 		uint8_t slaveAddr, 
 219:../sensor.c   **** 		uint8_t highAddr,
 220:../sensor.c   **** 		uint8_t lowAddr, 
 221:../sensor.c   **** 		uint8_t RegAdd,
 222:../sensor.c   **** 		uint8_t *buf) {
 677              		.loc 1 222 0
 678              		.cfi_startproc
 679              		@ args = 4, pretend = 0, frame = 16
 680              		@ frame_needed = 0, uses_anonymous_args = 0
 681              	.LVL79:
 682 0400 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 683              	.LCFI10:
 684              		.cfi_def_cfa_offset 16
 223:../sensor.c   **** 	
 224:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 225:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 226:../sensor.c   **** 
 227:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 685              		.loc 1 227 0
 686 0404 A10050E3 		cmp	r0, #161
 687 0408 71005013 		cmpne	r0, #113
 222:../sensor.c   **** 		uint8_t *buf) {
 688              		.loc 1 222 0
 689 040c 18D04DE2 		sub	sp, sp, #24
 690              	.LCFI11:
 691              		.cfi_def_cfa_offset 40
 692              		.loc 1 227 0
 693 0410 00C0A003 		moveq	ip, #0
 694 0414 01C0A013 		movne	ip, #1
 222:../sensor.c   **** 		uint8_t *buf) {
 695              		.loc 1 222 0
 696 0418 0150A0E1 		mov	r5, r1
 697              		.cfi_offset 14, -4
 698              		.cfi_offset 6, -8
 699              		.cfi_offset 5, -12
 700              		.cfi_offset 4, -16
 701 041c 02E0A0E1 		mov	lr, r2
 702 0420 28409DE5 		ldr	r4, [sp, #40]
 703              		.loc 1 227 0
 704 0424 1300001A 		bne	.L49
 228:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 229:../sensor.c   **** 		return 1;
 230:../sensor.c   **** 	}
 231:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 232:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 233:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 234:../sensor.c   **** 	preamble.length = 3;
 235:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 236:../sensor.c   **** 	buf[0] = RegAdd;
 705              		.loc 1 236 0
 706 0428 0030C4E5 		strb	r3, [r4, #0]
 231:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 707              		.loc 1 231 0
 708 042c 0160C0E3 		bic	r6, r0, #1
 233:../sensor.c   **** 	preamble.buffer[2] = lowAddr; //lowAddr;
 709              		.loc 1 233 0
 710 0430 0EE0CDE5 		strb	lr, [sp, #14]
 237:../sensor.c   **** #ifdef DbgInfo
 238:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(0) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 239:../sensor.c   **** #endif
 240:../sensor.c   **** #if 0
 241:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0); //send command block to prepare for re
 242:../sensor.c   **** 	/*** test I2C bus ready ****/
 243:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 244:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(T) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 245:../sensor.c   **** 	}
 246:../sensor.c   **** 
 247:../sensor.c   **** #ifdef DbgInfo
 248:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(1) %d %d %d\r\n", lowAddr, buf[0], buf[1]); //additional debug
 249:../sensor.c   **** #endif
 250:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 251:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;
 252:../sensor.c   **** 	preamble.length = 1;
 253:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 254:../sensor.c   **** #endif
 255:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, 1, 0);//send data block read one byte
 711              		.loc 1 255 0
 712 0434 0C008DE2 		add	r0, sp, #12
 713              	.LVL80:
 234:../sensor.c   **** 	preamble.length = 3;
 714              		.loc 1 234 0
 715 0438 03E0A0E3 		mov	lr, #3
 716              		.loc 1 255 0
 717 043c 0410A0E1 		mov	r1, r4
 718              	.LVL81:
 719 0440 0120A0E3 		mov	r2, #1
 720              	.LVL82:
 721 0444 0C30A0E1 		mov	r3, ip
 722              	.LVL83:
 232:../sensor.c   **** 	preamble.buffer[1] = highAddr; //highAddr;
 723              		.loc 1 232 0
 724 0448 0D50CDE5 		strb	r5, [sp, #13]
 231:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 725              		.loc 1 231 0
 726 044c 0C60CDE5 		strb	r6, [sp, #12]
 234:../sensor.c   **** 	preamble.length = 3;
 727              		.loc 1 234 0
 728 0450 14E0CDE5 		strb	lr, [sp, #20]
 235:../sensor.c   **** 	preamble.ctrlMask = 0x0000; /*  Send start bit after third byte of preamble. */
 729              		.loc 1 235 0
 730 0454 B6C1CDE1 		strh	ip, [sp, #22]	@ movhi
 731              		.loc 1 255 0
 732 0458 FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 733              	.LVL84:
 256:../sensor.c   **** 	/*** test I2C bus ready ****/
 257:../sensor.c   **** 	if(apiRetStatus != CY_U3P_SUCCESS){
 734              		.loc 1 257 0
 735 045c 005050E2 		subs	r5, r0, #0
 736 0460 0900001A 		bne	.L50
 737              	.LVL85:
 738              	.LBB44:
 739              	.LBB45:
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 740              		.loc 1 46 0
 741 0464 7D0EA0E3 		mov	r0, #2000
 742              	.LVL86:
 743 0468 FEFFFFEB 		bl	CyU3PBusyWait
 744              	.LVL87:
 745              	.L47:
 746              	.LBE45:
 747              	.LBE44:
 258:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 259:../sensor.c   **** 	}
 260:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 261:../sensor.c   **** #ifdef DbgInfo
 262:../sensor.c   **** 	CyU3PDebugPrint(4, "sensor read2B(2) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]); //additional de
 263:../sensor.c   **** #endif
 264:../sensor.c   **** 	return apiRetStatus;
 265:../sensor.c   **** }
 748              		.loc 1 265 0
 749 046c 0500A0E1 		mov	r0, r5
 750 0470 18D08DE2 		add	sp, sp, #24
 751 0474 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 752              	.LVL88:
 753              	.L49:
 228:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 754              		.loc 1 228 0
 755 0478 0400A0E3 		mov	r0, #4
 756              	.LVL89:
 757 047c 30109FE5 		ldr	r1, .L51
 758              	.LVL90:
 759 0480 FEFFFFEB 		bl	CyU3PDebugPrint
 760              	.LVL91:
 229:../sensor.c   **** 		return 1;
 761              		.loc 1 229 0
 762 0484 0150A0E3 		mov	r5, #1
 763 0488 F7FFFFEA 		b	.L47
 764              	.LVL92:
 765              	.L50:
 258:../sensor.c   **** 		CyU3PDebugPrint(4, "sensor read2B(R) %d %d %d\r\n", apiRetStatus, buf[0], buf[1]);
 766              		.loc 1 258 0
 767 048c 01C0D4E5 		ldrb	ip, [r4, #1]	@ zero_extendqisi2
 768 0490 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 769 0494 1C109FE5 		ldr	r1, .L51+4
 770 0498 0520A0E1 		mov	r2, r5
 771 049c 0400A0E3 		mov	r0, #4
 772              	.LVL93:
 773 04a0 00C08DE5 		str	ip, [sp, #0]
 774 04a4 FEFFFFEB 		bl	CyU3PDebugPrint
 775              	.LVL94:
 776              	.LBB47:
 777              	.LBB46:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 778              		.loc 1 51 0
 779 04a8 FA0FA0E3 		mov	r0, #1000
 780 04ac FEFFFFEB 		bl	CyU3PBusyWait
 781 04b0 EDFFFFEA 		b	.L47
 782              	.L52:
 783              		.align	2
 784              	.L51:
 785 04b4 38000000 		.word	.LC2
 786 04b8 1C000000 		.word	.LC1
 787              	.LBE46:
 788              	.LBE47:
 789              		.cfi_endproc
 790              	.LFE5:
 792              		.align	2
 793              		.global	SensorRead
 795              	SensorRead:
 796              	.LFB6:
 266:../sensor.c   **** 
 267:../sensor.c   **** 
 268:../sensor.c   **** CyU3PReturnStatus_t SensorRead(uint8_t slaveAddr, uint8_t highAddr,
 269:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 797              		.loc 1 269 0
 798              		.cfi_startproc
 799              		@ args = 4, pretend = 0, frame = 16
 800              		@ frame_needed = 0, uses_anonymous_args = 0
 801              	.LVL95:
 270:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 271:../sensor.c   **** 	CyU3PI2cPreamble_t preamble;
 272:../sensor.c   **** 
 273:../sensor.c   **** 	/* Validate the parameters. */
 274:../sensor.c   **** 	if ((slaveAddr != SENSOR_ADDR_RD) && (slaveAddr != I2C_MEMORY_ADDR_RD)) {
 802              		.loc 1 274 0
 803 04bc A10050E3 		cmp	r0, #161
 804 04c0 71005013 		cmpne	r0, #113
 269:../sensor.c   **** 		uint8_t lowAddr, uint8_t count, uint8_t *buf) {
 805              		.loc 1 269 0
 806 04c4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 807              	.LCFI12:
 808              		.cfi_def_cfa_offset 12
 809 04c8 00C0A0E1 		mov	ip, r0
 810 04cc 14D04DE2 		sub	sp, sp, #20
 811              	.LCFI13:
 812              		.cfi_def_cfa_offset 32
 813              		.loc 1 274 0
 814 04d0 00E0A003 		moveq	lr, #0
 815 04d4 01E0A013 		movne	lr, #1
 816              		.cfi_offset 14, -4
 817              		.cfi_offset 5, -8
 818              		.cfi_offset 4, -12
 819 04d8 1C00001A 		bne	.L58
 275:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 276:../sensor.c   **** 		return 1;
 277:../sensor.c   **** 	}
 278:../sensor.c   **** 	if (count > 64) {
 820              		.loc 1 278 0
 821 04dc 400053E3 		cmp	r3, #64
 822 04e0 1500008A 		bhi	.L59
 279:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 280:../sensor.c   **** 		return 1;
 281:../sensor.c   **** 	}
 282:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 283:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 284:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 285:../sensor.c   **** 	preamble.buffer[3] = slaveAddr;
 286:../sensor.c   **** 	preamble.length = 4;
 823              		.loc 1 286 0
 824 04e4 0440A0E3 		mov	r4, #4
 287:../sensor.c   **** 	preamble.ctrlMask = 0x0004; /*  Send start bit after third byte of preamble. */
 288:../sensor.c   **** 
 289:../sensor.c   **** 	apiRetStatus = CyU3PI2cReceiveBytes(&preamble, buf, count, 0);
 825              		.loc 1 289 0
 826 04e8 0320A0E1 		mov	r2, r3
 827              	.LVL96:
 828 04ec 0E30A0E1 		mov	r3, lr
 829              	.LVL97:
 283:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 830              		.loc 1 283 0
 831 04f0 55E0A0E3 		mov	lr, #85
 282:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 832              		.loc 1 282 0
 833 04f4 0150C0E3 		bic	r5, r0, #1
 283:../sensor.c   **** 	preamble.buffer[1] = 0x55;//highAddr;
 834              		.loc 1 283 0
 835 04f8 05E0CDE5 		strb	lr, [sp, #5]
 836              		.loc 1 289 0
 837 04fc 04008DE0 		add	r0, sp, r4
 838              	.LVL98:
 284:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 839              		.loc 1 284 0
 840 0500 55E0E0E3 		mvn	lr, #85
 841              		.loc 1 289 0
 842 0504 20109DE5 		ldr	r1, [sp, #32]
 843              	.LVL99:
 286:../sensor.c   **** 	preamble.length = 4;
 844              		.loc 1 286 0
 845 0508 0C40CDE5 		strb	r4, [sp, #12]
 287:../sensor.c   **** 	preamble.ctrlMask = 0x0004; /*  Send start bit after third byte of preamble. */
 846              		.loc 1 287 0
 847 050c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
 282:../sensor.c   **** 	preamble.buffer[0] = slaveAddr & I2C_SLAVEADDR_MASK; /*  Mask out the transfer type bit. */
 848              		.loc 1 282 0
 849 0510 0450CDE5 		strb	r5, [sp, #4]
 284:../sensor.c   **** 	preamble.buffer[2] = 0xaa;//lowAddr;
 850              		.loc 1 284 0
 851 0514 06E0CDE5 		strb	lr, [sp, #6]
 285:../sensor.c   **** 	preamble.buffer[3] = slaveAddr;
 852              		.loc 1 285 0
 853 0518 07C0CDE5 		strb	ip, [sp, #7]
 854              		.loc 1 289 0
 855 051c FEFFFFEB 		bl	CyU3PI2cReceiveBytes
 856              	.LVL100:
 857              	.LBB50:
 858              	.LBB51:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 859              		.loc 1 44 0
 860 0520 004050E2 		subs	r4, r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 861              		.loc 1 46 0
 862 0524 7D0EA003 		moveq	r0, #2000
 863              	.LVL101:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 864              		.loc 1 51 0
 865 0528 FA0FA013 		movne	r0, #1000
 866 052c FEFFFFEB 		bl	CyU3PBusyWait
 867              	.LVL102:
 868              	.L55:
 869              	.LBE51:
 870              	.LBE50:
 290:../sensor.c   **** 	SensorI2CAccessDelay(apiRetStatus);
 291:../sensor.c   **** 
 292:../sensor.c   **** 	return apiRetStatus;
 293:../sensor.c   **** }
 871              		.loc 1 293 0
 872 0530 0400A0E1 		mov	r0, r4
 873 0534 14D08DE2 		add	sp, sp, #20
 874 0538 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 875              	.LVL103:
 876              	.L59:
 279:../sensor.c   **** 		CyU3PDebugPrint(4, "ERROR: SensorWrite count > 64\n");
 877              		.loc 1 279 0
 878 053c 0400A0E3 		mov	r0, #4
 879              	.LVL104:
 880 0540 1C109FE5 		ldr	r1, .L60
 881              	.LVL105:
 882 0544 FEFFFFEB 		bl	CyU3PDebugPrint
 883              	.LVL106:
 280:../sensor.c   **** 		return 1;
 884              		.loc 1 280 0
 885 0548 0140A0E3 		mov	r4, #1
 886 054c F7FFFFEA 		b	.L55
 887              	.LVL107:
 888              	.L58:
 275:../sensor.c   **** 		CyU3PDebugPrint(4, "I2C Slave address is not valid!\n");
 889              		.loc 1 275 0
 890 0550 0400A0E3 		mov	r0, #4
 891              	.LVL108:
 892 0554 0C109FE5 		ldr	r1, .L60+4
 893              	.LVL109:
 894 0558 FEFFFFEB 		bl	CyU3PDebugPrint
 895              	.LVL110:
 276:../sensor.c   **** 		return 1;
 896              		.loc 1 276 0
 897 055c 0140A0E3 		mov	r4, #1
 898 0560 F2FFFFEA 		b	.L55
 899              	.L61:
 900              		.align	2
 901              	.L60:
 902 0564 7C000000 		.word	.LC4
 903 0568 38000000 		.word	.LC2
 904              		.cfi_endproc
 905              	.LFE6:
 907              		.align	2
 908              		.global	SensorReset
 910              	SensorReset:
 911              	.LFB7:
 294:../sensor.c   **** 
 295:../sensor.c   **** /*
 296:../sensor.c   ****  * Reset the image sensor using GPIO.
 297:../sensor.c   ****  */
 298:../sensor.c   **** void SensorReset(void) {
 912              		.loc 1 298 0
 913              		.cfi_startproc
 914              		@ args = 0, pretend = 0, frame = 0
 915              		@ frame_needed = 0, uses_anonymous_args = 0
 916 056c 10402DE9 		stmfd	sp!, {r4, lr}
 917              	.LCFI14:
 918              		.cfi_def_cfa_offset 8
 299:../sensor.c   **** 	CyU3PReturnStatus_t apiRetStatus;
 300:../sensor.c   **** 	uint16_t preTick, posTick;
 301:../sensor.c   **** 	/* Drive the GPIO low to reset the sensor. */
 302:../sensor.c   **** 	//apiRetStatus = CyU3PGpioSetValue(SENSOR_POWER_GPIO, CyFalse);
 303:../sensor.c   **** 	apiRetStatus = CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
 919              		.loc 1 303 0
 920 0570 1600A0E3 		mov	r0, #22
 921 0574 0010A0E3 		mov	r1, #0
 922              		.cfi_offset 14, -4
 923              		.cfi_offset 4, -8
 924 0578 FEFFFFEB 		bl	CyU3PGpioSetValue
 925              	.LVL111:
 304:../sensor.c   **** 	if (apiRetStatus != CY_U3P_SUCCESS) {
 926              		.loc 1 304 0
 927 057c 002050E2 		subs	r2, r0, #0
 928 0580 2200001A 		bne	.L64
 305:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 306:../sensor.c   **** 				apiRetStatus);
 307:../sensor.c   **** 		return;
 308:../sensor.c   **** 	}
 309:../sensor.c   **** 	CyU3PDebugPrint(4, "GPIO Set Value\r\n");
 929              		.loc 1 309 0
 930 0584 94109FE5 		ldr	r1, .L65
 931 0588 0400A0E3 		mov	r0, #4
 932              	.LVL112:
 933 058c FEFFFFEB 		bl	CyU3PDebugPrint
 934              	.LVL113:
 310:../sensor.c   **** 	/* Wait for some time to allow proper reset. */
 311:../sensor.c   **** 	uint8_t i = 0;
 312:../sensor.c   **** 	while (i++ < 2){
 313:../sensor.c   **** 		preTick = CyU3PGetTime();
 935              		.loc 1 313 0
 936 0590 FEFFFFEB 		bl	_tx_time_get
 937 0594 0040A0E1 		mov	r4, r0
 938              	.LVL114:
 314:../sensor.c   **** 		CyU3PThreadSleep(500);  // change the value into 100 from 10.
 939              		.loc 1 314 0
 940 0598 7D0FA0E3 		mov	r0, #500
 941              	.LVL115:
 942 059c FEFFFFEB 		bl	_tx_thread_sleep
 315:../sensor.c   **** 		posTick = CyU3PGetTime();
 943              		.loc 1 315 0
 944 05a0 FEFFFFEB 		bl	_tx_time_get
 945              	.LVL116:
 316:../sensor.c   **** 		CyU3PDebugPrint(4, "The ticks %d %d \r\n", preTick, posTick); //additional debug
 946              		.loc 1 316 0
 947 05a4 0448A0E1 		mov	r4, r4, asl #16
 948              	.LVL117:
 949 05a8 2428A0E1 		mov	r2, r4, lsr #16
 950 05ac 70109FE5 		ldr	r1, .L65+4
 951 05b0 0008A0E1 		mov	r0, r0, asl #16
 952              	.LVL118:
 953 05b4 2038A0E1 		mov	r3, r0, lsr #16
 954 05b8 0400A0E3 		mov	r0, #4
 955 05bc FEFFFFEB 		bl	CyU3PDebugPrint
 956              	.LVL119:
 313:../sensor.c   **** 		preTick = CyU3PGetTime();
 957              		.loc 1 313 0
 958 05c0 FEFFFFEB 		bl	_tx_time_get
 959 05c4 0040A0E1 		mov	r4, r0
 960              	.LVL120:
 314:../sensor.c   **** 		CyU3PThreadSleep(500);  // change the value into 100 from 10.
 961              		.loc 1 314 0
 962 05c8 7D0FA0E3 		mov	r0, #500
 963              	.LVL121:
 964 05cc FEFFFFEB 		bl	_tx_thread_sleep
 315:../sensor.c   **** 		posTick = CyU3PGetTime();
 965              		.loc 1 315 0
 966 05d0 FEFFFFEB 		bl	_tx_time_get
 967              	.LVL122:
 968              		.loc 1 316 0
 969 05d4 0428A0E1 		mov	r2, r4, asl #16
 970 05d8 2228A0E1 		mov	r2, r2, lsr #16
 971 05dc 40109FE5 		ldr	r1, .L65+4
 972 05e0 0038A0E1 		mov	r3, r0, asl #16
 973 05e4 2338A0E1 		mov	r3, r3, lsr #16
 974 05e8 0400A0E3 		mov	r0, #4
 975              	.LVL123:
 976 05ec FEFFFFEB 		bl	CyU3PDebugPrint
 977              	.LVL124:
 317:../sensor.c   **** 		//;//CyU3PDebugPrint(4, "cpu pause \r\n");
 318:../sensor.c   **** 	}
 319:../sensor.c   **** 
 320:../sensor.c   **** 	/* Drive the GPIO high to bring the sensor out of reset. */
 321:../sensor.c   **** 	//apiRetStatus = CyU3PGpioSetValue(SENSOR_POWER_GPIO, CyTrue);
 322:../sensor.c   **** 	apiRetStatus = CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
 978              		.loc 1 322 0
 979 05f0 1600A0E3 		mov	r0, #22
 980 05f4 0110A0E3 		mov	r1, #1
 981 05f8 FEFFFFEB 		bl	CyU3PGpioSetValue
 982              	.LVL125:
 323:../sensor.c   **** 	if (apiRetStatus != CY_U3P_SUCCESS) {
 983              		.loc 1 323 0
 984 05fc 002050E2 		subs	r2, r0, #0
 985 0600 0200001A 		bne	.L64
 986              	.LVL126:
 324:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 325:../sensor.c   **** 				apiRetStatus);
 326:../sensor.c   **** 		return;
 327:../sensor.c   **** 	}
 328:../sensor.c   **** /* pause the cpu */
 329:../sensor.c   **** 	while (i++ < 4){
 330:../sensor.c   **** 		CyU3PThreadSleep(600);  // change the value into 100 from 10.
 987              		.loc 1 330 0 discriminator 1
 988 0604 960FA0E3 		mov	r0, #600
 989              	.LVL127:
 331:../sensor.c   **** 		//;//CyU3PDebugPrint(4, "cpu pause \r\n");
 332:../sensor.c   **** 	}
 333:../sensor.c   **** 
 334:../sensor.c   **** 	return;
 335:../sensor.c   **** }
 990              		.loc 1 335 0 discriminator 1
 991 0608 1040BDE8 		ldmfd	sp!, {r4, lr}
 330:../sensor.c   **** 		CyU3PThreadSleep(600);  // change the value into 100 from 10.
 992              		.loc 1 330 0 discriminator 1
 993 060c FEFFFFEA 		b	_tx_thread_sleep
 994              	.LVL128:
 995              	.L64:
 324:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 996              		.loc 1 324 0
 997 0610 10109FE5 		ldr	r1, .L65+8
 998 0614 0400A0E3 		mov	r0, #4
 999              	.LVL129:
 1000              		.loc 1 335 0
 1001 0618 1040BDE8 		ldmfd	sp!, {r4, lr}
 324:../sensor.c   **** 		CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n",
 1002              		.loc 1 324 0
 1003 061c FEFFFFEA 		b	CyU3PDebugPrint
 1004              	.LVL130:
 1005              	.L66:
 1006              		.align	2
 1007              	.L65:
 1008 0620 C4000000 		.word	.LC6
 1009 0624 D8000000 		.word	.LC7
 1010 0628 9C000000 		.word	.LC5
 1011              		.cfi_endproc
 1012              	.LFE7:
 1014              		.align	2
 1015              		.global	SensorInit
 1017              	SensorInit:
 1018              	.LFB8:
 336:../sensor.c   **** 
 337:../sensor.c   **** /* Image sensor initialization sequence. */
 338:../sensor.c   **** void SensorInit(void) {
 1019              		.loc 1 338 0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 8
 1022              		@ frame_needed = 0, uses_anonymous_args = 0
 1023 062c 04E02DE5 		str	lr, [sp, #-4]!
 1024              	.LCFI15:
 1025              		.cfi_def_cfa_offset 4
 1026 0630 0CD04DE2 		sub	sp, sp, #12
 1027              	.LCFI16:
 1028              		.cfi_def_cfa_offset 16
 1029              	.LBB54:
 1030              	.LBB55:
 339:../sensor.c   **** 	if (SensorI2cBusTest() != CY_U3P_SUCCESS) /* Verify that the sensor is connected. */
 340:../sensor.c   **** 	{
 341:../sensor.c   **** 		CyU3PDebugPrint(4, "Error: Reading Sensor ID failed!\r\n");
 342:../sensor.c   **** 		return;
 343:../sensor.c   **** 	}
 344:../sensor.c   **** 
 345:../sensor.c   **** 	/* Generic settings (which are common for all resolutions) for bringing up the image sensor to str
 346:../sensor.c   **** 	 video data should be populated here.
 347:../sensor.c   **** 	 */
 348:../sensor.c   **** 
 349:../sensor.c   **** 	/* Update sensor configuration based on desired video stream parameters. Using 720p 30fps as defau
 350:../sensor.c   **** 	//SensorScaling_HD720p_30fps();
 351:../sensor.c   **** }
 352:../sensor.c   **** 
 353:../sensor.c   **** /*
 354:../sensor.c   ****    Verify that the sensor can be accessed over the I2C bus from FX3.
 355:../sensor.c   ****  */
 356:../sensor.c   **** uint8_t SensorI2cBusTest(void) {
 357:../sensor.c   **** 	/* The sensor ID register can be read here to verify sensor connectivity. */
 358:../sensor.c   **** 	uint8_t buf[2];
 359:../sensor.c   **** 
 360:../sensor.c   **** 	/* Reading sensor ID */
 361:../sensor.c   **** 	if (SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_WR, I2C_EAGLESDP_ADDR, 0xf2, buf) == CY_U3P_SUC
 1031              		.loc 1 361 0
 1032 0634 5200A0E3 		mov	r0, #82
 1033 0638 3010A0E3 		mov	r1, #48
 1034 063c F220A0E3 		mov	r2, #242
 1035 0640 04308DE2 		add	r3, sp, #4
 1036              		.cfi_offset 14, -4
 1037 0644 6DFEFFEB 		bl	SensorRead2B.clone.1
 1038 0648 000050E3 		cmp	r0, #0
 1039 064c 0200001A 		bne	.L68
 362:../sensor.c   **** 		if ((buf[0] == 0x56) /*&& (buf[1] == 0x02)*/) {
 1040              		.loc 1 362 0
 1041 0650 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1042 0654 560053E3 		cmp	r3, #86
 1043 0658 0200000A 		beq	.L67
 1044              	.L68:
 1045              	.LBE55:
 1046              	.LBE54:
 341:../sensor.c   **** 		CyU3PDebugPrint(4, "Error: Reading Sensor ID failed!\r\n");
 1047              		.loc 1 341 0
 1048 065c 0400A0E3 		mov	r0, #4
 1049 0660 08109FE5 		ldr	r1, .L70
 1050 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 1051              	.L67:
 351:../sensor.c   **** }
 1052              		.loc 1 351 0
 1053 0668 0CD08DE2 		add	sp, sp, #12
 1054 066c 04F09DE4 		ldmfd	sp!, {pc}
 1055              	.L71:
 1056              		.align	2
 1057              	.L70:
 1058 0670 EC000000 		.word	.LC8
 1059              		.cfi_endproc
 1060              	.LFE8:
 1062              		.align	2
 1063              		.global	SensorI2cBusTest
 1065              	SensorI2cBusTest:
 1066              	.LFB9:
 356:../sensor.c   **** uint8_t SensorI2cBusTest(void) {
 1067              		.loc 1 356 0
 1068              		.cfi_startproc
 1069              		@ args = 0, pretend = 0, frame = 8
 1070              		@ frame_needed = 0, uses_anonymous_args = 0
 1071 0674 04E02DE5 		str	lr, [sp, #-4]!
 1072              	.LCFI17:
 1073              		.cfi_def_cfa_offset 4
 1074 0678 0CD04DE2 		sub	sp, sp, #12
 1075              	.LCFI18:
 1076              		.cfi_def_cfa_offset 16
 361:../sensor.c   **** 	if (SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_WR, I2C_EAGLESDP_ADDR, 0xf2, buf) == CY_U3P_SUC
 1077              		.loc 1 361 0
 1078 067c 5200A0E3 		mov	r0, #82
 1079 0680 3010A0E3 		mov	r1, #48
 1080 0684 F220A0E3 		mov	r2, #242
 1081 0688 04308DE2 		add	r3, sp, #4
 1082              		.cfi_offset 14, -4
 1083 068c 5BFEFFEB 		bl	SensorRead2B.clone.1
 1084 0690 000050E3 		cmp	r0, #0
 363:../sensor.c   **** 			return CY_U3P_SUCCESS;
 364:../sensor.c   **** 		}
 365:../sensor.c   **** 	}
 366:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 367:../sensor.c   **** 	CyU3PDebugPrint (4, "The Sensor test 0x%x 0x%x\r\n", buf[0], buf[1]); // additional debug
 368:../sensor.c   **** #endif
 369:../sensor.c   **** 	return 1;
 1085              		.loc 1 369 0
 1086 0694 0100A013 		movne	r0, #1
 361:../sensor.c   **** 	if (SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_WR, I2C_EAGLESDP_ADDR, 0xf2, buf) == CY_U3P_SUC
 1087              		.loc 1 361 0
 1088 0698 0200001A 		bne	.L73
 356:../sensor.c   **** uint8_t SensorI2cBusTest(void) {
 1089              		.loc 1 356 0
 1090 069c 0400DDE5 		ldrb	r0, [sp, #4]	@ zero_extendqisi2
 363:../sensor.c   **** 			return CY_U3P_SUCCESS;
 1091              		.loc 1 363 0
 1092 06a0 560050E2 		subs	r0, r0, #86
 1093 06a4 0100A013 		movne	r0, #1
 1094              	.L73:
 370:../sensor.c   **** }
 1095              		.loc 1 370 0
 1096 06a8 0CD08DE2 		add	sp, sp, #12
 1097 06ac 04F09DE4 		ldmfd	sp!, {pc}
 1098              		.cfi_endproc
 1099              	.LFE9:
 1101              		.align	2
 1102              		.global	SensorGetControl
 1104              	SensorGetControl:
 1105              	.LFB10:
 371:../sensor.c   **** 
 372:../sensor.c   **** /*************************************************************
 373:../sensor.c   ****  *  the modularized control get routine. IDext is the control ID.
 374:../sensor.c   ****  *
 375:../sensor.c   ****  * ********************************************************* */
 376:../sensor.c   **** 
 377:../sensor.c   **** uint8_t SensorGetControl(uint8_t IDext, uint8_t devAdd)  //for register w/r, the IDext is Reg. addr
 378:../sensor.c   **** {
 1106              		.loc 1 378 0
 1107              		.cfi_startproc
 1108              		@ args = 0, pretend = 0, frame = 8
 1109              		@ frame_needed = 0, uses_anonymous_args = 0
 1110              	.LVL131:
 1111 06b0 10402DE9 		stmfd	sp!, {r4, lr}
 1112              	.LCFI19:
 1113              		.cfi_def_cfa_offset 8
 1114 06b4 08D04DE2 		sub	sp, sp, #8
 1115              	.LCFI20:
 1116              		.cfi_def_cfa_offset 16
 1117              		.loc 1 378 0
 1118 06b8 0040A0E1 		mov	r4, r0
 1119              		.cfi_offset 14, -4
 1120              		.cfi_offset 4, -8
 379:../sensor.c   **** 	uint8_t buf[2];
 380:../sensor.c   **** 	SensorRead2B(SENSOR_ADDR_RD, I2C_DSPBOARD_ADDR_RD, devAdd, IDext, buf);
 1121              		.loc 1 380 0
 1122 06bc 0020A0E1 		mov	r2, r0
 1123 06c0 04308DE2 		add	r3, sp, #4
 1124 06c4 5300A0E3 		mov	r0, #83
 1125              	.LVL132:
 1126 06c8 4CFEFFEB 		bl	SensorRead2B.clone.1
 1127              	.LVL133:
 381:../sensor.c   **** //#ifdef USB_DEBUG_PRINT
 382:../sensor.c   **** 	CyU3PDebugPrint (4, "The Get control ID 0x%x %d\r\n", IDext, buf[0]); // additional debug
 1128              		.loc 1 382 0
 1129 06cc 18109FE5 		ldr	r1, .L76
 1130 06d0 0420A0E1 		mov	r2, r4
 1131 06d4 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 1132 06d8 0400A0E3 		mov	r0, #4
 1133 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 383:../sensor.c   **** //#endif
 384:../sensor.c   **** 	return buf[0];
 385:../sensor.c   **** };
 1134              		.loc 1 385 0
 1135 06e0 0400DDE5 		ldrb	r0, [sp, #4]	@ zero_extendqisi2
 1136 06e4 08D08DE2 		add	sp, sp, #8
 1137 06e8 1080BDE8 		ldmfd	sp!, {r4, pc}
 1138              	.L77:
 1139              		.align	2
 1140              	.L76:
 1141 06ec 10010000 		.word	.LC9
 1142              		.cfi_endproc
 1143              	.LFE10:
 1145              		.align	2
 1146              		.global	SensorSetControl
 1148              	SensorSetControl:
 1149              	.LFB11:
 386:../sensor.c   **** 
 387:../sensor.c   **** /* *********************************************************
 388:../sensor.c   ****  * the modularized control Set routine. IDuvc: the control ID;
 389:../sensor.c   ****  * value: set value, range check.
 390:../sensor.c   ****  *
 391:../sensor.c   ****  ************************************************************ */
 392:../sensor.c   **** 
 393:../sensor.c   **** uint8_t SensorSetControl(uint8_t IDext, uint8_t devAdd, uint8_t value) //for register w/r, the IDex
 394:../sensor.c   **** {
 1150              		.loc 1 394 0
 1151              		.cfi_startproc
 1152              		@ args = 0, pretend = 0, frame = 16
 1153              		@ frame_needed = 0, uses_anonymous_args = 0
 1154              	.LVL134:
 1155 06f0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 1156              	.LCFI21:
 1157              		.cfi_def_cfa_offset 12
 1158              	.LBB62:
 1159              	.LBB64:
  73:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 1160              		.loc 1 73 0
 1161 06f4 52C0A0E3 		mov	ip, #82
 1162              	.LBE64:
 1163              	.LBE62:
 1164              		.loc 1 394 0
 1165 06f8 14D04DE2 		sub	sp, sp, #20
 1166              	.LCFI22:
 1167              		.cfi_def_cfa_offset 32
 1168              	.LBB70:
 1169              	.LBB63:
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 1170              		.loc 1 72 0
 1171 06fc 70E0A0E3 		mov	lr, #112
 1172              		.cfi_offset 14, -4
 1173              		.cfi_offset 5, -8
 1174              		.cfi_offset 4, -12
 1175              	.LBE63:
 1176              	.LBE70:
 1177              		.loc 1 394 0
 1178 0700 0040A0E1 		mov	r4, r0
 1179              	.LVL135:
 1180 0704 0250A0E1 		mov	r5, r2
 1181              	.LVL136:
 1182              	.LBB71:
 1183              	.LBB69:
  74:../sensor.c   **** 	preamble.buffer[2] = lowAddr;
 1184              		.loc 1 74 0
 1185 0708 0210CDE5 		strb	r1, [sp, #2]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1186              		.loc 1 79 0
 1187 070c 0120A0E3 		mov	r2, #1
 1188              	.LVL137:
 1189 0710 0C108DE2 		add	r1, sp, #12
 1190              	.LVL138:
 1191 0714 0030A0E3 		mov	r3, #0
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 1192              		.loc 1 72 0
 1193 0718 00E0CDE5 		strb	lr, [sp, #0]
  73:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 1194              		.loc 1 73 0
 1195 071c 01C0CDE5 		strb	ip, [sp, #1]
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1196              		.loc 1 75 0
 1197 0720 00E0A0E3 		mov	lr, #0	@ movhi
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1198              		.loc 1 76 0
 1199 0724 03C0A0E3 		mov	ip, #3
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1200              		.loc 1 79 0
 1201 0728 0D00A0E1 		mov	r0, sp
 1202              	.LVL139:
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1203              		.loc 1 75 0
 1204 072c BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1205              		.loc 1 76 0
 1206 0730 08C0CDE5 		strb	ip, [sp, #8]
  77:../sensor.c   **** 	buf[0] = highData;
 1207              		.loc 1 77 0
 1208 0734 0C40CDE5 		strb	r4, [sp, #12]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1209              		.loc 1 79 0
 1210 0738 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1211              	.LVL140:
 1212              	.LBB65:
 1213              	.LBB66:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 1214              		.loc 1 44 0
 1215 073c 000050E3 		cmp	r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 1216              		.loc 1 46 0
 1217 0740 7D0EA003 		moveq	r0, #2000
 1218              	.LVL141:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 1219              		.loc 1 51 0
 1220 0744 FA0FA013 		movne	r0, #1000
 1221 0748 FEFFFFEB 		bl	CyU3PBusyWait
 1222              	.LBE66:
 1223              	.LBE65:
  87:../sensor.c   **** 	preamble.length = 1;
 1224              		.loc 1 87 0
 1225 074c 01C0A0E3 		mov	ip, #1
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1226              		.loc 1 88 0
 1227 0750 0C20A0E1 		mov	r2, ip
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1228              		.loc 1 86 0
 1229 0754 00E0A0E3 		mov	lr, #0	@ movhi
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1230              		.loc 1 88 0
 1231 0758 0C108DE2 		add	r1, sp, #12
 1232 075c 0030A0E3 		mov	r3, #0
 1233 0760 0D00A0E1 		mov	r0, sp
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1234              		.loc 1 86 0
 1235 0764 BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  87:../sensor.c   **** 	preamble.length = 1;
 1236              		.loc 1 87 0
 1237 0768 08C0CDE5 		strb	ip, [sp, #8]
  85:../sensor.c   **** 	buf[0] = lowData;								/****************** data block *****************************************/
 1238              		.loc 1 85 0
 1239 076c 0C50CDE5 		strb	r5, [sp, #12]
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1240              		.loc 1 88 0
 1241 0770 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1242              	.LVL142:
 1243              	.LBB67:
 1244              	.LBB68:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 1245              		.loc 1 44 0
 1246 0774 000050E3 		cmp	r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 1247              		.loc 1 46 0
 1248 0778 7D0EA003 		moveq	r0, #2000
 1249              	.LVL143:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 1250              		.loc 1 51 0
 1251 077c FA0FA013 		movne	r0, #1000
 1252 0780 FEFFFFEB 		bl	CyU3PBusyWait
 1253              	.LBE68:
 1254              	.LBE67:
 1255              	.LBE69:
 1256              	.LBE71:
 395:../sensor.c   **** 	SensorWrite2B(SENSOR_ADDR_WR, I2C_DSPBOARD_ADDR_WR, devAdd, IDext, value);
 396:../sensor.c   **** //#ifdef USB_DEBUG_PRINT
 397:../sensor.c   **** 	CyU3PDebugPrint (4, "The Set control regAdd 0x%x 0x%x\r\n", IDext, value); // additional debug
 1257              		.loc 1 397 0
 1258 0784 18109FE5 		ldr	r1, .L83
 1259 0788 0420A0E1 		mov	r2, r4
 1260 078c 0530A0E1 		mov	r3, r5
 1261 0790 0400A0E3 		mov	r0, #4
 1262 0794 FEFFFFEB 		bl	CyU3PDebugPrint
 398:../sensor.c   **** //#endif
 399:../sensor.c   **** 	return 0;
 400:../sensor.c   **** };
 1263              		.loc 1 400 0
 1264 0798 0000A0E3 		mov	r0, #0
 1265 079c 14D08DE2 		add	sp, sp, #20
 1266 07a0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1267              	.L84:
 1268              		.align	2
 1269              	.L83:
 1270 07a4 30010000 		.word	.LC10
 1271              		.cfi_endproc
 1272              	.LFE11:
 1274              		.align	2
 1275              		.global	SensorGetIrisControl
 1277              	SensorGetIrisControl:
 1278              	.LFB12:
 401:../sensor.c   **** /*************************************************************
 402:../sensor.c   ****  *  the Iris control get routine. IDext is the control ID, boardID: the Iris control board address.
 403:../sensor.c   ****  *
 404:../sensor.c   ****  * ********************************************************* */
 405:../sensor.c   **** 
 406:../sensor.c   **** uint8_t SensorGetIrisControl(uint8_t IDext, uint8_t devAdd, uint8_t boardID)  //for register w/r, t
 407:../sensor.c   **** {
 1279              		.loc 1 407 0
 1280              		.cfi_startproc
 1281              		@ args = 0, pretend = 0, frame = 8
 1282              		@ frame_needed = 0, uses_anonymous_args = 0
 1283              	.LVL144:
 1284 07a8 00C0A0E1 		mov	ip, r0
 1285 07ac 04E02DE5 		str	lr, [sp, #-4]!
 1286              	.LCFI23:
 1287              		.cfi_def_cfa_offset 4
 1288 07b0 0CD04DE2 		sub	sp, sp, #12
 1289              	.LCFI24:
 1290              		.cfi_def_cfa_offset 16
 408:../sensor.c   **** 	uint8_t buf[2];
 409:../sensor.c   **** 	SensorRead2B(SENSOR_ADDR_RD, boardID, devAdd, IDext, buf);
 1291              		.loc 1 409 0
 1292 07b4 04308DE2 		add	r3, sp, #4
 1293 07b8 0200A0E1 		mov	r0, r2
 1294              	.LVL145:
 1295 07bc 0C20A0E1 		mov	r2, ip
 1296              	.LVL146:
 1297              		.cfi_offset 14, -4
 1298 07c0 0EFEFFEB 		bl	SensorRead2B.clone.1
 1299              	.LVL147:
 410:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 411:../sensor.c   **** 	CyU3PDebugPrint (4, "The Get control ID 0x%x 0x%x %d\r\n", boardID, IDext, buf[0]); // additional 
 412:../sensor.c   **** #endif
 413:../sensor.c   **** 	return buf[0];
 414:../sensor.c   **** };
 1300              		.loc 1 414 0
 1301 07c4 0400DDE5 		ldrb	r0, [sp, #4]	@ zero_extendqisi2
 1302 07c8 0CD08DE2 		add	sp, sp, #12
 1303 07cc 04F09DE4 		ldmfd	sp!, {pc}
 1304              		.cfi_endproc
 1305              	.LFE12:
 1307              		.align	2
 1308              		.global	SensorSetIrisControl
 1310              	SensorSetIrisControl:
 1311              	.LFB13:
 415:../sensor.c   **** 
 416:../sensor.c   **** /* *********************************************************
 417:../sensor.c   ****  * the Iris control Set routine. IDuvc: the control ID, boardID: the Iris control board address;
 418:../sensor.c   ****  * value: set value, range check.
 419:../sensor.c   ****  *
 420:../sensor.c   ****  ************************************************************ */
 421:../sensor.c   **** 
 422:../sensor.c   **** uint8_t SensorSetIrisControl(uint8_t IDext, uint8_t devAdd, uint8_t value, uint8_t boardID) //for r
 423:../sensor.c   **** {
 1312              		.loc 1 423 0
 1313              		.cfi_startproc
 1314              		@ args = 0, pretend = 0, frame = 16
 1315              		@ frame_needed = 0, uses_anonymous_args = 0
 1316              	.LVL148:
 1317 07d0 10402DE9 		stmfd	sp!, {r4, lr}
 1318              	.LCFI25:
 1319              		.cfi_def_cfa_offset 8
 1320              	.LBB78:
 1321              	.LBB80:
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 1322              		.loc 1 72 0
 1323 07d4 70C0A0E3 		mov	ip, #112
 1324              	.LBE80:
 1325              	.LBE78:
 1326              		.loc 1 423 0
 1327 07d8 10D04DE2 		sub	sp, sp, #16
 1328              	.LCFI26:
 1329              		.cfi_def_cfa_offset 24
 1330              	.LBB86:
 1331              	.LBB79:
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1332              		.loc 1 75 0
 1333 07dc 00E0A0E3 		mov	lr, #0	@ movhi
 1334              		.cfi_offset 14, -4
 1335              		.cfi_offset 4, -8
  73:../sensor.c   **** 	preamble.buffer[1] = highAddr;
 1336              		.loc 1 73 0
 1337 07e0 0130CDE5 		strb	r3, [sp, #1]
  74:../sensor.c   **** 	preamble.buffer[2] = lowAddr;
 1338              		.loc 1 74 0
 1339 07e4 0210CDE5 		strb	r1, [sp, #2]
  77:../sensor.c   **** 	buf[0] = highData;
 1340              		.loc 1 77 0
 1341 07e8 0C00CDE5 		strb	r0, [sp, #12]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1342              		.loc 1 79 0
 1343 07ec 0C108DE2 		add	r1, sp, #12
 1344              	.LVL149:
 1345              	.LBE79:
 1346              	.LBE86:
 1347              		.loc 1 423 0
 1348 07f0 0240A0E1 		mov	r4, r2
 1349              	.LVL150:
 1350              	.LBB87:
 1351              	.LBB85:
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1352              		.loc 1 79 0
 1353 07f4 0030A0E3 		mov	r3, #0
 1354              	.LVL151:
 1355 07f8 0120A0E3 		mov	r2, #1
 1356              	.LVL152:
  72:../sensor.c   **** 	preamble.buffer[0] = slaveAddr;						/************** command block *******************************
 1357              		.loc 1 72 0
 1358 07fc 00C0CDE5 		strb	ip, [sp, #0]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1359              		.loc 1 79 0
 1360 0800 0D00A0E1 		mov	r0, sp
 1361              	.LVL153:
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1362              		.loc 1 76 0
 1363 0804 03C0A0E3 		mov	ip, #3
  75:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1364              		.loc 1 75 0
 1365 0808 BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  76:../sensor.c   **** 	preamble.length = 3; /*  Three byte preamble. */
 1366              		.loc 1 76 0
 1367 080c 08C0CDE5 		strb	ip, [sp, #8]
  79:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1368              		.loc 1 79 0
 1369 0810 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1370              	.LVL154:
 1371              	.LBB81:
 1372              	.LBB82:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 1373              		.loc 1 44 0
 1374 0814 000050E3 		cmp	r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 1375              		.loc 1 46 0
 1376 0818 7D0EA003 		moveq	r0, #2000
 1377              	.LVL155:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 1378              		.loc 1 51 0
 1379 081c FA0FA013 		movne	r0, #1000
 1380 0820 FEFFFFEB 		bl	CyU3PBusyWait
 1381              	.LBE82:
 1382              	.LBE81:
  87:../sensor.c   **** 	preamble.length = 1;
 1383              		.loc 1 87 0
 1384 0824 01C0A0E3 		mov	ip, #1
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1385              		.loc 1 86 0
 1386 0828 00E0A0E3 		mov	lr, #0	@ movhi
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1387              		.loc 1 88 0
 1388 082c 0C108DE2 		add	r1, sp, #12
 1389 0830 0C20A0E1 		mov	r2, ip
 1390 0834 0030A0E3 		mov	r3, #0
 1391 0838 0D00A0E1 		mov	r0, sp
  86:../sensor.c   **** 	preamble.ctrlMask = 0x0000;
 1392              		.loc 1 86 0
 1393 083c BAE0CDE1 		strh	lr, [sp, #10]	@ movhi
  87:../sensor.c   **** 	preamble.length = 1;
 1394              		.loc 1 87 0
 1395 0840 08C0CDE5 		strb	ip, [sp, #8]
  85:../sensor.c   **** 	buf[0] = lowData;								/****************** data block *****************************************/
 1396              		.loc 1 85 0
 1397 0844 0C40CDE5 		strb	r4, [sp, #12]
  88:../sensor.c   **** 	apiRetStatus = CyU3PI2cTransmitBytes(&preamble, buf, 1, 0);
 1398              		.loc 1 88 0
 1399 0848 FEFFFFEB 		bl	CyU3PI2cTransmitBytes
 1400              	.LVL156:
 1401              	.LBB83:
 1402              	.LBB84:
  44:../sensor.c   **** 	if (status == CY_U3P_SUCCESS)
 1403              		.loc 1 44 0
 1404 084c 000050E3 		cmp	r0, #0
  46:../sensor.c   **** 		CyU3PBusyWait(2000); //change into 100us.
 1405              		.loc 1 46 0
 1406 0850 7D0EA003 		moveq	r0, #2000
 1407              	.LVL157:
  51:../sensor.c   **** 		CyU3PBusyWait(1000);
 1408              		.loc 1 51 0
 1409 0854 FA0FA013 		movne	r0, #1000
 1410 0858 FEFFFFEB 		bl	CyU3PBusyWait
 1411              	.LBE84:
 1412              	.LBE83:
 1413              	.LBE85:
 1414              	.LBE87:
 424:../sensor.c   **** 	SensorWrite2B(SENSOR_ADDR_WR, boardID, devAdd, IDext, value);
 425:../sensor.c   **** #ifdef USB_DEBUG_PRINT
 426:../sensor.c   **** 	CyU3PDebugPrint (4, "The Set control ID 0x%x 0x%x 0x%x\r\n", boardID, IDext, value); // additional
 427:../sensor.c   **** #endif
 428:../sensor.c   **** 	return 0;
 429:../sensor.c   **** };
 1415              		.loc 1 429 0
 1416 085c 0000A0E3 		mov	r0, #0
 1417 0860 10D08DE2 		add	sp, sp, #16
 1418 0864 1080BDE8 		ldmfd	sp!, {r4, pc}
 1419              		.cfi_endproc
 1420              	.LFE13:
 1422              		.section	.rodata.str1.4,"aMS",%progbits,1
 1423              		.align	2
 1424              	.LC0:
 1425 0000 73656E73 		.ascii	"sensor read2B(T) %d %d %d\015\012\000"
 1425      6F722072 
 1425      65616432 
 1425      42285429 
 1425      20256420 
 1426              	.LC1:
 1427 001c 73656E73 		.ascii	"sensor read2B(R) %d %d %d\015\012\000"
 1427      6F722072 
 1427      65616432 
 1427      42285229 
 1427      20256420 
 1428              	.LC2:
 1429 0038 49324320 		.ascii	"I2C Slave address is not valid!\012\000"
 1429      536C6176 
 1429      65206164 
 1429      64726573 
 1429      73206973 
 1430 0059 000000   		.space	3
 1431              	.LC3:
 1432 005c 73656E73 		.ascii	"sensor write2B(0) %d %d %d\015\012\000"
 1432      6F722077 
 1432      72697465 
 1432      32422830 
 1432      29202564 
 1433 0079 000000   		.space	3
 1434              	.LC4:
 1435 007c 4552524F 		.ascii	"ERROR: SensorWrite count > 64\012\000"
 1435      523A2053 
 1435      656E736F 
 1435      72577269 
 1435      74652063 
 1436 009b 00       		.space	1
 1437              	.LC5:
 1438 009c 4750494F 		.ascii	"GPIO Set Value Error, Error Code = %d\012\000"
 1438      20536574 
 1438      2056616C 
 1438      75652045 
 1438      72726F72 
 1439 00c3 00       		.space	1
 1440              	.LC6:
 1441 00c4 4750494F 		.ascii	"GPIO Set Value\015\012\000"
 1441      20536574 
 1441      2056616C 
 1441      75650D0A 
 1441      00
 1442 00d5 000000   		.space	3
 1443              	.LC7:
 1444 00d8 54686520 		.ascii	"The ticks %d %d \015\012\000"
 1444      7469636B 
 1444      73202564 
 1444      20256420 
 1444      0D0A00
 1445 00eb 00       		.space	1
 1446              	.LC8:
 1447 00ec 4572726F 		.ascii	"Error: Reading Sensor ID failed!\015\012\000"
 1447      723A2052 
 1447      65616469 
 1447      6E672053 
 1447      656E736F 
 1448 010f 00       		.space	1
 1449              	.LC9:
 1450 0110 54686520 		.ascii	"The Get control ID 0x%x %d\015\012\000"
 1450      47657420 
 1450      636F6E74 
 1450      726F6C20 
 1450      49442030 
 1451 012d 000000   		.space	3
 1452              	.LC10:
 1453 0130 54686520 		.ascii	"The Set control regAdd 0x%x 0x%x\015\012\000"
 1453      53657420 
 1453      636F6E74 
 1453      726F6C20 
 1453      72656741 
 1454 0153 00       		.text
 1455              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 sensor.c
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:23     .text:00000000 SensorRead2B.clone.1
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:163    .text:000000e8 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:170    .text:000000f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:173    .text:000000f0 SensorWrite2B
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:297    .text:000001b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:301    .text:000001bc $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:304    .text:000001bc SensorWrite2B2
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:382    .text:00000234 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:386    .text:00000238 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:389    .text:00000238 SensorWrite
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:490    .text:000002d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:495    .text:000002e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:498    .text:000002e0 SensorRead2B
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:664    .text:000003f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:672    .text:00000400 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:675    .text:00000400 SensorRead2B2
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:785    .text:000004b4 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:792    .text:000004bc $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:795    .text:000004bc SensorRead
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:902    .text:00000564 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:907    .text:0000056c $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:910    .text:0000056c SensorReset
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1008   .text:00000620 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1014   .text:0000062c $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1017   .text:0000062c SensorInit
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1058   .text:00000670 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1062   .text:00000674 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1065   .text:00000674 SensorI2cBusTest
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1104   .text:000006b0 SensorGetControl
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1141   .text:000006ec $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1145   .text:000006f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1148   .text:000006f0 SensorSetControl
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1270   .text:000007a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1274   .text:000007a8 $a
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1277   .text:000007a8 SensorGetIrisControl
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1310   .text:000007d0 SensorSetIrisControl
C:\Users\wcheng\AppData\Local\Temp\ccBeMb5N.s:1423   .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PI2cTransmitBytes
CyU3PBusyWait
CyU3PI2cReceiveBytes
CyU3PDebugPrint
CyU3PGpioSetValue
_tx_time_get
_tx_thread_sleep
