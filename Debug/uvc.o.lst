   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB19:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      **** CyBool_t        streamingRecove = CyFalse;              /* start streaming again */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static CyBool_t stream_start = CyFalse;
 214:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 215:../uvc.c      ****                                                            the current video frame. */
 216:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 217:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 218:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 219:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 220:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 221:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 222:../uvc.c      **** 
 223:../uvc.c      **** /************ control parameters array ***********
 224:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 225:../uvc.c      ****  *    e.g.
 226:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 227:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 228:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 229:../uvc.c      ****  **************************************************/
 230:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 231:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 232:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 233:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 234:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 236:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 237:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 238:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 239:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 240:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 241:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 244:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 245:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 249:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 254:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 256:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 258:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 259:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 260:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 261:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 262:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 264:../uvc.c      **** 		/**********************************
 265:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 266:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 267:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 268:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 269:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 270:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 271:../uvc.c      **** 		 *
 272:../uvc.c      **** 		 *********************************/
 273:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 274:../uvc.c      **** };
 275:../uvc.c      **** #if 1 // the new control structure
 276:../uvc.c      **** /* the processing unit control request */
 277:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 278:../uvc.c      **** 
 279:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 280:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 281:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 282:../uvc.c      **** 		 2,					//UVCLn: the command length
 283:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 284:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 285:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 286:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 287:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 288:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 289:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 290:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 291:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 292:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 293:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 294:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 295:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 296:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 297:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 298:../uvc.c      **** 		}; //
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 301:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 302:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 303:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 304:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 305:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 306:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 307:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 308:../uvc.c      **** 		 2,					//UVCLn: the command length
 309:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 310:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 311:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 312:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 313:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 314:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 315:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 316:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 317:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 318:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 319:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 320:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 321:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 322:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 323:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 324:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 325:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 326:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 327:../uvc.c      **** 
 328:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 329:../uvc.c      **** 	&PUCBLC,
 330:../uvc.c      **** 	0, //&PUCBright,
 331:../uvc.c      **** 	0, //&PUCContrast,
 332:../uvc.c      **** 	0, //&PUCGain (AGC?)
 333:../uvc.c      **** 	0, //&PUCPLFreq,
 334:../uvc.c      **** 	0, //&PUCHueC,
 335:../uvc.c      **** 	0, //&PUCSaturation,
 336:../uvc.c      **** 	&PUCSharp,
 337:../uvc.c      **** 	0, //&PUCGamGain,
 338:../uvc.c      **** 	0, //&PUCWBMd,
 339:../uvc.c      **** 	0, //UVCCtlID10,
 340:../uvc.c      **** 	0, //&PUCWBLC,
 341:../uvc.c      **** 	0, //UVCCtlID12,
 342:../uvc.c      **** 	0, //UVCCtlID13,
 343:../uvc.c      **** 	0, //&PUCDZoom,
 344:../uvc.c      **** 	0 //UVCCtlID15
 345:../uvc.c      **** };
 346:../uvc.c      **** 
 347:../uvc.c      **** /* the Camera terminal control request */
 348:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 349:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 350:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 351:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 352:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 353:../uvc.c      **** 
 354:../uvc.c      **** /* the Extentsion control request */
 355:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 356:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 357:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 358:../uvc.c      **** 		 2,					//UVCLn: the command length
 359:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 360:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 361:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 362:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 363:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 364:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 365:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 366:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 367:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 368:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 369:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 370:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 371:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 372:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 373:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 374:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 375:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 376:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 377:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 378:../uvc.c      **** 		 2,					//UVCLn: the command length
 379:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 380:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 381:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 382:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 383:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 384:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 385:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 386:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 387:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 388:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 389:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 390:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 391:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 392:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 393:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 394:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 395:../uvc.c      **** */
 396:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 397:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 398:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 399:../uvc.c      **** 		 2,					//UVCLn: the command length
 400:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 401:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 402:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 403:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 404:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 405:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 406:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 407:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 408:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 409:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 410:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 411:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 412:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 413:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 414:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 415:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 416:../uvc.c      **** */
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 418:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 421:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 422:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 423:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 424:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 425:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 426:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 427:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 428:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 429:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 430:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 431:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 432:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 433:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 434:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 435:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 436:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 437:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 438:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 439:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 440:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 441:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 442:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 443:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 444:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 445:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 447:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 448:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 449:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 450:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 451:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 452:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 453:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 454:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 456:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 457:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 458:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 459:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 460:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 461:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 462:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 464:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 465:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 466:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 467:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 468:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 469:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 470:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 471:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 472:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 473:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 474:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 475:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 476:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 477:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 478:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 479:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 480:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 481:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 482:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 483:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 484:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 485:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 486:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 487:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 488:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 489:../uvc.c      **** 		}; //
 490:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 491:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 492:../uvc.c      **** 
 493:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 494:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 495:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 496:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 497:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 498:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 499:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 500:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 501:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 502:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 503:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 504:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 505:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 506:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 507:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 508:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 509:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 510:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 511:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 512:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 513:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 514:../uvc.c      **** 
 515:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 516:../uvc.c      **** 		&EXTShutter,
 517:../uvc.c      **** 		0, //&EXTSensUp,
 518:../uvc.c      **** 		0, //&EXTMirror,
 519:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 520:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 521:../uvc.c      **** 		0, //&EXTDayNightMode,
 522:../uvc.c      **** 		0, //&EXTDayNightdely,
 523:../uvc.c      **** 		0, //&EXTDayNightlev,
 524:../uvc.c      **** 		0, //&EXTNightDaylev,
 525:../uvc.c      **** 		&EXTAexModGainlev,
 526:../uvc.c      **** 		0, //&EXTExpReflev,
 527:../uvc.c      **** 		&EXTShutlev,
 528:../uvc.c      **** 		0, //&EXTCamMode,
 529:../uvc.c      **** 		0, //&EXTSnapshot,
 530:../uvc.c      **** 		0, //&EXTSensorPare,
 531:../uvc.c      **** 		0, //&EXTI2Ccmd,
 532:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 533:../uvc.c      **** 		0, //&Ext1CtlID1,
 534:../uvc.c      **** 		0, //&Ext1CtlID2,
 535:../uvc.c      **** 		0, //&Ext1CtlID3,
 536:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 537:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 538:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 539:../uvc.c      **** 		0
 540:../uvc.c      **** };
 541:../uvc.c      **** 
 542:../uvc.c      **** #endif //end of the new control structure
 543:../uvc.c      **** 
 544:../uvc.c      **** #ifndef CAM720
 545:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 546:../uvc.c      **** #else
 547:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 548:../uvc.c      **** #endif
 549:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 550:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 551:../uvc.c      **** 
 552:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 553:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 554:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 555:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 556:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 557:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 558:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 559:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 560:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 561:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 564:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 565:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 569:../uvc.c      **** };
 570:../uvc.c      **** 
 571:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 572:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 573:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 574:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 575:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 576:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 577:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 578:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 579:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 580:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 581:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 582:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 590:../uvc.c      **** };
 591:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 592:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 593:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 594:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 595:../uvc.c      **** 
 596:../uvc.c      **** static uint8_t debugData[64][2] = {{0,0}};
 597:../uvc.c      **** static uint8_t dbgIdx = 2;
 598:../uvc.c      **** static uint8_t value[32][2] = {{0,0}};
 599:../uvc.c      **** static uint8_t valIdx = 1;
 600:../uvc.c      **** 
 601:../uvc.c      **** /*
 602:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 603:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 604:../uvc.c      ****  */
 605:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 606:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 607:../uvc.c      **** };
 608:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 609:../uvc.c      **** 		0 //bit0:0-read; 1-write. bit1:number of addr. bit2:device addr. bit3:board addr. bit4:DSP addr. 
 610:../uvc.c      **** 			//bit8:number of data. bit9:data0. bit10:data1. ......
 611:../uvc.c      **** };
 612:../uvc.c      **** 
 613:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 614:../uvc.c      **** 
 615:../uvc.c      **** void I2CCmdHandler(){
 616:../uvc.c      **** 	uint8_t buf[2];
 617:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 621:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 622:../uvc.c      **** 	uint8_t i;
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 624:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 625:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 627:../uvc.c      **** 	{
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 630:../uvc.c      **** 			{
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 632:../uvc.c      **** 			}
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 634:../uvc.c      **** 
 635:../uvc.c      **** 	}
 636:../uvc.c      **** 	else if(I2CCMDArry[2]!=0x70){//for get debug data
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 643:../uvc.c      **** 			}
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 647:../uvc.c      **** 			}
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 649:../uvc.c      **** 				CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 651:../uvc.c      **** 
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 653:../uvc.c      **** 				{
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 655:../uvc.c      **** 				}
 656:../uvc.c      **** 
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else {
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 661:../uvc.c      **** 			}
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 663:../uvc.c      **** 			{
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 		I2CCMDArry[11] = 0xff;
 671:../uvc.c      **** 		//CmdType = 0xf;//end the routine
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 676:../uvc.c      **** 			dbgIdx = 2;
 677:../uvc.c      **** 			valIdx = 1;
 678:../uvc.c      **** 			value[0][1] = valIdx;
 679:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 680:../uvc.c      **** 		}
 681:../uvc.c      **** 		CmdType = 0xf;//end the routine
 682:../uvc.c      **** 	}
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 684:../uvc.c      **** 	{
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 686:../uvc.c      **** #if 0 //for debugging
 687:../uvc.c      **** 		/* test still image operation */
 688:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 689:../uvc.c      **** 			snapButFlag = 0; //press
 690:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 691:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 692:../uvc.c      **** 			snapButFlag = 0xf; //release
 693:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 694:../uvc.c      **** 		}
 695:../uvc.c      **** 
 696:../uvc.c      **** 		/* end of the test */
 697:../uvc.c      **** #endif
 698:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 703:../uvc.c      **** 				}
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 705:../uvc.c      **** 		}else{//not support currently
 706:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 707:../uvc.c      **** 		}
 708:../uvc.c      **** 	}else if(CmdType == 1){
 709:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 711:../uvc.c      **** 				for(i = 0; i<4; i++)
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 713:../uvc.c      **** 			}
 714:../uvc.c      **** 			else{
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 719:../uvc.c      **** 				}
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 721:../uvc.c      **** 				//if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 722:../uvc.c      **** 			}
 723:../uvc.c      **** 		}else{//not support currently
 724:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 725:../uvc.c      **** 		}
 726:../uvc.c      **** 
 727:../uvc.c      **** 	}
 728:../uvc.c      **** }
 729:../uvc.c      **** 
 730:../uvc.c      **** /************************************
 731:../uvc.c      ****  * set Iris mode
 732:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 733:../uvc.c      ****  */
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 735:../uvc.c      **** 	uint8_t dataIdx = 0;
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** }
 741:../uvc.c      **** 
 742:../uvc.c      **** 
 743:../uvc.c      **** 
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 745:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 746:../uvc.c      **** 	uint16_t NumLn;
 747:../uvc.c      **** 	uint16_t fRate, shutTm;
 748:../uvc.c      **** 	uint8_t LnVal;
 749:../uvc.c      **** 	switch (Data){
 750:../uvc.c      **** 	case 1:
 751:../uvc.c      **** 	case 2:
 752:../uvc.c      **** 	case 3:
 753:../uvc.c      **** 	case 4:
 754:../uvc.c      **** 	case 5:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 756:../uvc.c      **** 		fRate = 30;
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 758:../uvc.c      **** 		if(NumLn > 1944)
 759:../uvc.c      **** 			NumLn =1944;
 760:../uvc.c      **** 		else if(NumLn < 8)
 761:../uvc.c      **** 			NumLn = 8;
 762:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 763:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 764:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 765:../uvc.c      **** 		break;
 766:../uvc.c      **** 	case 6:
 767:../uvc.c      **** 	case 7:
 768:../uvc.c      **** 	case 8:
 769:../uvc.c      **** 	case 9:
 770:../uvc.c      **** 	case 10:
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 772:../uvc.c      **** 		fRate = 30;
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 774:../uvc.c      **** 		if(NumLn > 1944)
 775:../uvc.c      **** 			NumLn =1944;
 776:../uvc.c      **** 		else if(NumLn < 8)
 777:../uvc.c      **** 			NumLn = 8;
 778:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 781:../uvc.c      **** 		break;
 782:../uvc.c      **** 	case 0: //auto
 783:../uvc.c      **** 	default:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 785:../uvc.c      **** 		LnVal = 1;
 786:../uvc.c      **** 		break;
 787:../uvc.c      **** 	}
 788:../uvc.c      **** 	return LnVal;
 789:../uvc.c      **** }
 790:../uvc.c      **** 
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 792:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 793:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 794:../uvc.c      ****     uint16_t readCount;
 795:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 796:../uvc.c      ****     uint8_t devAdd;
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 803:../uvc.c      ****     }else{
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 808:../uvc.c      ****     }
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 810:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 811:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 812:../uvc.c      **** #endif
 813:../uvc.c      ****     reqData = bRequest;
 814:../uvc.c      ****     /*
 815:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 816:../uvc.c      ****      */
 817:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 818:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 819:../uvc.c      ****     	goto EndofSet;
 820:../uvc.c      ****     }
 821:../uvc.c      ****     switch (bRequest)
 822:../uvc.c      **** 		 {
 823:../uvc.c      **** 
 824:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 828:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 829:../uvc.c      **** 			  break;
 830:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 831:../uvc.c      **** 
 832:../uvc.c      **** 			 switch(CtrlID)
 833:../uvc.c      **** 			 {
 834:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 835:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 839:../uvc.c      **** 			 	 		 }else{
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 844:../uvc.c      **** 			 	 		 }
 845:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 846:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 847:../uvc.c      **** 						 break;
 848:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 849:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 850:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 854:../uvc.c      **** 			 	 		 }else{
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 860:../uvc.c      **** 			 	 		 }
 861:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 862:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 863:../uvc.c      **** 			 	 		 break;
 864:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 865:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 866:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 867:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 868:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 872:../uvc.c      **** 			 	 		 }else{
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 876:../uvc.c      **** 			 	 			else
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 881:../uvc.c      **** 			 	 		 }
 882:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 883:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 884:../uvc.c      **** 			 	 		 break;
 885:../uvc.c      **** 			 	 }
 886:../uvc.c      **** 			 	 case ExtShutCtlID0:
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 890:../uvc.c      **** 
 891:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 892:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 893:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 897:../uvc.c      **** 		 	 		 }else{
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 903:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 905:../uvc.c      **** 
 906:../uvc.c      **** 		 	 		 }
 907:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 910:../uvc.c      **** 			 		 break;
 911:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 915:../uvc.c      **** 
 916:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 917:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 922:../uvc.c      **** 		 	 		 }else{
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 927:../uvc.c      **** 		 	 		 }
 928:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 929:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 930:../uvc.c      **** 			 		 break;
 931:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 933:../uvc.c      **** 
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 935:../uvc.c      **** 						if(sendData >= 3){
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 937:../uvc.c      **** 							sendData = 0; //set back to default
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 939:../uvc.c      **** 						}
 940:../uvc.c      **** 						sendData += 4;
 941:../uvc.c      **** 					 }
 942:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 943:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 944:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 945:../uvc.c      **** 					 break;
 946:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 949:../uvc.c      **** 			 		 }
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 954:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 955:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 956:../uvc.c      **** #endif
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 958:../uvc.c      **** 			 		 {
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 960:../uvc.c      **** 			 		 }
 961:../uvc.c      **** 			 		 break;
 962:../uvc.c      **** 				 case ExtAexModCtlID9:
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 966:../uvc.c      **** 
 967:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 968:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 972:../uvc.c      **** 		 	 		 }else{
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 976:../uvc.c      **** 
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 980:../uvc.c      **** 		 	 		 }
 981:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 982:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 983:../uvc.c      **** 
 984:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 986:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 991:../uvc.c      **** 					 break;
 992:../uvc.c      **** 
 993:../uvc.c      **** 			 	 case BrgtCtlID1:
 994:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 995:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 996:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 997:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 998:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 999:../uvc.c      **** 					 }else{
1000:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1001:../uvc.c      **** 					 }
1002:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
1003:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 */
1006:../uvc.c      **** 
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1009:../uvc.c      **** 		 	 		 }else{
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
1015:../uvc.c      **** 					  if(Data0&0x80){
1016:../uvc.c      **** 						  Data0 = ~Data0;
1017:../uvc.c      **** 					  }else{
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
1019:../uvc.c      **** 					  }
1020:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1021:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1022:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1023:../uvc.c      **** 			 		 break;
1024:../uvc.c      **** 				 case HueCtlID5:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1027:../uvc.c      **** 		 	 		 }else{
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1031:../uvc.c      **** 		 	 		 }
1032:../uvc.c      **** 
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1035:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1036:../uvc.c      **** 					 break;
1037:../uvc.c      **** 				 case WBTLevCtlID11:
1038:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1039:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1040:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1041:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1045:../uvc.c      **** 		 	 		 }else{
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1053:../uvc.c      **** 		 	 		 }
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1056:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1057:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1058:../uvc.c      **** 					 break;
1059:../uvc.c      **** 				 case BLCCtlID0:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1063:../uvc.c      **** 		 	 		 }else{
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1069:../uvc.c      **** 		 	 		 }
1070:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1071:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1072:../uvc.c      **** 					 break;
1073:../uvc.c      **** 				 case ShapCtlID7:
1074:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1075:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1076:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1080:../uvc.c      **** 		 	 		 }else{
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1085:../uvc.c      **** 		 	 		 }
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case ExtExRefCtlID10:
1090:../uvc.c      **** 				 case ConsCtlID2:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1093:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1097:../uvc.c      **** 		 	 		 }else{
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1102:../uvc.c      **** 		 	 		 }
1103:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1104:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1105:../uvc.c      **** 					 break;
1106:../uvc.c      **** 				 case WBTMdCtlID9:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1108:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1111:../uvc.c      **** 		 	 		 }else{
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1116:../uvc.c      **** 
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1118:../uvc.c      **** 		 	 		 }
1119:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1120:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1121:../uvc.c      **** 					 break;
1122:../uvc.c      **** 				 case MFreqCtlID4:
1123:../uvc.c      **** 
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1125:../uvc.c      **** 
1126:../uvc.c      **** 		 	 			 if(is60Hz)
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1128:../uvc.c      **** 		 	 			 else
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1130:../uvc.c      **** 
1131:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1133:../uvc.c      **** 		 	 		 }else{
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1140:../uvc.c      **** 		 	 		 }
1141:../uvc.c      **** 
1142:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1143:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1144:../uvc.c      **** 					 break;
1145:../uvc.c      **** 				 case SaturCtlID6:
1146:../uvc.c      **** 				 default:
1147:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1148:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1152:../uvc.c      **** 		 	 		 }else{
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1157:../uvc.c      **** 		 	 		 }
1158:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1159:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1160:../uvc.c      **** 
1161:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1162:../uvc.c      **** 					 break;
1163:../uvc.c      **** 			 }
1164:../uvc.c      **** 
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 
1167:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1168:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1169:../uvc.c      **** #endif
1170:../uvc.c      **** 			  break;
1171:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1175:../uvc.c      **** 		 	 }
1176:../uvc.c      **** 
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1179:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1180:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1181:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1182:../uvc.c      **** 			 }else
1183:../uvc.c      **** 			 {
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1186:../uvc.c      **** 			 }
1187:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1188:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1189:../uvc.c      **** 			  break;
1190:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1194:../uvc.c      **** 		 	 }
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1197:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1198:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1199:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1200:../uvc.c      **** 			 }else
1201:../uvc.c      **** 			 {
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1204:../uvc.c      **** 			 }
1205:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1206:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1207:../uvc.c      **** 			  break;
1208:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1212:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1213:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1214:../uvc.c      **** 		 	 }
1215:../uvc.c      **** 		 	 else{
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1220:../uvc.c      **** 		 	 }
1221:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1222:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1223:../uvc.c      **** 			  break;
1224:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1227:../uvc.c      **** 		 	 }
1228:../uvc.c      **** 		 	 else{
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1230:../uvc.c      **** 		 	 }
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1232:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1233:../uvc.c      **** 			  Len = 1;
1234:../uvc.c      **** 			  break;
1235:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1239:../uvc.c      **** 		 	 }
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1245:../uvc.c      **** 			 }else{
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1248:../uvc.c      **** 			 }
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1250:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1251:../uvc.c      **** 			  break;
1252:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1254:../uvc.c      **** 				  glEp0Buffer, &readCount);
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1256:../uvc.c      **** 			   {
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1259:../uvc.c      **** 				  getData = glEp0Buffer[0];
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1261:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1262:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1263:../uvc.c      **** #endif
1264:../uvc.c      **** 				  switch(CtrlID)
1265:../uvc.c      **** 					 {
1266:../uvc.c      **** 						 case ExtShutCtlID0:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1271:../uvc.c      **** #if 1	// register setting directly
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1273:../uvc.c      **** 						     {
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1275:../uvc.c      **** 						    	 dataIdx = 0;
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1278:../uvc.c      **** 								 dataIdx++;
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1281:../uvc.c      **** 						     }
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1284:../uvc.c      **** 						     break;
1285:../uvc.c      **** #else	// old fashion
1286:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1287:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1288:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1289:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1290:../uvc.c      **** 									 }else{
1291:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1292:../uvc.c      **** 									 }
1293:../uvc.c      **** 								 }
1294:../uvc.c      **** 							 }else{
1295:../uvc.c      **** 								 Data1 = Data0 - 1;
1296:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1297:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1298:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1299:../uvc.c      **** 									 }else{
1300:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1301:../uvc.c      **** 									 }
1302:../uvc.c      **** 								 }
1303:../uvc.c      **** 								 if(Data1 < 8){
1304:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1305:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1306:../uvc.c      **** 								 }else{
1307:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1308:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1309:../uvc.c      **** 								 }
1310:../uvc.c      **** 							 }
1311:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1312:../uvc.c      **** 							 dataIdx = 0;
1313:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1314:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1315:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1316:../uvc.c      **** 							 if(AxMode){
1317:../uvc.c      **** 								 dataIdx++;
1318:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1319:../uvc.c      **** 								 dataIdx++;
1320:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1321:../uvc.c      **** 							 }
1322:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1323:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1324:../uvc.c      **** 							 break;
1325:../uvc.c      **** #endif
1326:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1330:../uvc.c      **** 						     dataIdx = 0;
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1333:../uvc.c      **** 							 {
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1337:../uvc.c      **** 								 /*
1338:../uvc.c      **** 								 dataIdx++;
1339:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1340:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1341:../uvc.c      **** 									 dataIdx++;
1342:../uvc.c      **** 								 }else{
1343:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1344:../uvc.c      **** 									 dataIdx++;
1345:../uvc.c      **** 								 }
1346:../uvc.c      **** 								 */
1347:../uvc.c      **** 							 }
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1352:../uvc.c      **** 								 }
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 
1360:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1364:../uvc.c      **** 						     dataIdx = 0;
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1366:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1367:../uvc.c      **** 							 {
1368:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1369:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1370:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1371:../uvc.c      **** 								 dataIdx++;
1372:../uvc.c      **** 							 }
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1377:../uvc.c      **** 									 dataIdx++;
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1379:../uvc.c      **** 								 }
1380:../uvc.c      **** 							 }
1381:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1385:../uvc.c      **** 							 break;
1386:../uvc.c      **** 						 case ExtCamMCtlID12:
1387:../uvc.c      **** 							 dataIdx = 0;
1388:../uvc.c      **** 							 if(Data0 <= 3){
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1390:../uvc.c      **** 								 Data1 = Data0;
1391:../uvc.c      **** 							 }else{
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1393:../uvc.c      **** 								 Data1 = Data0-4;
1394:../uvc.c      **** 							 }
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1401:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1402:../uvc.c      **** 							 break;
1403:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1404:../uvc.c      **** 							 dataIdx = 0;
1405:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1406:../uvc.c      **** 								 Data0 = 1;
1407:../uvc.c      **** 							 }else{ //save current sensor parameters.
1408:../uvc.c      **** 								 Data0 = 0;
1409:../uvc.c      **** 							 }
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1414:../uvc.c      **** 							 break;
1415:../uvc.c      **** 						 case ExtI2CCtlID15:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1418:../uvc.c      **** 					 		 }
1419:../uvc.c      **** 					 		I2CCmdHandler();
1420:../uvc.c      **** 							 break;
1421:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1425:../uvc.c      **** 
1426:../uvc.c      **** 							 dataIdx = 0;
1427:../uvc.c      **** #if 0 //seperate version
1428:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1429:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1431:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1432:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1433:../uvc.c      **** 							 }else{ //disable BLD window
1434:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1435:../uvc.c      **** 							 }
1436:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1437:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1438:../uvc.c      **** 							 dataIdx++;
1439:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1440:../uvc.c      **** 							 dataIdx++;
1441:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1442:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1444:../uvc.c      **** 							 dataIdx++;
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1446:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1447:../uvc.c      **** #else //combination version
1448:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1450:../uvc.c      **** 						     /* end test */
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1452:../uvc.c      **** 							 dataIdx++;
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1455:../uvc.c      **** 							 getData1 = Data1;
1456:../uvc.c      **** #endif
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1460:../uvc.c      **** 							 break;
1461:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1465:../uvc.c      **** 
1466:../uvc.c      **** 							 dataIdx = 0;
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1472:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1473:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1474:../uvc.c      **** 							 break;
1475:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1476:../uvc.c      **** 							 dataIdx = 0;
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1478:../uvc.c      **** 							 if(Data0 == 1){
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1480:../uvc.c      **** 							 }else{
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1482:../uvc.c      **** 							 }
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1486:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1488:../uvc.c      **** 							 break;
1489:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1490:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1491:../uvc.c      **** 							 dataIdx = 0;
1492:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1493:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1494:../uvc.c      **** 							  if(Data0&0x80){
1495:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1496:../uvc.c      **** 							  }else{
1497:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1498:../uvc.c      **** 							  }
1499:../uvc.c      **** 							 Data1 |= ~0x03;
1500:../uvc.c      **** 							 Data1 &= 0xC7;
1501:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1502:../uvc.c      **** 						  	 dataIdx++;
1503:../uvc.c      **** 
1504:../uvc.c      **** 							 Data0 = (Data0 << 2);
1505:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1506:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1507:../uvc.c      **** 
1508:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1509:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1510:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1511:../uvc.c      **** #endif
1512:../uvc.c      **** 							 dataIdx = 0;
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1514:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1515:../uvc.c      **** 							  if(Data0&0x80){
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1517:../uvc.c      **** 							  }else{
1518:../uvc.c      **** 								  Data0 = ~Data0;
1519:../uvc.c      **** 							  }
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1522:../uvc.c      **** 
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1525:../uvc.c      **** 
1526:../uvc.c      **** 
1527:../uvc.c      **** 							 break;
1528:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1529:../uvc.c      **** 							 dataIdx = 0;
1530:../uvc.c      **** 
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1533:../uvc.c      **** 							 dataIdx++;
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1535:../uvc.c      **** 							 dataIdx++;
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1537:../uvc.c      **** 							 dataIdx++;
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1539:../uvc.c      **** 							 dataIdx++;
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1541:../uvc.c      **** 							 dataIdx++;
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1544:../uvc.c      **** 
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1547:../uvc.c      **** 							 break;
1548:../uvc.c      **** 						 case SaturCtlID6:
1549:../uvc.c      **** 							 dataIdx = 0;
1550:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1553:../uvc.c      **** 							 dataIdx++;
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1558:../uvc.c      **** 							 break;
1559:../uvc.c      **** 
1560:../uvc.c      **** 						 case WBTLevCtlID11:
1561:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1562:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1563:../uvc.c      **** 							 dataIdx = 0;
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1567:../uvc.c      **** 							 dataIdx++;
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1570:../uvc.c      **** 
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1574:../uvc.c      **** 							 break;
1575:../uvc.c      **** 						 case MFreqCtlID4:
1576:../uvc.c      **** 							 dataIdx = 0;
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
1579:../uvc.c      **** 							 is60Hz = Data0;
1580:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1581:../uvc.c      **** 							 {
1582:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1583:../uvc.c      **** 								 is60Hz = CyFalse;
1584:../uvc.c      **** 							 }
1585:../uvc.c      **** 							 else if(Data0 >2)
1586:../uvc.c      **** 							 {
1587:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1588:../uvc.c      **** 								 is60Hz = CyTrue;
1589:../uvc.c      **** 							 }
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1592:../uvc.c      **** 							 {
1593:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1594:../uvc.c      **** 			                       switch (setRes)
1595:../uvc.c      **** 			                         {
1596:../uvc.c      **** 			                         	case 1: //1944
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1600:../uvc.c      **** 			                         		break;
1601:../uvc.c      **** 			                         	case 2: //1080
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1605:../uvc.c      **** 			                         		break;
1606:../uvc.c      **** 			                         	case 3: //720
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1610:../uvc.c      **** 			                         		break;
1611:../uvc.c      **** 			                         	case 4: //VGA
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1615:../uvc.c      **** 			                         	default:
1616:../uvc.c      **** 			                         		break;
1617:../uvc.c      **** 			                         }
1618:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1619:../uvc.c      **** 							 }
1620:../uvc.c      **** 
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1622:../uvc.c      **** 							 break;
1623:../uvc.c      **** 					 	 case BLCCtlID0:
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1627:../uvc.c      **** 						     dataIdx = 0;
1628:../uvc.c      **** 
1629:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1630:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1635:../uvc.c      **** 							 {
1636:../uvc.c      **** 								 if(Data0 < 3){
1637:../uvc.c      **** 					 				 Data0 += 4;
1638:../uvc.c      **** 					 			 }else{
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1640:../uvc.c      **** 									Data0 = 4; //set to default.
1641:../uvc.c      **** 					 			 }
1642:../uvc.c      **** 					 		 }
1643:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1644:../uvc.c      **** 							 dataIdx = 0;
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1648:../uvc.c      **** 
1649:../uvc.c      **** 					 		 break;
1650:../uvc.c      **** 					 	 case ShapCtlID7:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1654:../uvc.c      **** 						     dataIdx = 0;
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1657:../uvc.c      **** 							 if(Data0 != 0){
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1659:../uvc.c      **** #ifdef COLOR
1660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1661:../uvc.c      **** #else
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1663:../uvc.c      **** 								 dataIdx++;
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1665:../uvc.c      **** #endif
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1667:../uvc.c      **** 							 }else{
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1671:../uvc.c      **** 
1672:../uvc.c      **** 							 }
1673:../uvc.c      **** 							 break;
1674:../uvc.c      **** 						 case ExtExRefCtlID10:
1675:../uvc.c      **** 						 case ConsCtlID2:
1676:../uvc.c      **** 							 dataIdx = 0;
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1680:../uvc.c      **** 
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1683:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1684:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1685:../uvc.c      **** 
1686:../uvc.c      **** 							 break;
1687:../uvc.c      **** 						 default:
1688:../uvc.c      **** 							 dataIdx = 0;
1689:../uvc.c      **** 
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1693:../uvc.c      **** 
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1696:../uvc.c      **** 							 break;
1697:../uvc.c      **** 					 }
1698:../uvc.c      **** 			   }else{
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1700:../uvc.c      **** 			   }
1701:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1702:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1703:../uvc.c      **** #endif
1704:../uvc.c      **** 
1705:../uvc.c      **** 			  break;
1706:../uvc.c      **** 		  default:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1708:../uvc.c      **** 			  break;
1709:../uvc.c      **** 		 }
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1711:../uvc.c      **** }
1712:../uvc.c      **** /************** CT control requests handler *************************/
1713:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1714:../uvc.c      **** 
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1716:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1717:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1718:../uvc.c      ****     uint16_t readCount;
1719:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1720:../uvc.c      ****     uint16_t diff, value, diffRd;
1721:../uvc.c      ****     uint8_t i, shutter, index;
1722:../uvc.c      ****     diff = 0xffff;
1723:../uvc.c      ****     shutter = 1;
1724:../uvc.c      ****     index = 1;
1725:../uvc.c      **** 
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1728:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1730:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1731:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1732:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1733:../uvc.c      **** #endif
1734:../uvc.c      ****     reqData = bRequest;
1735:../uvc.c      **** 
1736:../uvc.c      ****     switch (bRequest)
1737:../uvc.c      **** 		 {
1738:../uvc.c      **** 
1739:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1743:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 			  break;
1745:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1746:../uvc.c      **** 
1747:../uvc.c      **** 			 switch(CtrlID)
1748:../uvc.c      **** 			 {
1749:../uvc.c      **** 				 default:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1754:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1755:../uvc.c      **** 					 break;
1756:../uvc.c      **** 			 }
1757:../uvc.c      **** 
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1759:../uvc.c      **** 
1760:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1761:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1762:../uvc.c      **** #endif
1763:../uvc.c      **** 			  break;
1764:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1768:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1769:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1772:../uvc.c      **** 			  break;
1773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1777:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1778:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1779:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1780:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1781:../uvc.c      **** 			  break;
1782:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1786:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1787:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1788:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1789:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1790:../uvc.c      **** 			  break;
1791:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1794:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1795:../uvc.c      **** 			  Len = 1;
1796:../uvc.c      **** 			  break;
1797:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1804:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1805:../uvc.c      **** 			  break;
1806:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1808:../uvc.c      **** 			  glEp0Buffer, &readCount);
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1811:../uvc.c      **** 			  value = Data1;
1812:../uvc.c      **** 
1813:../uvc.c      **** 			  switch(CtrlID)
1814:../uvc.c      **** 			  {
1815:../uvc.c      **** 		  	      case AutoExMCtlID1:
1816:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1817:../uvc.c      **** 
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1820:../uvc.c      **** 				    getData = glEp0Buffer[0];
1821:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1822:../uvc.c      **** 		  		    switch (getData){
1823:../uvc.c      **** 						case 1:
1824:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1825:../uvc.c      **** 							break;
1826:../uvc.c      **** 						case 2:
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1828:../uvc.c      **** 							dataIdx = 0;
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1832:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1833:../uvc.c      **** 
1834:../uvc.c      **** 							break;
1835:../uvc.c      **** 						case 4:
1836:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1837:../uvc.c      **** 							break;
1838:../uvc.c      **** 						case 8:
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1840:../uvc.c      **** 			  		    	dataIdx = 0;
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1844:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1845:../uvc.c      **** 							break;
1846:../uvc.c      **** 		  		    }
1847:../uvc.c      **** #if 0
1848:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1849:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1850:../uvc.c      **** 						  dataIdx = 0;
1851:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1852:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1853:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1854:../uvc.c      **** 		  		    }
1855:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1856:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1857:../uvc.c      **** 		  		    }
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 				    break;
1860:../uvc.c      **** 
1861:../uvc.c      **** 			  	  case ExTmACtlID3:
1862:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1863:../uvc.c      **** 
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1867:../uvc.c      **** 					  {
1868:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1869:../uvc.c      **** 						  {
1870:../uvc.c      **** 							if(value > ShutValueArry[i]){
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1872:../uvc.c      **** 							}else{
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1874:../uvc.c      **** 							}
1875:../uvc.c      **** 							  if(diff > diffRd){
1876:../uvc.c      **** 								  diff = diffRd;
1877:../uvc.c      **** 								  index = i;
1878:../uvc.c      **** 							  }
1879:../uvc.c      **** 						  }
1880:../uvc.c      **** 						  shutter = shutter+index;
1881:../uvc.c      **** 
1882:../uvc.c      **** 						  dataIdx = 0;
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1886:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1887:../uvc.c      **** 
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1892:../uvc.c      **** 					  }else{
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1894:../uvc.c      **** 					  }
1895:../uvc.c      **** 					  getData = glEp0Buffer[0];
1896:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1897:../uvc.c      **** 					  break;
1898:../uvc.c      **** 			  	  case IriACtlID7:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1900:../uvc.c      **** 					  {
1901:../uvc.c      **** 							 dataIdx = 0;
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1905:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1906:../uvc.c      **** 
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1910:../uvc.c      **** 					  }else{
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1912:../uvc.c      **** 					  }
1913:../uvc.c      **** 					  getData = glEp0Buffer[0];
1914:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1915:../uvc.c      **** 
1916:../uvc.c      **** 					  break;
1917:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1918:../uvc.c      **** 					  getData = glEp0Buffer[0];
1919:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1920:../uvc.c      **** #if 1
1921:../uvc.c      **** 					  dataIdx = 0;
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 					  if(getData == 1)
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1925:../uvc.c      **** 					  else if(getData == 0xff)
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1927:../uvc.c      **** 					  else
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1929:../uvc.c      **** 					  //dataIdx++;
1930:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1932:../uvc.c      **** #endif
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1934:../uvc.c      **** 					  break;
1935:../uvc.c      **** 
1936:../uvc.c      **** 			  	  default:
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1939:../uvc.c      **** 			  		 break;
1940:../uvc.c      **** 			  }
1941:../uvc.c      **** 			  break;
1942:../uvc.c      **** 		  default:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1945:../uvc.c      **** 			  break;
1946:../uvc.c      **** 		 }
1947:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1948:../uvc.c      **** 
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1950:../uvc.c      **** }
1951:../uvc.c      **** 
1952:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1953:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1954:../uvc.c      **** {
1955:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1956:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1957:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1958:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1959:../uvc.c      **** 
1960:../uvc.c      ****     CtrlID = BrgtCtlID1;
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1964:../uvc.c      ****     Data1 = Data0;
1965:../uvc.c      **** 
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      ****     if(Data1&0x80){
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1969:../uvc.c      ****     }else{
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1971:../uvc.c      ****     }
1972:../uvc.c      ****     Data0 = (Data0 << 2);
1973:../uvc.c      **** 
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1975:../uvc.c      **** 
1976:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1981:../uvc.c      **** 
1982:../uvc.c      ****     CtrlID = ConsCtlID2;
1983:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1984:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1990:../uvc.c      **** 
1991:../uvc.c      ****     CtrlID = HueCtlID5;
1992:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2003:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2004:../uvc.c      **** 
2005:../uvc.c      ****     CtrlID = SaturCtlID6;
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2012:../uvc.c      **** 
2013:../uvc.c      ****     CtrlID = ShapCtlID7;
2014:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2015:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2020:../uvc.c      **** 
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2022:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2023:../uvc.c      **** 	return;
2024:../uvc.c      **** }
2025:../uvc.c      **** 
2026:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2027:../uvc.c      **** void
2028:../uvc.c      **** CyFxUVCAddHeader (
2029:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2030:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2031:../uvc.c      ****         )
2032:../uvc.c      **** {
2033:../uvc.c      ****     /* Copy header to buffer */
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2037:../uvc.c      **** 
2038:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2042:../uvc.c      ****     }
2043:../uvc.c      **** }
2044:../uvc.c      **** 
2045:../uvc.c      **** 
2046:../uvc.c      **** /* Application Error Handler */
2047:../uvc.c      **** void
2048:../uvc.c      **** CyFxAppErrorHandler (
2049:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2050:../uvc.c      ****         )
2051:../uvc.c      **** {
2052:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2053:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2054:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2055:../uvc.c      **** 
2056:../uvc.c      ****        This function can be modified to take additional error handling actions such
2057:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2058:../uvc.c      ****      */
2059:../uvc.c      ****     for (;;)
2060:../uvc.c      ****     {
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
2063:../uvc.c      ****     }
2064:../uvc.c      **** }
2065:../uvc.c      **** 
2066:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2067:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2068:../uvc.c      ****  */
2069:../uvc.c      **** static void
2070:../uvc.c      **** CyFxUVCApplnAbortHandler (
2071:../uvc.c      ****         void)
2072:../uvc.c      **** {
2073:../uvc.c      **** 	uint32_t flag;
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2075:../uvc.c      **** 	{
2076:../uvc.c      ****         /* Clear the Video Stream Request Event */
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2078:../uvc.c      **** 
2079:../uvc.c      ****         /* Set Video Stream Abort Event */
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2081:../uvc.c      **** 	}
2082:../uvc.c      **** }
2083:../uvc.c      **** 
2084:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2085:../uvc.c      **** static void
2086:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2087:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2088:../uvc.c      ****         uint16_t             evdata  /* Event data */
2089:../uvc.c      ****         )
2090:../uvc.c      **** {
2091:../uvc.c      ****     switch (evtype)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
2097:../uvc.c      ****             gpif_initialized = 0;
2098:../uvc.c      ****             streamingStarted = CyFalse;
2099:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2100:../uvc.c      ****             break;
2101:../uvc.c      **** 
2102:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
2106:../uvc.c      ****             gpif_initialized = 0;
2107:../uvc.c      ****             streamingStarted = CyFalse;
2108:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2109:../uvc.c      ****             break;
2110:../uvc.c      **** 
2111:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
2115:../uvc.c      ****             gpif_initialized = 0;
2116:../uvc.c      ****             isUsbConnected = CyFalse;
2117:../uvc.c      ****             streamingStarted = CyFalse;
2118:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2119:../uvc.c      ****             break;
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef BACKFLOW_DETECT
2122:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2123:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2124:../uvc.c      ****             break;
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      ****         default:
2128:../uvc.c      ****             break;
2129:../uvc.c      ****     }
2130:../uvc.c      **** }
2131:../uvc.c      **** 
2132:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2133:../uvc.c      **** static CyBool_t
2134:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2135:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2136:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2137:../uvc.c      ****         )
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2140:../uvc.c      ****     uint32_t status;
2141:../uvc.c      ****     //CyU3PDebugPrint (4, "The USB setup Requests and UVC events 0x%x, 0x%x\r\n", setupdat0, setupd
2142:../uvc.c      ****     /* Obtain Request Type and Request */
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
2149:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
2150:../uvc.c      ****     if(dbgIdx < 63){
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
2154:../uvc.c      **** 		dbgIdx++;
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Check for UVC Class Requests */
2159:../uvc.c      ****     switch (bmReqType)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2162:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2163:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2164:../uvc.c      ****             switch (wIndex & 0xFF)
2165:../uvc.c      ****             {
2166:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2167:../uvc.c      ****                     {
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2170:../uvc.c      ****                                 CYU3P_EVENT_OR);
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2172:../uvc.c      ****                         {
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2175:../uvc.c      ****                         }
2176:../uvc.c      ****                     }
2177:../uvc.c      ****                     break;
2178:../uvc.c      **** 
2179:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2180:../uvc.c      ****                     {
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2183:../uvc.c      ****                                 CYU3P_EVENT_OR);
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2185:../uvc.c      ****                         {
2186:../uvc.c      ****                             /* Error handling */
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2189:../uvc.c      ****                         }
2190:../uvc.c      ****                     }
2191:../uvc.c      ****                     break;
2192:../uvc.c      **** 
2193:../uvc.c      ****                 default:
2194:../uvc.c      ****                     break;
2195:../uvc.c      ****             }
2196:../uvc.c      ****             break;
2197:../uvc.c      **** 
2198:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2200:../uvc.c      ****             {
2201:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2202:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2204:../uvc.c      ****                 {
2205:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2208:../uvc.c      ****                     gpif_initialized = 0;
2209:../uvc.c      ****                     streamingStarted = CyFalse;
2210:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2212:../uvc.c      ****                     CyU3PBusyWait (100);
2213:../uvc.c      **** 
2214:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2218:../uvc.c      ****                     CyU3PBusyWait (100);
2219:../uvc.c      **** 
2220:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
2223:../uvc.c      ****                     /* Complete Control request handshake */
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
2225:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2228:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2229:../uvc.c      **** 
2230:../uvc.c      ****                 }
2231:../uvc.c      ****             }
2232:../uvc.c      ****             break;
2233:../uvc.c      **** 
2234:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2236:../uvc.c      ****             {
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2238:../uvc.c      ****                 {
2239:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2240:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2241:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2242:../uvc.c      ****                 	 * has started. */
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
2244:../uvc.c      ****                     {
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2246:../uvc.c      **** 
2247:../uvc.c      ****                         /* Disable the GPIF state machine. */
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2249:../uvc.c      ****                         gpif_initialized = 0;
2250:../uvc.c      ****                         streamingStarted = CyFalse;
2251:../uvc.c      **** 
2252:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2254:../uvc.c      ****                         CyU3PBusyWait (100);
2255:../uvc.c      **** 
2256:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2260:../uvc.c      ****                         CyU3PBusyWait (100);
2261:../uvc.c      **** 
2262:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2264:../uvc.c      **** 
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
2266:../uvc.c      ****                         /* Complete Control request handshake */
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
2268:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
2271:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2272:../uvc.c      ****                     }
2273:../uvc.c      ****                     else
2274:../uvc.c      ****                     {
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
2277:../uvc.c      ****                     }
2278:../uvc.c      ****                 }
2279:../uvc.c      ****             }
2280:../uvc.c      ****             break;
2281:../uvc.c      **** 
2282:../uvc.c      ****         default:
2283:../uvc.c      ****             break;
2284:../uvc.c      ****     }
2285:../uvc.c      **** 
2286:../uvc.c      ****     /* Return status of request handling to the USB driver */
2287:../uvc.c      ****     return uvcHandleReq;
2288:../uvc.c      **** }
2289:../uvc.c      **** 
2290:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2291:../uvc.c      **** 
2292:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2293:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2294:../uvc.c      ****  */
2295:../uvc.c      **** void
2296:../uvc.c      **** CyFxUvcApplnDmaCallback (
2297:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2298:../uvc.c      ****         CyU3PDmaCbType_t      type,
2299:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2300:../uvc.c      ****         )
2301:../uvc.c      **** {
2302:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2303:../uvc.c      **** #if 1
2304:../uvc.c      ****     CyU3PReturnStatus_t status;
2305:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2306:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2307:../uvc.c      **** 
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2309:../uvc.c      ****     {
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2311:../uvc.c      ****             {
2312:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2313:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2314:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2315:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2316:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2317:../uvc.c      ****                 	stiflag = 0x03;
2318:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2319:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2320:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2321:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2322:../uvc.c      ****                 }
2323:../uvc.c      **** #endif
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2325:../uvc.c      ****                 fb++;
2326:../uvc.c      ****             }
2327:../uvc.c      ****             else
2328:../uvc.c      ****             {
2329:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2331:../uvc.c      ****                 pb++;
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
2333:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2334:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2335:../uvc.c      ****                 //lineCount = 0; //res test
2336:../uvc.c      **** #if 1   //remove the still flag clearing here
2337:../uvc.c      ****                 if(stiflag == 0x0F){
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2341:../uvc.c      ****                 	stiflag = 0xAA;
2342:../uvc.c      ****                 }
2343:../uvc.c      **** #endif
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2345:../uvc.c      ****             }
2346:../uvc.c      **** 
2347:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2348:../uvc.c      ****             prodCount++;
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2350:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2351:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2353:../uvc.c      ****             {
2354:../uvc.c      ****                 prodCount--;
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2356:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2357:../uvc.c      ****             }
2358:../uvc.c      ****     }
2359:../uvc.c      **** #endif
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         consCount++;
2363:../uvc.c      ****         streamingStarted = CyTrue;
2364:../uvc.c      ****     }
2365:../uvc.c      **** }
2366:../uvc.c      **** 
2367:../uvc.c      **** /*
2368:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2369:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2370:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2371:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2372:../uvc.c      ****  * to commit the buffer.
2373:../uvc.c      ****  */
2374:../uvc.c      **** static uint8_t
2375:../uvc.c      **** CyFxUvcAppCommitEOF (
2376:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2377:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2378:../uvc.c      ****         )
2379:../uvc.c      **** {
2380:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2381:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2384:../uvc.c      **** 
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2386:../uvc.c      ****     {
2387:../uvc.c      ****         switch (stateId)
2388:../uvc.c      ****         {
2389:../uvc.c      **** 
2390:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2391:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2392:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2393:../uvc.c      ****                 break;
2394:../uvc.c      **** 
2395:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2396:../uvc.c      ****                 socket = 0;
2397:../uvc.c      ****                 break;
2398:../uvc.c      **** 
2399:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2400:../uvc.c      ****                 socket = 1;
2401:../uvc.c      ****                 break;
2402:../uvc.c      **** 
2403:../uvc.c      ****             default:
2404:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2405:../uvc.c      ****                 /* Unexpected current state. Return error. */
2406:../uvc.c      ****             	//lineCount++;
2407:../uvc.c      ****             	return 1;
2408:../uvc.c      ****         }
2409:../uvc.c      ****     }
2410:../uvc.c      **** 
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2412:../uvc.c      ****     {
2413:../uvc.c      ****         switch (stateId)
2414:../uvc.c      ****         {
2415:../uvc.c      **** #ifndef CAM720
2416:../uvc.c      **** #ifdef GPIFIIM
2417:../uvc.c      ****             case 13:
2418:../uvc.c      ****             case 24:
2419:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2420:../uvc.c      ****                 break;
2421:../uvc.c      **** 
2422:../uvc.c      ****             case 8:
2423:../uvc.c      ****                 socket = 0;
2424:../uvc.c      ****                 break;
2425:../uvc.c      **** 
2426:../uvc.c      ****             case 20:
2427:../uvc.c      ****                 socket = 1;
2428:../uvc.c      ****                 break;
2429:../uvc.c      **** #else
2430:../uvc.c      ****             case 11:
2431:../uvc.c      ****             case 18:
2432:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2433:../uvc.c      ****                 break;
2434:../uvc.c      **** 
2435:../uvc.c      ****             case 8:
2436:../uvc.c      ****                 socket = 0;
2437:../uvc.c      ****                 break;
2438:../uvc.c      **** 
2439:../uvc.c      ****             case 15:
2440:../uvc.c      ****                 socket = 1;
2441:../uvc.c      ****                 break;
2442:../uvc.c      **** #endif
2443:../uvc.c      **** #else
2444:../uvc.c      ****             case 11:
2445:../uvc.c      ****             case 18:
2446:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2447:../uvc.c      ****                 break;
2448:../uvc.c      **** 
2449:../uvc.c      ****             case 8:
2450:../uvc.c      ****                 socket = 0;
2451:../uvc.c      ****                 break;
2452:../uvc.c      **** 
2453:../uvc.c      ****             case 15:
2454:../uvc.c      ****                 socket = 1;
2455:../uvc.c      ****                 break;
2456:../uvc.c      **** 
2457:../uvc.c      **** #endif
2458:../uvc.c      ****              default:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2460:../uvc.c      ****                 /* Unexpected current state. Return error. */
2461:../uvc.c      ****                return 1;
2462:../uvc.c      ****         }
2463:../uvc.c      ****     }
2464:../uvc.c      **** 
2465:../uvc.c      ****     if (socket != 0xFF)
2466:../uvc.c      ****     {
2467:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2468:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2469:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2472:../uvc.c      ****         {
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2474:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2475:../uvc.c      ****         }
2476:../uvc.c      ****     }
2477:../uvc.c      **** 
2478:../uvc.c      ****     return 0;
2479:../uvc.c      **** }
2480:../uvc.c      **** 
2481:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2482:../uvc.c      **** void
2483:../uvc.c      **** CyFxGpifCB (
2484:../uvc.c      ****         CyU3PGpifEventType event,
2485:../uvc.c      ****         uint8_t currentState
2486:../uvc.c      ****         )
2487:../uvc.c      **** {
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2489:../uvc.c      ****     {
2490:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2491:../uvc.c      ****     	           in the UVC implementation. */
2492:../uvc.c      ****     	//hitFV = CyTrue;
2493:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2495:../uvc.c      ****     }
2496:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2497:../uvc.c      **** }
2498:../uvc.c      **** 
2499:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2500:../uvc.c      **** static void
2501:../uvc.c      **** CyFxUVCApplnDebugInit (
2502:../uvc.c      ****         void)
2503:../uvc.c      **** {
2504:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2505:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2506:../uvc.c      **** 
2507:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2510:../uvc.c      ****     {
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****     }
2514:../uvc.c      **** 
2515:../uvc.c      ****     /* Set UART Configuration */
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2523:../uvc.c      **** 
2524:../uvc.c      ****     /* Set the UART configuration */
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2527:../uvc.c      ****     {
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2529:../uvc.c      ****     }
2530:../uvc.c      **** 
2531:../uvc.c      ****     /* Set the UART transfer */
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2534:../uvc.c      ****     {
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2536:../uvc.c      ****     }
2537:../uvc.c      **** 
2538:../uvc.c      ****     /* Initialize the Debug logger module. */
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      ****     /* Disable log message headers. */
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2547:../uvc.c      **** }
2548:../uvc.c      **** 
2549:../uvc.c      **** /* I2C initialization. */
2550:../uvc.c      **** static void
2551:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2552:../uvc.c      **** {
2553:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2554:../uvc.c      ****     CyU3PReturnStatus_t status;
2555:../uvc.c      **** 
2556:../uvc.c      ****     status = CyU3PI2cInit ();
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2558:../uvc.c      ****     {
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
2561:../uvc.c      ****     }
2562:../uvc.c      **** 
2563:../uvc.c      ****     /*  Set I2C Configuration */
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2568:../uvc.c      **** 
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2571:../uvc.c      ****     {
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
2574:../uvc.c      ****     }
2575:../uvc.c      **** }
2576:../uvc.c      **** 
2577:../uvc.c      **** #ifdef BACKFLOW_DETECT
2578:../uvc.c      **** static void CyFxUvcAppPibCallback (
2579:../uvc.c      ****         CyU3PPibIntrType cbType,
2580:../uvc.c      ****         uint16_t cbArg)
2581:../uvc.c      **** {
2582:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2583:../uvc.c      ****     {
2584:../uvc.c      ****         if (!back_flow_detected)
2585:../uvc.c      ****         {
2586:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2587:../uvc.c      ****             back_flow_detected = 1;
2588:../uvc.c      ****         }
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** #endif
2592:../uvc.c      **** 
2593:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2594:../uvc.c      **** static void
2595:../uvc.c      **** CyFxUvcAppDebugCallback (
2596:../uvc.c      ****         CyU3PDmaChannel   *handle,
2597:../uvc.c      ****         CyU3PDmaCbType_t   type,
2598:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2599:../uvc.c      **** {
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2604:../uvc.c      ****     }
2605:../uvc.c      **** }
2606:../uvc.c      **** #endif
2607:../uvc.c      **** 
2608:../uvc.c      **** #if 0
2609:../uvc.c      **** static void CyFxAppIntEpCb(
2610:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2611:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2612:../uvc.c      **** 		uint8_t  ebNum)
2613:../uvc.c      **** 		{
2614:../uvc.c      **** 			//CyBool_t value;
2615:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2616:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2617:../uvc.c      **** 
2618:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2619:../uvc.c      **** 		}
2620:../uvc.c      **** #endif
2621:../uvc.c      **** 
2622:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2623:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2624:../uvc.c      ****    configures the DMA module for the UVC Application */
2625:../uvc.c      **** static void
2626:../uvc.c      **** CyFxUVCApplnInit (void)
2627:../uvc.c      **** {
2628:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2629:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2630:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2631:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2632:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2633:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2634:../uvc.c      **** 
2635:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2636:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2637:../uvc.c      **** 
2638:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2639:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2640:../uvc.c      **** #endif
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Create UVC event group */
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2644:../uvc.c      ****     if (apiRetStatus != 0)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2651:../uvc.c      ****     CyFxUvcAppPTZInit ();
2652:../uvc.c      **** #endif
2653:../uvc.c      **** 
2654:../uvc.c      ****     isUsbConnected = CyFalse;
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2656:../uvc.c      **** 
2657:../uvc.c      ****     /* Init the GPIO module */
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize Gpio interface */
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2666:../uvc.c      ****     if (apiRetStatus != 0)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2669:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2670:../uvc.c      ****     }
2671:../uvc.c      **** 
2672:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2673:../uvc.c      ****      * must use GpioOverride to configure it */
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2675:../uvc.c      ****     if (apiRetStatus != 0)
2676:../uvc.c      ****     {
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2679:../uvc.c      ****     }
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2681:../uvc.c      ****     if (apiRetStatus != 0)
2682:../uvc.c      ****     {
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2684:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2685:../uvc.c      ****     }
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2687:../uvc.c      ****     if (apiRetStatus != 0)
2688:../uvc.c      ****     {
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2691:../uvc.c      ****     }
2692:../uvc.c      **** 
2693:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2701:../uvc.c      ****     {
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2703:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2704:../uvc.c      ****     }
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2707:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2715:../uvc.c      ****     {
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2717:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2718:../uvc.c      ****     }
2719:../uvc.c      **** 
2720:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2721:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2729:../uvc.c      ****     {
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2732:../uvc.c      ****     }
2733:../uvc.c      **** 
2734:../uvc.c      ****     /* Initialize the P-port. */
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2739:../uvc.c      **** 
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2742:../uvc.c      ****     {
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2744:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2745:../uvc.c      ****     }
2746:../uvc.c      **** 
2747:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2749:../uvc.c      **** 
2750:../uvc.c      **** #ifdef BACKFLOW_DETECT
2751:../uvc.c      ****     back_flow_detected = 0;
2752:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2753:../uvc.c      **** #endif
2754:../uvc.c      **** 
2755:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2756:../uvc.c      ****     SensorReset ();
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
2758:../uvc.c      ****     //SensorInit ();
2759:../uvc.c      **** 
2760:../uvc.c      ****     /* USB initialization. */
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2763:../uvc.c      ****     {
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2765:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2766:../uvc.c      ****     }
2767:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2769:../uvc.c      **** 
2770:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2772:../uvc.c      **** 
2773:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2774:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2775:../uvc.c      **** 
2776:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2779:../uvc.c      **** 
2780:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* Configuration descriptors. */
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2788:../uvc.c      **** 
2789:../uvc.c      ****     /* String Descriptors */
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2793:../uvc.c      **** 
2794:../uvc.c      ****     /* Configure the status interrupt endpoint.
2795:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2796:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2797:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2798:../uvc.c      ****      */
2799:../uvc.c      ****     endPointConfig.enable   = 1;
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2803:../uvc.c      ****     endPointConfig.streams  = 0;
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2807:../uvc.c      ****     {
2808:../uvc.c      ****         /* Error Handling */
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2811:../uvc.c      ****     }
2812:../uvc.c      **** 
2813:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2826:../uvc.c      ****             &dmaInterConfig);
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2828:../uvc.c      ****     {
2829:../uvc.c      ****         /* Error handling */
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2832:../uvc.c      ****     }
2833:../uvc.c      **** 
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
2836:../uvc.c      ****     {
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2838:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2857:../uvc.c      ****             &dmaMultiConfig);
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2859:../uvc.c      ****     {
2860:../uvc.c      ****         /* Error handling */
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2863:../uvc.c      ****     }
2864:../uvc.c      **** 
2865:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2866:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2867:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2868:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2869:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2870:../uvc.c      ****      */
2871:../uvc.c      **** 
2872:../uvc.c      ****     endPointConfig.enable   = 1;
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2876:../uvc.c      ****     endPointConfig.streams  = 0;
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
2878:../uvc.c      **** 
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2887:../uvc.c      **** 
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2890:../uvc.c      ****     {
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2892:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2893:../uvc.c      ****     }
2894:../uvc.c      **** 
2895:../uvc.c      ****     channelConfig.size           = 1024;
2896:../uvc.c      ****     channelConfig.count          = 1;
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2906:../uvc.c      **** 
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2909:../uvc.c      ****     {
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2911:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2912:../uvc.c      ****     }
2913:../uvc.c      **** 
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2916:../uvc.c      ****     {
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2918:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2919:../uvc.c      ****     }
2920:../uvc.c      **** 
2921:../uvc.c      ****     channelConfig.size           = 1024;
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2930:../uvc.c      ****     channelConfig.notification   = 0;
2931:../uvc.c      ****     channelConfig.cb             = 0;
2932:../uvc.c      **** 
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2935:../uvc.c      ****     {
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2938:../uvc.c      ****     }
2939:../uvc.c      **** 
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
2942:../uvc.c      ****     {
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2944:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2945:../uvc.c      ****     }
2946:../uvc.c      **** #endif
2947:../uvc.c      **** 
2948:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2951:../uvc.c      ****     {
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2953:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2954:../uvc.c      ****     }
2955:../uvc.c      **** 
2956:../uvc.c      ****     CyU3PBusyWait(100);
2957:../uvc.c      **** 
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2959:../uvc.c      **** 
2960:../uvc.c      ****     endPointConfig.enable   = 1;
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2963:../uvc.c      ****     {
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
2966:../uvc.c      ****     }
2967:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2968:../uvc.c      ****     {
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
2971:../uvc.c      ****     }
2972:../uvc.c      ****     endPointConfig.streams  = 0;
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2975:../uvc.c      ****     {
2976:../uvc.c      ****         /* Error Handling */
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2979:../uvc.c      ****     }
2980:../uvc.c      **** #if 0    //for still image method 3 using
2981:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2982:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2983:../uvc.c      ****     {
2984:../uvc.c      ****         /* Error Handling */
2985:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2986:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2987:../uvc.c      ****     }
2988:../uvc.c      **** #endif
2989:../uvc.c      **** 
2990:../uvc.c      **** }
2991:../uvc.c      **** 
2992:../uvc.c      **** /*
2993:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2994:../uvc.c      ****  * streaming session is started.
2995:../uvc.c      ****  */
2996:../uvc.c      **** static void
2997:../uvc.c      **** CyFxUvcAppGpifInit (
2998:../uvc.c      ****         void)
2999:../uvc.c      **** {
3000:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3001:../uvc.c      **** 
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3003:../uvc.c      ****     {
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3006:../uvc.c      ****     }
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3008:../uvc.c      ****     {
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3011:../uvc.c      ****     }
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3013:../uvc.c      ****     {
3014:../uvc.c      ****         /* Error Handling */
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3017:../uvc.c      ****     }
3018:../uvc.c      **** 
3019:../uvc.c      ****     /* Start the state machine from the designated start state. */
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3021:../uvc.c      ****     {
3022:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3023:../uvc.c      ****     }
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3025:../uvc.c      ****     {
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3027:../uvc.c      ****     }
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3029:../uvc.c      ****     {
3030:../uvc.c      ****         /* Error Handling */
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3032:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3033:../uvc.c      ****     }
3034:../uvc.c      **** }
3035:../uvc.c      **** 
3036:../uvc.c      **** /*
3037:../uvc.c      ****  * Entry function for the UVC Application Thread
3038:../uvc.c      ****  */
3039:../uvc.c      **** 
3040:../uvc.c      **** uint32_t posTick;
3041:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3042:../uvc.c      **** 
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3043 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3044 0
  28 0000 28209FE5 		ldr	r2, .L2
3043:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3043 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3044 0
  36 0008 002092E5 		ldr	r2, [r2]
3043:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3043 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3044 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3045 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3046:../uvc.c      **** }
  49              		.loc 1 3046 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3045 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE19:
  63              		.align	2
  64              		.global	I2cAppThread_Entry
  66              	I2cAppThread_Entry:
  67              	.LFB27:
3047:../uvc.c      **** 
3048:../uvc.c      **** 
3049:../uvc.c      **** void
3050:../uvc.c      **** UVCAppThread_Entry (
3051:../uvc.c      ****         uint32_t input)
3052:../uvc.c      **** {
3053:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3054:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3055:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3056:../uvc.c      ****     uint8_t i = 0;
3057:../uvc.c      ****     uint32_t flag;
3058:../uvc.c      ****     uint32_t prinflag = 0;
3059:../uvc.c      **** static uint8_t IMcount = 0;
3060:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3061:../uvc.c      ****     uint32_t frameCnt = 0;
3062:../uvc.c      **** #endif
3063:../uvc.c      ****     /* Initialize the Uart Debug Module */
3064:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3065:../uvc.c      **** 
3066:../uvc.c      ****     /* Initialize the I2C interface */
3067:../uvc.c      **** 	while (i++ < 6){
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
3069:../uvc.c      **** 	}
3070:../uvc.c      **** 
3071:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3072:../uvc.c      **** 
3073:../uvc.c      ****     /* Initialize the UVC Application */
3074:../uvc.c      ****     CyFxUVCApplnInit ();
3075:../uvc.c      ****     /*
3076:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3077:../uvc.c      **** 
3078:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3079:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3080:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3081:../uvc.c      **** 
3082:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3083:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3084:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3085:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3086:../uvc.c      **** 
3087:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3088:../uvc.c      ****        of handling the abort request.
3089:../uvc.c      ****      */
3090:../uvc.c      **** 
3091:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3092:../uvc.c      ****     //CyU3PThreadSleep(1000);
3093:../uvc.c      **** 
3094:../uvc.c      ****     for (;;)
3095:../uvc.c      ****     {
3096:../uvc.c      ****         /* Waiting for the Video Stream Event */
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3098:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3099:../uvc.c      ****         {
3100:../uvc.c      ****         	debugData[0][1] = debugData[0][1]&0xFF;
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
3102:../uvc.c      ****         	//CyU3PDebugPrint (4, "stream ready %x\n", apiRetStatus);
3103:../uvc.c      **** #if 0 //test for new firmware no video bring up
3104:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3105:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3106:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3107:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3108:../uvc.c      ****             {
3109:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3110:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3111:../uvc.c      ****                 {
3112:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3113:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3114:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3115:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3116:../uvc.c      **** #endif
3117:../uvc.c      **** #endif
3118:../uvc.c      ****                     }
3119:../uvc.c      ****                 else
3120:../uvc.c      ****                 {
3121:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3122:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3123:../uvc.c      **** #ifdef USB_LOWRES_IMG
3124:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3125:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3126:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3127:../uvc.c      **** #endif
3128:../uvc.c      **** #endif
3129:../uvc.c      ****                 }
3130:../uvc.c      **** 
3131:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3132:../uvc.c      ****                 prodCount++;
3133:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3134:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3135:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3136:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3137:../uvc.c      ****                 {
3138:../uvc.c      ****                     prodCount--;
3139:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3140:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3141:../uvc.c      ****                 }
3142:../uvc.c      ****             }
3143:../uvc.c      **** #endif
3144:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3145:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3147:../uvc.c      ****             {
3148:../uvc.c      ****             	if(0&&(prinflag == 0)){
3149:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3150:../uvc.c      ****             		prinflag = 1;
3151:../uvc.c      ****             	}
3152:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3153:../uvc.c      ****             	debugData[0][0]++;
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
3155:../uvc.c      ****             	fb=0;
3156:../uvc.c      ****             	pb=0;
3157:../uvc.c      ****             	pbc=0;
3158:../uvc.c      ****                 prodCount = 0;
3159:../uvc.c      ****                 consCount = 0;
3160:../uvc.c      ****                 hitFV     = CyFalse;
3161:../uvc.c      **** 
3162:../uvc.c      **** #ifdef BACKFLOW_DETECT
3163:../uvc.c      ****                 back_flow_detected = 0;
3164:../uvc.c      **** #endif
3165:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3166:../uvc.c      ****                 frameCnt++;
3167:../uvc.c      **** #endif
3168:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3169:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3170:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3171:../uvc.c      ****                 //}
3172:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3174:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3175:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3177:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3178:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3179:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3180:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3181:../uvc.c      ****                 		stiflag = 0xFF;
3182:../uvc.c      ****                 		IMcount = 0;
3183:../uvc.c      ****                 	}
3184:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3185:../uvc.c      **** 
3186:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3188:../uvc.c      ****                 		stiflag = 0x0F;
3189:../uvc.c      ****                 		IMcount = 0;
3190:../uvc.c      ****                 		}
3191:../uvc.c      ****                  		/*if(IMcount > 0x4){
3192:../uvc.c      ****                 			stiflag = 0x0F;
3193:../uvc.c      ****                 			IMcount = 0;
3194:../uvc.c      ****                 		}*/
3195:../uvc.c      **** 
3196:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3197:../uvc.c      ****                     //CyU3PThreadSleep(400);
3198:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3199:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3200:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3201:../uvc.c      **** 
3202:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3203:../uvc.c      ****                 	{
3204:../uvc.c      ****                     switch (setRes)
3205:../uvc.c      ****                      {
3206:../uvc.c      ****                  	case 1: //1944
3207:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3208:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3209:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3210:../uvc.c      ****                  		break;
3211:../uvc.c      ****                  	case 2: //1080
3212:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3213:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3214:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3215:../uvc.c      ****                  		break;
3216:../uvc.c      ****                  	case 3: //720
3217:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3218:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3219:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3220:../uvc.c      ****                  		break;
3221:../uvc.c      ****                  	case 4: //VGA
3222:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3223:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3224:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3225:../uvc.c      ****                  		break;
3226:../uvc.c      ****                  	default:
3227:../uvc.c      ****                  		break;
3228:../uvc.c      ****                      }
3229:../uvc.c      ****                     IMcount = 0;
3230:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3231:../uvc.c      ****                 	stiflag = 0x0;
3232:../uvc.c      ****                 	}
3233:../uvc.c      ****                 }
3234:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3235:../uvc.c      ****                 /* Reset the DMA channel. */
3236:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3237:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3238:../uvc.c      ****                 {
3239:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3240:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3241:../uvc.c      ****                 }
3242:../uvc.c      **** 
3243:../uvc.c      ****                 /* Start Channel Immediately */
3244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3245:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3246:../uvc.c      ****                 {
3247:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3248:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3249:../uvc.c      ****                 }
3250:../uvc.c      **** 
3251:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3252:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3253:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3254:../uvc.c      ****                 }
3255:../uvc.c      ****         }
3256:../uvc.c      ****         else
3257:../uvc.c      ****         {
3258:../uvc.c      ****             /* If we have a stream abort request pending. */
3259:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3260:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3261:../uvc.c      ****             {
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
3264:../uvc.c      ****             	hitFV     = CyFalse;
3265:../uvc.c      ****                 prodCount = 0;
3266:../uvc.c      ****                 consCount = 0;
3267:../uvc.c      ****                 if(0&&(prinflag == 0)){
3268:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3269:../uvc.c      ****                 	prinflag = 1;
3270:../uvc.c      ****                 }
3271:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3272:../uvc.c      ****                 fb=0;
3273:../uvc.c      ****                 pb=0;
3274:../uvc.c      ****                 pbc=0;
3275:../uvc.c      **** 
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3277:../uvc.c      ****                 {
3278:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3279:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3280:../uvc.c      ****                     {
3281:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3282:../uvc.c      ****                     }
3283:../uvc.c      **** 
3284:../uvc.c      ****                     /* Flush the Endpoint memory */
3285:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3286:../uvc.c      ****                 }else{
3287:../uvc.c      ****                     apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT
3288:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]&0x7F;
3289:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]|0x10;
3290:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3291:../uvc.c      ****                     {
3292:../uvc.c      ****                         CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus)
3293:../uvc.c      ****                     }
3294:../uvc.c      ****                     CyU3PDebugPrint (4, "clear feature stream set %x\n", apiRetStatus);
3295:../uvc.c      ****                 }
3296:../uvc.c      **** 
3297:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3298:../uvc.c      ****             }
3299:../uvc.c      ****             else
3300:../uvc.c      ****             {
3301:../uvc.c      **** #if 0
3302:../uvc.c      ****                 if(stream_start == CyTrue){
3303:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
3304:../uvc.c      ****                     		&flag, CYU3P_NO_WAIT != CY_U3P_SUCCESS)){
3305:../uvc.c      ****     					if(1||clearFeatureRqtReceived){
3306:../uvc.c      ****     						CyU3PThreadSleep(3000);
3307:../uvc.c      ****     						//if(stream_start == CyTrue){
3308:../uvc.c      ****     							streamingRecove = CyTrue;
3309:../uvc.c      ****     							debugData[1][1]++;
3310:../uvc.c      ****     						//}
3311:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
3312:../uvc.c      ****     						stream_start == CyFalse;
3313:../uvc.c      ****     					}
3314:../uvc.c      ****                     }
3315:../uvc.c      **** 
3316:../uvc.c      ****                 }
3317:../uvc.c      **** #endif
3318:../uvc.c      **** 
3319:../uvc.c      ****             	/* We are essentially idle at this point. Wait for the reception of a start streaming 
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
3323:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
3324:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
3325:../uvc.c      ****                     		CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
3326:../uvc.c      ****             	}
3327:../uvc.c      ****             	else
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
3329:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3330:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3331:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3332:../uvc.c      ****             	CyU3PDebugPrint (4, "post wait stream set %x\n", apiRetStatus);
3333:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3334:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3335:../uvc.c      ****                 {
3336:../uvc.c      ****                     /* Error handling */
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3338:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3339:../uvc.c      ****                 }
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
3342:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3344:../uvc.c      ****                 {
3345:../uvc.c      **** #if 0
3346:../uvc.c      ****                 	//for start up of the AF Lens
3347:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3348:../uvc.c      ****                     CyU3PThreadSleep(500);
3349:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3350:../uvc.c      ****                     CyU3PThreadSleep(500);
3351:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3352:../uvc.c      ****                    	CyU3PThreadSleep(300);
3353:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3354:../uvc.c      ****                     CyU3PThreadSleep(500);
3355:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3356:../uvc.c      ****                     CyU3PThreadSleep(500);
3357:../uvc.c      **** #endif
3358:../uvc.c      **** #if 0
3359:../uvc.c      ****                     if(streamingRecove){
3360:../uvc.c      ****                     switch (setRes)
3361:../uvc.c      ****                     {
3362:../uvc.c      ****                      	case 1: //1944
3363:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
3364:../uvc.c      ****                      		CyU3PThreadSleep(100);
3365:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
3366:../uvc.c      ****                      		break;
3367:../uvc.c      ****                      	case 2: //1080
3368:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
3369:../uvc.c      ****                      		CyU3PThreadSleep(100);
3370:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
3371:../uvc.c      ****                      		break;
3372:../uvc.c      ****                      	case 3: //720
3373:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
3374:../uvc.c      ****                      		CyU3PThreadSleep(100);
3375:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
3376:../uvc.c      ****                      		break;
3377:../uvc.c      ****                      	case 4: //VGA
3378:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
3379:../uvc.c      ****                      		CyU3PThreadSleep(100);
3380:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
3381:../uvc.c      ****                      		break;
3382:../uvc.c      ****                      	default:
3383:../uvc.c      ****                      		break;
3384:../uvc.c      **** 
3385:../uvc.c      ****                     }
3386:../uvc.c      ****                     streamingRecove = CyFalse;
3387:../uvc.c      ****                     }
3388:../uvc.c      **** #endif
3389:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3390:../uvc.c      **** 
3391:../uvc.c      ****                     gpif_initialized = CyTrue;
3392:../uvc.c      ****                     //stream_start = CyTrue;
3393:../uvc.c      ****                     CyU3PThreadSleep(200);
3394:../uvc.c      ****                     
3395:../uvc.c      ****                 }
3396:../uvc.c      ****                 else
3397:../uvc.c      ****                 {
3398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3401:../uvc.c      ****                 }
3402:../uvc.c      ****             }
3403:../uvc.c      ****         }
3404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3405:../uvc.c      **** 
3406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3407:../uvc.c      ****         CyU3PThreadRelinquish ();
3408:../uvc.c      ****     }
3409:../uvc.c      **** }
3410:../uvc.c      **** 
3411:../uvc.c      **** /*
3412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3413:../uvc.c      ****  */
3414:../uvc.c      **** 
3415:../uvc.c      **** static void
3416:../uvc.c      **** UVCHandleProcessingUnitRqts (
3417:../uvc.c      ****         void)
3418:../uvc.c      **** {
3419:../uvc.c      ****     uint8_t CtrlAdd;
3420:../uvc.c      **** #ifdef DbgInfo
3421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3422:../uvc.c      **** #endif
3423:../uvc.c      ****     switch (wValue)
3424:../uvc.c      ****     {
3425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3428:../uvc.c      ****     		break;
3429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3432:../uvc.c      ****     		break;
3433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3436:../uvc.c      **** 			break;
3437:../uvc.c      **** 
3438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3439:../uvc.c      **** 
3440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3443:../uvc.c      ****       		break;
3444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3446:../uvc.c      ****      		ControlHandle(HueCtlID5);
3447:../uvc.c      ****      		break;
3448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3451:../uvc.c      ****           		break;
3452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3455:../uvc.c      ****           		break;
3456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3461:../uvc.c      ****     		break;
3462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3465:../uvc.c      ****     		break;
3466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3469:../uvc.c      ****     		break;
3470:../uvc.c      **** 
3471:../uvc.c      ****         default:
3472:../uvc.c      ****             /*
3473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3474:../uvc.c      ****              * other controls.
3475:../uvc.c      ****              */
3476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3478:../uvc.c      ****             break;
3479:../uvc.c      ****     }
3480:../uvc.c      **** }
3481:../uvc.c      **** 
3482:../uvc.c      **** /*
3483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3484:../uvc.c      ****  */
3485:../uvc.c      **** static void
3486:../uvc.c      **** UVCHandleCameraTerminalRqts (
3487:../uvc.c      ****         void)
3488:../uvc.c      **** {
3489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3491:../uvc.c      ****     uint16_t readCount;
3492:../uvc.c      ****     uint16_t zoomVal;
3493:../uvc.c      ****     int32_t  panVal, tiltVal;
3494:../uvc.c      ****     CyBool_t sendData = CyFalse;
3495:../uvc.c      **** #endif
3496:../uvc.c      ****     uint8_t CtrlAdd;
3497:../uvc.c      **** 
3498:../uvc.c      ****     switch (wValue)
3499:../uvc.c      ****     {
3500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3503:../uvc.c      ****     		break;
3504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3507:../uvc.c      ****     		break;
3508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3511:../uvc.c      **** 			break;
3512:../uvc.c      **** 
3513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3516:../uvc.c      **** 			break;
3517:../uvc.c      **** 
3518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3521:../uvc.c      ****       		break;
3522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3525:../uvc.c      ****      		break;
3526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3529:../uvc.c      ****           		break;
3530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3531:../uvc.c      ****           		break;
3532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3535:../uvc.c      ****      		break;
3536:../uvc.c      **** 
3537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3540:../uvc.c      ****     		break;
3541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3544:../uvc.c      ****     		break;
3545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3548:../uvc.c      ****     		break;
3549:../uvc.c      **** 
3550:../uvc.c      ****         default:
3551:../uvc.c      ****             /*
3552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3553:../uvc.c      ****              * other controls.
3554:../uvc.c      ****              */
3555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3557:../uvc.c      ****             break;
3558:../uvc.c      ****     }
3559:../uvc.c      **** 
3560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3561:../uvc.c      ****     switch (wValue)
3562:../uvc.c      ****     {
3563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3564:../uvc.c      ****             switch (bRequest)
3565:../uvc.c      ****             {
3566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3569:../uvc.c      ****                     break;
3570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3572:../uvc.c      ****                     sendData = CyTrue;
3573:../uvc.c      ****                     break;
3574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3576:../uvc.c      ****                     sendData = CyTrue;
3577:../uvc.c      ****                     break;
3578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3580:../uvc.c      ****                     sendData = CyTrue;
3581:../uvc.c      ****                     break;
3582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3584:../uvc.c      ****                     sendData = CyTrue;
3585:../uvc.c      ****                     break;
3586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3588:../uvc.c      ****                     sendData = CyTrue;
3589:../uvc.c      ****                     break;
3590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3592:../uvc.c      ****                             glEp0Buffer, &readCount);
3593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3594:../uvc.c      ****                     {
3595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3597:../uvc.c      ****                     }
3598:../uvc.c      ****                     break;
3599:../uvc.c      ****                 default:
3600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3601:../uvc.c      ****                     break;
3602:../uvc.c      ****             }
3603:../uvc.c      **** 
3604:../uvc.c      ****             if (sendData)
3605:../uvc.c      ****             {
3606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3610:../uvc.c      ****             }
3611:../uvc.c      ****             break;
3612:../uvc.c      **** 
3613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3614:../uvc.c      ****             switch (bRequest)
3615:../uvc.c      ****             {
3616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3619:../uvc.c      ****                     break;
3620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3623:../uvc.c      ****                     sendData = CyTrue;
3624:../uvc.c      ****                     break;
3625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3628:../uvc.c      ****                     sendData = CyTrue;
3629:../uvc.c      ****                     break;
3630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3633:../uvc.c      ****                     sendData = CyTrue;
3634:../uvc.c      ****                     break;
3635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3638:../uvc.c      ****                     sendData = CyTrue;
3639:../uvc.c      ****                     break;
3640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3643:../uvc.c      ****                     sendData = CyTrue;
3644:../uvc.c      ****                     break;
3645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3647:../uvc.c      ****                             glEp0Buffer, &readCount);
3648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3649:../uvc.c      ****                     {
3650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3654:../uvc.c      **** 
3655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3657:../uvc.c      ****                     }
3658:../uvc.c      ****                     break;
3659:../uvc.c      ****                 default:
3660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3661:../uvc.c      ****                     break;
3662:../uvc.c      ****             }
3663:../uvc.c      **** 
3664:../uvc.c      ****             if (sendData)
3665:../uvc.c      ****             {
3666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3676:../uvc.c      ****             }
3677:../uvc.c      ****             break;
3678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3679:../uvc.c      ****         default:
3680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3681:../uvc.c      ****             break;
3682:../uvc.c      ****     }
3683:../uvc.c      **** #endif
3684:../uvc.c      **** }
3685:../uvc.c      **** 
3686:../uvc.c      **** /*
3687:../uvc.c      ****  * Handler for UVC Interface control requests.
3688:../uvc.c      ****  */
3689:../uvc.c      **** static void
3690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3691:../uvc.c      ****         void)
3692:../uvc.c      **** {
3693:../uvc.c      **** 	if(valIdx < 32){
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
3695:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
3696:../uvc.c      **** 		valIdx++;
3697:../uvc.c      **** 		value[0][1] = valIdx;
3698:../uvc.c      **** 	}
3699:../uvc.c      ****     switch (wValue)
3700:../uvc.c      ****     {
3701:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3702:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3703:../uvc.c      ****     		break;
3704:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3705:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3706:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3707:../uvc.c      ****     		break;
3708:../uvc.c      ****     	default:
3709:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3710:../uvc.c      ****      		break;
3711:../uvc.c      ****     }
3712:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3713:../uvc.c      **** 
3714:../uvc.c      **** }
3715:../uvc.c      **** 
3716:../uvc.c      **** /*
3717:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3718:../uvc.c      ****  */
3719:../uvc.c      **** static void
3720:../uvc.c      **** UVCHandleExtensionUnitRqts (
3721:../uvc.c      ****         void)
3722:../uvc.c      **** {
3723:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3724:../uvc.c      **** 
3725:../uvc.c      **** #ifdef DbgInfo
3726:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3727:../uvc.c      **** #endif
3728:../uvc.c      ****     switch (wValue)
3729:../uvc.c      ****     {
3730:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3731:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3732:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3733:../uvc.c      ****     		break;
3734:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3735:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3736:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3737:../uvc.c      ****     		break;
3738:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3739:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3740:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3741:../uvc.c      ****      		break;
3742:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3743:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3744:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3745:../uvc.c      ****     		break;
3746:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3747:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3748:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3749:../uvc.c      ****     		break;
3750:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3751:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3752:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3753:../uvc.c      ****      		break;
3754:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3755:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3756:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3757:../uvc.c      ****     		break;
3758:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3759:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3760:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3761:../uvc.c      ****     		break;
3762:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3763:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3764:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3765:../uvc.c      ****      		break;
3766:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3767:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3768:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3769:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3770:../uvc.c      ****     		}else/* no support for 1080p camera */
3771:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3772:../uvc.c      ****     		break;
3773:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3774:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3775:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3776:../uvc.c      ****     		break;
3777:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3778:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3779:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3780:../uvc.c      ****     		break;
3781:../uvc.c      **** 
3782:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3783:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3784:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3785:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3786:../uvc.c      ****     		break;
3787:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3788:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3789:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3790:../uvc.c      ****     		//break;
3791:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3792:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3793:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3794:../uvc.c      ****     		break;
3795:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3796:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3797:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3798:../uvc.c      ****     		break;
3799:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3800:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3801:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3802:../uvc.c      ****     		break;
3803:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3804:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3805:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3806:../uvc.c      ****     		break;
3807:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3808:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3809:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3810:../uvc.c      ****     		break;
3811:../uvc.c      ****    	default:
3812:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3813:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3814:../uvc.c      ****     		break;
3815:../uvc.c      ****     }
3816:../uvc.c      **** 
3817:../uvc.c      **** }
3818:../uvc.c      **** 
3819:../uvc.c      **** /*
3820:../uvc.c      ****  * Handler for the video streaming control requests.
3821:../uvc.c      ****  */
3822:../uvc.c      **** static void
3823:../uvc.c      **** UVCHandleVideoStreamingRqts (
3824:../uvc.c      ****         void)
3825:../uvc.c      **** {
3826:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3827:../uvc.c      ****     uint16_t readCount;
3828:../uvc.c      **** 
3829:../uvc.c      ****     switch (wValue)
3830:../uvc.c      ****     {
3831:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3832:../uvc.c      ****             switch (bRequest)
3833:../uvc.c      ****             {
3834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3835:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3836:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3837:../uvc.c      ****                     break;
3838:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3839:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3840:../uvc.c      ****                     glEp0Buffer[1] = 0;
3841:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3842:../uvc.c      ****                     break;
3843:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3844:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3845:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3846:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3847:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3848:../uvc.c      ****                     {
3849:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3850:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3851:../uvc.c      **** 
3852:../uvc.c      ****                     }
3853:../uvc.c      ****                     else
3854:../uvc.c      ****                     {
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3856:../uvc.c      ****                     }
3857:../uvc.c      ****                     break;
3858:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3859:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3860:../uvc.c      ****                             glCommitCtrl, &readCount);
3861:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3862:../uvc.c      ****                     {
3863:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3864:../uvc.c      ****                         {
3865:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3866:../uvc.c      ****                                active data structure. */
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3873:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3874:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3875:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3876:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3877:../uvc.c      **** #if 0
3878:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3879:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3880:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3881:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3882:../uvc.c      **** #endif
3883:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3884:../uvc.c      ****                        }
3885:../uvc.c      ****                     }
3886:../uvc.c      ****                     break;
3887:../uvc.c      ****                 default:
3888:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3889:../uvc.c      ****                     break;
3890:../uvc.c      ****             }
3891:../uvc.c      ****             break;
3892:../uvc.c      **** 
3893:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3894:../uvc.c      ****             switch (bRequest)
3895:../uvc.c      ****             {
3896:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3899:../uvc.c      ****                     break;
3900:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3901:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3902:../uvc.c      ****                     glEp0Buffer[1] = 0;
3903:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3904:../uvc.c      ****                     break;
3905:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3906:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3907:../uvc.c      ****                     {
3908:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3909:../uvc.c      ****                     }
3910:../uvc.c      ****                     else
3911:../uvc.c      ****                     {
3912:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3913:../uvc.c      ****                     }
3914:../uvc.c      ****                     break;
3915:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3916:../uvc.c      ****                     /* for error cover implementation */
3917:../uvc.c      ****                     CyU3PDebugPrint (4, "Clear feature request detected (fake)..\r\n");
3918:../uvc.c      **** 
3919:../uvc.c      ****                     /* Disable the GPIF state machine. */
3920:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
3921:../uvc.c      ****                     gpif_initialized = 0;
3922:../uvc.c      ****                     streamingStarted = CyFalse;
3923:../uvc.c      **** 
3924:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
3925:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3926:../uvc.c      ****                     CyU3PBusyWait (100);
3927:../uvc.c      **** 
3928:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
3929:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3930:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3931:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3932:../uvc.c      ****                     CyU3PBusyWait (100);
3933:../uvc.c      **** 
3934:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
3935:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3936:../uvc.c      **** 
3937:../uvc.c      ****                     //uvcHandleReq = CyTrue;
3938:../uvc.c      ****                     /* Complete Control request handshake */
3939:../uvc.c      ****                     CyU3PUsbAckSetup ();
3940:../uvc.c      ****                     /* Indicate stop streaming to main thread */
3941:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
3942:../uvc.c      ****                     //debugData[1][0] = debugData[1][0]|0x10; //set bit0
3943:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
3944:../uvc.c      ****                     /* end of the error cover implementation */
3945:../uvc.c      **** 
3946:../uvc.c      ****                 	/* The host has selected the parameters for the video stream. Check the desired
3947:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3948:../uvc.c      ****                        */
3949:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3950:../uvc.c      ****                             glCommitCtrl, &readCount);
3951:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3952:../uvc.c      ****                     {
3953:../uvc.c      ****                         switch (glCommitCtrl[3])
3954:../uvc.c      ****                          {
3955:../uvc.c      ****                          	case 1: //1944
3956:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3957:../uvc.c      ****                          		CyU3PThreadSleep(500);
3958:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3959:../uvc.c      ****                          		break;
3960:../uvc.c      ****                          	case 2: //1080
3961:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3962:../uvc.c      ****                          		CyU3PThreadSleep(500);
3963:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3964:../uvc.c      ****                          		break;
3965:../uvc.c      ****                          	case 3: //720
3966:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3967:../uvc.c      ****                          		CyU3PThreadSleep(500);
3968:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3969:../uvc.c      ****                          		break;
3970:../uvc.c      ****                          	case 4: //VGA
3971:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3972:../uvc.c      ****                          		CyU3PThreadSleep(500);
3973:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3974:../uvc.c      ****                          		break;
3975:../uvc.c      ****                          	default:
3976:../uvc.c      ****                          		break;
3977:../uvc.c      ****                          }
3978:../uvc.c      ****                         setRes = glCommitCtrl[3];
3979:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3980:../uvc.c      **** 
3981:../uvc.c      **** #if 0
3982:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3983:../uvc.c      ****                         {
3984:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3985:../uvc.c      ****                         }
3986:../uvc.c      ****                         else
3987:../uvc.c      ****                         {
3988:../uvc.c      ****                             SensorScaling_VGA ();
3989:../uvc.c      ****                         }
3990:../uvc.c      **** #endif
3991:../uvc.c      ****                         /* We can start streaming video now. */
3992:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3993:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3994:../uvc.c      ****                         {
3995:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3996:../uvc.c      ****                         }
3997:../uvc.c      ****                     }
3998:../uvc.c      ****                     break;
3999:../uvc.c      **** 
4000:../uvc.c      ****                 default:
4001:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4002:../uvc.c      ****                     break;
4003:../uvc.c      ****             }
4004:../uvc.c      ****             break;
4005:../uvc.c      **** 
4006:../uvc.c      **** /* still image streaming handler */
4007:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4008:../uvc.c      ****                 switch (bRequest)
4009:../uvc.c      ****                 {
4010:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4011:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4012:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4013:../uvc.c      ****                         break;
4014:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4015:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4016:../uvc.c      ****                         glEp0Buffer[1] = 0;
4017:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4018:../uvc.c      ****                         break;
4019:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4020:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4021:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4022:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4023:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4024:../uvc.c      ****                         {
4025:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4026:../uvc.c      ****                         }
4027:../uvc.c      ****                         else
4028:../uvc.c      ****                         {
4029:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4030:../uvc.c      ****                         }
4031:../uvc.c      ****                         break;
4032:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4033:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4034:../uvc.c      ****                                 glCommitCtrl, &readCount);
4035:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4036:../uvc.c      ****                         {
4037:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4038:../uvc.c      ****                             {
4039:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4040:../uvc.c      ****                                    active data structure. */
4041:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4042:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4043:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
4044:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
4045:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
4046:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
4047:../uvc.c      ****                             }
4048:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4049:../uvc.c      ****                         }
4050:../uvc.c      ****                         break;
4051:../uvc.c      ****                     default:
4052:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4053:../uvc.c      ****                         break;
4054:../uvc.c      ****                 }
4055:../uvc.c      ****                 break;
4056:../uvc.c      **** 
4057:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4058:../uvc.c      ****                 switch (bRequest)
4059:../uvc.c      ****                 {
4060:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4061:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4062:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4063:../uvc.c      ****                         break;
4064:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4065:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4066:../uvc.c      ****                         glEp0Buffer[1] = 0;
4067:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4068:../uvc.c      ****                         break;
4069:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4070:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4071:../uvc.c      ****                         {
4072:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4073:../uvc.c      ****                         }
4074:../uvc.c      ****                         else
4075:../uvc.c      ****                         {
4076:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4077:../uvc.c      ****                         }
4078:../uvc.c      ****                         break;
4079:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4080:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4081:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4082:../uvc.c      ****                            */
4083:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4084:../uvc.c      ****                                 glCommitCtrl, &readCount);
4085:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4086:../uvc.c      ****                         {
4087:../uvc.c      ****     #if 0
4088:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4089:../uvc.c      ****                             {
4090:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4091:../uvc.c      ****                             }
4092:../uvc.c      ****                             else
4093:../uvc.c      ****                             {
4094:../uvc.c      ****                                 SensorScaling_VGA ();
4095:../uvc.c      ****                             }
4096:../uvc.c      ****                             /* We can start streaming video now. */
4097:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4098:../uvc.c      **** 
4099:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4100:../uvc.c      ****                             {
4101:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4102:../uvc.c      ****                             }
4103:../uvc.c      **** 	#endif
4104:../uvc.c      ****                            switch (glCommitCtrl[1])
4105:../uvc.c      ****                              {
4106:../uvc.c      ****                              	case 4: //1944
4107:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4108:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4109:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4110:../uvc.c      ****                              		break;
4111:../uvc.c      ****                              	case 3: //1080
4112:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4113:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4114:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4115:../uvc.c      ****                              		break;
4116:../uvc.c      ****                              	case 2: //720
4117:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4118:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4119:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4120:../uvc.c      ****                              		break;
4121:../uvc.c      ****                             	case 1: //VGA
4122:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4123:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4124:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4125:../uvc.c      ****                              		break;
4126:../uvc.c      ****                               	default:
4127:../uvc.c      ****                              		break;
4128:../uvc.c      ****                              }
4129:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4130:../uvc.c      **** 
4131:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4132:../uvc.c      **** 
4133:../uvc.c      ****                         }
4134:../uvc.c      ****                         break;
4135:../uvc.c      **** 
4136:../uvc.c      ****                     default:
4137:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4138:../uvc.c      ****                         break;
4139:../uvc.c      ****                 }
4140:../uvc.c      ****                 break;
4141:../uvc.c      **** 
4142:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4143:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4144:../uvc.c      ****             	switch (bRequest)
4145:../uvc.c      ****                 {
4146:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4147:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4148:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4149:../uvc.c      ****                         break;
4150:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4151:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4152:../uvc.c      ****                         glEp0Buffer[1] = 0;
4153:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4154:../uvc.c      ****                         break;
4155:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4156:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4157:../uvc.c      ****                         {
4158:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4159:../uvc.c      ****                         }
4160:../uvc.c      ****                         else
4161:../uvc.c      ****                         {
4162:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4163:../uvc.c      ****                         }
4164:../uvc.c      ****                         break;
4165:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4166:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4167:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4168:../uvc.c      ****                            */
4169:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4170:../uvc.c      ****                                 glCommitCtrl, &readCount);
4171:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4172:../uvc.c      ****                         {
4173:../uvc.c      ****     #if 1
4174:../uvc.c      ****                             /* We can start still streaming video now. */
4175:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4176:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4177:../uvc.c      ****                             {
4178:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4179:../uvc.c      ****                             }
4180:../uvc.c      ****     #endif
4181:../uvc.c      ****                             else{
4182:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4183:../uvc.c      ****                             //stillcont = 0;
4184:../uvc.c      ****                             }
4185:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4186:../uvc.c      ****                         }else{
4187:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4188:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4189:../uvc.c      ****                         }
4190:../uvc.c      ****                         break;
4191:../uvc.c      **** 
4192:../uvc.c      ****                     default:
4193:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4194:../uvc.c      ****                         break;
4195:../uvc.c      ****                 }
4196:../uvc.c      ****                 break;
4197:../uvc.c      **** 
4198:../uvc.c      ****         default:
4199:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4200:../uvc.c      ****             break;
4201:../uvc.c      ****     }
4202:../uvc.c      **** }
4203:../uvc.c      **** 
4204:../uvc.c      **** /*
4205:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4206:../uvc.c      ****  */
4207:../uvc.c      **** void
4208:../uvc.c      **** UVCAppEP0Thread_Entry (
4209:../uvc.c      ****         uint32_t input)
4210:../uvc.c      **** {
4211:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4212:../uvc.c      ****     uint32_t eventFlag;
4213:../uvc.c      **** 	CyBool_t value;
4214:../uvc.c      **** 	CyBool_t *valueptr = &value;
4215:../uvc.c      **** 
4216:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4217:../uvc.c      **** 
4218:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4219:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4220:../uvc.c      **** 
4221:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4222:../uvc.c      **** #endif
4223:../uvc.c      **** 
4224:../uvc.c      ****     /* for interrupt status test */
4225:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4226:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4227:../uvc.c      **** 
4228:../uvc.c      ****     for (;;)
4229:../uvc.c      ****     {
4230:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4232:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4233:../uvc.c      ****         {
4234:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4235:../uvc.c      ****             if (!isUsbConnected)
4236:../uvc.c      ****             {
4237:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4238:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4239:../uvc.c      ****                 {
4240:../uvc.c      ****                     isUsbConnected = CyTrue;
4241:../uvc.c      ****                 }
4242:../uvc.c      ****             }
4243:../uvc.c      **** #ifdef DbgInfo
4244:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4245:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4246:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4247:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4248:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4249:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4250:../uvc.c      **** #endif
4251:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4252:../uvc.c      ****             {
4253:../uvc.c      ****             	switch ((wIndex >> 8))
4254:../uvc.c      ****                 {
4255:../uvc.c      **** 
4256:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4257:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4258:../uvc.c      ****                         break;
4259:../uvc.c      **** 
4260:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4261:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4262:../uvc.c      ****                         break;
4263:../uvc.c      **** 
4264:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4265:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4266:../uvc.c      ****                         break;
4267:../uvc.c      **** 
4268:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4269:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4270:../uvc.c      ****                         break;
4271:../uvc.c      **** 
4272:../uvc.c      ****                     default:
4273:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4274:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4275:../uvc.c      ****                         break;
4276:../uvc.c      ****                 }
4277:../uvc.c      ****             }
4278:../uvc.c      **** 
4279:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4280:../uvc.c      ****             {
4281:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4282:../uvc.c      **** 
4283:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4284:../uvc.c      ****                 {
4285:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4286:../uvc.c      ****                 }
4287:../uvc.c      ****                 else
4288:../uvc.c      ****                 {
4289:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4290:../uvc.c      ****                 }
4291:../uvc.c      ****             }
4292:../uvc.c      **** 
4293:../uvc.c      ****             /* handle interrupt status event */
4294:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4295:../uvc.c      ****             {
4296:../uvc.c      **** 
4297:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4298:../uvc.c      ****             	/** preparing interrupt status data **/
4299:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4300:../uvc.c      **** 
4301:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4302:../uvc.c      **** 
4303:../uvc.c      **** #if 0 //for real button
4304:../uvc.c      **** 				if(value&&(!snapButFlag)){
4305:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4306:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4307:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4308:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4309:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4310:../uvc.c      **** 
4311:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4312:../uvc.c      **** 					interStabuf.size   = 1024;
4313:../uvc.c      **** 					interStabuf.status = 0;
4314:../uvc.c      **** 
4315:../uvc.c      **** 					interStabuf.count = 4;
4316:../uvc.c      **** 
4317:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4318:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4319:../uvc.c      **** 
4320:../uvc.c      **** 					/** send a interrupt status data **/
4321:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4322:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4323:../uvc.c      **** 					{
4324:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4325:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4326:../uvc.c      **** 					}
4327:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4328:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4329:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4330:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4331:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4332:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4333:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4334:../uvc.c      **** 
4335:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4336:../uvc.c      **** 					interStabuf.size   = 1024;
4337:../uvc.c      **** 					interStabuf.status = 0;
4338:../uvc.c      **** 
4339:../uvc.c      **** 					interStabuf.count = 4;
4340:../uvc.c      **** 
4341:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4342:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4343:../uvc.c      **** 
4344:../uvc.c      **** 					/** send a interrupt status data **/
4345:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4346:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4347:../uvc.c      **** 					{
4348:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4349:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4350:../uvc.c      **** 					}
4351:../uvc.c      **** 
4352:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4353:../uvc.c      **** 					stiflag = 0xFF;
4354:../uvc.c      **** 				}
4355:../uvc.c      **** #else			//for botton simulation
4356:../uvc.c      **** 				if(snapButFlag == 0x0f){
4357:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4361:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4362:../uvc.c      **** 
4363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4364:../uvc.c      **** 					interStabuf.size   = 1024;
4365:../uvc.c      **** 					interStabuf.status = 0;
4366:../uvc.c      **** 
4367:../uvc.c      **** 					interStabuf.count = 4;
4368:../uvc.c      **** 
4369:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4371:../uvc.c      **** 
4372:../uvc.c      **** 					/** send a interrupt status data **/
4373:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4374:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4375:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4376:../uvc.c      **** 					{
4377:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4378:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4379:../uvc.c      **** 					}
4380:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4381:../uvc.c      **** 
4382:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4383:../uvc.c      **** 				}else if(!snapButFlag){
4384:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4385:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4387:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4389:../uvc.c      **** 
4390:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4391:../uvc.c      **** 					interStabuf.size   = 1024;
4392:../uvc.c      **** 					interStabuf.status = 0;
4393:../uvc.c      **** 
4394:../uvc.c      **** 					interStabuf.count = 4;
4395:../uvc.c      **** 
4396:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4397:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4398:../uvc.c      **** 
4399:../uvc.c      **** 					/** send a interrupt status data **/
4400:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4401:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4402:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4403:../uvc.c      **** 					{
4404:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4405:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4406:../uvc.c      **** 					}
4407:../uvc.c      **** 
4408:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4409:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4410:../uvc.c      **** 				}
4411:../uvc.c      **** #endif
4412:../uvc.c      **** 
4413:../uvc.c      ****             }
4414:../uvc.c      **** 
4415:../uvc.c      **** 
4416:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4417:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4418:../uvc.c      ****             {
4419:../uvc.c      ****                 /* Get the command buffer */
4420:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4421:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4422:../uvc.c      ****                 {
4423:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4424:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4425:../uvc.c      ****                 }
4426:../uvc.c      **** 
4427:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4428:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4429:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4430:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4431:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4432:../uvc.c      ****                  * register value high byte and register value low byte.
4433:../uvc.c      ****                  */
4434:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4435:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4436:../uvc.c      ****                 {
4437:../uvc.c      ****                     if (dmaInfo.count == 3)
4438:../uvc.c      ****                     {
4439:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4440:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4441:../uvc.c      ****                         dmaInfo.count = 3;
4442:../uvc.c      ****                     }
4443:../uvc.c      ****                     else if (dmaInfo.count == 4)
4444:../uvc.c      ****                     {
4445:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4446:../uvc.c      ****                         {
4447:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4448:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4449:../uvc.c      ****                         }
4450:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4451:../uvc.c      ****                     }
4452:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4453:../uvc.c      ****                 }
4454:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4455:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4456:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4457:../uvc.c      ****                  */
4458:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4459:../uvc.c      ****                 {
4460:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4461:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4462:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4463:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4464:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4465:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4466:../uvc.c      ****                         	break;
4467:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4468:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4469:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4470:../uvc.c      ****                         	break;*/
4471:../uvc.c      ****                     dmaInfo.count -= 2;
4472:../uvc.c      ****                 }
4473:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4474:../uvc.c      ****                 else
4475:../uvc.c      ****                 {
4476:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4477:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4478:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4479:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4480:../uvc.c      ****                 }
4481:../uvc.c      **** 
4482:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4483:../uvc.c      ****                 dmaInfo.size   = 1024;
4484:../uvc.c      ****                 dmaInfo.status = 0;
4485:../uvc.c      **** 
4486:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4487:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4488:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4489:../uvc.c      ****                 {
4490:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4491:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4492:../uvc.c      ****                 }
4493:../uvc.c      **** 
4494:../uvc.c      ****                 /* Wait until the response has gone out. */
4495:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4496:../uvc.c      **** 
4497:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4498:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4499:../uvc.c      ****                 {
4500:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4501:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4502:../uvc.c      ****                 }
4503:../uvc.c      ****             }
4504:../uvc.c      **** #endif
4505:../uvc.c      ****         }
4506:../uvc.c      ****         /* Allow other ready threads to run. */
4507:../uvc.c      ****         CyU3PThreadRelinquish ();
4508:../uvc.c      ****     }
4509:../uvc.c      **** }
4510:../uvc.c      **** 
4511:../uvc.c      **** /*
4512:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4513:../uvc.c      ****  * added 10/2013
4514:../uvc.c      ****  */
4515:../uvc.c      **** /*
4516:../uvc.c      **** static uint8_t timeDelay[64] = {
4517:../uvc.c      **** 
4518:../uvc.c      **** };
4519:../uvc.c      **** */
4520:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  68              		.loc 1 4520 0
  69              		.cfi_startproc
  70              		@ args = 0, pretend = 0, frame = 8
  71              		@ frame_needed = 0, uses_anonymous_args = 0
  72              	.LVL4:
  73 003c F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
  74              	.LCFI1:
  75              		.cfi_def_cfa_offset 28
  76              		.cfi_offset 4, -28
  77              		.cfi_offset 5, -24
  78              		.cfi_offset 6, -20
  79              		.cfi_offset 7, -16
  80              		.cfi_offset 8, -12
  81              		.cfi_offset 9, -8
  82              		.cfi_offset 14, -4
4521:../uvc.c      **** 
4522:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4523:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4524:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4525:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4526:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4527:../uvc.c      **** 	uint32_t flag = 0;
4528:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4529:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4530:../uvc.c      **** 	uint8_t i;
4531:../uvc.c      **** 	uint16_t delaytime;
4532:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4533:../uvc.c      **** 
4534:../uvc.c      **** #if 0 //for test the command queue
4535:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4536:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4537:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4538:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4539:../uvc.c      **** 		lcCmdDes += 1;
4540:../uvc.c      **** 	}
4541:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4542:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4543:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4544:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4545:../uvc.c      **** 		lcCmdDes += 1;
4546:../uvc.c      **** 	}
4547:../uvc.c      **** 
4548:../uvc.c      **** #endif
4549:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4550:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  83              		.loc 1 4550 0
  84 0040 34029FE5 		ldr	r0, .L31
  85              	.LVL5:
4520:../uvc.c      **** 
  86              		.loc 1 4520 0
  87 0044 1CD04DE2 		sub	sp, sp, #28
  88              	.LCFI2:
  89              		.cfi_def_cfa_offset 56
4527:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  90              		.loc 1 4527 0
  91 0048 00C0A0E3 		mov	ip, #0
  92              		.loc 1 4550 0
  93 004c FA2FA0E3 		mov	r2, #1000
  94 0050 2C30A0E3 		mov	r3, #44
  95 0054 0C10A0E1 		mov	r1, ip
  96 0058 04C08DE5 		str	ip, [sp, #4]
  97 005c 08C08DE5 		str	ip, [sp, #8]
  98 0060 00208DE5 		str	r2, [sp]
  99 0064 0C308DE5 		str	r3, [sp, #12]
 100 0068 10229FE5 		ldr	r2, .L31+4
 101 006c 0B30A0E3 		mov	r3, #11
4527:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 102              		.loc 1 4527 0
 103 0070 14C08DE5 		str	ip, [sp, #20]
 104              	.LVL6:
 105              		.loc 1 4550 0
 106 0074 FEFFFFEB 		bl	_txe_timer_create
 107              	.LVL7:
4551:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 108              		.loc 1 4551 0
 109 0078 FEFFFFEB 		bl	_tx_time_get
 110              	.LVL8:
4552:../uvc.c      **** 	CyU3PThreadSleep(50);
4553:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
4554:../uvc.c      **** 
4555:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 111              		.loc 1 4555 0
 112 007c 00529FE5 		ldr	r5, .L31+8
4551:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 113              		.loc 1 4551 0
 114 0080 00129FE5 		ldr	r1, .L31+12
 115 0084 0020A0E1 		mov	r2, r0
 116 0088 0400A0E3 		mov	r0, #4
 117 008c FEFFFFEB 		bl	CyU3PDebugPrint
 118              	.LVL9:
4552:../uvc.c      **** 	CyU3PThreadSleep(50);
 119              		.loc 1 4552 0
 120 0090 3200A0E3 		mov	r0, #50
 121 0094 FEFFFFEB 		bl	_tx_thread_sleep
 122              	.LVL10:
4553:../uvc.c      **** 
 123              		.loc 1 4553 0
 124 0098 DC019FE5 		ldr	r0, .L31
 125 009c FEFFFFEB 		bl	_txe_timer_activate
 126              	.LVL11:
 127              		.loc 1 4555 0
 128 00a0 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 129 00a4 000052E3 		cmp	r2, #0
 130 00a8 0300001A 		bne	.L5
 131              	.L6:
4556:../uvc.c      ****         /* Allow other ready threads to run. */
4557:../uvc.c      **** 
4558:../uvc.c      ****         CyU3PThreadRelinquish ();
 132              		.loc 1 4558 0
 133 00ac FEFFFFEB 		bl	_txe_thread_relinquish
 134              	.LVL12:
4555:../uvc.c      ****         /* Allow other ready threads to run. */
 135              		.loc 1 4555 0
 136 00b0 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 137 00b4 000052E3 		cmp	r2, #0
 138 00b8 FBFFFF0A 		beq	.L6
 139              	.L5:
4559:../uvc.c      **** 	}
4560:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 140              		.loc 1 4560 0
 141 00bc 103095E5 		ldr	r3, [r5, #16]
 142 00c0 0400A0E3 		mov	r0, #4
 143 00c4 3C3093E5 		ldr	r3, [r3, #60]
 144 00c8 BC119FE5 		ldr	r1, .L31+16
 145 00cc FEFFFFEB 		bl	CyU3PDebugPrint
 146              	.LVL13:
 147 00d0 B8619FE5 		ldr	r6, .L31+20
 148 00d4 B8819FE5 		ldr	r8, .L31+24
4561:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4562:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4563:../uvc.c      **** 	//CyU3PThreadSleep(100);
4564:../uvc.c      **** 	//SetCurCmd();
4565:../uvc.c      **** 	/*********** the loop of the thread ***********/
4566:../uvc.c      **** 	for(;;){
4567:../uvc.c      **** 
4568:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 149              		.loc 1 4568 0
 150 00d8 0070E0E3 		mvn	r7, #0
 151              	.L23:
 152 00dc 14308DE2 		add	r3, sp, #20
 153 00e0 2010A0E3 		mov	r1, #32
 154 00e4 0320A0E3 		mov	r2, #3
 155 00e8 00708DE5 		str	r7, [sp]
 156 00ec A4019FE5 		ldr	r0, .L31+28
 157 00f0 FEFFFFEB 		bl	_txe_event_flags_get
 158              	.LVL14:
4569:../uvc.c      **** /*  // for test GPIO output
4570:../uvc.c      **** 		if(trigger)
4571:../uvc.c      **** 		{
4572:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4573:../uvc.c      **** 			{
4574:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4575:../uvc.c      **** 			}
4576:../uvc.c      **** 
4577:../uvc.c      **** 		}else{
4578:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4579:../uvc.c      **** 			{
4580:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4581:../uvc.c      **** 			}
4582:../uvc.c      **** 
4583:../uvc.c      **** 		}
4584:../uvc.c      **** */
4585:../uvc.c      **** 		if(0&&streamingRecove){//start stream again after the USB-pipe reset
4586:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
4587:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
4588:../uvc.c      **** 
4589:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
4590:../uvc.c      ****             {
4591:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
4592:../uvc.c      ****             }
4593:../uvc.c      **** 		}
4594:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 159              		.loc 1 4594 0
 160 00f4 1C0096E5 		ldr	r0, [r6, #28]
 161 00f8 0010E0E3 		mvn	r1, #0
 162 00fc FEFFFFEB 		bl	_txe_mutex_get
 163              	.LVL15:
4595:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4596:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4597:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4598:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4599:../uvc.c      **** 				i = 0;
4600:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 164              		.loc 1 4600 0
 165 0100 103096E5 		ldr	r3, [r6, #16]
 166 0104 3C3093E5 		ldr	r3, [r3, #60]
 167 0108 000053E3 		cmp	r3, #0
 168 010c 0300001A 		bne	.L7
 169 0110 4030A0E3 		mov	r3, #64
 170              	.LVL16:
 171              	.L8:
 172 0114 013043E2 		sub	r3, r3, #1
 173 0118 FF3013E2 		ands	r3, r3, #255
 174 011c FCFFFF1A 		bne	.L8
 175              	.LVL17:
 176              	.L7:
4601:../uvc.c      **** 					i++;
4602:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4603:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4604:../uvc.c      **** 				}
4605:../uvc.c      **** #if 0
4606:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4607:../uvc.c      **** 				i = lcStaDes->curNum;
4608:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4609:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4610:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4611:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4612:../uvc.c      **** 
4613:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4614:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4615:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4616:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4617:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4618:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4619:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4620:../uvc.c      **** #endif
4621:../uvc.c      **** 				//}
4622:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4623:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4624:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4625:../uvc.c      **** 				/* setting delay */
4626:../uvc.c      **** 				delaytime = 300;
4627:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4628:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4629:../uvc.c      **** 			} //end of the if condition statment
4630:../uvc.c      **** #endif
4631:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 177              		.loc 1 4631 0
 178 0120 1C0096E5 		ldr	r0, [r6, #28]
 179 0124 FEFFFFEB 		bl	_txe_mutex_put
 180              	.LVL18:
4632:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4633:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 181              		.loc 1 4633 0
 182 0128 1C0095E5 		ldr	r0, [r5, #28]
 183 012c 0010E0E3 		mvn	r1, #0
 184 0130 FEFFFFEB 		bl	_txe_mutex_get
 185              	.LVL19:
4634:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 186              		.loc 1 4634 0
 187 0134 104095E5 		ldr	r4, [r5, #16]
 188              	.LVL20:
4635:../uvc.c      **** 
4636:../uvc.c      **** 				/*
4637:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4638:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4639:../uvc.c      **** 				*/
4640:../uvc.c      **** 
4641:../uvc.c      **** 				/* find a available command */
4642:../uvc.c      **** 				i = 0;
4643:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 189              		.loc 1 4643 0
 190 0138 3C3094E5 		ldr	r3, [r4, #60]
 191 013c 000053E3 		cmp	r3, #0
 192 0140 0900001A 		bne	.L9
 193 0144 4020A0E3 		mov	r2, #64
 194 0148 010000EA 		b	.L12
 195              	.LVL21:
 196              	.L10:
 197              		.loc 1 4643 0 is_stmt 0 discriminator 2
 198 014c FF2012E2 		ands	r2, r2, #255
 199 0150 3100000A 		beq	.L29
 200              	.L12:
4644:../uvc.c      **** 					i++;
4645:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 201              		.loc 1 4645 0 is_stmt 1
 202 0154 344094E5 		ldr	r4, [r4, #52]
 203              	.LVL22:
 204 0158 012042E2 		sub	r2, r2, #1
4643:../uvc.c      **** 					i++;
 205              		.loc 1 4643 0
 206 015c 3C3094E5 		ldr	r3, [r4, #60]
 207 0160 000053E3 		cmp	r3, #0
 208 0164 F8FFFF0A 		beq	.L10
 209 0168 104085E5 		str	r4, [r5, #16]
 210              	.L9:
 211              	.LVL23:
 212 016c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4646:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4647:../uvc.c      **** 				}
4648:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4649:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4650:../uvc.c      **** 					i = lcCmdDes->curNum;
4651:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4652:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4653:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4654:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4655:../uvc.c      **** #if 1
4656:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 213              		.loc 1 4656 0
 214 0170 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 215 0174 833083E0 		add	r3, r3, r3, asl #1
 216 0178 833084E0 		add	r3, r4, r3, asl #1
 217 017c 20C04CE2 		sub	ip, ip, #32
4651:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 218              		.loc 1 4651 0
 219 0180 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 220              	.LVL24:
4652:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 221              		.loc 1 4652 0
 222 0184 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 223              	.LVL25:
4653:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 224              		.loc 1 4653 0
 225 0188 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 226              	.LVL26:
4654:../uvc.c      **** #if 1
 227              		.loc 1 4654 0
 228 018c B890D3E1 		ldrh	r9, [r3, #8]
 229              	.LVL27:
 230              		.loc 1 4656 0
 231 0190 03005CE3 		cmp	ip, #3
 232 0194 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 233 0198 340000EA 		b	.L18
 234              	.L24:
 235 019c 0C020000 		.word	.L13
 236 01a0 FC010000 		.word	.L15
 237 01a4 AC010000 		.word	.L17
 238 01a8 AC010000 		.word	.L17
 239              	.L17:
4657:../uvc.c      **** 						case 0x20:
4658:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4659:../uvc.c      **** 							delaytime = 500;
4660:../uvc.c      **** 							break;
4661:../uvc.c      **** 						case 0x21:
4662:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4663:../uvc.c      **** 							delaytime = 500;
4664:../uvc.c      **** 							break;
4665:../uvc.c      **** 						case 0x22:
4666:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4667:../uvc.c      **** 							delaytime = 300;
4668:../uvc.c      **** 							break;
4669:../uvc.c      **** 						case 0x23:
4670:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 240              		.loc 1 4670 0
 241 01ac 8230A0E3 		mov	r3, #130
 242              	.LVL28:
 243 01b0 FEFFFFEB 		bl	SensorSetIrisControl
 244              	.LVL29:
4671:../uvc.c      **** 							delaytime = 300;
4672:../uvc.c      **** 							break;
 245              		.loc 1 4672 0
 246 01b4 4B1FA0E3 		mov	r1, #300
 247              	.LVL30:
 248              	.L14:
4673:../uvc.c      **** 						default:
4674:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4675:../uvc.c      **** 							break;
4676:../uvc.c      **** 					}
4677:../uvc.c      **** #endif
4678:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4679:../uvc.c      **** 					/** timer's ticket modify **/
4680:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4681:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 249              		.loc 1 4681 0
 250 01b8 0020A0E3 		mov	r2, #0
 251 01bc B8009FE5 		ldr	r0, .L31
 252 01c0 FEFFFFEB 		bl	_txe_timer_change
 253              	.LVL31:
4682:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 254              		.loc 1 4682 0
 255 01c4 B0009FE5 		ldr	r0, .L31
 256 01c8 FEFFFFEB 		bl	_txe_timer_activate
 257              	.LVL32:
4683:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4684:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4685:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4686:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4687:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4688:../uvc.c      **** #endif
4689:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 258              		.loc 1 4689 0
 259 01cc 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 260 01d0 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 261 01d4 030052E1 		cmp	r2, r3
 262 01d8 1600000A 		beq	.L30
4690:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4691:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4692:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4693:../uvc.c      **** 						}else{
4694:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4695:../uvc.c      **** 						}
4696:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4697:../uvc.c      **** 					}else{
4698:../uvc.c      **** 						lcCmdDes->curNum ++;
 263              		.loc 1 4698 0
 264 01dc 013083E2 		add	r3, r3, #1
4699:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 265              		.loc 1 4699 0
 266 01e0 0F20A0E3 		mov	r2, #15
4698:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 267              		.loc 1 4698 0
 268 01e4 0130C4E5 		strb	r3, [r4, #1]
 269              		.loc 1 4699 0
 270 01e8 3C2084E5 		str	r2, [r4, #60]
 271              	.LVL33:
 272              	.L22:
4700:../uvc.c      **** 					}
4701:../uvc.c      **** 				}else{
4702:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4703:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4704:../uvc.c      **** 				}
4705:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 273              		.loc 1 4705 0
 274 01ec 1C0095E5 		ldr	r0, [r5, #28]
 275 01f0 FEFFFFEB 		bl	_txe_mutex_put
 276              	.LVL34:
4706:../uvc.c      **** 			}
4707:../uvc.c      **** /*
4708:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4709:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4710:../uvc.c      **** */
4711:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4712:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4713:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4714:../uvc.c      **** #endif
4715:../uvc.c      **** 
4716:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4717:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4718:../uvc.c      **** #if 0
4719:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4720:../uvc.c      **** 
4721:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4722:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4723:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4724:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4725:../uvc.c      **** 			    i = 0;
4726:../uvc.c      **** 				 switch(cmdCopyIdx)
4727:../uvc.c      **** 				 {
4728:../uvc.c      **** 					 case BrgtCtlID1:
4729:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4730:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4731:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4733:../uvc.c      **** 							 i++;
4734:../uvc.c      **** 						 }
4735:../uvc.c      **** 						 else{
4736:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4737:../uvc.c      **** 						 }
4738:../uvc.c      **** 
4739:../uvc.c      **** 						 CyU3PBusyWait(500);
4740:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4741:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4743:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4745:../uvc.c      **** 						 }
4746:../uvc.c      **** 						 else{
4747:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4748:../uvc.c      **** 						 }
4749:../uvc.c      **** 						 break;
4750:../uvc.c      **** 					 case HueCtlID5:
4751:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4752:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4753:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4754:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4755:../uvc.c      **** 						 }
4756:../uvc.c      **** 						 else{
4757:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4758:../uvc.c      **** 						 }
4759:../uvc.c      **** 						 break;
4760:../uvc.c      **** 					 case SaturCtlID6:
4761:../uvc.c      **** 					 case WBTLevCtlID10:
4762:../uvc.c      **** 					 default:
4763:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4765:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4767:../uvc.c      **** 						 }
4768:../uvc.c      **** 						 else{
4769:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4770:../uvc.c      **** 						 }
4771:../uvc.c      **** 						 break;
4772:../uvc.c      **** 				 }
4773:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4774:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4775:../uvc.c      **** 			}
4776:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4777:../uvc.c      **** #endif
4778:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4779:../uvc.c      **** 		/* Allow other ready threads to run. */
4780:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4781:../uvc.c      **** 			CyU3PThreadRelinquish ();
 277              		.loc 1 4781 0
 278 01f4 FEFFFFEB 		bl	_txe_thread_relinquish
 279              	.LVL35:
4782:../uvc.c      **** 		}
 280              		.loc 1 4782 0
 281 01f8 B7FFFFEA 		b	.L23
 282              	.LVL36:
 283              	.L15:
4662:../uvc.c      **** 							delaytime = 500;
 284              		.loc 1 4662 0
 285 01fc 5230A0E3 		mov	r3, #82
 286              	.LVL37:
 287 0200 FEFFFFEB 		bl	SensorSetIrisControl
 288              	.LVL38:
4664:../uvc.c      **** 						case 0x22:
 289              		.loc 1 4664 0
 290 0204 7D1FA0E3 		mov	r1, #500
 291 0208 EAFFFFEA 		b	.L14
 292              	.LVL39:
 293              	.L13:
4658:../uvc.c      **** 							delaytime = 500;
 294              		.loc 1 4658 0
 295 020c 8230A0E3 		mov	r3, #130
 296              	.LVL40:
 297 0210 FEFFFFEB 		bl	SensorSetIrisControl
 298              	.LVL41:
4660:../uvc.c      **** 						case 0x21:
 299              		.loc 1 4660 0
 300 0214 7D1FA0E3 		mov	r1, #500
 301 0218 E6FFFFEA 		b	.L14
 302              	.LVL42:
 303              	.L29:
4702:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 304              		.loc 1 4702 0
 305 021c FA1FA0E3 		mov	r1, #1000
 306 0220 54009FE5 		ldr	r0, .L31
 307 0224 104085E5 		str	r4, [r5, #16]
 308 0228 FEFFFFEB 		bl	_txe_timer_change
 309              	.LVL43:
4703:../uvc.c      **** 				}
 310              		.loc 1 4703 0
 311 022c 48009FE5 		ldr	r0, .L31
 312 0230 FEFFFFEB 		bl	_txe_timer_activate
 313              	.LVL44:
 314 0234 ECFFFFEA 		b	.L22
 315              	.LVL45:
 316              	.L30:
4691:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 317              		.loc 1 4691 0
 318 0238 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
4690:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 319              		.loc 1 4690 0
 320 023c 0020A0E3 		mov	r2, #0
4691:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 321              		.loc 1 4691 0
 322 0240 230053E3 		cmp	r3, #35
4692:../uvc.c      **** 						}else{
 323              		.loc 1 4692 0
 324 0244 24304382 		subhi	r3, r3, #36
 325 0248 83308380 		addhi	r3, r3, r3, asl #1
4694:../uvc.c      **** 						}
 326              		.loc 1 4694 0
 327 024c 83308390 		addls	r3, r3, r3, asl #1
4692:../uvc.c      **** 						}else{
 328              		.loc 1 4692 0
 329 0250 83318880 		addhi	r3, r8, r3, asl #3
4694:../uvc.c      **** 						}
 330              		.loc 1 4694 0
 331 0254 83318890 		addls	r3, r8, r3, asl #3
4692:../uvc.c      **** 						}else{
 332              		.loc 1 4692 0
 333 0258 1020C385 		strhib	r2, [r3, #16]
4694:../uvc.c      **** 						}
 334              		.loc 1 4694 0
 335 025c 9021C395 		strlsb	r2, [r3, #400]
4696:../uvc.c      **** 					}else{
 336              		.loc 1 4696 0
 337 0260 343094E5 		ldr	r3, [r4, #52]
4690:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 338              		.loc 1 4690 0
 339 0264 3C2084E5 		str	r2, [r4, #60]
4696:../uvc.c      **** 					}else{
 340              		.loc 1 4696 0
 341 0268 103085E5 		str	r3, [r5, #16]
 342 026c DEFFFFEA 		b	.L22
 343              	.LVL46:
 344              	.L18:
4674:../uvc.c      **** 							break;
 345              		.loc 1 4674 0
 346 0270 FEFFFFEB 		bl	SensorSetControl
 347              	.LVL47:
 348 0274 0910A0E1 		mov	r1, r9
4675:../uvc.c      **** 					}
 349              		.loc 1 4675 0
 350 0278 CEFFFFEA 		b	.L14
 351              	.L32:
 352              		.align	2
 353              	.L31:
 354 027c 00000000 		.word	I2CCmdTimer
 355 0280 00000000 		.word	I2CCmdCb
 356 0284 00000000 		.word	cmdQu
 357 0288 18000000 		.word	.LC1
 358 028c 2C000000 		.word	.LC2
 359 0290 00000000 		.word	statQu
 360 0294 00000000 		.word	.LANCHOR1
 361 0298 00000000 		.word	.LANCHOR0
 362              		.cfi_endproc
 363              	.LFE27:
 365              		.align	2
 367              	CyFxUvcAppDebugCallback:
 368              	.LFB16:
2599:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 369              		.loc 1 2599 0
 370              		.cfi_startproc
 371              		@ args = 0, pretend = 0, frame = 0
 372              		@ frame_needed = 0, uses_anonymous_args = 0
 373              		@ link register save eliminated.
 374              	.LVL48:
2600:../uvc.c      ****     {
 375              		.loc 1 2600 0
 376 029c 080051E3 		cmp	r1, #8
 377 02a0 1EFF2F11 		bxne	lr
 378              	.LVL49:
 379              	.LBB4:
 380              	.LBB5:
2603:../uvc.c      ****     }
 381              		.loc 1 2603 0
 382 02a4 08009FE5 		ldr	r0, .L35
 383              	.LVL50:
 384 02a8 1010A0E3 		mov	r1, #16
 385              	.LVL51:
 386 02ac 0020A0E3 		mov	r2, #0
 387              	.LVL52:
 388 02b0 FEFFFFEA 		b	_txe_event_flags_set
 389              	.LVL53:
 390              	.L36:
 391              		.align	2
 392              	.L35:
 393 02b4 00000000 		.word	.LANCHOR0
 394              	.LBE5:
 395              	.LBE4:
 396              		.cfi_endproc
 397              	.LFE16:
 399              		.align	2
 401              	UVCHandleVideoStreamingRqts:
 402              	.LFB25:
3825:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 403              		.loc 1 3825 0
 404              		.cfi_startproc
 405              		@ args = 0, pretend = 0, frame = 8
 406              		@ frame_needed = 0, uses_anonymous_args = 0
 407              	.LVL54:
3829:../uvc.c      ****     {
 408              		.loc 1 3829 0
 409 02b8 8C379FE5 		ldr	r3, .L166
3825:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 410              		.loc 1 3825 0
 411 02bc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 412              	.LCFI3:
 413              		.cfi_def_cfa_offset 16
 414              		.cfi_offset 4, -16
 415              		.cfi_offset 5, -12
 416              		.cfi_offset 6, -8
 417              		.cfi_offset 14, -4
3829:../uvc.c      ****     {
 418              		.loc 1 3829 0
 419 02c0 B030D3E1 		ldrh	r3, [r3]
3825:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 420              		.loc 1 3825 0
 421 02c4 10D04DE2 		sub	sp, sp, #16
 422              	.LCFI4:
 423              		.cfi_def_cfa_offset 32
3829:../uvc.c      ****     {
 424              		.loc 1 3829 0
 425 02c8 030C53E3 		cmp	r3, #768
 426 02cc 4500000A 		beq	.L39
 427 02d0 1300008A 		bhi	.L40
 428 02d4 010C53E3 		cmp	r3, #256
 429 02d8 2E00000A 		beq	.L41
 430 02dc 020C53E3 		cmp	r3, #512
 431 02e0 2600001A 		bne	.L38
3894:../uvc.c      ****             {
 432              		.loc 1 3894 0
 433 02e4 64379FE5 		ldr	r3, .L166+4
 434 02e8 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 435 02ec 810055E3 		cmp	r5, #129
 436 02f0 7E00000A 		beq	.L56
 437 02f4 8500009A 		bls	.L159
 438 02f8 850055E3 		cmp	r5, #133
 439 02fc 2F00000A 		beq	.L89
 440              	.L157:
4144:../uvc.c      ****                 {
 441              		.loc 1 4144 0
 442 0300 860055E3 		cmp	r5, #134
 443 0304 1D00001A 		bne	.L38
 444              	.L154:
4147:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 445              		.loc 1 4147 0
 446 0308 44179FE5 		ldr	r1, .L166+8
 447 030c 0330A0E3 		mov	r3, #3
 448 0310 2830E1E5 		strb	r3, [r1, #40]!
4148:../uvc.c      ****                         break;
 449              		.loc 1 4148 0
 450 0314 0100A0E3 		mov	r0, #1
 451 0318 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 452              	.LVL55:
4202:../uvc.c      **** 
 453              		.loc 1 4202 0
 454 031c 10D08DE2 		add	sp, sp, #16
 455              		@ sp needed
 456 0320 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 457              	.L40:
3829:../uvc.c      ****     {
 458              		.loc 1 3829 0
 459 0324 010B53E3 		cmp	r3, #1024
 460 0328 0B00000A 		beq	.L43
 461 032c 050C53E3 		cmp	r3, #1280
 462 0330 1200001A 		bne	.L38
4144:../uvc.c      ****                 {
 463              		.loc 1 4144 0
 464 0334 14379FE5 		ldr	r3, .L166+4
 465 0338 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 466 033c 810055E3 		cmp	r5, #129
 467 0340 6A00000A 		beq	.L56
 468 0344 C200009A 		bls	.L160
 469 0348 850055E3 		cmp	r5, #133
 470 034c EBFFFF1A 		bne	.L157
4151:../uvc.c      ****                         glEp0Buffer[1] = 0;
 471              		.loc 1 4151 0
 472 0350 FC369FE5 		ldr	r3, .L166+8
 473 0354 01C0A0E3 		mov	ip, #1
 474 0358 1A0000EA 		b	.L155
 475              	.L43:
4058:../uvc.c      ****                 {
 476              		.loc 1 4058 0
 477 035c EC369FE5 		ldr	r3, .L166+4
 478 0360 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 479 0364 810053E3 		cmp	r3, #129
 480 0368 2600000A 		beq	.L78
 481 036c A600009A 		bls	.L161
 482 0370 850053E3 		cmp	r3, #133
 483 0374 1100000A 		beq	.L89
 484 0378 860053E3 		cmp	r3, #134
 485 037c E1FFFF0A 		beq	.L154
 486              	.L38:
4199:../uvc.c      ****             break;
 487              		.loc 1 4199 0
 488 0380 0000A0E3 		mov	r0, #0
 489 0384 0020A0E1 		mov	r2, r0
 490 0388 0110A0E3 		mov	r1, #1
 491 038c FEFFFFEB 		bl	CyU3PUsbStall
 492              	.LVL56:
 493              	.L37:
4202:../uvc.c      **** 
 494              		.loc 1 4202 0
 495 0390 10D08DE2 		add	sp, sp, #16
 496              		@ sp needed
 497 0394 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 498              	.LVL57:
 499              	.L41:
3832:../uvc.c      ****             {
 500              		.loc 1 3832 0
 501 0398 B0469FE5 		ldr	r4, .L166+4
 502 039c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 503 03a0 830053E3 		cmp	r3, #131
 504 03a4 3500009A 		bls	.L162
 505 03a8 860053E3 		cmp	r3, #134
 506 03ac D5FFFF0A 		beq	.L154
 507 03b0 870053E3 		cmp	r3, #135
 508 03b4 7901000A 		beq	.L47
 509              	.L158:
4008:../uvc.c      ****                 {
 510              		.loc 1 4008 0
 511 03b8 850053E3 		cmp	r3, #133
 512 03bc EFFFFF1A 		bne	.L38
 513              	.L89:
4065:../uvc.c      ****                         glEp0Buffer[1] = 0;
 514              		.loc 1 4065 0
 515 03c0 8C369FE5 		ldr	r3, .L166+8
 516 03c4 1AC0A0E3 		mov	ip, #26
 517              	.L155:
4152:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 518              		.loc 1 4152 0
 519 03c8 0020A0E3 		mov	r2, #0
4153:../uvc.c      ****                         break;
 520              		.loc 1 4153 0
 521 03cc 281083E2 		add	r1, r3, #40
 522 03d0 0200A0E3 		mov	r0, #2
4151:../uvc.c      ****                         glEp0Buffer[1] = 0;
 523              		.loc 1 4151 0
 524 03d4 28C0C3E5 		strb	ip, [r3, #40]
4152:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 525              		.loc 1 4152 0
 526 03d8 2920C3E5 		strb	r2, [r3, #41]
4153:../uvc.c      ****                         break;
 527              		.loc 1 4153 0
 528 03dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 529              	.LVL58:
4202:../uvc.c      **** 
 530              		.loc 1 4202 0
 531 03e0 10D08DE2 		add	sp, sp, #16
 532              		@ sp needed
 533 03e4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 534              	.L39:
4008:../uvc.c      ****                 {
 535              		.loc 1 4008 0
 536 03e8 60369FE5 		ldr	r3, .L166+4
 537 03ec 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 538 03f0 830053E3 		cmp	r3, #131
 539 03f4 0B00009A 		bls	.L163
 540 03f8 860053E3 		cmp	r3, #134
 541 03fc C1FFFF0A 		beq	.L154
 542 0400 870053E3 		cmp	r3, #135
 543 0404 EBFFFF1A 		bne	.L158
 544              	.L78:
4023:../uvc.c      ****                         {
 545              		.loc 1 4023 0
 546 0408 44369FE5 		ldr	r3, .L166+8
4025:../uvc.c      ****                         }
 547              		.loc 1 4025 0
 548 040c 0B00A0E3 		mov	r0, #11
4023:../uvc.c      ****                         {
 549              		.loc 1 4023 0
 550 0410 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 551 0414 030053E3 		cmp	r3, #3
4025:../uvc.c      ****                         }
 552              		.loc 1 4025 0
 553 0418 38169F05 		ldreq	r1, .L166+12
4029:../uvc.c      ****                         }
 554              		.loc 1 4029 0
 555 041c 38169F15 		ldrne	r1, .L166+16
 556 0420 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 557              	.LVL59:
 558 0424 D9FFFFEA 		b	.L37
 559              	.L163:
4008:../uvc.c      ****                 {
 560              		.loc 1 4008 0
 561 0428 810053E3 		cmp	r3, #129
 562 042c F5FFFF2A 		bcs	.L78
 563 0430 010053E3 		cmp	r3, #1
 564 0434 D1FFFF1A 		bne	.L38
4033:../uvc.c      ****                                 glCommitCtrl, &readCount);
 565              		.loc 1 4033 0
 566 0438 14469FE5 		ldr	r4, .L166+8
 567 043c 2000A0E3 		mov	r0, #32
 568 0440 4C1084E2 		add	r1, r4, #76
 569 0444 08208DE2 		add	r2, sp, #8
 570 0448 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 571              	.LVL60:
4035:../uvc.c      ****                         {
 572              		.loc 1 4035 0
 573 044c 000050E3 		cmp	r0, #0
 574 0450 CEFFFF1A 		bne	.L37
4037:../uvc.c      ****                             {
 575              		.loc 1 4037 0
 576 0454 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 577 0458 030053E3 		cmp	r3, #3
 578 045c 6501000A 		beq	.L83
 579 0460 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 580              	.LVL61:
 581              	.L84:
4048:../uvc.c      ****                         }
 582              		.loc 1 4048 0
 583 0464 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 584 0468 B820DDE1 		ldrh	r2, [sp, #8]
 585 046c 00108DE5 		str	r1, [sp]
 586 0470 0400A0E3 		mov	r0, #4
 587 0474 E4159FE5 		ldr	r1, .L166+20
 588 0478 FEFFFFEB 		bl	CyU3PDebugPrint
 589              	.LVL62:
 590 047c C3FFFFEA 		b	.L37
 591              	.LVL63:
 592              	.L162:
3832:../uvc.c      ****             {
 593              		.loc 1 3832 0
 594 0480 810053E3 		cmp	r3, #129
 595 0484 4501002A 		bcs	.L47
 596 0488 010053E3 		cmp	r3, #1
 597 048c BBFFFF1A 		bne	.L38
3859:../uvc.c      ****                             glCommitCtrl, &readCount);
 598              		.loc 1 3859 0
 599 0490 BC459FE5 		ldr	r4, .L166+8
 600 0494 2000A0E3 		mov	r0, #32
 601 0498 4C1084E2 		add	r1, r4, #76
 602 049c 08208DE2 		add	r2, sp, #8
 603 04a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 604              	.LVL64:
3861:../uvc.c      ****                     {
 605              		.loc 1 3861 0
 606 04a4 000050E3 		cmp	r0, #0
 607 04a8 B8FFFF1A 		bne	.L37
3863:../uvc.c      ****                         {
 608              		.loc 1 3863 0
 609 04ac 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 610 04b0 030053E3 		cmp	r3, #3
 611 04b4 B5FFFF1A 		bne	.L37
3867:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 612              		.loc 1 3867 0
 613 04b8 A4359FE5 		ldr	r3, .L166+24
 614 04bc 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
3868:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 615              		.loc 1 3868 0
 616 04c0 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
3869:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 617              		.loc 1 3869 0
 618 04c4 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
3870:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 619              		.loc 1 3870 0
 620 04c8 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 621              	.LVL65:
3871:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 622              		.loc 1 3871 0
 623 04cc 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
3872:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 624              		.loc 1 3872 0
 625 04d0 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
3867:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 626              		.loc 1 3867 0
 627 04d4 8264C3E5 		strb	r6, [r3, #1154]
3868:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 628              		.loc 1 3868 0
 629 04d8 8354C3E5 		strb	r5, [r3, #1155]
3869:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 630              		.loc 1 3869 0
 631 04dc 84C4C3E5 		strb	ip, [r3, #1156]
3870:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 632              		.loc 1 3870 0
 633 04e0 8504C3E5 		strb	r0, [r3, #1157]
3871:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 634              		.loc 1 3871 0
 635 04e4 8614C3E5 		strb	r1, [r3, #1158]
3872:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 636              		.loc 1 3872 0
 637 04e8 8724C3E5 		strb	r2, [r3, #1159]
 638 04ec A7FFFFEA 		b	.L37
 639              	.LVL66:
 640              	.L56:
3906:../uvc.c      ****                     {
 641              		.loc 1 3906 0
 642 04f0 5C359FE5 		ldr	r3, .L166+8
 643 04f4 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 644 04f8 030053E3 		cmp	r3, #3
 645 04fc 6C00000A 		beq	.L164
 646              	.L52:
3855:../uvc.c      ****                     }
 647              		.loc 1 3855 0
 648 0500 60159FE5 		ldr	r1, .L166+28
 649 0504 1A00A0E3 		mov	r0, #26
 650 0508 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 651              	.LVL67:
 652 050c 9FFFFFEA 		b	.L37
 653              	.L159:
3894:../uvc.c      ****             {
 654              		.loc 1 3894 0
 655 0510 010055E3 		cmp	r5, #1
 656 0514 99FFFF1A 		bne	.L38
3921:../uvc.c      ****                     streamingStarted = CyFalse;
 657              		.loc 1 3921 0
 658 0518 34459FE5 		ldr	r4, .L166+8
3917:../uvc.c      **** 
 659              		.loc 1 3917 0
 660 051c 48159FE5 		ldr	r1, .L166+32
 661 0520 0400A0E3 		mov	r0, #4
 662 0524 FEFFFFEB 		bl	CyU3PDebugPrint
 663              	.LVL68:
3920:../uvc.c      ****                     gpif_initialized = 0;
 664              		.loc 1 3920 0
 665 0528 0500A0E1 		mov	r0, r5
 666 052c FEFFFFEB 		bl	CyU3PGpifDisable
 667              	.LVL69:
3921:../uvc.c      ****                     streamingStarted = CyFalse;
 668              		.loc 1 3921 0
 669 0530 0060A0E3 		mov	r6, #0
3925:../uvc.c      ****                     CyU3PBusyWait (100);
 670              		.loc 1 3925 0
 671 0534 0510A0E1 		mov	r1, r5
 672 0538 8300A0E3 		mov	r0, #131
3921:../uvc.c      ****                     streamingStarted = CyFalse;
 673              		.loc 1 3921 0
 674 053c 6C6084E5 		str	r6, [r4, #108]
3922:../uvc.c      **** 
 675              		.loc 1 3922 0
 676 0540 706084E5 		str	r6, [r4, #112]
3925:../uvc.c      ****                     CyU3PBusyWait (100);
 677              		.loc 1 3925 0
 678 0544 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 679              	.LVL70:
3926:../uvc.c      **** 
 680              		.loc 1 3926 0
 681 0548 6400A0E3 		mov	r0, #100
 682 054c FEFFFFEB 		bl	CyFx3BusyWait
 683              	.LVL71:
3929:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 684              		.loc 1 3929 0
 685 0550 18059FE5 		ldr	r0, .L166+36
 686 0554 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 687              	.LVL72:
3930:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 688              		.loc 1 3930 0
 689 0558 8300A0E3 		mov	r0, #131
 690 055c FEFFFFEB 		bl	CyU3PUsbFlushEp
 691              	.LVL73:
3931:../uvc.c      ****                     CyU3PBusyWait (100);
 692              		.loc 1 3931 0
 693 0560 0610A0E1 		mov	r1, r6
 694 0564 8300A0E3 		mov	r0, #131
 695 0568 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 696              	.LVL74:
3932:../uvc.c      **** 
 697              		.loc 1 3932 0
 698 056c 6400A0E3 		mov	r0, #100
 699 0570 FEFFFFEB 		bl	CyFx3BusyWait
 700              	.LVL75:
3935:../uvc.c      **** 
 701              		.loc 1 3935 0
 702 0574 0520A0E1 		mov	r2, r5
 703 0578 0610A0E1 		mov	r1, r6
 704 057c 8300A0E3 		mov	r0, #131
 705 0580 FEFFFFEB 		bl	CyU3PUsbStall
 706              	.LVL76:
3939:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 707              		.loc 1 3939 0
 708 0584 FEFFFFEB 		bl	CyU3PUsbAckSetup
 709              	.LVL77:
 710              	.LBB10:
 711              	.LBB11:
2074:../uvc.c      **** 	{
 712              		.loc 1 2074 0
 713 0588 00608DE5 		str	r6, [sp]
 714 058c 0510A0E1 		mov	r1, r5
 715              	.LBE11:
 716              	.LBE10:
3941:../uvc.c      ****                     //debugData[1][0] = debugData[1][0]|0x10; //set bit0
 717              		.loc 1 3941 0
 718 0590 745084E5 		str	r5, [r4, #116]
 719              	.LBB15:
 720              	.LBB14:
2074:../uvc.c      **** 	{
 721              		.loc 1 2074 0
 722 0594 0400A0E1 		mov	r0, r4
 723 0598 08308DE2 		add	r3, sp, #8
 724 059c 0220A0E3 		mov	r2, #2
 725 05a0 FEFFFFEB 		bl	_txe_event_flags_get
 726              	.LVL78:
 727 05a4 005050E2 		subs	r5, r0, #0
 728 05a8 0700001A 		bne	.L61
 729              	.LBB12:
 730              	.LBB13:
2077:../uvc.c      **** 
 731              		.loc 1 2077 0
 732 05ac 0110E0E3 		mvn	r1, #1
 733 05b0 0220A0E3 		mov	r2, #2
 734 05b4 0400A0E1 		mov	r0, r4
 735 05b8 FEFFFFEB 		bl	_txe_event_flags_set
 736              	.LVL79:
2080:../uvc.c      **** 	}
 737              		.loc 1 2080 0
 738 05bc 0400A0E1 		mov	r0, r4
 739 05c0 0520A0E1 		mov	r2, r5
 740 05c4 0210A0E3 		mov	r1, #2
 741 05c8 FEFFFFEB 		bl	_txe_event_flags_set
 742              	.LVL80:
 743              	.L61:
 744              	.LBE13:
 745              	.LBE12:
 746              	.LBE14:
 747              	.LBE15:
3949:../uvc.c      ****                             glCommitCtrl, &readCount);
 748              		.loc 1 3949 0
 749 05cc 80549FE5 		ldr	r5, .L166+8
 750 05d0 08208DE2 		add	r2, sp, #8
 751 05d4 4C1085E2 		add	r1, r5, #76
 752 05d8 2000A0E3 		mov	r0, #32
 753 05dc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 754              	.LVL81:
3951:../uvc.c      ****                     {
 755              		.loc 1 3951 0
 756 05e0 000050E3 		cmp	r0, #0
 757 05e4 69FFFF1A 		bne	.L37
3953:../uvc.c      ****                          {
 758              		.loc 1 3953 0
 759 05e8 4F20D5E5 		ldrb	r2, [r5, #79]	@ zero_extendqisi2
 760 05ec 013042E2 		sub	r3, r2, #1
 761 05f0 030053E3 		cmp	r3, #3
 762 05f4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 763 05f8 110100EA 		b	.L116
 764              	.L64:
 765 05fc 50090000 		.word	.L63
 766 0600 00090000 		.word	.L65
 767 0604 B0080000 		.word	.L66
 768 0608 14080000 		.word	.L67
 769              	.LVL82:
 770              	.L161:
4058:../uvc.c      ****                 {
 771              		.loc 1 4058 0
 772 060c 010053E3 		cmp	r3, #1
 773 0610 5AFFFF1A 		bne	.L38
4083:../uvc.c      ****                                 glCommitCtrl, &readCount);
 774              		.loc 1 4083 0
 775 0614 38449FE5 		ldr	r4, .L166+8
 776 0618 2000A0E3 		mov	r0, #32
 777 061c 4C1084E2 		add	r1, r4, #76
 778 0620 08208DE2 		add	r2, sp, #8
 779 0624 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 780              	.LVL83:
4085:../uvc.c      ****                         {
 781              		.loc 1 4085 0
 782 0628 000050E3 		cmp	r0, #0
 783 062c 57FFFF1A 		bne	.L37
4104:../uvc.c      ****                              {
 784              		.loc 1 4104 0
 785 0630 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 786 0634 01304CE2 		sub	r3, ip, #1
 787 0638 030053E3 		cmp	r3, #3
 788 063c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 789 0640 300000EA 		b	.L92
 790              	.L94:
 791 0644 84070000 		.word	.L93
 792 0648 28070000 		.word	.L95
 793 064c C4060000 		.word	.L96
 794 0650 CC070000 		.word	.L97
 795              	.LVL84:
 796              	.L160:
4144:../uvc.c      ****                 {
 797              		.loc 1 4144 0
 798 0654 010055E3 		cmp	r5, #1
 799 0658 48FFFF1A 		bne	.L38
4169:../uvc.c      ****                                 glCommitCtrl, &readCount);
 800              		.loc 1 4169 0
 801 065c F0439FE5 		ldr	r4, .L166+8
 802 0660 08208DE2 		add	r2, sp, #8
 803 0664 2000A0E3 		mov	r0, #32
 804 0668 4C1084E2 		add	r1, r4, #76
 805 066c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 806              	.LVL85:
4171:../uvc.c      ****                         {
 807              		.loc 1 4171 0
 808 0670 002050E2 		subs	r2, r0, #0
 809 0674 D500001A 		bne	.L113
4175:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 810              		.loc 1 4175 0
 811 0678 0400A0E1 		mov	r0, r4
 812              	.LVL86:
 813 067c 8010A0E3 		mov	r1, #128
 814 0680 FEFFFFEB 		bl	_txe_event_flags_set
 815              	.LVL87:
4176:../uvc.c      ****                             {
 816              		.loc 1 4176 0
 817 0684 002050E2 		subs	r2, r0, #0
4182:../uvc.c      ****                             //stillcont = 0;
 818              		.loc 1 4182 0
 819 0688 0F30E003 		mvneq	r3, #15
 820 068c 7E30C405 		streqb	r3, [r4, #126]
4176:../uvc.c      ****                             {
 821              		.loc 1 4176 0
 822 0690 E700001A 		bne	.L165
 823              	.LVL88:
 824              	.L115:
4185:../uvc.c      ****                         }else{
 825              		.loc 1 4185 0 discriminator 1
 826 0694 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 827 0698 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 828 069c B820DDE1 		ldrh	r2, [sp, #8]
 829 06a0 00108DE5 		str	r1, [sp]
 830 06a4 0400A0E3 		mov	r0, #4
 831 06a8 C4139FE5 		ldr	r1, .L166+40
 832 06ac FEFFFFEB 		bl	CyU3PDebugPrint
 833              	.LVL89:
 834 06b0 36FFFFEA 		b	.L37
 835              	.LVL90:
 836              	.L164:
3908:../uvc.c      ****                     }
 837              		.loc 1 3908 0
 838 06b4 BC139FE5 		ldr	r1, .L166+44
 839 06b8 1A00A0E3 		mov	r0, #26
 840 06bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 841              	.LVL91:
 842 06c0 32FFFFEA 		b	.L37
 843              	.LVL92:
 844              	.L96:
4112:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 845              		.loc 1 4112 0
 846 06c4 782094E5 		ldr	r2, [r4, #120]
 847 06c8 3010A0E3 		mov	r1, #48
 848 06cc 000052E3 		cmp	r2, #0
 849 06d0 D420A003 		moveq	r2, #212
 850 06d4 5420A013 		movne	r2, #84
 851 06d8 5230A0E3 		mov	r3, #82
 852 06dc 0100A0E3 		mov	r0, #1
 853              	.LVL93:
 854 06e0 FEFFFFEB 		bl	SensorSetIrisControl
 855              	.LVL94:
4114:../uvc.c      ****                              		break;
 856              		.loc 1 4114 0
 857 06e4 782094E5 		ldr	r2, [r4, #120]
 858 06e8 0400A0E3 		mov	r0, #4
 859 06ec 000052E3 		cmp	r2, #0
 860 06f0 783094E5 		ldr	r3, [r4, #120]
 861 06f4 D420A003 		moveq	r2, #212
 862 06f8 5420A013 		movne	r2, #84
 863 06fc 78139FE5 		ldr	r1, .L166+48
 864 0700 FEFFFFEB 		bl	CyU3PDebugPrint
 865              	.LVL95:
 866 0704 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 867              	.L92:
4131:../uvc.c      **** 
 868              		.loc 1 4131 0
 869 0708 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 870 070c B820DDE1 		ldrh	r2, [sp, #8]
 871 0710 00C08DE5 		str	ip, [sp]
 872 0714 64139FE5 		ldr	r1, .L166+52
4129:../uvc.c      **** 
 873              		.loc 1 4129 0
 874 0718 7DC0C4E5 		strb	ip, [r4, #125]
4131:../uvc.c      **** 
 875              		.loc 1 4131 0
 876 071c 0400A0E3 		mov	r0, #4
 877 0720 FEFFFFEB 		bl	CyU3PDebugPrint
 878              	.LVL96:
 879 0724 19FFFFEA 		b	.L37
 880              	.LVL97:
 881              	.L95:
4117:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 882              		.loc 1 4117 0
 883 0728 34539FE5 		ldr	r5, .L166+24
 884 072c 782094E5 		ldr	r2, [r4, #120]
 885 0730 D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 886 0734 000052E3 		cmp	r2, #0
 887 0738 C420A003 		moveq	r2, #196
 888 073c 4420A013 		movne	r2, #68
 889 0740 032082E1 		orr	r2, r2, r3
 890 0744 3010A0E3 		mov	r1, #48
 891 0748 5230A0E3 		mov	r3, #82
 892 074c 0100A0E3 		mov	r0, #1
 893              	.LVL98:
 894 0750 FEFFFFEB 		bl	SensorSetIrisControl
 895              	.LVL99:
4119:../uvc.c      ****                              		break;
 896              		.loc 1 4119 0
 897 0754 781094E5 		ldr	r1, [r4, #120]
 898 0758 D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 899 075c 783094E5 		ldr	r3, [r4, #120]
 900 0760 000051E3 		cmp	r1, #0
 901 0764 C410A003 		moveq	r1, #196
 902 0768 4410A013 		movne	r1, #68
 903              	.L152:
4124:../uvc.c      ****                              		break;
 904              		.loc 1 4124 0
 905 076c 022081E1 		orr	r2, r1, r2
 906 0770 0400A0E3 		mov	r0, #4
 907 0774 00139FE5 		ldr	r1, .L166+48
 908 0778 FEFFFFEB 		bl	CyU3PDebugPrint
 909              	.LVL100:
 910 077c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4125:../uvc.c      ****                               	default:
 911              		.loc 1 4125 0
 912 0780 E0FFFFEA 		b	.L92
 913              	.LVL101:
 914              	.L93:
4122:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 915              		.loc 1 4122 0
 916 0784 D8529FE5 		ldr	r5, .L166+24
 917 0788 782094E5 		ldr	r2, [r4, #120]
 918 078c D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 919 0790 000052E3 		cmp	r2, #0
 920 0794 F420A003 		moveq	r2, #244
 921 0798 7420A013 		movne	r2, #116
 922 079c 032082E1 		orr	r2, r2, r3
 923 07a0 3010A0E3 		mov	r1, #48
 924 07a4 5230A0E3 		mov	r3, #82
 925 07a8 0100A0E3 		mov	r0, #1
 926              	.LVL102:
 927 07ac FEFFFFEB 		bl	SensorSetIrisControl
 928              	.LVL103:
4124:../uvc.c      ****                              		break;
 929              		.loc 1 4124 0
 930 07b0 781094E5 		ldr	r1, [r4, #120]
 931 07b4 D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 932 07b8 000051E3 		cmp	r1, #0
 933 07bc 783094E5 		ldr	r3, [r4, #120]
 934 07c0 F410A003 		moveq	r1, #244
 935 07c4 7410A013 		movne	r1, #116
 936 07c8 E7FFFFEA 		b	.L152
 937              	.LVL104:
 938              	.L97:
4107:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 939              		.loc 1 4107 0
 940 07cc 782094E5 		ldr	r2, [r4, #120]
 941 07d0 3010A0E3 		mov	r1, #48
 942 07d4 000052E3 		cmp	r2, #0
 943 07d8 E420A003 		moveq	r2, #228
 944 07dc 6420A013 		movne	r2, #100
 945 07e0 5230A0E3 		mov	r3, #82
 946 07e4 0100A0E3 		mov	r0, #1
 947              	.LVL105:
 948 07e8 FEFFFFEB 		bl	SensorSetIrisControl
 949              	.LVL106:
4109:../uvc.c      ****                              		break;
 950              		.loc 1 4109 0
 951 07ec 782094E5 		ldr	r2, [r4, #120]
 952 07f0 0400A0E3 		mov	r0, #4
 953 07f4 000052E3 		cmp	r2, #0
 954 07f8 783094E5 		ldr	r3, [r4, #120]
 955 07fc E420A003 		moveq	r2, #228
 956 0800 6420A013 		movne	r2, #100
 957 0804 70129FE5 		ldr	r1, .L166+48
 958 0808 FEFFFFEB 		bl	CyU3PDebugPrint
 959              	.LVL107:
 960 080c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4110:../uvc.c      ****                              	case 3: //1080
 961              		.loc 1 4110 0
 962 0810 BCFFFFEA 		b	.L92
 963              	.LVL108:
 964              	.L67:
3971:../uvc.c      ****                          		CyU3PThreadSleep(500);
 965              		.loc 1 3971 0
 966 0814 48529FE5 		ldr	r5, .L166+24
 967 0818 782094E5 		ldr	r2, [r4, #120]
 968 081c D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 969 0820 000052E3 		cmp	r2, #0
 970 0824 F420A003 		moveq	r2, #244
 971 0828 7420A013 		movne	r2, #116
 972 082c 032082E1 		orr	r2, r2, r3
 973 0830 3010A0E3 		mov	r1, #48
 974 0834 5230A0E3 		mov	r3, #82
 975 0838 0100A0E3 		mov	r0, #1
 976              	.LVL109:
 977 083c FEFFFFEB 		bl	SensorSetIrisControl
 978              	.LVL110:
3972:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 979              		.loc 1 3972 0
 980 0840 7D0FA0E3 		mov	r0, #500
 981 0844 FEFFFFEB 		bl	_tx_thread_sleep
 982              	.LVL111:
3973:../uvc.c      ****                          		break;
 983              		.loc 1 3973 0
 984 0848 781094E5 		ldr	r1, [r4, #120]
 985 084c D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 986 0850 783094E5 		ldr	r3, [r4, #120]
 987 0854 000051E3 		cmp	r1, #0
 988 0858 F410A003 		moveq	r1, #244
 989 085c 7410A013 		movne	r1, #116
 990              	.L150:
 991 0860 022081E1 		orr	r2, r1, r2
 992 0864 0400A0E3 		mov	r0, #4
 993 0868 14129FE5 		ldr	r1, .L166+56
 994 086c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL112:
 996 0870 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 997              	.L62:
3979:../uvc.c      **** 
 998              		.loc 1 3979 0
 999 0874 0320A0E1 		mov	r2, r3
 1000 0878 08129FE5 		ldr	r1, .L166+60
 1001 087c 0400A0E3 		mov	r0, #4
3978:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 1002              		.loc 1 3978 0
 1003 0880 7C30C4E5 		strb	r3, [r4, #124]
3979:../uvc.c      **** 
 1004              		.loc 1 3979 0
 1005 0884 FEFFFFEB 		bl	CyU3PDebugPrint
 1006              	.LVL113:
3992:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 1007              		.loc 1 3992 0
 1008 0888 0020A0E3 		mov	r2, #0
 1009 088c C0019FE5 		ldr	r0, .L166+8
 1010 0890 0110A0E3 		mov	r1, #1
 1011 0894 FEFFFFEB 		bl	_txe_event_flags_set
 1012              	.LVL114:
3993:../uvc.c      ****                         {
 1013              		.loc 1 3993 0
 1014 0898 002050E2 		subs	r2, r0, #0
 1015 089c BBFEFF0A 		beq	.L37
3995:../uvc.c      ****                         }
 1016              		.loc 1 3995 0
 1017 08a0 E4119FE5 		ldr	r1, .L166+64
 1018 08a4 0400A0E3 		mov	r0, #4
 1019              	.LVL115:
 1020 08a8 FEFFFFEB 		bl	CyU3PDebugPrint
 1021              	.LVL116:
 1022 08ac B7FEFFEA 		b	.L37
 1023              	.LVL117:
 1024              	.L66:
3966:../uvc.c      ****                          		CyU3PThreadSleep(500);
 1025              		.loc 1 3966 0
 1026 08b0 AC519FE5 		ldr	r5, .L166+24
 1027 08b4 782094E5 		ldr	r2, [r4, #120]
 1028 08b8 D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 1029 08bc 000052E3 		cmp	r2, #0
 1030 08c0 C420A003 		moveq	r2, #196
 1031 08c4 4420A013 		movne	r2, #68
 1032 08c8 032082E1 		orr	r2, r2, r3
 1033 08cc 3010A0E3 		mov	r1, #48
 1034 08d0 5230A0E3 		mov	r3, #82
 1035 08d4 0100A0E3 		mov	r0, #1
 1036              	.LVL118:
 1037 08d8 FEFFFFEB 		bl	SensorSetIrisControl
 1038              	.LVL119:
3967:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 1039              		.loc 1 3967 0
 1040 08dc 7D0FA0E3 		mov	r0, #500
 1041 08e0 FEFFFFEB 		bl	_tx_thread_sleep
 1042              	.LVL120:
3968:../uvc.c      ****                          		break;
 1043              		.loc 1 3968 0
 1044 08e4 781094E5 		ldr	r1, [r4, #120]
 1045 08e8 D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 1046 08ec 000051E3 		cmp	r1, #0
 1047 08f0 783094E5 		ldr	r3, [r4, #120]
 1048 08f4 C410A003 		moveq	r1, #196
 1049 08f8 4410A013 		movne	r1, #68
 1050 08fc D7FFFFEA 		b	.L150
 1051              	.LVL121:
 1052              	.L65:
3961:../uvc.c      ****                          		CyU3PThreadSleep(500);
 1053              		.loc 1 3961 0
 1054 0900 782094E5 		ldr	r2, [r4, #120]
 1055 0904 3010A0E3 		mov	r1, #48
 1056 0908 000052E3 		cmp	r2, #0
 1057 090c D420A003 		moveq	r2, #212
 1058 0910 5420A013 		movne	r2, #84
 1059 0914 5230A0E3 		mov	r3, #82
 1060 0918 0100A0E3 		mov	r0, #1
 1061              	.LVL122:
 1062 091c FEFFFFEB 		bl	SensorSetIrisControl
 1063              	.LVL123:
3962:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 1064              		.loc 1 3962 0
 1065 0920 7D0FA0E3 		mov	r0, #500
 1066 0924 FEFFFFEB 		bl	_tx_thread_sleep
 1067              	.LVL124:
3963:../uvc.c      ****                          		break;
 1068              		.loc 1 3963 0
 1069 0928 782094E5 		ldr	r2, [r4, #120]
 1070 092c 0400A0E3 		mov	r0, #4
 1071 0930 000052E3 		cmp	r2, #0
 1072 0934 783094E5 		ldr	r3, [r4, #120]
 1073 0938 D420A003 		moveq	r2, #212
 1074 093c 5420A013 		movne	r2, #84
 1075 0940 3C119FE5 		ldr	r1, .L166+56
 1076 0944 FEFFFFEB 		bl	CyU3PDebugPrint
 1077              	.LVL125:
 1078 0948 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
3964:../uvc.c      ****                          	case 3: //720
 1079              		.loc 1 3964 0
 1080 094c C8FFFFEA 		b	.L62
 1081              	.LVL126:
 1082              	.L63:
3956:../uvc.c      ****                          		CyU3PThreadSleep(500);
 1083              		.loc 1 3956 0
 1084 0950 782094E5 		ldr	r2, [r4, #120]
 1085 0954 3010A0E3 		mov	r1, #48
 1086 0958 000052E3 		cmp	r2, #0
 1087 095c E420A003 		moveq	r2, #228
 1088 0960 6420A013 		movne	r2, #100
 1089 0964 5230A0E3 		mov	r3, #82
 1090 0968 0100A0E3 		mov	r0, #1
 1091              	.LVL127:
 1092 096c FEFFFFEB 		bl	SensorSetIrisControl
 1093              	.LVL128:
3957:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 1094              		.loc 1 3957 0
 1095 0970 7D0FA0E3 		mov	r0, #500
 1096 0974 FEFFFFEB 		bl	_tx_thread_sleep
 1097              	.LVL129:
3958:../uvc.c      ****                          		break;
 1098              		.loc 1 3958 0
 1099 0978 782094E5 		ldr	r2, [r4, #120]
 1100 097c 0400A0E3 		mov	r0, #4
 1101 0980 000052E3 		cmp	r2, #0
 1102 0984 783094E5 		ldr	r3, [r4, #120]
 1103 0988 E420A003 		moveq	r2, #228
 1104 098c 6420A013 		movne	r2, #100
 1105 0990 EC109FE5 		ldr	r1, .L166+56
 1106 0994 FEFFFFEB 		bl	CyU3PDebugPrint
 1107              	.LVL130:
 1108 0998 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
3959:../uvc.c      ****                          	case 2: //1080
 1109              		.loc 1 3959 0
 1110 099c B4FFFFEA 		b	.L62
 1111              	.LVL131:
 1112              	.L47:
3847:../uvc.c      ****                     {
 1113              		.loc 1 3847 0
 1114 09a0 AC309FE5 		ldr	r3, .L166+8
 1115 09a4 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1116 09a8 030053E3 		cmp	r3, #3
 1117 09ac D3FEFF1A 		bne	.L52
3849:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 1118              		.loc 1 3849 0
 1119 09b0 D8109FE5 		ldr	r1, .L166+68
 1120 09b4 1A00A0E3 		mov	r0, #26
 1121 09b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1122              	.LVL132:
3850:../uvc.c      **** 
 1123              		.loc 1 3850 0
 1124 09bc 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 1125 09c0 CC109FE5 		ldr	r1, .L166+72
 1126 09c4 0400A0E3 		mov	r0, #4
 1127 09c8 FEFFFFEB 		bl	CyU3PDebugPrint
 1128              	.LVL133:
 1129 09cc 6FFEFFEA 		b	.L37
 1130              	.LVL134:
 1131              	.L113:
4187:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 1132              		.loc 1 4187 0
 1133 09d0 B820DDE1 		ldrh	r2, [sp, #8]
 1134 09d4 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 1135 09d8 B8109FE5 		ldr	r1, .L166+76
 1136 09dc 0400A0E3 		mov	r0, #4
 1137              	.LVL135:
 1138 09e0 FEFFFFEB 		bl	CyU3PDebugPrint
 1139              	.LVL136:
4188:../uvc.c      ****                         }
 1140              		.loc 1 4188 0
 1141 09e4 0000A0E3 		mov	r0, #0
 1142 09e8 0510A0E1 		mov	r1, r5
 1143 09ec 0020A0E1 		mov	r2, r0
 1144 09f0 FEFFFFEB 		bl	CyU3PUsbStall
 1145              	.LVL137:
 1146 09f4 65FEFFEA 		b	.L37
 1147              	.LVL138:
 1148              	.L83:
4041:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 1149              		.loc 1 4041 0
 1150 09f8 64309FE5 		ldr	r3, .L166+24
 1151 09fc 4D20D4E5 		ldrb	r2, [r4, #77]	@ zero_extendqisi2
4042:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 1152              		.loc 1 4042 0
 1153 0a00 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4043:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 1154              		.loc 1 4043 0
 1155 0a04 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4044:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 1156              		.loc 1 4044 0
 1157 0a08 50E0D4E5 		ldrb	lr, [r4, #80]	@ zero_extendqisi2
4045:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 1158              		.loc 1 4045 0
 1159 0a0c 51C0D4E5 		ldrb	ip, [r4, #81]	@ zero_extendqisi2
4046:../uvc.c      ****                             }
 1160              		.loc 1 4046 0
 1161 0a10 5200D4E5 		ldrb	r0, [r4, #82]	@ zero_extendqisi2
 1162              	.LVL139:
 1163 0a14 0210A0E1 		mov	r1, r2
4041:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 1164              		.loc 1 4041 0
 1165 0a18 D524C3E5 		strb	r2, [r3, #1237]
4042:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 1166              		.loc 1 4042 0
 1167 0a1c D664C3E5 		strb	r6, [r3, #1238]
4043:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 1168              		.loc 1 4043 0
 1169 0a20 D754C3E5 		strb	r5, [r3, #1239]
4044:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 1170              		.loc 1 4044 0
 1171 0a24 D8E4C3E5 		strb	lr, [r3, #1240]
4045:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 1172              		.loc 1 4045 0
 1173 0a28 D9C4C3E5 		strb	ip, [r3, #1241]
4046:../uvc.c      ****                             }
 1174              		.loc 1 4046 0
 1175 0a2c DA04C3E5 		strb	r0, [r3, #1242]
 1176 0a30 8BFEFFEA 		b	.L84
 1177              	.LVL140:
 1178              	.L165:
4178:../uvc.c      ****                             }
 1179              		.loc 1 4178 0
 1180 0a34 60109FE5 		ldr	r1, .L166+80
 1181 0a38 0400A0E3 		mov	r0, #4
 1182              	.LVL141:
 1183 0a3c FEFFFFEB 		bl	CyU3PDebugPrint
 1184              	.LVL142:
 1185 0a40 13FFFFEA 		b	.L115
 1186              	.LVL143:
 1187              	.L116:
3953:../uvc.c      ****                          {
 1188              		.loc 1 3953 0
 1189 0a44 0230A0E1 		mov	r3, r2
 1190 0a48 89FFFFEA 		b	.L62
 1191              	.L167:
 1192              		.align	2
 1193              	.L166:
 1194 0a4c 00000000 		.word	wValue
 1195 0a50 00000000 		.word	bRequest
 1196 0a54 00000000 		.word	.LANCHOR0
 1197 0a58 D4040000 		.word	.LANCHOR1+1236
 1198 0a5c E0040000 		.word	.LANCHOR1+1248
 1199 0a60 18010000 		.word	.LC8
 1200 0a64 00000000 		.word	.LANCHOR1
 1201 0a68 9C040000 		.word	.LANCHOR1+1180
 1202 0a6c 78000000 		.word	.LC4
 1203 0a70 00000000 		.word	glChHandleUVCStream
 1204 0a74 B4010000 		.word	.LC12
 1205 0a78 B8040000 		.word	.LANCHOR1+1208
 1206 0a7c 44010000 		.word	.LC9
 1207 0a80 68010000 		.word	.LC10
 1208 0a84 A4000000 		.word	.LC5
 1209 0a88 C8000000 		.word	.LC6
 1210 0a8c F0000000 		.word	.LC7
 1211 0a90 80040000 		.word	.LANCHOR1+1152
 1212 0a94 50000000 		.word	.LC3
 1213 0a98 E0010000 		.word	.LC13
 1214 0a9c 90010000 		.word	.LC11
 1215              		.cfi_endproc
 1216              	.LFE25:
 1218              		.align	2
 1219              		.global	CyFxUvcApplnDmaCallback
 1221              	CyFxUvcApplnDmaCallback:
 1222              	.LFB11:
2301:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1223              		.loc 1 2301 0
 1224              		.cfi_startproc
 1225              		@ args = 0, pretend = 0, frame = 0
 1226              		@ frame_needed = 0, uses_anonymous_args = 0
 1227              	.LVL144:
2308:../uvc.c      ****     {
 1228              		.loc 1 2308 0
 1229 0aa0 080051E3 		cmp	r1, #8
2301:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1230              		.loc 1 2301 0
 1231 0aa4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1232              	.LCFI5:
 1233              		.cfi_def_cfa_offset 16
 1234              		.cfi_offset 4, -16
 1235              		.cfi_offset 5, -12
 1236              		.cfi_offset 6, -8
 1237              		.cfi_offset 14, -4
 1238 0aa8 0250A0E1 		mov	r5, r2
 1239 0aac 08D04DE2 		sub	sp, sp, #8
 1240              	.LCFI6:
 1241              		.cfi_def_cfa_offset 24
2308:../uvc.c      ****     {
 1242              		.loc 1 2308 0
 1243 0ab0 0B00000A 		beq	.L179
2360:../uvc.c      ****     {
 1244              		.loc 1 2360 0
 1245 0ab4 100051E3 		cmp	r1, #16
 1246 0ab8 0700001A 		bne	.L168
2362:../uvc.c      ****         streamingStarted = CyTrue;
 1247              		.loc 1 2362 0
 1248 0abc 6C319FE5 		ldr	r3, .L182
2363:../uvc.c      ****     }
 1249              		.loc 1 2363 0
 1250 0ac0 0110A0E3 		mov	r1, #1
 1251              	.LVL145:
2362:../uvc.c      ****         streamingStarted = CyTrue;
 1252              		.loc 1 2362 0
 1253 0ac4 BE28D3E1 		ldrh	r2, [r3, #142]
 1254              	.LVL146:
2363:../uvc.c      ****     }
 1255              		.loc 1 2363 0
 1256 0ac8 701083E5 		str	r1, [r3, #112]
2362:../uvc.c      ****         streamingStarted = CyTrue;
 1257              		.loc 1 2362 0
 1258 0acc 012082E0 		add	r2, r2, r1
 1259 0ad0 0228A0E1 		mov	r2, r2, asl #16
 1260 0ad4 2228A0E1 		mov	r2, r2, lsr #16
 1261 0ad8 BE28C3E1 		strh	r2, [r3, #142]	@ movhi
 1262              	.LVL147:
 1263              	.L168:
2365:../uvc.c      **** 
 1264              		.loc 1 2365 0
 1265 0adc 08D08DE2 		add	sp, sp, #8
 1266              		@ sp needed
 1267 0ae0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1268              	.LVL148:
 1269              	.L179:
2310:../uvc.c      ****             {
 1270              		.loc 1 2310 0
 1271 0ae4 48319FE5 		ldr	r3, .L182+4
 1272 0ae8 B420D2E1 		ldrh	r2, [r2, #4]
 1273              	.LVL149:
2324:../uvc.c      ****                 fb++;
 1274              		.loc 1 2324 0
 1275 0aec 006095E5 		ldr	r6, [r5]
2310:../uvc.c      ****             {
 1276              		.loc 1 2310 0
 1277 0af0 030052E1 		cmp	r2, r3
 1278              	.LBB20:
 1279              	.LBB21:
2034:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1280              		.loc 1 2034 0
 1281 0af4 3C019FE5 		ldr	r0, .L182+8
 1282              	.LVL150:
 1283              	.LBE21:
 1284              	.LBE20:
2310:../uvc.c      ****             {
 1285              		.loc 1 2310 0
 1286 0af8 3100000A 		beq	.L180
 1287              	.LBB25:
 1288              	.LBB26:
2034:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1289              		.loc 1 2034 0
 1290 0afc 0010E0E3 		mvn	r1, #0
 1291              	.LVL151:
 1292 0b00 FEFFFFEB 		bl	_txe_mutex_get
 1293              	.LVL152:
2035:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1294              		.loc 1 2035 0
 1295 0b04 0C0046E2 		sub	r0, r6, #12
 1296 0b08 2C119FE5 		ldr	r1, .L182+12
 1297 0b0c 0C20A0E3 		mov	r2, #12
 1298 0b10 FEFFFFEB 		bl	CyU3PMemCopy
 1299              	.LVL153:
2036:../uvc.c      **** 
 1300              		.loc 1 2036 0
 1301 0b14 1C019FE5 		ldr	r0, .L182+8
 1302 0b18 FEFFFFEB 		bl	_txe_mutex_put
 1303              	.LVL154:
2041:../uvc.c      ****     }
 1304              		.loc 1 2041 0
 1305 0b1c 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1306              	.LBE26:
 1307              	.LBE25:
2331:../uvc.c      ****                 pbc = input->buffer_p.count;
 1308              		.loc 1 2331 0
 1309 0b20 08419FE5 		ldr	r4, .L182
 1310              	.LBB29:
 1311              	.LBB27:
2041:../uvc.c      ****     }
 1312              		.loc 1 2041 0
 1313 0b24 023083E3 		orr	r3, r3, #2
 1314 0b28 0B3046E5 		strb	r3, [r6, #-11]
 1315              	.LBE27:
 1316              	.LBE29:
2337:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1317              		.loc 1 2337 0
 1318 0b2c 7E10D4E5 		ldrb	r1, [r4, #126]	@ zero_extendqisi2
2331:../uvc.c      ****                 pbc = input->buffer_p.count;
 1319              		.loc 1 2331 0
 1320 0b30 B228D4E1 		ldrh	r2, [r4, #130]
2332:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1321              		.loc 1 2332 0
 1322 0b34 B430D5E1 		ldrh	r3, [r5, #4]
2331:../uvc.c      ****                 pbc = input->buffer_p.count;
 1323              		.loc 1 2331 0
 1324 0b38 012082E2 		add	r2, r2, #1
2337:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1325              		.loc 1 2337 0
 1326 0b3c 0F0051E3 		cmp	r1, #15
2331:../uvc.c      ****                 pbc = input->buffer_p.count;
 1327              		.loc 1 2331 0
 1328 0b40 B228C4E1 		strh	r2, [r4, #130]	@ movhi
2332:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1329              		.loc 1 2332 0
 1330 0b44 B438C4E1 		strh	r3, [r4, #132]	@ movhi
 1331              	.LBB30:
 1332              	.LBB28:
2035:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1333              		.loc 1 2035 0
 1334 0b48 F0609FE5 		ldr	r6, .L182+16
 1335              	.LBE28:
 1336              	.LBE30:
2337:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1337              		.loc 1 2337 0
 1338 0b4c 2B00000A 		beq	.L181
 1339              	.L172:
2344:../uvc.c      ****             }
 1340              		.loc 1 2344 0
 1341 0b50 0120A0E3 		mov	r2, #1
 1342 0b54 882084E5 		str	r2, [r4, #136]
 1343              	.L171:
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1344              		.loc 1 2348 0
 1345 0b58 BC28D4E1 		ldrh	r2, [r4, #140]
2349:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1346              		.loc 1 2349 0
 1347 0b5c 0C1083E2 		add	r1, r3, #12
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1348              		.loc 1 2348 0
 1349 0b60 013082E2 		add	r3, r2, #1
2349:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1350              		.loc 1 2349 0
 1351 0b64 0118A0E1 		mov	r1, r1, asl #16
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1352              		.loc 1 2348 0
 1353 0b68 0338A0E1 		mov	r3, r3, asl #16
2349:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1354              		.loc 1 2349 0
 1355 0b6c 2118A0E1 		mov	r1, r1, lsr #16
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1356              		.loc 1 2348 0
 1357 0b70 2338A0E1 		mov	r3, r3, lsr #16
2349:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1358              		.loc 1 2349 0
 1359 0b74 0020A0E3 		mov	r2, #0
 1360 0b78 C4009FE5 		ldr	r0, .L182+20
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1361              		.loc 1 2348 0
 1362 0b7c BC38C4E1 		strh	r3, [r4, #140]	@ movhi
2349:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1363              		.loc 1 2349 0
 1364 0b80 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1365              	.LVL155:
2348:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1366              		.loc 1 2348 0
 1367 0b84 A4109FE5 		ldr	r1, .L182
2352:../uvc.c      ****             {
 1368              		.loc 1 2352 0
 1369 0b88 002050E2 		subs	r2, r0, #0
 1370 0b8c D2FFFF0A 		beq	.L168
2354:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1371              		.loc 1 2354 0
 1372 0b90 BC08D1E1 		ldrh	r0, [r1, #140]
 1373              	.LVL156:
2355:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1374              		.loc 1 2355 0
 1375 0b94 B430D5E1 		ldrh	r3, [r5, #4]
2354:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1376              		.loc 1 2354 0
 1377 0b98 010040E2 		sub	r0, r0, #1
 1378 0b9c 0008A0E1 		mov	r0, r0, asl #16
 1379 0ba0 2008A0E1 		mov	r0, r0, lsr #16
 1380 0ba4 BC08C1E1 		strh	r0, [r1, #140]	@ movhi
2355:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1381              		.loc 1 2355 0
 1382 0ba8 BC08D1E1 		ldrh	r0, [r1, #140]
 1383 0bac BE18D1E1 		ldrh	r1, [r1, #142]
 1384 0bb0 03008DE8 		stmia	sp, {r0, r1}
 1385 0bb4 8C109FE5 		ldr	r1, .L182+24
 1386 0bb8 0400A0E3 		mov	r0, #4
 1387 0bbc FEFFFFEB 		bl	CyU3PDebugPrint
 1388              	.LVL157:
 1389 0bc0 C5FFFFEA 		b	.L168
 1390              	.LVL158:
 1391              	.L180:
 1392              	.LBB31:
 1393              	.LBB22:
2034:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1394              		.loc 1 2034 0
 1395 0bc4 0010E0E3 		mvn	r1, #0
 1396              	.LVL159:
 1397              	.LBE22:
 1398              	.LBE31:
2325:../uvc.c      ****             }
 1399              		.loc 1 2325 0
 1400 0bc8 60409FE5 		ldr	r4, .L182
 1401              	.LBB32:
 1402              	.LBB23:
2034:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1403              		.loc 1 2034 0
 1404 0bcc FEFFFFEB 		bl	_txe_mutex_get
 1405              	.LVL160:
 1406              	.LBE23:
 1407              	.LBE32:
2324:../uvc.c      ****                 fb++;
 1408              		.loc 1 2324 0
 1409 0bd0 0C6046E2 		sub	r6, r6, #12
 1410              	.LVL161:
 1411              	.LBB33:
 1412              	.LBB24:
2035:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1413              		.loc 1 2035 0
 1414 0bd4 0C20A0E3 		mov	r2, #12
 1415 0bd8 0600A0E1 		mov	r0, r6
 1416 0bdc 58109FE5 		ldr	r1, .L182+12
 1417 0be0 FEFFFFEB 		bl	CyU3PMemCopy
 1418              	.LVL162:
2036:../uvc.c      **** 
 1419              		.loc 1 2036 0
 1420 0be4 4C009FE5 		ldr	r0, .L182+8
 1421 0be8 FEFFFFEB 		bl	_txe_mutex_put
 1422              	.LVL163:
 1423              	.LBE24:
 1424              	.LBE33:
2325:../uvc.c      ****             }
 1425              		.loc 1 2325 0
 1426 0bec B028D4E1 		ldrh	r2, [r4, #128]
 1427 0bf0 B430D5E1 		ldrh	r3, [r5, #4]
 1428 0bf4 012082E2 		add	r2, r2, #1
 1429 0bf8 B028C4E1 		strh	r2, [r4, #128]	@ movhi
 1430 0bfc D5FFFFEA 		b	.L171
 1431              	.LVL164:
 1432              	.L181:
2338:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1433              		.loc 1 2338 0
 1434 0c00 0010E0E3 		mvn	r1, #0
 1435 0c04 2C009FE5 		ldr	r0, .L182+8
 1436 0c08 FEFFFFEB 		bl	_txe_mutex_get
 1437              	.LVL165:
2339:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1438              		.loc 1 2339 0
 1439 0c0c ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2340:../uvc.c      ****                 	stiflag = 0xAA;
 1440              		.loc 1 2340 0
 1441 0c10 20009FE5 		ldr	r0, .L182+8
2339:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1442              		.loc 1 2339 0
 1443 0c14 DF3003E2 		and	r3, r3, #223
 1444 0c18 ED34C6E5 		strb	r3, [r6, #1261]
2340:../uvc.c      ****                 	stiflag = 0xAA;
 1445              		.loc 1 2340 0
 1446 0c1c FEFFFFEB 		bl	_txe_mutex_put
 1447              	.LVL166:
2341:../uvc.c      ****                 }
 1448              		.loc 1 2341 0
 1449 0c20 5530E0E3 		mvn	r3, #85
 1450 0c24 7E30C4E5 		strb	r3, [r4, #126]
 1451 0c28 B430D5E1 		ldrh	r3, [r5, #4]
 1452 0c2c C7FFFFEA 		b	.L172
 1453              	.L183:
 1454              		.align	2
 1455              	.L182:
 1456 0c30 00000000 		.word	.LANCHOR0
 1457 0c34 F03F0000 		.word	16368
 1458 0c38 00000000 		.word	imgHdMux
 1459 0c3c EC040000 		.word	.LANCHOR1+1260
 1460 0c40 00000000 		.word	.LANCHOR1
 1461 0c44 00000000 		.word	glChHandleUVCStream
 1462 0c48 08020000 		.word	.LC14
 1463              		.cfi_endproc
 1464              	.LFE11:
 1466              		.align	2
 1468              	CyFxUVCApplnUSBEventCB:
 1469              	.LFB9:
2090:../uvc.c      ****     switch (evtype)
 1470              		.loc 1 2090 0
 1471              		.cfi_startproc
 1472              		@ args = 0, pretend = 0, frame = 8
 1473              		@ frame_needed = 0, uses_anonymous_args = 0
 1474              	.LVL167:
2091:../uvc.c      ****     {
 1475              		.loc 1 2091 0
 1476 0c4c 020050E3 		cmp	r0, #2
2090:../uvc.c      ****     switch (evtype)
 1477              		.loc 1 2090 0
 1478 0c50 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1479              	.LCFI7:
 1480              		.cfi_def_cfa_offset 16
 1481              		.cfi_offset 4, -16
 1482              		.cfi_offset 5, -12
 1483              		.cfi_offset 6, -8
 1484              		.cfi_offset 14, -4
 1485 0c54 0040A0E1 		mov	r4, r0
 1486 0c58 10D04DE2 		sub	sp, sp, #16
 1487              	.LCFI8:
 1488              		.cfi_def_cfa_offset 32
2091:../uvc.c      ****     {
 1489              		.loc 1 2091 0
 1490 0c5c 3D00000A 		beq	.L186
 1491 0c60 040050E3 		cmp	r0, #4
 1492 0c64 2400000A 		beq	.L187
 1493 0c68 010050E3 		cmp	r0, #1
 1494 0c6c 0100000A 		beq	.L194
 1495              	.LVL168:
 1496              	.L184:
2130:../uvc.c      **** 
 1497              		.loc 1 2130 0
 1498 0c70 10D08DE2 		add	sp, sp, #16
 1499              		@ sp needed
 1500 0c74 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1501              	.LVL169:
 1502              	.L194:
 1503              	.LBB48:
 1504              	.LBB49:
2114:../uvc.c      ****             gpif_initialized = 0;
 1505              		.loc 1 2114 0
 1506 0c78 54519FE5 		ldr	r5, .L195
2112:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1507              		.loc 1 2112 0
 1508 0c7c 0130A0E1 		mov	r3, r1
 1509 0c80 0420A0E1 		mov	r2, r4
 1510 0c84 4C119FE5 		ldr	r1, .L195+4
 1511              	.LVL170:
 1512 0c88 0400A0E3 		mov	r0, #4
 1513              	.LVL171:
 1514 0c8c FEFFFFEB 		bl	CyU3PDebugPrint
 1515              	.LVL172:
2113:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 1516              		.loc 1 2113 0
 1517 0c90 0400A0E1 		mov	r0, r4
 1518 0c94 FEFFFFEB 		bl	CyU3PGpifDisable
 1519              	.LVL173:
2114:../uvc.c      ****             gpif_initialized = 0;
 1520              		.loc 1 2114 0
 1521 0c98 92E0D5E5 		ldrb	lr, [r5, #146]	@ zero_extendqisi2
2115:../uvc.c      ****             isUsbConnected = CyFalse;
 1522              		.loc 1 2115 0
 1523 0c9c 00C0A0E3 		mov	ip, #0
 1524              	.LBB50:
 1525              	.LBB51:
2074:../uvc.c      **** 	{
 1526              		.loc 1 2074 0
 1527 0ca0 0410A0E1 		mov	r1, r4
 1528              	.LBE51:
 1529              	.LBE50:
2114:../uvc.c      ****             gpif_initialized = 0;
 1530              		.loc 1 2114 0
 1531 0ca4 04E08EE3 		orr	lr, lr, #4
 1532              	.LBB56:
 1533              	.LBB54:
2074:../uvc.c      **** 	{
 1534              		.loc 1 2074 0
 1535 0ca8 0500A0E1 		mov	r0, r5
 1536 0cac 00C08DE5 		str	ip, [sp]
 1537 0cb0 0220A0E3 		mov	r2, #2
 1538 0cb4 0C308DE2 		add	r3, sp, #12
 1539              	.LBE54:
 1540              	.LBE56:
2114:../uvc.c      ****             gpif_initialized = 0;
 1541              		.loc 1 2114 0
 1542 0cb8 92E0C5E5 		strb	lr, [r5, #146]
2115:../uvc.c      ****             isUsbConnected = CyFalse;
 1543              		.loc 1 2115 0
 1544 0cbc 6CC085E5 		str	ip, [r5, #108]
2116:../uvc.c      ****             streamingStarted = CyFalse;
 1545              		.loc 1 2116 0
 1546 0cc0 10C185E5 		str	ip, [r5, #272]
2117:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1547              		.loc 1 2117 0
 1548 0cc4 70C085E5 		str	ip, [r5, #112]
 1549              	.LBB57:
 1550              	.LBB55:
2074:../uvc.c      **** 	{
 1551              		.loc 1 2074 0
 1552 0cc8 FEFFFFEB 		bl	_txe_event_flags_get
 1553              	.LVL174:
 1554 0ccc 004050E2 		subs	r4, r0, #0
 1555 0cd0 E6FFFF1A 		bne	.L184
 1556              	.LVL175:
 1557              	.L192:
 1558              	.LBB52:
 1559              	.LBB53:
2077:../uvc.c      **** 
 1560              		.loc 1 2077 0
 1561 0cd4 0500A0E1 		mov	r0, r5
 1562 0cd8 0110E0E3 		mvn	r1, #1
 1563 0cdc 0220A0E3 		mov	r2, #2
 1564 0ce0 FEFFFFEB 		bl	_txe_event_flags_set
 1565              	.LVL176:
2080:../uvc.c      **** 	}
 1566              		.loc 1 2080 0
 1567 0ce4 0500A0E1 		mov	r0, r5
 1568 0ce8 0420A0E1 		mov	r2, r4
 1569 0cec 0210A0E3 		mov	r1, #2
 1570 0cf0 FEFFFFEB 		bl	_txe_event_flags_set
 1571              	.LVL177:
 1572              	.LBE53:
 1573              	.LBE52:
 1574              	.LBE55:
 1575              	.LBE57:
 1576              	.LBE49:
 1577              	.LBE48:
2130:../uvc.c      **** 
 1578              		.loc 1 2130 0
 1579 0cf4 10D08DE2 		add	sp, sp, #16
 1580              		@ sp needed
 1581 0cf8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1582              	.LVL178:
 1583              	.L187:
2096:../uvc.c      ****             gpif_initialized = 0;
 1584              		.loc 1 2096 0
 1585 0cfc D0509FE5 		ldr	r5, .L195
2094:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1586              		.loc 1 2094 0
 1587 0d00 0130A0E1 		mov	r3, r1
 1588 0d04 0020A0E1 		mov	r2, r0
 1589 0d08 CC109FE5 		ldr	r1, .L195+8
 1590              	.LVL179:
 1591 0d0c FEFFFFEB 		bl	CyU3PDebugPrint
 1592              	.LVL180:
2095:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 1593              		.loc 1 2095 0
 1594 0d10 0100A0E3 		mov	r0, #1
 1595 0d14 FEFFFFEB 		bl	CyU3PGpifDisable
 1596              	.LVL181:
2096:../uvc.c      ****             gpif_initialized = 0;
 1597              		.loc 1 2096 0
 1598 0d18 92E0D5E5 		ldrb	lr, [r5, #146]	@ zero_extendqisi2
2097:../uvc.c      ****             streamingStarted = CyFalse;
 1599              		.loc 1 2097 0
 1600 0d1c 00C0A0E3 		mov	ip, #0
2096:../uvc.c      ****             gpif_initialized = 0;
 1601              		.loc 1 2096 0
 1602 0d20 01E08EE3 		orr	lr, lr, #1
 1603              	.LBB58:
 1604              	.LBB59:
2074:../uvc.c      **** 	{
 1605              		.loc 1 2074 0
 1606 0d24 0500A0E1 		mov	r0, r5
 1607 0d28 00C08DE5 		str	ip, [sp]
 1608 0d2c 0110A0E3 		mov	r1, #1
 1609 0d30 0220A0E3 		mov	r2, #2
 1610 0d34 0C308DE2 		add	r3, sp, #12
 1611              	.LBE59:
 1612              	.LBE58:
2096:../uvc.c      ****             gpif_initialized = 0;
 1613              		.loc 1 2096 0
 1614 0d38 92E0C5E5 		strb	lr, [r5, #146]
2097:../uvc.c      ****             streamingStarted = CyFalse;
 1615              		.loc 1 2097 0
 1616 0d3c 6CC085E5 		str	ip, [r5, #108]
2098:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1617              		.loc 1 2098 0
 1618 0d40 70C085E5 		str	ip, [r5, #112]
 1619              	.LBB61:
 1620              	.LBB60:
2074:../uvc.c      **** 	{
 1621              		.loc 1 2074 0
 1622 0d44 FEFFFFEB 		bl	_txe_event_flags_get
 1623              	.LVL182:
 1624 0d48 004050E2 		subs	r4, r0, #0
 1625 0d4c E0FFFF0A 		beq	.L192
 1626              	.LBE60:
 1627              	.LBE61:
2130:../uvc.c      **** 
 1628              		.loc 1 2130 0
 1629 0d50 10D08DE2 		add	sp, sp, #16
 1630              		@ sp needed
 1631 0d54 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1632              	.LVL183:
 1633              	.L186:
2105:../uvc.c      ****             gpif_initialized = 0;
 1634              		.loc 1 2105 0
 1635 0d58 74509FE5 		ldr	r5, .L195
2103:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1636              		.loc 1 2103 0
 1637 0d5c 0130A0E1 		mov	r3, r1
 1638 0d60 0420A0E1 		mov	r2, r4
 1639 0d64 74109FE5 		ldr	r1, .L195+12
 1640              	.LVL184:
 1641 0d68 0400A0E3 		mov	r0, #4
 1642              	.LVL185:
 1643 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1644              	.LVL186:
2104:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 1645              		.loc 1 2104 0
 1646 0d70 0100A0E3 		mov	r0, #1
 1647 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1648              	.LVL187:
2105:../uvc.c      ****             gpif_initialized = 0;
 1649              		.loc 1 2105 0
 1650 0d78 92E0D5E5 		ldrb	lr, [r5, #146]	@ zero_extendqisi2
2106:../uvc.c      ****             streamingStarted = CyFalse;
 1651              		.loc 1 2106 0
 1652 0d7c 00C0A0E3 		mov	ip, #0
2105:../uvc.c      ****             gpif_initialized = 0;
 1653              		.loc 1 2105 0
 1654 0d80 02E08EE3 		orr	lr, lr, #2
 1655              	.LBB62:
 1656              	.LBB63:
2074:../uvc.c      **** 	{
 1657              		.loc 1 2074 0
 1658 0d84 0500A0E1 		mov	r0, r5
 1659 0d88 00C08DE5 		str	ip, [sp]
 1660 0d8c 0110A0E3 		mov	r1, #1
 1661 0d90 0420A0E1 		mov	r2, r4
 1662 0d94 0C308DE2 		add	r3, sp, #12
 1663              	.LBE63:
 1664              	.LBE62:
2105:../uvc.c      ****             gpif_initialized = 0;
 1665              		.loc 1 2105 0
 1666 0d98 92E0C5E5 		strb	lr, [r5, #146]
2106:../uvc.c      ****             streamingStarted = CyFalse;
 1667              		.loc 1 2106 0
 1668 0d9c 6CC085E5 		str	ip, [r5, #108]
2107:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1669              		.loc 1 2107 0
 1670 0da0 70C085E5 		str	ip, [r5, #112]
 1671              	.LBB67:
 1672              	.LBB66:
2074:../uvc.c      **** 	{
 1673              		.loc 1 2074 0
 1674 0da4 FEFFFFEB 		bl	_txe_event_flags_get
 1675              	.LVL188:
 1676 0da8 006050E2 		subs	r6, r0, #0
 1677 0dac AFFFFF1A 		bne	.L184
 1678              	.LBB64:
 1679              	.LBB65:
2077:../uvc.c      **** 
 1680              		.loc 1 2077 0
 1681 0db0 0420A0E1 		mov	r2, r4
 1682 0db4 0500A0E1 		mov	r0, r5
 1683 0db8 0110E0E3 		mvn	r1, #1
 1684 0dbc FEFFFFEB 		bl	_txe_event_flags_set
 1685              	.LVL189:
2080:../uvc.c      **** 	}
 1686              		.loc 1 2080 0
 1687 0dc0 0500A0E1 		mov	r0, r5
 1688 0dc4 0410A0E1 		mov	r1, r4
 1689 0dc8 0620A0E1 		mov	r2, r6
 1690 0dcc FEFFFFEB 		bl	_txe_event_flags_set
 1691              	.LVL190:
 1692 0dd0 A6FFFFEA 		b	.L184
 1693              	.L196:
 1694              		.align	2
 1695              	.L195:
 1696 0dd4 00000000 		.word	.LANCHOR0
 1697 0dd8 98020000 		.word	.LC17
 1698 0ddc 54020000 		.word	.LC15
 1699 0de0 74020000 		.word	.LC16
 1700              	.LBE65:
 1701              	.LBE64:
 1702              	.LBE66:
 1703              	.LBE67:
 1704              		.cfi_endproc
 1705              	.LFE9:
 1707              		.align	2
 1709              	CyFxUVCApplnUSBSetupCB:
 1710              	.LFB10:
2138:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1711              		.loc 1 2138 0
 1712              		.cfi_startproc
 1713              		@ args = 0, pretend = 0, frame = 8
 1714              		@ frame_needed = 0, uses_anonymous_args = 0
 1715              	.LVL191:
 1716 0de4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1717              	.LCFI9:
 1718              		.cfi_def_cfa_offset 36
 1719              		.cfi_offset 4, -36
 1720              		.cfi_offset 5, -32
 1721              		.cfi_offset 6, -28
 1722              		.cfi_offset 7, -24
 1723              		.cfi_offset 8, -20
 1724              		.cfi_offset 9, -16
 1725              		.cfi_offset 10, -12
 1726              		.cfi_offset 11, -8
 1727              		.cfi_offset 14, -4
2144:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1728              		.loc 1 2144 0
 1729 0de8 68739FE5 		ldr	r7, .L236
2147:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 1730              		.loc 1 2147 0
 1731 0dec 68B39FE5 		ldr	fp, .L236+4
2146:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1732              		.loc 1 2146 0
 1733 0df0 68839FE5 		ldr	r8, .L236+8
2143:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1734              		.loc 1 2143 0
 1735 0df4 68439FE5 		ldr	r4, .L236+12
2138:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1736              		.loc 1 2138 0
 1737 0df8 00C0A0E1 		mov	ip, r0
2144:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1738              		.loc 1 2144 0
 1739 0dfc FFAC00E2 		and	r10, r0, #65280
2145:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1740              		.loc 1 2145 0
 1741 0e00 60939FE5 		ldr	r9, .L236+16
 1742 0e04 0108A0E1 		mov	r0, r1, asl #16
 1743              	.LVL192:
2138:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1744              		.loc 1 2138 0
 1745 0e08 1CD04DE2 		sub	sp, sp, #28
 1746              	.LCFI10:
 1747              		.cfi_def_cfa_offset 64
2138:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1748              		.loc 1 2138 0
 1749 0e0c 01E0A0E1 		mov	lr, r1
2145:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1750              		.loc 1 2145 0
 1751 0e10 2C68A0E1 		mov	r6, ip, lsr #16
2147:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 1752              		.loc 1 2147 0
 1753 0e14 2158A0E1 		mov	r5, r1, lsr #16
2144:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1754              		.loc 1 2144 0
 1755 0e18 2AA4A0E1 		mov	r10, r10, lsr #8
 1756 0e1c 2008A0E1 		mov	r0, r0, lsr #16
2148:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
 1757              		.loc 1 2148 0
 1758 0e20 0010A0E3 		mov	r1, #0
 1759              	.LVL193:
 1760 0e24 04008DE5 		str	r0, [sp, #4]
 1761 0e28 0C108DE5 		str	r1, [sp, #12]
 1762 0e2c 00608DE5 		str	r6, [sp]
 1763 0e30 08508DE5 		str	r5, [sp, #8]
 1764 0e34 FF200CE2 		and	r2, ip, #255
 1765 0e38 0A30A0E1 		mov	r3, r10
 1766 0e3c 0400A0E3 		mov	r0, #4
 1767 0e40 24139FE5 		ldr	r1, .L236+20
2144:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1768              		.loc 1 2144 0
 1769 0e44 00A0C7E5 		strb	r10, [r7]
2147:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 1770              		.loc 1 2147 0
 1771 0e48 B050CBE1 		strh	r5, [fp]	@ movhi
2146:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1772              		.loc 1 2146 0
 1773 0e4c B0E0C8E1 		strh	lr, [r8]	@ movhi
2143:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1774              		.loc 1 2143 0
 1775 0e50 00C0C4E5 		strb	ip, [r4]
2145:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1776              		.loc 1 2145 0
 1777 0e54 B060C9E1 		strh	r6, [r9]	@ movhi
2148:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
 1778              		.loc 1 2148 0
 1779 0e58 FEFFFFEB 		bl	CyU3PDebugPrint
 1780              	.LVL194:
2150:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
 1781              		.loc 1 2150 0
 1782 0e5c 0C239FE5 		ldr	r2, .L236+24
 1783 0e60 F834D2E5 		ldrb	r3, [r2, #1272]	@ zero_extendqisi2
 1784 0e64 3E0053E3 		cmp	r3, #62
 1785 0e68 0D00008A 		bhi	.L198
2151:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1786              		.loc 1 2151 0
 1787 0e6c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 1788 0e70 800054E3 		cmp	r4, #128
 1789 0e74 A1005413 		cmpne	r4, #161
 1790 0e78 5700001A 		bne	.L231
 1791              	.L199:
2159:../uvc.c      ****     {
 1792              		.loc 1 2159 0
 1793 0e7c 020054E3 		cmp	r4, #2
 1794 0e80 0D00000A 		beq	.L201
 1795              	.L233:
 1796 0e84 1900009A 		bls	.L232
 1797 0e88 210054E3 		cmp	r4, #33
 1798 0e8c 5C00000A 		beq	.L204
 1799 0e90 A10054E3 		cmp	r4, #161
 1800 0e94 5A00000A 		beq	.L204
 1801              	.L219:
2139:../uvc.c      ****     uint32_t status;
 1802              		.loc 1 2139 0
 1803 0e98 0000A0E3 		mov	r0, #0
 1804              	.LVL195:
 1805              	.L200:
2288:../uvc.c      **** 
 1806              		.loc 1 2288 0
 1807 0e9c 1CD08DE2 		add	sp, sp, #28
 1808              		@ sp needed
 1809 0ea0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1810              	.LVL196:
 1811              	.L198:
 1812 0ea4 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
2156:../uvc.c      **** 
 1813              		.loc 1 2156 0
 1814 0ea8 C4329FE5 		ldr	r3, .L236+28
 1815 0eac 0020E0E3 		mvn	r2, #0
2159:../uvc.c      ****     {
 1816              		.loc 1 2159 0
 1817 0eb0 020054E3 		cmp	r4, #2
2156:../uvc.c      **** 
 1818              		.loc 1 2156 0
 1819 0eb4 0F21C3E5 		strb	r2, [r3, #271]
2159:../uvc.c      ****     {
 1820              		.loc 1 2159 0
 1821 0eb8 F1FFFF1A 		bne	.L233
 1822              	.L201:
2235:../uvc.c      ****             {
 1823              		.loc 1 2235 0
 1824 0ebc 0050D7E5 		ldrb	r5, [r7]	@ zero_extendqisi2
 1825 0ec0 010055E3 		cmp	r5, #1
 1826 0ec4 F3FFFF1A 		bne	.L219
2237:../uvc.c      ****                 {
 1827              		.loc 1 2237 0
 1828 0ec8 B060D8E1 		ldrh	r6, [r8]
 1829 0ecc 830056E3 		cmp	r6, #131
 1830 0ed0 F0FFFF1A 		bne	.L219
2243:../uvc.c      ****                     {
 1831              		.loc 1 2243 0
 1832 0ed4 98729FE5 		ldr	r7, .L236+28
 1833 0ed8 708097E5 		ldr	r8, [r7, #112]
 1834 0edc 010058E3 		cmp	r8, #1
 1835 0ee0 6C00000A 		beq	.L234
 1836              	.LVL197:
2276:../uvc.c      ****                     }
 1837              		.loc 1 2276 0
 1838 0ee4 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1839              	.LVL198:
2275:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1840              		.loc 1 2275 0
 1841 0ee8 0500A0E1 		mov	r0, r5
 1842 0eec EAFFFFEA 		b	.L200
 1843              	.LVL199:
 1844              	.L232:
2159:../uvc.c      ****     {
 1845              		.loc 1 2159 0
 1846 0ef0 010054E3 		cmp	r4, #1
 1847 0ef4 E7FFFF1A 		bne	.L219
2199:../uvc.c      ****             {
 1848              		.loc 1 2199 0
 1849 0ef8 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 1850 0efc 0B0053E3 		cmp	r3, #11
 1851 0f00 E4FFFF1A 		bne	.L219
2203:../uvc.c      ****                 {
 1852              		.loc 1 2203 0
 1853 0f04 B030D8E1 		ldrh	r3, [r8]
 1854 0f08 010053E3 		cmp	r3, #1
 1855 0f0c E1FFFF1A 		bne	.L219
2203:../uvc.c      ****                 {
 1856              		.loc 1 2203 0 is_stmt 0 discriminator 1
 1857 0f10 B050D9E1 		ldrh	r5, [r9]
 1858 0f14 000055E3 		cmp	r5, #0
 1859 0f18 DEFFFF1A 		bne	.L219
2208:../uvc.c      ****                     streamingStarted = CyFalse;
 1860              		.loc 1 2208 0 is_stmt 1
 1861 0f1c 50629FE5 		ldr	r6, .L236+28
2206:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1862              		.loc 1 2206 0
 1863 0f20 50129FE5 		ldr	r1, .L236+32
 1864 0f24 0400A0E3 		mov	r0, #4
 1865 0f28 FEFFFFEB 		bl	CyU3PDebugPrint
 1866              	.LVL200:
2207:../uvc.c      ****                     gpif_initialized = 0;
 1867              		.loc 1 2207 0
 1868 0f2c 0400A0E1 		mov	r0, r4
 1869 0f30 FEFFFFEB 		bl	CyU3PGpifDisable
 1870              	.LVL201:
2211:../uvc.c      ****                     CyU3PBusyWait (100);
 1871              		.loc 1 2211 0
 1872 0f34 0410A0E1 		mov	r1, r4
 1873 0f38 8300A0E3 		mov	r0, #131
2208:../uvc.c      ****                     streamingStarted = CyFalse;
 1874              		.loc 1 2208 0
 1875 0f3c 6C5086E5 		str	r5, [r6, #108]
2209:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1876              		.loc 1 2209 0
 1877 0f40 705086E5 		str	r5, [r6, #112]
2211:../uvc.c      ****                     CyU3PBusyWait (100);
 1878              		.loc 1 2211 0
 1879 0f44 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1880              	.LVL202:
2212:../uvc.c      **** 
 1881              		.loc 1 2212 0
 1882 0f48 6400A0E3 		mov	r0, #100
 1883 0f4c FEFFFFEB 		bl	CyFx3BusyWait
 1884              	.LVL203:
2215:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1885              		.loc 1 2215 0
 1886 0f50 24029FE5 		ldr	r0, .L236+36
 1887 0f54 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1888              	.LVL204:
2216:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1889              		.loc 1 2216 0
 1890 0f58 8300A0E3 		mov	r0, #131
 1891 0f5c FEFFFFEB 		bl	CyU3PUsbFlushEp
 1892              	.LVL205:
2217:../uvc.c      ****                     CyU3PBusyWait (100);
 1893              		.loc 1 2217 0
 1894 0f60 0510A0E1 		mov	r1, r5
 1895 0f64 8300A0E3 		mov	r0, #131
 1896 0f68 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1897              	.LVL206:
2218:../uvc.c      **** 
 1898              		.loc 1 2218 0
 1899 0f6c 6400A0E3 		mov	r0, #100
 1900 0f70 FEFFFFEB 		bl	CyFx3BusyWait
 1901              	.LVL207:
2221:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1902              		.loc 1 2221 0
 1903 0f74 0420A0E1 		mov	r2, r4
 1904 0f78 0510A0E1 		mov	r1, r5
 1905 0f7c 8300A0E3 		mov	r0, #131
 1906 0f80 FEFFFFEB 		bl	CyU3PUsbStall
 1907              	.LVL208:
2224:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1908              		.loc 1 2224 0
 1909 0f84 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1910              	.LVL209:
2226:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1911              		.loc 1 2226 0
 1912 0f88 92C0D6E5 		ldrb	ip, [r6, #146]	@ zero_extendqisi2
 1913              	.LBB76:
 1914              	.LBB77:
2074:../uvc.c      **** 	{
 1915              		.loc 1 2074 0
 1916 0f8c 0410A0E1 		mov	r1, r4
 1917              	.LBE77:
 1918              	.LBE76:
2226:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1919              		.loc 1 2226 0
 1920 0f90 08C08CE3 		orr	ip, ip, #8
 1921              	.LBB83:
 1922              	.LBB80:
2074:../uvc.c      **** 	{
 1923              		.loc 1 2074 0
 1924 0f94 00508DE5 		str	r5, [sp]
 1925 0f98 0600A0E1 		mov	r0, r6
 1926              	.LBE80:
 1927              	.LBE83:
2227:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1928              		.loc 1 2227 0
 1929 0f9c 744086E5 		str	r4, [r6, #116]
 1930              	.LBB84:
 1931              	.LBB81:
2074:../uvc.c      **** 	{
 1932              		.loc 1 2074 0
 1933 0fa0 0220A0E3 		mov	r2, #2
 1934 0fa4 14308DE2 		add	r3, sp, #20
 1935              	.LBE81:
 1936              	.LBE84:
2226:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1937              		.loc 1 2226 0
 1938 0fa8 92C0C6E5 		strb	ip, [r6, #146]
 1939              	.LBB85:
 1940              	.LBB82:
2074:../uvc.c      **** 	{
 1941              		.loc 1 2074 0
 1942 0fac FEFFFFEB 		bl	_txe_event_flags_get
 1943              	.LVL210:
 1944 0fb0 004050E2 		subs	r4, r0, #0
 1945 0fb4 1D00001A 		bne	.L230
 1946              	.LBB78:
 1947              	.LBB79:
2077:../uvc.c      **** 
 1948              		.loc 1 2077 0
 1949 0fb8 0600A0E1 		mov	r0, r6
 1950 0fbc 0110E0E3 		mvn	r1, #1
 1951 0fc0 0220A0E3 		mov	r2, #2
 1952 0fc4 FEFFFFEB 		bl	_txe_event_flags_set
 1953              	.LVL211:
2080:../uvc.c      **** 	}
 1954              		.loc 1 2080 0
 1955 0fc8 0600A0E1 		mov	r0, r6
 1956 0fcc 0420A0E1 		mov	r2, r4
 1957 0fd0 0210A0E3 		mov	r1, #2
 1958 0fd4 FEFFFFEB 		bl	_txe_event_flags_set
 1959              	.LVL212:
 1960 0fd8 140000EA 		b	.L230
 1961              	.LVL213:
 1962              	.L231:
 1963              	.LBE79:
 1964              	.LBE78:
 1965              	.LBE82:
 1966              	.LBE85:
2152:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1967              		.loc 1 2152 0
 1968 0fdc 90119FE5 		ldr	r1, .L236+28
2153:../uvc.c      **** 		dbgIdx++;
 1969              		.loc 1 2153 0
 1970 0fe0 00C0D7E5 		ldrb	ip, [r7]	@ zero_extendqisi2
2154:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
 1971              		.loc 1 2154 0
 1972 0fe4 010083E2 		add	r0, r3, #1
 1973 0fe8 FF0000E2 		and	r0, r0, #255
2152:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1974              		.loc 1 2152 0
 1975 0fec 833081E0 		add	r3, r1, r3, asl #1
 1976 0ff0 9040C3E5 		strb	r4, [r3, #144]
2153:../uvc.c      **** 		dbgIdx++;
 1977              		.loc 1 2153 0
 1978 0ff4 91C0C3E5 		strb	ip, [r3, #145]
2154:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
 1979              		.loc 1 2154 0
 1980 0ff8 F804C2E5 		strb	r0, [r2, #1272]
2155:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 1981              		.loc 1 2155 0
 1982 0ffc 0F01C1E5 		strb	r0, [r1, #271]
 1983 1000 9DFFFFEA 		b	.L199
 1984              	.L204:
2164:../uvc.c      ****             {
 1985              		.loc 1 2164 0
 1986 1004 0040D8E5 		ldrb	r4, [r8]	@ zero_extendqisi2
 1987 1008 000054E3 		cmp	r4, #0
 1988 100c 0A00000A 		beq	.L205
 1989 1010 010054E3 		cmp	r4, #1
 1990 1014 9FFFFF1A 		bne	.L219
 1991              	.LVL214:
2182:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1992              		.loc 1 2182 0
 1993 1018 0020A0E3 		mov	r2, #0
 1994 101c 50019FE5 		ldr	r0, .L236+28
 1995 1020 0810A0E3 		mov	r1, #8
 1996 1024 FEFFFFEB 		bl	_txe_event_flags_set
 1997              	.LVL215:
2184:../uvc.c      ****                         {
 1998              		.loc 1 2184 0
 1999 1028 002050E2 		subs	r2, r0, #0
 2000 102c 1000001A 		bne	.L235
 2001              	.LVL216:
 2002              	.L230:
2168:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 2003              		.loc 1 2168 0
 2004 1030 0100A0E3 		mov	r0, #1
 2005              	.LVL217:
2288:../uvc.c      **** 
 2006              		.loc 1 2288 0
 2007 1034 1CD08DE2 		add	sp, sp, #28
 2008              		@ sp needed
 2009 1038 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2010              	.LVL218:
 2011              	.L205:
2169:../uvc.c      ****                                 CYU3P_EVENT_OR);
 2012              		.loc 1 2169 0
 2013 103c 0420A0E1 		mov	r2, r4
 2014 1040 2C019FE5 		ldr	r0, .L236+28
 2015 1044 0410A0E3 		mov	r1, #4
 2016 1048 FEFFFFEB 		bl	_txe_event_flags_set
 2017              	.LVL219:
2171:../uvc.c      ****                         {
 2018              		.loc 1 2171 0
 2019 104c 002050E2 		subs	r2, r0, #0
 2020 1050 F6FFFF0A 		beq	.L230
2173:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 2021              		.loc 1 2173 0
 2022 1054 24119FE5 		ldr	r1, .L236+40
 2023 1058 0400A0E3 		mov	r0, #4
 2024              	.LVL220:
 2025 105c FEFFFFEB 		bl	CyU3PDebugPrint
 2026              	.LVL221:
2174:../uvc.c      ****                         }
 2027              		.loc 1 2174 0
 2028 1060 0400A0E1 		mov	r0, r4
 2029 1064 0420A0E1 		mov	r2, r4
 2030 1068 0110A0E3 		mov	r1, #1
 2031 106c FEFFFFEB 		bl	CyU3PUsbStall
 2032              	.LVL222:
 2033 1070 EEFFFFEA 		b	.L230
 2034              	.LVL223:
 2035              	.L235:
2187:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 2036              		.loc 1 2187 0
 2037 1074 08119FE5 		ldr	r1, .L236+44
 2038 1078 0400A0E3 		mov	r0, #4
 2039              	.LVL224:
 2040 107c FEFFFFEB 		bl	CyU3PDebugPrint
 2041              	.LVL225:
2188:../uvc.c      ****                         }
 2042              		.loc 1 2188 0
 2043 1080 0000A0E3 		mov	r0, #0
 2044 1084 0020A0E1 		mov	r2, r0
 2045 1088 0410A0E1 		mov	r1, r4
 2046 108c FEFFFFEB 		bl	CyU3PUsbStall
 2047              	.LVL226:
2181:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 2048              		.loc 1 2181 0
 2049 1090 0400A0E1 		mov	r0, r4
 2050 1094 80FFFFEA 		b	.L200
 2051              	.LVL227:
 2052              	.L234:
2245:../uvc.c      **** 
 2053              		.loc 1 2245 0
 2054 1098 E8109FE5 		ldr	r1, .L236+48
 2055 109c 0400A0E3 		mov	r0, #4
 2056 10a0 FEFFFFEB 		bl	CyU3PDebugPrint
 2057              	.LVL228:
2248:../uvc.c      ****                         gpif_initialized = 0;
 2058              		.loc 1 2248 0
 2059 10a4 0800A0E1 		mov	r0, r8
 2060 10a8 FEFFFFEB 		bl	CyU3PGpifDisable
 2061              	.LVL229:
2249:../uvc.c      ****                         streamingStarted = CyFalse;
 2062              		.loc 1 2249 0
 2063 10ac 0050A0E3 		mov	r5, #0
2253:../uvc.c      ****                         CyU3PBusyWait (100);
 2064              		.loc 1 2253 0
 2065 10b0 0810A0E1 		mov	r1, r8
 2066 10b4 0600A0E1 		mov	r0, r6
2249:../uvc.c      ****                         streamingStarted = CyFalse;
 2067              		.loc 1 2249 0
 2068 10b8 6C5087E5 		str	r5, [r7, #108]
2250:../uvc.c      **** 
 2069              		.loc 1 2250 0
 2070 10bc 705087E5 		str	r5, [r7, #112]
2253:../uvc.c      ****                         CyU3PBusyWait (100);
 2071              		.loc 1 2253 0
 2072 10c0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 2073              	.LVL230:
2254:../uvc.c      **** 
 2074              		.loc 1 2254 0
 2075 10c4 6400A0E3 		mov	r0, #100
 2076 10c8 FEFFFFEB 		bl	CyFx3BusyWait
 2077              	.LVL231:
2257:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 2078              		.loc 1 2257 0
 2079 10cc A8009FE5 		ldr	r0, .L236+36
 2080 10d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 2081              	.LVL232:
2258:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 2082              		.loc 1 2258 0
 2083 10d4 0600A0E1 		mov	r0, r6
 2084 10d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
 2085              	.LVL233:
2259:../uvc.c      ****                         CyU3PBusyWait (100);
 2086              		.loc 1 2259 0
 2087 10dc 0510A0E1 		mov	r1, r5
 2088 10e0 0600A0E1 		mov	r0, r6
 2089 10e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 2090              	.LVL234:
2260:../uvc.c      **** 
 2091              		.loc 1 2260 0
 2092 10e8 6400A0E3 		mov	r0, #100
 2093 10ec FEFFFFEB 		bl	CyFx3BusyWait
 2094              	.LVL235:
2263:../uvc.c      **** 
 2095              		.loc 1 2263 0
 2096 10f0 0510A0E1 		mov	r1, r5
 2097 10f4 0820A0E1 		mov	r2, r8
 2098 10f8 0600A0E1 		mov	r0, r6
 2099 10fc FEFFFFEB 		bl	CyU3PUsbStall
 2100              	.LVL236:
2267:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 2101              		.loc 1 2267 0
 2102 1100 FEFFFFEB 		bl	CyU3PUsbAckSetup
 2103              	.LVL237:
2270:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 2104              		.loc 1 2270 0
 2105 1104 92C0D7E5 		ldrb	ip, [r7, #146]	@ zero_extendqisi2
 2106              	.LBB86:
 2107              	.LBB87:
2074:../uvc.c      **** 	{
 2108              		.loc 1 2074 0
 2109 1108 0810A0E1 		mov	r1, r8
 2110              	.LBE87:
 2111              	.LBE86:
2270:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 2112              		.loc 1 2270 0
 2113 110c 10C08CE3 		orr	ip, ip, #16
 2114              	.LBB92:
 2115              	.LBB90:
2074:../uvc.c      **** 	{
 2116              		.loc 1 2074 0
 2117 1110 00508DE5 		str	r5, [sp]
 2118 1114 0700A0E1 		mov	r0, r7
 2119 1118 0420A0E1 		mov	r2, r4
 2120 111c 14308DE2 		add	r3, sp, #20
 2121              	.LBE90:
 2122              	.LBE92:
2269:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 2123              		.loc 1 2269 0
 2124 1120 748087E5 		str	r8, [r7, #116]
2270:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 2125              		.loc 1 2270 0
 2126 1124 92C0C7E5 		strb	ip, [r7, #146]
 2127              	.LBB93:
 2128              	.LBB91:
2074:../uvc.c      **** 	{
 2129              		.loc 1 2074 0
 2130 1128 FEFFFFEB 		bl	_txe_event_flags_get
 2131              	.LVL238:
 2132 112c 005050E2 		subs	r5, r0, #0
 2133 1130 BEFFFF1A 		bne	.L230
 2134              	.LBB88:
 2135              	.LBB89:
2077:../uvc.c      **** 
 2136              		.loc 1 2077 0
 2137 1134 0420A0E1 		mov	r2, r4
 2138 1138 0700A0E1 		mov	r0, r7
 2139 113c 0110E0E3 		mvn	r1, #1
 2140 1140 FEFFFFEB 		bl	_txe_event_flags_set
 2141              	.LVL239:
2080:../uvc.c      **** 	}
 2142              		.loc 1 2080 0
 2143 1144 0700A0E1 		mov	r0, r7
 2144 1148 0410A0E1 		mov	r1, r4
 2145 114c 0520A0E1 		mov	r2, r5
 2146 1150 FEFFFFEB 		bl	_txe_event_flags_set
 2147              	.LVL240:
 2148 1154 B5FFFFEA 		b	.L230
 2149              	.L237:
 2150              		.align	2
 2151              	.L236:
 2152 1158 00000000 		.word	bRequest
 2153 115c 00000000 		.word	wLength
 2154 1160 00000000 		.word	wIndex
 2155 1164 00000000 		.word	bmReqType
 2156 1168 00000000 		.word	wValue
 2157 116c B8020000 		.word	.LC18
 2158 1170 00000000 		.word	.LANCHOR1
 2159 1174 00000000 		.word	.LANCHOR0
 2160 1178 80030000 		.word	.LC21
 2161 117c 00000000 		.word	glChHandleUVCStream
 2162 1180 14030000 		.word	.LC19
 2163 1184 4C030000 		.word	.LC20
 2164 1188 98030000 		.word	.LC22
 2165              	.LBE89:
 2166              	.LBE88:
 2167              	.LBE91:
 2168              	.LBE93:
 2169              		.cfi_endproc
 2170              	.LFE10:
 2172              		.align	2
 2173              		.global	I2CCmdHandler
 2175              	I2CCmdHandler:
 2176              	.LFB0:
 615:../uvc.c      **** 	uint8_t buf[2];
 2177              		.loc 1 615 0
 2178              		.cfi_startproc
 2179              		@ args = 0, pretend = 0, frame = 8
 2180              		@ frame_needed = 0, uses_anonymous_args = 0
 2181 118c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2182              	.LCFI11:
 2183              		.cfi_def_cfa_offset 36
 2184              		.cfi_offset 4, -36
 2185              		.cfi_offset 5, -32
 2186              		.cfi_offset 6, -28
 2187              		.cfi_offset 7, -24
 2188              		.cfi_offset 8, -20
 2189              		.cfi_offset 9, -16
 2190              		.cfi_offset 10, -12
 2191              		.cfi_offset 11, -8
 2192              		.cfi_offset 14, -4
 618:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 2193              		.loc 1 618 0
 2194 1190 00439FE5 		ldr	r4, .L273
 615:../uvc.c      **** 	uint8_t buf[2];
 2195              		.loc 1 615 0
 2196 1194 34D04DE2 		sub	sp, sp, #52
 2197              	.LCFI12:
 2198              		.cfi_def_cfa_offset 88
 623:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 2199              		.loc 1 623 0
 2200 1198 1A31D4E5 		ldrb	r3, [r4, #282]	@ zero_extendqisi2
 618:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 2201              		.loc 1 618 0
 2202 119c 1451D4E5 		ldrb	r5, [r4, #276]	@ zero_extendqisi2
 2203              	.LVL241:
 619:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 2204              		.loc 1 619 0
 2205 11a0 1571D4E5 		ldrb	r7, [r4, #277]	@ zero_extendqisi2
 2206              	.LVL242:
 620:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 2207              		.loc 1 620 0
 2208 11a4 1C61D4E5 		ldrb	r6, [r4, #284]	@ zero_extendqisi2
 2209              	.LVL243:
 623:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 2210              		.loc 1 623 0
 2211 11a8 16B1D4E5 		ldrb	fp, [r4, #278]	@ zero_extendqisi2
 2212 11ac 17A1D4E5 		ldrb	r10, [r4, #279]	@ zero_extendqisi2
 2213 11b0 1891D4E5 		ldrb	r9, [r4, #280]	@ zero_extendqisi2
 2214 11b4 1981D4E5 		ldrb	r8, [r4, #281]	@ zero_extendqisi2
 2215 11b8 10308DE5 		str	r3, [sp, #16]
 2216 11bc 1E11D4E5 		ldrb	r1, [r4, #286]	@ zero_extendqisi2
 2217 11c0 1BE1D4E5 		ldrb	lr, [r4, #283]	@ zero_extendqisi2
 2218 11c4 1DC1D4E5 		ldrb	ip, [r4, #285]	@ zero_extendqisi2
 2219 11c8 0730A0E1 		mov	r3, r7
 2220 11cc 20108DE5 		str	r1, [sp, #32]
 2221 11d0 0400A0E3 		mov	r0, #4
 2222 11d4 0520A0E1 		mov	r2, r5
 2223 11d8 18608DE5 		str	r6, [sp, #24]
 2224 11dc 00B08DE5 		str	fp, [sp]
 2225 11e0 04A08DE5 		str	r10, [sp, #4]
 2226 11e4 08908DE5 		str	r9, [sp, #8]
 2227 11e8 0C808DE5 		str	r8, [sp, #12]
 2228 11ec 14E08DE5 		str	lr, [sp, #20]
 2229 11f0 1CC08DE5 		str	ip, [sp, #28]
 2230 11f4 A0129FE5 		ldr	r1, .L273+4
 2231 11f8 FEFFFFEB 		bl	CyU3PDebugPrint
 2232              	.LVL244:
 626:../uvc.c      **** 	{
 2233              		.loc 1 626 0
 2234 11fc 1631D4E5 		ldrb	r3, [r4, #278]	@ zero_extendqisi2
 2235 1200 700053E3 		cmp	r3, #112
 2236 1204 1100000A 		beq	.L265
 637:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 2237              		.loc 1 637 0
 2238 1208 000055E3 		cmp	r5, #0
 2239 120c 0300000A 		beq	.L266
 672:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 2240              		.loc 1 672 0
 2241 1210 010055E3 		cmp	r5, #1
 2242 1214 2F00000A 		beq	.L267
 2243              	.LVL245:
 2244              	.L238:
 728:../uvc.c      **** 
 2245              		.loc 1 728 0
 2246 1218 34D08DE2 		add	sp, sp, #52
 2247              		@ sp needed
 2248 121c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2249              	.LVL246:
 2250              	.L266:
 639:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 2251              		.loc 1 639 0
 2252 1220 1721D4E5 		ldrb	r2, [r4, #279]	@ zero_extendqisi2
 638:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 2253              		.loc 1 638 0
 2254 1224 0F10A0E3 		mov	r1, #15
 639:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 2255              		.loc 1 639 0
 2256 1228 000052E3 		cmp	r2, #0
 638:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 2257              		.loc 1 638 0
 2258 122c 1F11C4E5 		strb	r1, [r4, #287]
 639:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 2259              		.loc 1 639 0
 2260 1230 2000001A 		bne	.L243
 640:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 2261              		.loc 1 640 0
 2262 1234 000053E3 		cmp	r3, #0
 2263 1238 3400001A 		bne	.L244
 641:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 2264              		.loc 1 641 0
 2265 123c 9020D4E5 		ldrb	r2, [r4, #144]	@ zero_extendqisi2
 642:../uvc.c      **** 			}
 2266              		.loc 1 642 0
 2267 1240 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 641:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 2268              		.loc 1 641 0
 2269 1244 1E21C4E5 		strb	r2, [r4, #286]
 642:../uvc.c      **** 			}
 2270              		.loc 1 642 0
 2271 1248 1D31C4E5 		strb	r3, [r4, #285]
 2272 124c 150000EA 		b	.L252
 2273              	.L265:
 626:../uvc.c      **** 	{
 2274              		.loc 1 626 0 discriminator 1
 2275 1250 1731D4E5 		ldrb	r3, [r4, #279]	@ zero_extendqisi2
 2276 1254 520053E3 		cmp	r3, #82
 2277 1258 3600000A 		beq	.L268
 2278              	.L240:
 683:../uvc.c      **** 	{
 2279              		.loc 1 683 0
 2280 125c 000055E3 		cmp	r5, #0
 2281 1260 5600001A 		bne	.L251
 699:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2282              		.loc 1 699 0
 2283 1264 1601D4E5 		ldrb	r0, [r4, #278]	@ zero_extendqisi2
 2284 1268 1711D4E5 		ldrb	r1, [r4, #279]	@ zero_extendqisi2
 2285 126c 28C08DE2 		add	ip, sp, #40
 2286 1270 1821D4E5 		ldrb	r2, [r4, #280]	@ zero_extendqisi2
 2287 1274 1931D4E5 		ldrb	r3, [r4, #281]	@ zero_extendqisi2
 2288 1278 00C08DE5 		str	ip, [sp]
 685:../uvc.c      **** #if 0 //for debugging
 2289              		.loc 1 685 0
 2290 127c 0FC0A0E3 		mov	ip, #15
 699:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2291              		.loc 1 699 0
 2292 1280 010080E3 		orr	r0, r0, #1
 2293 1284 011081E3 		orr	r1, r1, #1
 685:../uvc.c      **** #if 0 //for debugging
 2294              		.loc 1 685 0
 2295 1288 1FC1C4E5 		strb	ip, [r4, #287]
 699:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2296              		.loc 1 699 0
 2297 128c FEFFFFEB 		bl	SensorRead2B
 2298              	.LVL247:
 700:../uvc.c      **** 				if(CmdDataLen == 2){
 2299              		.loc 1 700 0
 2300 1290 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 701:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2301              		.loc 1 701 0
 2302 1294 020056E3 		cmp	r6, #2
 700:../uvc.c      **** 				if(CmdDataLen == 2){
 2303              		.loc 1 700 0
 2304 1298 1D31C4E5 		strb	r3, [r4, #285]
 702:../uvc.c      **** 				}
 2305              		.loc 1 702 0
 2306 129c 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
 685:../uvc.c      **** #if 0 //for debugging
 2307              		.loc 1 685 0
 2308 12a0 F0319FE5 		ldr	r3, .L273
 702:../uvc.c      **** 				}
 2309              		.loc 1 702 0
 2310 12a4 1E21C305 		streqb	r2, [r3, #286]
 2311              	.LVL248:
 2312              	.L252:
 704:../uvc.c      **** 		}else{//not support currently
 2313              		.loc 1 704 0
 2314 12a8 0030E0E3 		mvn	r3, #0
 2315 12ac 1F31C4E5 		strb	r3, [r4, #287]
 728:../uvc.c      **** 
 2316              		.loc 1 728 0
 2317 12b0 34D08DE2 		add	sp, sp, #52
 2318              		@ sp needed
 2319 12b4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2320              	.LVL249:
 2321              	.L243:
 662:../uvc.c      **** 			{
 2322              		.loc 1 662 0
 2323 12b8 010052E3 		cmp	r2, #1
 2324 12bc F9FFFF1A 		bne	.L252
 664:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 2325              		.loc 1 664 0
 2326 12c0 833084E0 		add	r3, r4, r3, asl #1
 2327 12c4 2021D3E5 		ldrb	r2, [r3, #288]	@ zero_extendqisi2
 665:../uvc.c      **** 			}
 2328              		.loc 1 665 0
 2329 12c8 2131D3E5 		ldrb	r3, [r3, #289]	@ zero_extendqisi2
 664:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 2330              		.loc 1 664 0
 2331 12cc 1D21C4E5 		strb	r2, [r4, #285]
 665:../uvc.c      **** 			}
 2332              		.loc 1 665 0
 2333 12d0 1E31C4E5 		strb	r3, [r4, #286]
 2334 12d4 F3FFFFEA 		b	.L252
 2335              	.L267:
 676:../uvc.c      **** 			valIdx = 1;
 2336              		.loc 1 676 0
 2337 12d8 C0219FE5 		ldr	r2, .L273+8
 673:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 2338              		.loc 1 673 0
 2339 12dc 0030A0E3 		mov	r3, #0
 676:../uvc.c      **** 			valIdx = 1;
 2340              		.loc 1 676 0
 2341 12e0 0210A0E3 		mov	r1, #2
 678:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 2342              		.loc 1 678 0
 2343 12e4 2151C4E5 		strb	r5, [r4, #289]
 677:../uvc.c      **** 			value[0][1] = valIdx;
 2344              		.loc 1 677 0
 2345 12e8 F954C2E5 		strb	r5, [r2, #1273]
 676:../uvc.c      **** 			valIdx = 1;
 2346              		.loc 1 676 0
 2347 12ec F814C2E5 		strb	r1, [r2, #1272]
 673:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 2348              		.loc 1 673 0
 2349 12f0 9030C4E5 		strb	r3, [r4, #144]
 2350 12f4 9130C4E5 		strb	r3, [r4, #145]
 674:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 2351              		.loc 1 674 0
 2352 12f8 9230C4E5 		strb	r3, [r4, #146]
 2353 12fc 9330C4E5 		strb	r3, [r4, #147]
 675:../uvc.c      **** 			dbgIdx = 2;
 2354              		.loc 1 675 0
 2355 1300 AE30C4E5 		strb	r3, [r4, #174]
 2356 1304 AF30C4E5 		strb	r3, [r4, #175]
 728:../uvc.c      **** 
 2357              		.loc 1 728 0
 2358 1308 34D08DE2 		add	sp, sp, #52
 2359              		@ sp needed
 2360 130c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2361              	.LVL250:
 2362              	.L244:
 644:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 2363              		.loc 1 644 0
 2364 1310 010053E3 		cmp	r3, #1
 2365 1314 1A00000A 		beq	.L269
 648:../uvc.c      **** 				CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2366              		.loc 1 648 0
 2367 1318 110053E3 		cmp	r3, #17
 2368 131c 1E00000A 		beq	.L270
 659:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 2369              		.loc 1 659 0
 2370 1320 833084E0 		add	r3, r4, r3, asl #1
 2371 1324 9020D3E5 		ldrb	r2, [r3, #144]	@ zero_extendqisi2
 660:../uvc.c      **** 			}
 2372              		.loc 1 660 0
 2373 1328 9130D3E5 		ldrb	r3, [r3, #145]	@ zero_extendqisi2
 659:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 2374              		.loc 1 659 0
 2375 132c 1D21C4E5 		strb	r2, [r4, #285]
 660:../uvc.c      **** 			}
 2376              		.loc 1 660 0
 2377 1330 1E31C4E5 		strb	r3, [r4, #286]
 2378 1334 DBFFFFEA 		b	.L252
 2379              	.L268:
 626:../uvc.c      **** 	{
 2380              		.loc 1 626 0 discriminator 1
 2381 1338 1831D4E5 		ldrb	r3, [r4, #280]	@ zero_extendqisi2
 2382 133c 300053E3 		cmp	r3, #48
 2383 1340 C5FFFF1A 		bne	.L240
 2384 1344 1931D4E5 		ldrb	r3, [r4, #281]	@ zero_extendqisi2
 2385 1348 010053E3 		cmp	r3, #1
 2386 134c C2FFFF1A 		bne	.L240
 628:../uvc.c      **** 		if(is60Hz==CyFalse)
 2387              		.loc 1 628 0
 2388 1350 1D21D4E5 		ldrb	r2, [r4, #285]	@ zero_extendqisi2
 2389 1354 44319FE5 		ldr	r3, .L273+8
 2390 1358 031002E2 		and	r1, r2, #3
 2391 135c D214C3E5 		strb	r1, [r3, #1234]
 629:../uvc.c      **** 			{
 2392              		.loc 1 629 0
 2393 1360 781094E5 		ldr	r1, [r4, #120]
 633:../uvc.c      **** 
 2394              		.loc 1 633 0
 2395 1364 0400A0E3 		mov	r0, #4
 629:../uvc.c      **** 			{
 2396              		.loc 1 629 0
 2397 1368 000051E3 		cmp	r1, #0
 631:../uvc.c      **** 			}
 2398              		.loc 1 631 0
 2399 136c 80208203 		orreq	r2, r2, #128
 633:../uvc.c      **** 
 2400              		.loc 1 633 0
 2401 1370 D234D3E5 		ldrb	r3, [r3, #1234]	@ zero_extendqisi2
 2402 1374 28119FE5 		ldr	r1, .L273+12
 631:../uvc.c      **** 			}
 2403              		.loc 1 631 0
 2404 1378 1D21C405 		streqb	r2, [r4, #285]
 633:../uvc.c      **** 
 2405              		.loc 1 633 0
 2406 137c FEFFFFEB 		bl	CyU3PDebugPrint
 2407              	.LVL251:
 2408 1380 B5FFFFEA 		b	.L240
 2409              	.L269:
 646:../uvc.c      **** 			}
 2410              		.loc 1 646 0
 2411 1384 14319FE5 		ldr	r3, .L273+8
 645:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 2412              		.loc 1 645 0
 2413 1388 9220D4E5 		ldrb	r2, [r4, #146]	@ zero_extendqisi2
 646:../uvc.c      **** 			}
 2414              		.loc 1 646 0
 2415 138c F834D3E5 		ldrb	r3, [r3, #1272]	@ zero_extendqisi2
 645:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 2416              		.loc 1 645 0
 2417 1390 1D21C4E5 		strb	r2, [r4, #285]
 646:../uvc.c      **** 			}
 2418              		.loc 1 646 0
 2419 1394 1E31C4E5 		strb	r3, [r4, #286]
 2420 1398 C2FFFFEA 		b	.L252
 2421              	.L270:
 2422              	.LVL252:
 2423              	.LBB94:
 650:../uvc.c      **** 
 2424              		.loc 1 650 0
 2425 139c 0400A0E1 		mov	r0, r4
 2426 13a0 0110A0E3 		mov	r1, #1
 2427 13a4 FEFFFFEB 		bl	_txe_event_flags_set
 2428              	.LVL253:
 652:../uvc.c      **** 				{
 2429              		.loc 1 652 0
 2430 13a8 002050E2 		subs	r2, r0, #0
 2431 13ac BDFFFF0A 		beq	.L252
 654:../uvc.c      **** 				}
 2432              		.loc 1 654 0
 2433 13b0 F0109FE5 		ldr	r1, .L273+16
 2434 13b4 0400A0E3 		mov	r0, #4
 2435              	.LVL254:
 2436 13b8 FEFFFFEB 		bl	CyU3PDebugPrint
 2437              	.LVL255:
 2438 13bc B9FFFFEA 		b	.L252
 2439              	.L251:
 2440              	.LBE94:
 708:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 2441              		.loc 1 708 0
 2442 13c0 010055E3 		cmp	r5, #1
 2443 13c4 93FFFF1A 		bne	.L238
 710:../uvc.c      **** 				for(i = 0; i<4; i++)
 2444              		.loc 1 710 0
 2445 13c8 020057E3 		cmp	r7, #2
 2446 13cc 1000000A 		beq	.L271
 715:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2447              		.loc 1 715 0
 2448 13d0 1711D4E5 		ldrb	r1, [r4, #279]	@ zero_extendqisi2
 2449 13d4 BC009FE5 		ldr	r0, .L273
 2450 13d8 FE1001E2 		and	r1, r1, #254
 2451 13dc 820051E3 		cmp	r1, #130
 2452 13e0 0200001A 		bne	.L258
 715:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2453              		.loc 1 715 0 is_stmt 0 discriminator 1
 2454 13e4 1851D0E5 		ldrb	r5, [r0, #280]	@ zero_extendqisi2
 2455              	.LVL256:
 2456 13e8 300055E3 		cmp	r5, #48
 2457 13ec 1500000A 		beq	.L272
 2458              	.L258:
 2459 13f0 1821D4E5 		ldrb	r2, [r4, #280]	@ zero_extendqisi2
 2460 13f4 1931D4E5 		ldrb	r3, [r4, #281]	@ zero_extendqisi2
 2461              	.LVL257:
 2462              	.L259:
 720:../uvc.c      **** 				//if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 2463              		.loc 1 720 0 is_stmt 1
 2464 13f8 1601D4E5 		ldrb	r0, [r4, #278]	@ zero_extendqisi2
 2465 13fc 1DC1D4E5 		ldrb	ip, [r4, #285]	@ zero_extendqisi2
 2466 1400 FE0000E2 		and	r0, r0, #254
 2467 1404 00C08DE5 		str	ip, [sp]
 2468 1408 FEFFFFEB 		bl	SensorWrite2B
 2469              	.LVL258:
 728:../uvc.c      **** 
 2470              		.loc 1 728 0
 2471 140c 34D08DE2 		add	sp, sp, #52
 2472              		@ sp needed
 2473 1410 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2474              	.LVL259:
 2475              	.L271:
 710:../uvc.c      **** 				for(i = 0; i<4; i++)
 2476              		.loc 1 710 0
 2477 1414 0450A0E3 		mov	r5, #4
 2478              	.LVL260:
 2479              	.L257:
 712:../uvc.c      **** 			}
 2480              		.loc 1 712 0 discriminator 2
 2481 1418 1601D4E5 		ldrb	r0, [r4, #278]	@ zero_extendqisi2
 2482 141c 1D21D4E5 		ldrb	r2, [r4, #285]	@ zero_extendqisi2
 2483 1420 1711D4E5 		ldrb	r1, [r4, #279]	@ zero_extendqisi2
 2484 1424 1831D4E5 		ldrb	r3, [r4, #280]	@ zero_extendqisi2
 2485 1428 FE0000E2 		and	r0, r0, #254
 2486 142c 00208DE5 		str	r2, [sp]
 2487 1430 015045E2 		sub	r5, r5, #1
 2488 1434 0020A0E3 		mov	r2, #0
 2489 1438 FEFFFFEB 		bl	SensorWrite2B2
 2490              	.LVL261:
 711:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2491              		.loc 1 711 0 discriminator 2
 2492 143c FF5015E2 		ands	r5, r5, #255
 2493 1440 F4FFFF1A 		bne	.L257
 2494 1444 73FFFFEA 		b	.L238
 2495              	.L272:
 715:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2496              		.loc 1 715 0 discriminator 1
 2497 1448 1961D0E5 		ldrb	r6, [r0, #281]	@ zero_extendqisi2
 2498              	.LVL262:
 2499 144c 100056E3 		cmp	r6, #16
 2500 1450 0630A011 		movne	r3, r6
 2501 1454 0520A011 		movne	r2, r5
 2502 1458 E6FFFF1A 		bne	.L259
 716:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2503              		.loc 1 716 0
 2504 145c 48409FE5 		ldr	r4, .L273+20
 2505 1460 0010E0E3 		mvn	r1, #0
 2506 1464 1C0094E5 		ldr	r0, [r4, #28]
 2507 1468 FEFFFFEB 		bl	_txe_mutex_get
 2508              	.LVL263:
 717:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2509              		.loc 1 717 0
 2510 146c 0010A0E3 		mov	r1, #0
 2511 1470 00108DE5 		str	r1, [sp]
 2512 1474 04108DE5 		str	r1, [sp, #4]
 2513 1478 0620A0E1 		mov	r2, r6
 2514 147c 0530A0E1 		mov	r3, r5
 2515 1480 0400A0E1 		mov	r0, r4
 2516 1484 1710A0E3 		mov	r1, #23
 2517 1488 FEFFFFEB 		bl	cmdSet
 2518              	.LVL264:
 718:../uvc.c      **** 				}
 2519              		.loc 1 718 0
 2520 148c 1C0094E5 		ldr	r0, [r4, #28]
 2521 1490 FEFFFFEB 		bl	_txe_mutex_put
 2522              	.LVL265:
 2523 1494 5FFFFFEA 		b	.L238
 2524              	.L274:
 2525              		.align	2
 2526              	.L273:
 2527 1498 00000000 		.word	.LANCHOR0
 2528 149c BC030000 		.word	.LC23
 2529 14a0 00000000 		.word	.LANCHOR1
 2530 14a4 08040000 		.word	.LC24
 2531 14a8 F0000000 		.word	.LC7
 2532 14ac 00000000 		.word	cmdQu
 2533              		.cfi_endproc
 2534              	.LFE0:
 2536              		.align	2
 2537              		.global	setIrisauto
 2539              	setIrisauto:
 2540              	.LFB1:
 734:../uvc.c      **** 	uint8_t dataIdx = 0;
 2541              		.loc 1 734 0
 2542              		.cfi_startproc
 2543              		@ args = 0, pretend = 0, frame = 0
 2544              		@ frame_needed = 0, uses_anonymous_args = 0
 2545              	.LVL266:
 2546 14b0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2547              	.LCFI13:
 2548              		.cfi_def_cfa_offset 16
 2549              		.cfi_offset 4, -16
 2550              		.cfi_offset 5, -12
 2551              		.cfi_offset 6, -8
 2552              		.cfi_offset 14, -4
 2553 14b4 0150A0E1 		mov	r5, r1
 2554 14b8 08D04DE2 		sub	sp, sp, #8
 2555              	.LCFI14:
 2556              		.cfi_def_cfa_offset 24
 734:../uvc.c      **** 	uint8_t dataIdx = 0;
 2557              		.loc 1 734 0
 2558 14bc 0040A0E1 		mov	r4, r0
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2559              		.loc 1 737 0
 2560 14c0 0060A0E3 		mov	r6, #0
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2561              		.loc 1 736 0
 2562 14c4 0010E0E3 		mvn	r1, #0
 2563              	.LVL267:
 2564 14c8 1C0090E5 		ldr	r0, [r0, #28]
 2565              	.LVL268:
 2566 14cc FEFFFFEB 		bl	_txe_mutex_get
 2567              	.LVL269:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2568              		.loc 1 737 0
 2569 14d0 062055E0 		subs	r2, r5, r6
 2570 14d4 003072E2 		rsbs	r3, r2, #0
 2571 14d8 0230B3E0 		adcs	r3, r3, r2
 2572 14dc 00308DE5 		str	r3, [sp]
 2573 14e0 0400A0E1 		mov	r0, r4
 2574 14e4 04608DE5 		str	r6, [sp, #4]
 2575 14e8 2010A0E3 		mov	r1, #32
 2576 14ec 2720A0E3 		mov	r2, #39
 2577 14f0 3030A0E3 		mov	r3, #48
 2578 14f4 FEFFFFEB 		bl	cmdSet
 2579              	.LVL270:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2580              		.loc 1 738 0
 2581 14f8 060055E1 		cmp	r5, r6
 2582 14fc 0250A003 		moveq	r5, #2
 2583 1500 0150A013 		movne	r5, #1
 2584 1504 60008DE8 		stmia	sp, {r5, r6}
 2585 1508 0400A0E1 		mov	r0, r4
 2586 150c 2110A0E3 		mov	r1, #33
 2587 1510 2520A0E3 		mov	r2, #37
 2588 1514 3030A0E3 		mov	r3, #48
 2589 1518 FEFFFFEB 		bl	cmdSet
 2590              	.LVL271:
 739:../uvc.c      **** }
 2591              		.loc 1 739 0
 2592 151c 1C0094E5 		ldr	r0, [r4, #28]
 740:../uvc.c      **** 
 2593              		.loc 1 740 0
 2594 1520 08D08DE2 		add	sp, sp, #8
 2595              		@ sp needed
 2596 1524 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2597              	.LVL272:
 739:../uvc.c      **** }
 2598              		.loc 1 739 0
 2599 1528 FEFFFFEA 		b	_txe_mutex_put
 2600              	.LVL273:
 2601              		.cfi_endproc
 2602              	.LFE1:
 2604              		.align	2
 2605              		.global	getShutCtrl
 2607              	getShutCtrl:
 2608              	.LFB2:
 744:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2609              		.loc 1 744 0
 2610              		.cfi_startproc
 2611              		@ args = 0, pretend = 0, frame = 0
 2612              		@ frame_needed = 0, uses_anonymous_args = 0
 2613              	.LVL274:
 749:../uvc.c      **** 	case 1:
 2614              		.loc 1 749 0
 2615 152c 013040E2 		sub	r3, r0, #1
 744:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2616              		.loc 1 744 0
 2617 1530 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2618              	.LCFI15:
 2619              		.cfi_def_cfa_offset 12
 2620              		.cfi_offset 4, -12
 2621              		.cfi_offset 5, -8
 2622              		.cfi_offset 14, -4
 2623 1534 0020A0E1 		mov	r2, r0
 2624 1538 0CD04DE2 		sub	sp, sp, #12
 2625              	.LCFI16:
 2626              		.cfi_def_cfa_offset 24
 749:../uvc.c      **** 	case 1:
 2627              		.loc 1 749 0
 2628 153c 090053E3 		cmp	r3, #9
 2629 1540 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2630 1544 350000EA 		b	.L279
 2631              	.L281:
 2632 1548 E4150000 		.word	.L280
 2633 154c E4150000 		.word	.L280
 2634 1550 E4150000 		.word	.L280
 2635 1554 E4150000 		.word	.L280
 2636 1558 E4150000 		.word	.L280
 2637 155c 70150000 		.word	.L282
 2638 1560 70150000 		.word	.L282
 2639 1564 70150000 		.word	.L282
 2640 1568 70150000 		.word	.L282
 2641 156c 70150000 		.word	.L282
 2642              	.L282:
 2643              	.LVL275:
 771:../uvc.c      **** 		fRate = 30;
 2644              		.loc 1 771 0
 2645 1570 D0009FE5 		ldr	r0, .L294
 2646              	.LVL276:
 2647 1574 8330A0E1 		mov	r3, r3, asl #1
 773:../uvc.c      **** 		if(NumLn > 1944)
 2648              		.loc 1 773 0
 2649 1578 B33090E1 		ldrh	r3, [r0, r3]
 2650 157c C8C09FE5 		ldr	ip, .L294+4
 2651 1580 030263E0 		rsb	r0, r3, r3, asl #4
 2652 1584 8000A0E1 		mov	r0, r0, asl #1
 2653 1588 90ECCCE0 		smull	lr, ip, r0, ip
 2654 158c C00FA0E1 		mov	r0, r0, asr #31
 2655 1590 4C0460E0 		rsb	r0, r0, ip, asr #8
 774:../uvc.c      **** 			NumLn =1944;
 2656              		.loc 1 774 0
 2657 1594 B4E09FE5 		ldr	lr, .L294+8
 773:../uvc.c      **** 		if(NumLn > 1944)
 2658              		.loc 1 773 0
 2659 1598 0008A0E1 		mov	r0, r0, asl #16
 2660 159c 20C8A0E1 		mov	ip, r0, lsr #16
 2661              	.LVL277:
 774:../uvc.c      **** 			NumLn =1944;
 2662              		.loc 1 774 0
 2663 15a0 0E005CE1 		cmp	ip, lr
 2664 15a4 1A00008A 		bhi	.L288
 2665              	.LVL278:
 2666              	.L292:
 776:../uvc.c      **** 			NumLn = 8;
 2667              		.loc 1 776 0
 2668 15a8 07005CE3 		cmp	ip, #7
 2669 15ac 2100008A 		bhi	.L293
 2670 15b0 0100A0E3 		mov	r0, #1
 2671 15b4 0040A0E1 		mov	r4, r0
 2672 15b8 08E0A0E3 		mov	lr, #8
 2673              	.L285:
 2674              	.LVL279:
 779:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2675              		.loc 1 779 0
 2676 15bc 0150A0E3 		mov	r5, #1
 780:../uvc.c      **** 		break;
 2677              		.loc 1 780 0
 2678 15c0 04008DE5 		str	r0, [sp, #4]
 2679 15c4 00E08DE5 		str	lr, [sp]
 2680 15c8 0400A0E3 		mov	r0, #4
 779:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2681              		.loc 1 779 0
 2682 15cc 0050C1E5 		strb	r5, [r1]
 780:../uvc.c      **** 		break;
 2683              		.loc 1 780 0
 2684 15d0 7C109FE5 		ldr	r1, .L294+12
 2685              	.LVL280:
 2686 15d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2687              	.LVL281:
 789:../uvc.c      **** 
 2688              		.loc 1 789 0
 2689 15d8 0400A0E1 		mov	r0, r4
 2690 15dc 0CD08DE2 		add	sp, sp, #12
 2691              		@ sp needed
 2692 15e0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2693              	.LVL282:
 2694              	.L280:
 755:../uvc.c      **** 		fRate = 30;
 2695              		.loc 1 755 0
 2696 15e4 5C009FE5 		ldr	r0, .L294
 2697              	.LVL283:
 2698 15e8 8330A0E1 		mov	r3, r3, asl #1
 2699 15ec B33090E1 		ldrh	r3, [r0, r3]
 2700              	.LVL284:
 757:../uvc.c      **** 		if(NumLn > 1944)
 2701              		.loc 1 757 0
 2702 15f0 60009FE5 		ldr	r0, .L294+16
 2703              	.LVL285:
 758:../uvc.c      **** 			NumLn =1944;
 2704              		.loc 1 758 0
 2705 15f4 54E09FE5 		ldr	lr, .L294+8
 757:../uvc.c      **** 		if(NumLn > 1944)
 2706              		.loc 1 757 0
 2707 15f8 93C080E0 		umull	ip, r0, r3, r0
 2708 15fc A004A0E1 		mov	r0, r0, lsr #9
 2709 1600 000260E0 		rsb	r0, r0, r0, asl #4
 2710 1604 8008A0E1 		mov	r0, r0, asl #17
 2711 1608 20C8A0E1 		mov	ip, r0, lsr #16
 2712              	.LVL286:
 758:../uvc.c      **** 			NumLn =1944;
 2713              		.loc 1 758 0
 2714 160c 0E005CE1 		cmp	ip, lr
 2715 1610 E4FFFF9A 		bls	.L292
 2716              	.LVL287:
 2717              	.L288:
 2718 1614 F300A0E3 		mov	r0, #243
 2719 1618 0040A0E1 		mov	r4, r0
 2720 161c E6FFFFEA 		b	.L285
 2721              	.LVL288:
 2722              	.L279:
 785:../uvc.c      **** 		break;
 2723              		.loc 1 785 0
 2724 1620 0140A0E3 		mov	r4, #1
 784:../uvc.c      **** 		LnVal = 1;
 2725              		.loc 1 784 0
 2726 1624 0030A0E3 		mov	r3, #0
 789:../uvc.c      **** 
 2727              		.loc 1 789 0
 2728 1628 0400A0E1 		mov	r0, r4
 2729              	.LVL289:
 784:../uvc.c      **** 		LnVal = 1;
 2730              		.loc 1 784 0
 2731 162c 0030C1E5 		strb	r3, [r1]
 2732              	.LVL290:
 789:../uvc.c      **** 
 2733              		.loc 1 789 0
 2734 1630 0CD08DE2 		add	sp, sp, #12
 2735              		@ sp needed
 2736 1634 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2737              	.LVL291:
 2738              	.L293:
 2739 1638 A009A0E1 		mov	r0, r0, lsr #19
 2740 163c FF4000E2 		and	r4, r0, #255
 2741 1640 0CE0A0E1 		mov	lr, ip
 2742 1644 DCFFFFEA 		b	.L285
 2743              	.L295:
 2744              		.align	2
 2745              	.L294:
 2746 1648 00000000 		.word	.LANCHOR2
 2747 164c 817F807F 		.word	2139127681
 2748 1650 98070000 		.word	1944
 2749 1654 30040000 		.word	.LC25
 2750 1658 01FF00FF 		.word	-16711935
 2751              		.cfi_endproc
 2752              	.LFE2:
 2754              		.align	2
 2755              		.global	ControlHandle
 2757              	ControlHandle:
 2758              	.LFB3:
 791:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2759              		.loc 1 791 0
 2760              		.cfi_startproc
 2761              		@ args = 0, pretend = 0, frame = 24
 2762              		@ frame_needed = 0, uses_anonymous_args = 0
 2763              	.LVL292:
 2764 165c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2765              	.LCFI17:
 2766              		.cfi_def_cfa_offset 36
 2767              		.cfi_offset 4, -36
 2768              		.cfi_offset 5, -32
 2769              		.cfi_offset 6, -28
 2770              		.cfi_offset 7, -24
 2771              		.cfi_offset 8, -20
 2772              		.cfi_offset 9, -16
 2773              		.cfi_offset 10, -12
 2774              		.cfi_offset 11, -8
 2775              		.cfi_offset 14, -4
 799:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2776              		.loc 1 799 0
 2777 1660 BC6F9FE5 		ldr	r6, .L465+48
 797:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2778              		.loc 1 797 0
 2779 1664 208040E2 		sub	r8, r0, #32
 798:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2780              		.loc 1 798 0
 2781 1668 230050E3 		cmp	r0, #35
 791:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2782              		.loc 1 791 0
 2783 166c 2CD04DE2 		sub	sp, sp, #44
 2784              	.LCFI18:
 2785              		.cfi_def_cfa_offset 80
 791:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2786              		.loc 1 791 0
 2787 1670 0040A0E1 		mov	r4, r0
 797:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2788              		.loc 1 797 0
 2789 1674 FF8008E2 		and	r8, r8, #255
 2790              	.LVL293:
 798:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2791              		.loc 1 798 0
 2792 1678 2B00009A 		bls	.L297
 799:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2793              		.loc 1 799 0
 2794 167c 883088E0 		add	r3, r8, r8, asl #1
 2795 1680 8331A0E1 		mov	r3, r3, asl #3
 2796 1684 032086E0 		add	r2, r6, r3
 800:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 2797              		.loc 1 800 0
 2798 1688 01B0D2E5 		ldrb	fp, [r2, #1]	@ zero_extendqisi2
 801:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 2799              		.loc 1 801 0
 2800 168c 0FA0D2E5 		ldrb	r10, [r2, #15]	@ zero_extendqisi2
 802:../uvc.c      ****     }else{
 2801              		.loc 1 802 0
 2802 1690 0290D2E5 		ldrb	r9, [r2, #2]	@ zero_extendqisi2
 813:../uvc.c      ****     /*
 2803              		.loc 1 813 0
 2804 1694 582F9FE5 		ldr	r2, .L465
 799:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2805              		.loc 1 799 0
 2806 1698 0330D6E7 		ldrb	r3, [r6, r3]	@ zero_extendqisi2
 2807              	.LVL294:
 813:../uvc.c      ****     /*
 2808              		.loc 1 813 0
 2809 169c 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2810              	.LVL295:
 821:../uvc.c      **** 		 {
 2811              		.loc 1 821 0
 2812 16a0 830055E3 		cmp	r5, #131
 2813 16a4 2A00000A 		beq	.L300
 2814              	.LVL296:
 2815              	.L458:
 2816 16a8 3300009A 		bls	.L457
 2817 16ac 850055E3 		cmp	r5, #133
 2818 16b0 BC00000A 		beq	.L305
 2819 16b4 C700003A 		bcc	.L306
 2820 16b8 860055E3 		cmp	r5, #134
 2821 16bc 7500000A 		beq	.L307
 2822 16c0 870055E3 		cmp	r5, #135
 2823 16c4 AE00001A 		bne	.L299
1236:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2824              		.loc 1 1236 0
 2825 16c8 230054E3 		cmp	r4, #35
 2826 16cc D100009A 		bls	.L378
1237:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2827              		.loc 1 1237 0
 2828 16d0 888088E0 		add	r8, r8, r8, asl #1
 2829              	.LVL297:
 2830 16d4 886186E0 		add	r6, r6, r8, asl #3
 2831 16d8 4C7F9FE5 		ldr	r7, .L465+56
 2832 16dc 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
1238:../uvc.c      **** 		 	 }
 2833              		.loc 1 1238 0
 2834 16e0 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
1237:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2835              		.loc 1 1237 0
 2836 16e4 2820C7E5 		strb	r2, [r7, #40]
1238:../uvc.c      **** 		 	 }
 2837              		.loc 1 1238 0
 2838 16e8 2930C7E5 		strb	r3, [r7, #41]
 2839              	.L379:
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2840              		.loc 1 1249 0
 2841 16ec 0900A0E1 		mov	r0, r9
 2842              	.LVL298:
1251:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2843              		.loc 1 1251 0
 2844 16f0 FF40A0E3 		mov	r4, #255
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2845              		.loc 1 1249 0
 2846 16f4 FC1E9FE5 		ldr	r1, .L465+4
 2847 16f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2848              	.LVL299:
1251:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2849              		.loc 1 1251 0
 2850 16fc 0490A0E1 		mov	r9, r4
 2851 1700 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 2852 1704 0470A0E1 		mov	r7, r4
 2853              	.LVL300:
 2854              	.L309:
1710:../uvc.c      **** }
 2855              		.loc 1 1710 0
 2856 1708 00068DE8 		stmia	sp, {r9, r10}
 2857 170c E81E9FE5 		ldr	r1, .L465+8
 2858 1710 08408DE5 		str	r4, [sp, #8]
 2859 1714 0520A0E1 		mov	r2, r5
 2860 1718 0730A0E1 		mov	r3, r7
 2861 171c 0400A0E3 		mov	r0, #4
 2862 1720 FEFFFFEB 		bl	CyU3PDebugPrint
 2863              	.LVL301:
1711:../uvc.c      **** /************** CT control requests handler *************************/
 2864              		.loc 1 1711 0
 2865 1724 2CD08DE2 		add	sp, sp, #44
 2866              		@ sp needed
 2867 1728 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2868              	.LVL302:
 2869              	.L297:
 804:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2870              		.loc 1 804 0
 2871 172c 802080E0 		add	r2, r0, r0, asl #1
 2872 1730 822186E0 		add	r2, r6, r2, asl #3
 2873 1734 8031D2E5 		ldrb	r3, [r2, #384]	@ zero_extendqisi2
 2874              	.LVL303:
 805:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2875              		.loc 1 805 0
 2876 1738 81B1D2E5 		ldrb	fp, [r2, #385]	@ zero_extendqisi2
 2877              	.LVL304:
 806:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2878              		.loc 1 806 0
 2879 173c 8FA1D2E5 		ldrb	r10, [r2, #399]	@ zero_extendqisi2
 2880              	.LVL305:
 807:../uvc.c      ****     }
 2881              		.loc 1 807 0
 2882 1740 8291D2E5 		ldrb	r9, [r2, #386]	@ zero_extendqisi2
 2883              	.LVL306:
 813:../uvc.c      ****     /*
 2884              		.loc 1 813 0
 2885 1744 A82E9FE5 		ldr	r2, .L465
 2886              	.LVL307:
 2887 1748 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2888              	.LVL308:
 821:../uvc.c      **** 		 {
 2889              		.loc 1 821 0
 2890 174c 830055E3 		cmp	r5, #131
 2891 1750 D4FFFF1A 		bne	.L458
 2892              	.LVL309:
 2893              	.L300:
1191:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2894              		.loc 1 1191 0
 2895 1754 230054E3 		cmp	r4, #35
 2896 1758 C400009A 		bls	.L371
1192:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2897              		.loc 1 1192 0
 2898 175c 888088E0 		add	r8, r8, r8, asl #1
 2899              	.LVL310:
 2900 1760 886186E0 		add	r6, r6, r8, asl #3
 2901 1764 C07E9FE5 		ldr	r7, .L465+56
 2902 1768 0520D6E5 		ldrb	r2, [r6, #5]	@ zero_extendqisi2
1193:../uvc.c      **** 		 	 }
 2903              		.loc 1 1193 0
 2904 176c 0630D6E5 		ldrb	r3, [r6, #6]	@ zero_extendqisi2
1192:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2905              		.loc 1 1192 0
 2906 1770 2820C7E5 		strb	r2, [r7, #40]
1193:../uvc.c      **** 		 	 }
 2907              		.loc 1 1193 0
 2908 1774 2930C7E5 		strb	r3, [r7, #41]
 2909 1778 DBFFFFEA 		b	.L379
 2910              	.LVL311:
 2911              	.L457:
 821:../uvc.c      **** 		 {
 2912              		.loc 1 821 0
 2913 177c 810055E3 		cmp	r5, #129
 2914 1780 5500000A 		beq	.L302
 2915 1784 3900008A 		bhi	.L303
 2916 1788 010055E3 		cmp	r5, #1
 2917 178c 7C00001A 		bne	.L299
1253:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2918              		.loc 1 1253 0
 2919 1790 947E9FE5 		ldr	r7, .L465+56
 2920 1794 26208DE2 		add	r2, sp, #38
 2921 1798 2000A0E3 		mov	r0, #32
 2922              	.LVL312:
 2923 179c 281087E2 		add	r1, r7, #40
 2924 17a0 14308DE5 		str	r3, [sp, #20]
 2925 17a4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2926              	.LVL313:
1255:../uvc.c      **** 			   {
 2927              		.loc 1 1255 0
 2928 17a8 14309DE5 		ldr	r3, [sp, #20]
 2929 17ac 002050E2 		subs	r2, r0, #0
 2930 17b0 4304001A 		bne	.L381
1257:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2931              		.loc 1 1257 0
 2932 17b4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2933              		.loc 1 1260 0
 2934 17b8 2A00D7E5 		ldrb	r0, [r7, #42]	@ zero_extendqisi2
 2935              	.LVL314:
1257:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2936              		.loc 1 1257 0
 2937 17bc 18C08DE5 		str	ip, [sp, #24]
 2938              	.LVL315:
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2939              		.loc 1 1260 0
 2940 17c0 1C008DE5 		str	r0, [sp, #28]
1258:../uvc.c      **** 				  getData = glEp0Buffer[0];
 2941              		.loc 1 1258 0
 2942 17c4 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 2943              	.LVL316:
1264:../uvc.c      **** 					 {
 2944              		.loc 1 1264 0
 2945 17c8 260054E3 		cmp	r4, #38
 2946 17cc 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2947 17d0 1F0400EA 		b	.L382
 2948              	.L384:
 2949 17d4 A8270000 		.word	.L383
 2950 17d8 3C270000 		.word	.L385
 2951 17dc 28220000 		.word	.L386
 2952 17e0 54280000 		.word	.L382
 2953 17e4 C8210000 		.word	.L387
 2954 17e8 80200000 		.word	.L388
 2955 17ec F81F0000 		.word	.L389
 2956 17f0 F4230000 		.word	.L390
 2957 17f4 54280000 		.word	.L382
 2958 17f8 54280000 		.word	.L382
 2959 17fc 54280000 		.word	.L382
 2960 1800 68230000 		.word	.L391
 2961 1804 54280000 		.word	.L382
 2962 1808 54280000 		.word	.L382
 2963 180c 54280000 		.word	.L382
 2964 1810 54280000 		.word	.L382
 2965 1814 90240000 		.word	.L392
 2966 1818 54280000 		.word	.L382
 2967 181c 54280000 		.word	.L382
 2968 1820 54280000 		.word	.L382
 2969 1824 54280000 		.word	.L382
 2970 1828 54280000 		.word	.L382
 2971 182c 54280000 		.word	.L382
 2972 1830 54280000 		.word	.L382
 2973 1834 54280000 		.word	.L382
 2974 1838 90220000 		.word	.L393
 2975 183c 28220000 		.word	.L386
 2976 1840 44260000 		.word	.L394
 2977 1844 64250000 		.word	.L395
 2978 1848 54280000 		.word	.L382
 2979 184c D4260000 		.word	.L396
 2980 1850 281E0000 		.word	.L397
 2981 1854 54280000 		.word	.L382
 2982 1858 54280000 		.word	.L382
 2983 185c 54280000 		.word	.L382
 2984 1860 54280000 		.word	.L382
 2985 1864 581F0000 		.word	.L398
 2986 1868 E41E0000 		.word	.L399
 2987 186c 581E0000 		.word	.L400
 2988              	.LVL317:
 2989              	.L303:
1172:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2990              		.loc 1 1172 0
 2991 1870 230054E3 		cmp	r4, #35
 2992 1874 7100009A 		bls	.L368
1173:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2993              		.loc 1 1173 0
 2994 1878 888088E0 		add	r8, r8, r8, asl #1
 2995              	.LVL318:
 2996 187c 886186E0 		add	r6, r6, r8, asl #3
 2997 1880 A47D9FE5 		ldr	r7, .L465+56
 2998 1884 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
1174:../uvc.c      **** 		 	 }
 2999              		.loc 1 1174 0
 3000 1888 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
1173:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 3001              		.loc 1 1173 0
 3002 188c 2820C7E5 		strb	r2, [r7, #40]
1174:../uvc.c      **** 		 	 }
 3003              		.loc 1 1174 0
 3004 1890 2930C7E5 		strb	r3, [r7, #41]
 3005 1894 94FFFFEA 		b	.L379
 3006              	.LVL319:
 3007              	.L307:
1225:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 3008              		.loc 1 1225 0
 3009 1898 230054E3 		cmp	r4, #35
1229:../uvc.c      **** 		 	 }
 3010              		.loc 1 1229 0
 3011 189c 84408490 		addls	r4, r4, r4, asl #1
1226:../uvc.c      **** 		 	 }
 3012              		.loc 1 1226 0
 3013 18a0 88808880 		addhi	r8, r8, r8, asl #1
 3014              	.LVL320:
1229:../uvc.c      **** 		 	 }
 3015              		.loc 1 1229 0
 3016 18a4 84618690 		addls	r6, r6, r4, asl #3
1226:../uvc.c      **** 		 	 }
 3017              		.loc 1 1226 0
 3018 18a8 88618680 		addhi	r6, r6, r8, asl #3
 3019 18ac 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1229:../uvc.c      **** 		 	 }
 3020              		.loc 1 1229 0
 3021 18b0 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 3022 18b4 706D9FE5 		ldr	r6, .L465+56
1234:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3023              		.loc 1 1234 0
 3024 18b8 FF40A0E3 		mov	r4, #255
 3025 18bc 0610A0E1 		mov	r1, r6
1231:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3026              		.loc 1 1231 0
 3027 18c0 0100A0E3 		mov	r0, #1
 3028              	.LVL321:
 3029 18c4 2830E1E5 		strb	r3, [r1, #40]!
 3030 18c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3031              	.LVL322:
1234:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 3032              		.loc 1 1234 0
 3033 18cc 0490A0E1 		mov	r9, r4
 3034 18d0 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 3035 18d4 0470A0E1 		mov	r7, r4
 3036 18d8 8AFFFFEA 		b	.L309
 3037              	.LVL323:
 3038              	.L302:
 832:../uvc.c      **** 			 {
 3039              		.loc 1 832 0
 3040 18dc 260054E3 		cmp	r4, #38
 3041 18e0 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 3042 18e4 CE0300EA 		b	.L310
 3043              	.L312:
 3044 18e8 141D0000 		.word	.L311
 3045 18ec 281C0000 		.word	.L313
 3046 18f0 C01C0000 		.word	.L314
 3047 18f4 24280000 		.word	.L310
 3048 18f8 C81B0000 		.word	.L315
 3049 18fc 081E0000 		.word	.L316
 3050 1900 24280000 		.word	.L310
 3051 1904 E81C0000 		.word	.L317
 3052 1908 24280000 		.word	.L310
 3053 190c 841D0000 		.word	.L318
 3054 1910 24280000 		.word	.L310
 3055 1914 F81B0000 		.word	.L319
 3056 1918 24280000 		.word	.L310
 3057 191c 24280000 		.word	.L310
 3058 1920 24280000 		.word	.L310
 3059 1924 24280000 		.word	.L310
 3060 1928 AC1D0000 		.word	.L320
 3061 192c 24280000 		.word	.L310
 3062 1930 24280000 		.word	.L310
 3063 1934 24280000 		.word	.L310
 3064 1938 24280000 		.word	.L310
 3065 193c 24280000 		.word	.L310
 3066 1940 24280000 		.word	.L310
 3067 1944 24280000 		.word	.L310
 3068 1948 24280000 		.word	.L310
 3069 194c 501C0000 		.word	.L321
 3070 1950 C01C0000 		.word	.L314
 3071 1954 401D0000 		.word	.L322
 3072 1958 9C1B0000 		.word	.L323
 3073 195c 24280000 		.word	.L310
 3074 1960 24280000 		.word	.L310
 3075 1964 C41A0000 		.word	.L324
 3076 1968 24280000 		.word	.L310
 3077 196c 24280000 		.word	.L310
 3078 1970 24280000 		.word	.L310
 3079 1974 24280000 		.word	.L310
 3080 1978 201B0000 		.word	.L325
 3081 197c 701B0000 		.word	.L326
 3082 1980 4C1B0000 		.word	.L327
 3083              	.L299:
1707:../uvc.c      **** 			  break;
 3084              		.loc 1 1707 0
 3085 1984 0000A0E3 		mov	r0, #0
 3086              	.LVL324:
1708:../uvc.c      **** 		 }
 3087              		.loc 1 1708 0
 3088 1988 FF40A0E3 		mov	r4, #255
1707:../uvc.c      **** 			  break;
 3089              		.loc 1 1707 0
 3090 198c 0020A0E1 		mov	r2, r0
 3091 1990 0110A0E3 		mov	r1, #1
 3092 1994 FEFFFFEB 		bl	CyU3PUsbStall
 3093              	.LVL325:
1708:../uvc.c      **** 		 }
 3094              		.loc 1 1708 0
 3095 1998 04A0A0E1 		mov	r10, r4
 3096 199c 0490A0E1 		mov	r9, r4
 3097 19a0 0470A0E1 		mov	r7, r4
 3098 19a4 57FFFFEA 		b	.L309
 3099              	.LVL326:
 3100              	.L305:
 825:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3101              		.loc 1 825 0
 3102 19a8 7C6C9FE5 		ldr	r6, .L465+56
 826:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3103              		.loc 1 826 0
 3104 19ac 0030A0E3 		mov	r3, #0
 829:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3105              		.loc 1 829 0
 3106 19b0 FF40A0E3 		mov	r4, #255
 827:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3107              		.loc 1 827 0
 3108 19b4 281086E2 		add	r1, r6, #40
 3109 19b8 0200A0E3 		mov	r0, #2
 3110              	.LVL327:
 825:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3111              		.loc 1 825 0
 3112 19bc 2890C6E5 		strb	r9, [r6, #40]
 826:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3113              		.loc 1 826 0
 3114 19c0 2930C6E5 		strb	r3, [r6, #41]
 829:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3115              		.loc 1 829 0
 3116 19c4 0490A0E1 		mov	r9, r4
 827:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3117              		.loc 1 827 0
 3118 19c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3119              	.LVL328:
 829:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 3120              		.loc 1 829 0
 3121 19cc 0470A0E1 		mov	r7, r4
 3122 19d0 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 3123 19d4 4BFFFFEA 		b	.L309
 3124              	.LVL329:
 3125              	.L306:
1209:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 3126              		.loc 1 1209 0
 3127 19d8 230054E3 		cmp	r4, #35
1210:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 3128              		.loc 1 1210 0
 3129 19dc 88808880 		addhi	r8, r8, r8, asl #1
 3130              	.LVL330:
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3131              		.loc 1 1216 0
 3132 19e0 84408490 		addls	r4, r4, r4, asl #1
1210:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 3133              		.loc 1 1210 0
 3134 19e4 88618680 		addhi	r6, r6, r8, asl #3
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3135              		.loc 1 1216 0
 3136 19e8 84618690 		addls	r6, r6, r4, asl #3
 3137 19ec 387C9FE5 		ldr	r7, .L465+56
1210:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 3138              		.loc 1 1210 0
 3139 19f0 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1211:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 3140              		.loc 1 1211 0
 3141 19f4 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3142              		.loc 1 1216 0
 3143 19f8 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3144              		.loc 1 1217 0
 3145 19fc 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3146              		.loc 1 1218 0
 3147 1a00 0030A0E3 		mov	r3, #0
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3148              		.loc 1 1216 0
 3149 1a04 2810C7E5 		strb	r1, [r7, #40]
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3150              		.loc 1 1217 0
 3151 1a08 2920C7E5 		strb	r2, [r7, #41]
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3152              		.loc 1 1218 0
 3153 1a0c 2A30C7E5 		strb	r3, [r7, #42]
1219:../uvc.c      **** 		 	 }
 3154              		.loc 1 1219 0
 3155 1a10 2B30C7E5 		strb	r3, [r7, #43]
 3156 1a14 34FFFFEA 		b	.L379
 3157              	.LVL331:
 3158              	.L378:
1240:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 3159              		.loc 1 1240 0
 3160 1a18 0B0054E3 		cmp	r4, #11
 3161 1a1c 1F00000A 		beq	.L459
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 3162              		.loc 1 1246 0
 3163 1a20 844084E0 		add	r4, r4, r4, asl #1
 3164 1a24 846186E0 		add	r6, r6, r4, asl #3
 3165 1a28 FC7B9FE5 		ldr	r7, .L465+56
 3166 1a2c 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
1247:../uvc.c      **** 			 }
 3167              		.loc 1 1247 0
 3168 1a30 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 3169              		.loc 1 1246 0
 3170 1a34 2820C7E5 		strb	r2, [r7, #40]
1247:../uvc.c      **** 			 }
 3171              		.loc 1 1247 0
 3172 1a38 2930C7E5 		strb	r3, [r7, #41]
 3173 1a3c 2AFFFFEA 		b	.L379
 3174              	.L368:
1177:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 3175              		.loc 1 1177 0
 3176 1a40 0B0054E3 		cmp	r4, #11
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 3177              		.loc 1 1184 0
 3178 1a44 84408410 		addne	r4, r4, r4, asl #1
 3179 1a48 84618610 		addne	r6, r6, r4, asl #3
 3180 1a4c D87B9F15 		ldrne	r7, .L465+56
1178:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 3181              		.loc 1 1178 0
 3182 1a50 D47B9F05 		ldreq	r7, .L465+56
 3183 1a54 A43B9F05 		ldreq	r3, .L465+12
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 3184              		.loc 1 1184 0
 3185 1a58 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1185:../uvc.c      **** 			 }
 3186              		.loc 1 1185 0
 3187 1a5c 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1178:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 3188              		.loc 1 1178 0
 3189 1a60 28308705 		streq	r3, [r7, #40]
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 3190              		.loc 1 1184 0
 3191 1a64 2820C715 		strneb	r2, [r7, #40]
1185:../uvc.c      **** 			 }
 3192              		.loc 1 1185 0
 3193 1a68 2930C715 		strneb	r3, [r7, #41]
 3194 1a6c 1EFFFFEA 		b	.L379
 3195              	.L371:
1195:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 3196              		.loc 1 1195 0
 3197 1a70 0B0054E3 		cmp	r4, #11
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 3198              		.loc 1 1202 0
 3199 1a74 84408410 		addne	r4, r4, r4, asl #1
 3200 1a78 84618610 		addne	r6, r6, r4, asl #3
 3201 1a7c A87B9F15 		ldrne	r7, .L465+56
1196:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 3202              		.loc 1 1196 0
 3203 1a80 A47B9F05 		ldreq	r7, .L465+56
 3204 1a84 783B9F05 		ldreq	r3, .L465+16
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 3205              		.loc 1 1202 0
 3206 1a88 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1203:../uvc.c      **** 			 }
 3207              		.loc 1 1203 0
 3208 1a8c 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1196:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 3209              		.loc 1 1196 0
 3210 1a90 28308705 		streq	r3, [r7, #40]
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 3211              		.loc 1 1202 0
 3212 1a94 2820C715 		strneb	r2, [r7, #40]
1203:../uvc.c      **** 			 }
 3213              		.loc 1 1203 0
 3214 1a98 2930C715 		strneb	r3, [r7, #41]
 3215 1a9c 12FFFFEA 		b	.L379
 3216              	.L459:
1241:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 3217              		.loc 1 1241 0
 3218 1aa0 847B9FE5 		ldr	r7, .L465+56
 3219 1aa4 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
1243:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 3220              		.loc 1 1243 0
 3221 1aa8 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
1242:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 3222              		.loc 1 1242 0
 3223 1aac 0030A0E3 		mov	r3, #0
1241:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 3224              		.loc 1 1241 0
 3225 1ab0 2810C7E5 		strb	r1, [r7, #40]
1243:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 3226              		.loc 1 1243 0
 3227 1ab4 2A20C7E5 		strb	r2, [r7, #42]
1242:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 3228              		.loc 1 1242 0
 3229 1ab8 2930C7E5 		strb	r3, [r7, #41]
1244:../uvc.c      **** 			 }else{
 3230              		.loc 1 1244 0
 3231 1abc 2B30C7E5 		strb	r3, [r7, #43]
 3232 1ac0 09FFFFEA 		b	.L379
 3233              	.L324:
 3234              	.LVL332:
 947:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3235              		.loc 1 947 0 discriminator 1
 3236 1ac4 000059E3 		cmp	r9, #0
 3237 1ac8 0300000A 		beq	.L344
 3238 1acc 240B9FE5 		ldr	r0, .L465+4
 3239              	.LVL333:
 3240 1ad0 0920A0E1 		mov	r2, r9
 3241 1ad4 EC1080E2 		add	r1, r0, #236
 3242 1ad8 FEFFFFEB 		bl	memcpy
 3243              	.LVL334:
 3244              	.L344:
 950:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 3245              		.loc 1 950 0
 3246 1adc 483B9FE5 		ldr	r3, .L465+56
 957:../uvc.c      **** 			 		 {
 3247              		.loc 1 957 0
 3248 1ae0 1F21D3E5 		ldrb	r2, [r3, #287]	@ zero_extendqisi2
 950:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 3249              		.loc 1 950 0
 3250 1ae4 31A0D3E5 		ldrb	r10, [r3, #49]	@ zero_extendqisi2
 3251              	.LVL335:
 957:../uvc.c      **** 			 		 {
 3252              		.loc 1 957 0
 3253 1ae8 FF0052E3 		cmp	r2, #255
 951:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3254              		.loc 1 951 0
 3255 1aec 3240D3E5 		ldrb	r4, [r3, #50]	@ zero_extendqisi2
 3256              	.LVL336:
 957:../uvc.c      **** 			 		 {
 3257              		.loc 1 957 0
 3258 1af0 0400000A 		beq	.L333
 959:../uvc.c      **** 			 		 }
 3259              		.loc 1 959 0
 3260 1af4 1D21D3E5 		ldrb	r2, [r3, #285]	@ zero_extendqisi2
 3261 1af8 0400A0E3 		mov	r0, #4
 3262 1afc 041B9FE5 		ldr	r1, .L465+20
 3263 1b00 1E31D3E5 		ldrb	r3, [r3, #286]	@ zero_extendqisi2
 3264 1b04 FEFFFFEB 		bl	CyU3PDebugPrint
 3265              	.LVL337:
 3266              	.L333:
1165:../uvc.c      **** 
 3267              		.loc 1 1165 0
 3268 1b08 0900A0E1 		mov	r0, r9
 3269 1b0c E41A9FE5 		ldr	r1, .L465+4
 3270 1b10 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3271              	.LVL338:
1170:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 3272              		.loc 1 1170 0
 3273 1b14 FF90A0E3 		mov	r9, #255
 3274 1b18 0970A0E1 		mov	r7, r9
 3275 1b1c F9FEFFEA 		b	.L309
 3276              	.LVL339:
 3277              	.L325:
 836:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3278              		.loc 1 836 0
 3279 1b20 047B9FE5 		ldr	r7, .L465+56
 3280 1b24 8421D7E5 		ldrb	r2, [r7, #388]	@ zero_extendqisi2
 3281 1b28 000052E3 		cmp	r2, #0
 3282 1b2c 7203000A 		beq	.L331
 837:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3283              		.loc 1 837 0
 3284 1b30 09A5D6E5 		ldrb	r10, [r6, #1289]	@ zero_extendqisi2
 838:../uvc.c      **** 			 	 		 }else{
 3285              		.loc 1 838 0
 3286 1b34 0A45D6E5 		ldrb	r4, [r6, #1290]	@ zero_extendqisi2
 837:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3287              		.loc 1 837 0
 3288 1b38 FFA00AE2 		and	r10, r10, #255
 838:../uvc.c      **** 			 	 		 }else{
 3289              		.loc 1 838 0
 3290 1b3c FF4004E2 		and	r4, r4, #255
 837:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3291              		.loc 1 837 0
 3292 1b40 28A0C7E5 		strb	r10, [r7, #40]
 838:../uvc.c      **** 			 	 		 }else{
 3293              		.loc 1 838 0
 3294 1b44 2940C7E5 		strb	r4, [r7, #41]
 3295 1b48 EEFFFFEA 		b	.L333
 3296              	.L327:
 869:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 3297              		.loc 1 869 0
 3298 1b4c D87A9FE5 		ldr	r7, .L465+56
 3299 1b50 8621D7E5 		ldrb	r2, [r7, #390]	@ zero_extendqisi2
 3300 1b54 000052E3 		cmp	r2, #0
 3301 1b58 7803000A 		beq	.L336
 870:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 3302              		.loc 1 870 0
 3303 1b5c 9DA0D6E5 		ldrb	r10, [r6, #157]	@ zero_extendqisi2
 871:../uvc.c      **** 			 	 		 }else{
 3304              		.loc 1 871 0
 3305 1b60 9E40D6E5 		ldrb	r4, [r6, #158]	@ zero_extendqisi2
 870:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 3306              		.loc 1 870 0
 3307 1b64 28A0C7E5 		strb	r10, [r7, #40]
 871:../uvc.c      **** 			 	 		 }else{
 3308              		.loc 1 871 0
 3309 1b68 2940C7E5 		strb	r4, [r7, #41]
 3310 1b6c E5FFFFEA 		b	.L333
 3311              	.L326:
 851:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3312              		.loc 1 851 0
 3313 1b70 B47A9FE5 		ldr	r7, .L465+56
 3314 1b74 8521D7E5 		ldrb	r2, [r7, #389]	@ zero_extendqisi2
 3315 1b78 000052E3 		cmp	r2, #0
 3316 1b7c EC03000A 		beq	.L334
 852:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3317              		.loc 1 852 0
 3318 1b80 1DA5D6E5 		ldrb	r10, [r6, #1309]	@ zero_extendqisi2
 853:../uvc.c      **** 			 	 		 }else{
 3319              		.loc 1 853 0
 3320 1b84 1E45D6E5 		ldrb	r4, [r6, #1310]	@ zero_extendqisi2
 852:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3321              		.loc 1 852 0
 3322 1b88 FFA00AE2 		and	r10, r10, #255
 853:../uvc.c      **** 			 	 		 }else{
 3323              		.loc 1 853 0
 3324 1b8c FF4004E2 		and	r4, r4, #255
 852:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3325              		.loc 1 852 0
 3326 1b90 28A0C7E5 		strb	r10, [r7, #40]
 853:../uvc.c      **** 			 	 		 }else{
 3327              		.loc 1 853 0
 3328 1b94 2940C7E5 		strb	r4, [r7, #41]
 3329 1b98 DAFFFFEA 		b	.L333
 3330              	.L323:
 934:../uvc.c      **** 						if(sendData >= 3){
 3331              		.loc 1 934 0
 3332 1b9c 887A9FE5 		ldr	r7, .L465+56
 932:../uvc.c      **** 
 3333              		.loc 1 932 0
 3334 1ba0 2DA4D6E5 		ldrb	r10, [r6, #1069]	@ zero_extendqisi2
 3335              	.LVL340:
 934:../uvc.c      **** 						if(sendData >= 3){
 3336              		.loc 1 934 0
 3337 1ba4 A021D7E5 		ldrb	r2, [r7, #416]	@ zero_extendqisi2
 932:../uvc.c      **** 
 3338              		.loc 1 932 0
 3339 1ba8 744A9FE5 		ldr	r4, .L465+48
 934:../uvc.c      **** 						if(sendData >= 3){
 3340              		.loc 1 934 0
 3341 1bac 010052E3 		cmp	r2, #1
 3342 1bb0 7704000A 		beq	.L460
 3343              	.LVL341:
 3344              	.L453:
1034:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3345              		.loc 1 1034 0
 3346 1bb4 0030A0E3 		mov	r3, #0
1033:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3347              		.loc 1 1033 0
 3348 1bb8 28A0C7E5 		strb	r10, [r7, #40]
1034:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3349              		.loc 1 1034 0
 3350 1bbc 2930C7E5 		strb	r3, [r7, #41]
 3351              	.LVL342:
1036:../uvc.c      **** 				 case WBTLevCtlID11:
 3352              		.loc 1 1036 0
 3353 1bc0 FF40A0E3 		mov	r4, #255
 3354 1bc4 CFFFFFEA 		b	.L333
 3355              	.LVL343:
 3356              	.L315:
1124:../uvc.c      **** 
 3357              		.loc 1 1124 0
 3358 1bc8 5C7A9FE5 		ldr	r7, .L465+56
 3359 1bcc 6431D7E5 		ldrb	r3, [r7, #356]	@ zero_extendqisi2
 3360 1bd0 000053E3 		cmp	r3, #0
 3361 1bd4 0504000A 		beq	.L363
1126:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3362              		.loc 1 1126 0
 3363 1bd8 783097E5 		ldr	r3, [r7, #120]
1132:../uvc.c      **** 		 	 		 }else{
 3364              		.loc 1 1132 0
 3365 1bdc EE41D6E5 		ldrb	r4, [r6, #494]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3366              		.loc 1 1126 0
 3367 1be0 000053E3 		cmp	r3, #0
 3368 1be4 02A0A013 		movne	r10, #2
 3369 1be8 01A0A003 		moveq	r10, #1
 3370 1bec 28A0C7E5 		strb	r10, [r7, #40]
1132:../uvc.c      **** 		 	 		 }else{
 3371              		.loc 1 1132 0
 3372 1bf0 2940C7E5 		strb	r4, [r7, #41]
 3373 1bf4 C3FFFFEA 		b	.L333
 3374              	.L319:
1042:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 3375              		.loc 1 1042 0
 3376 1bf8 2C7A9FE5 		ldr	r7, .L465+56
 3377 1bfc 6B21D7E5 		ldrb	r2, [r7, #363]	@ zero_extendqisi2
 3378 1c00 000052E3 		cmp	r2, #0
 3379 1c04 3E04000A 		beq	.L353
1043:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3380              		.loc 1 1043 0
 3381 1c08 60A5D6E5 		ldrb	r10, [r6, #1376]	@ zero_extendqisi2
1044:../uvc.c      **** 		 	 		 }else{
 3382              		.loc 1 1044 0
 3383 1c0c 6245D6E5 		ldrb	r4, [r6, #1378]	@ zero_extendqisi2
1043:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3384              		.loc 1 1043 0
 3385 1c10 28A0C7E5 		strb	r10, [r7, #40]
1044:../uvc.c      **** 		 	 		 }else{
 3386              		.loc 1 1044 0
 3387 1c14 2A40C7E5 		strb	r4, [r7, #42]
 3388              	.LVL344:
 3389              	.L354:
1054:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3390              		.loc 1 1054 0
 3391 1c18 0030A0E3 		mov	r3, #0
 3392 1c1c 2930C7E5 		strb	r3, [r7, #41]
1055:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3393              		.loc 1 1055 0
 3394 1c20 2B30C7E5 		strb	r3, [r7, #43]
 3395              	.LVL345:
1058:../uvc.c      **** 				 case BLCCtlID0:
 3396              		.loc 1 1058 0
 3397 1c24 B7FFFFEA 		b	.L333
 3398              	.LVL346:
 3399              	.L313:
1007:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3400              		.loc 1 1007 0
 3401 1c28 FC799FE5 		ldr	r7, .L465+56
 3402 1c2c 6121D7E5 		ldrb	r2, [r7, #353]	@ zero_extendqisi2
 3403 1c30 000052E3 		cmp	r2, #0
 3404 1c34 D903000A 		beq	.L347
1008:../uvc.c      **** 		 	 		 }else{
 3405              		.loc 1 1008 0
 3406 1c38 A501D6E5 		ldrb	r0, [r6, #421]	@ zero_extendqisi2
 3407              	.LVL347:
 3408              	.L348:
1015:../uvc.c      **** 						  Data0 = ~Data0;
 3409              		.loc 1 1015 0
 3410 1c3c 800010E3 		tst	r0, #128
1016:../uvc.c      **** 					  }else{
 3411              		.loc 1 1016 0
 3412 1c40 0000E011 		mvnne	r0, r0
 3413              	.LVL348:
1018:../uvc.c      **** 					  }
 3414              		.loc 1 1018 0
 3415 1c44 80004002 		subeq	r0, r0, #128
 3416 1c48 FFA000E2 		and	r10, r0, #255
 3417              	.LVL349:
 3418 1c4c D8FFFFEA 		b	.L453
 3419              	.LVL350:
 3420              	.L321:
 969:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3421              		.loc 1 969 0
 3422 1c50 D4799FE5 		ldr	r7, .L465+56
 963:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3423              		.loc 1 963 0
 3424 1c54 4C15D6E5 		ldrb	r1, [r6, #1356]	@ zero_extendqisi2
 969:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3425              		.loc 1 969 0
 3426 1c58 7901D7E5 		ldrb	r0, [r7, #377]	@ zero_extendqisi2
 3427              	.LVL351:
 964:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3428              		.loc 1 964 0
 3429 1c5c 4D25D6E5 		ldrb	r2, [r6, #1357]	@ zero_extendqisi2
 965:../uvc.c      **** 
 3430              		.loc 1 965 0
 3431 1c60 5B35D6E5 		ldrb	r3, [r6, #1371]	@ zero_extendqisi2
 969:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3432              		.loc 1 969 0
 3433 1c64 000050E3 		cmp	r0, #0
 964:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3434              		.loc 1 964 0
 3435 1c68 FF8002E2 		and	r8, r2, #255
 3436              	.LVL352:
 963:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3437              		.loc 1 963 0
 3438 1c6c FF0001E2 		and	r0, r1, #255
 3439              	.LVL353:
 965:../uvc.c      **** 
 3440              		.loc 1 965 0
 3441 1c70 FF4003E2 		and	r4, r3, #255
 3442              	.LVL354:
 963:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3443              		.loc 1 963 0
 3444 1c74 A8699FE5 		ldr	r6, .L465+48
 969:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3445              		.loc 1 969 0
 3446 1c78 1204000A 		beq	.L345
 970:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3447              		.loc 1 970 0
 3448 1c7c 59A5D6E5 		ldrb	r10, [r6, #1369]	@ zero_extendqisi2
 971:../uvc.c      **** 		 	 		 }else{
 3449              		.loc 1 971 0
 3450 1c80 5A45D6E5 		ldrb	r4, [r6, #1370]	@ zero_extendqisi2
 3451              	.LVL355:
 970:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3452              		.loc 1 970 0
 3453 1c84 FFA00AE2 		and	r10, r10, #255
 971:../uvc.c      **** 		 	 		 }else{
 3454              		.loc 1 971 0
 3455 1c88 FF4004E2 		and	r4, r4, #255
 970:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3456              		.loc 1 970 0
 3457 1c8c 28A0C7E5 		strb	r10, [r7, #40]
 971:../uvc.c      **** 		 	 		 }else{
 3458              		.loc 1 971 0
 3459 1c90 2A40C7E5 		strb	r4, [r7, #42]
 3460              	.LVL356:
 3461              	.L346:
 985:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3462              		.loc 1 985 0
 3463 1c94 00C0A0E3 		mov	ip, #0
 990:../uvc.c      **** 					 break;
 3464              		.loc 1 990 0
 3465 1c98 00408DE5 		str	r4, [sp]
 3466 1c9c 04C08DE5 		str	ip, [sp, #4]
 3467 1ca0 0A20A0E1 		mov	r2, r10
 3468 1ca4 0C30A0E1 		mov	r3, ip
 3469 1ca8 5C199FE5 		ldr	r1, .L465+24
 985:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3470              		.loc 1 985 0
 3471 1cac 29C0C7E5 		strb	ip, [r7, #41]
 987:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3472              		.loc 1 987 0
 3473 1cb0 2BC0C7E5 		strb	ip, [r7, #43]
 3474              	.LVL357:
 990:../uvc.c      **** 					 break;
 3475              		.loc 1 990 0
 3476 1cb4 0400A0E3 		mov	r0, #4
 3477 1cb8 FEFFFFEB 		bl	CyU3PDebugPrint
 3478              	.LVL358:
 991:../uvc.c      **** 
 3479              		.loc 1 991 0
 3480 1cbc 91FFFFEA 		b	.L333
 3481              	.LVL359:
 3482              	.L314:
1094:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 3483              		.loc 1 1094 0
 3484 1cc0 64799FE5 		ldr	r7, .L465+56
 3485 1cc4 048087E0 		add	r8, r7, r4
 3486              	.LVL360:
 3487 1cc8 6021D8E5 		ldrb	r2, [r8, #352]	@ zero_extendqisi2
 3488 1ccc 000052E3 		cmp	r2, #0
 3489 1cd0 E003000A 		beq	.L359
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3490              		.loc 1 1095 0
 3491 1cd4 BDA1D6E5 		ldrb	r10, [r6, #445]	@ zero_extendqisi2
1096:../uvc.c      **** 		 	 		 }else{
 3492              		.loc 1 1096 0
 3493 1cd8 BE41D6E5 		ldrb	r4, [r6, #446]	@ zero_extendqisi2
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3494              		.loc 1 1095 0
 3495 1cdc 28A0C7E5 		strb	r10, [r7, #40]
1096:../uvc.c      **** 		 	 		 }else{
 3496              		.loc 1 1096 0
 3497 1ce0 2940C7E5 		strb	r4, [r7, #41]
 3498 1ce4 87FFFFEA 		b	.L333
 3499              	.LVL361:
 3500              	.L317:
1077:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3501              		.loc 1 1077 0
 3502 1ce8 3C799FE5 		ldr	r7, .L465+56
 3503 1cec 6731D7E5 		ldrb	r3, [r7, #359]	@ zero_extendqisi2
 3504 1cf0 000053E3 		cmp	r3, #0
 3505 1cf4 1204000A 		beq	.L357
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3506              		.loc 1 1078 0
 3507 1cf8 85A5D6E5 		ldrb	r10, [r6, #1413]	@ zero_extendqisi2
1079:../uvc.c      **** 		 	 		 }else{
 3508              		.loc 1 1079 0
 3509 1cfc 8645D6E5 		ldrb	r4, [r6, #1414]	@ zero_extendqisi2
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3510              		.loc 1 1078 0
 3511 1d00 FFA00AE2 		and	r10, r10, #255
1079:../uvc.c      **** 		 	 		 }else{
 3512              		.loc 1 1079 0
 3513 1d04 FF4004E2 		and	r4, r4, #255
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3514              		.loc 1 1078 0
 3515 1d08 28A0C7E5 		strb	r10, [r7, #40]
1079:../uvc.c      **** 		 	 		 }else{
 3516              		.loc 1 1079 0
 3517 1d0c 2940C7E5 		strb	r4, [r7, #41]
 3518 1d10 7CFFFFEA 		b	.L333
 3519              	.L311:
1060:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3520              		.loc 1 1060 0
 3521 1d14 10799FE5 		ldr	r7, .L465+56
 3522 1d18 6021D7E5 		ldrb	r2, [r7, #352]	@ zero_extendqisi2
 3523 1d1c 000052E3 		cmp	r2, #0
 3524 1d20 9003000A 		beq	.L355
1061:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3525              		.loc 1 1061 0
 3526 1d24 71A5D6E5 		ldrb	r10, [r6, #1393]	@ zero_extendqisi2
1062:../uvc.c      **** 		 	 		 }else{
 3527              		.loc 1 1062 0
 3528 1d28 7245D6E5 		ldrb	r4, [r6, #1394]	@ zero_extendqisi2
1061:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3529              		.loc 1 1061 0
 3530 1d2c FFA00AE2 		and	r10, r10, #255
1062:../uvc.c      **** 		 	 		 }else{
 3531              		.loc 1 1062 0
 3532 1d30 FF4004E2 		and	r4, r4, #255
1061:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3533              		.loc 1 1061 0
 3534 1d34 28A0C7E5 		strb	r10, [r7, #40]
1062:../uvc.c      **** 		 	 		 }else{
 3535              		.loc 1 1062 0
 3536 1d38 2940C7E5 		strb	r4, [r7, #41]
 3537 1d3c 71FFFFEA 		b	.L333
 3538              	.L322:
 919:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3539              		.loc 1 919 0
 3540 1d40 E4789FE5 		ldr	r7, .L465+56
 912:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3541              		.loc 1 912 0
 3542 1d44 3835D6E5 		ldrb	r3, [r6, #1336]	@ zero_extendqisi2
 919:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3543              		.loc 1 919 0
 3544 1d48 7B11D7E5 		ldrb	r1, [r7, #379]	@ zero_extendqisi2
 913:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3545              		.loc 1 913 0
 3546 1d4c 3925D6E5 		ldrb	r2, [r6, #1337]	@ zero_extendqisi2
 914:../uvc.c      **** 
 3547              		.loc 1 914 0
 3548 1d50 4735D6E5 		ldrb	r3, [r6, #1351]	@ zero_extendqisi2
 919:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3549              		.loc 1 919 0
 3550 1d54 000051E3 		cmp	r1, #0
 913:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3551              		.loc 1 913 0
 3552 1d58 FF0002E2 		and	r0, r2, #255
 3553              	.LVL362:
 914:../uvc.c      **** 
 3554              		.loc 1 914 0
 3555 1d5c FF1003E2 		and	r1, r3, #255
 3556              	.LVL363:
 912:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3557              		.loc 1 912 0
 3558 1d60 BC489FE5 		ldr	r4, .L465+48
 919:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3559              		.loc 1 919 0
 3560 1d64 B003000A 		beq	.L340
 920:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3561              		.loc 1 920 0
 3562 1d68 45A5D4E5 		ldrb	r10, [r4, #1349]	@ zero_extendqisi2
 921:../uvc.c      **** 		 	 		 }else{
 3563              		.loc 1 921 0
 3564 1d6c 4645D4E5 		ldrb	r4, [r4, #1350]	@ zero_extendqisi2
 920:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3565              		.loc 1 920 0
 3566 1d70 FFA00AE2 		and	r10, r10, #255
 921:../uvc.c      **** 		 	 		 }else{
 3567              		.loc 1 921 0
 3568 1d74 FF4004E2 		and	r4, r4, #255
 920:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3569              		.loc 1 920 0
 3570 1d78 28A0C7E5 		strb	r10, [r7, #40]
 921:../uvc.c      **** 		 	 		 }else{
 3571              		.loc 1 921 0
 3572 1d7c 2940C7E5 		strb	r4, [r7, #41]
 3573 1d80 60FFFFEA 		b	.L333
 3574              	.LVL364:
 3575              	.L318:
1107:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3576              		.loc 1 1107 0
 3577 1d84 A0789FE5 		ldr	r7, .L465+56
 3578 1d88 6921D7E5 		ldrb	r2, [r7, #361]	@ zero_extendqisi2
 3579 1d8c 000052E3 		cmp	r2, #0
 3580 1d90 8903000A 		beq	.L361
1109:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3581              		.loc 1 1109 0
 3582 1d94 65A2D6E5 		ldrb	r10, [r6, #613]	@ zero_extendqisi2
1110:../uvc.c      **** 		 	 		 }else{
 3583              		.loc 1 1110 0
 3584 1d98 6642D6E5 		ldrb	r4, [r6, #614]	@ zero_extendqisi2
1109:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3585              		.loc 1 1109 0
 3586 1d9c 03A00AE2 		and	r10, r10, #3
 3587 1da0 28A0C7E5 		strb	r10, [r7, #40]
1110:../uvc.c      **** 		 	 		 }else{
 3588              		.loc 1 1110 0
 3589 1da4 2940C7E5 		strb	r4, [r7, #41]
 3590 1da8 56FFFFEA 		b	.L333
 3591              	.L320:
 894:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3592              		.loc 1 894 0
 3593 1dac 78489FE5 		ldr	r4, .L465+56
 887:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3594              		.loc 1 887 0
 3595 1db0 2425D6E5 		ldrb	r2, [r6, #1316]	@ zero_extendqisi2
 894:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3596              		.loc 1 894 0
 3597 1db4 7011D4E5 		ldrb	r1, [r4, #368]	@ zero_extendqisi2
 888:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3598              		.loc 1 888 0
 3599 1db8 2535D6E5 		ldrb	r3, [r6, #1317]	@ zero_extendqisi2
 889:../uvc.c      **** 
 3600              		.loc 1 889 0
 3601 1dbc 3335D6E5 		ldrb	r3, [r6, #1331]	@ zero_extendqisi2
 894:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3602              		.loc 1 894 0
 3603 1dc0 000051E3 		cmp	r1, #0
 887:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3604              		.loc 1 887 0
 3605 1dc4 FF0002E2 		and	r0, r2, #255
 3606              	.LVL365:
 889:../uvc.c      **** 
 3607              		.loc 1 889 0
 3608 1dc8 FF1003E2 		and	r1, r3, #255
 3609              	.LVL366:
 887:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3610              		.loc 1 887 0
 3611 1dcc 50689FE5 		ldr	r6, .L465+48
 894:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3612              		.loc 1 894 0
 3613 1dd0 AC03000A 		beq	.L338
 895:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3614              		.loc 1 895 0
 3615 1dd4 31A5D6E5 		ldrb	r10, [r6, #1329]	@ zero_extendqisi2
 896:../uvc.c      **** 		 	 		 }else{
 3616              		.loc 1 896 0
 3617 1dd8 3235D6E5 		ldrb	r3, [r6, #1330]	@ zero_extendqisi2
 895:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3618              		.loc 1 895 0
 3619 1ddc FFA00AE2 		and	r10, r10, #255
 3620 1de0 28A0C4E5 		strb	r10, [r4, #40]
 896:../uvc.c      **** 		 	 		 }else{
 3621              		.loc 1 896 0
 3622 1de4 2930C4E5 		strb	r3, [r4, #41]
 3623              	.LVL367:
 3624              	.L339:
 909:../uvc.c      **** 			 		 break;
 3625              		.loc 1 909 0
 3626 1de8 00708DE5 		str	r7, [sp]
 3627 1dec 0A20A0E1 		mov	r2, r10
 3628 1df0 0A30A0E1 		mov	r3, r10
 3629 1df4 14189FE5 		ldr	r1, .L465+28
 3630 1df8 0400A0E3 		mov	r0, #4
 3631 1dfc 0740A0E1 		mov	r4, r7
 3632 1e00 FEFFFFEB 		bl	CyU3PDebugPrint
 3633              	.LVL368:
 910:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 3634              		.loc 1 910 0
 3635 1e04 3FFFFFEA 		b	.L333
 3636              	.LVL369:
 3637              	.L316:
1025:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3638              		.loc 1 1025 0
 3639 1e08 1C789FE5 		ldr	r7, .L465+56
 3640 1e0c 6521D7E5 		ldrb	r2, [r7, #357]	@ zero_extendqisi2
 3641 1e10 000052E3 		cmp	r2, #0
 3642 1e14 D703000A 		beq	.L351
1026:../uvc.c      **** 		 	 		 }else{
 3643              		.loc 1 1026 0
 3644 1e18 0502D6E5 		ldrb	r0, [r6, #517]	@ zero_extendqisi2
 3645              	.LVL370:
 3646              	.L352:
1033:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3647              		.loc 1 1033 0
 3648 1e1c 80A040E2 		sub	r10, r0, #128
 3649 1e20 FFA00AE2 		and	r10, r10, #255
 3650 1e24 62FFFFEA 		b	.L453
 3651              	.LVL371:
 3652              	.L397:
1416:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 3653              		.loc 1 1416 0 discriminator 1
 3654 1e28 000059E3 		cmp	r9, #0
 3655 1e2c 0300000A 		beq	.L413
 3656 1e30 DC079FE5 		ldr	r0, .L465+32
 3657 1e34 0920A0E1 		mov	r2, r9
 3658              	.LVL372:
 3659 1e38 EC1040E2 		sub	r1, r0, #236
 3660 1e3c FEFFFFEB 		bl	memcpy
 3661              	.LVL373:
 3662              	.L413:
1420:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3663              		.loc 1 1420 0
 3664 1e40 FF40A0E3 		mov	r4, #255
1419:../uvc.c      **** 							 break;
 3665              		.loc 1 1419 0
 3666 1e44 FEFFFFEB 		bl	I2CCmdHandler
 3667              	.LVL374:
1420:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3668              		.loc 1 1420 0
 3669 1e48 04A0A0E1 		mov	r10, r4
 3670 1e4c 18709DE5 		ldr	r7, [sp, #24]
 3671 1e50 1C909DE5 		ldr	r9, [sp, #28]
 3672 1e54 2BFEFFEA 		b	.L309
 3673              	.LVL375:
 3674              	.L400:
1478:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3675              		.loc 1 1478 0
 3676 1e58 18C09DE5 		ldr	ip, [sp, #24]
1477:../uvc.c      **** 							 if(Data0 == 1){
 3677              		.loc 1 1477 0
 3678 1e5c 8870A0E1 		mov	r7, r8, asl #1
 3679 1e60 082087E0 		add	r2, r7, r8
 3680              	.LVL376:
 3681 1e64 822186E0 		add	r2, r6, r2, asl #3
 3682 1e68 0DC0C2E5 		strb	ip, [r2, #13]
 3683 1e6c B0279FE5 		ldr	r2, .L465+48
1483:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3684              		.loc 1 1483 0
 3685 1e70 C4479FE5 		ldr	r4, .L465+72
1479:../uvc.c      **** 							 }else{
 3686              		.loc 1 1479 0
 3687 1e74 7195D2E5 		ldrb	r9, [r2, #1393]	@ zero_extendqisi2
1478:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3688              		.loc 1 1478 0
 3689 1e78 01005CE3 		cmp	ip, #1
1483:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3690              		.loc 1 1483 0
 3691 1e7c 1C0094E5 		ldr	r0, [r4, #28]
 3692 1e80 0010E0E3 		mvn	r1, #0
1479:../uvc.c      **** 							 }else{
 3693              		.loc 1 1479 0
 3694 1e84 80908903 		orreq	r9, r9, #128
 3695              	.LVL377:
1481:../uvc.c      **** 							 }
 3696              		.loc 1 1481 0
 3697 1e88 7F900912 		andne	r9, r9, #127
 3698              	.LVL378:
1483:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3699              		.loc 1 1483 0
 3700 1e8c 14308DE5 		str	r3, [sp, #20]
 3701 1e90 FEFFFFEB 		bl	_txe_mutex_get
 3702              	.LVL379:
1484:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3703              		.loc 1 1484 0
 3704 1e94 14309DE5 		ldr	r3, [sp, #20]
 3705 1e98 0010A0E3 		mov	r1, #0
 3706 1e9c 0320A0E1 		mov	r2, r3
 3707 1ea0 00908DE5 		str	r9, [sp]
 3708 1ea4 0A30A0E1 		mov	r3, r10
 3709 1ea8 0400A0E1 		mov	r0, r4
 3710 1eac 04108DE5 		str	r1, [sp, #4]
 3711 1eb0 2610A0E3 		mov	r1, #38
 3712 1eb4 FEFFFFEB 		bl	cmdSet
 3713              	.LVL380:
1487:../uvc.c      **** 							 break;
 3714              		.loc 1 1487 0
 3715 1eb8 087087E0 		add	r7, r7, r8
1485:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3716              		.loc 1 1485 0
 3717 1ebc 1C0094E5 		ldr	r0, [r4, #28]
 3718 1ec0 FEFFFFEB 		bl	_txe_mutex_put
 3719              	.LVL381:
1487:../uvc.c      **** 							 break;
 3720              		.loc 1 1487 0
 3721 1ec4 876186E0 		add	r6, r6, r7, asl #3
 3722 1ec8 0130A0E3 		mov	r3, #1
1488:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3723              		.loc 1 1488 0
 3724 1ecc FF40A0E3 		mov	r4, #255
 3725 1ed0 18709DE5 		ldr	r7, [sp, #24]
 3726 1ed4 1C909DE5 		ldr	r9, [sp, #28]
 3727              	.LVL382:
1487:../uvc.c      **** 							 break;
 3728              		.loc 1 1487 0
 3729 1ed8 1030C6E5 		strb	r3, [r6, #16]
1488:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3730              		.loc 1 1488 0
 3731 1edc 04A0A0E1 		mov	r10, r4
 3732 1ee0 08FEFFEA 		b	.L309
 3733              	.LVL383:
 3734              	.L399:
1467:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3735              		.loc 1 1467 0
 3736 1ee4 50479FE5 		ldr	r4, .L465+72
1462:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3737              		.loc 1 1462 0
 3738 1ee8 1085D6E5 		ldrb	r8, [r6, #1296]	@ zero_extendqisi2
 3739              	.LVL384:
1467:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3740              		.loc 1 1467 0
 3741 1eec 1C0094E5 		ldr	r0, [r4, #28]
1463:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3742              		.loc 1 1463 0
 3743 1ef0 1135D6E5 		ldrb	r3, [r6, #1297]	@ zero_extendqisi2
1467:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3744              		.loc 1 1467 0
 3745 1ef4 0010E0E3 		mvn	r1, #0
1464:../uvc.c      **** 
 3746              		.loc 1 1464 0
 3747 1ef8 1F75D6E5 		ldrb	r7, [r6, #1311]	@ zero_extendqisi2
1467:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3748              		.loc 1 1467 0
 3749 1efc FEFFFFEB 		bl	_txe_mutex_get
 3750              	.LVL385:
1468:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3751              		.loc 1 1468 0
 3752 1f00 18C09DE5 		ldr	ip, [sp, #24]
1464:../uvc.c      **** 
 3753              		.loc 1 1464 0
 3754 1f04 FF7007E2 		and	r7, r7, #255
1468:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3755              		.loc 1 1468 0
 3756 1f08 0010A0E3 		mov	r1, #0
1462:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3757              		.loc 1 1462 0
 3758 1f0c FF8008E2 		and	r8, r8, #255
 3759              	.LVL386:
1468:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3760              		.loc 1 1468 0
 3761 1f10 0730A0E1 		mov	r3, r7
 3762 1f14 00C08DE5 		str	ip, [sp]
 3763 1f18 0820A0E1 		mov	r2, r8
 3764 1f1c 0400A0E1 		mov	r0, r4
 3765 1f20 04108DE5 		str	r1, [sp, #4]
 3766 1f24 2510A0E3 		mov	r1, #37
 3767 1f28 FEFFFFEB 		bl	cmdSet
 3768              	.LVL387:
1469:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3769              		.loc 1 1469 0
 3770 1f2c 1C0094E5 		ldr	r0, [r4, #28]
 3771 1f30 FEFFFFEB 		bl	_txe_mutex_put
 3772              	.LVL388:
1470:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3773              		.loc 1 1470 0
 3774 1f34 18C09DE5 		ldr	ip, [sp, #24]
1474:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3775              		.loc 1 1474 0
 3776 1f38 FF40A0E3 		mov	r4, #255
1471:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3777              		.loc 1 1471 0
 3778 1f3c 0130A0E3 		mov	r3, #1
1470:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3779              		.loc 1 1470 0
 3780 1f40 1DC5C6E5 		strb	ip, [r6, #1309]
 3781 1f44 1C909DE5 		ldr	r9, [sp, #28]
 3782 1f48 0C70A0E1 		mov	r7, ip
 3783              	.LVL389:
1471:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3784              		.loc 1 1471 0
 3785 1f4c 2135C6E5 		strb	r3, [r6, #1313]
1474:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3786              		.loc 1 1474 0
 3787 1f50 04A0A0E1 		mov	r10, r4
 3788 1f54 EBFDFFEA 		b	.L309
 3789              	.LVL390:
 3790              	.L398:
1449:../uvc.c      **** 						     /* end test */
 3791              		.loc 1 1449 0
 3792 1f58 DC769FE5 		ldr	r7, .L465+72
1422:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3793              		.loc 1 1422 0
 3794 1f5c FC84D6E5 		ldrb	r8, [r6, #1276]	@ zero_extendqisi2
 3795              	.LVL391:
1449:../uvc.c      **** 						     /* end test */
 3796              		.loc 1 1449 0
 3797 1f60 1C0097E5 		ldr	r0, [r7, #28]
1423:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3798              		.loc 1 1423 0
 3799 1f64 FD94D6E5 		ldrb	r9, [r6, #1277]	@ zero_extendqisi2
1449:../uvc.c      **** 						     /* end test */
 3800              		.loc 1 1449 0
 3801 1f68 0010E0E3 		mvn	r1, #0
1424:../uvc.c      **** 
 3802              		.loc 1 1424 0
 3803 1f6c 0B45D6E5 		ldrb	r4, [r6, #1291]	@ zero_extendqisi2
 3804              	.LVL392:
1449:../uvc.c      **** 						     /* end test */
 3805              		.loc 1 1449 0
 3806 1f70 14C08DE5 		str	ip, [sp, #20]
 3807 1f74 FEFFFFEB 		bl	_txe_mutex_get
 3808              	.LVL393:
1451:../uvc.c      **** 							 dataIdx++;
 3809              		.loc 1 1451 0
 3810 1f78 18009DE5 		ldr	r0, [sp, #24]
1424:../uvc.c      **** 
 3811              		.loc 1 1424 0
 3812 1f7c FF4004E2 		and	r4, r4, #255
1422:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3813              		.loc 1 1422 0
 3814 1f80 FF8008E2 		and	r8, r8, #255
 3815              	.LVL394:
1451:../uvc.c      **** 							 dataIdx++;
 3816              		.loc 1 1451 0
 3817 1f84 0010A0E3 		mov	r1, #0
 3818 1f88 0820A0E1 		mov	r2, r8
 3819 1f8c 0430A0E1 		mov	r3, r4
 3820 1f90 00008DE5 		str	r0, [sp]
 3821 1f94 04108DE5 		str	r1, [sp, #4]
 3822 1f98 0700A0E1 		mov	r0, r7
 3823 1f9c 2410A0E3 		mov	r1, #36
 3824 1fa0 FEFFFFEB 		bl	cmdSet
 3825              	.LVL395:
1453:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3826              		.loc 1 1453 0
 3827 1fa4 14C09DE5 		ldr	ip, [sp, #20]
1423:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3828              		.loc 1 1423 0
 3829 1fa8 FF9009E2 		and	r9, r9, #255
 3830              	.LVL396:
1453:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3831              		.loc 1 1453 0
 3832 1fac 0180A0E3 		mov	r8, #1
 3833              	.LVL397:
 3834 1fb0 0920A0E1 		mov	r2, r9
 3835 1fb4 0430A0E1 		mov	r3, r4
 3836 1fb8 00C08DE5 		str	ip, [sp]
 3837 1fbc 0700A0E1 		mov	r0, r7
 3838 1fc0 2410A0E3 		mov	r1, #36
 3839 1fc4 04808DE5 		str	r8, [sp, #4]
 3840 1fc8 FEFFFFEB 		bl	cmdSet
 3841              	.LVL398:
1454:../uvc.c      **** 							 getData1 = Data1;
 3842              		.loc 1 1454 0
 3843 1fcc 1C0097E5 		ldr	r0, [r7, #28]
 3844 1fd0 FEFFFFEB 		bl	_txe_mutex_put
 3845              	.LVL399:
 3846 1fd4 18709DE5 		ldr	r7, [sp, #24]
1460:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3847              		.loc 1 1460 0
 3848 1fd8 FF40A0E3 		mov	r4, #255
 3849              	.LVL400:
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3850              		.loc 1 1457 0
 3851 1fdc 0975C6E5 		strb	r7, [r6, #1289]
 3852 1fe0 14C09DE5 		ldr	ip, [sp, #20]
1460:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3853              		.loc 1 1460 0
 3854 1fe4 04A0A0E1 		mov	r10, r4
1458:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3855              		.loc 1 1458 0
 3856 1fe8 0AC5C6E5 		strb	ip, [r6, #1290]
 3857 1fec 0C90A0E1 		mov	r9, ip
 3858              	.LVL401:
1459:../uvc.c      **** 							 break;
 3859              		.loc 1 1459 0
 3860 1ff0 0D85C6E5 		strb	r8, [r6, #1293]
1460:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3861              		.loc 1 1460 0
 3862 1ff4 C3FDFFEA 		b	.L309
 3863              	.LVL402:
 3864              	.L389:
1551:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3865              		.loc 1 1551 0
 3866 1ff8 3C769FE5 		ldr	r7, .L465+72
 3867 1ffc 0010E0E3 		mvn	r1, #0
 3868 2000 1C0097E5 		ldr	r0, [r7, #28]
 3869 2004 14308DE5 		str	r3, [sp, #20]
 3870 2008 FEFFFFEB 		bl	_txe_mutex_get
 3871              	.LVL403:
1552:../uvc.c      **** 							 dataIdx++;
 3872              		.loc 1 1552 0
 3873 200c 18C09DE5 		ldr	ip, [sp, #24]
 3874 2010 14309DE5 		ldr	r3, [sp, #20]
 3875 2014 0010A0E3 		mov	r1, #0
 3876 2018 0320A0E1 		mov	r2, r3
 3877 201c 00C08DE5 		str	ip, [sp]
 3878 2020 0A30A0E1 		mov	r3, r10
 3879 2024 0700A0E1 		mov	r0, r7
 3880 2028 04108DE5 		str	r1, [sp, #4]
 3881 202c 0610A0E3 		mov	r1, #6
 3882 2030 FEFFFFEB 		bl	cmdSet
 3883              	.LVL404:
1554:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3884              		.loc 1 1554 0
 3885 2034 18C09DE5 		ldr	ip, [sp, #24]
 3886 2038 0180A0E3 		mov	r8, #1
 3887              	.LVL405:
 3888 203c 00C08DE5 		str	ip, [sp]
 3889 2040 0A30A0E1 		mov	r3, r10
 3890 2044 0B20A0E1 		mov	r2, fp
 3891 2048 0700A0E1 		mov	r0, r7
 3892 204c 0610A0E3 		mov	r1, #6
 3893 2050 04808DE5 		str	r8, [sp, #4]
 3894 2054 FEFFFFEB 		bl	cmdSet
 3895              	.LVL406:
1555:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3896              		.loc 1 1555 0
 3897 2058 1C0097E5 		ldr	r0, [r7, #28]
 3898 205c FEFFFFEB 		bl	_txe_mutex_put
 3899              	.LVL407:
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3900              		.loc 1 1556 0
 3901 2060 18C09DE5 		ldr	ip, [sp, #24]
1558:../uvc.c      **** 
 3902              		.loc 1 1558 0
 3903 2064 FF40A0E3 		mov	r4, #255
 3904              	.LVL408:
 3905 2068 1C909DE5 		ldr	r9, [sp, #28]
1557:../uvc.c      **** 							 break;
 3906              		.loc 1 1557 0
 3907 206c 2082C6E5 		strb	r8, [r6, #544]
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3908              		.loc 1 1556 0
 3909 2070 1DC2C6E5 		strb	ip, [r6, #541]
 3910 2074 0C70A0E1 		mov	r7, ip
1558:../uvc.c      **** 
 3911              		.loc 1 1558 0
 3912 2078 04A0A0E1 		mov	r10, r4
 3913 207c A1FDFFEA 		b	.L309
 3914              	.LVL409:
 3915              	.L388:
1531:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3916              		.loc 1 1531 0
 3917 2080 B4459FE5 		ldr	r4, .L465+72
 3918 2084 0010E0E3 		mvn	r1, #0
 3919 2088 1C0094E5 		ldr	r0, [r4, #28]
 3920 208c 14308DE5 		str	r3, [sp, #20]
 3921 2090 FEFFFFEB 		bl	_txe_mutex_get
 3922              	.LVL410:
1532:../uvc.c      **** 							 dataIdx++;
 3923              		.loc 1 1532 0
 3924 2094 18C09DE5 		ldr	ip, [sp, #24]
 3925 2098 14309DE5 		ldr	r3, [sp, #20]
 3926 209c 80004CE2 		sub	r0, ip, #128
 3927 20a0 FF0000E2 		and	r0, r0, #255
 3928 20a4 0010A0E3 		mov	r1, #0
 3929 20a8 0320A0E1 		mov	r2, r3
 3930 20ac 00008DE5 		str	r0, [sp]
 3931 20b0 0A30A0E1 		mov	r3, r10
 3932 20b4 0400A0E1 		mov	r0, r4
 3933 20b8 04108DE5 		str	r1, [sp, #4]
 3934 20bc 0510A0E3 		mov	r1, #5
 3935 20c0 FEFFFFEB 		bl	cmdSet
 3936              	.LVL411:
1534:../uvc.c      **** 							 dataIdx++;
 3937              		.loc 1 1534 0
 3938 20c4 18C09DE5 		ldr	ip, [sp, #24]
 3939 20c8 0180A0E3 		mov	r8, #1
 3940              	.LVL412:
 3941 20cc 76304CE2 		sub	r3, ip, #118
 3942 20d0 FF3003E2 		and	r3, r3, #255
 3943 20d4 00308DE5 		str	r3, [sp]
 3944 20d8 0400A0E1 		mov	r0, r4
 3945 20dc 0A30A0E1 		mov	r3, r10
 3946 20e0 0510A0E3 		mov	r1, #5
 3947 20e4 DC20A0E3 		mov	r2, #220
 3948 20e8 04808DE5 		str	r8, [sp, #4]
 3949 20ec FEFFFFEB 		bl	cmdSet
 3950              	.LVL413:
1536:../uvc.c      **** 							 dataIdx++;
 3951              		.loc 1 1536 0
 3952 20f0 18C09DE5 		ldr	ip, [sp, #24]
 3953 20f4 0230A0E3 		mov	r3, #2
 3954 20f8 7E208CE2 		add	r2, ip, #126
 3955 20fc FF2002E2 		and	r2, r2, #255
 3956 2100 00208DE5 		str	r2, [sp]
 3957 2104 0400A0E1 		mov	r0, r4
 3958 2108 04308DE5 		str	r3, [sp, #4]
 3959 210c 0510A0E3 		mov	r1, #5
 3960 2110 0A30A0E1 		mov	r3, r10
 3961 2114 DE20A0E3 		mov	r2, #222
 3962 2118 FEFFFFEB 		bl	cmdSet
 3963              	.LVL414:
1538:../uvc.c      **** 							 dataIdx++;
 3964              		.loc 1 1538 0
 3965 211c 18C09DE5 		ldr	ip, [sp, #24]
 3966 2120 0330A0E3 		mov	r3, #3
 3967 2124 72208CE2 		add	r2, ip, #114
 3968 2128 FF2002E2 		and	r2, r2, #255
 3969 212c 00208DE5 		str	r2, [sp]
 3970 2130 0400A0E1 		mov	r0, r4
 3971 2134 04308DE5 		str	r3, [sp, #4]
 3972 2138 0510A0E3 		mov	r1, #5
 3973 213c 0A30A0E1 		mov	r3, r10
 3974 2140 E020A0E3 		mov	r2, #224
 3975 2144 FEFFFFEB 		bl	cmdSet
 3976              	.LVL415:
1540:../uvc.c      **** 							 dataIdx++;
 3977              		.loc 1 1540 0
 3978 2148 18C09DE5 		ldr	ip, [sp, #24]
 3979 214c 0430A0E3 		mov	r3, #4
 3980 2150 6F204CE2 		sub	r2, ip, #111
 3981 2154 FF2002E2 		and	r2, r2, #255
 3982 2158 00208DE5 		str	r2, [sp]
 3983 215c 0400A0E1 		mov	r0, r4
 3984 2160 04308DE5 		str	r3, [sp, #4]
 3985 2164 0510A0E3 		mov	r1, #5
 3986 2168 0A30A0E1 		mov	r3, r10
 3987 216c DD20A0E3 		mov	r2, #221
 3988 2170 FEFFFFEB 		bl	cmdSet
 3989              	.LVL416:
1542:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3990              		.loc 1 1542 0
 3991 2174 2800D7E5 		ldrb	r0, [r7, #40]	@ zero_extendqisi2
 3992 2178 0510A0E3 		mov	r1, #5
 3993 217c 7F0080E2 		add	r0, r0, #127
 3994 2180 FF0000E2 		and	r0, r0, #255
 3995 2184 0A30A0E1 		mov	r3, r10
 3996 2188 0B20A0E1 		mov	r2, fp
 3997 218c 00008DE5 		str	r0, [sp]
 3998 2190 04108DE5 		str	r1, [sp, #4]
 3999 2194 0400A0E1 		mov	r0, r4
 4000 2198 FEFFFFEB 		bl	cmdSet
 4001              	.LVL417:
1543:../uvc.c      **** 
 4002              		.loc 1 1543 0
 4003 219c 1C0094E5 		ldr	r0, [r4, #28]
 4004 21a0 FEFFFFEB 		bl	_txe_mutex_put
 4005              	.LVL418:
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4006              		.loc 1 1545 0
 4007 21a4 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
1547:../uvc.c      **** 						 case SaturCtlID6:
 4008              		.loc 1 1547 0
 4009 21a8 FF40A0E3 		mov	r4, #255
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4010              		.loc 1 1545 0
 4011 21ac 803043E2 		sub	r3, r3, #128
 4012 21b0 1C909DE5 		ldr	r9, [sp, #28]
 4013 21b4 18709DE5 		ldr	r7, [sp, #24]
1546:../uvc.c      **** 							 break;
 4014              		.loc 1 1546 0
 4015 21b8 0882C6E5 		strb	r8, [r6, #520]
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4016              		.loc 1 1545 0
 4017 21bc 0532C6E5 		strb	r3, [r6, #517]
1547:../uvc.c      **** 						 case SaturCtlID6:
 4018              		.loc 1 1547 0
 4019 21c0 04A0A0E1 		mov	r10, r4
 4020 21c4 4FFDFFEA 		b	.L309
 4021              	.LVL419:
 4022              	.L387:
1578:../uvc.c      **** 							 is60Hz = Data0;
 4023              		.loc 1 1578 0
 4024 21c8 18C09DE5 		ldr	ip, [sp, #24]
1579:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 4025              		.loc 1 1579 0
 4026 21cc 58349FE5 		ldr	r3, .L465+56
1578:../uvc.c      **** 							 is60Hz = Data0;
 4027              		.loc 1 1578 0
 4028 21d0 01204CE2 		sub	r2, ip, #1
 4029              	.LVL420:
 4030 21d4 FF2002E2 		and	r2, r2, #255
 4031              	.LVL421:
1585:../uvc.c      **** 							 {
 4032              		.loc 1 1585 0
 4033 21d8 020052E3 		cmp	r2, #2
1579:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 4034              		.loc 1 1579 0
 4035 21dc 782087E5 		str	r2, [r7, #120]
1588:../uvc.c      **** 							 }
 4036              		.loc 1 1588 0
 4037 21e0 0120A083 		movhi	r2, #1
 4038 21e4 78208385 		strhi	r2, [r3, #120]
 4039              	.LVL422:
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4040              		.loc 1 1590 0
 4041 21e8 0400A0E3 		mov	r0, #4
 4042 21ec 783097E5 		ldr	r3, [r7, #120]
 4043 21f0 20149FE5 		ldr	r1, .L465+36
1577:../uvc.c      **** 							 Data0 = Data0 - 1;
 4044              		.loc 1 1577 0
 4045 21f4 EDC1C6E5 		strb	ip, [r6, #493]
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4046              		.loc 1 1590 0
 4047 21f8 FEFFFFEB 		bl	CyU3PDebugPrint
 4048              	.LVL423:
1591:../uvc.c      **** 							 {
 4049              		.loc 1 1591 0
 4050 21fc 6C3097E5 		ldr	r3, [r7, #108]
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4051              		.loc 1 1590 0
 4052 2200 24249FE5 		ldr	r2, .L465+56
1591:../uvc.c      **** 							 {
 4053              		.loc 1 1591 0
 4054 2204 010053E3 		cmp	r3, #1
 4055 2208 D901000A 		beq	.L461
 4056              	.L419:
1621:../uvc.c      **** 							 break;
 4057              		.loc 1 1621 0
 4058 220c 0130A0E3 		mov	r3, #1
1622:../uvc.c      **** 					 	 case BLCCtlID0:
 4059              		.loc 1 1622 0
 4060 2210 FF40A0E3 		mov	r4, #255
 4061 2214 18709DE5 		ldr	r7, [sp, #24]
 4062 2218 1C909DE5 		ldr	r9, [sp, #28]
1621:../uvc.c      **** 							 break;
 4063              		.loc 1 1621 0
 4064 221c F031C6E5 		strb	r3, [r6, #496]
1622:../uvc.c      **** 					 	 case BLCCtlID0:
 4065              		.loc 1 1622 0
 4066 2220 04A0A0E1 		mov	r10, r4
 4067 2224 37FDFFEA 		b	.L309
 4068              	.LVL424:
 4069              	.L386:
1677:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4070              		.loc 1 1677 0
 4071 2228 0C749FE5 		ldr	r7, .L465+72
 4072 222c 0010E0E3 		mvn	r1, #0
 4073 2230 1C0097E5 		ldr	r0, [r7, #28]
 4074 2234 14308DE5 		str	r3, [sp, #20]
 4075 2238 FEFFFFEB 		bl	_txe_mutex_get
 4076              	.LVL425:
1678:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4077              		.loc 1 1678 0
 4078 223c 18C09DE5 		ldr	ip, [sp, #24]
 4079 2240 14309DE5 		ldr	r3, [sp, #20]
 4080 2244 00E0A0E3 		mov	lr, #0
 4081 2248 00C08DE5 		str	ip, [sp]
 4082 224c 0410A0E1 		mov	r1, r4
 4083 2250 0320A0E1 		mov	r2, r3
 4084 2254 0700A0E1 		mov	r0, r7
 4085 2258 0A30A0E1 		mov	r3, r10
 4086 225c 04E08DE5 		str	lr, [sp, #4]
 4087 2260 FEFFFFEB 		bl	cmdSet
 4088              	.LVL426:
1679:../uvc.c      **** 
 4089              		.loc 1 1679 0
 4090 2264 1C0097E5 		ldr	r0, [r7, #28]
 4091 2268 FEFFFFEB 		bl	_txe_mutex_put
 4092              	.LVL427:
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 4093              		.loc 1 1681 0
 4094 226c 18C09DE5 		ldr	ip, [sp, #24]
1686:../uvc.c      **** 						 default:
 4095              		.loc 1 1686 0
 4096 2270 FF40A0E3 		mov	r4, #255
1682:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 4097              		.loc 1 1682 0
 4098 2274 0130A0E3 		mov	r3, #1
 4099 2278 1C909DE5 		ldr	r9, [sp, #28]
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 4100              		.loc 1 1681 0
 4101 227c BDC1C6E5 		strb	ip, [r6, #445]
 4102 2280 0C70A0E1 		mov	r7, ip
1682:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 4103              		.loc 1 1682 0
 4104 2284 C031C6E5 		strb	r3, [r6, #448]
1686:../uvc.c      **** 						 default:
 4105              		.loc 1 1686 0
 4106 2288 04A0A0E1 		mov	r10, r4
 4107 228c 1DFDFFEA 		b	.L309
 4108              	.LVL428:
 4109              	.L393:
1331:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 4110              		.loc 1 1331 0
 4111 2290 A4439FE5 		ldr	r4, .L465+72
 4112 2294 0010E0E3 		mvn	r1, #0
 4113 2298 1C0094E5 		ldr	r0, [r4, #28]
1327:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4114              		.loc 1 1327 0
 4115 229c 4C95D6E5 		ldrb	r9, [r6, #1356]	@ zero_extendqisi2
1328:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 4116              		.loc 1 1328 0
 4117 22a0 4DA5D6E5 		ldrb	r10, [r6, #1357]	@ zero_extendqisi2
1329:../uvc.c      **** 						     dataIdx = 0;
 4118              		.loc 1 1329 0
 4119 22a4 5B85D6E5 		ldrb	r8, [r6, #1371]	@ zero_extendqisi2
 4120              	.LVL429:
1331:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 4121              		.loc 1 1331 0
 4122 22a8 FEFFFFEB 		bl	_txe_mutex_get
 4123              	.LVL430:
1332:../uvc.c      **** 							 {
 4124              		.loc 1 1332 0
 4125 22ac 18C09DE5 		ldr	ip, [sp, #24]
 4126 22b0 5925D6E5 		ldrb	r2, [r6, #1369]	@ zero_extendqisi2
1327:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4127              		.loc 1 1327 0
 4128 22b4 FF9009E2 		and	r9, r9, #255
 4129              	.LVL431:
1332:../uvc.c      **** 							 {
 4130              		.loc 1 1332 0
 4131 22b8 02005CE1 		cmp	ip, r2
1328:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 4132              		.loc 1 1328 0
 4133 22bc FFA00AE2 		and	r10, r10, #255
 4134              	.LVL432:
1329:../uvc.c      **** 						     dataIdx = 0;
 4135              		.loc 1 1329 0
 4136 22c0 FF8008E2 		and	r8, r8, #255
 4137              	.LVL433:
1327:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4138              		.loc 1 1327 0
 4139 22c4 58339FE5 		ldr	r3, .L465+48
 4140 22c8 0C70A001 		moveq	r7, ip
1332:../uvc.c      **** 							 {
 4141              		.loc 1 1332 0
 4142 22cc 0B00000A 		beq	.L404
1334:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4143              		.loc 1 1334 0
 4144 22d0 59C5C3E5 		strb	ip, [r3, #1369]
1335:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 4145              		.loc 1 1335 0
 4146 22d4 3175D3E5 		ldrb	r7, [r3, #1329]	@ zero_extendqisi2
1336:../uvc.c      **** 								 /*
 4147              		.loc 1 1336 0
 4148 22d8 0030A0E3 		mov	r3, #0
1335:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 4149              		.loc 1 1335 0
 4150 22dc 07728CE1 		orr	r7, ip, r7, asl #4
 4151 22e0 FF7007E2 		and	r7, r7, #255
 4152              	.LVL434:
1336:../uvc.c      **** 								 /*
 4153              		.loc 1 1336 0
 4154 22e4 04308DE5 		str	r3, [sp, #4]
 4155 22e8 00708DE5 		str	r7, [sp]
 4156 22ec 0920A0E1 		mov	r2, r9
 4157 22f0 0400A0E1 		mov	r0, r4
 4158 22f4 1910A0E3 		mov	r1, #25
 4159 22f8 0830A0E1 		mov	r3, r8
 4160 22fc FEFFFFEB 		bl	cmdSet
 4161              	.LVL435:
 4162              	.L404:
1348:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 4163              		.loc 1 1348 0
 4164 2300 5A35D6E5 		ldrb	r3, [r6, #1370]	@ zero_extendqisi2
 4165 2304 1CC09DE5 		ldr	ip, [sp, #28]
 4166 2308 14239FE5 		ldr	r2, .L465+48
 4167 230c 0C0053E1 		cmp	r3, ip
 4168 2310 0600000A 		beq	.L406
1350:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4169              		.loc 1 1350 0
 4170 2314 18C09DE5 		ldr	ip, [sp, #24]
 4171 2318 02304CE2 		sub	r3, ip, #2
1349:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 4172              		.loc 1 1349 0
 4173 231c 1CC09DE5 		ldr	ip, [sp, #28]
1350:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4174              		.loc 1 1350 0
 4175 2320 FF3003E2 		and	r3, r3, #255
 4176 2324 010053E3 		cmp	r3, #1
1349:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 4177              		.loc 1 1349 0
 4178 2328 5AC5C2E5 		strb	ip, [r2, #1370]
1350:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4179              		.loc 1 1350 0
 4180 232c AF02009A 		bls	.L462
 4181              	.L406:
1355:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4182              		.loc 1 1355 0
 4183 2330 1C0094E5 		ldr	r0, [r4, #28]
 4184 2334 FEFFFFEB 		bl	_txe_mutex_put
 4185              	.LVL436:
1357:../uvc.c      **** 							 break;
 4186              		.loc 1 1357 0
 4187 2338 5925D6E5 		ldrb	r2, [r6, #1369]	@ zero_extendqisi2
1356:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 4188              		.loc 1 1356 0
 4189 233c 1C909DE5 		ldr	r9, [sp, #28]
 4190              	.LVL437:
1357:../uvc.c      **** 							 break;
 4191              		.loc 1 1357 0
 4192 2340 5A35D6E5 		ldrb	r3, [r6, #1370]	@ zero_extendqisi2
 4193 2344 3115D6E5 		ldrb	r1, [r6, #1329]	@ zero_extendqisi2
1356:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 4194              		.loc 1 1356 0
 4195 2348 0400A0E3 		mov	r0, #4
 4196 234c 82028DE8 		stmia	sp, {r1, r7, r9}
 4197 2350 C4129FE5 		ldr	r1, .L465+40
 4198 2354 FEFFFFEB 		bl	CyU3PDebugPrint
 4199              	.LVL438:
1358:../uvc.c      **** 
 4200              		.loc 1 1358 0
 4201 2358 FF40A0E3 		mov	r4, #255
 4202 235c 18709DE5 		ldr	r7, [sp, #24]
 4203              	.LVL439:
 4204 2360 04A0A0E1 		mov	r10, r4
 4205              	.LVL440:
 4206 2364 E7FCFFEA 		b	.L309
 4207              	.LVL441:
 4208              	.L391:
1565:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4209              		.loc 1 1565 0
 4210 2368 CC729FE5 		ldr	r7, .L465+72
 4211 236c 0010E0E3 		mvn	r1, #0
 4212 2370 1C0097E5 		ldr	r0, [r7, #28]
 4213 2374 14308DE5 		str	r3, [sp, #20]
 4214 2378 FEFFFFEB 		bl	_txe_mutex_get
 4215              	.LVL442:
1566:../uvc.c      **** 							 dataIdx++;
 4216              		.loc 1 1566 0
 4217 237c 18C09DE5 		ldr	ip, [sp, #24]
 4218 2380 14309DE5 		ldr	r3, [sp, #20]
 4219 2384 0010A0E3 		mov	r1, #0
 4220 2388 0320A0E1 		mov	r2, r3
 4221 238c 00C08DE5 		str	ip, [sp]
 4222 2390 0A30A0E1 		mov	r3, r10
 4223 2394 0700A0E1 		mov	r0, r7
 4224 2398 04108DE5 		str	r1, [sp, #4]
 4225 239c 0B10A0E3 		mov	r1, #11
 4226 23a0 FEFFFFEB 		bl	cmdSet
 4227              	.LVL443:
1568:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4228              		.loc 1 1568 0
 4229 23a4 1CC09DE5 		ldr	ip, [sp, #28]
 4230 23a8 0180A0E3 		mov	r8, #1
 4231              	.LVL444:
 4232 23ac 00C08DE5 		str	ip, [sp]
 4233 23b0 0A30A0E1 		mov	r3, r10
 4234 23b4 0B20A0E1 		mov	r2, fp
 4235 23b8 0700A0E1 		mov	r0, r7
 4236 23bc 0B10A0E3 		mov	r1, #11
 4237 23c0 04808DE5 		str	r8, [sp, #4]
 4238 23c4 FEFFFFEB 		bl	cmdSet
 4239              	.LVL445:
1569:../uvc.c      **** 
 4240              		.loc 1 1569 0
 4241 23c8 1C0097E5 		ldr	r0, [r7, #28]
 4242 23cc FEFFFFEB 		bl	_txe_mutex_put
 4243              	.LVL446:
1572:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4244              		.loc 1 1572 0
 4245 23d0 1CC09DE5 		ldr	ip, [sp, #28]
 4246 23d4 18709DE5 		ldr	r7, [sp, #24]
1574:../uvc.c      **** 						 case MFreqCtlID4:
 4247              		.loc 1 1574 0
 4248 23d8 FF40A0E3 		mov	r4, #255
 4249              	.LVL447:
1573:../uvc.c      **** 							 break;
 4250              		.loc 1 1573 0
 4251 23dc 9882C6E5 		strb	r8, [r6, #664]
1571:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 4252              		.loc 1 1571 0
 4253 23e0 6075C6E5 		strb	r7, [r6, #1376]
1572:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4254              		.loc 1 1572 0
 4255 23e4 62C5C6E5 		strb	ip, [r6, #1378]
 4256 23e8 0C90A0E1 		mov	r9, ip
1574:../uvc.c      **** 						 case MFreqCtlID4:
 4257              		.loc 1 1574 0
 4258 23ec 04A0A0E1 		mov	r10, r4
 4259 23f0 C4FCFFEA 		b	.L309
 4260              	.LVL448:
 4261              	.L390:
1657:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4262              		.loc 1 1657 0
 4263 23f4 18C09DE5 		ldr	ip, [sp, #24]
1656:../uvc.c      **** 							 if(Data0 != 0){
 4264              		.loc 1 1656 0
 4265 23f8 0140A0E3 		mov	r4, #1
1651:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4266              		.loc 1 1651 0
 4267 23fc 7885D6E5 		ldrb	r8, [r6, #1400]	@ zero_extendqisi2
 4268              	.LVL449:
1652:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4269              		.loc 1 1652 0
 4270 2400 7995D6E5 		ldrb	r9, [r6, #1401]	@ zero_extendqisi2
1653:../uvc.c      **** 						     dataIdx = 0;
 4271              		.loc 1 1653 0
 4272 2404 8775D6E5 		ldrb	r7, [r6, #1415]	@ zero_extendqisi2
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4273              		.loc 1 1655 0
 4274 2408 85C5C6E5 		strb	ip, [r6, #1413]
1656:../uvc.c      **** 							 if(Data0 != 0){
 4275              		.loc 1 1656 0
 4276 240c 8945C6E5 		strb	r4, [r6, #1417]
1658:../uvc.c      **** #ifdef COLOR
 4277              		.loc 1 1658 0
 4278 2410 24629FE5 		ldr	r6, .L465+72
1657:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4279              		.loc 1 1657 0
 4280 2414 00005CE3 		cmp	ip, #0
1651:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4281              		.loc 1 1651 0
 4282 2418 FF8008E2 		and	r8, r8, #255
 4283              	.LVL450:
1652:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4284              		.loc 1 1652 0
 4285 241c FF9009E2 		and	r9, r9, #255
 4286              	.LVL451:
1653:../uvc.c      **** 						     dataIdx = 0;
 4287              		.loc 1 1653 0
 4288 2420 FF7007E2 		and	r7, r7, #255
 4289              	.LVL452:
1658:../uvc.c      **** #ifdef COLOR
 4290              		.loc 1 1658 0
 4291 2424 0010E0E3 		mvn	r1, #0
 4292 2428 1C0096E5 		ldr	r0, [r6, #28]
1657:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4293              		.loc 1 1657 0
 4294 242c 2C01000A 		beq	.L435
1658:../uvc.c      **** #ifdef COLOR
 4295              		.loc 1 1658 0
 4296 2430 FEFFFFEB 		bl	_txe_mutex_get
 4297              	.LVL453:
1662:../uvc.c      **** 								 dataIdx++;
 4298              		.loc 1 1662 0
 4299 2434 0030A0E3 		mov	r3, #0
 4300 2438 0820A0E1 		mov	r2, r8
 4301 243c 04308DE5 		str	r3, [sp, #4]
 4302 2440 00408DE5 		str	r4, [sp]
 4303 2444 0600A0E1 		mov	r0, r6
 4304 2448 0710A0E3 		mov	r1, #7
 4305 244c 0730A0E1 		mov	r3, r7
 4306 2450 FEFFFFEB 		bl	cmdSet
 4307              	.LVL454:
1664:../uvc.c      **** #endif
 4308              		.loc 1 1664 0
 4309 2454 18C09DE5 		ldr	ip, [sp, #24]
 4310 2458 0920A0E1 		mov	r2, r9
 4311 245c 00C08DE5 		str	ip, [sp]
 4312 2460 04408DE5 		str	r4, [sp, #4]
 4313              	.LVL455:
 4314              	.L456:
1669:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4315              		.loc 1 1669 0
 4316 2464 0730A0E1 		mov	r3, r7
 4317 2468 0710A0E3 		mov	r1, #7
 4318 246c 0600A0E1 		mov	r0, r6
 4319 2470 FEFFFFEB 		bl	cmdSet
 4320              	.LVL456:
1670:../uvc.c      **** 
 4321              		.loc 1 1670 0
 4322 2474 FF40A0E3 		mov	r4, #255
 4323 2478 1C0096E5 		ldr	r0, [r6, #28]
 4324 247c FEFFFFEB 		bl	_txe_mutex_put
 4325              	.LVL457:
 4326 2480 04A0A0E1 		mov	r10, r4
 4327 2484 1C909DE5 		ldr	r9, [sp, #28]
 4328              	.LVL458:
 4329 2488 18709DE5 		ldr	r7, [sp, #24]
 4330              	.LVL459:
 4331 248c 9DFCFFEA 		b	.L309
 4332              	.LVL460:
 4333              	.L392:
1270:../uvc.c      **** #if 1	// register setting directly
 4334              		.loc 1 1270 0
 4335 2490 18109DE5 		ldr	r1, [sp, #24]
1267:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 4336              		.loc 1 1267 0
 4337 2494 2495D6E5 		ldrb	r9, [r6, #1316]	@ zero_extendqisi2
1268:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 4338              		.loc 1 1268 0
 4339 2498 2535D6E5 		ldrb	r3, [r6, #1317]	@ zero_extendqisi2
1269:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 4340              		.loc 1 1269 0
 4341 249c 3345D6E5 		ldrb	r4, [r6, #1331]	@ zero_extendqisi2
1270:../uvc.c      **** #if 1	// register setting directly
 4342              		.loc 1 1270 0
 4343 24a0 3115C6E5 		strb	r1, [r6, #1329]
1272:../uvc.c      **** 						     {
 4344              		.loc 1 1272 0
 4345 24a4 5925D6E5 		ldrb	r2, [r6, #1369]	@ zero_extendqisi2
 4346              	.LVL461:
1268:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 4347              		.loc 1 1268 0
 4348 24a8 FFB003E2 		and	fp, r3, #255
1272:../uvc.c      **** 						     {
 4349              		.loc 1 1272 0
 4350 24ac 030012E3 		tst	r2, #3
1267:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 4351              		.loc 1 1267 0
 4352 24b0 6C319FE5 		ldr	r3, .L465+48
 4353 24b4 FF9009E2 		and	r9, r9, #255
 4354              	.LVL462:
 4355 24b8 0170A0E1 		mov	r7, r1
1269:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 4356              		.loc 1 1269 0
 4357 24bc FF4004E2 		and	r4, r4, #255
 4358              	.LVL463:
1272:../uvc.c      **** 						     {
 4359              		.loc 1 1272 0
 4360 24c0 0130A001 		moveq	r3, r1
 4361 24c4 1B00000A 		beq	.L403
1274:../uvc.c      **** 						    	 dataIdx = 0;
 4362              		.loc 1 1274 0
 4363 24c8 59A5D3E5 		ldrb	r10, [r3, #1369]	@ zero_extendqisi2
1276:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4364              		.loc 1 1276 0
 4365 24cc 68819FE5 		ldr	r8, .L465+72
 4366              	.LVL464:
1274:../uvc.c      **** 						    	 dataIdx = 0;
 4367              		.loc 1 1274 0
 4368 24d0 01A28AE1 		orr	r10, r10, r1, asl #4
1276:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4369              		.loc 1 1276 0
 4370 24d4 1C0098E5 		ldr	r0, [r8, #28]
 4371 24d8 0010E0E3 		mvn	r1, #0
 4372 24dc 14C08DE5 		str	ip, [sp, #20]
 4373 24e0 FEFFFFEB 		bl	_txe_mutex_get
 4374              	.LVL465:
1277:../uvc.c      **** 								 dataIdx++;
 4375              		.loc 1 1277 0
 4376 24e4 0030A0E3 		mov	r3, #0
 4377 24e8 0B20A0E1 		mov	r2, fp
 4378 24ec 00308DE5 		str	r3, [sp]
 4379 24f0 04308DE5 		str	r3, [sp, #4]
 4380 24f4 1010A0E3 		mov	r1, #16
 4381 24f8 0430A0E1 		mov	r3, r4
 4382 24fc 0800A0E1 		mov	r0, r8
 4383 2500 FEFFFFEB 		bl	cmdSet
 4384              	.LVL466:
1274:../uvc.c      **** 						    	 dataIdx = 0;
 4385              		.loc 1 1274 0
 4386 2504 FFA00AE2 		and	r10, r10, #255
 4387              	.LVL467:
1279:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4388              		.loc 1 1279 0
 4389 2508 0110A0E3 		mov	r1, #1
 4390 250c 0430A0E1 		mov	r3, r4
 4391 2510 0920A0E1 		mov	r2, r9
 4392 2514 04108DE5 		str	r1, [sp, #4]
 4393 2518 00A08DE5 		str	r10, [sp]
 4394 251c 1010A0E3 		mov	r1, #16
 4395 2520 0800A0E1 		mov	r0, r8
 4396 2524 FEFFFFEB 		bl	cmdSet
 4397              	.LVL468:
1280:../uvc.c      **** 						     }
 4398              		.loc 1 1280 0
 4399 2528 1C0098E5 		ldr	r0, [r8, #28]
 4400 252c FEFFFFEB 		bl	_txe_mutex_put
 4401              	.LVL469:
 4402 2530 14C09DE5 		ldr	ip, [sp, #20]
 4403 2534 0A30A0E1 		mov	r3, r10
 4404              	.LVL470:
 4405              	.L403:
1283:../uvc.c      **** 						     break;
 4406              		.loc 1 1283 0
 4407 2538 5905D6E5 		ldrb	r0, [r6, #1369]	@ zero_extendqisi2
 4408 253c 3115D6E5 		ldrb	r1, [r6, #1329]	@ zero_extendqisi2
1282:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4409              		.loc 1 1282 0
 4410 2540 0C20A0E1 		mov	r2, ip
 4411 2544 03008DE8 		stmia	sp, {r0, r1}
 4412 2548 D0109FE5 		ldr	r1, .L465+44
 4413 254c 0400A0E3 		mov	r0, #4
1284:../uvc.c      **** #else	// old fashion
 4414              		.loc 1 1284 0
 4415 2550 FF40A0E3 		mov	r4, #255
 4416              	.LVL471:
1282:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4417              		.loc 1 1282 0
 4418 2554 FEFFFFEB 		bl	CyU3PDebugPrint
 4419              	.LVL472:
1284:../uvc.c      **** #else	// old fashion
 4420              		.loc 1 1284 0
 4421 2558 04A0A0E1 		mov	r10, r4
 4422 255c 1C909DE5 		ldr	r9, [sp, #28]
 4423              	.LVL473:
 4424 2560 68FCFFEA 		b	.L309
 4425              	.LVL474:
 4426              	.L395:
1388:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 4427              		.loc 1 1388 0
 4428 2564 18C09DE5 		ldr	ip, [sp, #24]
1398:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4429              		.loc 1 1398 0
 4430 2568 CC809FE5 		ldr	r8, .L465+72
 4431              	.LVL475:
1388:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 4432              		.loc 1 1388 0
 4433 256c 03005CE3 		cmp	ip, #3
1393:../uvc.c      **** 							 }
 4434              		.loc 1 1393 0
 4435 2570 04E04C82 		subhi	lr, ip, #4
 4436 2574 18C09D85 		ldrhi	ip, [sp, #24]
 4437 2578 0CE0A091 		movls	lr, ip
1392:../uvc.c      **** 								 Data1 = Data0-4;
 4438              		.loc 1 1392 0
 4439 257c 0140A083 		movhi	r4, #1
 4440              	.LVL476:
1389:../uvc.c      **** 								 Data1 = Data0;
 4441              		.loc 1 1389 0
 4442 2580 0040A093 		movls	r4, #0
 4443 2584 0EC0A091 		movls	ip, lr
1393:../uvc.c      **** 							 }
 4444              		.loc 1 1393 0
 4445 2588 FFE00E82 		andhi	lr, lr, #255
 4446              	.LVL477:
1397:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4447              		.loc 1 1397 0
 4448 258c 0120A0E3 		mov	r2, #1
 4449              	.LVL478:
1398:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4450              		.loc 1 1398 0
 4451 2590 1C0098E5 		ldr	r0, [r8, #28]
 4452 2594 0010E0E3 		mvn	r1, #0
 4453 2598 A041C7E5 		strb	r4, [r7, #416]
 4454              	.LVL479:
1396:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4455              		.loc 1 1396 0
 4456 259c 8DE1C6E5 		strb	lr, [r6, #397]
1395:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 4457              		.loc 1 1395 0
 4458 25a0 2DC4C6E5 		strb	ip, [r6, #1069]
1397:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4459              		.loc 1 1397 0
 4460 25a4 3024C6E5 		strb	r2, [r6, #1072]
1398:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4461              		.loc 1 1398 0
 4462 25a8 14308DE5 		str	r3, [sp, #20]
 4463 25ac FEFFFFEB 		bl	_txe_mutex_get
 4464              	.LVL480:
1399:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4465              		.loc 1 1399 0
 4466 25b0 18C09DE5 		ldr	ip, [sp, #24]
 4467 25b4 14309DE5 		ldr	r3, [sp, #20]
 4468 25b8 0010A0E3 		mov	r1, #0
 4469 25bc 0320A0E1 		mov	r2, r3
 4470 25c0 00C08DE5 		str	ip, [sp]
 4471 25c4 0A30A0E1 		mov	r3, r10
 4472 25c8 04108DE5 		str	r1, [sp, #4]
 4473 25cc 0800A0E1 		mov	r0, r8
 4474 25d0 1C10A0E3 		mov	r1, #28
 4475 25d4 FEFFFFEB 		bl	cmdSet
 4476              	.LVL481:
1402:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4477              		.loc 1 1402 0
 4478 25d8 FF40A0E3 		mov	r4, #255
1400:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 4479              		.loc 1 1400 0
 4480 25dc 1C0098E5 		ldr	r0, [r8, #28]
 4481 25e0 FEFFFFEB 		bl	_txe_mutex_put
 4482              	.LVL482:
1402:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4483              		.loc 1 1402 0
 4484 25e4 04A0A0E1 		mov	r10, r4
 4485 25e8 1C909DE5 		ldr	r9, [sp, #28]
 4486 25ec 18709DE5 		ldr	r7, [sp, #24]
 4487 25f0 44FCFFEA 		b	.L309
 4488              	.L466:
 4489              		.align	2
 4490              	.L465:
 4491 25f4 00000000 		.word	bRequest
 4492 25f8 28000000 		.word	.LANCHOR0+40
 4493 25fc 54060000 		.word	.LC37
 4494 2600 01000100 		.word	65537
 4495 2604 FF00FF00 		.word	16711935
 4496 2608 E4040000 		.word	.LC29
 4497 260c 20050000 		.word	.LC30
 4498 2610 84040000 		.word	.LC27
 4499 2614 14010000 		.word	.LANCHOR0+276
 4500 2618 E0050000 		.word	.LC34
 4501 261c 74050000 		.word	.LC32
 4502 2620 48050000 		.word	.LC31
 4503 2624 00000000 		.word	.LANCHOR1
 4504 2628 A8050000 		.word	.LC33
 4505 262c 00000000 		.word	.LANCHOR0
 4506 2630 24060000 		.word	.LC36
 4507 2634 00060000 		.word	.LC35
 4508 2638 5C040000 		.word	.LC26
 4509 263c 00000000 		.word	cmdQu
 4510 2640 AC040000 		.word	.LC28
 4511              	.LVL483:
 4512              	.L394:
1365:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 4513              		.loc 1 1365 0
 4514 2644 10401FE5 		ldr	r4, .L465+72
 4515 2648 0010E0E3 		mvn	r1, #0
 4516 264c 1C0094E5 		ldr	r0, [r4, #28]
1361:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4517              		.loc 1 1361 0
 4518 2650 3895D6E5 		ldrb	r9, [r6, #1336]	@ zero_extendqisi2
1362:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 4519              		.loc 1 1362 0
 4520 2654 3985D6E5 		ldrb	r8, [r6, #1337]	@ zero_extendqisi2
 4521              	.LVL484:
1363:../uvc.c      **** 						     dataIdx = 0;
 4522              		.loc 1 1363 0
 4523 2658 4775D6E5 		ldrb	r7, [r6, #1351]	@ zero_extendqisi2
1365:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 4524              		.loc 1 1365 0
 4525 265c FEFFFFEB 		bl	_txe_mutex_get
 4526              	.LVL485:
1373:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4527              		.loc 1 1373 0
 4528 2660 4525D6E5 		ldrb	r2, [r6, #1349]	@ zero_extendqisi2
 4529 2664 18C09DE5 		ldr	ip, [sp, #24]
1361:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4530              		.loc 1 1361 0
 4531 2668 FF9009E2 		and	r9, r9, #255
 4532              	.LVL486:
1373:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4533              		.loc 1 1373 0
 4534 266c 02005CE1 		cmp	ip, r2
1362:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 4535              		.loc 1 1362 0
 4536 2670 FF8008E2 		and	r8, r8, #255
 4537              	.LVL487:
1363:../uvc.c      **** 						     dataIdx = 0;
 4538              		.loc 1 1363 0
 4539 2674 FF7007E2 		and	r7, r7, #255
 4540              	.LVL488:
1361:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4541              		.loc 1 1361 0
 4542 2678 5C301FE5 		ldr	r3, .L465+48
1373:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4543              		.loc 1 1373 0
 4544 267c 0600000A 		beq	.L409
1374:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 4545              		.loc 1 1374 0
 4546 2680 45C5C3E5 		strb	ip, [r3, #1349]
1375:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4547              		.loc 1 1375 0
 4548 2684 5925D3E5 		ldrb	r2, [r3, #1369]	@ zero_extendqisi2
 4549 2688 010052E3 		cmp	r2, #1
 4550 268c C501000A 		beq	.L410
1375:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4551              		.loc 1 1375 0 is_stmt 0 discriminator 1
 4552 2690 5935D3E5 		ldrb	r3, [r3, #1369]	@ zero_extendqisi2
 4553 2694 030053E3 		cmp	r3, #3
 4554 2698 C201000A 		beq	.L410
 4555              	.LVL489:
 4556              	.L409:
1382:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4557              		.loc 1 1382 0 is_stmt 1
 4558 269c 1C0094E5 		ldr	r0, [r4, #28]
 4559 26a0 FEFFFFEB 		bl	_txe_mutex_put
 4560              	.LVL490:
1384:../uvc.c      **** 							 break;
 4561              		.loc 1 1384 0
 4562 26a4 5925D6E5 		ldrb	r2, [r6, #1369]	@ zero_extendqisi2
1383:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4563              		.loc 1 1383 0
 4564 26a8 18709DE5 		ldr	r7, [sp, #24]
 4565              	.LVL491:
1384:../uvc.c      **** 							 break;
 4566              		.loc 1 1384 0
 4567 26ac 5A35D6E5 		ldrb	r3, [r6, #1370]	@ zero_extendqisi2
1383:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4568              		.loc 1 1383 0
 4569 26b0 1C909DE5 		ldr	r9, [sp, #28]
 4570              	.LVL492:
1384:../uvc.c      **** 							 break;
 4571              		.loc 1 1384 0
 4572 26b4 4515D6E5 		ldrb	r1, [r6, #1349]	@ zero_extendqisi2
1383:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4573              		.loc 1 1383 0
 4574 26b8 0400A0E3 		mov	r0, #4
 4575 26bc 82028DE8 		stmia	sp, {r1, r7, r9}
 4576 26c0 A0101FE5 		ldr	r1, .L465+52
 4577 26c4 FEFFFFEB 		bl	CyU3PDebugPrint
 4578              	.LVL493:
1385:../uvc.c      **** 						 case ExtCamMCtlID12:
 4579              		.loc 1 1385 0
 4580 26c8 FF40A0E3 		mov	r4, #255
 4581 26cc 04A0A0E1 		mov	r10, r4
 4582 26d0 0CFCFFEA 		b	.L309
 4583              	.LVL494:
 4584              	.L396:
1410:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4585              		.loc 1 1410 0
 4586 26d4 A0401FE5 		ldr	r4, .L465+72
 4587 26d8 0010E0E3 		mvn	r1, #0
 4588 26dc 1C0094E5 		ldr	r0, [r4, #28]
 4589 26e0 14308DE5 		str	r3, [sp, #20]
 4590 26e4 FEFFFFEB 		bl	_txe_mutex_get
 4591              	.LVL495:
1411:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4592              		.loc 1 1411 0
 4593 26e8 18C09DE5 		ldr	ip, [sp, #24]
 4594 26ec 14309DE5 		ldr	r3, [sp, #20]
 4595 26f0 01E07CE2 		rsbs	lr, ip, #1
 4596 26f4 00E0A033 		movcc	lr, #0
 4597 26f8 0010A0E3 		mov	r1, #0
 4598 26fc 0320A0E1 		mov	r2, r3
 4599 2700 0400A0E1 		mov	r0, r4
 4600 2704 0A30A0E1 		mov	r3, r10
 4601 2708 00E08DE5 		str	lr, [sp]
 4602 270c 04108DE5 		str	r1, [sp, #4]
 4603 2710 1E10A0E3 		mov	r1, #30
 4604 2714 FEFFFFEB 		bl	cmdSet
 4605              	.LVL496:
1412:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4606              		.loc 1 1412 0
 4607 2718 1C0094E5 		ldr	r0, [r4, #28]
 4608 271c FEFFFFEB 		bl	_txe_mutex_put
 4609              	.LVL497:
1414:../uvc.c      **** 						 case ExtI2CCtlID15:
 4610              		.loc 1 1414 0
 4611 2720 FF40A0E3 		mov	r4, #255
1413:../uvc.c      **** 							 break;
 4612              		.loc 1 1413 0
 4613 2724 0130A0E3 		mov	r3, #1
 4614 2728 1C909DE5 		ldr	r9, [sp, #28]
 4615 272c 18709DE5 		ldr	r7, [sp, #24]
 4616 2730 6034C6E5 		strb	r3, [r6, #1120]
1414:../uvc.c      **** 						 case ExtI2CCtlID15:
 4617              		.loc 1 1414 0
 4618 2734 04A0A0E1 		mov	r10, r4
 4619 2738 F2FBFFEA 		b	.L309
 4620              	.LVL498:
 4621              	.L385:
1513:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 4622              		.loc 1 1513 0
 4623 273c 08411FE5 		ldr	r4, .L465+72
 4624 2740 0010E0E3 		mvn	r1, #0
 4625 2744 1C0094E5 		ldr	r0, [r4, #28]
 4626 2748 FEFFFFEB 		bl	_txe_mutex_get
 4627              	.LVL499:
1515:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 4628              		.loc 1 1515 0
 4629 274c 18C09DE5 		ldr	ip, [sp, #24]
1520:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4630              		.loc 1 1520 0
 4631 2750 0010A0E3 		mov	r1, #0
1515:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 4632              		.loc 1 1515 0
 4633 2754 80001CE3 		tst	ip, #128
1516:../uvc.c      **** 							  }else{
 4634              		.loc 1 1516 0
 4635 2758 80804C12 		subne	r8, ip, #128
 4636              	.LVL500:
1518:../uvc.c      **** 							  }
 4637              		.loc 1 1518 0
 4638 275c 0C80E001 		mvneq	r8, ip
 4639 2760 FF8008E2 		and	r8, r8, #255
 4640              	.LVL501:
1520:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4641              		.loc 1 1520 0
 4642 2764 0A30A0E1 		mov	r3, r10
 4643 2768 0B20A0E1 		mov	r2, fp
 4644 276c 04108DE5 		str	r1, [sp, #4]
 4645 2770 00808DE5 		str	r8, [sp]
 4646 2774 0110A0E3 		mov	r1, #1
 4647 2778 44011FE5 		ldr	r0, .L465+72
 4648 277c FEFFFFEB 		bl	cmdSet
 4649              	.LVL502:
1521:../uvc.c      **** 
 4650              		.loc 1 1521 0
 4651 2780 1C0094E5 		ldr	r0, [r4, #28]
 4652 2784 FEFFFFEB 		bl	_txe_mutex_put
 4653              	.LVL503:
1527:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4654              		.loc 1 1527 0
 4655 2788 FF40A0E3 		mov	r4, #255
1524:../uvc.c      **** 
 4656              		.loc 1 1524 0
 4657 278c 0130A0E3 		mov	r3, #1
 4658 2790 18709DE5 		ldr	r7, [sp, #24]
 4659 2794 1C909DE5 		ldr	r9, [sp, #28]
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4660              		.loc 1 1523 0
 4661 2798 A581C6E5 		strb	r8, [r6, #421]
1524:../uvc.c      **** 
 4662              		.loc 1 1524 0
 4663 279c A831C6E5 		strb	r3, [r6, #424]
1527:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4664              		.loc 1 1527 0
 4665 27a0 04A0A0E1 		mov	r10, r4
 4666 27a4 D7FBFFEA 		b	.L309
 4667              	.LVL504:
 4668              	.L383:
1634:../uvc.c      **** 							 {
 4669              		.loc 1 1634 0
 4670 27a8 A021D7E5 		ldrb	r2, [r7, #416]	@ zero_extendqisi2
 4671              	.LVL505:
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4672              		.loc 1 1631 0
 4673 27ac 18C09DE5 		ldr	ip, [sp, #24]
1624:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4674              		.loc 1 1624 0
 4675 27b0 6475D6E5 		ldrb	r7, [r6, #1380]	@ zero_extendqisi2
1625:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4676              		.loc 1 1625 0
 4677 27b4 6535D6E5 		ldrb	r3, [r6, #1381]	@ zero_extendqisi2
1626:../uvc.c      **** 						     dataIdx = 0;
 4678              		.loc 1 1626 0
 4679 27b8 7345D6E5 		ldrb	r4, [r6, #1395]	@ zero_extendqisi2
1634:../uvc.c      **** 							 {
 4680              		.loc 1 1634 0
 4681 27bc 010052E3 		cmp	r2, #1
1632:../uvc.c      **** 
 4682              		.loc 1 1632 0
 4683 27c0 0130A0E3 		mov	r3, #1
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4684              		.loc 1 1631 0
 4685 27c4 71C5C6E5 		strb	ip, [r6, #1393]
1624:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4686              		.loc 1 1624 0
 4687 27c8 FF7007E2 		and	r7, r7, #255
 4688              	.LVL506:
1626:../uvc.c      **** 						     dataIdx = 0;
 4689              		.loc 1 1626 0
 4690 27cc FF4004E2 		and	r4, r4, #255
 4691              	.LVL507:
1632:../uvc.c      **** 
 4692              		.loc 1 1632 0
 4693 27d0 7535C6E5 		strb	r3, [r6, #1397]
 4694 27d4 0C80A011 		movne	r8, ip
 4695              	.LVL508:
1634:../uvc.c      **** 							 {
 4696              		.loc 1 1634 0
 4697 27d8 C200000A 		beq	.L463
 4698              	.LVL509:
 4699              	.L433:
1645:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4700              		.loc 1 1645 0
 4701 27dc A8611FE5 		ldr	r6, .L465+72
 4702 27e0 0010E0E3 		mvn	r1, #0
 4703 27e4 1C0096E5 		ldr	r0, [r6, #28]
 4704 27e8 FEFFFFEB 		bl	_txe_mutex_get
 4705              	.LVL510:
1646:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4706              		.loc 1 1646 0
 4707 27ec 0010A0E3 		mov	r1, #0
 4708 27f0 0720A0E1 		mov	r2, r7
 4709 27f4 0430A0E1 		mov	r3, r4
 4710 27f8 04108DE5 		str	r1, [sp, #4]
 4711 27fc 00808DE5 		str	r8, [sp]
 4712 2800 0600A0E1 		mov	r0, r6
 4713 2804 FEFFFFEB 		bl	cmdSet
 4714              	.LVL511:
1649:../uvc.c      **** 					 	 case ShapCtlID7:
 4715              		.loc 1 1649 0
 4716 2808 FF40A0E3 		mov	r4, #255
 4717              	.LVL512:
1647:../uvc.c      **** 
 4718              		.loc 1 1647 0
 4719 280c 1C0096E5 		ldr	r0, [r6, #28]
 4720 2810 FEFFFFEB 		bl	_txe_mutex_put
 4721              	.LVL513:
1649:../uvc.c      **** 					 	 case ShapCtlID7:
 4722              		.loc 1 1649 0
 4723 2814 04A0A0E1 		mov	r10, r4
 4724 2818 18709DE5 		ldr	r7, [sp, #24]
 4725              	.LVL514:
 4726 281c 1C909DE5 		ldr	r9, [sp, #28]
 4727 2820 B8FBFFEA 		b	.L309
 4728              	.LVL515:
 4729              	.L310:
1149:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 4730              		.loc 1 1149 0
 4731 2824 00721FE5 		ldr	r7, .L465+56
 4732 2828 048087E0 		add	r8, r7, r4
 4733              	.LVL516:
 4734 282c 6021D8E5 		ldrb	r2, [r8, #352]	@ zero_extendqisi2
 4735 2830 000052E3 		cmp	r2, #0
 4736 2834 B000000A 		beq	.L366
1150:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4737              		.loc 1 1150 0
 4738 2838 844084E0 		add	r4, r4, r4, asl #1
 4739 283c 846186E0 		add	r6, r6, r4, asl #3
 4740 2840 8DA1D6E5 		ldrb	r10, [r6, #397]	@ zero_extendqisi2
1151:../uvc.c      **** 		 	 		 }else{
 4741              		.loc 1 1151 0
 4742 2844 8E41D6E5 		ldrb	r4, [r6, #398]	@ zero_extendqisi2
1150:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4743              		.loc 1 1150 0
 4744 2848 28A0C7E5 		strb	r10, [r7, #40]
1151:../uvc.c      **** 		 	 		 }else{
 4745              		.loc 1 1151 0
 4746 284c 2940C7E5 		strb	r4, [r7, #41]
 4747 2850 ACFCFFEA 		b	.L333
 4748              	.LVL517:
 4749              	.L382:
1690:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4750              		.loc 1 1690 0
 4751 2854 20721FE5 		ldr	r7, .L465+72
 4752 2858 0010E0E3 		mvn	r1, #0
 4753 285c 1C0097E5 		ldr	r0, [r7, #28]
 4754 2860 14308DE5 		str	r3, [sp, #20]
 4755 2864 FEFFFFEB 		bl	_txe_mutex_get
 4756              	.LVL518:
1691:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4757              		.loc 1 1691 0
 4758 2868 18C09DE5 		ldr	ip, [sp, #24]
 4759 286c 14309DE5 		ldr	r3, [sp, #20]
 4760 2870 0010A0E3 		mov	r1, #0
 4761 2874 00C08DE5 		str	ip, [sp]
 4762 2878 0320A0E1 		mov	r2, r3
 4763 287c 0700A0E1 		mov	r0, r7
 4764 2880 0A30A0E1 		mov	r3, r10
 4765 2884 04108DE5 		str	r1, [sp, #4]
 4766 2888 0410A0E1 		mov	r1, r4
 4767 288c FEFFFFEB 		bl	cmdSet
 4768              	.LVL519:
1692:../uvc.c      **** 
 4769              		.loc 1 1692 0
 4770 2890 1C0097E5 		ldr	r0, [r7, #28]
 4771 2894 FEFFFFEB 		bl	_txe_mutex_put
 4772              	.LVL520:
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4773              		.loc 1 1694 0
 4774 2898 18C09DE5 		ldr	ip, [sp, #24]
 4775 289c 844084E0 		add	r4, r4, r4, asl #1
 4776 28a0 846186E0 		add	r6, r6, r4, asl #3
1695:../uvc.c      **** 							 break;
 4777              		.loc 1 1695 0
 4778 28a4 0130A0E3 		mov	r3, #1
1696:../uvc.c      **** 					 }
 4779              		.loc 1 1696 0
 4780 28a8 FF40A0E3 		mov	r4, #255
 4781 28ac 1C909DE5 		ldr	r9, [sp, #28]
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4782              		.loc 1 1694 0
 4783 28b0 8DC1C6E5 		strb	ip, [r6, #397]
 4784 28b4 0C70A0E1 		mov	r7, ip
1695:../uvc.c      **** 							 break;
 4785              		.loc 1 1695 0
 4786 28b8 9031C6E5 		strb	r3, [r6, #400]
1696:../uvc.c      **** 					 }
 4787              		.loc 1 1696 0
 4788 28bc 04A0A0E1 		mov	r10, r4
 4789 28c0 90FBFFEA 		b	.L309
 4790              	.LVL521:
 4791              	.L381:
1699:../uvc.c      **** 			   }
 4792              		.loc 1 1699 0
 4793 28c4 FF40A0E3 		mov	r4, #255
 4794 28c8 0400A0E3 		mov	r0, #4
 4795              	.LVL522:
 4796 28cc A4121FE5 		ldr	r1, .L465+60
 4797 28d0 FEFFFFEB 		bl	CyU3PDebugPrint
 4798              	.LVL523:
 4799 28d4 04A0A0E1 		mov	r10, r4
 4800 28d8 0490A0E1 		mov	r9, r4
 4801 28dc 0470A0E1 		mov	r7, r4
 4802 28e0 88FBFFEA 		b	.L309
 4803              	.LVL524:
 4804              	.L435:
1668:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4805              		.loc 1 1668 0
 4806 28e4 FEFFFFEB 		bl	_txe_mutex_get
 4807              	.LVL525:
1669:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4808              		.loc 1 1669 0
 4809 28e8 18C09DE5 		ldr	ip, [sp, #24]
 4810 28ec 0820A0E1 		mov	r2, r8
 4811 28f0 00C08DE5 		str	ip, [sp]
 4812 28f4 04C08DE5 		str	ip, [sp, #4]
 4813 28f8 D9FEFFEA 		b	.L456
 4814              	.LVL526:
 4815              	.L331:
 840:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4816              		.loc 1 840 0
 4817 28fc 0A10A0E1 		mov	r1, r10
 4818 2900 0B00A0E1 		mov	r0, fp
 4819              	.LVL527:
 4820 2904 14308DE5 		str	r3, [sp, #20]
 4821 2908 FEFFFFEB 		bl	SensorGetControl
 4822              	.LVL528:
 842:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4823              		.loc 1 842 0
 4824 290c 14309DE5 		ldr	r3, [sp, #20]
 4825 2910 0A10A0E1 		mov	r1, r10
 840:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4826              		.loc 1 840 0
 4827 2914 0020A0E1 		mov	r2, r0
 842:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4828              		.loc 1 842 0
 4829 2918 0300A0E1 		mov	r0, r3
 840:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4830              		.loc 1 840 0
 4831 291c 2820C7E5 		strb	r2, [r7, #40]
 841:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4832              		.loc 1 841 0
 4833 2920 0925C6E5 		strb	r2, [r6, #1289]
 842:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4834              		.loc 1 842 0
 4835 2924 FEFFFFEB 		bl	SensorGetControl
 4836              	.LVL529:
 843:../uvc.c      **** 			 	 		 }
 4837              		.loc 1 843 0
 4838 2928 0130A0E3 		mov	r3, #1
 4839 292c 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 4840 2930 8431C7E5 		strb	r3, [r7, #388]
 4841              	.LVL530:
 4842 2934 0040A0E1 		mov	r4, r0
 4843              	.LVL531:
 842:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4844              		.loc 1 842 0
 4845 2938 2900C7E5 		strb	r0, [r7, #41]
 847:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 4846              		.loc 1 847 0
 4847 293c 71FCFFEA 		b	.L333
 4848              	.LVL532:
 4849              	.L336:
 873:../uvc.c      **** 			 	 			if(Data0&0x80)
 4850              		.loc 1 873 0
 4851 2940 0300A0E1 		mov	r0, r3
 4852              	.LVL533:
 4853 2944 0A10A0E1 		mov	r1, r10
 4854 2948 FEFFFFEB 		bl	SensorGetControl
 4855              	.LVL534:
 879:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4856              		.loc 1 879 0
 4857 294c 9E30D6E5 		ldrb	r3, [r6, #158]	@ zero_extendqisi2
 880:../uvc.c      **** 			 	 		 }
 4858              		.loc 1 880 0
 4859 2950 0120A0E3 		mov	r2, #1
 4860 2954 0340A0E1 		mov	r4, r3
 879:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4861              		.loc 1 879 0
 4862 2958 2930C7E5 		strb	r3, [r7, #41]
 880:../uvc.c      **** 			 	 		 }
 4863              		.loc 1 880 0
 4864 295c 8621C7E5 		strb	r2, [r7, #390]
 874:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4865              		.loc 1 874 0
 4866 2960 A003A0E1 		mov	r0, r0, lsr #7
 4867              	.LVL535:
 875:../uvc.c      **** 			 	 			else
 4868              		.loc 1 875 0
 4869 2964 02A000E0 		and	r10, r0, r2
 4870 2968 28A0C7E5 		strb	r10, [r7, #40]
 878:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4871              		.loc 1 878 0
 4872 296c 9DA0C6E5 		strb	r10, [r6, #157]
 4873              	.LVL536:
 884:../uvc.c      **** 			 	 }
 4874              		.loc 1 884 0
 4875 2970 64FCFFEA 		b	.L333
 4876              	.LVL537:
 4877              	.L461:
1594:../uvc.c      **** 			                         {
 4878              		.loc 1 1594 0
 4879 2974 7C30D2E5 		ldrb	r3, [r2, #124]	@ zero_extendqisi2
 4880 2978 013043E2 		sub	r3, r3, #1
 4881 297c 030053E3 		cmp	r3, #3
 4882 2980 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4883 2984 20FEFFEA 		b	.L419
 4884              	.L421:
 4885 2988 9C2A0000 		.word	.L420
 4886 298c 502A0000 		.word	.L422
 4887 2990 F4290000 		.word	.L423
 4888 2994 98290000 		.word	.L424
 4889              	.L424:
1612:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4890              		.loc 1 1612 0
 4891 2998 782097E5 		ldr	r2, [r7, #120]
 4892 299c D234D6E5 		ldrb	r3, [r6, #1234]	@ zero_extendqisi2
 4893 29a0 000052E3 		cmp	r2, #0
 4894 29a4 F420A003 		moveq	r2, #244
 4895 29a8 7420A013 		movne	r2, #116
 4896 29ac 032082E1 		orr	r2, r2, r3
 4897 29b0 3010A0E3 		mov	r1, #48
 4898 29b4 5230A0E3 		mov	r3, #82
 4899 29b8 0100A0E3 		mov	r0, #1
 4900 29bc FEFFFFEB 		bl	SensorSetIrisControl
 4901              	.LVL538:
1613:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4902              		.loc 1 1613 0
 4903 29c0 7D0FA0E3 		mov	r0, #500
 4904 29c4 FEFFFFEB 		bl	_tx_thread_sleep
 4905              	.LVL539:
1614:../uvc.c      **** 			                         	default:
 4906              		.loc 1 1614 0
 4907 29c8 781097E5 		ldr	r1, [r7, #120]
 4908 29cc D224D6E5 		ldrb	r2, [r6, #1234]	@ zero_extendqisi2
 4909 29d0 000051E3 		cmp	r1, #0
 4910 29d4 F410A003 		moveq	r1, #244
 4911 29d8 7410A013 		movne	r1, #116
 4912 29dc 022081E1 		orr	r2, r1, r2
 4913 29e0 783097E5 		ldr	r3, [r7, #120]
 4914 29e4 B8131FE5 		ldr	r1, .L465+64
 4915 29e8 0400A0E3 		mov	r0, #4
 4916 29ec FEFFFFEB 		bl	CyU3PDebugPrint
 4917              	.LVL540:
 4918 29f0 05FEFFEA 		b	.L419
 4919              	.L423:
1607:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4920              		.loc 1 1607 0
 4921 29f4 782097E5 		ldr	r2, [r7, #120]
 4922 29f8 D234D6E5 		ldrb	r3, [r6, #1234]	@ zero_extendqisi2
 4923 29fc 000052E3 		cmp	r2, #0
 4924 2a00 C420A003 		moveq	r2, #196
 4925 2a04 4420A013 		movne	r2, #68
 4926 2a08 032082E1 		orr	r2, r2, r3
 4927 2a0c 3010A0E3 		mov	r1, #48
 4928 2a10 5230A0E3 		mov	r3, #82
 4929 2a14 0100A0E3 		mov	r0, #1
 4930 2a18 FEFFFFEB 		bl	SensorSetIrisControl
 4931              	.LVL541:
1608:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4932              		.loc 1 1608 0
 4933 2a1c 7D0FA0E3 		mov	r0, #500
 4934 2a20 FEFFFFEB 		bl	_tx_thread_sleep
 4935              	.LVL542:
1609:../uvc.c      **** 			                         		break;
 4936              		.loc 1 1609 0
 4937 2a24 781097E5 		ldr	r1, [r7, #120]
 4938 2a28 D224D6E5 		ldrb	r2, [r6, #1234]	@ zero_extendqisi2
 4939 2a2c 000051E3 		cmp	r1, #0
 4940 2a30 C410A003 		moveq	r1, #196
 4941 2a34 4410A013 		movne	r1, #68
 4942 2a38 022081E1 		orr	r2, r1, r2
 4943 2a3c 783097E5 		ldr	r3, [r7, #120]
 4944 2a40 14141FE5 		ldr	r1, .L465+64
 4945 2a44 0400A0E3 		mov	r0, #4
 4946 2a48 FEFFFFEB 		bl	CyU3PDebugPrint
 4947              	.LVL543:
1610:../uvc.c      **** 			                         	case 4: //VGA
 4948              		.loc 1 1610 0
 4949 2a4c EEFDFFEA 		b	.L419
 4950              	.L422:
1602:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4951              		.loc 1 1602 0
 4952 2a50 782097E5 		ldr	r2, [r7, #120]
 4953 2a54 3010A0E3 		mov	r1, #48
 4954 2a58 000052E3 		cmp	r2, #0
 4955 2a5c D420A003 		moveq	r2, #212
 4956 2a60 5420A013 		movne	r2, #84
 4957 2a64 5230A0E3 		mov	r3, #82
 4958 2a68 0100A0E3 		mov	r0, #1
 4959 2a6c FEFFFFEB 		bl	SensorSetIrisControl
 4960              	.LVL544:
1603:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4961              		.loc 1 1603 0
 4962 2a70 7D0FA0E3 		mov	r0, #500
 4963 2a74 FEFFFFEB 		bl	_tx_thread_sleep
 4964              	.LVL545:
1604:../uvc.c      **** 			                         		break;
 4965              		.loc 1 1604 0
 4966 2a78 782097E5 		ldr	r2, [r7, #120]
 4967 2a7c 50141FE5 		ldr	r1, .L465+64
 4968 2a80 000052E3 		cmp	r2, #0
 4969 2a84 783097E5 		ldr	r3, [r7, #120]
 4970 2a88 D420A003 		moveq	r2, #212
 4971 2a8c 5420A013 		movne	r2, #84
 4972 2a90 0400A0E3 		mov	r0, #4
 4973 2a94 FEFFFFEB 		bl	CyU3PDebugPrint
 4974              	.LVL546:
1605:../uvc.c      **** 			                         	case 3: //720
 4975              		.loc 1 1605 0
 4976 2a98 DBFDFFEA 		b	.L419
 4977              	.L420:
1597:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4978              		.loc 1 1597 0
 4979 2a9c 782097E5 		ldr	r2, [r7, #120]
 4980 2aa0 3010A0E3 		mov	r1, #48
 4981 2aa4 000052E3 		cmp	r2, #0
 4982 2aa8 E420A003 		moveq	r2, #228
 4983 2aac 6420A013 		movne	r2, #100
 4984 2ab0 5230A0E3 		mov	r3, #82
 4985 2ab4 0100A0E3 		mov	r0, #1
 4986 2ab8 FEFFFFEB 		bl	SensorSetIrisControl
 4987              	.LVL547:
1598:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4988              		.loc 1 1598 0
 4989 2abc 7D0FA0E3 		mov	r0, #500
 4990 2ac0 FEFFFFEB 		bl	_tx_thread_sleep
 4991              	.LVL548:
1599:../uvc.c      **** 			                         		break;
 4992              		.loc 1 1599 0
 4993 2ac4 782097E5 		ldr	r2, [r7, #120]
 4994 2ac8 9C141FE5 		ldr	r1, .L465+64
 4995 2acc 000052E3 		cmp	r2, #0
 4996 2ad0 783097E5 		ldr	r3, [r7, #120]
 4997 2ad4 E420A003 		moveq	r2, #228
 4998 2ad8 6420A013 		movne	r2, #100
 4999 2adc 0400A0E3 		mov	r0, #4
 5000 2ae0 FEFFFFEB 		bl	CyU3PDebugPrint
 5001              	.LVL549:
1600:../uvc.c      **** 			                         	case 2: //1080
 5002              		.loc 1 1600 0
 5003 2ae4 C8FDFFEA 		b	.L419
 5004              	.LVL550:
 5005              	.L463:
1636:../uvc.c      **** 					 				 Data0 += 4;
 5006              		.loc 1 1636 0
 5007 2ae8 02005CE3 		cmp	ip, #2
 5008 2aec D000008A 		bhi	.L434
1637:../uvc.c      **** 					 			 }else{
 5009              		.loc 1 1637 0
 5010 2af0 04808CE2 		add	r8, ip, #4
 5011 2af4 FF8008E2 		and	r8, r8, #255
 5012              	.LVL551:
 5013 2af8 37FFFFEA 		b	.L433
 5014              	.LVL552:
 5015              	.L366:
1153:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5016              		.loc 1 1153 0
 5017 2afc 0300A0E1 		mov	r0, r3
 5018              	.LVL553:
 5019 2b00 0A10A0E1 		mov	r1, r10
 5020 2b04 FEFFFFEB 		bl	SensorGetControl
 5021              	.LVL554:
1154:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5022              		.loc 1 1154 0
 5023 2b08 844084E0 		add	r4, r4, r4, asl #1
 5024              	.LVL555:
 5025 2b0c 846186E0 		add	r6, r6, r4, asl #3
1155:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5026              		.loc 1 1155 0
 5027 2b10 8E31D6E5 		ldrb	r3, [r6, #398]	@ zero_extendqisi2
1156:../uvc.c      **** 		 	 		 }
 5028              		.loc 1 1156 0
 5029 2b14 0120A0E3 		mov	r2, #1
 5030 2b18 0340A0E1 		mov	r4, r3
1155:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5031              		.loc 1 1155 0
 5032 2b1c 2930C7E5 		strb	r3, [r7, #41]
1156:../uvc.c      **** 		 	 		 }
 5033              		.loc 1 1156 0
 5034 2b20 6021C8E5 		strb	r2, [r8, #352]
 5035 2b24 00A0A0E1 		mov	r10, r0
 5036              	.LVL556:
1154:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5037              		.loc 1 1154 0
 5038 2b28 8D01C6E5 		strb	r0, [r6, #397]
1153:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5039              		.loc 1 1153 0
 5040 2b2c 2800C7E5 		strb	r0, [r7, #40]
1162:../uvc.c      **** 			 }
 5041              		.loc 1 1162 0
 5042 2b30 F4FBFFEA 		b	.L333
 5043              	.LVL557:
 5044              	.L334:
 855:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 5045              		.loc 1 855 0
 5046 2b34 0300A0E1 		mov	r0, r3
 5047              	.LVL558:
 5048 2b38 0A10A0E1 		mov	r1, r10
 5049 2b3c FEFFFFEB 		bl	SensorGetControl
 5050              	.LVL559:
 859:../uvc.c      **** 			 	 		 }
 5051              		.loc 1 859 0
 5052 2b40 0120A0E3 		mov	r2, #1
 5053 2b44 8521C7E5 		strb	r2, [r7, #389]
 857:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5054              		.loc 1 857 0
 5055 2b48 1D05C6E5 		strb	r0, [r6, #1309]
 858:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5056              		.loc 1 858 0
 5057 2b4c 1E35D6E5 		ldrb	r3, [r6, #1310]	@ zero_extendqisi2
 859:../uvc.c      **** 			 	 		 }
 5058              		.loc 1 859 0
 5059 2b50 00A0A0E1 		mov	r10, r0
 5060              	.LVL560:
 858:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5061              		.loc 1 858 0
 5062 2b54 FF3003E2 		and	r3, r3, #255
 859:../uvc.c      **** 			 	 		 }
 5063              		.loc 1 859 0
 5064 2b58 0340A0E1 		mov	r4, r3
 5065              	.LVL561:
 858:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5066              		.loc 1 858 0
 5067 2b5c 2930C7E5 		strb	r3, [r7, #41]
 856:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5068              		.loc 1 856 0
 5069 2b60 2800C7E5 		strb	r0, [r7, #40]
 863:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 5070              		.loc 1 863 0
 5071 2b64 E7FBFFEA 		b	.L333
 5072              	.LVL562:
 5073              	.L355:
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 5074              		.loc 1 1064 0
 5075 2b68 0300A0E1 		mov	r0, r3
 5076              	.LVL563:
 5077 2b6c 0A10A0E1 		mov	r1, r10
 5078 2b70 FEFFFFEB 		bl	SensorGetControl
 5079              	.LVL564:
1068:../uvc.c      **** 		 	 		 }
 5080              		.loc 1 1068 0
 5081 2b74 0130A0E3 		mov	r3, #1
 5082 2b78 6031C7E5 		strb	r3, [r7, #352]
1065:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5083              		.loc 1 1065 0
 5084 2b7c 030000E0 		and	r0, r0, r3
1066:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 5085              		.loc 1 1066 0
 5086 2b80 7105C6E5 		strb	r0, [r6, #1393]
1067:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5087              		.loc 1 1067 0
 5088 2b84 7235D6E5 		ldrb	r3, [r6, #1394]	@ zero_extendqisi2
1068:../uvc.c      **** 		 	 		 }
 5089              		.loc 1 1068 0
 5090 2b88 00A0A0E1 		mov	r10, r0
1067:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5091              		.loc 1 1067 0
 5092 2b8c FF3003E2 		and	r3, r3, #255
1068:../uvc.c      **** 		 	 		 }
 5093              		.loc 1 1068 0
 5094 2b90 0340A0E1 		mov	r4, r3
1067:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5095              		.loc 1 1067 0
 5096 2b94 2930C7E5 		strb	r3, [r7, #41]
1065:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5097              		.loc 1 1065 0
 5098 2b98 2800C7E5 		strb	r0, [r7, #40]
 5099              	.LVL565:
1072:../uvc.c      **** 				 case ShapCtlID7:
 5100              		.loc 1 1072 0
 5101 2b9c D9FBFFEA 		b	.L333
 5102              	.LVL566:
 5103              	.L347:
1010:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 5104              		.loc 1 1010 0
 5105 2ba0 0300A0E1 		mov	r0, r3
 5106              	.LVL567:
 5107 2ba4 0A10A0E1 		mov	r1, r10
 5108 2ba8 FEFFFFEB 		bl	SensorGetControl
 5109              	.LVL568:
1012:../uvc.c      **** 		 	 		 }
 5110              		.loc 1 1012 0
 5111 2bac 0130A0E3 		mov	r3, #1
 5112 2bb0 6131C7E5 		strb	r3, [r7, #353]
1011:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5113              		.loc 1 1011 0
 5114 2bb4 A501C6E5 		strb	r0, [r6, #421]
 5115 2bb8 1FFCFFEA 		b	.L348
 5116              	.LVL569:
 5117              	.L361:
1112:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5118              		.loc 1 1112 0
 5119 2bbc 0A10A0E1 		mov	r1, r10
 5120 2bc0 0300A0E1 		mov	r0, r3
 5121              	.LVL570:
 5122 2bc4 FEFFFFEB 		bl	SensorGetControl
 5123              	.LVL571:
1115:../uvc.c      **** 
 5124              		.loc 1 1115 0
 5125 2bc8 6632D6E5 		ldrb	r3, [r6, #614]	@ zero_extendqisi2
1117:../uvc.c      **** 		 	 		 }
 5126              		.loc 1 1117 0
 5127 2bcc 0110A0E3 		mov	r1, #1
 5128 2bd0 0340A0E1 		mov	r4, r3
1115:../uvc.c      **** 
 5129              		.loc 1 1115 0
 5130 2bd4 2930C7E5 		strb	r3, [r7, #41]
1117:../uvc.c      **** 		 	 		 }
 5131              		.loc 1 1117 0
 5132 2bd8 6911C7E5 		strb	r1, [r7, #361]
1114:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5133              		.loc 1 1114 0
 5134 2bdc 032000E2 		and	r2, r0, #3
1117:../uvc.c      **** 		 	 		 }
 5135              		.loc 1 1117 0
 5136 2be0 02A0A0E1 		mov	r10, r2
 5137              	.LVL572:
1113:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 5138              		.loc 1 1113 0
 5139 2be4 6502C6E5 		strb	r0, [r6, #613]
1114:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5140              		.loc 1 1114 0
 5141 2be8 2820C7E5 		strb	r2, [r7, #40]
1121:../uvc.c      **** 				 case MFreqCtlID4:
 5142              		.loc 1 1121 0
 5143 2bec C5FBFFEA 		b	.L333
 5144              	.LVL573:
 5145              	.L363:
1134:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 5146              		.loc 1 1134 0
 5147 2bf0 0A10A0E1 		mov	r1, r10
 5148 2bf4 0100A0E3 		mov	r0, #1
 5149              	.LVL574:
 5150 2bf8 FEFFFFEB 		bl	SensorGetControl
 5151              	.LVL575:
1138:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5152              		.loc 1 1138 0
 5153 2bfc EE31D6E5 		ldrb	r3, [r6, #494]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 		 }
 5154              		.loc 1 1139 0
 5155 2c00 0120A0E3 		mov	r2, #1
 5156 2c04 0340A0E1 		mov	r4, r3
1138:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5157              		.loc 1 1138 0
 5158 2c08 2930C7E5 		strb	r3, [r7, #41]
1139:../uvc.c      **** 		 	 		 }
 5159              		.loc 1 1139 0
 5160 2c0c 6421C7E5 		strb	r2, [r7, #356]
1135:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 5161              		.loc 1 1135 0
 5162 2c10 A003A0E1 		mov	r0, r0, lsr #7
 5163              	.LVL576:
1136:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5164              		.loc 1 1136 0
 5165 2c14 023080E0 		add	r3, r0, r2
 5166 2c18 FF3003E2 		and	r3, r3, #255
 5167 2c1c 03A0A0E1 		mov	r10, r3
 5168 2c20 2830C7E5 		strb	r3, [r7, #40]
1137:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5169              		.loc 1 1137 0
 5170 2c24 ED31C6E5 		strb	r3, [r6, #493]
 5171              	.LVL577:
1144:../uvc.c      **** 				 case SaturCtlID6:
 5172              		.loc 1 1144 0
 5173 2c28 B6FBFFEA 		b	.L333
 5174              	.LVL578:
 5175              	.L340:
 923:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5176              		.loc 1 923 0
 5177 2c2c FEFFFFEB 		bl	SensorGetControl
 5178              	.LVL579:
 926:../uvc.c      **** 		 	 		 }
 5179              		.loc 1 926 0
 5180 2c30 0120A0E3 		mov	r2, #1
 5181 2c34 7B21C7E5 		strb	r2, [r7, #379]
 924:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5182              		.loc 1 924 0
 5183 2c38 4505C4E5 		strb	r0, [r4, #1349]
 925:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5184              		.loc 1 925 0
 5185 2c3c 4635D4E5 		ldrb	r3, [r4, #1350]	@ zero_extendqisi2
 926:../uvc.c      **** 		 	 		 }
 5186              		.loc 1 926 0
 5187 2c40 00A0A0E1 		mov	r10, r0
 5188              	.LVL580:
 925:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5189              		.loc 1 925 0
 5190 2c44 FF3003E2 		and	r3, r3, #255
 926:../uvc.c      **** 		 	 		 }
 5191              		.loc 1 926 0
 5192 2c48 0340A0E1 		mov	r4, r3
 5193              	.LVL581:
 925:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5194              		.loc 1 925 0
 5195 2c4c 2930C7E5 		strb	r3, [r7, #41]
 923:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5196              		.loc 1 923 0
 5197 2c50 2800C7E5 		strb	r0, [r7, #40]
 930:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 5198              		.loc 1 930 0
 5199 2c54 ABFBFFEA 		b	.L333
 5200              	.LVL582:
 5201              	.L359:
1098:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 5202              		.loc 1 1098 0
 5203 2c58 0300A0E1 		mov	r0, r3
 5204              	.LVL583:
 5205 2c5c 0A10A0E1 		mov	r1, r10
 5206 2c60 FEFFFFEB 		bl	SensorGetControl
 5207              	.LVL584:
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5208              		.loc 1 1100 0
 5209 2c64 BE31D6E5 		ldrb	r3, [r6, #446]	@ zero_extendqisi2
1101:../uvc.c      **** 		 	 		 }
 5210              		.loc 1 1101 0
 5211 2c68 0120A0E3 		mov	r2, #1
 5212 2c6c 0340A0E1 		mov	r4, r3
 5213              	.LVL585:
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5214              		.loc 1 1100 0
 5215 2c70 2930C7E5 		strb	r3, [r7, #41]
1101:../uvc.c      **** 		 	 		 }
 5216              		.loc 1 1101 0
 5217 2c74 6021C8E5 		strb	r2, [r8, #352]
 5218 2c78 00A0A0E1 		mov	r10, r0
 5219              	.LVL586:
1098:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 5220              		.loc 1 1098 0
 5221 2c7c 2800C7E5 		strb	r0, [r7, #40]
1099:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 5222              		.loc 1 1099 0
 5223 2c80 BD01C6E5 		strb	r0, [r6, #445]
1105:../uvc.c      **** 				 case WBTMdCtlID9:
 5224              		.loc 1 1105 0
 5225 2c84 9FFBFFEA 		b	.L333
 5226              	.LVL587:
 5227              	.L338:
 898:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 5228              		.loc 1 898 0
 5229 2c88 FEFFFFEB 		bl	SensorGetControl
 5230              	.LVL588:
 904:../uvc.c      **** 
 5231              		.loc 1 904 0
 5232 2c8c 5C161FE5 		ldr	r1, .L465+68
 899:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 5233              		.loc 1 899 0
 5234 2c90 3105C6E5 		strb	r0, [r6, #1329]
 900:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5235              		.loc 1 900 0
 5236 2c94 707000E2 		and	r7, r0, #112
 902:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 5237              		.loc 1 902 0
 5238 2c98 32C5D6E5 		ldrb	ip, [r6, #1330]	@ zero_extendqisi2
 900:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5239              		.loc 1 900 0
 5240 2c9c 4772A0E1 		mov	r7, r7, asr #4
 904:../uvc.c      **** 
 5241              		.loc 1 904 0
 5242 2ca0 0720A0E1 		mov	r2, r7
 900:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5243              		.loc 1 900 0
 5244 2ca4 FF7007E2 		and	r7, r7, #255
 5245              	.LVL589:
 904:../uvc.c      **** 
 5246              		.loc 1 904 0
 5247 2ca8 00008DE5 		str	r0, [sp]
 5248 2cac 0230A0E1 		mov	r3, r2
 5249 2cb0 0400A0E3 		mov	r0, #4
 5250              	.LVL590:
 902:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 5251              		.loc 1 902 0
 5252 2cb4 29C0C4E5 		strb	ip, [r4, #41]
 901:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5253              		.loc 1 901 0
 5254 2cb8 2870C4E5 		strb	r7, [r4, #40]
 904:../uvc.c      **** 
 5255              		.loc 1 904 0
 5256 2cbc FEFFFFEB 		bl	CyU3PDebugPrint
 5257              	.LVL591:
 5258 2cc0 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 5259 2cc4 47FCFFEA 		b	.L339
 5260              	.LVL592:
 5261              	.L345:
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 5262              		.loc 1 973 0
 5263 2cc8 0410A0E1 		mov	r1, r4
 5264 2ccc FEFFFFEB 		bl	SensorGetControl
 5265              	.LVL593:
 977:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5266              		.loc 1 977 0
 5267 2cd0 0410A0E1 		mov	r1, r4
 974:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5268              		.loc 1 974 0
 5269 2cd4 033000E2 		and	r3, r0, #3
 977:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5270              		.loc 1 977 0
 5271 2cd8 0800A0E1 		mov	r0, r8
 974:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5272              		.loc 1 974 0
 5273 2cdc 2830C7E5 		strb	r3, [r7, #40]
 975:../uvc.c      **** 
 5274              		.loc 1 975 0
 5275 2ce0 5935C6E5 		strb	r3, [r6, #1369]
 977:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5276              		.loc 1 977 0
 5277 2ce4 FEFFFFEB 		bl	SensorGetControl
 5278              	.LVL594:
 979:../uvc.c      **** 		 	 		 }
 5279              		.loc 1 979 0
 5280 2ce8 0130A0E3 		mov	r3, #1
 5281 2cec 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5282 2cf0 7931C7E5 		strb	r3, [r7, #377]
 5283 2cf4 0040A0E1 		mov	r4, r0
 5284              	.LVL595:
 977:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5285              		.loc 1 977 0
 5286 2cf8 2A00C7E5 		strb	r0, [r7, #42]
 978:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5287              		.loc 1 978 0
 5288 2cfc 5A05C6E5 		strb	r0, [r6, #1370]
 5289 2d00 E3FBFFEA 		b	.L346
 5290              	.LVL596:
 5291              	.L353:
1046:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 5292              		.loc 1 1046 0
 5293 2d04 0300A0E1 		mov	r0, r3
 5294              	.LVL597:
 5295 2d08 0A10A0E1 		mov	r1, r10
 5296 2d0c FEFFFFEB 		bl	SensorGetControl
 5297              	.LVL598:
1047:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 5298              		.loc 1 1047 0
 5299 2d10 0A10A0E1 		mov	r1, r10
1046:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 5300              		.loc 1 1046 0
 5301 2d14 0080A0E1 		mov	r8, r0
 5302              	.LVL599:
1047:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 5303              		.loc 1 1047 0
 5304 2d18 0B00A0E1 		mov	r0, fp
 5305              	.LVL600:
 5306 2d1c FEFFFFEB 		bl	SensorGetControl
 5307              	.LVL601:
1052:../uvc.c      **** 		 	 		 }
 5308              		.loc 1 1052 0
 5309 2d20 0130A0E3 		mov	r3, #1
 5310 2d24 08A0A0E1 		mov	r10, r8
1048:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 5311              		.loc 1 1048 0
 5312 2d28 2880C7E5 		strb	r8, [r7, #40]
1049:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 5313              		.loc 1 1049 0
 5314 2d2c 6085C6E5 		strb	r8, [r6, #1376]
1052:../uvc.c      **** 		 	 		 }
 5315              		.loc 1 1052 0
 5316 2d30 6B31C7E5 		strb	r3, [r7, #363]
 5317 2d34 0040A0E1 		mov	r4, r0
 5318              	.LVL602:
1050:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 5319              		.loc 1 1050 0
 5320 2d38 2A00C7E5 		strb	r0, [r7, #42]
1051:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5321              		.loc 1 1051 0
 5322 2d3c 6205C6E5 		strb	r0, [r6, #1378]
 5323 2d40 B4FBFFEA 		b	.L354
 5324              	.LVL603:
 5325              	.L357:
1081:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5326              		.loc 1 1081 0
 5327 2d44 0A10A0E1 		mov	r1, r10
 5328 2d48 0B00A0E1 		mov	r0, fp
 5329              	.LVL604:
 5330 2d4c FEFFFFEB 		bl	SensorGetControl
 5331              	.LVL605:
1084:../uvc.c      **** 		 	 		 }
 5332              		.loc 1 1084 0
 5333 2d50 0120A0E3 		mov	r2, #1
 5334 2d54 6721C7E5 		strb	r2, [r7, #359]
1082:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 5335              		.loc 1 1082 0
 5336 2d58 8505C6E5 		strb	r0, [r6, #1413]
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5337              		.loc 1 1083 0
 5338 2d5c 8635D6E5 		ldrb	r3, [r6, #1414]	@ zero_extendqisi2
1084:../uvc.c      **** 		 	 		 }
 5339              		.loc 1 1084 0
 5340 2d60 00A0A0E1 		mov	r10, r0
 5341              	.LVL606:
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5342              		.loc 1 1083 0
 5343 2d64 FF3003E2 		and	r3, r3, #255
1084:../uvc.c      **** 		 	 		 }
 5344              		.loc 1 1084 0
 5345 2d68 0340A0E1 		mov	r4, r3
 5346              	.LVL607:
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5347              		.loc 1 1083 0
 5348 2d6c 2930C7E5 		strb	r3, [r7, #41]
1081:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5349              		.loc 1 1081 0
 5350 2d70 2800C7E5 		strb	r0, [r7, #40]
1088:../uvc.c      **** 				 case ExtExRefCtlID10:
 5351              		.loc 1 1088 0
 5352 2d74 63FBFFEA 		b	.L333
 5353              	.LVL608:
 5354              	.L351:
1028:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 5355              		.loc 1 1028 0
 5356 2d78 0300A0E1 		mov	r0, r3
 5357              	.LVL609:
 5358 2d7c 0A10A0E1 		mov	r1, r10
 5359 2d80 FEFFFFEB 		bl	SensorGetControl
 5360              	.LVL610:
1030:../uvc.c      **** 		 	 		 }
 5361              		.loc 1 1030 0
 5362 2d84 0130A0E3 		mov	r3, #1
 5363 2d88 6531C7E5 		strb	r3, [r7, #357]
1029:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5364              		.loc 1 1029 0
 5365 2d8c 0502C6E5 		strb	r0, [r6, #517]
 5366 2d90 21FCFFEA 		b	.L352
 5367              	.LVL611:
 5368              	.L460:
 935:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 5369              		.loc 1 935 0
 5370 2d94 02005AE3 		cmp	r10, #2
 5371 2d98 1D00008A 		bhi	.L464
 5372              	.LVL612:
 5373              	.L343:
 940:../uvc.c      **** 					 }
 5374              		.loc 1 940 0
 5375 2d9c 04A08AE2 		add	r10, r10, #4
 5376              	.LVL613:
 5377 2da0 FFA00AE2 		and	r10, r10, #255
 5378              	.LVL614:
 5379 2da4 82FBFFEA 		b	.L453
 5380              	.LVL615:
 5381              	.L410:
1376:../uvc.c      **** 									 dataIdx++;
 5382              		.loc 1 1376 0
 5383 2da8 8010A0E3 		mov	r1, #128
 5384 2dac 0030A0E3 		mov	r3, #0
 5385 2db0 0A008DE8 		stmia	sp, {r1, r3}
 5386 2db4 80071FE5 		ldr	r0, .L465+72
 5387 2db8 0920A0E1 		mov	r2, r9
 5388 2dbc 0730A0E1 		mov	r3, r7
 5389 2dc0 1B10A0E3 		mov	r1, #27
 5390 2dc4 FEFFFFEB 		bl	cmdSet
 5391              	.LVL616:
1378:../uvc.c      **** 								 }
 5392              		.loc 1 1378 0
 5393 2dc8 18C09DE5 		ldr	ip, [sp, #24]
 5394 2dcc 0110A0E3 		mov	r1, #1
 5395 2dd0 04108DE5 		str	r1, [sp, #4]
 5396 2dd4 00C08DE5 		str	ip, [sp]
 5397 2dd8 0820A0E1 		mov	r2, r8
 5398 2ddc 0730A0E1 		mov	r3, r7
 5399 2de0 1B10A0E3 		mov	r1, #27
 5400 2de4 B0071FE5 		ldr	r0, .L465+72
 5401 2de8 FEFFFFEB 		bl	cmdSet
 5402              	.LVL617:
 5403 2dec 2AFEFFEA 		b	.L409
 5404              	.LVL618:
 5405              	.L462:
1351:../uvc.c      **** 								 }
 5406              		.loc 1 1351 0
 5407 2df0 0010A0E3 		mov	r1, #0
 5408 2df4 04108DE5 		str	r1, [sp, #4]
 5409 2df8 00C08DE5 		str	ip, [sp]
 5410 2dfc 0A20A0E1 		mov	r2, r10
 5411 2e00 0830A0E1 		mov	r3, r8
 5412 2e04 1910A0E3 		mov	r1, #25
 5413 2e08 D4071FE5 		ldr	r0, .L465+72
 5414 2e0c FEFFFFEB 		bl	cmdSet
 5415              	.LVL619:
 5416 2e10 46FDFFEA 		b	.L406
 5417              	.LVL620:
 5418              	.L464:
 936:../uvc.c      **** 							sendData = 0; //set back to default
 5419              		.loc 1 936 0
 5420 2e14 0A30A0E1 		mov	r3, r10
 5421 2e18 0400A0E3 		mov	r0, #4
 5422              	.LVL621:
 5423 2e1c E4171FE5 		ldr	r1, .L465+76
 5424 2e20 FEFFFFEB 		bl	CyU3PDebugPrint
 5425              	.LVL622:
 938:../uvc.c      **** 						}
 5426              		.loc 1 938 0
 5427 2e24 0030A0E3 		mov	r3, #0
 937:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 5428              		.loc 1 937 0
 5429 2e28 03A0A0E1 		mov	r10, r3
 938:../uvc.c      **** 						}
 5430              		.loc 1 938 0
 5431 2e2c 2D34C4E5 		strb	r3, [r4, #1069]
 5432 2e30 D9FFFFEA 		b	.L343
 5433              	.LVL623:
 5434              	.L434:
1639:../uvc.c      **** 									Data0 = 4; //set to default.
 5435              		.loc 1 1639 0
 5436 2e34 0400A0E3 		mov	r0, #4
 5437 2e38 00181FE5 		ldr	r1, .L465+76
 5438 2e3c 18309DE5 		ldr	r3, [sp, #24]
 5439 2e40 FEFFFFEB 		bl	CyU3PDebugPrint
 5440              	.LVL624:
1640:../uvc.c      **** 					 			 }
 5441              		.loc 1 1640 0
 5442 2e44 0480A0E3 		mov	r8, #4
 5443 2e48 63FEFFEA 		b	.L433
 5444              		.cfi_endproc
 5445              	.LFE3:
 5447              		.align	2
 5448              		.global	CTControlHandle
 5450              	CTControlHandle:
 5451              	.LFB4:
1715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5452              		.loc 1 1715 0
 5453              		.cfi_startproc
 5454              		@ args = 0, pretend = 0, frame = 24
 5455              		@ frame_needed = 0, uses_anonymous_args = 0
 5456              	.LVL625:
 5457 2e4c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5458              	.LCFI19:
 5459              		.cfi_def_cfa_offset 36
 5460              		.cfi_offset 4, -36
 5461              		.cfi_offset 5, -32
 5462              		.cfi_offset 6, -28
 5463              		.cfi_offset 7, -24
 5464              		.cfi_offset 8, -20
 5465              		.cfi_offset 9, -16
 5466              		.cfi_offset 10, -12
 5467              		.cfi_offset 11, -8
 5468              		.cfi_offset 14, -4
1734:../uvc.c      **** 
 5469              		.loc 1 1734 0
 5470 2e50 28B89FE5 		ldr	fp, .L505
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5471              		.loc 1 1726 0
 5472 2e54 28389FE5 		ldr	r3, .L505+4
1734:../uvc.c      **** 
 5473              		.loc 1 1734 0
 5474 2e58 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5475              		.loc 1 1726 0
 5476 2e5c 8080A0E1 		mov	r8, r0, asl #1
 5477 2e60 002088E0 		add	r2, r8, r0
 5478 2e64 822183E0 		add	r2, r3, r2, asl #3
1736:../uvc.c      **** 		 {
 5479              		.loc 1 1736 0
 5480 2e68 830055E3 		cmp	r5, #131
1715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5481              		.loc 1 1715 0
 5482 2e6c 34D04DE2 		sub	sp, sp, #52
 5483              	.LCFI20:
 5484              		.cfi_def_cfa_offset 88
1715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5485              		.loc 1 1715 0
 5486 2e70 0060A0E1 		mov	r6, r0
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5487              		.loc 1 1726 0
 5488 2e74 9B95D2E5 		ldrb	r9, [r2, #1435]	@ zero_extendqisi2
 5489              	.LVL626:
1727:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5490              		.loc 1 1727 0
 5491 2e78 8CA5D2E5 		ldrb	r10, [r2, #1420]	@ zero_extendqisi2
 5492              	.LVL627:
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5493              		.loc 1 1729 0
 5494 2e7c 8E75D2E5 		ldrb	r7, [r2, #1422]	@ zero_extendqisi2
 5495              	.LVL628:
1736:../uvc.c      **** 		 {
 5496              		.loc 1 1736 0
 5497 2e80 8000000A 		beq	.L469
 5498 2e84 2600009A 		bls	.L503
 5499 2e88 850055E3 		cmp	r5, #133
 5500 2e8c 7200000A 		beq	.L474
 5501 2e90 5000003A 		bcc	.L475
 5502 2e94 860055E3 		cmp	r5, #134
 5503 2e98 4300000A 		beq	.L476
 5504 2e9c 870055E3 		cmp	r5, #135
 5505 2ea0 5F00001A 		bne	.L468
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5506              		.loc 1 1798 0
 5507 2ea4 97C5D2E5 		ldrb	ip, [r2, #1431]	@ zero_extendqisi2
 5508 2ea8 D8479FE5 		ldr	r4, .L505+8
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5509              		.loc 1 1799 0
 5510 2eac 9825D2E5 		ldrb	r2, [r2, #1432]	@ zero_extendqisi2
 5511              	.LVL629:
 5512              	.L502:
1776:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5513              		.loc 1 1776 0
 5514 2eb0 0A1056E2 		subs	r1, r6, #10
 5515 2eb4 006071E2 		rsbs	r6, r1, #0
 5516 2eb8 0160B6E0 		adcs	r6, r6, r1
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5517              		.loc 1 1778 0
 5518 2ebc 0030A0E3 		mov	r3, #0
 5519              	.LVL630:
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5520              		.loc 1 1779 0
 5521 2ec0 281084E2 		add	r1, r4, #40
 5522 2ec4 0700A0E1 		mov	r0, r7
 5523              	.LVL631:
1776:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5524              		.loc 1 1776 0
 5525 2ec8 2A60C4E5 		strb	r6, [r4, #42]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5526              		.loc 1 1774 0
 5527 2ecc 28C0C4E5 		strb	ip, [r4, #40]
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5528              		.loc 1 1775 0
 5529 2ed0 2920C4E5 		strb	r2, [r4, #41]
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5530              		.loc 1 1778 0
 5531 2ed4 2B30C4E5 		strb	r3, [r4, #43]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5532              		.loc 1 1779 0
 5533 2ed8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5534              	.LVL632:
 5535 2edc 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
1781:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 5536              		.loc 1 1781 0
 5537 2ee0 FF80A0E3 		mov	r8, #255
 5538 2ee4 0860A0E1 		mov	r6, r8
 5539              	.LVL633:
 5540              	.L478:
1949:../uvc.c      **** }
 5541              		.loc 1 1949 0
 5542 2ee8 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5543 2eec FFC0A0E3 		mov	ip, #255
 5544 2ef0 04108DE5 		str	r1, [sp, #4]
 5545 2ef4 10108DE5 		str	r1, [sp, #16]
 5546 2ef8 08008DE5 		str	r0, [sp, #8]
 5547 2efc 00808DE5 		str	r8, [sp]
 5548 2f00 14708DE5 		str	r7, [sp, #20]
 5549 2f04 0520A0E1 		mov	r2, r5
 5550 2f08 0630A0E1 		mov	r3, r6
 5551 2f0c 0CC08DE5 		str	ip, [sp, #12]
 5552 2f10 74179FE5 		ldr	r1, .L505+12
 5553 2f14 0400A0E3 		mov	r0, #4
 5554 2f18 FEFFFFEB 		bl	CyU3PDebugPrint
 5555              	.LVL634:
1950:../uvc.c      **** 
 5556              		.loc 1 1950 0
 5557 2f1c 34D08DE2 		add	sp, sp, #52
 5558              		@ sp needed
 5559 2f20 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5560              	.LVL635:
 5561              	.L503:
1736:../uvc.c      **** 		 {
 5562              		.loc 1 1736 0
 5563 2f24 810055E3 		cmp	r5, #129
 5564 2f28 2E00000A 		beq	.L471
 5565 2f2c 1A00008A 		bhi	.L472
 5566 2f30 010055E3 		cmp	r5, #1
 5567 2f34 3A00001A 		bne	.L468
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 5568              		.loc 1 1807 0
 5569 2f38 48479FE5 		ldr	r4, .L505+8
 5570 2f3c 2E208DE2 		add	r2, sp, #46
 5571              	.LVL636:
 5572 2f40 2000A0E3 		mov	r0, #32
 5573              	.LVL637:
 5574 2f44 281084E2 		add	r1, r4, #40
 5575 2f48 18308DE5 		str	r3, [sp, #24]
 5576 2f4c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5577              	.LVL638:
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5578              		.loc 1 1809 0
 5579 2f50 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
1813:../uvc.c      **** 			  {
 5580              		.loc 1 1813 0
 5581 2f54 012046E2 		sub	r2, r6, #1
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5582              		.loc 1 1809 0
 5583 2f58 1CC08DE5 		str	ip, [sp, #28]
 5584              	.LVL639:
1810:../uvc.c      **** 			  value = Data1;
 5585              		.loc 1 1810 0
 5586 2f5c 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
1813:../uvc.c      **** 			  {
 5587              		.loc 1 1813 0
 5588 2f60 18309DE5 		ldr	r3, [sp, #24]
1810:../uvc.c      **** 			  value = Data1;
 5589              		.loc 1 1810 0
 5590 2f64 20C08DE5 		str	ip, [sp, #32]
 5591              	.LVL640:
1813:../uvc.c      **** 			  {
 5592              		.loc 1 1813 0
 5593 2f68 090052E3 		cmp	r2, #9
 5594 2f6c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5595 2f70 1D0100EA 		b	.L479
 5596              	.L481:
 5597 2f74 A4330000 		.word	.L480
 5598 2f78 EC330000 		.word	.L479
 5599 2f7c A4310000 		.word	.L482
 5600 2f80 EC330000 		.word	.L479
 5601 2f84 EC330000 		.word	.L479
 5602 2f88 EC330000 		.word	.L479
 5603 2f8c 14310000 		.word	.L483
 5604 2f90 EC330000 		.word	.L479
 5605 2f94 EC330000 		.word	.L479
 5606 2f98 98300000 		.word	.L484
 5607              	.LVL641:
 5608              	.L472:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 5609              		.loc 1 1765 0
 5610 2f9c 8FC5D2E5 		ldrb	ip, [r2, #1423]	@ zero_extendqisi2
 5611 2fa0 E0469FE5 		ldr	r4, .L505+8
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 5612              		.loc 1 1766 0
 5613 2fa4 9025D2E5 		ldrb	r2, [r2, #1424]	@ zero_extendqisi2
 5614              	.LVL642:
 5615 2fa8 C0FFFFEA 		b	.L502
 5616              	.LVL643:
 5617              	.L476:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5618              		.loc 1 1792 0
 5619 2fac D4469FE5 		ldr	r4, .L505+8
 5620 2fb0 9535D2E5 		ldrb	r3, [r2, #1429]	@ zero_extendqisi2
 5621 2fb4 0410A0E1 		mov	r1, r4
 5622 2fb8 2830E1E5 		strb	r3, [r1, #40]!
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5623              		.loc 1 1793 0
 5624 2fbc 0100A0E3 		mov	r0, #1
 5625              	.LVL644:
1796:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5626              		.loc 1 1796 0
 5627 2fc0 FF80A0E3 		mov	r8, #255
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5628              		.loc 1 1793 0
 5629 2fc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5630              	.LVL645:
1796:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5631              		.loc 1 1796 0
 5632 2fc8 0860A0E1 		mov	r6, r8
 5633 2fcc 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 5634 2fd0 0170A0E3 		mov	r7, #1
 5635 2fd4 C3FFFFEA 		b	.L478
 5636              	.LVL646:
 5637              	.L475:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 5638              		.loc 1 1783 0
 5639 2fd8 93C5D2E5 		ldrb	ip, [r2, #1427]	@ zero_extendqisi2
 5640 2fdc A4469FE5 		ldr	r4, .L505+8
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5641              		.loc 1 1784 0
 5642 2fe0 9425D2E5 		ldrb	r2, [r2, #1428]	@ zero_extendqisi2
 5643              	.LVL647:
 5644 2fe4 B1FFFFEA 		b	.L502
 5645              	.LVL648:
 5646              	.L471:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5647              		.loc 1 1750 0
 5648 2fe8 98469FE5 		ldr	r4, .L505+8
 5649 2fec 9995D2E5 		ldrb	r9, [r2, #1433]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5650              		.loc 1 1751 0
 5651 2ff0 9AC5D2E5 		ldrb	ip, [r2, #1434]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5652              		.loc 1 1752 0
 5653 2ff4 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 5654              		.loc 1 1758 0
 5655 2ff8 281084E2 		add	r1, r4, #40
 5656 2ffc 0700A0E1 		mov	r0, r7
 5657              	.LVL649:
1763:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5658              		.loc 1 1763 0
 5659 3000 FF80A0E3 		mov	r8, #255
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5660              		.loc 1 1751 0
 5661 3004 29C0C4E5 		strb	ip, [r4, #41]
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5662              		.loc 1 1750 0
 5663 3008 2890C4E5 		strb	r9, [r4, #40]
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5664              		.loc 1 1752 0
 5665 300c 2A30C4E5 		strb	r3, [r4, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 5666              		.loc 1 1753 0
 5667 3010 2B30C4E5 		strb	r3, [r4, #43]
 5668              	.LVL650:
1763:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5669              		.loc 1 1763 0
 5670 3014 0860A0E1 		mov	r6, r8
 5671              	.LVL651:
1758:../uvc.c      **** 
 5672              		.loc 1 1758 0
 5673 3018 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5674              	.LVL652:
 5675 301c 0900A0E1 		mov	r0, r9
1763:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5676              		.loc 1 1763 0
 5677 3020 B0FFFFEA 		b	.L478
 5678              	.LVL653:
 5679              	.L468:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5680              		.loc 1 1943 0
 5681 3024 0000A0E3 		mov	r0, #0
 5682              	.LVL654:
 5683 3028 0020A0E1 		mov	r2, r0
 5684              	.LVL655:
 5685 302c 0110A0E3 		mov	r1, #1
 5686 3030 FEFFFFEB 		bl	CyU3PUsbStall
 5687              	.LVL656:
1944:../uvc.c      **** 			  break;
 5688              		.loc 1 1944 0
 5689 3034 0620A0E1 		mov	r2, r6
 5690 3038 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5691 303c 0400A0E3 		mov	r0, #4
 5692 3040 48169FE5 		ldr	r1, .L505+16
 5693 3044 FEFFFFEB 		bl	CyU3PDebugPrint
 5694              	.LVL657:
1945:../uvc.c      **** 		 }
 5695              		.loc 1 1945 0
 5696 3048 FF00A0E3 		mov	r0, #255
 5697 304c 34469FE5 		ldr	r4, .L505+8
 5698 3050 0080A0E1 		mov	r8, r0
 5699 3054 0060A0E1 		mov	r6, r0
 5700 3058 A2FFFFEA 		b	.L478
 5701              	.LVL658:
 5702              	.L474:
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5703              		.loc 1 1740 0
 5704 305c 24469FE5 		ldr	r4, .L505+8
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5705              		.loc 1 1741 0
 5706 3060 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5707              		.loc 1 1742 0
 5708 3064 281084E2 		add	r1, r4, #40
 5709 3068 0200A0E3 		mov	r0, #2
 5710              	.LVL659:
1744:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5711              		.loc 1 1744 0
 5712 306c FF80A0E3 		mov	r8, #255
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5713              		.loc 1 1740 0
 5714 3070 2870C4E5 		strb	r7, [r4, #40]
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5715              		.loc 1 1741 0
 5716 3074 2930C4E5 		strb	r3, [r4, #41]
1744:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5717              		.loc 1 1744 0
 5718 3078 0860A0E1 		mov	r6, r8
 5719              	.LVL660:
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5720              		.loc 1 1742 0
 5721 307c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5722              	.LVL661:
 5723 3080 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
1744:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5724              		.loc 1 1744 0
 5725 3084 97FFFFEA 		b	.L478
 5726              	.LVL662:
 5727              	.L469:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5728              		.loc 1 1774 0
 5729 3088 91C5D2E5 		ldrb	ip, [r2, #1425]	@ zero_extendqisi2
 5730 308c F4459FE5 		ldr	r4, .L505+8
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5731              		.loc 1 1775 0
 5732 3090 9225D2E5 		ldrb	r2, [r2, #1426]	@ zero_extendqisi2
 5733              	.LVL663:
 5734 3094 85FFFFEA 		b	.L502
 5735              	.LVL664:
 5736              	.L484:
1922:../uvc.c      **** 					  if(getData == 1)
 5737              		.loc 1 1922 0
 5738 3098 F4659FE5 		ldr	r6, .L505+20
 5739 309c 0010E0E3 		mvn	r1, #0
 5740 30a0 1C0096E5 		ldr	r0, [r6, #28]
 5741 30a4 FEFFFFEB 		bl	_txe_mutex_get
 5742              	.LVL665:
1923:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5743              		.loc 1 1923 0
 5744 30a8 1CC09DE5 		ldr	ip, [sp, #28]
 5745 30ac 01005CE3 		cmp	ip, #1
1924:../uvc.c      **** 					  else if(getData == 0xff)
 5746              		.loc 1 1924 0
 5747 30b0 0400A003 		moveq	r0, #4
1923:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5748              		.loc 1 1923 0
 5749 30b4 6901000A 		beq	.L501
1925:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5750              		.loc 1 1925 0
 5751 30b8 FF005CE3 		cmp	ip, #255
 5752 30bc 6601000A 		beq	.L504
1928:../uvc.c      **** 					  //dataIdx++;
 5753              		.loc 1 1928 0
 5754 30c0 0010A0E3 		mov	r1, #0
 5755 30c4 00108DE5 		str	r1, [sp]
 5756 30c8 04108DE5 		str	r1, [sp, #4]
 5757 30cc 0A20A0E1 		mov	r2, r10
 5758 30d0 0930A0E1 		mov	r3, r9
 5759 30d4 0600A0E1 		mov	r0, r6
 5760 30d8 2310A0E3 		mov	r1, #35
 5761 30dc FEFFFFEB 		bl	cmdSet
 5762              	.LVL666:
 5763              	.L496:
1931:../uvc.c      **** #endif
 5764              		.loc 1 1931 0
 5765 30e0 1C0096E5 		ldr	r0, [r6, #28]
 5766 30e4 FEFFFFEB 		bl	_txe_mutex_put
 5767              	.LVL667:
1933:../uvc.c      **** 					  break;
 5768              		.loc 1 1933 0
 5769 30e8 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5770 30ec 1C609DE5 		ldr	r6, [sp, #28]
 5771 30f0 20809DE5 		ldr	r8, [sp, #32]
 5772 30f4 00108DE5 		str	r1, [sp]
 5773 30f8 0620A0E1 		mov	r2, r6
 5774 30fc 0830A0E1 		mov	r3, r8
 5775 3100 0400A0E3 		mov	r0, #4
 5776 3104 8C159FE5 		ldr	r1, .L505+24
 5777 3108 FEFFFFEB 		bl	CyU3PDebugPrint
 5778              	.LVL668:
1934:../uvc.c      **** 
 5779              		.loc 1 1934 0
 5780 310c FF00A0E3 		mov	r0, #255
 5781 3110 74FFFFEA 		b	.L478
 5782              	.LVL669:
 5783              	.L483:
1899:../uvc.c      **** 					  {
 5784              		.loc 1 1899 0
 5785 3114 B105D3E5 		ldrb	r0, [r3, #1457]	@ zero_extendqisi2
 5786 3118 64C59FE5 		ldr	ip, .L505+4
 5787 311c 010050E3 		cmp	r0, #1
 5788 3120 08005013 		cmpne	r0, #8
 5789 3124 0000A013 		movne	r0, #0
 5790 3128 0100A003 		moveq	r0, #1
 5791 312c 4601001A 		bne	.L493
 5792              	.LVL670:
1902:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5793              		.loc 1 1902 0
 5794 3130 5CB59FE5 		ldr	fp, .L505+20
 5795 3134 0010E0E3 		mvn	r1, #0
 5796 3138 1C009BE5 		ldr	r0, [fp, #28]
 5797 313c 18C08DE5 		str	ip, [sp, #24]
 5798 3140 FEFFFFEB 		bl	_txe_mutex_get
 5799              	.LVL671:
1903:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5800              		.loc 1 1903 0
 5801 3144 1C009DE5 		ldr	r0, [sp, #28]
 5802 3148 0010A0E3 		mov	r1, #0
 5803 314c 0A20A0E1 		mov	r2, r10
 5804 3150 0930A0E1 		mov	r3, r9
 5805 3154 00008DE5 		str	r0, [sp]
 5806 3158 04108DE5 		str	r1, [sp, #4]
 5807 315c 0B00A0E1 		mov	r0, fp
 5808 3160 2210A0E3 		mov	r1, #34
 5809 3164 FEFFFFEB 		bl	cmdSet
 5810              	.LVL672:
1904:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5811              		.loc 1 1904 0
 5812 3168 1C009BE5 		ldr	r0, [fp, #28]
 5813 316c FEFFFFEB 		bl	_txe_mutex_put
 5814              	.LVL673:
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5815              		.loc 1 1907 0
 5816 3170 18C09DE5 		ldr	ip, [sp, #24]
 5817 3174 1C109DE5 		ldr	r1, [sp, #28]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5818              		.loc 1 1908 0
 5819 3178 20209DE5 		ldr	r2, [sp, #32]
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5820              		.loc 1 1907 0
 5821 317c 066088E0 		add	r6, r8, r6
 5822 3180 86C18CE0 		add	ip, ip, r6, asl #3
1909:../uvc.c      **** 					  }else{
 5823              		.loc 1 1909 0
 5824 3184 0130A0E3 		mov	r3, #1
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5825              		.loc 1 1907 0
 5826 3188 9915CCE5 		strb	r1, [ip, #1433]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5827              		.loc 1 1908 0
 5828 318c 9A25CCE5 		strb	r2, [ip, #1434]
1909:../uvc.c      **** 					  }else{
 5829              		.loc 1 1909 0
 5830 3190 9C35CCE5 		strb	r3, [ip, #1436]
 5831              	.LVL674:
 5832              	.L494:
 5833 3194 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5834 3198 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
1916:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5835              		.loc 1 1916 0
 5836 319c FF00A0E3 		mov	r0, #255
 5837 31a0 50FFFFEA 		b	.L478
 5838              	.LVL675:
 5839              	.L482:
1865:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5840              		.loc 1 1865 0
 5841 31a4 B135D3E5 		ldrb	r3, [r3, #1457]	@ zero_extendqisi2
 5842 31a8 010053E3 		cmp	r3, #1
 5843 31ac 04005313 		cmpne	r3, #4
 5844 31b0 2001001A 		bne	.L491
1864:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5845              		.loc 1 1864 0
 5846 31b4 1CC09DE5 		ldr	ip, [sp, #28]
 5847 31b8 20009DE5 		ldr	r0, [sp, #32]
 5848 31bc 00348CE1 		orr	r3, ip, r0, asl #8
1866:../uvc.c      **** 					  {
 5849              		.loc 1 1866 0
 5850 31c0 F90053E3 		cmp	r3, #249
 5851 31c4 1B01008A 		bhi	.L491
 5852              	.LVL676:
1871:../uvc.c      **** 							}else{
 5853              		.loc 1 1871 0
 5854 31c8 C80043E2 		sub	r0, r3, #200
 5855 31cc C80053E3 		cmp	r3, #200
1873:../uvc.c      **** 							}
 5856              		.loc 1 1873 0
 5857 31d0 C82063E2 		rsb	r2, r3, #200
 5858 31d4 C0149FE5 		ldr	r1, .L505+28
 5859 31d8 0208A091 		movls	r0, r2, asl #16
 5860 31dc 0008A081 		movhi	r0, r0, asl #16
 5861 31e0 642063E2 		rsb	r2, r3, #100
 5862 31e4 640053E3 		cmp	r3, #100
1871:../uvc.c      **** 							}else{
 5863              		.loc 1 1871 0
 5864 31e8 64C043E2 		sub	ip, r3, #100
 5865 31ec 2008A0E1 		mov	r0, r0, lsr #16
 5866 31f0 0C28A081 		movhi	r2, ip, asl #16
 5867 31f4 0228A091 		movls	r2, r2, asl #16
 5868 31f8 010050E1 		cmp	r0, r1
 5869 31fc 00E0A031 		movcc	lr, r0
 5870 3200 01E0A021 		movcs	lr, r1
 5871 3204 010050E1 		cmp	r0, r1
 5872 3208 27C043E2 		sub	ip, r3, #39
1873:../uvc.c      **** 							}
 5873              		.loc 1 1873 0
 5874 320c 271063E2 		rsb	r1, r3, #39
 5875 3210 00B0A033 		movcc	fp, #0
 5876 3214 01B0A023 		movcs	fp, #1
 5877 3218 270053E3 		cmp	r3, #39
1871:../uvc.c      **** 							}else{
 5878              		.loc 1 1871 0
 5879 321c 140043E2 		sub	r0, r3, #20
 5880 3220 01C8A091 		movls	ip, r1, asl #16
 5881 3224 2228A0E1 		mov	r2, r2, lsr #16
1873:../uvc.c      **** 							}
 5882              		.loc 1 1873 0
 5883 3228 141063E2 		rsb	r1, r3, #20
 5884 322c 0CC8A081 		movhi	ip, ip, asl #16
 5885 3230 140053E3 		cmp	r3, #20
 5886 3234 0018A081 		movhi	r1, r0, asl #16
 5887 3238 0118A091 		movls	r1, r1, asl #16
 5888 323c 0E0052E1 		cmp	r2, lr
1871:../uvc.c      **** 							}else{
 5889              		.loc 1 1871 0
 5890 3240 0A0043E2 		sub	r0, r3, #10
 5891 3244 01B0A033 		movcc	fp, #1
 5892 3248 2CC8A0E1 		mov	ip, ip, lsr #16
 5893 324c 02005EE1 		cmp	lr, r2
 5894 3250 0E20A031 		movcc	r2, lr
 5895 3254 0A0053E3 		cmp	r3, #10
 5896 3258 21E8A0E1 		mov	lr, r1, lsr #16
1873:../uvc.c      **** 							}
 5897              		.loc 1 1873 0
 5898 325c 0A1063E2 		rsb	r1, r3, #10
 5899 3260 0118A091 		movls	r1, r1, asl #16
 5900 3264 0018A081 		movhi	r1, r0, asl #16
 5901 3268 0C0052E1 		cmp	r2, ip
 5902 326c 02B0A083 		movhi	fp, #2
 5903 3270 24B08DE5 		str	fp, [sp, #36]
1871:../uvc.c      **** 							}else{
 5904              		.loc 1 1871 0
 5905 3274 050043E2 		sub	r0, r3, #5
 5906 3278 02005CE1 		cmp	ip, r2
 5907 327c 0C20A031 		movcc	r2, ip
 5908 3280 21B8A0E1 		mov	fp, r1, lsr #16
1873:../uvc.c      **** 							}
 5909              		.loc 1 1873 0
 5910 3284 05C063E2 		rsb	ip, r3, #5
 5911 3288 050053E3 		cmp	r3, #5
 5912 328c 24109DE5 		ldr	r1, [sp, #36]
 5913 3290 00C8A081 		movhi	ip, r0, asl #16
 5914 3294 0CC8A091 		movls	ip, ip, asl #16
 5915 3298 0E0052E1 		cmp	r2, lr
 5916 329c 0310A083 		movhi	r1, #3
 5917 32a0 24108DE5 		str	r1, [sp, #36]
 5918 32a4 02005EE1 		cmp	lr, r2
 5919 32a8 0E00A031 		movcc	r0, lr
 5920 32ac 0200A021 		movcs	r0, r2
 5921 32b0 021063E2 		rsb	r1, r3, #2
1871:../uvc.c      **** 							}else{
 5922              		.loc 1 1871 0
 5923 32b4 022043E2 		sub	r2, r3, #2
 5924 32b8 020053E3 		cmp	r3, #2
 5925 32bc 0128A091 		movls	r2, r1, asl #16
 5926 32c0 0228A081 		movhi	r2, r2, asl #16
 5927 32c4 0B0050E1 		cmp	r0, fp
 5928 32c8 24E09DE5 		ldr	lr, [sp, #36]
 5929 32cc 2CC8A0E1 		mov	ip, ip, lsr #16
 5930 32d0 04E0A083 		movhi	lr, #4
 5931 32d4 00005BE1 		cmp	fp, r0
 5932 32d8 0B00A031 		movcc	r0, fp
 5933 32dc 00005CE1 		cmp	ip, r0
 5934 32e0 0C10A031 		movcc	r1, ip
 5935 32e4 0010A021 		movcs	r1, r0
 5936 32e8 0C0050E1 		cmp	r0, ip
 5937 32ec 05E0A083 		movhi	lr, #5
 5938 32f0 01C043E2 		sub	ip, r3, #1
 5939 32f4 010053E3 		cmp	r3, #1
1873:../uvc.c      **** 							}
 5940              		.loc 1 1873 0
 5941 32f8 010063E2 		rsb	r0, r3, #1
 5942 32fc 0C38A081 		movhi	r3, ip, asl #16
1883:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5943              		.loc 1 1883 0
 5944 3300 8CC39FE5 		ldr	ip, .L505+20
 5945 3304 2228A0E1 		mov	r2, r2, lsr #16
 5946 3308 0038A091 		movls	r3, r0, asl #16
 5947 330c 010052E1 		cmp	r2, r1
 5948 3310 0200A031 		movcc	r0, r2
 5949 3314 0100A021 		movcs	r0, r1
 5950 3318 020051E1 		cmp	r1, r2
 5951 331c 0E20A091 		movls	r2, lr
 5952 3320 0620A083 		movhi	r2, #6
 5953              	.LVL677:
 5954 3324 0010E0E3 		mvn	r1, #0
 5955              	.LVL678:
 5956 3328 230850E1 		cmp	r0, r3, lsr #16
 5957 332c 1C009CE5 		ldr	r0, [ip, #28]
 5958 3330 02B0A091 		movls	fp, r2
 5959 3334 07B0A083 		movhi	fp, #7
 5960              	.LVL679:
 5961 3338 18C08DE5 		str	ip, [sp, #24]
 5962 333c FEFFFFEB 		bl	_txe_mutex_get
 5963              	.LVL680:
1884:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5964              		.loc 1 1884 0
 5965 3340 18C09DE5 		ldr	ip, [sp, #24]
1880:../uvc.c      **** 
 5966              		.loc 1 1880 0
 5967 3344 01B08BE2 		add	fp, fp, #1
 5968              	.LVL681:
1884:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5969              		.loc 1 1884 0
 5970 3348 0010A0E3 		mov	r1, #0
 5971 334c 0A20A0E1 		mov	r2, r10
 5972 3350 0930A0E1 		mov	r3, r9
 5973 3354 0C00A0E1 		mov	r0, ip
 5974 3358 04108DE5 		str	r1, [sp, #4]
 5975 335c 00B08DE5 		str	fp, [sp]
 5976 3360 0310A0E3 		mov	r1, #3
 5977 3364 FEFFFFEB 		bl	cmdSet
 5978              	.LVL682:
1885:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5979              		.loc 1 1885 0
 5980 3368 18C09DE5 		ldr	ip, [sp, #24]
 5981 336c 1C009CE5 		ldr	r0, [ip, #28]
 5982 3370 FEFFFFEB 		bl	_txe_mutex_put
 5983              	.LVL683:
1891:../uvc.c      **** 					  }else{
 5984              		.loc 1 1891 0
 5985 3374 08C39FE5 		ldr	ip, .L505+4
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5986              		.loc 1 1888 0
 5987 3378 04239FE5 		ldr	r2, .L505+4
1891:../uvc.c      **** 					  }else{
 5988              		.loc 1 1891 0
 5989 337c 0DB3CCE5 		strb	fp, [ip, #781]
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5990              		.loc 1 1888 0
 5991 3380 1CC09DE5 		ldr	ip, [sp, #28]
 5992 3384 063088E0 		add	r3, r8, r6
 5993 3388 833182E0 		add	r3, r2, r3, asl #3
 5994 338c 99C5C3E5 		strb	ip, [r3, #1433]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5995              		.loc 1 1889 0
 5996 3390 20C09DE5 		ldr	ip, [sp, #32]
1890:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5997              		.loc 1 1890 0
 5998 3394 0120A0E3 		mov	r2, #1
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5999              		.loc 1 1889 0
 6000 3398 9AC5C3E5 		strb	ip, [r3, #1434]
1890:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6001              		.loc 1 1890 0
 6002 339c 9C25C3E5 		strb	r2, [r3, #1436]
1891:../uvc.c      **** 					  }else{
 6003              		.loc 1 1891 0
 6004 33a0 7BFFFFEA 		b	.L494
 6005              	.LVL684:
 6006              	.L480:
1822:../uvc.c      **** 						case 1:
 6007              		.loc 1 1822 0
 6008 33a4 1CC09DE5 		ldr	ip, [sp, #28]
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6009              		.loc 1 1818 0
 6010 33a8 066088E0 		add	r6, r8, r6
 6011 33ac 866183E0 		add	r6, r3, r6, asl #3
1819:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6012              		.loc 1 1819 0
 6013 33b0 0110A0E3 		mov	r1, #1
1822:../uvc.c      **** 						case 1:
 6014              		.loc 1 1822 0
 6015 33b4 01204CE2 		sub	r2, ip, #1
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6016              		.loc 1 1818 0
 6017 33b8 99C5C6E5 		strb	ip, [r6, #1433]
1819:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6018              		.loc 1 1819 0
 6019 33bc 9C15C6E5 		strb	r1, [r6, #1436]
 6020              	.LVL685:
1822:../uvc.c      **** 						case 1:
 6021              		.loc 1 1822 0
 6022 33c0 070052E3 		cmp	r2, #7
 6023 33c4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 6024 33c8 960000EA 		b	.L485
 6025              	.L487:
 6026 33cc C4350000 		.word	.L486
 6027 33d0 28350000 		.word	.L488
 6028 33d4 28360000 		.word	.L485
 6029 33d8 C0340000 		.word	.L489
 6030 33dc 28360000 		.word	.L485
 6031 33e0 28360000 		.word	.L485
 6032 33e4 28360000 		.word	.L485
 6033 33e8 20340000 		.word	.L490
 6034              	.LVL686:
 6035              	.L479:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6036              		.loc 1 1937 0
 6037 33ec 1CC09DE5 		ldr	ip, [sp, #28]
 6038 33f0 068088E0 		add	r8, r8, r6
 6039 33f4 888183E0 		add	r8, r3, r8, asl #3
1938:../uvc.c      **** 			  		 break;
 6040              		.loc 1 1938 0
 6041 33f8 0620A0E1 		mov	r2, r6
 6042 33fc 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 6043 3400 0400A0E3 		mov	r0, #4
 6044 3404 94129FE5 		ldr	r1, .L505+32
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6045              		.loc 1 1937 0
 6046 3408 99C5C8E5 		strb	ip, [r8, #1433]
1938:../uvc.c      **** 			  		 break;
 6047              		.loc 1 1938 0
 6048 340c FEFFFFEB 		bl	CyU3PDebugPrint
 6049              	.LVL687:
1939:../uvc.c      **** 			  }
 6050              		.loc 1 1939 0
 6051 3410 FF00A0E3 		mov	r0, #255
 6052 3414 0080A0E1 		mov	r8, r0
 6053 3418 0060A0E1 		mov	r6, r0
 6054 341c B1FEFFEA 		b	.L478
 6055              	.LVL688:
 6056              	.L490:
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6057              		.loc 1 1841 0
 6058 3420 6C629FE5 		ldr	r6, .L505+20
1839:../uvc.c      **** 			  		    	dataIdx = 0;
 6059              		.loc 1 1839 0
 6060 3424 0080A0E3 		mov	r8, #0
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6061              		.loc 1 1841 0
 6062 3428 1C0096E5 		ldr	r0, [r6, #28]
 6063 342c 0010E0E3 		mvn	r1, #0
1839:../uvc.c      **** 			  		    	dataIdx = 0;
 6064              		.loc 1 1839 0
 6065 3430 0D83C3E5 		strb	r8, [r3, #781]
 6066              	.LVL689:
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6067              		.loc 1 1841 0
 6068 3434 FEFFFFEB 		bl	_txe_mutex_get
 6069              	.LVL690:
1842:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6070              		.loc 1 1842 0
 6071 3438 0A20A0E1 		mov	r2, r10
 6072 343c 0930A0E1 		mov	r3, r9
 6073 3440 1010A0E3 		mov	r1, #16
 6074 3444 00808DE5 		str	r8, [sp]
 6075 3448 04808DE5 		str	r8, [sp, #4]
 6076 344c 0600A0E1 		mov	r0, r6
 6077 3450 FEFFFFEB 		bl	cmdSet
 6078              	.LVL691:
1843:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 6079              		.loc 1 1843 0
 6080 3454 1C0096E5 		ldr	r0, [r6, #28]
 6081 3458 FEFFFFEB 		bl	_txe_mutex_put
 6082              	.LVL692:
 6083              	.LBB103:
 6084              	.LBB104:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6085              		.loc 1 736 0
 6086 345c 1C0096E5 		ldr	r0, [r6, #28]
 6087 3460 0010E0E3 		mvn	r1, #0
 6088 3464 FEFFFFEB 		bl	_txe_mutex_get
 6089              	.LVL693:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6090              		.loc 1 737 0
 6091 3468 0130A0E3 		mov	r3, #1
 6092 346c 04808DE5 		str	r8, [sp, #4]
 6093 3470 0600A0E1 		mov	r0, r6
 6094 3474 00308DE5 		str	r3, [sp]
 6095 3478 2010A0E3 		mov	r1, #32
 6096 347c 2720A0E3 		mov	r2, #39
 6097 3480 3030A0E3 		mov	r3, #48
 6098 3484 FEFFFFEB 		bl	cmdSet
 6099              	.LVL694:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6100              		.loc 1 738 0
 6101 3488 0230A0E3 		mov	r3, #2
 6102 348c 04808DE5 		str	r8, [sp, #4]
 6103 3490 0600A0E1 		mov	r0, r6
 6104 3494 00308DE5 		str	r3, [sp]
 6105 3498 2110A0E3 		mov	r1, #33
 6106 349c 2520A0E3 		mov	r2, #37
 6107 34a0 3030A0E3 		mov	r3, #48
 6108 34a4 FEFFFFEB 		bl	cmdSet
 6109              	.LVL695:
 739:../uvc.c      **** }
 6110              		.loc 1 739 0
 6111 34a8 1C0096E5 		ldr	r0, [r6, #28]
 6112 34ac FEFFFFEB 		bl	_txe_mutex_put
 6113              	.LVL696:
 6114 34b0 FF00A0E3 		mov	r0, #255
 6115 34b4 0080A0E1 		mov	r8, r0
 6116 34b8 0860A0E3 		mov	r6, #8
 6117 34bc 89FEFFEA 		b	.L478
 6118              	.LVL697:
 6119              	.L489:
 6120              	.LBE104:
 6121              	.LBE103:
 6122              	.LBB105:
 6123              	.LBB106:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6124              		.loc 1 736 0
 6125 34c0 CC619FE5 		ldr	r6, .L505+20
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6126              		.loc 1 737 0
 6127 34c4 0080A0E3 		mov	r8, #0
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6128              		.loc 1 736 0
 6129 34c8 0010E0E3 		mvn	r1, #0
 6130 34cc 1C0096E5 		ldr	r0, [r6, #28]
 6131 34d0 FEFFFFEB 		bl	_txe_mutex_get
 6132              	.LVL698:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6133              		.loc 1 737 0
 6134 34d4 0600A0E1 		mov	r0, r6
 6135 34d8 00808DE5 		str	r8, [sp]
 6136 34dc 04808DE5 		str	r8, [sp, #4]
 6137 34e0 2010A0E3 		mov	r1, #32
 6138 34e4 2720A0E3 		mov	r2, #39
 6139 34e8 3030A0E3 		mov	r3, #48
 6140 34ec FEFFFFEB 		bl	cmdSet
 6141              	.LVL699:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6142              		.loc 1 738 0
 6143 34f0 0130A0E3 		mov	r3, #1
 6144 34f4 04808DE5 		str	r8, [sp, #4]
 6145 34f8 0600A0E1 		mov	r0, r6
 6146 34fc 00308DE5 		str	r3, [sp]
 6147 3500 2110A0E3 		mov	r1, #33
 6148 3504 2520A0E3 		mov	r2, #37
 6149 3508 3030A0E3 		mov	r3, #48
 6150 350c FEFFFFEB 		bl	cmdSet
 6151              	.LVL700:
 739:../uvc.c      **** }
 6152              		.loc 1 739 0
 6153 3510 1C0096E5 		ldr	r0, [r6, #28]
 6154 3514 FEFFFFEB 		bl	_txe_mutex_put
 6155              	.LVL701:
 6156 3518 FF00A0E3 		mov	r0, #255
 6157 351c 0080A0E1 		mov	r8, r0
 6158 3520 0460A0E3 		mov	r6, #4
 6159 3524 6FFEFFEA 		b	.L478
 6160              	.LVL702:
 6161              	.L488:
 6162              	.LBE106:
 6163              	.LBE105:
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6164              		.loc 1 1829 0
 6165 3528 64619FE5 		ldr	r6, .L505+20
1827:../uvc.c      **** 							dataIdx = 0;
 6166              		.loc 1 1827 0
 6167 352c 0080A0E3 		mov	r8, #0
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6168              		.loc 1 1829 0
 6169 3530 1C0096E5 		ldr	r0, [r6, #28]
 6170 3534 0010E0E3 		mvn	r1, #0
1827:../uvc.c      **** 							dataIdx = 0;
 6171              		.loc 1 1827 0
 6172 3538 0D83C3E5 		strb	r8, [r3, #781]
 6173              	.LVL703:
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6174              		.loc 1 1829 0
 6175 353c FEFFFFEB 		bl	_txe_mutex_get
 6176              	.LVL704:
1830:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6177              		.loc 1 1830 0
 6178 3540 0A20A0E1 		mov	r2, r10
 6179 3544 0930A0E1 		mov	r3, r9
 6180 3548 1010A0E3 		mov	r1, #16
 6181 354c 00808DE5 		str	r8, [sp]
 6182 3550 04808DE5 		str	r8, [sp, #4]
 6183 3554 0600A0E1 		mov	r0, r6
 6184 3558 FEFFFFEB 		bl	cmdSet
 6185              	.LVL705:
1831:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 6186              		.loc 1 1831 0
 6187 355c 1C0096E5 		ldr	r0, [r6, #28]
 6188 3560 FEFFFFEB 		bl	_txe_mutex_put
 6189              	.LVL706:
 6190              	.LBB107:
 6191              	.LBB108:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6192              		.loc 1 736 0
 6193 3564 1C0096E5 		ldr	r0, [r6, #28]
 6194 3568 0010E0E3 		mvn	r1, #0
 6195 356c FEFFFFEB 		bl	_txe_mutex_get
 6196              	.LVL707:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6197              		.loc 1 737 0
 6198 3570 00808DE5 		str	r8, [sp]
 6199 3574 04808DE5 		str	r8, [sp, #4]
 6200 3578 0600A0E1 		mov	r0, r6
 6201 357c 2010A0E3 		mov	r1, #32
 6202 3580 2720A0E3 		mov	r2, #39
 6203 3584 3030A0E3 		mov	r3, #48
 6204 3588 FEFFFFEB 		bl	cmdSet
 6205              	.LVL708:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6206              		.loc 1 738 0
 6207 358c 0130A0E3 		mov	r3, #1
 6208 3590 04808DE5 		str	r8, [sp, #4]
 6209 3594 0600A0E1 		mov	r0, r6
 6210 3598 00308DE5 		str	r3, [sp]
 6211 359c 2110A0E3 		mov	r1, #33
 6212 35a0 2520A0E3 		mov	r2, #37
 6213 35a4 3030A0E3 		mov	r3, #48
 6214 35a8 FEFFFFEB 		bl	cmdSet
 6215              	.LVL709:
 739:../uvc.c      **** }
 6216              		.loc 1 739 0
 6217 35ac 1C0096E5 		ldr	r0, [r6, #28]
 6218 35b0 FEFFFFEB 		bl	_txe_mutex_put
 6219              	.LVL710:
 6220 35b4 FF00A0E3 		mov	r0, #255
 6221 35b8 0080A0E1 		mov	r8, r0
 6222 35bc 0260A0E3 		mov	r6, #2
 6223 35c0 48FEFFEA 		b	.L478
 6224              	.LVL711:
 6225              	.L486:
 6226              	.LBE108:
 6227              	.LBE107:
 6228              	.LBB109:
 6229              	.LBB110:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6230              		.loc 1 736 0
 6231 35c4 C8809FE5 		ldr	r8, .L505+20
 6232 35c8 0010E0E3 		mvn	r1, #0
 6233 35cc 1C0098E5 		ldr	r0, [r8, #28]
 6234 35d0 FEFFFFEB 		bl	_txe_mutex_get
 6235              	.LVL712:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6236              		.loc 1 737 0
 6237 35d4 0090A0E3 		mov	r9, #0
 6238              	.LVL713:
 6239 35d8 0160A0E3 		mov	r6, #1
 6240 35dc 0800A0E1 		mov	r0, r8
 6241 35e0 2010A0E3 		mov	r1, #32
 6242 35e4 2720A0E3 		mov	r2, #39
 6243 35e8 3030A0E3 		mov	r3, #48
 6244 35ec 40028DE8 		stmia	sp, {r6, r9}
 6245 35f0 FEFFFFEB 		bl	cmdSet
 6246              	.LVL714:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6247              		.loc 1 738 0
 6248 35f4 0230A0E3 		mov	r3, #2
 6249 35f8 0800A0E1 		mov	r0, r8
 6250 35fc 00308DE5 		str	r3, [sp]
 6251 3600 2110A0E3 		mov	r1, #33
 6252 3604 2520A0E3 		mov	r2, #37
 6253 3608 3030A0E3 		mov	r3, #48
 6254 360c 04908DE5 		str	r9, [sp, #4]
 6255 3610 FEFFFFEB 		bl	cmdSet
 6256              	.LVL715:
 739:../uvc.c      **** }
 6257              		.loc 1 739 0
 6258 3614 1C0098E5 		ldr	r0, [r8, #28]
 6259 3618 FEFFFFEB 		bl	_txe_mutex_put
 6260              	.LVL716:
 6261 361c FF00A0E3 		mov	r0, #255
 6262 3620 0080A0E1 		mov	r8, r0
 6263 3624 2FFEFFEA 		b	.L478
 6264              	.LVL717:
 6265              	.L485:
 6266              	.LBE110:
 6267              	.LBE109:
1822:../uvc.c      **** 						case 1:
 6268              		.loc 1 1822 0
 6269 3628 FF00A0E3 		mov	r0, #255
 6270 362c 0C60A0E1 		mov	r6, ip
 6271 3630 0080A0E1 		mov	r8, r0
 6272 3634 2BFEFFEA 		b	.L478
 6273              	.LVL718:
 6274              	.L491:
1893:../uvc.c      **** 					  }
 6275              		.loc 1 1893 0
 6276 3638 0000A0E3 		mov	r0, #0
 6277 363c 0020A0E1 		mov	r2, r0
 6278 3640 0110A0E3 		mov	r1, #1
 6279 3644 FEFFFFEB 		bl	CyU3PUsbStall
 6280              	.LVL719:
 6281 3648 D1FEFFEA 		b	.L494
 6282              	.LVL720:
 6283              	.L493:
1911:../uvc.c      **** 					  }
 6284              		.loc 1 1911 0
 6285 364c 0020A0E1 		mov	r2, r0
 6286 3650 0110A0E3 		mov	r1, #1
 6287 3654 FEFFFFEB 		bl	CyU3PUsbStall
 6288              	.LVL721:
 6289 3658 CDFEFFEA 		b	.L494
 6290              	.LVL722:
 6291              	.L504:
1926:../uvc.c      **** 					  else
 6292              		.loc 1 1926 0
 6293 365c 0800A0E3 		mov	r0, #8
 6294              	.L501:
 6295 3660 0010A0E3 		mov	r1, #0
 6296 3664 03008DE8 		stmia	sp, {r0, r1}
 6297 3668 0A20A0E1 		mov	r2, r10
 6298 366c 0930A0E1 		mov	r3, r9
 6299 3670 0600A0E1 		mov	r0, r6
 6300 3674 2310A0E3 		mov	r1, #35
 6301 3678 FEFFFFEB 		bl	cmdSet
 6302              	.LVL723:
 6303 367c 97FEFFEA 		b	.L496
 6304              	.L506:
 6305              		.align	2
 6306              	.L505:
 6307 3680 00000000 		.word	bRequest
 6308 3684 00000000 		.word	.LANCHOR1
 6309 3688 00000000 		.word	.LANCHOR0
 6310 368c 14070000 		.word	.LC41
 6311 3690 F0060000 		.word	.LC40
 6312 3694 00000000 		.word	cmdQu
 6313 3698 A4060000 		.word	.LC38
 6314 369c FFFF0000 		.word	65535
 6315 36a0 CC060000 		.word	.LC39
 6316              		.cfi_endproc
 6317              	.LFE4:
 6319              		.align	2
 6320              		.global	CamDefSet
 6322              	CamDefSet:
 6323              	.LFB5:
1954:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 6324              		.loc 1 1954 0
 6325              		.cfi_startproc
 6326              		@ args = 0, pretend = 0, frame = 24
 6327              		@ frame_needed = 0, uses_anonymous_args = 0
 6328              	.LVL724:
 6329 36a4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6330              	.LCFI21:
 6331              		.cfi_def_cfa_offset 36
 6332              		.cfi_offset 4, -36
 6333              		.cfi_offset 5, -32
 6334              		.cfi_offset 6, -28
 6335              		.cfi_offset 7, -24
 6336              		.cfi_offset 8, -20
 6337              		.cfi_offset 9, -16
 6338              		.cfi_offset 10, -12
 6339              		.cfi_offset 11, -8
 6340              		.cfi_offset 14, -4
1961:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6341              		.loc 1 1961 0
 6342 36a8 B0429FE5 		ldr	r4, .L510
1966:../uvc.c      ****     if(Data1&0x80){
 6343              		.loc 1 1966 0
 6344 36ac B0229FE5 		ldr	r2, .L510+4
1963:../uvc.c      ****     Data1 = Data0;
 6345              		.loc 1 1963 0
 6346 36b0 A351D4E5 		ldrb	r5, [r4, #419]	@ zero_extendqisi2
1954:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 6347              		.loc 1 1954 0
 6348 36b4 2CD04DE2 		sub	sp, sp, #44
 6349              	.LCFI22:
 6350              		.cfi_def_cfa_offset 80
1966:../uvc.c      ****     if(Data1&0x80){
 6351              		.loc 1 1966 0
 6352 36b8 1C0092E5 		ldr	r0, [r2, #28]
 6353 36bc 0010E0E3 		mvn	r1, #0
1968:../uvc.c      ****     }else{
 6354              		.loc 1 1968 0
 6355 36c0 2563A0E1 		mov	r6, r5, lsr #6
1962:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6356              		.loc 1 1962 0
 6357 36c4 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1961:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6358              		.loc 1 1961 0
 6359 36c8 9991D4E5 		ldrb	r9, [r4, #409]	@ zero_extendqisi2
 6360              	.LVL725:
1966:../uvc.c      ****     if(Data1&0x80){
 6361              		.loc 1 1966 0
 6362 36cc FEFFFFEB 		bl	_txe_mutex_get
 6363              	.LVL726:
1967:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6364              		.loc 1 1967 0
 6365 36d0 800015E3 		tst	r5, #128
1968:../uvc.c      ****     }else{
 6366              		.loc 1 1968 0
 6367 36d4 01600612 		andne	r6, r6, #1
 6368 36d8 0660E011 		mvnne	r6, r6
 6369 36dc 3B600612 		andne	r6, r6, #59
 6370 36e0 0660E011 		mvnne	r6, r6
 6371 36e4 FF600612 		andne	r6, r6, #255
 6372              	.LVL727:
1970:../uvc.c      ****     }
 6373              		.loc 1 1970 0
 6374 36e8 C6608603 		orreq	r6, r6, #198
 6375              	.LVL728:
1974:../uvc.c      **** 
 6376              		.loc 1 1974 0
 6377 36ec 0080A0E3 		mov	r8, #0
1972:../uvc.c      **** 
 6378              		.loc 1 1972 0
 6379 36f0 0551A0E1 		mov	r5, r5, asl #2
 6380              	.LVL729:
 6381 36f4 FF5005E2 		and	r5, r5, #255
 6382              	.LVL730:
1977:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6383              		.loc 1 1977 0
 6384 36f8 01A0A0E3 		mov	r10, #1
1974:../uvc.c      **** 
 6385              		.loc 1 1974 0
 6386 36fc 00608DE5 		str	r6, [sp]
 6387 3700 0920A0E1 		mov	r2, r9
 6388 3704 0730A0E1 		mov	r3, r7
 6389 3708 04808DE5 		str	r8, [sp, #4]
 6390 370c 0110A0E3 		mov	r1, #1
 6391 3710 4C029FE5 		ldr	r0, .L510+4
 6392 3714 FEFFFFEB 		bl	cmdSet
 6393              	.LVL731:
1977:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6394              		.loc 1 1977 0
 6395 3718 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6396 371c 0730A0E1 		mov	r3, r7
 6397 3720 0A10A0E1 		mov	r1, r10
 6398 3724 00508DE5 		str	r5, [sp]
 6399 3728 04A08DE5 		str	r10, [sp, #4]
 6400 372c 30029FE5 		ldr	r0, .L510+4
 6401 3730 FEFFFFEB 		bl	cmdSet
 6402              	.LVL732:
1980:../uvc.c      **** 
 6403              		.loc 1 1980 0
 6404 3734 0620A0E1 		mov	r2, r6
 6405 3738 0530A0E1 		mov	r3, r5
 6406 373c 24129FE5 		ldr	r1, .L510+8
 6407 3740 0400A0E3 		mov	r0, #4
1979:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6408              		.loc 1 1979 0
 6409 3744 A661C4E5 		strb	r6, [r4, #422]
1978:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6410              		.loc 1 1978 0
 6411 3748 A551C4E5 		strb	r5, [r4, #421]
1980:../uvc.c      **** 
 6412              		.loc 1 1980 0
 6413 374c FEFFFFEB 		bl	CyU3PDebugPrint
 6414              	.LVL733:
1985:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6415              		.loc 1 1985 0
 6416 3750 BB61D4E5 		ldrb	r6, [r4, #443]	@ zero_extendqisi2
 6417              	.LVL734:
1986:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6418              		.loc 1 1986 0
 6419 3754 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6420 3758 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6421 375c 40018DE8 		stmia	sp, {r6, r8}
 6422 3760 FC019FE5 		ldr	r0, .L510+4
 6423 3764 0210A0E3 		mov	r1, #2
 6424 3768 FEFFFFEB 		bl	cmdSet
 6425              	.LVL735:
1989:../uvc.c      **** 
 6426              		.loc 1 1989 0
 6427 376c 0620A0E1 		mov	r2, r6
 6428 3770 0530A0E1 		mov	r3, r5
 6429 3774 EC119FE5 		ldr	r1, .L510+8
 6430 3778 0400A0E3 		mov	r0, #4
1987:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 6431              		.loc 1 1987 0
 6432 377c BD51C4E5 		strb	r5, [r4, #445]
1988:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6433              		.loc 1 1988 0
 6434 3780 FD53C4E5 		strb	r5, [r4, #1021]
1989:../uvc.c      **** 
 6435              		.loc 1 1989 0
 6436 3784 FEFFFFEB 		bl	CyU3PDebugPrint
 6437              	.LVL736:
1994:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6438              		.loc 1 1994 0
 6439 3788 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1993:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6440              		.loc 1 1993 0
 6441 378c 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6442              	.LVL737:
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6443              		.loc 1 1995 0
 6444 3790 80C047E2 		sub	ip, r7, #128
 6445 3794 FF300CE2 		and	r3, ip, #255
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6446              		.loc 1 1996 0
 6447 3798 76E047E2 		sub	lr, r7, #118
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6448              		.loc 1 1995 0
 6449 379c 18308DE5 		str	r3, [sp, #24]
 6450 37a0 08018DE8 		stmia	sp, {r3, r8}
 6451 37a4 B8019FE5 		ldr	r0, .L510+4
 6452 37a8 0630A0E1 		mov	r3, r6
 6453 37ac 0510A0E3 		mov	r1, #5
 6454 37b0 DF20A0E3 		mov	r2, #223
 6455 37b4 14C08DE5 		str	ip, [sp, #20]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6456              		.loc 1 1996 0
 6457 37b8 1CE08DE5 		str	lr, [sp, #28]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6458              		.loc 1 1995 0
 6459 37bc FEFFFFEB 		bl	cmdSet
 6460              	.LVL738:
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6461              		.loc 1 1996 0
 6462 37c0 1C209DE5 		ldr	r2, [sp, #28]
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6463              		.loc 1 1997 0
 6464 37c4 7EE087E2 		add	lr, r7, #126
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6465              		.loc 1 1996 0
 6466 37c8 FF3002E2 		and	r3, r2, #255
 6467 37cc 08048DE8 		stmia	sp, {r3, r10}
 6468 37d0 8C019FE5 		ldr	r0, .L510+4
 6469 37d4 0630A0E1 		mov	r3, r6
 6470 37d8 0510A0E3 		mov	r1, #5
 6471 37dc DC20A0E3 		mov	r2, #220
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6472              		.loc 1 1997 0
 6473 37e0 20E08DE5 		str	lr, [sp, #32]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6474              		.loc 1 1996 0
 6475 37e4 FEFFFFEB 		bl	cmdSet
 6476              	.LVL739:
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6477              		.loc 1 1997 0
 6478 37e8 20209DE5 		ldr	r2, [sp, #32]
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6479              		.loc 1 1998 0
 6480 37ec 72E087E2 		add	lr, r7, #114
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6481              		.loc 1 1997 0
 6482 37f0 FF3002E2 		and	r3, r2, #255
 6483 37f4 0220A0E3 		mov	r2, #2
 6484 37f8 00308DE5 		str	r3, [sp]
 6485 37fc 04208DE5 		str	r2, [sp, #4]
 6486 3800 0630A0E1 		mov	r3, r6
 6487 3804 0510A0E3 		mov	r1, #5
 6488 3808 DE20A0E3 		mov	r2, #222
 6489 380c 50019FE5 		ldr	r0, .L510+4
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6490              		.loc 1 1998 0
 6491 3810 24E08DE5 		str	lr, [sp, #36]
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6492              		.loc 1 1997 0
 6493 3814 FEFFFFEB 		bl	cmdSet
 6494              	.LVL740:
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6495              		.loc 1 1998 0
 6496 3818 24209DE5 		ldr	r2, [sp, #36]
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6497              		.loc 1 1999 0
 6498 381c 6FB047E2 		sub	fp, r7, #111
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6499              		.loc 1 1998 0
 6500 3820 FF3002E2 		and	r3, r2, #255
 6501 3824 0320A0E3 		mov	r2, #3
 6502 3828 00308DE5 		str	r3, [sp]
 6503 382c 04208DE5 		str	r2, [sp, #4]
 6504 3830 0630A0E1 		mov	r3, r6
 6505 3834 0510A0E3 		mov	r1, #5
 6506 3838 E020A0E3 		mov	r2, #224
 6507 383c 20019FE5 		ldr	r0, .L510+4
 6508 3840 FEFFFFEB 		bl	cmdSet
 6509              	.LVL741:
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6510              		.loc 1 1999 0
 6511 3844 0490A0E3 		mov	r9, #4
 6512 3848 FF300BE2 		and	r3, fp, #255
2000:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6513              		.loc 1 2000 0
 6514 384c 7F7087E2 		add	r7, r7, #127
 6515              	.LVL742:
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6516              		.loc 1 1999 0
 6517 3850 00308DE5 		str	r3, [sp]
 6518 3854 04908DE5 		str	r9, [sp, #4]
 6519 3858 0630A0E1 		mov	r3, r6
 6520 385c 0510A0E3 		mov	r1, #5
 6521 3860 DD20A0E3 		mov	r2, #221
 6522 3864 F8009FE5 		ldr	r0, .L510+4
 6523 3868 FEFFFFEB 		bl	cmdSet
 6524              	.LVL743:
2000:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6525              		.loc 1 2000 0
 6526 386c FF2007E2 		and	r2, r7, #255
 6527 3870 0510A0E3 		mov	r1, #5
 6528 3874 0630A0E1 		mov	r3, r6
 6529 3878 00208DE5 		str	r2, [sp]
 6530 387c 04108DE5 		str	r1, [sp, #4]
 6531 3880 E120A0E3 		mov	r2, #225
 6532 3884 D8009FE5 		ldr	r0, .L510+4
 6533 3888 FEFFFFEB 		bl	cmdSet
 6534              	.LVL744:
2002:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6535              		.loc 1 2002 0
 6536 388c 14C09DE5 		ldr	ip, [sp, #20]
 6537 3890 24E09DE5 		ldr	lr, [sp, #36]
 6538 3894 20309DE5 		ldr	r3, [sp, #32]
 6539 3898 0C20A0E1 		mov	r2, ip
2001:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6540              		.loc 1 2001 0
 6541 389c 18C09DE5 		ldr	ip, [sp, #24]
2002:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6542              		.loc 1 2002 0
 6543 38a0 04E08DE5 		str	lr, [sp, #4]
 6544 38a4 00308DE5 		str	r3, [sp]
 6545 38a8 0C708DE5 		str	r7, [sp, #12]
 6546 38ac 1C309DE5 		ldr	r3, [sp, #28]
 6547 38b0 08B08DE5 		str	fp, [sp, #8]
 6548 38b4 0900A0E1 		mov	r0, r9
 6549 38b8 AC109FE5 		ldr	r1, .L510+12
2001:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6550              		.loc 1 2001 0
 6551 38bc 05C2C4E5 		strb	ip, [r4, #517]
2002:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6552              		.loc 1 2002 0
 6553 38c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6554              	.LVL745:
2007:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6555              		.loc 1 2007 0
 6556 38c4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 6557              	.LVL746:
2006:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6558              		.loc 1 2006 0
 6559 38c8 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 6560              	.LVL747:
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6561              		.loc 1 2008 0
 6562 38cc 00608DE5 		str	r6, [sp]
 6563 38d0 0730A0E1 		mov	r3, r7
 6564 38d4 04808DE5 		str	r8, [sp, #4]
 6565 38d8 0610A0E3 		mov	r1, #6
 6566 38dc 8520A0E3 		mov	r2, #133
 6567 38e0 7C009FE5 		ldr	r0, .L510+4
 6568 38e4 FEFFFFEB 		bl	cmdSet
 6569              	.LVL748:
2009:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6570              		.loc 1 2009 0
 6571 38e8 40048DE8 		stmia	sp, {r6, r10}
 6572 38ec 70009FE5 		ldr	r0, .L510+4
 6573 38f0 0730A0E1 		mov	r3, r7
 6574 38f4 0610A0E3 		mov	r1, #6
 6575 38f8 8620A0E3 		mov	r2, #134
 6576 38fc FEFFFFEB 		bl	cmdSet
 6577              	.LVL749:
2011:../uvc.c      **** 
 6578              		.loc 1 2011 0
 6579 3900 0620A0E1 		mov	r2, r6
 6580 3904 0530A0E1 		mov	r3, r5
 6581 3908 0900A0E1 		mov	r0, r9
 6582 390c 54109FE5 		ldr	r1, .L510+8
2010:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6583              		.loc 1 2010 0
 6584 3910 1D62C4E5 		strb	r6, [r4, #541]
2011:../uvc.c      **** 
 6585              		.loc 1 2011 0
 6586 3914 FEFFFFEB 		bl	CyU3PDebugPrint
 6587              	.LVL750:
2016:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6588              		.loc 1 2016 0
 6589 3918 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 6590              	.LVL751:
2017:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6591              		.loc 1 2017 0
 6592 391c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 6593 3920 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 6594 3924 40018DE8 		stmia	sp, {r6, r8}
 6595 3928 34009FE5 		ldr	r0, .L510+4
 6596 392c 0710A0E3 		mov	r1, #7
 6597 3930 FEFFFFEB 		bl	cmdSet
 6598              	.LVL752:
2019:../uvc.c      **** 
 6599              		.loc 1 2019 0
 6600 3934 0620A0E1 		mov	r2, r6
 6601 3938 0530A0E1 		mov	r3, r5
 6602 393c 0900A0E1 		mov	r0, r9
 6603 3940 20109FE5 		ldr	r1, .L510+8
2018:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6604              		.loc 1 2018 0
 6605 3944 3552C4E5 		strb	r5, [r4, #565]
2019:../uvc.c      **** 
 6606              		.loc 1 2019 0
 6607 3948 FEFFFFEB 		bl	CyU3PDebugPrint
 6608              	.LVL753:
2021:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6609              		.loc 1 2021 0
 6610 394c 10209FE5 		ldr	r2, .L510+4
 6611 3950 1C0092E5 		ldr	r0, [r2, #28]
2024:../uvc.c      **** 
 6612              		.loc 1 2024 0
 6613 3954 2CD08DE2 		add	sp, sp, #44
 6614              		@ sp needed
 6615 3958 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6616              	.LVL754:
2021:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6617              		.loc 1 2021 0
 6618 395c FEFFFFEA 		b	_txe_mutex_put
 6619              	.LVL755:
 6620              	.L511:
 6621              		.align	2
 6622              	.L510:
 6623 3960 00000000 		.word	.LANCHOR1
 6624 3964 00000000 		.word	statQu
 6625 3968 78070000 		.word	.LC42
 6626 396c 98070000 		.word	.LC43
 6627              		.cfi_endproc
 6628              	.LFE5:
 6630              		.align	2
 6631              		.global	CyFxUVCAddHeader
 6633              	CyFxUVCAddHeader:
 6634              	.LFB6:
2032:../uvc.c      ****     /* Copy header to buffer */
 6635              		.loc 1 2032 0
 6636              		.cfi_startproc
 6637              		@ args = 0, pretend = 0, frame = 0
 6638              		@ frame_needed = 0, uses_anonymous_args = 0
 6639              	.LVL756:
 6640 3970 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6641              	.LCFI23:
 6642              		.cfi_def_cfa_offset 16
 6643              		.cfi_offset 3, -16
 6644              		.cfi_offset 4, -12
 6645              		.cfi_offset 5, -8
 6646              		.cfi_offset 14, -4
2032:../uvc.c      ****     /* Copy header to buffer */
 6647              		.loc 1 2032 0
 6648 3974 0040A0E1 		mov	r4, r0
 6649 3978 0150A0E1 		mov	r5, r1
2034:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6650              		.loc 1 2034 0
 6651 397c 30009FE5 		ldr	r0, .L517
 6652              	.LVL757:
 6653 3980 0010E0E3 		mvn	r1, #0
 6654              	.LVL758:
 6655 3984 FEFFFFEB 		bl	_txe_mutex_get
 6656              	.LVL759:
2035:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6657              		.loc 1 2035 0
 6658 3988 0400A0E1 		mov	r0, r4
 6659 398c 24109FE5 		ldr	r1, .L517+4
 6660 3990 0C20A0E3 		mov	r2, #12
 6661 3994 FEFFFFEB 		bl	CyU3PMemCopy
 6662              	.LVL760:
2036:../uvc.c      **** 
 6663              		.loc 1 2036 0
 6664 3998 14009FE5 		ldr	r0, .L517
 6665 399c FEFFFFEB 		bl	_txe_mutex_put
 6666              	.LVL761:
2039:../uvc.c      ****     {
 6667              		.loc 1 2039 0
 6668 39a0 020015E3 		tst	r5, #2
2041:../uvc.c      ****     }
 6669              		.loc 1 2041 0
 6670 39a4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6671 39a8 02308313 		orrne	r3, r3, #2
 6672 39ac 0130C415 		strneb	r3, [r4, #1]
 6673 39b0 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6674              	.L518:
 6675              		.align	2
 6676              	.L517:
 6677 39b4 00000000 		.word	imgHdMux
 6678 39b8 EC040000 		.word	.LANCHOR1+1260
 6679              		.cfi_endproc
 6680              	.LFE6:
 6682              		.align	2
 6683              		.global	CyFxAppErrorHandler
 6685              	CyFxAppErrorHandler:
 6686              	.LFB7:
2051:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6687              		.loc 1 2051 0
 6688              		.cfi_startproc
 6689              		@ Volatile: function does not return.
 6690              		@ args = 0, pretend = 0, frame = 0
 6691              		@ frame_needed = 0, uses_anonymous_args = 0
 6692              	.LVL762:
 6693 39bc 08402DE9 		stmfd	sp!, {r3, lr}
 6694              	.LCFI24:
 6695              		.cfi_def_cfa_offset 8
 6696              		.cfi_offset 3, -8
 6697              		.cfi_offset 14, -4
 6698              	.LVL763:
 6699              	.L520:
2061:../uvc.c      ****         CyU3PThreadSleep (1000);
 6700              		.loc 1 2061 0 discriminator 1
 6701 39c0 10109FE5 		ldr	r1, .L521
 6702 39c4 0400A0E3 		mov	r0, #4
 6703 39c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6704              	.LVL764:
2062:../uvc.c      ****     }
 6705              		.loc 1 2062 0 discriminator 1
 6706 39cc FA0FA0E3 		mov	r0, #1000
 6707 39d0 FEFFFFEB 		bl	_tx_thread_sleep
 6708              	.LVL765:
 6709 39d4 F9FFFFEA 		b	.L520
 6710              	.L522:
 6711              		.align	2
 6712              	.L521:
 6713 39d8 D0070000 		.word	.LC44
 6714              		.cfi_endproc
 6715              	.LFE7:
 6717              		.align	2
 6718              		.global	UVCAppThread_Entry
 6720              	UVCAppThread_Entry:
 6721              	.LFB20:
3052:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6722              		.loc 1 3052 0
 6723              		.cfi_startproc
 6724              		@ args = 0, pretend = 0, frame = 160
 6725              		@ frame_needed = 0, uses_anonymous_args = 0
 6726              	.LVL766:
 6727 39dc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6728              	.LCFI25:
 6729              		.cfi_def_cfa_offset 36
 6730              		.cfi_offset 4, -36
 6731              		.cfi_offset 5, -32
 6732              		.cfi_offset 6, -28
 6733              		.cfi_offset 7, -24
 6734              		.cfi_offset 8, -20
 6735              		.cfi_offset 9, -16
 6736              		.cfi_offset 10, -12
 6737              		.cfi_offset 11, -8
 6738              		.cfi_offset 14, -4
 6739 39e0 ACD04DE2 		sub	sp, sp, #172
 6740              	.LCFI26:
 6741              		.cfi_def_cfa_offset 208
 6742              	.LBB119:
 6743              	.LBB120:
2508:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6744              		.loc 1 2508 0
 6745 39e4 FEFFFFEB 		bl	CyU3PUartInit
 6746              	.LVL767:
2509:../uvc.c      ****     {
 6747              		.loc 1 2509 0
 6748 39e8 004050E2 		subs	r4, r0, #0
 6749 39ec 0803001A 		bne	.L615
2516:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6750              		.loc 1 2516 0
 6751 39f0 D02C9FE5 		ldr	r2, .L650
2517:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6752              		.loc 1 2517 0
 6753 39f4 0130A0E3 		mov	r3, #1
2525:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6754              		.loc 1 2525 0
 6755 39f8 0410A0E1 		mov	r1, r4
 6756 39fc 80008DE2 		add	r0, sp, #128
 6757              	.LVL768:
2518:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6758              		.loc 1 2518 0
 6759 3a00 9540CDE5 		strb	r4, [sp, #149]
2520:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6760              		.loc 1 2520 0
 6761 3a04 84408DE5 		str	r4, [sp, #132]
2521:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6762              		.loc 1 2521 0
 6763 3a08 88408DE5 		str	r4, [sp, #136]
2516:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6764              		.loc 1 2516 0
 6765 3a0c 90208DE5 		str	r2, [sp, #144]
2517:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6766              		.loc 1 2517 0
 6767 3a10 9430CDE5 		strb	r3, [sp, #148]
2519:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6768              		.loc 1 2519 0
 6769 3a14 80308DE5 		str	r3, [sp, #128]
2522:../uvc.c      **** 
 6770              		.loc 1 2522 0
 6771 3a18 8C308DE5 		str	r3, [sp, #140]
2525:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6772              		.loc 1 2525 0
 6773 3a1c FEFFFFEB 		bl	CyU3PUartSetConfig
 6774              	.LVL769:
2526:../uvc.c      ****     {
 6775              		.loc 1 2526 0
 6776 3a20 000050E3 		cmp	r0, #0
 6777 3a24 2D02001A 		bne	.L613
2532:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6778              		.loc 1 2532 0
 6779 3a28 0000E0E3 		mvn	r0, #0
 6780              	.LVL770:
 6781 3a2c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6782              	.LVL771:
2533:../uvc.c      ****     {
 6783              		.loc 1 2533 0
 6784 3a30 000050E3 		cmp	r0, #0
 6785 3a34 2902001A 		bne	.L613
2539:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6786              		.loc 1 2539 0
 6787 3a38 0300A0E3 		mov	r0, #3
 6788              	.LVL772:
 6789 3a3c 0410A0E3 		mov	r1, #4
 6790 3a40 FEFFFFEB 		bl	CyU3PDebugInit
 6791              	.LVL773:
2540:../uvc.c      ****     {
 6792              		.loc 1 2540 0
 6793 3a44 000050E3 		cmp	r0, #0
 6794 3a48 2402001A 		bne	.L613
2546:../uvc.c      **** }
 6795              		.loc 1 2546 0
 6796 3a4c FEFFFFEB 		bl	CyU3PDebugPreamble
 6797              	.LVL774:
 6798 3a50 0640A0E3 		mov	r4, #6
 6799              	.LVL775:
 6800              	.L529:
 6801              	.LBE120:
 6802              	.LBE119:
3068:../uvc.c      **** 	}
 6803              		.loc 1 3068 0
 6804 3a54 7D0FA0E3 		mov	r0, #500
 6805 3a58 014044E2 		sub	r4, r4, #1
 6806 3a5c FEFFFFEB 		bl	_tx_thread_sleep
 6807              	.LVL776:
3067:../uvc.c      **** 		CyU3PThreadSleep(500);
 6808              		.loc 1 3067 0
 6809 3a60 FF4014E2 		ands	r4, r4, #255
 6810 3a64 FAFFFF1A 		bne	.L529
 6811              	.LBB122:
 6812              	.LBB123:
2556:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6813              		.loc 1 2556 0
 6814 3a68 FEFFFFEB 		bl	CyU3PI2cInit
 6815              	.LVL777:
2557:../uvc.c      ****     {
 6816              		.loc 1 2557 0
 6817 3a6c 005050E2 		subs	r5, r0, #0
 6818 3a70 0303001A 		bne	.L616
2564:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6819              		.loc 1 2564 0
 6820 3a74 502C9FE5 		ldr	r2, .L650+4
2566:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6821              		.loc 1 2566 0
 6822 3a78 0030E0E3 		mvn	r3, #0
2569:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6823              		.loc 1 2569 0
 6824 3a7c 80008DE2 		add	r0, sp, #128
 6825              	.LVL778:
 6826 3a80 0410A0E1 		mov	r1, r4
2565:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6827              		.loc 1 2565 0
 6828 3a84 84408DE5 		str	r4, [sp, #132]
2564:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6829              		.loc 1 2564 0
 6830 3a88 80208DE5 		str	r2, [sp, #128]
2566:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6831              		.loc 1 2566 0
 6832 3a8c 88308DE5 		str	r3, [sp, #136]
2567:../uvc.c      **** 
 6833              		.loc 1 2567 0
 6834 3a90 BC38CDE1 		strh	r3, [sp, #140]	@ movhi
2569:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6835              		.loc 1 2569 0
 6836 3a94 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6837              	.LVL779:
2570:../uvc.c      ****     {
 6838              		.loc 1 2570 0
 6839 3a98 005050E2 		subs	r5, r0, #0
 6840 3a9c F302001A 		bne	.L617
 6841              	.LBE123:
 6842              	.LBE122:
 6843              	.LBB125:
 6844              	.LBB126:
2643:../uvc.c      ****     if (apiRetStatus != 0)
 6845              		.loc 1 2643 0
 6846 3aa0 287C9FE5 		ldr	r7, .L650+8
 6847 3aa4 0410A0E1 		mov	r1, r4
 6848 3aa8 0700A0E1 		mov	r0, r7
 6849              	.LVL780:
 6850 3aac 2820A0E3 		mov	r2, #40
 6851 3ab0 FEFFFFEB 		bl	_txe_event_flags_create
 6852              	.LVL781:
2644:../uvc.c      ****     {
 6853              		.loc 1 2644 0
 6854 3ab4 005050E2 		subs	r5, r0, #0
 6855              	.LVL782:
 6856 3ab8 E602001A 		bne	.L618
2658:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6857              		.loc 1 2658 0
 6858 3abc 0230A0E3 		mov	r3, #2
2661:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6859              		.loc 1 2661 0
 6860 3ac0 0320A0E3 		mov	r2, #3
2665:../uvc.c      ****     if (apiRetStatus != 0)
 6861              		.loc 1 2665 0
 6862 3ac4 14008DE2 		add	r0, sp, #20
 6863              	.LVL783:
 6864 3ac8 0410A0E1 		mov	r1, r4
2654:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6865              		.loc 1 2654 0
 6866 3acc 104187E5 		str	r4, [r7, #272]
2655:../uvc.c      **** 
 6867              		.loc 1 2655 0
 6868 3ad0 744087E5 		str	r4, [r7, #116]
2660:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6869              		.loc 1 2660 0
 6870 3ad4 1C40CDE5 		strb	r4, [sp, #28]
2662:../uvc.c      **** 
 6871              		.loc 1 2662 0
 6872 3ad8 18408DE5 		str	r4, [sp, #24]
2658:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6873              		.loc 1 2658 0
 6874 3adc 1430CDE5 		strb	r3, [sp, #20]
2659:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6875              		.loc 1 2659 0
 6876 3ae0 1530CDE5 		strb	r3, [sp, #21]
2661:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6877              		.loc 1 2661 0
 6878 3ae4 1D20CDE5 		strb	r2, [sp, #29]
2665:../uvc.c      ****     if (apiRetStatus != 0)
 6879              		.loc 1 2665 0
 6880 3ae8 FEFFFFEB 		bl	CyU3PGpioInit
 6881              	.LVL784:
2666:../uvc.c      ****     {
 6882              		.loc 1 2666 0
 6883 3aec 005050E2 		subs	r5, r0, #0
 6884 3af0 D202001A 		bne	.L619
2674:../uvc.c      ****     if (apiRetStatus != 0)
 6885              		.loc 1 2674 0
 6886 3af4 1600A0E3 		mov	r0, #22
 6887              	.LVL785:
 6888 3af8 0110A0E3 		mov	r1, #1
 6889 3afc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6890              	.LVL786:
2675:../uvc.c      ****     {
 6891              		.loc 1 2675 0
 6892 3b00 005050E2 		subs	r5, r0, #0
 6893 3b04 BC02001A 		bne	.L620
2680:../uvc.c      ****     if (apiRetStatus != 0)
 6894              		.loc 1 2680 0
 6895 3b08 1400A0E3 		mov	r0, #20
 6896              	.LVL787:
 6897 3b0c 0110A0E3 		mov	r1, #1
 6898 3b10 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6899              	.LVL788:
2681:../uvc.c      ****     {
 6900              		.loc 1 2681 0
 6901 3b14 005050E2 		subs	r5, r0, #0
 6902 3b18 5902001A 		bne	.L621
2686:../uvc.c      ****     if (apiRetStatus != 0)
 6903              		.loc 1 2686 0
 6904 3b1c 1800A0E3 		mov	r0, #24
 6905              	.LVL789:
 6906 3b20 0110A0E3 		mov	r1, #1
 6907 3b24 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6908              	.LVL790:
2687:../uvc.c      ****     {
 6909              		.loc 1 2687 0
 6910 3b28 005050E2 		subs	r5, r0, #0
 6911 3b2c DF02001A 		bne	.L622
2694:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6912              		.loc 1 2694 0
 6913 3b30 0150A0E3 		mov	r5, #1
2699:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6914              		.loc 1 2699 0
 6915 3b34 34108DE2 		add	r1, sp, #52
 6916 3b38 1600A0E3 		mov	r0, #22
 6917              	.LVL791:
2697:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6918              		.loc 1 2697 0
 6919 3b3c 40408DE5 		str	r4, [sp, #64]
2698:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6920              		.loc 1 2698 0
 6921 3b40 4440CDE5 		strb	r4, [sp, #68]
2694:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6922              		.loc 1 2694 0
 6923 3b44 34508DE5 		str	r5, [sp, #52]
2695:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6924              		.loc 1 2695 0
 6925 3b48 38508DE5 		str	r5, [sp, #56]
2696:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6926              		.loc 1 2696 0
 6927 3b4c 3C508DE5 		str	r5, [sp, #60]
2699:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6928              		.loc 1 2699 0
 6929 3b50 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6930              	.LVL792:
2700:../uvc.c      ****     {
 6931              		.loc 1 2700 0
 6932 3b54 008050E2 		subs	r8, r0, #0
 6933 3b58 9002001A 		bne	.L623
2713:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6934              		.loc 1 2713 0
 6935 3b5c 1400A0E3 		mov	r0, #20
 6936              	.LVL793:
 6937 3b60 34108DE2 		add	r1, sp, #52
2711:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6938              		.loc 1 2711 0
 6939 3b64 40408DE5 		str	r4, [sp, #64]
2712:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6940              		.loc 1 2712 0
 6941 3b68 4440CDE5 		strb	r4, [sp, #68]
2708:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6942              		.loc 1 2708 0
 6943 3b6c 34508DE5 		str	r5, [sp, #52]
2709:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6944              		.loc 1 2709 0
 6945 3b70 38508DE5 		str	r5, [sp, #56]
2710:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6946              		.loc 1 2710 0
 6947 3b74 3C508DE5 		str	r5, [sp, #60]
2713:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6948              		.loc 1 2713 0
 6949 3b78 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6950              	.LVL794:
2714:../uvc.c      ****     {
 6951              		.loc 1 2714 0
 6952 3b7c 004050E2 		subs	r4, r0, #0
 6953 3b80 8002001A 		bne	.L624
2722:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6954              		.loc 1 2722 0
 6955 3b84 0030A0E3 		mov	r3, #0
2727:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6956              		.loc 1 2727 0
 6957 3b88 34108DE2 		add	r1, sp, #52
2725:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6958              		.loc 1 2725 0
 6959 3b8c 0150A0E3 		mov	r5, #1
2727:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6960              		.loc 1 2727 0
 6961 3b90 1800A0E3 		mov	r0, #24
 6962              	.LVL795:
2722:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6963              		.loc 1 2722 0
 6964 3b94 34308DE5 		str	r3, [sp, #52]
2723:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6965              		.loc 1 2723 0
 6966 3b98 38308DE5 		str	r3, [sp, #56]
2724:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6967              		.loc 1 2724 0
 6968 3b9c 3C308DE5 		str	r3, [sp, #60]
2726:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6969              		.loc 1 2726 0
 6970 3ba0 4430CDE5 		strb	r3, [sp, #68]
2725:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6971              		.loc 1 2725 0
 6972 3ba4 40508DE5 		str	r5, [sp, #64]
2727:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6973              		.loc 1 2727 0
 6974 3ba8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6975              	.LVL796:
2728:../uvc.c      ****     {
 6976              		.loc 1 2728 0
 6977 3bac 004050E2 		subs	r4, r0, #0
 6978 3bb0 6E02001A 		bne	.L625
2735:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6979              		.loc 1 2735 0
 6980 3bb4 0280A0E3 		mov	r8, #2
2736:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6981              		.loc 1 2736 0
 6982 3bb8 03A0A0E3 		mov	r10, #3
2740:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6983              		.loc 1 2740 0
 6984 3bbc 0500A0E1 		mov	r0, r5
 6985              	.LVL797:
 6986 3bc0 20108DE2 		add	r1, sp, #32
2737:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6987              		.loc 1 2737 0
 6988 3bc4 28408DE5 		str	r4, [sp, #40]
2738:../uvc.c      **** 
 6989              		.loc 1 2738 0
 6990 3bc8 24408DE5 		str	r4, [sp, #36]
2735:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6991              		.loc 1 2735 0
 6992 3bcc B082CDE1 		strh	r8, [sp, #32]	@ movhi
2736:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6993              		.loc 1 2736 0
 6994 3bd0 2CA0CDE5 		strb	r10, [sp, #44]
2740:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6995              		.loc 1 2740 0
 6996 3bd4 FEFFFFEB 		bl	CyU3PPibInit
 6997              	.LVL798:
2741:../uvc.c      ****     {
 6998              		.loc 1 2741 0
 6999 3bd8 004050E2 		subs	r4, r0, #0
 7000 3bdc 5D02001A 		bne	.L626
2748:../uvc.c      **** 
 7001              		.loc 1 2748 0
 7002 3be0 EC0A9FE5 		ldr	r0, .L650+12
 7003              	.LVL799:
 7004 3be4 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7005              	.LVL800:
2756:../uvc.c      ****     CyU3PThreadSleep(5000);
 7006              		.loc 1 2756 0
 7007 3be8 FEFFFFEB 		bl	SensorReset
 7008              	.LVL801:
2757:../uvc.c      ****     //SensorInit ();
 7009              		.loc 1 2757 0
 7010 3bec E40A9FE5 		ldr	r0, .L650+16
 7011 3bf0 FEFFFFEB 		bl	_tx_thread_sleep
 7012              	.LVL802:
2761:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7013              		.loc 1 2761 0
 7014 3bf4 FEFFFFEB 		bl	CyU3PUsbStart
 7015              	.LVL803:
2762:../uvc.c      ****     {
 7016              		.loc 1 2762 0
 7017 3bf8 004050E2 		subs	r4, r0, #0
 7018 3bfc A502001A 		bne	.L627
2768:../uvc.c      **** 
 7019              		.loc 1 2768 0
 7020 3c00 0410A0E1 		mov	r1, r4
 7021 3c04 D00A9FE5 		ldr	r0, .L650+20
 7022              	.LVL804:
 7023 3c08 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7024              	.LVL805:
2771:../uvc.c      **** 
 7025              		.loc 1 2771 0
 7026 3c0c CC0A9FE5 		ldr	r0, .L650+24
 7027 3c10 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 7028              	.LVL806:
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7029              		.loc 1 2777 0
 7030 3c14 0410A0E1 		mov	r1, r4
 7031 3c18 C42A9FE5 		ldr	r2, .L650+28
 7032 3c1c 0500A0E1 		mov	r0, r5
 7033 3c20 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7034              	.LVL807:
2778:../uvc.c      **** 
 7035              		.loc 1 2778 0
 7036 3c24 0410A0E1 		mov	r1, r4
 7037 3c28 0400A0E1 		mov	r0, r4
 7038 3c2c B42A9FE5 		ldr	r2, .L650+32
 7039 3c30 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7040              	.LVL808:
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7041              		.loc 1 2781 0
 7042 3c34 0410A0E1 		mov	r1, r4
 7043 3c38 AC2A9FE5 		ldr	r2, .L650+36
 7044 3c3c 0800A0E1 		mov	r0, r8
 7045 3c40 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7046              	.LVL809:
2782:../uvc.c      **** 
 7047              		.loc 1 2782 0
 7048 3c44 0410A0E1 		mov	r1, r4
 7049 3c48 A02A9FE5 		ldr	r2, .L650+40
 7050 3c4c 0700A0E3 		mov	r0, #7
 7051 3c50 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7052              	.LVL810:
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7053              		.loc 1 2785 0
 7054 3c54 0410A0E1 		mov	r1, r4
 7055 3c58 942A9FE5 		ldr	r2, .L650+44
 7056 3c5c 0400A0E3 		mov	r0, #4
 7057 3c60 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7058              	.LVL811:
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7059              		.loc 1 2786 0
 7060 3c64 0410A0E1 		mov	r1, r4
 7061 3c68 882A9FE5 		ldr	r2, .L650+48
 7062 3c6c 0A00A0E1 		mov	r0, r10
 7063 3c70 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7064              	.LVL812:
2787:../uvc.c      **** 
 7065              		.loc 1 2787 0
 7066 3c74 0410A0E1 		mov	r1, r4
 7067 3c78 7C2A9FE5 		ldr	r2, .L650+52
 7068 3c7c 0600A0E3 		mov	r0, #6
 7069 3c80 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7070              	.LVL813:
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7071              		.loc 1 2790 0
 7072 3c84 0410A0E1 		mov	r1, r4
 7073 3c88 702A9FE5 		ldr	r2, .L650+56
 7074 3c8c 0500A0E3 		mov	r0, #5
 7075 3c90 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7076              	.LVL814:
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7077              		.loc 1 2791 0
 7078 3c94 0510A0E1 		mov	r1, r5
 7079 3c98 642A9FE5 		ldr	r2, .L650+60
 7080 3c9c 0500A0E3 		mov	r0, #5
 7081 3ca0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7082              	.LVL815:
2792:../uvc.c      **** 
 7083              		.loc 1 2792 0
 7084 3ca4 0810A0E1 		mov	r1, r8
 7085 3ca8 582A9FE5 		ldr	r2, .L650+64
 7086 3cac 0500A0E3 		mov	r0, #5
 7087 3cb0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 7088              	.LVL816:
2801:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7089              		.loc 1 2801 0
 7090 3cb4 4030A0E3 		mov	r3, #64
2805:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7091              		.loc 1 2805 0
 7092 3cb8 08108DE2 		add	r1, sp, #8
 7093 3cbc 8200A0E3 		mov	r0, #130
2802:../uvc.c      ****     endPointConfig.streams  = 0;
 7094              		.loc 1 2802 0
 7095 3cc0 1340CDE5 		strb	r4, [sp, #19]
2803:../uvc.c      ****     endPointConfig.burstLen = 1;
 7096              		.loc 1 2803 0
 7097 3cc4 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2799:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7098              		.loc 1 2799 0
 7099 3cc8 08508DE5 		str	r5, [sp, #8]
2800:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7100              		.loc 1 2800 0
 7101 3ccc 0CA0CDE5 		strb	r10, [sp, #12]
2804:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7102              		.loc 1 2804 0
 7103 3cd0 1250CDE5 		strb	r5, [sp, #18]
2801:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7104              		.loc 1 2801 0
 7105 3cd4 B031CDE1 		strh	r3, [sp, #16]	@ movhi
2805:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7106              		.loc 1 2805 0
 7107 3cd8 FEFFFFEB 		bl	CyU3PSetEpConfig
 7108              	.LVL817:
2806:../uvc.c      ****     {
 7109              		.loc 1 2806 0
 7110 3cdc 004050E2 		subs	r4, r0, #0
 7111 3ce0 1002001A 		bne	.L614
2814:../uvc.c      ****     dmaInterConfig.count          = 1;
 7112              		.loc 1 2814 0
 7113 3ce4 203A9FE5 		ldr	r3, .L650+68
 7114 3ce8 41BBA0E3 		mov	fp, #66560
2823:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7115              		.loc 1 2823 0
 7116 3cec 1090A0E3 		mov	r9, #16
2825:../uvc.c      ****             &dmaInterConfig);
 7117              		.loc 1 2825 0
 7118 3cf0 180A9FE5 		ldr	r0, .L650+72
 7119              	.LVL818:
 7120 3cf4 0410A0E3 		mov	r1, #4
 7121 3cf8 48208DE2 		add	r2, sp, #72
2814:../uvc.c      ****     dmaInterConfig.count          = 1;
 7122              		.loc 1 2814 0
 7123 3cfc 50408DE5 		str	r4, [sp, #80]
 7124 3d00 54408DE5 		str	r4, [sp, #84]
2822:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7125              		.loc 1 2822 0
 7126 3d04 5840CDE5 		strb	r4, [sp, #88]
2824:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7127              		.loc 1 2824 0
 7128 3d08 60408DE5 		str	r4, [sp, #96]
2814:../uvc.c      ****     dmaInterConfig.count          = 1;
 7129              		.loc 1 2814 0
 7130 3d0c 4C308DE5 		str	r3, [sp, #76]
 7131 3d10 48B08DE5 		str	fp, [sp, #72]
2823:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7132              		.loc 1 2823 0
 7133 3d14 5C908DE5 		str	r9, [sp, #92]
2825:../uvc.c      ****             &dmaInterConfig);
 7134              		.loc 1 2825 0
 7135 3d18 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7136              	.LVL819:
2827:../uvc.c      ****     {
 7137              		.loc 1 2827 0
 7138 3d1c 004050E2 		subs	r4, r0, #0
 7139 3d20 FA01001A 		bne	.L628
2834:../uvc.c      ****     if (glInterStaBuffer == 0)
 7140              		.loc 1 2834 0
 7141 3d24 010BA0E3 		mov	r0, #1024
 7142              	.LVL820:
 7143 3d28 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7144              	.LVL821:
 7145 3d2c E0399FE5 		ldr	r3, .L650+76
2835:../uvc.c      ****     {
 7146              		.loc 1 2835 0
 7147 3d30 000050E3 		cmp	r0, #0
2834:../uvc.c      ****     if (glInterStaBuffer == 0)
 7148              		.loc 1 2834 0
 7149 3d34 000083E5 		str	r0, [r3]
2835:../uvc.c      ****     {
 7150              		.loc 1 2835 0
 7151 3d38 EF01000A 		beq	.L629
2842:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7152              		.loc 1 2842 0
 7153 3d3c 0410A0E1 		mov	r1, r4
 7154 3d40 0420A0E1 		mov	r2, r4
 7155 3d44 3830A0E3 		mov	r3, #56
 7156 3d48 C8099FE5 		ldr	r0, .L650+80
 7157 3d4c FEFFFFEB 		bl	_txe_mutex_create
 7158              	.LVL822:
2847:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7159              		.loc 1 2847 0
 7160 3d50 C4399FE5 		ldr	r3, .L650+84
2848:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7161              		.loc 1 2848 0
 7162 3d54 C4099FE5 		ldr	r0, .L650+88
2855:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7163              		.loc 1 2855 0
 7164 3d58 C4199FE5 		ldr	r1, .L650+92
2843:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7165              		.loc 1 2843 0
 7166 3d5c 0129A0E3 		mov	r2, #16384
2844:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7167              		.loc 1 2844 0
 7168 3d60 0490A0E3 		mov	r9, #4
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7169              		.loc 1 2846 0
 7170 3d64 01ECA0E3 		mov	lr, #256
2850:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7171              		.loc 1 2850 0
 7172 3d68 0CC0A0E3 		mov	ip, #12
2847:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7173              		.loc 1 2847 0
 7174 3d6c B838CDE1 		strh	r3, [sp, #136]	@ movhi
2848:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7175              		.loc 1 2848 0
 7176 3d70 BE08CDE1 		strh	r0, [sp, #142]	@ movhi
2854:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7177              		.loc 1 2854 0
 7178 3d74 1830A0E3 		mov	r3, #24
2855:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7179              		.loc 1 2855 0
 7180 3d78 A4108DE5 		str	r1, [sp, #164]
2843:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7181              		.loc 1 2843 0
 7182 3d7c B028CDE1 		strh	r2, [sp, #128]	@ movhi
2856:../uvc.c      ****             &dmaMultiConfig);
 7183              		.loc 1 2856 0
 7184 3d80 A0099FE5 		ldr	r0, .L650+96
 7185 3d84 0710A0E3 		mov	r1, #7
 7186 3d88 80208DE2 		add	r2, sp, #128
2849:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7187              		.loc 1 2849 0
 7188 3d8c B649CDE1 		strh	r4, [sp, #150]	@ movhi
2852:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7189              		.loc 1 2852 0
 7190 3d90 BC49CDE1 		strh	r4, [sp, #156]	@ movhi
2853:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7191              		.loc 1 2853 0
 7192 3d94 9E40CDE5 		strb	r4, [sp, #158]
2845:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7193              		.loc 1 2845 0
 7194 3d98 B488CDE1 		strh	r8, [sp, #132]	@ movhi
2844:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7195              		.loc 1 2844 0
 7196 3d9c B298CDE1 		strh	r9, [sp, #130]	@ movhi
2851:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7197              		.loc 1 2851 0
 7198 3da0 BA99CDE1 		strh	r9, [sp, #154]	@ movhi
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7199              		.loc 1 2846 0
 7200 3da4 B6E8CDE1 		strh	lr, [sp, #134]	@ movhi
2850:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7201              		.loc 1 2850 0
 7202 3da8 B8C9CDE1 		strh	ip, [sp, #152]	@ movhi
2854:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7203              		.loc 1 2854 0
 7204 3dac A0308DE5 		str	r3, [sp, #160]
2856:../uvc.c      ****             &dmaMultiConfig);
 7205              		.loc 1 2856 0
 7206 3db0 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7207              	.LVL823:
2858:../uvc.c      ****     {
 7208              		.loc 1 2858 0
 7209 3db4 004050E2 		subs	r4, r0, #0
 7210 3db8 C901001A 		bne	.L630
2874:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7211              		.loc 1 2874 0
 7212 3dbc 013BA0E3 		mov	r3, #1024
2879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7213              		.loc 1 2879 0
 7214 3dc0 0900A0E1 		mov	r0, r9
 7215              	.LVL824:
 7216 3dc4 08108DE2 		add	r1, sp, #8
2875:../uvc.c      ****     endPointConfig.streams  = 0;
 7217              		.loc 1 2875 0
 7218 3dc8 1340CDE5 		strb	r4, [sp, #19]
2876:../uvc.c      ****     endPointConfig.burstLen = 1;
 7219              		.loc 1 2876 0
 7220 3dcc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2872:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7221              		.loc 1 2872 0
 7222 3dd0 08508DE5 		str	r5, [sp, #8]
2873:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
 7223              		.loc 1 2873 0
 7224 3dd4 0C80CDE5 		strb	r8, [sp, #12]
2877:../uvc.c      **** 
 7225              		.loc 1 2877 0
 7226 3dd8 1250CDE5 		strb	r5, [sp, #18]
2874:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7227              		.loc 1 2874 0
 7228 3ddc B031CDE1 		strh	r3, [sp, #16]	@ movhi
2879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7229              		.loc 1 2879 0
 7230 3de0 FEFFFFEB 		bl	CyU3PSetEpConfig
 7231              	.LVL825:
2880:../uvc.c      ****     {
 7232              		.loc 1 2880 0
 7233 3de4 004050E2 		subs	r4, r0, #0
 7234 3de8 B701001A 		bne	.L631
2886:../uvc.c      **** 
 7235              		.loc 1 2886 0
 7236 3dec 0510A0E1 		mov	r1, r5
 7237 3df0 0900A0E1 		mov	r0, r9
 7238              	.LVL826:
 7239 3df4 FEFFFFEB 		bl	CyU3PUsbSetEpPktMode
 7240              	.LVL827:
2888:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7241              		.loc 1 2888 0
 7242 3df8 8400A0E3 		mov	r0, #132
 7243 3dfc 08108DE2 		add	r1, sp, #8
 7244 3e00 FEFFFFEB 		bl	CyU3PSetEpConfig
 7245              	.LVL828:
2889:../uvc.c      ****     {
 7246              		.loc 1 2889 0
 7247 3e04 004050E2 		subs	r4, r0, #0
 7248 3e08 A901001A 		bne	.L632
2895:../uvc.c      ****     channelConfig.count          = 1;
 7249              		.loc 1 2895 0
 7250 3e0c 18E99FE5 		ldr	lr, .L650+100
2905:../uvc.c      **** 
 7251              		.loc 1 2905 0
 7252 3e10 18C99FE5 		ldr	ip, .L650+104
2904:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 7253              		.loc 1 2904 0
 7254 3e14 0830A0E3 		mov	r3, #8
2907:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7255              		.loc 1 2907 0
 7256 3e18 0A10A0E1 		mov	r1, r10
 7257 3e1c 64208DE2 		add	r2, sp, #100
 7258 3e20 0C099FE5 		ldr	r0, .L650+108
 7259              	.LVL829:
2895:../uvc.c      ****     channelConfig.count          = 1;
 7260              		.loc 1 2895 0
 7261 3e24 6C408DE5 		str	r4, [sp, #108]
 7262 3e28 70408DE5 		str	r4, [sp, #112]
2903:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
 7263              		.loc 1 2903 0
 7264 3e2c 7440CDE5 		strb	r4, [sp, #116]
2895:../uvc.c      ****     channelConfig.count          = 1;
 7265              		.loc 1 2895 0
 7266 3e30 64B08DE5 		str	fp, [sp, #100]
 7267 3e34 68E08DE5 		str	lr, [sp, #104]
2905:../uvc.c      **** 
 7268              		.loc 1 2905 0
 7269 3e38 7CC08DE5 		str	ip, [sp, #124]
2904:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 7270              		.loc 1 2904 0
 7271 3e3c 78308DE5 		str	r3, [sp, #120]
2907:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7272              		.loc 1 2907 0
 7273 3e40 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7274              	.LVL830:
2908:../uvc.c      ****     {
 7275              		.loc 1 2908 0
 7276 3e44 004050E2 		subs	r4, r0, #0
 7277 3e48 9301001A 		bne	.L633
2914:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7278              		.loc 1 2914 0
 7279 3e4c E0089FE5 		ldr	r0, .L650+108
 7280              	.LVL831:
 7281 3e50 0010A0E3 		mov	r1, #0
 7282 3e54 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 7283              	.LVL832:
2915:../uvc.c      ****     {
 7284              		.loc 1 2915 0
 7285 3e58 004050E2 		subs	r4, r0, #0
 7286 3e5c DB01001A 		bne	.L634
2921:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 7287              		.loc 1 2921 0
 7288 3e60 D0389FE5 		ldr	r3, .L650+112
2933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7289              		.loc 1 2933 0
 7290 3e64 64208DE2 		add	r2, sp, #100
2921:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 7291              		.loc 1 2921 0
 7292 3e68 015BA0E3 		mov	r5, #1024
2933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7293              		.loc 1 2933 0
 7294 3e6c C8089FE5 		ldr	r0, .L650+116
 7295              	.LVL833:
 7296 3e70 0410A0E3 		mov	r1, #4
2921:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 7297              		.loc 1 2921 0
 7298 3e74 6C408DE5 		str	r4, [sp, #108]
 7299 3e78 70408DE5 		str	r4, [sp, #112]
2929:../uvc.c      ****     channelConfig.notification   = 0;
 7300              		.loc 1 2929 0
 7301 3e7c 7440CDE5 		strb	r4, [sp, #116]
2930:../uvc.c      ****     channelConfig.cb             = 0;
 7302              		.loc 1 2930 0
 7303 3e80 78408DE5 		str	r4, [sp, #120]
2931:../uvc.c      **** 
 7304              		.loc 1 2931 0
 7305 3e84 7C408DE5 		str	r4, [sp, #124]
2921:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 7306              		.loc 1 2921 0
 7307 3e88 68308DE5 		str	r3, [sp, #104]
 7308 3e8c 64508DE5 		str	r5, [sp, #100]
2933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7309              		.loc 1 2933 0
 7310 3e90 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7311              	.LVL834:
2934:../uvc.c      ****     {
 7312              		.loc 1 2934 0
 7313 3e94 004050E2 		subs	r4, r0, #0
 7314 3e98 C601001A 		bne	.L635
2940:../uvc.c      ****     if (glDebugRspBuffer == 0)
 7315              		.loc 1 2940 0
 7316 3e9c 0500A0E1 		mov	r0, r5
 7317              	.LVL835:
 7318 3ea0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7319              	.LVL836:
 7320 3ea4 94389FE5 		ldr	r3, .L650+120
2941:../uvc.c      ****     {
 7321              		.loc 1 2941 0
 7322 3ea8 000050E3 		cmp	r0, #0
2940:../uvc.c      ****     if (glDebugRspBuffer == 0)
 7323              		.loc 1 2940 0
 7324 3eac 000083E5 		str	r0, [r3]
2941:../uvc.c      ****     {
 7325              		.loc 1 2941 0
 7326 3eb0 CC01000A 		beq	.L636
2949:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7327              		.loc 1 2949 0
 7328 3eb4 0100A0E3 		mov	r0, #1
 7329 3eb8 0010A0E1 		mov	r1, r0
 7330 3ebc FEFFFFEB 		bl	CyU3PConnectState
 7331              	.LVL837:
2950:../uvc.c      ****     {
 7332              		.loc 1 2950 0
 7333 3ec0 004050E2 		subs	r4, r0, #0
 7334 3ec4 9D01001A 		bne	.L637
2956:../uvc.c      **** 
 7335              		.loc 1 2956 0
 7336 3ec8 6400A0E3 		mov	r0, #100
 7337              	.LVL838:
 7338 3ecc FEFFFFEB 		bl	CyFx3BusyWait
 7339              	.LVL839:
2958:../uvc.c      **** 
 7340              		.loc 1 2958 0
 7341 3ed0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7342              	.LVL840:
2960:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7343              		.loc 1 2960 0
 7344 3ed4 01C0A0E3 		mov	ip, #1
2961:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7345              		.loc 1 2961 0
 7346 3ed8 0220A0E3 		mov	r2, #2
2973:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7347              		.loc 1 2973 0
 7348 3edc 08108DE2 		add	r1, sp, #8
2972:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7349              		.loc 1 2972 0
 7350 3ee0 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2960:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7351              		.loc 1 2960 0
 7352 3ee4 08C08DE5 		str	ip, [sp, #8]
2961:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7353              		.loc 1 2961 0
 7354 3ee8 0C20CDE5 		strb	r2, [sp, #12]
2965:../uvc.c      ****     }
 7355              		.loc 1 2965 0
 7356 3eec 030050E3 		cmp	r0, #3
2958:../uvc.c      **** 
 7357              		.loc 1 2958 0
 7358 3ef0 0030A0E1 		mov	r3, r0
2965:../uvc.c      ****     }
 7359              		.loc 1 2965 0
 7360 3ef4 0150A013 		movne	r5, #1
 7361 3ef8 1050A003 		moveq	r5, #16
 7362 3efc 02ECA013 		movne	lr, #512
 7363 3f00 01EBA003 		moveq	lr, #1024
2973:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7364              		.loc 1 2973 0
 7365 3f04 8300A0E3 		mov	r0, #131
2958:../uvc.c      **** 
 7366              		.loc 1 2958 0
 7367 3f08 4830C7E5 		strb	r3, [r7, #72]
 7368 3f0c 1250CDE5 		strb	r5, [sp, #18]
 7369 3f10 B0E1CDE1 		strh	lr, [sp, #16]	@ movhi
2973:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7370              		.loc 1 2973 0
 7371 3f14 FEFFFFEB 		bl	CyU3PSetEpConfig
 7372              	.LVL841:
2974:../uvc.c      ****     {
 7373              		.loc 1 2974 0
 7374 3f18 004050E2 		subs	r4, r0, #0
 7375              	.LBE126:
 7376              	.LBE125:
3097:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7377              		.loc 1 3097 0
 7378 3f1c AC479F05 		ldreq	r4, .L650+8
 7379              	.LBB131:
 7380              	.LBB127:
2974:../uvc.c      ****     {
 7381              		.loc 1 2974 0
 7382 3f20 0F00000A 		beq	.L590
 7383 3f24 7F0100EA 		b	.L614
 7384              	.LVL842:
 7385              	.L639:
 7386              	.LBE127:
 7387              	.LBE131:
3100:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 7388              		.loc 1 3100 0
 7389 3f28 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
3146:../uvc.c      ****             {
 7390              		.loc 1 3146 0
 7391 3f2c 88C094E5 		ldr	ip, [r4, #136]
3101:../uvc.c      ****         	//CyU3PDebugPrint (4, "stream ready %x\n", apiRetStatus);
 7392              		.loc 1 3101 0
 7393 3f30 011083E3 		orr	r1, r3, #1
3146:../uvc.c      ****             {
 7394              		.loc 1 3146 0
 7395 3f34 05005CE1 		cmp	ip, r5
3101:../uvc.c      ****         	//CyU3PDebugPrint (4, "stream ready %x\n", apiRetStatus);
 7396              		.loc 1 3101 0
 7397 3f38 9110C4E5 		strb	r1, [r4, #145]
3146:../uvc.c      ****             {
 7398              		.loc 1 3146 0
 7399 3f3c 0300000A 		beq	.L556
3146:../uvc.c      ****             {
 7400              		.loc 1 3146 0 is_stmt 0 discriminator 1
 7401 3f40 BC18D4E1 		ldrh	r1, [r4, #140]
 7402 3f44 BE28D4E1 		ldrh	r2, [r4, #142]
 7403 3f48 020051E1 		cmp	r1, r2
 7404 3f4c 6600000A 		beq	.L638
 7405              	.LVL843:
 7406              	.L556:
3404:../uvc.c      **** 
 7407              		.loc 1 3404 0 is_stmt 1
 7408 3f50 4010A0E3 		mov	r1, #64
 7409 3f54 0020A0E3 		mov	r2, #0
 7410 3f58 70079FE5 		ldr	r0, .L650+8
 7411 3f5c FEFFFFEB 		bl	_txe_event_flags_set
 7412              	.LVL844:
3407:../uvc.c      ****     }
 7413              		.loc 1 3407 0
 7414 3f60 FEFFFFEB 		bl	_txe_thread_relinquish
 7415              	.LVL845:
 7416              	.L590:
3097:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7417              		.loc 1 3097 0
 7418 3f64 0050A0E3 		mov	r5, #0
 7419 3f68 00508DE5 		str	r5, [sp]
 7420 3f6c 5C079FE5 		ldr	r0, .L650+8
 7421 3f70 0110A0E3 		mov	r1, #1
 7422 3f74 0220A0E3 		mov	r2, #2
 7423 3f78 80308DE2 		add	r3, sp, #128
 7424 3f7c FEFFFFEB 		bl	_txe_event_flags_get
 7425              	.LVL846:
 7426 3f80 008050E2 		subs	r8, r0, #0
 7427 3f84 E7FFFF0A 		beq	.L639
3259:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7428              		.loc 1 3259 0
 7429 3f88 0320A0E3 		mov	r2, #3
 7430 3f8c 80308DE2 		add	r3, sp, #128
 7431 3f90 00508DE5 		str	r5, [sp]
 7432 3f94 34079FE5 		ldr	r0, .L650+8
 7433 3f98 0210A0E3 		mov	r1, #2
 7434 3f9c FEFFFFEB 		bl	_txe_event_flags_get
 7435              	.LVL847:
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 7436              		.loc 1 3262 0
 7437 3fa0 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
3259:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7438              		.loc 1 3259 0
 7439 3fa4 002050E2 		subs	r2, r0, #0
 7440 3fa8 2200001A 		bne	.L578
3276:../uvc.c      ****                 {
 7441              		.loc 1 3276 0
 7442 3fac 741094E5 		ldr	r1, [r4, #116]
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 7443              		.loc 1 3262 0
 7444 3fb0 7F3003E2 		and	r3, r3, #127
3263:../uvc.c      ****             	hitFV     = CyFalse;
 7445              		.loc 1 3263 0
 7446 3fb4 043083E3 		orr	r3, r3, #4
3276:../uvc.c      ****                 {
 7447              		.loc 1 3276 0
 7448 3fb8 000051E3 		cmp	r1, #0
3264:../uvc.c      ****                 prodCount = 0;
 7449              		.loc 1 3264 0
 7450 3fbc 882084E5 		str	r2, [r4, #136]
3272:../uvc.c      ****                 pb=0;
 7451              		.loc 1 3272 0
 7452 3fc0 B028C4E1 		strh	r2, [r4, #128]	@ movhi
3265:../uvc.c      ****                 consCount = 0;
 7453              		.loc 1 3265 0
 7454 3fc4 BC28C4E1 		strh	r2, [r4, #140]	@ movhi
3273:../uvc.c      ****                 pbc=0;
 7455              		.loc 1 3273 0
 7456 3fc8 B228C4E1 		strh	r2, [r4, #130]	@ movhi
3266:../uvc.c      ****                 if(0&&(prinflag == 0)){
 7457              		.loc 1 3266 0
 7458 3fcc BE28C4E1 		strh	r2, [r4, #142]	@ movhi
3274:../uvc.c      **** 
 7459              		.loc 1 3274 0
 7460 3fd0 B428C4E1 		strh	r2, [r4, #132]	@ movhi
3263:../uvc.c      ****             	hitFV     = CyFalse;
 7461              		.loc 1 3263 0
 7462 3fd4 9130C4E5 		strb	r3, [r4, #145]
3276:../uvc.c      ****                 {
 7463              		.loc 1 3276 0
 7464 3fd8 0800001A 		bne	.L579
3278:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7465              		.loc 1 3278 0
 7466 3fdc 44079FE5 		ldr	r0, .L650+96
 7467 3fe0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7468              	.LVL848:
3279:../uvc.c      ****                     {
 7469              		.loc 1 3279 0
 7470 3fe4 006050E2 		subs	r6, r0, #0
 7471 3fe8 BC00001A 		bne	.L613
3285:../uvc.c      ****                 }else{
 7472              		.loc 1 3285 0
 7473 3fec 8300A0E3 		mov	r0, #131
 7474              	.LVL849:
 7475 3ff0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 7476              	.LVL850:
 7477              	.L581:
3297:../uvc.c      ****             }
 7478              		.loc 1 3297 0 discriminator 1
 7479 3ff4 0030A0E3 		mov	r3, #0
 7480 3ff8 743087E5 		str	r3, [r7, #116]
 7481 3ffc D3FFFFEA 		b	.L556
 7482              	.L579:
3287:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]&0x7F;
 7483              		.loc 1 3287 0
 7484 4000 C8069FE5 		ldr	r0, .L650+8
 7485 4004 011CA0E3 		mov	r1, #256
 7486 4008 FEFFFFEB 		bl	_txe_event_flags_set
 7487              	.LVL851:
3288:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]|0x10;
 7488              		.loc 1 3288 0
 7489 400c 9130D4E5 		ldrb	r3, [r4, #145]	@ zero_extendqisi2
 7490 4010 7F3003E2 		and	r3, r3, #127
3289:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7491              		.loc 1 3289 0
 7492 4014 103083E3 		orr	r3, r3, #16
 7493 4018 9130C4E5 		strb	r3, [r4, #145]
3290:../uvc.c      ****                     {
 7494              		.loc 1 3290 0
 7495 401c 006050E2 		subs	r6, r0, #0
 7496 4020 6B00001A 		bne	.L640
 7497              	.LVL852:
 7498              	.L582:
3294:../uvc.c      ****                 }
 7499              		.loc 1 3294 0
 7500 4024 18179FE5 		ldr	r1, .L650+124
 7501 4028 0620A0E1 		mov	r2, r6
 7502 402c 0400A0E3 		mov	r0, #4
 7503 4030 FEFFFFEB 		bl	CyU3PDebugPrint
 7504              	.LVL853:
 7505 4034 EEFFFFEA 		b	.L581
 7506              	.L578:
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
 7507              		.loc 1 3320 0
 7508 4038 7F3003E2 		and	r3, r3, #127
3321:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 7509              		.loc 1 3321 0
 7510 403c 203083E3 		orr	r3, r3, #32
3322:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
 7511              		.loc 1 3322 0
 7512 4040 00179FE5 		ldr	r1, .L650+128
 7513 4044 0620A0E1 		mov	r2, r6
 7514 4048 0400A0E3 		mov	r0, #4
3321:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 7515              		.loc 1 3321 0
 7516 404c 9130C4E5 		strb	r3, [r4, #145]
3322:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
 7517              		.loc 1 3322 0
 7518 4050 FEFFFFEB 		bl	CyU3PDebugPrint
 7519              	.LVL854:
3323:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
 7520              		.loc 1 3323 0
 7521 4054 0220A0E3 		mov	r2, #2
 7522 4058 00508DE5 		str	r5, [sp]
 7523 405c 6C069FE5 		ldr	r0, .L650+8
 7524 4060 011CA0E3 		mov	r1, #256
 7525 4064 80308DE2 		add	r3, sp, #128
 7526 4068 FEFFFFEB 		bl	_txe_event_flags_get
 7527              	.LVL855:
 7528 406c 002050E2 		subs	r2, r0, #0
 7529 4070 4F00001A 		bne	.L583
3325:../uvc.c      ****             	}
 7530              		.loc 1 3325 0
 7531 4074 54069FE5 		ldr	r0, .L650+8
 7532 4078 0110A0E3 		mov	r1, #1
 7533 407c FEFFFFEB 		bl	_txe_event_flags_set
 7534              	.LVL856:
 7535              	.L584:
3332:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7536              		.loc 1 3332 0
 7537 4080 0620A0E1 		mov	r2, r6
 7538 4084 C0169FE5 		ldr	r1, .L650+132
 7539 4088 0400A0E3 		mov	r0, #4
 7540 408c FEFFFFEB 		bl	CyU3PDebugPrint
 7541              	.LVL857:
3333:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7542              		.loc 1 3333 0
 7543 4090 0010A0E3 		mov	r1, #0
 7544 4094 0120A0E1 		mov	r2, r1
 7545 4098 88069FE5 		ldr	r0, .L650+96
 7546 409c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7547              	.LVL858:
3334:../uvc.c      ****                 {
 7548              		.loc 1 3334 0
 7549 40a0 006050E2 		subs	r6, r0, #0
 7550 40a4 A900001A 		bne	.L641
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 7551              		.loc 1 3340 0
 7552 40a8 9130D7E5 		ldrb	r3, [r7, #145]	@ zero_extendqisi2
3343:../uvc.c      ****                 {
 7553              		.loc 1 3343 0
 7554 40ac 6C2097E5 		ldr	r2, [r7, #108]
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 7555              		.loc 1 3340 0
 7556 40b0 7F3003E2 		and	r3, r3, #127
3341:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
 7557              		.loc 1 3341 0
 7558 40b4 083083E3 		orr	r3, r3, #8
3343:../uvc.c      ****                 {
 7559              		.loc 1 3343 0
 7560 40b8 000052E3 		cmp	r2, #0
3341:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
 7561              		.loc 1 3341 0
 7562 40bc 9130C7E5 		strb	r3, [r7, #145]
3343:../uvc.c      ****                 {
 7563              		.loc 1 3343 0
 7564 40c0 3200001A 		bne	.L577
 7565              	.LVL859:
 7566              	.LBB132:
 7567              	.LBB133:
3002:../uvc.c      ****     {
 7568              		.loc 1 3002 0
 7569 40c4 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7570 40c8 030053E3 		cmp	r3, #3
 7571 40cc 6C00000A 		beq	.L642
3007:../uvc.c      ****     {
 7572              		.loc 1 3007 0
 7573 40d0 020053E3 		cmp	r3, #2
 7574 40d4 8200000A 		beq	.L643
 7575              	.LVL860:
 7576              	.L588:
 7577              	.LBE133:
 7578              	.LBE132:
3391:../uvc.c      ****                     //stream_start = CyTrue;
 7579              		.loc 1 3391 0
 7580 40d8 0130A0E3 		mov	r3, #1
3393:../uvc.c      ****                     
 7581              		.loc 1 3393 0
 7582 40dc C800A0E3 		mov	r0, #200
3391:../uvc.c      ****                     //stream_start = CyTrue;
 7583              		.loc 1 3391 0
 7584 40e0 6C3087E5 		str	r3, [r7, #108]
3393:../uvc.c      ****                     
 7585              		.loc 1 3393 0
 7586 40e4 FEFFFFEB 		bl	_tx_thread_sleep
 7587              	.LVL861:
 7588 40e8 98FFFFEA 		b	.L556
 7589              	.L638:
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 7590              		.loc 1 3153 0
 7591 40ec 9020D4E5 		ldrb	r2, [r4, #144]	@ zero_extendqisi2
3174:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7592              		.loc 1 3174 0
 7593 40f0 58569FE5 		ldr	r5, .L650+136
3154:../uvc.c      ****             	fb=0;
 7594              		.loc 1 3154 0
 7595 40f4 0330E0E1 		mvn	r3, r3
 7596 40f8 7C3003E2 		and	r3, r3, #124
 7597 40fc 0330E0E1 		mvn	r3, r3
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 7598              		.loc 1 3153 0
 7599 4100 012082E2 		add	r2, r2, #1
3173:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7600              		.loc 1 3173 0
 7601 4104 0C069FE5 		ldr	r0, .L650+80
 7602 4108 0010E0E3 		mvn	r1, #0
3158:../uvc.c      ****                 consCount = 0;
 7603              		.loc 1 3158 0
 7604 410c BC88C4E1 		strh	r8, [r4, #140]	@ movhi
3154:../uvc.c      ****             	fb=0;
 7605              		.loc 1 3154 0
 7606 4110 9130C4E5 		strb	r3, [r4, #145]
3159:../uvc.c      ****                 hitFV     = CyFalse;
 7607              		.loc 1 3159 0
 7608 4114 BE88C4E1 		strh	r8, [r4, #142]	@ movhi
3155:../uvc.c      ****             	pb=0;
 7609              		.loc 1 3155 0
 7610 4118 B088C4E1 		strh	r8, [r4, #128]	@ movhi
3156:../uvc.c      ****             	pbc=0;
 7611              		.loc 1 3156 0
 7612 411c B288C4E1 		strh	r8, [r4, #130]	@ movhi
3157:../uvc.c      ****                 prodCount = 0;
 7613              		.loc 1 3157 0
 7614 4120 B488C4E1 		strh	r8, [r4, #132]	@ movhi
3160:../uvc.c      **** 
 7615              		.loc 1 3160 0
 7616 4124 888084E5 		str	r8, [r4, #136]
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 7617              		.loc 1 3153 0
 7618 4128 9020C4E5 		strb	r2, [r4, #144]
3173:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7619              		.loc 1 3173 0
 7620 412c FEFFFFEB 		bl	_txe_mutex_get
 7621              	.LVL862:
3174:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7622              		.loc 1 3174 0
 7623 4130 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 7624 4134 013023E2 		eor	r3, r3, #1
 7625 4138 ED34C5E5 		strb	r3, [r5, #1261]
3176:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7626              		.loc 1 3176 0
 7627 413c 7E30D4E5 		ldrb	r3, [r4, #126]	@ zero_extendqisi2
 7628 4140 F00053E3 		cmp	r3, #240
 7629 4144 4200000A 		beq	.L644
 7630              	.L557:
3184:../uvc.c      **** 
 7631              		.loc 1 3184 0
 7632 4148 7E30D7E5 		ldrb	r3, [r7, #126]	@ zero_extendqisi2
 7633 414c FF0053E3 		cmp	r3, #255
 7634 4150 2400000A 		beq	.L645
3196:../uvc.c      ****                     //CyU3PThreadSleep(400);
 7635              		.loc 1 3196 0
 7636 4154 7E30D4E5 		ldrb	r3, [r4, #126]	@ zero_extendqisi2
 7637 4158 AA0053E3 		cmp	r3, #170
 7638 415c 2E00000A 		beq	.L646
 7639              	.L558:
3234:../uvc.c      ****                 /* Reset the DMA channel. */
 7640              		.loc 1 3234 0
 7641 4160 B0059FE5 		ldr	r0, .L650+80
 7642 4164 FEFFFFEB 		bl	_txe_mutex_put
 7643              	.LVL863:
3236:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7644              		.loc 1 3236 0
 7645 4168 B8059FE5 		ldr	r0, .L650+96
 7646 416c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7647              	.LVL864:
3237:../uvc.c      ****                 {
 7648              		.loc 1 3237 0
 7649 4170 005050E2 		subs	r5, r0, #0
 7650 4174 BC00001A 		bne	.L647
3244:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7651              		.loc 1 3244 0
 7652 4178 0510A0E1 		mov	r1, r5
 7653 417c 0520A0E1 		mov	r2, r5
 7654 4180 A0059FE5 		ldr	r0, .L650+96
 7655              	.LVL865:
 7656 4184 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7657              	.LVL866:
3245:../uvc.c      ****                 {
 7658              		.loc 1 3245 0
 7659 4188 005050E2 		subs	r5, r0, #0
 7660 418c B000001A 		bne	.L648
 7661              	.L577:
3253:../uvc.c      ****                 }
 7662              		.loc 1 3253 0
 7663 4190 84059FE5 		ldr	r0, .L650+84
 7664              	.LVL867:
 7665 4194 0230A0E3 		mov	r3, #2
 7666 4198 0010A0E3 		mov	r1, #0
 7667 419c 00308DE5 		str	r3, [sp]
 7668 41a0 0020A0E1 		mov	r2, r0
 7669 41a4 0130A0E1 		mov	r3, r1
 7670 41a8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7671              	.LVL868:
 7672 41ac 0060A0E3 		mov	r6, #0
 7673 41b0 66FFFFEA 		b	.L556
 7674              	.LVL869:
 7675              	.L583:
3328:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 7676              		.loc 1 3328 0
 7677 41b4 0030E0E3 		mvn	r3, #0
 7678 41b8 00308DE5 		str	r3, [sp]
 7679 41bc 0110A0E3 		mov	r1, #1
 7680 41c0 0220A0E3 		mov	r2, #2
 7681 41c4 80308DE2 		add	r3, sp, #128
 7682 41c8 00059FE5 		ldr	r0, .L650+8
 7683 41cc FEFFFFEB 		bl	_txe_event_flags_get
 7684              	.LVL870:
 7685 41d0 AAFFFFEA 		b	.L584
 7686              	.LVL871:
 7687              	.L640:
3292:../uvc.c      ****                     }
 7688              		.loc 1 3292 0
 7689 41d4 78159FE5 		ldr	r1, .L650+140
 7690 41d8 0620A0E1 		mov	r2, r6
 7691 41dc 0400A0E3 		mov	r0, #4
 7692              	.LVL872:
 7693 41e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7694              	.LVL873:
 7695 41e4 8EFFFFEA 		b	.L582
 7696              	.L645:
3186:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7697              		.loc 1 3186 0
 7698 41e8 A131D4E5 		ldrb	r3, [r4, #417]	@ zero_extendqisi2
 7699 41ec 020053E3 		cmp	r3, #2
 7700 41f0 013083E2 		add	r3, r3, #1
 7701 41f4 A131C4E5 		strb	r3, [r4, #417]
 7702 41f8 D8FFFF9A 		bls	.L558
3187:../uvc.c      ****                 		stiflag = 0x0F;
 7703              		.loc 1 3187 0
 7704 41fc ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3188:../uvc.c      ****                 		IMcount = 0;
 7705              		.loc 1 3188 0
 7706 4200 0F30A0E3 		mov	r3, #15
3187:../uvc.c      ****                 		stiflag = 0x0F;
 7707              		.loc 1 3187 0
 7708 4204 201081E3 		orr	r1, r1, #32
3189:../uvc.c      ****                 		}
 7709              		.loc 1 3189 0
 7710 4208 0020A0E3 		mov	r2, #0
3187:../uvc.c      ****                 		stiflag = 0x0F;
 7711              		.loc 1 3187 0
 7712 420c ED14C5E5 		strb	r1, [r5, #1261]
3189:../uvc.c      ****                 		}
 7713              		.loc 1 3189 0
 7714 4210 A121C4E5 		strb	r2, [r4, #417]
3188:../uvc.c      ****                 		IMcount = 0;
 7715              		.loc 1 3188 0
 7716 4214 7E30C4E5 		strb	r3, [r4, #126]
 7717 4218 D0FFFFEA 		b	.L558
 7718              	.L646:
3202:../uvc.c      ****                 	{
 7719              		.loc 1 3202 0
 7720 421c A131D4E5 		ldrb	r3, [r4, #417]	@ zero_extendqisi2
 7721 4220 020053E3 		cmp	r3, #2
 7722 4224 013083E2 		add	r3, r3, #1
 7723 4228 A131C4E5 		strb	r3, [r4, #417]
 7724 422c CBFFFF9A 		bls	.L558
3204:../uvc.c      ****                      {
 7725              		.loc 1 3204 0
 7726 4230 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 7727 4234 013043E2 		sub	r3, r3, #1
 7728 4238 030053E3 		cmp	r3, #3
 7729 423c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 7730 4240 3E0000EA 		b	.L562
 7731              	.L564:
 7732 4244 00430000 		.word	.L563
 7733 4248 BC430000 		.word	.L565
 7734 424c 00440000 		.word	.L566
 7735 4250 68430000 		.word	.L567
 7736              	.L644:
3176:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7737              		.loc 1 3176 0 discriminator 1
 7738 4254 8010A0E3 		mov	r1, #128
 7739 4258 00808DE5 		str	r8, [sp]
 7740 425c 6C049FE5 		ldr	r0, .L650+8
 7741 4260 0320A0E3 		mov	r2, #3
 7742 4264 01308DE0 		add	r3, sp, r1
 7743 4268 FEFFFFEB 		bl	_txe_event_flags_get
 7744              	.LVL874:
 7745 426c 000050E3 		cmp	r0, #0
 7746 4270 B4FFFF1A 		bne	.L557
3181:../uvc.c      ****                 		IMcount = 0;
 7747              		.loc 1 3181 0
 7748 4274 0030E0E3 		mvn	r3, #0
3182:../uvc.c      ****                 	}
 7749              		.loc 1 3182 0
 7750 4278 A101C4E5 		strb	r0, [r4, #417]
3181:../uvc.c      ****                 		IMcount = 0;
 7751              		.loc 1 3181 0
 7752 427c 7E30C4E5 		strb	r3, [r4, #126]
3182:../uvc.c      ****                 	}
 7753              		.loc 1 3182 0
 7754 4280 B6FFFFEA 		b	.L558
 7755              	.LVL875:
 7756              	.L642:
 7757              	.LBB136:
 7758              	.LBB134:
3004:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7759              		.loc 1 3004 0
 7760 4284 CC149FE5 		ldr	r1, .L650+144
 7761 4288 0100A0E3 		mov	r0, #1
 7762              	.LVL876:
 7763 428c FEFFFFEB 		bl	CyU3PDebugPrint
 7764              	.LVL877:
3005:../uvc.c      ****     }
 7765              		.loc 1 3005 0
 7766 4290 C4049FE5 		ldr	r0, .L650+148
 7767 4294 FEFFFFEB 		bl	CyU3PGpifLoad
 7768              	.LVL878:
 7769 4298 0050A0E1 		mov	r5, r0
 7770              	.LVL879:
 7771              	.L587:
3012:../uvc.c      ****     {
 7772              		.loc 1 3012 0
 7773 429c 000055E3 		cmp	r5, #0
 7774 42a0 E000001A 		bne	.L649
 7775              	.LVL880:
3024:../uvc.c      ****     {
 7776              		.loc 1 3024 0
 7777 42a4 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 7778 42a8 023043E2 		sub	r3, r3, #2
 7779 42ac FF3003E2 		and	r3, r3, #255
 7780 42b0 010053E3 		cmp	r3, #1
 7781 42b4 87FFFF8A 		bhi	.L588
3022:../uvc.c      ****     }
 7782              		.loc 1 3022 0
 7783 42b8 0500A0E1 		mov	r0, r5
 7784 42bc 0510A0E1 		mov	r1, r5
 7785 42c0 FEFFFFEB 		bl	CyU3PGpifSMStart
 7786              	.LVL881:
3028:../uvc.c      ****     {
 7787              		.loc 1 3028 0
 7788 42c4 005050E2 		subs	r5, r0, #0
 7789 42c8 82FFFF0A 		beq	.L588
3031:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7790              		.loc 1 3031 0
 7791 42cc 0400A0E3 		mov	r0, #4
 7792              	.LVL882:
 7793 42d0 88149FE5 		ldr	r1, .L650+152
 7794 42d4 0520A0E1 		mov	r2, r5
 7795 42d8 FEFFFFEB 		bl	CyU3PDebugPrint
 7796              	.LVL883:
3032:../uvc.c      ****     }
 7797              		.loc 1 3032 0
 7798 42dc 0500A0E1 		mov	r0, r5
 7799              	.LVL884:
 7800              	.L613:
 7801 42e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7802              	.LVL885:
 7803              	.L643:
3009:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7804              		.loc 1 3009 0
 7805 42e4 78149FE5 		ldr	r1, .L650+156
 7806 42e8 0100A0E3 		mov	r0, #1
 7807              	.LVL886:
 7808 42ec FEFFFFEB 		bl	CyU3PDebugPrint
 7809              	.LVL887:
3010:../uvc.c      ****     }
 7810              		.loc 1 3010 0
 7811 42f0 70049FE5 		ldr	r0, .L650+160
 7812 42f4 FEFFFFEB 		bl	CyU3PGpifLoad
 7813              	.LVL888:
 7814 42f8 0050A0E1 		mov	r5, r0
 7815              	.LVL889:
 7816 42fc E6FFFFEA 		b	.L587
 7817              	.LVL890:
 7818              	.L563:
 7819              	.LBE134:
 7820              	.LBE136:
3207:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7821              		.loc 1 3207 0
 7822 4300 782097E5 		ldr	r2, [r7, #120]
 7823 4304 3010A0E3 		mov	r1, #48
 7824 4308 000052E3 		cmp	r2, #0
 7825 430c E420A003 		moveq	r2, #228
 7826 4310 6420A013 		movne	r2, #100
 7827 4314 5230A0E3 		mov	r3, #82
 7828 4318 0100A0E3 		mov	r0, #1
 7829 431c FEFFFFEB 		bl	SensorSetIrisControl
 7830              	.LVL891:
3209:../uvc.c      ****                  		break;
 7831              		.loc 1 3209 0
 7832 4320 782097E5 		ldr	r2, [r7, #120]
 7833 4324 0400A0E3 		mov	r0, #4
 7834 4328 000052E3 		cmp	r2, #0
 7835 432c 783097E5 		ldr	r3, [r7, #120]
 7836 4330 E420A003 		moveq	r2, #228
 7837 4334 6420A013 		movne	r2, #100
 7838 4338 2C149FE5 		ldr	r1, .L650+164
 7839 433c FEFFFFEB 		bl	CyU3PDebugPrint
 7840              	.LVL892:
 7841              	.L562:
3229:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 7842              		.loc 1 3229 0
 7843 4340 0030A0E3 		mov	r3, #0
 7844 4344 A131C7E5 		strb	r3, [r7, #417]
3231:../uvc.c      ****                 	}
 7845              		.loc 1 3231 0
 7846 4348 7E30C7E5 		strb	r3, [r7, #126]
 7847 434c 83FFFFEA 		b	.L558
 7848              	.LVL893:
 7849              	.L641:
3337:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7850              		.loc 1 3337 0
 7851 4350 0400A0E3 		mov	r0, #4
 7852              	.LVL894:
 7853 4354 14149FE5 		ldr	r1, .L650+168
 7854 4358 0620A0E1 		mov	r2, r6
 7855 435c FEFFFFEB 		bl	CyU3PDebugPrint
 7856              	.LVL895:
3338:../uvc.c      ****                 }
 7857              		.loc 1 3338 0
 7858 4360 0600A0E1 		mov	r0, r6
 7859 4364 FEFFFFEB 		bl	CyFxAppErrorHandler
 7860              	.LVL896:
 7861              	.L567:
3222:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7862              		.loc 1 3222 0
 7863 4368 782097E5 		ldr	r2, [r7, #120]
 7864 436c D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 7865 4370 000052E3 		cmp	r2, #0
 7866 4374 F420A003 		moveq	r2, #244
 7867 4378 7420A013 		movne	r2, #116
 7868 437c 032082E1 		orr	r2, r2, r3
 7869 4380 3010A0E3 		mov	r1, #48
 7870 4384 5230A0E3 		mov	r3, #82
 7871 4388 0100A0E3 		mov	r0, #1
 7872 438c FEFFFFEB 		bl	SensorSetIrisControl
 7873              	.LVL897:
3224:../uvc.c      ****                  		break;
 7874              		.loc 1 3224 0
 7875 4390 781097E5 		ldr	r1, [r7, #120]
 7876 4394 D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 7877 4398 000051E3 		cmp	r1, #0
 7878 439c F410A003 		moveq	r1, #244
 7879 43a0 7410A013 		movne	r1, #116
 7880 43a4 022081E1 		orr	r2, r1, r2
 7881 43a8 783097E5 		ldr	r3, [r7, #120]
 7882 43ac B8139FE5 		ldr	r1, .L650+164
 7883 43b0 0400A0E3 		mov	r0, #4
 7884 43b4 FEFFFFEB 		bl	CyU3PDebugPrint
 7885              	.LVL898:
3225:../uvc.c      ****                  	default:
 7886              		.loc 1 3225 0
 7887 43b8 E0FFFFEA 		b	.L562
 7888              	.L565:
3212:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7889              		.loc 1 3212 0
 7890 43bc 782097E5 		ldr	r2, [r7, #120]
 7891 43c0 3010A0E3 		mov	r1, #48
 7892 43c4 000052E3 		cmp	r2, #0
 7893 43c8 D420A003 		moveq	r2, #212
 7894 43cc 5420A013 		movne	r2, #84
 7895 43d0 5230A0E3 		mov	r3, #82
 7896 43d4 0100A0E3 		mov	r0, #1
 7897 43d8 FEFFFFEB 		bl	SensorSetIrisControl
 7898              	.LVL899:
3214:../uvc.c      ****                  		break;
 7899              		.loc 1 3214 0
 7900 43dc 782097E5 		ldr	r2, [r7, #120]
 7901 43e0 84139FE5 		ldr	r1, .L650+164
 7902 43e4 000052E3 		cmp	r2, #0
 7903 43e8 783097E5 		ldr	r3, [r7, #120]
 7904 43ec D420A003 		moveq	r2, #212
 7905 43f0 5420A013 		movne	r2, #84
 7906 43f4 0400A0E3 		mov	r0, #4
 7907 43f8 FEFFFFEB 		bl	CyU3PDebugPrint
 7908              	.LVL900:
3215:../uvc.c      ****                  	case 3: //720
 7909              		.loc 1 3215 0
 7910 43fc CFFFFFEA 		b	.L562
 7911              	.L566:
3217:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7912              		.loc 1 3217 0
 7913 4400 782097E5 		ldr	r2, [r7, #120]
 7914 4404 D234D5E5 		ldrb	r3, [r5, #1234]	@ zero_extendqisi2
 7915 4408 000052E3 		cmp	r2, #0
 7916 440c C420A003 		moveq	r2, #196
 7917 4410 4420A013 		movne	r2, #68
 7918 4414 032082E1 		orr	r2, r2, r3
 7919 4418 3010A0E3 		mov	r1, #48
 7920 441c 5230A0E3 		mov	r3, #82
 7921 4420 0100A0E3 		mov	r0, #1
 7922 4424 FEFFFFEB 		bl	SensorSetIrisControl
 7923              	.LVL901:
3219:../uvc.c      ****                  		break;
 7924              		.loc 1 3219 0
 7925 4428 781097E5 		ldr	r1, [r7, #120]
 7926 442c D224D5E5 		ldrb	r2, [r5, #1234]	@ zero_extendqisi2
 7927 4430 000051E3 		cmp	r1, #0
 7928 4434 C410A003 		moveq	r1, #196
 7929 4438 4410A013 		movne	r1, #68
 7930 443c 022081E1 		orr	r2, r1, r2
 7931 4440 783097E5 		ldr	r3, [r7, #120]
 7932 4444 20139FE5 		ldr	r1, .L650+164
 7933 4448 0400A0E3 		mov	r0, #4
 7934 444c FEFFFFEB 		bl	CyU3PDebugPrint
 7935              	.LVL902:
3220:../uvc.c      ****                  	case 4: //VGA
 7936              		.loc 1 3220 0
 7937 4450 BAFFFFEA 		b	.L562
 7938              	.LVL903:
 7939              	.L648:
3247:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7940              		.loc 1 3247 0
 7941 4454 0400A0E3 		mov	r0, #4
 7942              	.LVL904:
 7943 4458 14139FE5 		ldr	r1, .L650+172
 7944 445c 0520A0E1 		mov	r2, r5
 7945 4460 FEFFFFEB 		bl	CyU3PDebugPrint
 7946              	.LVL905:
3248:../uvc.c      ****                 }
 7947              		.loc 1 3248 0
 7948 4464 0500A0E1 		mov	r0, r5
 7949 4468 FEFFFFEB 		bl	CyFxAppErrorHandler
 7950              	.LVL906:
 7951              	.L647:
3239:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7952              		.loc 1 3239 0
 7953 446c 0400A0E3 		mov	r0, #4
 7954              	.LVL907:
 7955 4470 00139FE5 		ldr	r1, .L650+176
 7956 4474 0520A0E1 		mov	r2, r5
 7957 4478 FEFFFFEB 		bl	CyU3PDebugPrint
 7958              	.LVL908:
3240:../uvc.c      ****                 }
 7959              		.loc 1 3240 0
 7960 447c 0500A0E1 		mov	r0, r5
 7961 4480 FEFFFFEB 		bl	CyFxAppErrorHandler
 7962              	.LVL909:
 7963              	.L621:
 7964              	.LBB137:
 7965              	.LBB128:
2683:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7966              		.loc 1 2683 0
 7967 4484 0400A0E3 		mov	r0, #4
 7968              	.LVL910:
 7969 4488 EC129FE5 		ldr	r1, .L650+180
 7970 448c 0520A0E1 		mov	r2, r5
 7971 4490 FEFFFFEB 		bl	CyU3PDebugPrint
 7972              	.LVL911:
2684:../uvc.c      ****     }
 7973              		.loc 1 2684 0
 7974 4494 0500A0E1 		mov	r0, r5
 7975 4498 FEFFFFEB 		bl	CyFxAppErrorHandler
 7976              	.LVL912:
 7977              	.L633:
2910:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7978              		.loc 1 2910 0
 7979 449c 0400A0E3 		mov	r0, #4
 7980              	.LVL913:
 7981 44a0 D8129FE5 		ldr	r1, .L650+184
 7982 44a4 0420A0E1 		mov	r2, r4
 7983 44a8 FEFFFFEB 		bl	CyU3PDebugPrint
 7984              	.LVL914:
2911:../uvc.c      ****     }
 7985              		.loc 1 2911 0
 7986 44ac 0400A0E1 		mov	r0, r4
 7987 44b0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7988              	.LVL915:
 7989              	.L632:
2891:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7990              		.loc 1 2891 0
 7991 44b4 0900A0E1 		mov	r0, r9
 7992              	.LVL916:
 7993 44b8 C4129FE5 		ldr	r1, .L650+188
 7994 44bc 0420A0E1 		mov	r2, r4
 7995 44c0 FEFFFFEB 		bl	CyU3PDebugPrint
 7996              	.LVL917:
2892:../uvc.c      ****     }
 7997              		.loc 1 2892 0
 7998 44c4 0400A0E1 		mov	r0, r4
 7999 44c8 FEFFFFEB 		bl	CyFxAppErrorHandler
 8000              	.LVL918:
 8001              	.L631:
2882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8002              		.loc 1 2882 0
 8003 44cc 0900A0E1 		mov	r0, r9
 8004              	.LVL919:
 8005 44d0 B0129FE5 		ldr	r1, .L650+192
 8006 44d4 0420A0E1 		mov	r2, r4
 8007 44d8 FEFFFFEB 		bl	CyU3PDebugPrint
 8008              	.LVL920:
2883:../uvc.c      ****     }
 8009              		.loc 1 2883 0
 8010 44dc 0400A0E1 		mov	r0, r4
 8011 44e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 8012              	.LVL921:
 8013              	.L630:
2861:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8014              		.loc 1 2861 0
 8015 44e4 0900A0E1 		mov	r0, r9
 8016              	.LVL922:
 8017 44e8 9C129FE5 		ldr	r1, .L650+196
 8018 44ec 0420A0E1 		mov	r2, r4
 8019 44f0 FEFFFFEB 		bl	CyU3PDebugPrint
 8020              	.LVL923:
2862:../uvc.c      ****     }
 8021              		.loc 1 2862 0
 8022 44f4 0400A0E1 		mov	r0, r4
 8023 44f8 FEFFFFEB 		bl	CyFxAppErrorHandler
 8024              	.LVL924:
 8025              	.L629:
2837:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 8026              		.loc 1 2837 0
 8027 44fc 0400A0E3 		mov	r0, #4
 8028 4500 88129FE5 		ldr	r1, .L650+200
 8029 4504 FEFFFFEB 		bl	CyU3PDebugPrint
 8030              	.LVL925:
2838:../uvc.c      ****     }
 8031              		.loc 1 2838 0
 8032 4508 0900A0E1 		mov	r0, r9
 8033 450c FEFFFFEB 		bl	CyFxAppErrorHandler
 8034              	.LVL926:
 8035              	.L628:
2830:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8036              		.loc 1 2830 0
 8037 4510 0400A0E3 		mov	r0, #4
 8038              	.LVL927:
 8039 4514 78129FE5 		ldr	r1, .L650+204
 8040 4518 0420A0E1 		mov	r2, r4
 8041 451c FEFFFFEB 		bl	CyU3PDebugPrint
 8042              	.LVL928:
2831:../uvc.c      ****     }
 8043              		.loc 1 2831 0
 8044 4520 0400A0E1 		mov	r0, r4
 8045 4524 FEFFFFEB 		bl	CyFxAppErrorHandler
 8046              	.LVL929:
 8047              	.L614:
2977:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8048              		.loc 1 2977 0
 8049 4528 0400A0E3 		mov	r0, #4
 8050              	.LVL930:
 8051 452c 64129FE5 		ldr	r1, .L650+208
 8052 4530 0420A0E1 		mov	r2, r4
 8053 4534 FEFFFFEB 		bl	CyU3PDebugPrint
 8054              	.LVL931:
2978:../uvc.c      ****     }
 8055              		.loc 1 2978 0
 8056 4538 0400A0E1 		mov	r0, r4
 8057 453c FEFFFFEB 		bl	CyFxAppErrorHandler
 8058              	.LVL932:
 8059              	.L637:
2952:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8060              		.loc 1 2952 0
 8061 4540 0400A0E3 		mov	r0, #4
 8062              	.LVL933:
 8063 4544 50129FE5 		ldr	r1, .L650+212
 8064 4548 0420A0E1 		mov	r2, r4
 8065 454c FEFFFFEB 		bl	CyU3PDebugPrint
 8066              	.LVL934:
2953:../uvc.c      ****     }
 8067              		.loc 1 2953 0
 8068 4550 0400A0E1 		mov	r0, r4
 8069 4554 FEFFFFEB 		bl	CyFxAppErrorHandler
 8070              	.LVL935:
 8071              	.L626:
2743:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8072              		.loc 1 2743 0
 8073 4558 0400A0E3 		mov	r0, #4
 8074              	.LVL936:
 8075 455c 3C129FE5 		ldr	r1, .L650+216
 8076 4560 0420A0E1 		mov	r2, r4
 8077 4564 FEFFFFEB 		bl	CyU3PDebugPrint
 8078              	.LVL937:
2744:../uvc.c      ****     }
 8079              		.loc 1 2744 0
 8080 4568 0400A0E1 		mov	r0, r4
 8081 456c FEFFFFEB 		bl	CyFxAppErrorHandler
 8082              	.LVL938:
 8083              	.L625:
2730:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8084              		.loc 1 2730 0
 8085 4570 0400A0E3 		mov	r0, #4
 8086              	.LVL939:
 8087 4574 28129FE5 		ldr	r1, .L650+220
 8088 4578 0420A0E1 		mov	r2, r4
 8089 457c FEFFFFEB 		bl	CyU3PDebugPrint
 8090              	.LVL940:
2731:../uvc.c      ****     }
 8091              		.loc 1 2731 0
 8092 4580 0400A0E1 		mov	r0, r4
 8093 4584 FEFFFFEB 		bl	CyFxAppErrorHandler
 8094              	.LVL941:
 8095              	.L624:
2716:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8096              		.loc 1 2716 0
 8097 4588 0400A0E3 		mov	r0, #4
 8098              	.LVL942:
 8099 458c 14129FE5 		ldr	r1, .L650+224
 8100 4590 0420A0E1 		mov	r2, r4
 8101 4594 FEFFFFEB 		bl	CyU3PDebugPrint
 8102              	.LVL943:
2717:../uvc.c      ****     }
 8103              		.loc 1 2717 0
 8104 4598 0400A0E1 		mov	r0, r4
 8105 459c FEFFFFEB 		bl	CyFxAppErrorHandler
 8106              	.LVL944:
 8107              	.L623:
2702:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8108              		.loc 1 2702 0
 8109 45a0 0400A0E3 		mov	r0, #4
 8110              	.LVL945:
 8111 45a4 00129FE5 		ldr	r1, .L650+228
 8112 45a8 0820A0E1 		mov	r2, r8
 8113 45ac FEFFFFEB 		bl	CyU3PDebugPrint
 8114              	.LVL946:
2703:../uvc.c      ****     }
 8115              		.loc 1 2703 0
 8116 45b0 0800A0E1 		mov	r0, r8
 8117 45b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8118              	.LVL947:
 8119              	.L635:
2936:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8120              		.loc 1 2936 0
 8121 45b8 0400A0E3 		mov	r0, #4
 8122              	.LVL948:
 8123 45bc EC119FE5 		ldr	r1, .L650+232
 8124 45c0 0420A0E1 		mov	r2, r4
 8125 45c4 FEFFFFEB 		bl	CyU3PDebugPrint
 8126              	.LVL949:
2937:../uvc.c      ****     }
 8127              		.loc 1 2937 0
 8128 45c8 0400A0E1 		mov	r0, r4
 8129 45cc FEFFFFEB 		bl	CyFxAppErrorHandler
 8130              	.LVL950:
 8131              	.L634:
2917:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8132              		.loc 1 2917 0
 8133 45d0 0400A0E3 		mov	r0, #4
 8134              	.LVL951:
 8135 45d4 D8119FE5 		ldr	r1, .L650+236
 8136 45d8 0420A0E1 		mov	r2, r4
 8137 45dc FEFFFFEB 		bl	CyU3PDebugPrint
 8138              	.LVL952:
2918:../uvc.c      ****     }
 8139              		.loc 1 2918 0
 8140 45e0 0400A0E1 		mov	r0, r4
 8141 45e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8142              	.LVL953:
 8143              	.L636:
2943:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 8144              		.loc 1 2943 0
 8145 45e8 0400A0E3 		mov	r0, #4
 8146 45ec C4119FE5 		ldr	r1, .L650+240
 8147 45f0 FEFFFFEB 		bl	CyU3PDebugPrint
 8148              	.LVL954:
2944:../uvc.c      ****     }
 8149              		.loc 1 2944 0
 8150 45f4 1000A0E3 		mov	r0, #16
 8151 45f8 FEFFFFEB 		bl	CyFxAppErrorHandler
 8152              	.LVL955:
 8153              	.L620:
2677:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8154              		.loc 1 2677 0
 8155 45fc 0400A0E3 		mov	r0, #4
 8156              	.LVL956:
 8157 4600 B4119FE5 		ldr	r1, .L650+244
 8158 4604 0520A0E1 		mov	r2, r5
 8159 4608 FEFFFFEB 		bl	CyU3PDebugPrint
 8160              	.LVL957:
2678:../uvc.c      ****     }
 8161              		.loc 1 2678 0
 8162 460c 0500A0E1 		mov	r0, r5
 8163 4610 FEFFFFEB 		bl	CyFxAppErrorHandler
 8164              	.LVL958:
 8165              	.L615:
 8166              	.LBE128:
 8167              	.LBE137:
 8168              	.LBB138:
 8169              	.LBB121:
2511:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8170              		.loc 1 2511 0
 8171 4614 0400A0E3 		mov	r0, #4
 8172              	.LVL959:
 8173 4618 A0119FE5 		ldr	r1, .L650+248
 8174 461c FEFFFFEB 		bl	CyU3PDebugPrint
 8175              	.LVL960:
2512:../uvc.c      ****     }
 8176              		.loc 1 2512 0
 8177 4620 0400A0E1 		mov	r0, r4
 8178 4624 FEFFFFEB 		bl	CyFxAppErrorHandler
 8179              	.LVL961:
 8180              	.L649:
 8181              	.LBE121:
 8182              	.LBE138:
 8183              	.LBB139:
 8184              	.LBB135:
3015:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8185              		.loc 1 3015 0
 8186 4628 0400A0E3 		mov	r0, #4
 8187              	.LVL962:
 8188 462c 90119FE5 		ldr	r1, .L650+252
 8189 4630 0520A0E1 		mov	r2, r5
 8190 4634 FEFFFFEB 		bl	CyU3PDebugPrint
 8191              	.LVL963:
3016:../uvc.c      ****     }
 8192              		.loc 1 3016 0
 8193 4638 0500A0E1 		mov	r0, r5
 8194 463c FEFFFFEB 		bl	CyFxAppErrorHandler
 8195              	.LVL964:
 8196              	.L619:
 8197              	.LBE135:
 8198              	.LBE139:
 8199              	.LBB140:
 8200              	.LBB129:
2668:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8201              		.loc 1 2668 0
 8202 4640 0400A0E3 		mov	r0, #4
 8203              	.LVL965:
 8204 4644 7C119FE5 		ldr	r1, .L650+256
 8205 4648 0520A0E1 		mov	r2, r5
 8206 464c FEFFFFEB 		bl	CyU3PDebugPrint
 8207              	.LVL966:
2669:../uvc.c      ****     }
 8208              		.loc 1 2669 0
 8209 4650 0500A0E1 		mov	r0, r5
 8210 4654 FEFFFFEB 		bl	CyFxAppErrorHandler
 8211              	.LVL967:
 8212              	.L618:
2646:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8213              		.loc 1 2646 0
 8214 4658 0400A0E3 		mov	r0, #4
 8215              	.LVL968:
 8216 465c 68119FE5 		ldr	r1, .L650+260
 8217 4660 0520A0E1 		mov	r2, r5
 8218 4664 FEFFFFEB 		bl	CyU3PDebugPrint
 8219              	.LVL969:
2647:../uvc.c      ****     }
 8220              		.loc 1 2647 0
 8221 4668 0500A0E1 		mov	r0, r5
 8222 466c FEFFFFEB 		bl	CyFxAppErrorHandler
 8223              	.LVL970:
 8224              	.L617:
 8225              	.LBE129:
 8226              	.LBE140:
 8227              	.LBB141:
 8228              	.LBB124:
2572:../uvc.c      ****         CyFxAppErrorHandler (status);
 8229              		.loc 1 2572 0
 8230 4670 0400A0E3 		mov	r0, #4
 8231              	.LVL971:
 8232 4674 54119FE5 		ldr	r1, .L650+264
 8233 4678 FEFFFFEB 		bl	CyU3PDebugPrint
 8234              	.LVL972:
2573:../uvc.c      ****     }
 8235              		.loc 1 2573 0
 8236 467c 0500A0E1 		mov	r0, r5
 8237 4680 FEFFFFEB 		bl	CyFxAppErrorHandler
 8238              	.LVL973:
 8239              	.L616:
2559:../uvc.c      ****         CyFxAppErrorHandler (status);
 8240              		.loc 1 2559 0
 8241 4684 0400A0E3 		mov	r0, #4
 8242              	.LVL974:
 8243 4688 44119FE5 		ldr	r1, .L650+268
 8244 468c FEFFFFEB 		bl	CyU3PDebugPrint
 8245              	.LVL975:
2560:../uvc.c      ****     }
 8246              		.loc 1 2560 0
 8247 4690 0500A0E1 		mov	r0, r5
 8248 4694 FEFFFFEB 		bl	CyFxAppErrorHandler
 8249              	.LVL976:
 8250              	.L627:
 8251              	.LBE124:
 8252              	.LBE141:
 8253              	.LBB142:
 8254              	.LBB130:
2764:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8255              		.loc 1 2764 0
 8256 4698 0400A0E3 		mov	r0, #4
 8257              	.LVL977:
 8258 469c 34119FE5 		ldr	r1, .L650+272
 8259 46a0 0420A0E1 		mov	r2, r4
 8260 46a4 FEFFFFEB 		bl	CyU3PDebugPrint
 8261              	.LVL978:
2765:../uvc.c      ****     }
 8262              		.loc 1 2765 0
 8263 46a8 0400A0E1 		mov	r0, r4
 8264 46ac FEFFFFEB 		bl	CyFxAppErrorHandler
 8265              	.LVL979:
 8266              	.L622:
2689:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8267              		.loc 1 2689 0
 8268 46b0 0400A0E3 		mov	r0, #4
 8269              	.LVL980:
 8270 46b4 20119FE5 		ldr	r1, .L650+276
 8271 46b8 0520A0E1 		mov	r2, r5
 8272 46bc FEFFFFEB 		bl	CyU3PDebugPrint
 8273              	.LVL981:
2690:../uvc.c      ****     }
 8274              		.loc 1 2690 0
 8275 46c0 0500A0E1 		mov	r0, r5
 8276 46c4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8277              	.LVL982:
 8278              	.L651:
 8279              		.align	2
 8280              	.L650:
 8281 46c8 00C20100 		.word	115200
 8282 46cc A0860100 		.word	100000
 8283 46d0 00000000 		.word	.LANCHOR0
 8284 46d4 00000000 		.word	CyFxGpifCB
 8285 46d8 88130000 		.word	5000
 8286 46dc 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8287 46e0 00000000 		.word	CyFxUVCApplnUSBEventCB
 8288 46e4 00000000 		.word	CyFxUSBDeviceDscr
 8289 46e8 00000000 		.word	CyFxUSBDeviceDscrSS
 8290 46ec 00000000 		.word	CyFxUSBDeviceQualDscr
 8291 46f0 00000000 		.word	CyFxUSBBOSDscr
 8292 46f4 00000000 		.word	CyFxUSBHSConfigDscr
 8293 46f8 00000000 		.word	CyFxUSBFSConfigDscr
 8294 46fc 00000000 		.word	CyFxUSBSSConfigDscr
 8295 4700 00000000 		.word	CyFxUSBStringLangIDDscr
 8296 4704 00000000 		.word	CyFxUSBManufactureDscr
 8297 4708 00000000 		.word	CyFxUSBProductDscr
 8298 470c 013F0203 		.word	50478849
 8299 4710 00000000 		.word	glChHandleInterStat
 8300 4714 00000000 		.word	glInterStaBuffer
 8301 4718 00000000 		.word	imgHdMux
 8302 471c 01010000 		.word	257
 8303 4720 03030000 		.word	771
 8304 4724 00000000 		.word	CyFxUvcApplnDmaCallback
 8305 4728 00000000 		.word	glChHandleUVCStream
 8306 472c 0404003F 		.word	1056965636
 8307 4730 00000000 		.word	CyFxUvcAppDebugCallback
 8308 4734 00000000 		.word	glDebugCmdChannel
 8309 4738 013F0403 		.word	50609921
 8310 473c 00000000 		.word	glDebugRspChannel
 8311 4740 00000000 		.word	glDebugRspBuffer
 8312 4744 D40C0000 		.word	.LC72
 8313 4748 F40C0000 		.word	.LC73
 8314 474c 0C0D0000 		.word	.LC74
 8315 4750 00000000 		.word	.LANCHOR1
 8316 4754 F0000000 		.word	.LC7
 8317 4758 5C0D0000 		.word	.LC76
 8318 475c 20000000 		.word	.LANCHOR2+32
 8319 4760 B40D0000 		.word	.LC79
 8320 4764 6C0D0000 		.word	.LC77
 8321 4768 3C000000 		.word	.LANCHOR2+60
 8322 476c 500C0000 		.word	.LC69
 8323 4770 280D0000 		.word	.LC75
 8324 4774 A00C0000 		.word	.LC71
 8325 4778 740C0000 		.word	.LC70
 8326 477c B4080000 		.word	.LC51
 8327 4780 580B0000 		.word	.LC64
 8328 4784 200B0000 		.word	.LC63
 8329 4788 E80A0000 		.word	.LC62
 8330 478c B80A0000 		.word	.LC61
 8331 4790 800A0000 		.word	.LC60
 8332 4794 400A0000 		.word	.LC59
 8333 4798 0C0A0000 		.word	.LC58
 8334 479c 280C0000 		.word	.LC68
 8335 47a0 AC090000 		.word	.LC56
 8336 47a4 74090000 		.word	.LC55
 8337 47a8 40090000 		.word	.LC54
 8338 47ac 0C090000 		.word	.LC53
 8339 47b0 C00B0000 		.word	.LC66
 8340 47b4 900B0000 		.word	.LC65
 8341 47b8 F80B0000 		.word	.LC67
 8342 47bc 8C080000 		.word	.LC50
 8343 47c0 E4070000 		.word	.LC45
 8344 47c4 7C0D0000 		.word	.LC78
 8345 47c8 68080000 		.word	.LC49
 8346 47cc 3C080000 		.word	.LC48
 8347 47d0 20080000 		.word	.LC47
 8348 47d4 04080000 		.word	.LC46
 8349 47d8 DC090000 		.word	.LC57
 8350 47dc E0080000 		.word	.LC52
 8351              	.LBE130:
 8352              	.LBE142:
 8353              		.cfi_endproc
 8354              	.LFE20:
 8356              		.align	2
 8357              		.global	UVCAppEP0Thread_Entry
 8359              	UVCAppEP0Thread_Entry:
 8360              	.LFB26:
4210:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 8361              		.loc 1 4210 0
 8362              		.cfi_startproc
 8363              		@ args = 0, pretend = 0, frame = 56
 8364              		@ frame_needed = 0, uses_anonymous_args = 0
 8365              	.LVL983:
 8366 47e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 8367              	.LCFI27:
 8368              		.cfi_def_cfa_offset 36
 8369              		.cfi_offset 4, -36
 8370              		.cfi_offset 5, -32
 8371              		.cfi_offset 6, -28
 8372              		.cfi_offset 7, -24
 8373              		.cfi_offset 8, -20
 8374              		.cfi_offset 9, -16
 8375              		.cfi_offset 10, -12
 8376              		.cfi_offset 11, -8
 8377              		.cfi_offset 14, -4
 8378 47e4 9C5F9FE5 		ldr	r5, .L1075
4478:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
 8379              		.loc 1 4478 0
 8380 47e8 9C7F9FE5 		ldr	r7, .L1075+4
4210:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 8381              		.loc 1 4210 0
 8382 47ec 54D04DE2 		sub	sp, sp, #84
 8383              	.LCFI28:
 8384              		.cfi_def_cfa_offset 120
 8385              	.LVL984:
4231:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 8386              		.loc 1 4231 0
 8387 47f0 0540A0E1 		mov	r4, r5
 8388              	.LVL985:
 8389              	.L960:
 8390 47f4 0030E0E3 		mvn	r3, #0
 8391 47f8 00308DE5 		str	r3, [sp]
 8392 47fc 840F9FE5 		ldr	r0, .L1075
 8393 4800 5C10A0E3 		mov	r1, #92
 8394 4804 0120A0E3 		mov	r2, #1
 8395 4808 30308DE2 		add	r3, sp, #48
 8396 480c FEFFFFEB 		bl	_txe_event_flags_get
 8397              	.LVL986:
 8398 4810 000050E3 		cmp	r0, #0
 8399 4814 3000001A 		bne	.L982
4235:../uvc.c      ****             {
 8400              		.loc 1 4235 0
 8401 4818 103194E5 		ldr	r3, [r4, #272]
 8402 481c 000053E3 		cmp	r3, #0
 8403 4820 CE00000A 		beq	.L1037
 8404              	.L655:
4251:../uvc.c      ****             {
 8405              		.loc 1 4251 0
 8406 4824 30309DE5 		ldr	r3, [sp, #48]
 8407 4828 040013E3 		tst	r3, #4
 8408 482c 1B00000A 		beq	.L657
4253:../uvc.c      ****                 {
 8409              		.loc 1 4253 0
 8410 4830 582F9FE5 		ldr	r2, .L1075+8
 8411 4834 B020D2E1 		ldrh	r2, [r2]
 8412 4838 2224A0E1 		mov	r2, r2, lsr #8
 8413 483c 030052E3 		cmp	r2, #3
 8414 4840 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 8415 4844 390000EA 		b	.L658
 8416              	.L660:
 8417 4848 48490000 		.word	.L659
 8418 484c E4480000 		.word	.L661
 8419 4850 80490000 		.word	.L662
 8420 4854 58480000 		.word	.L663
 8421              	.L663:
 8422              	.LBB187:
 8423              	.LBB188:
3728:../uvc.c      ****     {
 8424              		.loc 1 3728 0
 8425 4858 343F9FE5 		ldr	r3, .L1075+12
 8426 485c B030D3E1 		ldrh	r3, [r3]
 8427 4860 090C53E3 		cmp	r3, #2304
 8428 4864 5703000A 		beq	.L919
 8429 4868 0401009A 		bls	.L1038
 8430 486c 0F0C53E3 		cmp	r3, #3840
 8431 4870 4C03000A 		beq	.L931
 8432 4874 8A01008A 		bhi	.L932
 8433 4878 0B0C53E3 		cmp	r3, #2816
 8434 487c 3D03000A 		beq	.L933
 8435 4880 2003009A 		bls	.L1039
 8436 4884 030B53E3 		cmp	r3, #3072
 8437 4888 4A03000A 		beq	.L936
 8438 488c 0D0C53E3 		cmp	r3, #3328
 8439 4890 2600001A 		bne	.L658
 8440              	.LVL987:
3785:../uvc.c      ****     		break;
 8441              		.loc 1 3785 0
 8442 4894 1C00A0E3 		mov	r0, #28
 8443 4898 FEFFFFEB 		bl	ControlHandle
 8444              	.LVL988:
 8445 489c 30309DE5 		ldr	r3, [sp, #48]
 8446              	.L657:
 8447              	.LBE188:
 8448              	.LBE187:
4279:../uvc.c      ****             {
 8449              		.loc 1 4279 0
 8450 48a0 080013E3 		tst	r3, #8
 8451 48a4 0800000A 		beq	.L943
4283:../uvc.c      ****                 {
 8452              		.loc 1 4283 0
 8453 48a8 E03E9FE5 		ldr	r3, .L1075+8
 8454 48ac B030D3E1 		ldrh	r3, [r3]
 8455 48b0 010053E3 		cmp	r3, #1
 8456 48b4 C000000A 		beq	.L944
4285:../uvc.c      ****                 }
 8457              		.loc 1 4285 0
 8458 48b8 0000A0E3 		mov	r0, #0
 8459 48bc 0020A0E1 		mov	r2, r0
 8460 48c0 0110A0E3 		mov	r1, #1
 8461 48c4 FEFFFFEB 		bl	CyU3PUsbStall
 8462              	.LVL989:
 8463 48c8 30309DE5 		ldr	r3, [sp, #48]
 8464              	.L943:
4294:../uvc.c      ****             {
 8465              		.loc 1 4294 0
 8466 48cc 400013E3 		tst	r3, #64
 8467 48d0 9700001A 		bne	.L1040
 8468              	.L945:
4417:../uvc.c      ****             {
 8469              		.loc 1 4417 0
 8470 48d4 100013E3 		tst	r3, #16
 8471 48d8 5900001A 		bne	.L1041
 8472              	.L982:
4507:../uvc.c      ****     }
 8473              		.loc 1 4507 0
 8474 48dc FEFFFFEB 		bl	_txe_thread_relinquish
 8475              	.LVL990:
4508:../uvc.c      **** }
 8476              		.loc 1 4508 0
 8477 48e0 C3FFFFEA 		b	.L960
 8478              	.L661:
 8479              	.LBB193:
 8480              	.LBB194:
3498:../uvc.c      ****     {
 8481              		.loc 1 3498 0
 8482 48e4 A82E9FE5 		ldr	r2, .L1075+12
 8483 48e8 B020D2E1 		ldrh	r2, [r2]
 8484 48ec 060C52E3 		cmp	r2, #1536
 8485 48f0 4F02000A 		beq	.L742
 8486 48f4 EF00009A 		bls	.L1042
 8487 48f8 090C52E3 		cmp	r2, #2304
 8488 48fc AC02000A 		beq	.L750
 8489 4900 E501009A 		bls	.L1043
 8490 4904 0B0C52E3 		cmp	r2, #2816
 8491 4908 E702000A 		beq	.L753
 8492 490c 030B52E3 		cmp	r2, #3072
 8493 4910 6902000A 		beq	.L754
 8494 4914 0A0C52E3 		cmp	r2, #2560
 8495 4918 9402000A 		beq	.L1044
 8496              	.L741:
3555:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 8497              		.loc 1 3555 0
 8498 491c 743E9FE5 		ldr	r3, .L1075+16
 8499 4920 0400A0E3 		mov	r0, #4
 8500 4924 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8501 4928 6C1E9FE5 		ldr	r1, .L1075+20
 8502 492c FEFFFFEB 		bl	CyU3PDebugPrint
 8503              	.LVL991:
 8504              	.L658:
 8505              	.LBE194:
 8506              	.LBE193:
4274:../uvc.c      ****                         break;
 8507              		.loc 1 4274 0
 8508 4930 0000A0E3 		mov	r0, #0
 8509 4934 0020A0E1 		mov	r2, r0
 8510 4938 0110A0E3 		mov	r1, #1
 8511 493c FEFFFFEB 		bl	CyU3PUsbStall
 8512              	.LVL992:
 8513 4940 30309DE5 		ldr	r3, [sp, #48]
4275:../uvc.c      ****                 }
 8514              		.loc 1 4275 0
 8515 4944 D5FFFFEA 		b	.L657
 8516              	.L659:
 8517              	.LBB362:
 8518              	.LBB363:
3693:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 8519              		.loc 1 3693 0
 8520 4948 501E9FE5 		ldr	r1, .L1075+24
 8521 494c F934D1E5 		ldrb	r3, [r1, #1273]	@ zero_extendqisi2
 8522 4950 1F0053E3 		cmp	r3, #31
3694:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 8523              		.loc 1 3694 0
 8524 4954 382E9F95 		ldrls	r2, .L1075+12
3696:../uvc.c      **** 		value[0][1] = valIdx;
 8525              		.loc 1 3696 0
 8526 4958 01C08392 		addls	ip, r3, #1
3694:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 8527              		.loc 1 3694 0
 8528 495c B000D291 		ldrlsh	r0, [r2]
 8529 4960 83308590 		addls	r3, r5, r3, asl #1
3696:../uvc.c      **** 		value[0][1] = valIdx;
 8530              		.loc 1 3696 0
 8531 4964 FFC00C92 		andls	ip, ip, #255
3694:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 8532              		.loc 1 3694 0
 8533 4968 20E4A091 		movls	lr, r0, lsr #8
 8534 496c 20E1C395 		strlsb	lr, [r3, #288]
3695:../uvc.c      **** 		valIdx++;
 8535              		.loc 1 3695 0
 8536 4970 2101C395 		strlsb	r0, [r3, #289]
3696:../uvc.c      **** 		value[0][1] = valIdx;
 8537              		.loc 1 3696 0
 8538 4974 F9C4C195 		strlsb	ip, [r1, #1273]
3697:../uvc.c      **** 	}
 8539              		.loc 1 3697 0
 8540 4978 21C1C595 		strlsb	ip, [r5, #289]
 8541 497c EBFFFFEA 		b	.L658
 8542              	.L662:
 8543              	.LBE363:
 8544              	.LBE362:
 8545              	.LBB364:
 8546              	.LBB365:
3423:../uvc.c      ****     {
 8547              		.loc 1 3423 0
 8548 4980 0C2E9FE5 		ldr	r2, .L1075+12
 8549 4984 B020D2E1 		ldrh	r2, [r2]
 8550 4988 060C52E3 		cmp	r2, #1536
 8551 498c F401000A 		beq	.L665
 8552 4990 AD00008A 		bhi	.L666
 8553 4994 030C52E3 		cmp	r2, #768
 8554 4998 E901000A 		beq	.L667
 8555 499c 4B01008A 		bhi	.L668
 8556 49a0 010C52E3 		cmp	r2, #256
 8557 49a4 E201000A 		beq	.L669
 8558 49a8 020C52E3 		cmp	r2, #512
 8559 49ac DAFFFF1A 		bne	.L741
 8560              	.LVL993:
 8561              	.LBB366:
 8562              	.LBB367:
 813:../uvc.c      ****     /*
 8563              		.loc 1 813 0
 8564 49b0 E03D9FE5 		ldr	r3, .L1075+16
 804:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8565              		.loc 1 804 0
 8566 49b4 E46D9FE5 		ldr	r6, .L1075+24
 813:../uvc.c      ****     /*
 8567              		.loc 1 813 0
 8568 49b8 0080D3E5 		ldrb	r8, [r3]	@ zero_extendqisi2
 804:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8569              		.loc 1 804 0
 8570 49bc 9801D6E5 		ldrb	r0, [r6, #408]	@ zero_extendqisi2
 8571              	.LVL994:
 821:../uvc.c      **** 		 {
 8572              		.loc 1 821 0
 8573 49c0 830058E3 		cmp	r8, #131
 805:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 8574              		.loc 1 805 0
 8575 49c4 9931D6E5 		ldrb	r3, [r6, #409]	@ zero_extendqisi2
 8576              	.LVL995:
 806:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8577              		.loc 1 806 0
 8578 49c8 A791D6E5 		ldrb	r9, [r6, #423]	@ zero_extendqisi2
 8579              	.LVL996:
 807:../uvc.c      ****     }
 8580              		.loc 1 807 0
 8581 49cc 9AA1D6E5 		ldrb	r10, [r6, #410]	@ zero_extendqisi2
 8582              	.LVL997:
 821:../uvc.c      **** 		 {
 8583              		.loc 1 821 0
 8584 49d0 5905000A 		beq	.L679
 8585 49d4 0B03009A 		bls	.L1045
 8586 49d8 850058E3 		cmp	r8, #133
 8587 49dc CC04000A 		beq	.L684
 8588 49e0 DE04003A 		bcc	.L685
 8589 49e4 860058E3 		cmp	r8, #134
 8590 49e8 D304000A 		beq	.L686
 8591 49ec 870058E3 		cmp	r8, #135
 8592 49f0 F104001A 		bne	.L678
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8593              		.loc 1 1246 0
 8594 49f4 A321D6E5 		ldrb	r2, [r6, #419]	@ zero_extendqisi2
1247:../uvc.c      **** 			 }
 8595              		.loc 1 1247 0
 8596 49f8 A431D6E5 		ldrb	r3, [r6, #420]	@ zero_extendqisi2
 8597              	.L1010:
1187:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8598              		.loc 1 1187 0
 8599 49fc D81D9FE5 		ldr	r1, .L1075+84
 8600 4a00 0A00A0E1 		mov	r0, r10
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 8601              		.loc 1 1184 0
 8602 4a04 2820C5E5 		strb	r2, [r5, #40]
 8603              	.L1009:
1185:../uvc.c      **** 			 }
 8604              		.loc 1 1185 0
 8605 4a08 2930C5E5 		strb	r3, [r5, #41]
1187:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8606              		.loc 1 1187 0
 8607 4a0c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8608              	.LVL998:
 8609 4a10 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
1188:../uvc.c      **** 			  break;
 8610              		.loc 1 1188 0
 8611 4a14 FF20A0E3 		mov	r2, #255
 8612 4a18 0230A0E1 		mov	r3, r2
 8613              	.LVL999:
 8614              	.L688:
1710:../uvc.c      **** }
 8615              		.loc 1 1710 0
 8616 4a1c FF00A0E3 		mov	r0, #255
 8617 4a20 00208DE5 		str	r2, [sp]
 8618 4a24 04108DE5 		str	r1, [sp, #4]
 8619 4a28 08008DE5 		str	r0, [sp, #8]
 8620 4a2c 0820A0E1 		mov	r2, r8
 8621 4a30 0400A0E3 		mov	r0, #4
 8622 4a34 681D9FE5 		ldr	r1, .L1075+28
 8623 4a38 FEFFFFEB 		bl	CyU3PDebugPrint
 8624              	.LVL1000:
 8625 4a3c 30309DE5 		ldr	r3, [sp, #48]
 8626 4a40 96FFFFEA 		b	.L657
 8627              	.LVL1001:
 8628              	.L1041:
 8629              	.LBE367:
 8630              	.LBE366:
 8631              	.LBE365:
 8632              	.LBE364:
4420:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8633              		.loc 1 4420 0
 8634 4a44 38108DE2 		add	r1, sp, #56
 8635 4a48 580D9FE5 		ldr	r0, .L1075+32
 8636 4a4c 0020E0E3 		mvn	r2, #0
 8637 4a50 FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 8638              	.LVL1002:
4421:../uvc.c      ****                 {
 8639              		.loc 1 4421 0
 8640 4a54 006050E2 		subs	r6, r0, #0
 8641 4a58 4B08001A 		bne	.L1046
4434:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
 8642              		.loc 1 4434 0
 8643 4a5c 38109DE5 		ldr	r1, [sp, #56]
 8644 4a60 BC23DDE1 		ldrh	r2, [sp, #60]
 8645 4a64 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 8646              	.LVL1003:
 8647 4a68 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8648 4a6c 00008DE5 		str	r0, [sp]
 8649 4a70 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 8650 4a74 0400A0E3 		mov	r0, #4
 8651 4a78 04108DE5 		str	r1, [sp, #4]
 8652 4a7c 281D9FE5 		ldr	r1, .L1075+36
 8653 4a80 FEFFFFEB 		bl	CyU3PDebugPrint
 8654              	.LVL1004:
4435:../uvc.c      ****                 {
 8655              		.loc 1 4435 0
 8656 4a84 38109DE5 		ldr	r1, [sp, #56]
 8657 4a88 0020D1E5 		ldrb	r2, [r1]	@ zero_extendqisi2
 8658 4a8c 000052E3 		cmp	r2, #0
 8659 4a90 3800001A 		bne	.L951
4437:../uvc.c      ****                     {
 8660              		.loc 1 4437 0
 8661 4a94 BC23DDE1 		ldrh	r2, [sp, #60]
 8662 4a98 030052E3 		cmp	r2, #3
 8663 4a9c D200000A 		beq	.L1047
4443:../uvc.c      ****                     {
 8664              		.loc 1 4443 0
 8665 4aa0 040052E3 		cmp	r2, #4
 8666 4aa4 F400000A 		beq	.L954
 8667 4aa8 DC6C9FE5 		ldr	r6, .L1075+4
 8668              	.LVL1005:
 8669              	.L953:
4452:../uvc.c      ****                 }
 8670              		.loc 1 4452 0 discriminator 1
 8671 4aac 001096E5 		ldr	r1, [r6]
 8672 4ab0 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 8673 4ab4 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8674 4ab8 00008DE5 		str	r0, [sp]
 8675 4abc 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 8676 4ac0 0400A0E3 		mov	r0, #4
 8677 4ac4 04108DE5 		str	r1, [sp, #4]
 8678 4ac8 E01C9FE5 		ldr	r1, .L1075+40
 8679 4acc FEFFFFEB 		bl	CyU3PDebugPrint
 8680              	.LVL1006:
 8681 4ad0 001096E5 		ldr	r1, [r6]
 8682              	.L956:
4483:../uvc.c      ****                 dmaInfo.status = 0;
 8683              		.loc 1 4483 0
 8684 4ad4 012BA0E3 		mov	r2, #1024
4484:../uvc.c      **** 
 8685              		.loc 1 4484 0
 8686 4ad8 0030A0E3 		mov	r3, #0
4487:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8687              		.loc 1 4487 0
 8688 4adc C40C9FE5 		ldr	r0, .L1075+32
4482:../uvc.c      ****                 dmaInfo.size   = 1024;
 8689              		.loc 1 4482 0
 8690 4ae0 38108DE5 		str	r1, [sp, #56]
4483:../uvc.c      ****                 dmaInfo.status = 0;
 8691              		.loc 1 4483 0
 8692 4ae4 BE23CDE1 		strh	r2, [sp, #62]	@ movhi
4484:../uvc.c      **** 
 8693              		.loc 1 4484 0
 8694 4ae8 B034CDE1 		strh	r3, [sp, #64]	@ movhi
4487:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8695              		.loc 1 4487 0
 8696 4aec FEFFFFEB 		bl	CyU3PDmaChannelDiscardBuffer
 8697              	.LVL1007:
4488:../uvc.c      ****                 {
 8698              		.loc 1 4488 0
 8699 4af0 000050E3 		cmp	r0, #0
 8700 4af4 4108001A 		bne	.L1048
4495:../uvc.c      **** 
 8701              		.loc 1 4495 0
 8702 4af8 0010E0E3 		mvn	r1, #0
 8703 4afc B00C9FE5 		ldr	r0, .L1075+44
 8704              	.LVL1008:
 8705 4b00 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 8706              	.LVL1009:
4497:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8707              		.loc 1 4497 0
 8708 4b04 38108DE2 		add	r1, sp, #56
 8709 4b08 A40C9FE5 		ldr	r0, .L1075+44
 8710 4b0c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8711              	.LVL1010:
4498:../uvc.c      ****                 {
 8712              		.loc 1 4498 0
 8713 4b10 000050E3 		cmp	r0, #0
 8714 4b14 70FFFF0A 		beq	.L982
 8715 4b18 0060A0E1 		mov	r6, r0
4500:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 8716              		.loc 1 4500 0
 8717 4b1c 941C9FE5 		ldr	r1, .L1075+48
 8718 4b20 0400A0E3 		mov	r0, #4
 8719              	.LVL1011:
 8720 4b24 0620A0E1 		mov	r2, r6
 8721 4b28 FEFFFFEB 		bl	CyU3PDebugPrint
 8722              	.LVL1012:
4501:../uvc.c      ****                 }
 8723              		.loc 1 4501 0
 8724 4b2c 0600A0E1 		mov	r0, r6
 8725 4b30 FEFFFFEB 		bl	CyFxAppErrorHandler
 8726              	.LVL1013:
 8727              	.L1040:
4356:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 8728              		.loc 1 4356 0
 8729 4b34 646C9FE5 		ldr	r6, .L1075+24
4299:../uvc.c      **** 
 8730              		.loc 1 4299 0
 8731 4b38 1800A0E3 		mov	r0, #24
 8732 4b3c 34108DE2 		add	r1, sp, #52
 8733              	.LVL1014:
 8734 4b40 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 8735              	.LVL1015:
4356:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 8736              		.loc 1 4356 0
 8737 4b44 0C37D6E5 		ldrb	r3, [r6, #1804]	@ zero_extendqisi2
 8738 4b48 0F0053E3 		cmp	r3, #15
 8739 4b4c A900000A 		beq	.L1049
4383:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 8740              		.loc 1 4383 0
 8741 4b50 000053E3 		cmp	r3, #0
 8742 4b54 1B00000A 		beq	.L948
 8743 4b58 30309DE5 		ldr	r3, [sp, #48]
 8744 4b5c 5CFFFFEA 		b	.L945
 8745              	.L1037:
4237:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 8746              		.loc 1 4237 0
 8747 4b60 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 8748              	.LVL1016:
4238:../uvc.c      ****                 {
 8749              		.loc 1 4238 0
 8750 4b64 000050E3 		cmp	r0, #0
4240:../uvc.c      ****                 }
 8751              		.loc 1 4240 0
 8752 4b68 0130A013 		movne	r3, #1
4237:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 8753              		.loc 1 4237 0
 8754 4b6c 4800C4E5 		strb	r0, [r4, #72]
4240:../uvc.c      ****                 }
 8755              		.loc 1 4240 0
 8756 4b70 10318415 		strne	r3, [r4, #272]
 8757 4b74 2AFFFFEA 		b	.L655
 8758              	.LVL1017:
 8759              	.L951:
4458:../uvc.c      ****                 {
 8760              		.loc 1 4458 0
 8761 4b78 010052E3 		cmp	r2, #1
 8762 4b7c 7E00000A 		beq	.L1050
4478:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
 8763              		.loc 1 4478 0
 8764 4b80 000097E5 		ldr	r0, [r7]
 8765 4b84 BC23DDE1 		ldrh	r2, [sp, #60]
 8766 4b88 FEFFFFEB 		bl	CyU3PMemCopy
 8767              	.LVL1018:
4479:../uvc.c      ****                 }
 8768              		.loc 1 4479 0
 8769 4b8c 001097E5 		ldr	r1, [r7]
 8770 4b90 BC23DDE1 		ldrh	r2, [sp, #60]
 8771 4b94 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 8772 4b98 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8773 4b9c 00008DE5 		str	r0, [sp]
 8774 4ba0 0210D1E5 		ldrb	r1, [r1, #2]	@ zero_extendqisi2
 8775 4ba4 0400A0E3 		mov	r0, #4
 8776 4ba8 04108DE5 		str	r1, [sp, #4]
 8777 4bac 081C9FE5 		ldr	r1, .L1075+52
 8778 4bb0 FEFFFFEB 		bl	CyU3PDebugPrint
 8779              	.LVL1019:
 8780 4bb4 001097E5 		ldr	r1, [r7]
 8781 4bb8 C5FFFFEA 		b	.L956
 8782              	.LVL1020:
 8783              	.L944:
4289:../uvc.c      ****                 }
 8784              		.loc 1 4289 0
 8785 4bbc BDEDFFEB 		bl	UVCHandleVideoStreamingRqts
 8786              	.LVL1021:
 8787 4bc0 30309DE5 		ldr	r3, [sp, #48]
 8788 4bc4 40FFFFEA 		b	.L943
 8789              	.L948:
4385:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 8790              		.loc 1 4385 0
 8791 4bc8 F01B9FE5 		ldr	r1, .L1075+56
 8792 4bcc 0200A0E3 		mov	r0, #2
 8793 4bd0 002091E5 		ldr	r2, [r1]
4386:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8794              		.loc 1 4386 0
 8795 4bd4 0180A0E3 		mov	r8, #1
4385:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 8796              		.loc 1 4385 0
 8797 4bd8 0000C2E5 		strb	r0, [r2]
4386:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8798              		.loc 1 4386 0
 8799 4bdc 000091E5 		ldr	r0, [r1]
4391:../uvc.c      **** 					interStabuf.status = 0;
 8800              		.loc 1 4391 0
 8801 4be0 012BA0E3 		mov	r2, #1024
4386:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8802              		.loc 1 4386 0
 8803 4be4 0180C0E5 		strb	r8, [r0, #1]
4387:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 8804              		.loc 1 4387 0
 8805 4be8 000091E5 		ldr	r0, [r1]
4394:../uvc.c      **** 
 8806              		.loc 1 4394 0
 8807 4bec 0490A0E3 		mov	r9, #4
4387:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 8808              		.loc 1 4387 0
 8809 4bf0 0230C0E5 		strb	r3, [r0, #2]
4388:../uvc.c      **** 
 8810              		.loc 1 4388 0
 8811 4bf4 00C091E5 		ldr	ip, [r1]
4397:../uvc.c      **** 
 8812              		.loc 1 4397 0
 8813 4bf8 C40B9FE5 		ldr	r0, .L1075+60
4388:../uvc.c      **** 
 8814              		.loc 1 4388 0
 8815 4bfc 0380CCE5 		strb	r8, [ip, #3]
4390:../uvc.c      **** 					interStabuf.size   = 1024;
 8816              		.loc 1 4390 0
 8817 4c00 00C091E5 		ldr	ip, [r1]
4397:../uvc.c      **** 
 8818              		.loc 1 4397 0
 8819 4c04 0010E0E3 		mvn	r1, #0
4390:../uvc.c      **** 					interStabuf.size   = 1024;
 8820              		.loc 1 4390 0
 8821 4c08 44C08DE5 		str	ip, [sp, #68]
4392:../uvc.c      **** 
 8822              		.loc 1 4392 0
 8823 4c0c BC34CDE1 		strh	r3, [sp, #76]	@ movhi
4391:../uvc.c      **** 					interStabuf.status = 0;
 8824              		.loc 1 4391 0
 8825 4c10 BA24CDE1 		strh	r2, [sp, #74]	@ movhi
4394:../uvc.c      **** 
 8826              		.loc 1 4394 0
 8827 4c14 B894CDE1 		strh	r9, [sp, #72]	@ movhi
4397:../uvc.c      **** 
 8828              		.loc 1 4397 0
 8829 4c18 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 8830              	.LVL1022:
4400:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 8831              		.loc 1 4400 0
 8832 4c1c A00B9FE5 		ldr	r0, .L1075+60
 8833 4c20 44108DE2 		add	r1, sp, #68
 8834 4c24 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8835              	.LVL1023:
4402:../uvc.c      **** 					{
 8836              		.loc 1 4402 0
 8837 4c28 000050E3 		cmp	r0, #0
 8838 4c2c FA07001A 		bne	.L1051
4408:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 8839              		.loc 1 4408 0
 8840 4c30 0500A0E3 		mov	r0, #5
 8841              	.LVL1024:
 8842 4c34 3010A0E3 		mov	r1, #48
 8843 4c38 0820A0E1 		mov	r2, r8
 8844 4c3c FEFFFFEB 		bl	SensorSetControl
 8845              	.LVL1025:
 8846 4c40 30309DE5 		ldr	r3, [sp, #48]
4409:../uvc.c      **** 				}
 8847              		.loc 1 4409 0
 8848 4c44 0C87C6E5 		strb	r8, [r6, #1804]
 8849 4c48 21FFFFEA 		b	.L945
 8850              	.L666:
 8851              	.LBB430:
 8852              	.LBB420:
3423:../uvc.c      ****     {
 8853              		.loc 1 3423 0
 8854 4c4c 0A0C52E3 		cmp	r2, #2560
 8855 4c50 2F01000A 		beq	.L672
 8856 4c54 C300009A 		bls	.L1052
 8857 4c58 0D0C52E3 		cmp	r2, #3328
 8858 4c5c 2C01000A 		beq	.L672
 8859 4c60 0E0C52E3 		cmp	r2, #3584
 8860 4c64 3A01000A 		beq	.L676
 8861 4c68 030B52E3 		cmp	r2, #3072
 8862 4c6c 2AFFFF1A 		bne	.L741
 8863              	.LVL1026:
3464:../uvc.c      ****     		break;
 8864              		.loc 1 3464 0
 8865 4c70 0B00A0E3 		mov	r0, #11
 8866 4c74 FEFFFFEB 		bl	ControlHandle
 8867              	.LVL1027:
 8868 4c78 30309DE5 		ldr	r3, [sp, #48]
 8869 4c7c 07FFFFEA 		b	.L657
 8870              	.L1038:
 8871              	.LBE420:
 8872              	.LBE430:
 8873              	.LBB431:
 8874              	.LBB189:
3728:../uvc.c      ****     {
 8875              		.loc 1 3728 0
 8876 4c80 010B53E3 		cmp	r3, #1024
 8877 4c84 4302000A 		beq	.L921
 8878 4c88 0801009A 		bls	.L1053
 8879 4c8c 060C53E3 		cmp	r3, #1536
 8880 4c90 3C02000A 		beq	.L926
 8881 4c94 2102009A 		bls	.L1054
 8882 4c98 070C53E3 		cmp	r3, #1792
 8883 4c9c 4D02000A 		beq	.L929
 8884 4ca0 020B53E3 		cmp	r3, #2048
 8885 4ca4 21FFFF1A 		bne	.L658
 8886              	.LVL1028:
3760:../uvc.c      ****     		break;
 8887              		.loc 1 3760 0
 8888 4ca8 1700A0E3 		mov	r0, #23
 8889 4cac FEFFFFEB 		bl	ControlHandle
 8890              	.LVL1029:
 8891 4cb0 30309DE5 		ldr	r3, [sp, #48]
 8892 4cb4 F9FEFFEA 		b	.L657
 8893              	.L1042:
 8894              	.LBE189:
 8895              	.LBE431:
 8896              	.LBB432:
 8897              	.LBB353:
3498:../uvc.c      ****     {
 8898              		.loc 1 3498 0
 8899 4cb8 030C52E3 		cmp	r2, #768
 8900 4cbc 2C01000A 		beq	.L744
 8901 4cc0 CA00008A 		bhi	.L745
 8902 4cc4 010C52E3 		cmp	r2, #256
 8903 4cc8 4801000A 		beq	.L746
 8904 4ccc 020C52E3 		cmp	r2, #512
 8905 4cd0 11FFFF1A 		bne	.L741
 8906              	.LVL1030:
 8907              	.LBB195:
 8908              	.LBB196:
1734:../uvc.c      **** 
 8909              		.loc 1 1734 0
 8910 4cd4 BCAA9FE5 		ldr	r10, .L1075+16
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8911              		.loc 1 1726 0
 8912 4cd8 C06A9FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 8913              		.loc 1 1734 0
 8914 4cdc 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8915              		.loc 1 1726 0
 8916 4ce0 B3C5D6E5 		ldrb	ip, [r6, #1459]	@ zero_extendqisi2
 8917              	.LVL1031:
1736:../uvc.c      **** 		 {
 8918              		.loc 1 1736 0
 8919 4ce4 830058E3 		cmp	r8, #131
1727:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8920              		.loc 1 1727 0
 8921 4ce8 A435D6E5 		ldrb	r3, [r6, #1444]	@ zero_extendqisi2
 8922              	.LVL1032:
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8923              		.loc 1 1729 0
 8924 4cec A695D6E5 		ldrb	r9, [r6, #1446]	@ zero_extendqisi2
 8925              	.LVL1033:
1736:../uvc.c      **** 		 {
 8926              		.loc 1 1736 0
 8927 4cf0 5805000A 		beq	.L768
 8928 4cf4 8103009A 		bls	.L1055
 8929 4cf8 850058E3 		cmp	r8, #133
 8930 4cfc 4905000A 		beq	.L773
 8931 4d00 9904003A 		bcc	.L774
 8932 4d04 860058E3 		cmp	r8, #134
 8933 4d08 8E04000A 		beq	.L775
 8934 4d0c 870058E3 		cmp	r8, #135
 8935 4d10 0305001A 		bne	.L767
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8936              		.loc 1 1798 0
 8937 4d14 AFC5D6E5 		ldrb	ip, [r6, #1455]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8938              		.loc 1 1799 0
 8939 4d18 B025D6E5 		ldrb	r2, [r6, #1456]	@ zero_extendqisi2
 8940              	.L1018:
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8941              		.loc 1 1777 0
 8942 4d1c 0030A0E3 		mov	r3, #0
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8943              		.loc 1 1779 0
 8944 4d20 0900A0E1 		mov	r0, r9
 8945 4d24 B01A9FE5 		ldr	r1, .L1075+84
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8946              		.loc 1 1775 0
 8947 4d28 2920C5E5 		strb	r2, [r5, #41]
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8948              		.loc 1 1777 0
 8949 4d2c 2A30C5E5 		strb	r3, [r5, #42]
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8950              		.loc 1 1778 0
 8951 4d30 2B30C5E5 		strb	r3, [r5, #43]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8952              		.loc 1 1774 0
 8953 4d34 28C0C5E5 		strb	ip, [r5, #40]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8954              		.loc 1 1779 0
 8955 4d38 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8956              	.LVL1034:
 8957 4d3c 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
1780:../uvc.c      **** 			  break;
 8958              		.loc 1 1780 0
 8959 4d40 FF30A0E3 		mov	r3, #255
 8960              	.LVL1035:
 8961              	.L777:
1949:../uvc.c      **** }
 8962              		.loc 1 1949 0
 8963 4d44 2A00D5E5 		ldrb	r0, [r5, #42]	@ zero_extendqisi2
 8964 4d48 FF10A0E3 		mov	r1, #255
 8965 4d4c 08208DE5 		str	r2, [sp, #8]
 8966 4d50 04008DE5 		str	r0, [sp, #4]
 8967 4d54 10008DE5 		str	r0, [sp, #16]
 8968 4d58 00108DE5 		str	r1, [sp]
 8969 4d5c 0C108DE5 		str	r1, [sp, #12]
 8970 4d60 14908DE5 		str	r9, [sp, #20]
 8971 4d64 0820A0E1 		mov	r2, r8
 8972 4d68 0400A0E3 		mov	r0, #4
 8973 4d6c 541A9FE5 		ldr	r1, .L1075+64
 8974 4d70 FEFFFFEB 		bl	CyU3PDebugPrint
 8975              	.LVL1036:
 8976 4d74 30309DE5 		ldr	r3, [sp, #48]
 8977 4d78 C8FEFFEA 		b	.L657
 8978              	.LVL1037:
 8979              	.L1050:
 8980              	.LBE196:
 8981              	.LBE195:
 8982              	.LBE353:
 8983              	.LBE432:
4462:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
 8984              		.loc 1 4462 0
 8985 4d7c 01C0D1E5 		ldrb	ip, [r1, #1]	@ zero_extendqisi2
 8986 4d80 0300D1E5 		ldrb	r0, [r1, #3]	@ zero_extendqisi2
 8987 4d84 0220D1E5 		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 8988 4d88 0630A0E1 		mov	r3, r6
 8989 4d8c 0C10A0E1 		mov	r1, ip
 8990 4d90 00008DE5 		str	r0, [sp]
 8991 4d94 7000A0E3 		mov	r0, #112
 8992 4d98 006097E5 		ldr	r6, [r7]
 8993              	.LVL1038:
 8994 4d9c FEFFFFEB 		bl	SensorWrite2B
 8995              	.LVL1039:
4464:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
 8996              		.loc 1 4464 0
 8997 4da0 241A9FE5 		ldr	r1, .L1075+68
4462:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
 8998              		.loc 1 4462 0
 8999 4da4 0000C6E5 		strb	r0, [r6]
4464:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
 9000              		.loc 1 4464 0
 9001 4da8 38309DE5 		ldr	r3, [sp, #56]
 9002 4dac BC23DDE1 		ldrh	r2, [sp, #60]
 9003 4db0 0300A0E1 		mov	r0, r3
 9004 4db4 03C0F0E5 		ldrb	ip, [r0, #3]!	@ zero_extendqisi2
 9005 4db8 0230D3E5 		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 9006 4dbc 04008DE5 		str	r0, [sp, #4]
 9007 4dc0 00C08DE5 		str	ip, [sp]
 9008 4dc4 0400A0E3 		mov	r0, #4
 9009 4dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 9010              	.LVL1040:
4465:../uvc.c      ****                         	break;
 9011              		.loc 1 4465 0
 9012 4dcc 001097E5 		ldr	r1, [r7]
 9013 4dd0 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 9014 4dd4 000053E3 		cmp	r3, #0
 9015 4dd8 B403001A 		bne	.L652
4471:../uvc.c      ****                 }
 9016              		.loc 1 4471 0
 9017 4ddc BC33DDE1 		ldrh	r3, [sp, #60]
 9018 4de0 023043E2 		sub	r3, r3, #2
 9019 4de4 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
 9020 4de8 39FFFFEA 		b	.L956
 9021              	.LVL1041:
 9022              	.L1047:
4441:../uvc.c      ****                     }
 9023              		.loc 1 4441 0
 9024 4dec BC23CDE1 		strh	r2, [sp, #60]	@ movhi
 9025 4df0 94699FE5 		ldr	r6, .L1075+4
 9026              	.LVL1042:
 9027 4df4 2CFFFFEA 		b	.L953
 9028              	.L1049:
4358:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 9029              		.loc 1 4358 0
 9030 4df8 C0399FE5 		ldr	r3, .L1075+56
 9031 4dfc 0210A0E3 		mov	r1, #2
 9032 4e00 002093E5 		ldr	r2, [r3]
4359:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 9033              		.loc 1 4359 0
 9034 4e04 0180A0E3 		mov	r8, #1
4358:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 9035              		.loc 1 4358 0
 9036 4e08 0010C2E5 		strb	r1, [r2]
4359:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 9037              		.loc 1 4359 0
 9038 4e0c 001093E5 		ldr	r1, [r3]
4360:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 9039              		.loc 1 4360 0
 9040 4e10 0020A0E3 		mov	r2, #0
4359:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 9041              		.loc 1 4359 0
 9042 4e14 0180C1E5 		strb	r8, [r1, #1]
4360:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 9043              		.loc 1 4360 0
 9044 4e18 001093E5 		ldr	r1, [r3]
4364:../uvc.c      **** 					interStabuf.status = 0;
 9045              		.loc 1 4364 0
 9046 4e1c 01CBA0E3 		mov	ip, #1024
4360:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 9047              		.loc 1 4360 0
 9048 4e20 0220C1E5 		strb	r2, [r1, #2]
4361:../uvc.c      **** 
 9049              		.loc 1 4361 0
 9050 4e24 001093E5 		ldr	r1, [r3]
4367:../uvc.c      **** 
 9051              		.loc 1 4367 0
 9052 4e28 04A0A0E3 		mov	r10, #4
4361:../uvc.c      **** 
 9053              		.loc 1 4361 0
 9054 4e2c 0320C1E5 		strb	r2, [r1, #3]
4363:../uvc.c      **** 					interStabuf.size   = 1024;
 9055              		.loc 1 4363 0
 9056 4e30 003093E5 		ldr	r3, [r3]
4370:../uvc.c      **** 
 9057              		.loc 1 4370 0
 9058 4e34 0010E0E3 		mvn	r1, #0
 9059 4e38 84099FE5 		ldr	r0, .L1075+60
4365:../uvc.c      **** 
 9060              		.loc 1 4365 0
 9061 4e3c BC24CDE1 		strh	r2, [sp, #76]	@ movhi
4363:../uvc.c      **** 					interStabuf.size   = 1024;
 9062              		.loc 1 4363 0
 9063 4e40 44308DE5 		str	r3, [sp, #68]
4364:../uvc.c      **** 					interStabuf.status = 0;
 9064              		.loc 1 4364 0
 9065 4e44 BAC4CDE1 		strh	ip, [sp, #74]	@ movhi
4367:../uvc.c      **** 
 9066              		.loc 1 4367 0
 9067 4e48 B8A4CDE1 		strh	r10, [sp, #72]	@ movhi
4370:../uvc.c      **** 
 9068              		.loc 1 4370 0
 9069 4e4c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 9070              	.LVL1043:
4373:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 9071              		.loc 1 4373 0
 9072 4e50 6C099FE5 		ldr	r0, .L1075+60
 9073 4e54 44108DE2 		add	r1, sp, #68
 9074 4e58 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 9075              	.LVL1044:
4375:../uvc.c      **** 					{
 9076              		.loc 1 4375 0
 9077 4e5c 002050E2 		subs	r2, r0, #0
 9078 4e60 7407001A 		bne	.L1056
4380:../uvc.c      **** 
 9079              		.loc 1 4380 0
 9080 4e64 0500A0E3 		mov	r0, #5
 9081              	.LVL1045:
 9082 4e68 3010A0E3 		mov	r1, #48
 9083 4e6c FEFFFFEB 		bl	SensorSetControl
 9084              	.LVL1046:
4382:../uvc.c      **** 				}else if(!snapButFlag){
 9085              		.loc 1 4382 0
 9086 4e70 0C87C6E5 		strb	r8, [r6, #1804]
 9087 4e74 30309DE5 		ldr	r3, [sp, #48]
 9088 4e78 95FEFFEA 		b	.L945
 9089              	.LVL1047:
 9090              	.L954:
4445:../uvc.c      ****                         {
 9091              		.loc 1 4445 0
 9092 4e7c 0330D1E5 		ldrb	r3, [r1, #3]	@ zero_extendqisi2
 9093 4e80 000053E3 		cmp	r3, #0
 9094 4e84 00699F05 		ldreq	r6, .L1075+4
 9095              	.LVL1048:
 9096 4e88 9200001A 		bne	.L1057
 9097              	.L955:
4450:../uvc.c      ****                     }
 9098              		.loc 1 4450 0
 9099 4e8c 8338A0E1 		mov	r3, r3, asl #17
 9100 4e90 013883E2 		add	r3, r3, #65536
 9101 4e94 2338A0E1 		mov	r3, r3, lsr #16
 9102 4e98 0320A0E1 		mov	r2, r3
 9103 4e9c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
 9104 4ea0 01FFFFEA 		b	.L953
 9105              	.L932:
 9106              	.LBB433:
 9107              	.LBB190:
3728:../uvc.c      ****     {
 9108              		.loc 1 3728 0
 9109 4ea4 110C53E3 		cmp	r3, #4352
 9110 4ea8 AE01000A 		beq	.L938
 9111 4eac 8F01009A 		bls	.L1058
 9112 4eb0 120C53E3 		cmp	r3, #4608
 9113 4eb4 A701000A 		beq	.L941
 9114 4eb8 130C53E3 		cmp	r3, #4864
 9115 4ebc 9BFEFF1A 		bne	.L658
 9116              	.LVL1049:
3809:../uvc.c      ****     		break;
 9117              		.loc 1 3809 0
 9118 4ec0 2600A0E3 		mov	r0, #38
 9119 4ec4 FEFFFFEB 		bl	ControlHandle
 9120              	.LVL1050:
 9121 4ec8 30309DE5 		ldr	r3, [sp, #48]
 9122 4ecc 73FEFFEA 		b	.L657
 9123              	.L668:
 9124              	.LBE190:
 9125              	.LBE433:
 9126              	.LBB434:
 9127              	.LBB421:
3423:../uvc.c      ****     {
 9128              		.loc 1 3423 0
 9129 4ed0 010B52E3 		cmp	r2, #1024
 9130 4ed4 71FEFF0A 		beq	.L657
 9131 4ed8 050C52E3 		cmp	r2, #1280
 9132 4edc 8EFEFF1A 		bne	.L741
 9133              	.LVL1051:
 9134              	.LBB375:
 9135              	.LBB376:
 813:../uvc.c      ****     /*
 9136              		.loc 1 813 0
 9137 4ee0 B0389FE5 		ldr	r3, .L1075+16
 806:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 9138              		.loc 1 806 0
 9139 4ee4 B4689FE5 		ldr	r6, .L1075+24
 813:../uvc.c      ****     /*
 9140              		.loc 1 813 0
 9141 4ee8 0080D3E5 		ldrb	r8, [r3]	@ zero_extendqisi2
 806:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 9142              		.loc 1 806 0
 9143 4eec EF11D6E5 		ldrb	r1, [r6, #495]	@ zero_extendqisi2
 9144              	.LVL1052:
 821:../uvc.c      **** 		 {
 9145              		.loc 1 821 0
 9146 4ef0 830058E3 		cmp	r8, #131
 807:../uvc.c      ****     }
 9147              		.loc 1 807 0
 9148 4ef4 E2A1D6E5 		ldrb	r10, [r6, #482]	@ zero_extendqisi2
 9149              	.LVL1053:
 821:../uvc.c      **** 		 {
 9150              		.loc 1 821 0
 9151 4ef8 8203000A 		beq	.L697
 9152 4efc 3902009A 		bls	.L1059
 9153 4f00 850058E3 		cmp	r8, #133
 9154 4f04 BE03000A 		beq	.L702
 9155 4f08 B303003A 		bcc	.L703
 9156 4f0c 860058E3 		cmp	r8, #134
 9157 4f10 DD03000A 		beq	.L704
 9158 4f14 870058E3 		cmp	r8, #135
 9159 4f18 D203001A 		bne	.L696
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9160              		.loc 1 1246 0
 9161 4f1c EB21D6E5 		ldrb	r2, [r6, #491]	@ zero_extendqisi2
1247:../uvc.c      **** 			 }
 9162              		.loc 1 1247 0
 9163 4f20 EC31D6E5 		ldrb	r3, [r6, #492]	@ zero_extendqisi2
 9164              	.L1012:
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9165              		.loc 1 1249 0
 9166 4f24 B0189FE5 		ldr	r1, .L1075+84
 9167 4f28 0A00A0E1 		mov	r0, r10
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9168              		.loc 1 1246 0
 9169 4f2c 2820C5E5 		strb	r2, [r5, #40]
 9170              	.L1011:
1247:../uvc.c      **** 			 }
 9171              		.loc 1 1247 0
 9172 4f30 2930C5E5 		strb	r3, [r5, #41]
 9173              	.L1013:
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9174              		.loc 1 1249 0
 9175 4f34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9176              	.LVL1054:
 9177 4f38 2890D5E5 		ldrb	r9, [r5, #40]	@ zero_extendqisi2
1250:../uvc.c      **** 			  break;
 9178              		.loc 1 1250 0
 9179 4f3c FF10A0E3 		mov	r1, #255
 9180 4f40 0120A0E1 		mov	r2, r1
 9181 4f44 0130A0E1 		mov	r3, r1
 9182              	.LVL1055:
 9183              	.L706:
1710:../uvc.c      **** }
 9184              		.loc 1 1710 0
 9185 4f48 04028DE8 		stmia	sp, {r2, r9}
 9186 4f4c 08108DE5 		str	r1, [sp, #8]
 9187              	.LVL1056:
 9188              	.L1029:
 9189              	.LBE376:
 9190              	.LBE375:
 9191              	.LBB385:
 9192              	.LBB386:
 9193 4f50 0820A0E1 		mov	r2, r8
 9194 4f54 0400A0E3 		mov	r0, #4
 9195 4f58 44189FE5 		ldr	r1, .L1075+28
 9196 4f5c FEFFFFEB 		bl	CyU3PDebugPrint
 9197              	.LVL1057:
 9198 4f60 30309DE5 		ldr	r3, [sp, #48]
 9199 4f64 4DFEFFEA 		b	.L657
 9200              	.L1052:
 9201              	.LBE386:
 9202              	.LBE385:
3423:../uvc.c      ****     {
 9203              		.loc 1 3423 0
 9204 4f68 070C52E3 		cmp	r2, #1792
 9205 4f6c 6C00000A 		beq	.L674
 9206 4f70 020B52E3 		cmp	r2, #2048
 9207 4f74 68FEFF1A 		bne	.L741
 9208              	.LVL1058:
 9209              	.LBB396:
 9210              	.LBB387:
 813:../uvc.c      ****     /*
 9211              		.loc 1 813 0
 9212 4f78 18389FE5 		ldr	r3, .L1075+16
 805:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 9213              		.loc 1 805 0
 9214 4f7c 1C689FE5 		ldr	r6, .L1075+24
 813:../uvc.c      ****     /*
 9215              		.loc 1 813 0
 9216 4f80 0080D3E5 		ldrb	r8, [r3]	@ zero_extendqisi2
 805:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 9217              		.loc 1 805 0
 9218 4f84 2902D6E5 		ldrb	r0, [r6, #553]	@ zero_extendqisi2
 9219              	.LVL1059:
 821:../uvc.c      **** 		 {
 9220              		.loc 1 821 0
 9221 4f88 830058E3 		cmp	r8, #131
 806:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 9222              		.loc 1 806 0
 9223 4f8c 3712D6E5 		ldrb	r1, [r6, #567]	@ zero_extendqisi2
 9224              	.LVL1060:
 807:../uvc.c      ****     }
 9225              		.loc 1 807 0
 9226 4f90 2A92D6E5 		ldrb	r9, [r6, #554]	@ zero_extendqisi2
 9227              	.LVL1061:
 821:../uvc.c      **** 		 {
 9228              		.loc 1 821 0
 9229 4f94 D003000A 		beq	.L727
 9230 4f98 C501009A 		bls	.L1060
 9231 4f9c 850058E3 		cmp	r8, #133
 9232 4fa0 6003000A 		beq	.L732
 9233 4fa4 C203003A 		bcc	.L733
 9234 4fa8 860058E3 		cmp	r8, #134
 9235 4fac BB03000A 		beq	.L734
 9236 4fb0 870058E3 		cmp	r8, #135
 9237 4fb4 7703001A 		bne	.L726
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9238              		.loc 1 1246 0
 9239 4fb8 3322D6E5 		ldrb	r2, [r6, #563]	@ zero_extendqisi2
1247:../uvc.c      **** 			 }
 9240              		.loc 1 1247 0
 9241 4fbc 3432D6E5 		ldrb	r3, [r6, #564]	@ zero_extendqisi2
 9242              	.L1015:
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9243              		.loc 1 1249 0
 9244 4fc0 14189FE5 		ldr	r1, .L1075+84
 9245 4fc4 0900A0E1 		mov	r0, r9
1246:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9246              		.loc 1 1246 0
 9247 4fc8 2820C5E5 		strb	r2, [r5, #40]
 9248              	.L1014:
1247:../uvc.c      **** 			 }
 9249              		.loc 1 1247 0
 9250 4fcc 2930C5E5 		strb	r3, [r5, #41]
 9251              	.L1016:
1249:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9252              		.loc 1 1249 0
 9253 4fd0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9254              	.LVL1062:
 9255 4fd4 2800D5E5 		ldrb	r0, [r5, #40]	@ zero_extendqisi2
1250:../uvc.c      **** 			  break;
 9256              		.loc 1 1250 0
 9257 4fd8 FF20A0E3 		mov	r2, #255
 9258 4fdc 0210A0E1 		mov	r1, r2
 9259 4fe0 0230A0E1 		mov	r3, r2
 9260              	.LVL1063:
 9261              	.L736:
1710:../uvc.c      **** }
 9262              		.loc 1 1710 0
 9263 4fe4 00108DE5 		str	r1, [sp]
 9264 4fe8 05008DE9 		stmib	sp, {r0, r2}
 9265 4fec D7FFFFEA 		b	.L1029
 9266              	.LVL1064:
 9267              	.L745:
 9268              	.LBE387:
 9269              	.LBE396:
 9270              	.LBE421:
 9271              	.LBE434:
 9272              	.LBB435:
 9273              	.LBB354:
3498:../uvc.c      ****     {
 9274              		.loc 1 3498 0
 9275 4ff0 010B52E3 		cmp	r2, #1024
 9276 4ff4 1901000A 		beq	.L748
 9277 4ff8 050C52E3 		cmp	r2, #1280
 9278 4ffc 46FEFF1A 		bne	.L741
 9279              	.LVL1065:
 9280              	.LBB212:
 9281              	.LBB213:
1734:../uvc.c      **** 
 9282              		.loc 1 1734 0
 9283 5000 90A79FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9284              		.loc 1 1729 0
 9285 5004 94679FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9286              		.loc 1 1734 0
 9287 5008 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9288              		.loc 1 1729 0
 9289 500c EE95D6E5 		ldrb	r9, [r6, #1518]	@ zero_extendqisi2
 9290              	.LVL1066:
1736:../uvc.c      **** 		 {
 9291              		.loc 1 1736 0
 9292 5010 830058E3 		cmp	r8, #131
 9293 5014 9204000A 		beq	.L832
 9294 5018 8202009A 		bls	.L1061
 9295 501c 850058E3 		cmp	r8, #133
 9296 5020 7001000A 		beq	.L894
 9297 5024 2505003A 		bcc	.L838
 9298 5028 860058E3 		cmp	r8, #134
 9299 502c 2105000A 		beq	.L839
 9300 5030 870058E3 		cmp	r8, #135
 9301 5034 2405001A 		bne	.L831
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9302              		.loc 1 1798 0
 9303 5038 F7C5D6E5 		ldrb	ip, [r6, #1527]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9304              		.loc 1 1799 0
 9305 503c F825D6E5 		ldrb	r2, [r6, #1528]	@ zero_extendqisi2
 9306              	.LVL1067:
 9307              	.L1026:
 9308              	.LBE213:
 9309              	.LBE212:
 9310              	.LBB218:
 9311              	.LBB219:
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9312              		.loc 1 1777 0
 9313 5040 0030A0E3 		mov	r3, #0
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9314              		.loc 1 1779 0
 9315 5044 0900A0E1 		mov	r0, r9
 9316 5048 8C179FE5 		ldr	r1, .L1075+84
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9317              		.loc 1 1775 0
 9318 504c 2920C5E5 		strb	r2, [r5, #41]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9319              		.loc 1 1774 0
 9320 5050 28C0C5E5 		strb	ip, [r5, #40]
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9321              		.loc 1 1777 0
 9322 5054 2A30C5E5 		strb	r3, [r5, #42]
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9323              		.loc 1 1778 0
 9324 5058 2B30C5E5 		strb	r3, [r5, #43]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9325              		.loc 1 1779 0
 9326 505c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9327              	.LVL1068:
 9328 5060 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 9329              	.LVL1069:
 9330              	.L898:
1949:../uvc.c      **** }
 9331              		.loc 1 1949 0
 9332 5064 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
 9333 5068 08208DE5 		str	r2, [sp, #8]
 9334 506c FF30A0E3 		mov	r3, #255
 9335 5070 0820A0E1 		mov	r2, r8
 9336 5074 14908DE5 		str	r9, [sp, #20]
 9337              	.LVL1070:
 9338              	.L1030:
 9339 5078 04108DE5 		str	r1, [sp, #4]
 9340 507c 10108DE5 		str	r1, [sp, #16]
 9341 5080 00308DE5 		str	r3, [sp]
 9342 5084 0C308DE5 		str	r3, [sp, #12]
 9343 5088 0400A0E3 		mov	r0, #4
 9344 508c 34179FE5 		ldr	r1, .L1075+64
 9345 5090 FEFFFFEB 		bl	CyU3PDebugPrint
 9346              	.LVL1071:
 9347 5094 30309DE5 		ldr	r3, [sp, #48]
 9348 5098 00FEFFEA 		b	.L657
 9349              	.L1043:
 9350              	.LBE219:
 9351              	.LBE218:
3498:../uvc.c      ****     {
 9352              		.loc 1 3498 0
 9353 509c 070C52E3 		cmp	r2, #1792
 9354 50a0 7400000A 		beq	.L752
 9355 50a4 020B52E3 		cmp	r2, #2048
 9356 50a8 FCFDFF0A 		beq	.L657
 9357 50ac 1AFEFFEA 		b	.L741
 9358              	.L1053:
 9359              	.LBE354:
 9360              	.LBE435:
 9361              	.LBB436:
 9362              	.LBB191:
3728:../uvc.c      ****     {
 9363              		.loc 1 3728 0
 9364 50b0 020C53E3 		cmp	r3, #512
 9365 50b4 2301000A 		beq	.L923
 9366 50b8 030C53E3 		cmp	r3, #768
 9367 50bc 1D01000A 		beq	.L924
 9368 50c0 010C53E3 		cmp	r3, #256
 9369 50c4 19FEFF1A 		bne	.L658
 9370              	.LVL1072:
3732:../uvc.c      ****     		break;
 9371              		.loc 1 3732 0
 9372 50c8 1000A0E3 		mov	r0, #16
 9373 50cc FEFFFFEB 		bl	ControlHandle
 9374              	.LVL1073:
 9375 50d0 30309DE5 		ldr	r3, [sp, #48]
 9376 50d4 F1FDFFEA 		b	.L657
 9377              	.L1057:
 9378              	.LBE191:
 9379              	.LBE436:
4447:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
 9380              		.loc 1 4447 0
 9381 50d8 008097E5 		ldr	r8, [r7]
 9382 50dc 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 9383 50e0 0220D1E5 		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 9384 50e4 8330A0E1 		mov	r3, r3, asl #1
 9385 50e8 011088E2 		add	r1, r8, #1
 9386 50ec FE3003E2 		and	r3, r3, #254
 9387 50f0 00108DE5 		str	r1, [sp]
 9388 50f4 0010A0E1 		mov	r1, r0
 9389 50f8 7100A0E3 		mov	r0, #113
 9390 50fc FEFFFFEB 		bl	SensorRead
 9391              	.LVL1074:
 9392 5100 84669FE5 		ldr	r6, .L1075+4
 9393 5104 0000C8E5 		strb	r0, [r8]
 9394 5108 38309DE5 		ldr	r3, [sp, #56]
 9395 510c 0330D3E5 		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 9396 5110 5DFFFFEA 		b	.L955
 9397              	.L672:
 9398              	.LVL1075:
 9399              	.LBB437:
 9400              	.LBB422:
3460:../uvc.c      ****     		break;
 9401              		.loc 1 3460 0
 9402 5114 0900A0E3 		mov	r0, #9
 9403 5118 FEFFFFEB 		bl	ControlHandle
 9404              	.LVL1076:
 9405 511c 30309DE5 		ldr	r3, [sp, #48]
 9406 5120 DEFDFFEA 		b	.L657
 9407              	.L674:
 9408              	.LVL1077:
3450:../uvc.c      ****           		break;
 9409              		.loc 1 3450 0
 9410 5124 0600A0E3 		mov	r0, #6
 9411 5128 FEFFFFEB 		bl	ControlHandle
 9412              	.LVL1078:
 9413 512c 30309DE5 		ldr	r3, [sp, #48]
 9414 5130 DAFDFFEA 		b	.L657
 9415              	.L669:
 9416              	.LVL1079:
3427:../uvc.c      ****     		break;
 9417              		.loc 1 3427 0
 9418 5134 0000A0E3 		mov	r0, #0
 9419 5138 FEFFFFEB 		bl	ControlHandle
 9420              	.LVL1080:
 9421 513c 30309DE5 		ldr	r3, [sp, #48]
 9422 5140 D6FDFFEA 		b	.L657
 9423              	.L667:
 9424              	.LVL1081:
3435:../uvc.c      **** 			break;
 9425              		.loc 1 3435 0
 9426 5144 0200A0E3 		mov	r0, #2
 9427 5148 FEFFFFEB 		bl	ControlHandle
 9428              	.LVL1082:
 9429 514c 30309DE5 		ldr	r3, [sp, #48]
 9430 5150 D2FDFFEA 		b	.L657
 9431              	.L676:
 9432              	.LVL1083:
3468:../uvc.c      ****     		break;
 9433              		.loc 1 3468 0
 9434 5154 0E00A0E3 		mov	r0, #14
 9435 5158 FEFFFFEB 		bl	ControlHandle
 9436              	.LVL1084:
 9437 515c 30309DE5 		ldr	r3, [sp, #48]
 9438 5160 CEFDFFEA 		b	.L657
 9439              	.L665:
 9440              	.LVL1085:
3446:../uvc.c      ****      		break;
 9441              		.loc 1 3446 0
 9442 5164 0500A0E3 		mov	r0, #5
 9443 5168 FEFFFFEB 		bl	ControlHandle
 9444              	.LVL1086:
 9445 516c 30309DE5 		ldr	r3, [sp, #48]
 9446 5170 CAFDFFEA 		b	.L657
 9447              	.L744:
 9448              	.LVL1087:
 9449              	.LBE422:
 9450              	.LBE437:
 9451              	.LBB438:
 9452              	.LBB355:
 9453              	.LBB228:
 9454              	.LBB229:
1734:../uvc.c      **** 
 9455              		.loc 1 1734 0
 9456 5174 1CA69FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9457              		.loc 1 1729 0
 9458 5178 20869FE5 		ldr	r8, .L1075+24
1734:../uvc.c      **** 
 9459              		.loc 1 1734 0
 9460 517c 0060DAE5 		ldrb	r6, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9461              		.loc 1 1729 0
 9462 5180 BE95D8E5 		ldrb	r9, [r8, #1470]	@ zero_extendqisi2
 9463              	.LVL1088:
1736:../uvc.c      **** 		 {
 9464              		.loc 1 1736 0
 9465 5184 830056E3 		cmp	r6, #131
 9466 5188 1204000A 		beq	.L785
 9467 518c 1302009A 		bls	.L1062
 9468 5190 850056E3 		cmp	r6, #133
 9469 5194 B302000A 		beq	.L848
 9470 5198 6004003A 		bcc	.L791
 9471 519c 860056E3 		cmp	r6, #134
 9472 51a0 A403000A 		beq	.L792
 9473 51a4 870056E3 		cmp	r6, #135
 9474 51a8 9703001A 		bne	.L784
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9475              		.loc 1 1798 0
 9476 51ac C7C5D8E5 		ldrb	ip, [r8, #1479]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9477              		.loc 1 1799 0
 9478 51b0 C825D8E5 		ldrb	r2, [r8, #1480]	@ zero_extendqisi2
 9479              	.LVL1089:
 9480              	.L1022:
 9481              	.LBE229:
 9482              	.LBE228:
 9483              	.LBB235:
 9484              	.LBB236:
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9485              		.loc 1 1777 0
 9486 51b4 0030A0E3 		mov	r3, #0
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9487              		.loc 1 1779 0
 9488 51b8 0900A0E1 		mov	r0, r9
 9489 51bc 18169FE5 		ldr	r1, .L1075+84
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9490              		.loc 1 1775 0
 9491 51c0 2920C5E5 		strb	r2, [r5, #41]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9492              		.loc 1 1774 0
 9493 51c4 28C0C5E5 		strb	ip, [r5, #40]
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9494              		.loc 1 1777 0
 9495 51c8 2A30C5E5 		strb	r3, [r5, #42]
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9496              		.loc 1 1778 0
 9497 51cc 2B30C5E5 		strb	r3, [r5, #43]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9498              		.loc 1 1779 0
 9499 51d0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9500              	.LVL1090:
 9501 51d4 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 9502              	.LVL1091:
 9503              	.L852:
1949:../uvc.c      **** }
 9504              		.loc 1 1949 0
 9505 51d8 08208DE5 		str	r2, [sp, #8]
 9506 51dc 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
 9507 51e0 FF30A0E3 		mov	r3, #255
 9508 51e4 14908DE5 		str	r9, [sp, #20]
 9509 51e8 0620A0E1 		mov	r2, r6
 9510 51ec A1FFFFEA 		b	.L1030
 9511              	.LVL1092:
 9512              	.L746:
 9513              	.LBE236:
 9514              	.LBE235:
 9515              	.LBB245:
 9516              	.LBB246:
1734:../uvc.c      **** 
 9517              		.loc 1 1734 0
 9518 51f0 A0A59FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9519              		.loc 1 1729 0
 9520 51f4 A4659FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9521              		.loc 1 1734 0
 9522 51f8 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9523              		.loc 1 1729 0
 9524 51fc 8E95D6E5 		ldrb	r9, [r6, #1422]	@ zero_extendqisi2
 9525              	.LVL1093:
1736:../uvc.c      **** 		 {
 9526              		.loc 1 1736 0
 9527 5200 830058E3 		cmp	r8, #131
 9528 5204 D203000A 		beq	.L757
 9529 5208 9901009A 		bls	.L1063
 9530 520c 850058E3 		cmp	r8, #133
 9531 5210 F400000A 		beq	.L894
 9532 5214 D303003A 		bcc	.L763
 9533 5218 860058E3 		cmp	r8, #134
 9534 521c CF03000A 		beq	.L764
 9535 5220 870058E3 		cmp	r8, #135
 9536 5224 EE03001A 		bne	.L756
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9537              		.loc 1 1798 0
 9538 5228 97C5D6E5 		ldrb	ip, [r6, #1431]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9539              		.loc 1 1799 0
 9540 522c 9825D6E5 		ldrb	r2, [r6, #1432]	@ zero_extendqisi2
 9541 5230 82FFFFEA 		b	.L1026
 9542              	.LVL1094:
 9543              	.L742:
 9544              	.LBE246:
 9545              	.LBE245:
 9546              	.LBB251:
 9547              	.LBB237:
1734:../uvc.c      **** 
 9548              		.loc 1 1734 0
 9549 5234 5CA59FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9550              		.loc 1 1729 0
 9551 5238 60859FE5 		ldr	r8, .L1075+24
1734:../uvc.c      **** 
 9552              		.loc 1 1734 0
 9553 523c 0060DAE5 		ldrb	r6, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9554              		.loc 1 1729 0
 9555 5240 0696D8E5 		ldrb	r9, [r8, #1542]	@ zero_extendqisi2
 9556              	.LVL1095:
1736:../uvc.c      **** 		 {
 9557              		.loc 1 1736 0
 9558 5244 830056E3 		cmp	r6, #131
 9559 5248 6604000A 		beq	.L843
 9560 524c 5902009A 		bls	.L1064
 9561 5250 850056E3 		cmp	r6, #133
 9562 5254 8302000A 		beq	.L848
 9563 5258 A803003A 		bcc	.L849
 9564 525c 860056E3 		cmp	r6, #134
 9565 5260 A403000A 		beq	.L850
 9566 5264 870056E3 		cmp	r6, #135
 9567 5268 5103001A 		bne	.L842
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9568              		.loc 1 1798 0
 9569 526c 0FC6D8E5 		ldrb	ip, [r8, #1551]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9570              		.loc 1 1799 0
 9571 5270 1026D8E5 		ldrb	r2, [r8, #1552]	@ zero_extendqisi2
 9572 5274 CEFFFFEA 		b	.L1022
 9573              	.LVL1096:
 9574              	.L752:
 9575              	.LBE237:
 9576              	.LBE251:
 9577              	.LBB252:
 9578              	.LBB253:
1734:../uvc.c      **** 
 9579              		.loc 1 1734 0
 9580 5278 18A59FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9581              		.loc 1 1729 0
 9582 527c 1C659FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9583              		.loc 1 1734 0
 9584 5280 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9585              		.loc 1 1729 0
 9586 5284 1E96D6E5 		ldrb	r9, [r6, #1566]	@ zero_extendqisi2
 9587              	.LVL1097:
1736:../uvc.c      **** 		 {
 9588              		.loc 1 1736 0
 9589 5288 830058E3 		cmp	r8, #131
 9590 528c EE03000A 		beq	.L854
 9591 5290 3602009A 		bls	.L1065
 9592 5294 850058E3 		cmp	r8, #133
 9593 5298 D200000A 		beq	.L894
 9594 529c 0C04003A 		bcc	.L860
 9595 52a0 860058E3 		cmp	r8, #134
 9596 52a4 0804000A 		beq	.L861
 9597 52a8 870058E3 		cmp	r8, #135
 9598 52ac 5304001A 		bne	.L853
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9599              		.loc 1 1798 0
 9600 52b0 27C6D6E5 		ldrb	ip, [r6, #1575]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9601              		.loc 1 1799 0
 9602 52b4 2826D6E5 		ldrb	r2, [r6, #1576]	@ zero_extendqisi2
 9603 52b8 60FFFFEA 		b	.L1026
 9604              	.LVL1098:
 9605              	.L754:
 9606              	.LBE253:
 9607              	.LBE252:
 9608              	.LBB259:
 9609              	.LBB260:
1734:../uvc.c      **** 
 9610              		.loc 1 1734 0
 9611 52bc D4A49FE5 		ldr	r10, .L1075+16
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9612              		.loc 1 1726 0
 9613 52c0 D8649FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9614              		.loc 1 1734 0
 9615 52c4 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9616              		.loc 1 1726 0
 9617 52c8 8BB6D6E5 		ldrb	fp, [r6, #1675]	@ zero_extendqisi2
 9618              	.LVL1099:
1736:../uvc.c      **** 		 {
 9619              		.loc 1 1736 0
 9620 52cc 830058E3 		cmp	r8, #131
1727:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9621              		.loc 1 1727 0
 9622 52d0 7C36D6E5 		ldrb	r3, [r6, #1660]	@ zero_extendqisi2
 9623              	.LVL1100:
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9624              		.loc 1 1729 0
 9625 52d4 7E96D6E5 		ldrb	r9, [r6, #1662]	@ zero_extendqisi2
 9626              	.LVL1101:
1736:../uvc.c      **** 		 {
 9627              		.loc 1 1736 0
 9628 52d8 B803000A 		beq	.L900
 9629 52dc 7601009A 		bls	.L1066
 9630 52e0 850058E3 		cmp	r8, #133
 9631 52e4 A503000A 		beq	.L905
 9632 52e8 A103003A 		bcc	.L906
 9633 52ec 860058E3 		cmp	r8, #134
 9634 52f0 EB03000A 		beq	.L907
 9635 52f4 870058E3 		cmp	r8, #135
 9636 52f8 DC03001A 		bne	.L899
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9637              		.loc 1 1798 0
 9638 52fc 87E6D6E5 		ldrb	lr, [r6, #1671]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9639              		.loc 1 1799 0
 9640 5300 88C6D6E5 		ldrb	ip, [r6, #1672]	@ zero_extendqisi2
 9641              	.L1028:
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9642              		.loc 1 1778 0
 9643 5304 0030A0E3 		mov	r3, #0
1776:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 9644              		.loc 1 1776 0
 9645 5308 0120A0E3 		mov	r2, #1
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9646              		.loc 1 1779 0
 9647 530c 0900A0E1 		mov	r0, r9
 9648 5310 C4149FE5 		ldr	r1, .L1075+84
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9649              		.loc 1 1778 0
 9650 5314 2B30C5E5 		strb	r3, [r5, #43]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9651              		.loc 1 1774 0
 9652 5318 28E0C5E5 		strb	lr, [r5, #40]
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9653              		.loc 1 1775 0
 9654 531c 29C0C5E5 		strb	ip, [r5, #41]
1776:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 9655              		.loc 1 1776 0
 9656 5320 2A20C5E5 		strb	r2, [r5, #42]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9657              		.loc 1 1779 0
 9658 5324 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9659              	.LVL1102:
 9660 5328 2830D5E5 		ldrb	r3, [r5, #40]	@ zero_extendqisi2
1780:../uvc.c      **** 			  break;
 9661              		.loc 1 1780 0
 9662 532c FFA0A0E3 		mov	r10, #255
 9663 5330 0A60A0E1 		mov	r6, r10
 9664              	.LVL1103:
 9665              	.L909:
1949:../uvc.c      **** }
 9666              		.loc 1 1949 0
 9667 5334 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
 9668 5338 FF00A0E3 		mov	r0, #255
 9669 533c 08308DE5 		str	r3, [sp, #8]
 9670 5340 04108DE5 		str	r1, [sp, #4]
 9671 5344 0630A0E1 		mov	r3, r6
 9672 5348 10108DE5 		str	r1, [sp, #16]
 9673 534c 0C008DE5 		str	r0, [sp, #12]
 9674 5350 00A08DE5 		str	r10, [sp]
 9675 5354 14908DE5 		str	r9, [sp, #20]
 9676 5358 0820A0E1 		mov	r2, r8
 9677 535c 0400A0E3 		mov	r0, #4
 9678 5360 60149FE5 		ldr	r1, .L1075+64
 9679 5364 FEFFFFEB 		bl	CyU3PDebugPrint
 9680              	.LVL1104:
 9681 5368 30309DE5 		ldr	r3, [sp, #48]
 9682 536c 4BFDFFEA 		b	.L657
 9683              	.LVL1105:
 9684              	.L1044:
 9685              	.LBE260:
 9686              	.LBE259:
 9687              	.LBB267:
 9688              	.LBB268:
1734:../uvc.c      **** 
 9689              		.loc 1 1734 0
 9690 5370 20A49FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9691              		.loc 1 1729 0
 9692 5374 24649FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9693              		.loc 1 1734 0
 9694 5378 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9695              		.loc 1 1729 0
 9696 537c 4E96D6E5 		ldrb	r9, [r6, #1614]	@ zero_extendqisi2
 9697              	.LVL1106:
1736:../uvc.c      **** 		 {
 9698              		.loc 1 1736 0
 9699 5380 830058E3 		cmp	r8, #131
 9700 5384 A403000A 		beq	.L878
 9701 5388 CA01009A 		bls	.L1067
 9702 538c 850058E3 		cmp	r8, #133
 9703 5390 9400000A 		beq	.L894
 9704 5394 6404003A 		bcc	.L884
 9705 5398 860058E3 		cmp	r8, #134
 9706 539c 6004000A 		beq	.L885
 9707 53a0 870058E3 		cmp	r8, #135
 9708 53a4 5304001A 		bne	.L877
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9709              		.loc 1 1798 0
 9710 53a8 57C6D6E5 		ldrb	ip, [r6, #1623]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9711              		.loc 1 1799 0
 9712 53ac 5826D6E5 		ldrb	r2, [r6, #1624]	@ zero_extendqisi2
 9713 53b0 22FFFFEA 		b	.L1026
 9714              	.LVL1107:
 9715              	.L750:
 9716              	.LBE268:
 9717              	.LBE267:
 9718              	.LBB273:
 9719              	.LBB274:
1734:../uvc.c      **** 
 9720              		.loc 1 1734 0
 9721 53b4 DCA39FE5 		ldr	r10, .L1075+16
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9722              		.loc 1 1726 0
 9723 53b8 E0639FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9724              		.loc 1 1734 0
 9725 53bc 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9726              		.loc 1 1726 0
 9727 53c0 43B6D6E5 		ldrb	fp, [r6, #1603]	@ zero_extendqisi2
 9728              	.LVL1108:
1736:../uvc.c      **** 		 {
 9729              		.loc 1 1736 0
 9730 53c4 830058E3 		cmp	r8, #131
1727:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9731              		.loc 1 1727 0
 9732 53c8 3436D6E5 		ldrb	r3, [r6, #1588]	@ zero_extendqisi2
 9733              	.LVL1109:
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9734              		.loc 1 1729 0
 9735 53cc 3696D6E5 		ldrb	r9, [r6, #1590]	@ zero_extendqisi2
 9736              	.LVL1110:
1736:../uvc.c      **** 		 {
 9737              		.loc 1 1736 0
 9738 53d0 0704000A 		beq	.L865
 9739 53d4 0902009A 		bls	.L1068
 9740 53d8 850058E3 		cmp	r8, #133
 9741 53dc 2902000A 		beq	.L870
 9742 53e0 D103003A 		bcc	.L871
 9743 53e4 860058E3 		cmp	r8, #134
 9744 53e8 EE03000A 		beq	.L872
 9745 53ec 870058E3 		cmp	r8, #135
 9746 53f0 DF03001A 		bne	.L864
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9747              		.loc 1 1798 0
 9748 53f4 3FC6D6E5 		ldrb	ip, [r6, #1599]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9749              		.loc 1 1799 0
 9750 53f8 4026D6E5 		ldrb	r2, [r6, #1600]	@ zero_extendqisi2
 9751              	.LVL1111:
 9752              	.L1024:
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9753              		.loc 1 1777 0
 9754 53fc 0030A0E3 		mov	r3, #0
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9755              		.loc 1 1779 0
 9756 5400 D4139FE5 		ldr	r1, .L1075+84
 9757 5404 0900A0E1 		mov	r0, r9
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9758              		.loc 1 1775 0
 9759 5408 2920C5E5 		strb	r2, [r5, #41]
1777:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9760              		.loc 1 1777 0
 9761 540c 2A30C5E5 		strb	r3, [r5, #42]
1778:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9762              		.loc 1 1778 0
 9763 5410 2B30C5E5 		strb	r3, [r5, #43]
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9764              		.loc 1 1774 0
 9765 5414 28C0C5E5 		strb	ip, [r5, #40]
1779:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9766              		.loc 1 1779 0
 9767 5418 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9768              	.LVL1112:
 9769 541c 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
1780:../uvc.c      **** 			  break;
 9770              		.loc 1 1780 0
 9771 5420 FF20A0E3 		mov	r2, #255
 9772 5424 0230A0E1 		mov	r3, r2
 9773              	.LVL1113:
 9774              	.L874:
1949:../uvc.c      **** }
 9775              		.loc 1 1949 0
 9776 5428 2A00D5E5 		ldrb	r0, [r5, #42]	@ zero_extendqisi2
 9777 542c FFC0A0E3 		mov	ip, #255
 9778 5430 00208DE5 		str	r2, [sp]
 9779 5434 08108DE5 		str	r1, [sp, #8]
 9780 5438 04008DE5 		str	r0, [sp, #4]
 9781 543c 10008DE5 		str	r0, [sp, #16]
 9782 5440 14908DE5 		str	r9, [sp, #20]
 9783 5444 0820A0E1 		mov	r2, r8
 9784 5448 0CC08DE5 		str	ip, [sp, #12]
 9785 544c 0400A0E3 		mov	r0, #4
 9786 5450 70139FE5 		ldr	r1, .L1075+64
 9787 5454 FEFFFFEB 		bl	CyU3PDebugPrint
 9788              	.LVL1114:
 9789 5458 30309DE5 		ldr	r3, [sp, #48]
 9790 545c 0FFDFFEA 		b	.L657
 9791              	.L748:
 9792              	.LVL1115:
 9793              	.LBE274:
 9794              	.LBE273:
 9795              	.LBB282:
 9796              	.LBB283:
1734:../uvc.c      **** 
 9797              		.loc 1 1734 0
 9798 5460 30A39FE5 		ldr	r10, .L1075+16
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9799              		.loc 1 1726 0
 9800 5464 34639FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9801              		.loc 1 1734 0
 9802 5468 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1726:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9803              		.loc 1 1726 0
 9804 546c E3B5D6E5 		ldrb	fp, [r6, #1507]	@ zero_extendqisi2
 9805              	.LVL1116:
1736:../uvc.c      **** 		 {
 9806              		.loc 1 1736 0
 9807 5470 830058E3 		cmp	r8, #131
1727:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9808              		.loc 1 1727 0
 9809 5474 D435D6E5 		ldrb	r3, [r6, #1492]	@ zero_extendqisi2
 9810              	.LVL1117:
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9811              		.loc 1 1729 0
 9812 5478 D695D6E5 		ldrb	r9, [r6, #1494]	@ zero_extendqisi2
 9813              	.LVL1118:
1736:../uvc.c      **** 		 {
 9814              		.loc 1 1736 0
 9815 547c 5203000A 		beq	.L796
 9816 5480 3801009A 		bls	.L1069
 9817 5484 850058E3 		cmp	r8, #133
 9818 5488 FE01000A 		beq	.L870
 9819 548c F503003A 		bcc	.L802
 9820 5490 860058E3 		cmp	r8, #134
 9821 5494 F103000A 		beq	.L803
 9822 5498 870058E3 		cmp	r8, #135
 9823 549c E203001A 		bne	.L795
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9824              		.loc 1 1798 0
 9825 54a0 DFC5D6E5 		ldrb	ip, [r6, #1503]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9826              		.loc 1 1799 0
 9827 54a4 E025D6E5 		ldrb	r2, [r6, #1504]	@ zero_extendqisi2
 9828 54a8 D3FFFFEA 		b	.L1024
 9829              	.LVL1119:
 9830              	.L753:
 9831              	.LBE283:
 9832              	.LBE282:
 9833              	.LBB290:
 9834              	.LBB220:
1734:../uvc.c      **** 
 9835              		.loc 1 1734 0
 9836 54ac E4A29FE5 		ldr	r10, .L1075+16
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9837              		.loc 1 1729 0
 9838 54b0 E8629FE5 		ldr	r6, .L1075+24
1734:../uvc.c      **** 
 9839              		.loc 1 1734 0
 9840 54b4 0080DAE5 		ldrb	r8, [r10]	@ zero_extendqisi2
1729:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9841              		.loc 1 1729 0
 9842 54b8 6696D6E5 		ldrb	r9, [r6, #1638]	@ zero_extendqisi2
 9843              	.LVL1120:
1736:../uvc.c      **** 		 {
 9844              		.loc 1 1736 0
 9845 54bc 830058E3 		cmp	r8, #131
 9846 54c0 5203000A 		beq	.L889
 9847 54c4 6901009A 		bls	.L1070
 9848 54c8 850058E3 		cmp	r8, #133
 9849 54cc 4500000A 		beq	.L894
 9850 54d0 FF02003A 		bcc	.L895
 9851 54d4 860058E3 		cmp	r8, #134
 9852 54d8 F502000A 		beq	.L896
 9853 54dc 870058E3 		cmp	r8, #135
 9854 54e0 BE02001A 		bne	.L888
1798:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9855              		.loc 1 1798 0
 9856 54e4 6FC6D6E5 		ldrb	ip, [r6, #1647]	@ zero_extendqisi2
1799:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9857              		.loc 1 1799 0
 9858 54e8 7026D6E5 		ldrb	r2, [r6, #1648]	@ zero_extendqisi2
 9859 54ec D3FEFFEA 		b	.L1026
 9860              	.LVL1121:
 9861              	.L1058:
 9862              	.LBE220:
 9863              	.LBE290:
 9864              	.LBE355:
 9865              	.LBE438:
 9866              	.LBB439:
 9867              	.LBB192:
3728:../uvc.c      ****     {
 9868              		.loc 1 3728 0
 9869 54f0 010A53E3 		cmp	r3, #4096
 9870 54f4 0DFDFF1A 		bne	.L658
 9871              	.LVL1122:
3797:../uvc.c      ****     		break;
 9872              		.loc 1 3797 0
 9873 54f8 1F00A0E3 		mov	r0, #31
 9874 54fc FEFFFFEB 		bl	ControlHandle
 9875              	.LVL1123:
 9876 5500 30309DE5 		ldr	r3, [sp, #48]
 9877 5504 E5FCFFEA 		b	.L657
 9878              	.L1039:
3728:../uvc.c      ****     {
 9879              		.loc 1 3728 0
 9880 5508 0A0C53E3 		cmp	r3, #2560
 9881 550c 07FDFF1A 		bne	.L658
 9882              	.LVL1124:
3769:../uvc.c      ****     		}else/* no support for 1080p camera */
 9883              		.loc 1 3769 0
 9884 5510 1900A0E3 		mov	r0, #25
 9885 5514 FEFFFFEB 		bl	ControlHandle
 9886              	.LVL1125:
 9887 5518 30309DE5 		ldr	r3, [sp, #48]
 9888 551c DFFCFFEA 		b	.L657
 9889              	.L1054:
3728:../uvc.c      ****     {
 9890              		.loc 1 3728 0
 9891 5520 050C53E3 		cmp	r3, #1280
 9892 5524 01FDFF1A 		bne	.L658
 9893              	.LVL1126:
3748:../uvc.c      ****     		break;
 9894              		.loc 1 3748 0
 9895 5528 1400A0E3 		mov	r0, #20
 9896 552c FEFFFFEB 		bl	ControlHandle
 9897              	.LVL1127:
 9898 5530 30309DE5 		ldr	r3, [sp, #48]
 9899 5534 D9FCFFEA 		b	.L657
 9900              	.L924:
 9901              	.LVL1128:
3740:../uvc.c      ****      		break;
 9902              		.loc 1 3740 0
 9903 5538 1200A0E3 		mov	r0, #18
 9904 553c FEFFFFEB 		bl	ControlHandle
 9905              	.LVL1129:
 9906 5540 30309DE5 		ldr	r3, [sp, #48]
 9907 5544 D5FCFFEA 		b	.L657
 9908              	.L923:
 9909              	.LVL1130:
3736:../uvc.c      ****     		break;
 9910              		.loc 1 3736 0
 9911 5548 1100A0E3 		mov	r0, #17
 9912 554c FEFFFFEB 		bl	ControlHandle
 9913              	.LVL1131:
 9914 5550 30309DE5 		ldr	r3, [sp, #48]
 9915 5554 D1FCFFEA 		b	.L657
 9916              	.L941:
 9917              	.LVL1132:
3805:../uvc.c      ****     		break;
 9918              		.loc 1 3805 0
 9919 5558 2500A0E3 		mov	r0, #37
 9920 555c FEFFFFEB 		bl	ControlHandle
 9921              	.LVL1133:
 9922 5560 30309DE5 		ldr	r3, [sp, #48]
 9923 5564 CDFCFFEA 		b	.L657
 9924              	.L938:
 9925              	.LVL1134:
3801:../uvc.c      ****     		break;
 9926              		.loc 1 3801 0
 9927 5568 2400A0E3 		mov	r0, #36
 9928 556c FEFFFFEB 		bl	ControlHandle
 9929              	.LVL1135:
 9930 5570 30309DE5 		ldr	r3, [sp, #48]
 9931 5574 C9FCFFEA 		b	.L657
 9932              	.L933:
 9933              	.LVL1136:
3775:../uvc.c      ****     		break;
 9934              		.loc 1 3775 0
 9935 5578 1A00A0E3 		mov	r0, #26
 9936 557c FEFFFFEB 		bl	ControlHandle
 9937              	.LVL1137:
 9938 5580 30309DE5 		ldr	r3, [sp, #48]
 9939 5584 C5FCFFEA 		b	.L657
 9940              	.L926:
 9941              	.LVL1138:
3752:../uvc.c      ****      		break;
 9942              		.loc 1 3752 0
 9943 5588 1500A0E3 		mov	r0, #21
 9944 558c FEFFFFEB 		bl	ControlHandle
 9945              	.LVL1139:
 9946 5590 30309DE5 		ldr	r3, [sp, #48]
 9947 5594 C1FCFFEA 		b	.L657
 9948              	.L921:
 9949              	.LVL1140:
3744:../uvc.c      ****     		break;
 9950              		.loc 1 3744 0
 9951 5598 1300A0E3 		mov	r0, #19
 9952 559c FEFFFFEB 		bl	ControlHandle
 9953              	.LVL1141:
 9954 55a0 30309DE5 		ldr	r3, [sp, #48]
 9955 55a4 BDFCFFEA 		b	.L657
 9956              	.L931:
 9957              	.LVL1142:
3793:../uvc.c      ****     		break;
 9958              		.loc 1 3793 0
 9959 55a8 1E00A0E3 		mov	r0, #30
 9960 55ac FEFFFFEB 		bl	ControlHandle
 9961              	.LVL1143:
 9962 55b0 30309DE5 		ldr	r3, [sp, #48]
 9963 55b4 B9FCFFEA 		b	.L657
 9964              	.L936:
 9965              	.LVL1144:
3779:../uvc.c      ****     		break;
 9966              		.loc 1 3779 0
 9967 55b8 1B00A0E3 		mov	r0, #27
 9968 55bc FEFFFFEB 		bl	ControlHandle
 9969              	.LVL1145:
 9970 55c0 30309DE5 		ldr	r3, [sp, #48]
 9971 55c4 B5FCFFEA 		b	.L657
 9972              	.L919:
 9973              	.LVL1146:
3764:../uvc.c      ****      		break;
 9974              		.loc 1 3764 0
 9975 55c8 1800A0E3 		mov	r0, #24
 9976 55cc FEFFFFEB 		bl	ControlHandle
 9977              	.LVL1147:
 9978 55d0 30309DE5 		ldr	r3, [sp, #48]
 9979 55d4 B1FCFFEA 		b	.L657
 9980              	.L929:
 9981              	.LVL1148:
3756:../uvc.c      ****     		break;
 9982              		.loc 1 3756 0
 9983 55d8 1600A0E3 		mov	r0, #22
 9984 55dc FEFFFFEB 		bl	ControlHandle
 9985              	.LVL1149:
 9986 55e0 30309DE5 		ldr	r3, [sp, #48]
 9987 55e4 ADFCFFEA 		b	.L657
 9988              	.L894:
 9989              	.LBE192:
 9990              	.LBE439:
 9991              	.LBB440:
 9992              	.LBB356:
 9993              	.LBB291:
 9994              	.LBB221:
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9995              		.loc 1 1741 0
 9996 55e8 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9997              		.loc 1 1742 0
 9998 55ec 0200A0E3 		mov	r0, #2
 9999 55f0 E4119FE5 		ldr	r1, .L1075+84
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10000              		.loc 1 1740 0
 10001 55f4 2890C5E5 		strb	r9, [r5, #40]
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10002              		.loc 1 1741 0
 10003 55f8 2930C5E5 		strb	r3, [r5, #41]
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10004              		.loc 1 1742 0
 10005 55fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10006              	.LVL1150:
 10007 5600 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 10008 5604 96FEFFEA 		b	.L898
 10009              	.LVL1151:
 10010              	.L1045:
 10011              	.LBE221:
 10012              	.LBE291:
 10013              	.LBE356:
 10014              	.LBE440:
 10015              	.LBB441:
 10016              	.LBB423:
 10017              	.LBB397:
 10018              	.LBB368:
 821:../uvc.c      **** 		 {
 10019              		.loc 1 821 0
 10020 5608 810058E3 		cmp	r8, #129
 10021 560c 3802000A 		beq	.L681
 10022 5610 3402008A 		bhi	.L682
 10023 5614 010058E3 		cmp	r8, #1
 10024 5618 E701001A 		bne	.L678
1253:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10025              		.loc 1 1253 0
 10026 561c 2E208DE2 		add	r2, sp, #46
 10027 5620 2000A0E3 		mov	r0, #32
 10028 5624 B0119FE5 		ldr	r1, .L1075+84
 10029 5628 20308DE5 		str	r3, [sp, #32]
 10030 562c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10031              	.LVL1152:
1255:../uvc.c      **** 			   {
 10032              		.loc 1 1255 0
 10033 5630 002050E2 		subs	r2, r0, #0
 10034 5634 5A05001A 		bne	.L693
1513:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 10035              		.loc 1 1513 0
 10036 5638 A4A19FE5 		ldr	r10, .L1075+92
 10037              	.LVL1153:
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10038              		.loc 1 1260 0
 10039 563c 2A20D4E5 		ldrb	r2, [r4, #42]	@ zero_extendqisi2
1513:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 10040              		.loc 1 1513 0
 10041 5640 0010E0E3 		mvn	r1, #0
 10042 5644 1C009AE5 		ldr	r0, [r10, #28]
 10043              	.LVL1154:
1257:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 10044              		.loc 1 1257 0
 10045 5648 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 10046              	.LVL1155:
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10047              		.loc 1 1260 0
 10048 564c 24208DE5 		str	r2, [sp, #36]
 10049              	.LVL1156:
1513:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 10050              		.loc 1 1513 0
 10051 5650 FEFFFFEB 		bl	_txe_mutex_get
 10052              	.LVL1157:
1515:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 10053              		.loc 1 1515 0
 10054 5654 80001BE3 		tst	fp, #128
 10055 5658 20309DE5 		ldr	r3, [sp, #32]
1516:../uvc.c      **** 							  }else{
 10056              		.loc 1 1516 0
 10057 565c 80C04B12 		subne	ip, fp, #128
1518:../uvc.c      **** 							  }
 10058              		.loc 1 1518 0
 10059 5660 0BC0E001 		mvneq	ip, fp
1520:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10060              		.loc 1 1520 0
 10061 5664 0010A0E3 		mov	r1, #0
 10062 5668 0320A0E1 		mov	r2, r3
 10063 566c 04108DE5 		str	r1, [sp, #4]
 10064 5670 0930A0E1 		mov	r3, r9
 10065 5674 0110A0E3 		mov	r1, #1
 10066 5678 64019FE5 		ldr	r0, .L1075+92
1518:../uvc.c      **** 							  }
 10067              		.loc 1 1518 0
 10068 567c FFC00CE2 		and	ip, ip, #255
 10069              	.LVL1158:
1520:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10070              		.loc 1 1520 0
 10071 5680 00C08DE5 		str	ip, [sp]
 10072 5684 1CC08DE5 		str	ip, [sp, #28]
 10073 5688 FEFFFFEB 		bl	cmdSet
 10074              	.LVL1159:
1521:../uvc.c      **** 
 10075              		.loc 1 1521 0
 10076 568c 1C009AE5 		ldr	r0, [r10, #28]
 10077 5690 FEFFFFEB 		bl	_txe_mutex_put
 10078              	.LVL1160:
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 10079              		.loc 1 1523 0
 10080 5694 1CC09DE5 		ldr	ip, [sp, #28]
1524:../uvc.c      **** 
 10081              		.loc 1 1524 0
 10082 5698 0110A0E3 		mov	r1, #1
 10083 569c A811C6E5 		strb	r1, [r6, #424]
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 10084              		.loc 1 1523 0
 10085 56a0 A5C1C6E5 		strb	ip, [r6, #421]
 10086 56a4 0B30A0E1 		mov	r3, fp
 10087 56a8 24209DE5 		ldr	r2, [sp, #36]
1524:../uvc.c      **** 
 10088              		.loc 1 1524 0
 10089 56ac FF10A0E3 		mov	r1, #255
 10090 56b0 D9FCFFEA 		b	.L688
 10091              	.LVL1161:
 10092              	.L1060:
 10093              	.LBE368:
 10094              	.LBE397:
 10095              	.LBB398:
 10096              	.LBB388:
 821:../uvc.c      **** 		 {
 10097              		.loc 1 821 0
 10098 56b4 810058E3 		cmp	r8, #129
 10099 56b8 D901000A 		beq	.L729
 10100 56bc D501008A 		bhi	.L730
 10101 56c0 010058E3 		cmp	r8, #1
 10102 56c4 B301001A 		bne	.L726
1253:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10103              		.loc 1 1253 0
 10104 56c8 2E208DE2 		add	r2, sp, #46
 10105 56cc 2000A0E3 		mov	r0, #32
 10106 56d0 04119FE5 		ldr	r1, .L1075+84
 10107 56d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10108              	.LVL1162:
1255:../uvc.c      **** 			   {
 10109              		.loc 1 1255 0
 10110 56d8 002050E2 		subs	r2, r0, #0
 10111 56dc 3705001A 		bne	.L739
1257:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 10112              		.loc 1 1257 0
 10113 56e0 2890D4E5 		ldrb	r9, [r4, #40]	@ zero_extendqisi2
 10114              	.LVL1163:
1651:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 10115              		.loc 1 1651 0
 10116 56e4 78B5D6E5 		ldrb	fp, [r6, #1400]	@ zero_extendqisi2
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10117              		.loc 1 1260 0
 10118 56e8 2A30D4E5 		ldrb	r3, [r4, #42]	@ zero_extendqisi2
1652:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 10119              		.loc 1 1652 0
 10120 56ec 79C5D6E5 		ldrb	ip, [r6, #1401]	@ zero_extendqisi2
1653:../uvc.c      **** 						     dataIdx = 0;
 10121              		.loc 1 1653 0
 10122 56f0 87A5D6E5 		ldrb	r10, [r6, #1415]	@ zero_extendqisi2
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 10123              		.loc 1 1655 0
 10124 56f4 8595C6E5 		strb	r9, [r6, #1413]
1656:../uvc.c      **** 							 if(Data0 != 0){
 10125              		.loc 1 1656 0
 10126 56f8 8985C6E5 		strb	r8, [r6, #1417]
1658:../uvc.c      **** #ifdef COLOR
 10127              		.loc 1 1658 0
 10128 56fc E0609FE5 		ldr	r6, .L1075+92
1657:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 10129              		.loc 1 1657 0
 10130 5700 000059E3 		cmp	r9, #0
1651:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 10131              		.loc 1 1651 0
 10132 5704 FFB00BE2 		and	fp, fp, #255
1652:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 10133              		.loc 1 1652 0
 10134 5708 FFC00CE2 		and	ip, ip, #255
1653:../uvc.c      **** 						     dataIdx = 0;
 10135              		.loc 1 1653 0
 10136 570c FFA00AE2 		and	r10, r10, #255
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10137              		.loc 1 1260 0
 10138 5710 24308DE5 		str	r3, [sp, #36]
 10139              	.LVL1164:
1658:../uvc.c      **** #ifdef COLOR
 10140              		.loc 1 1658 0
 10141 5714 0010E0E3 		mvn	r1, #0
 10142 5718 1C0096E5 		ldr	r0, [r6, #28]
 10143              	.LVL1165:
1657:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 10144              		.loc 1 1657 0
 10145 571c 8B03000A 		beq	.L740
1658:../uvc.c      **** #ifdef COLOR
 10146              		.loc 1 1658 0
 10147 5720 1CC08DE5 		str	ip, [sp, #28]
 10148 5724 20208DE5 		str	r2, [sp, #32]
 10149 5728 FEFFFFEB 		bl	_txe_mutex_get
 10150              	.LVL1166:
1662:../uvc.c      **** 								 dataIdx++;
 10151              		.loc 1 1662 0
 10152 572c 20209DE5 		ldr	r2, [sp, #32]
 10153 5730 0710A0E3 		mov	r1, #7
 10154 5734 04208DE5 		str	r2, [sp, #4]
 10155 5738 0A30A0E1 		mov	r3, r10
 10156 573c 0B20A0E1 		mov	r2, fp
 10157 5740 00808DE5 		str	r8, [sp]
 10158 5744 0600A0E1 		mov	r0, r6
 10159 5748 FEFFFFEB 		bl	cmdSet
 10160              	.LVL1167:
1664:../uvc.c      **** #endif
 10161              		.loc 1 1664 0
 10162 574c 1CC09DE5 		ldr	ip, [sp, #28]
 10163 5750 0A30A0E1 		mov	r3, r10
 10164 5754 0C20A0E1 		mov	r2, ip
 10165 5758 0710A0E3 		mov	r1, #7
 10166 575c 00908DE5 		str	r9, [sp]
 10167 5760 04808DE5 		str	r8, [sp, #4]
 10168 5764 0600A0E1 		mov	r0, r6
 10169 5768 FEFFFFEB 		bl	cmdSet
 10170              	.LVL1168:
1666:../uvc.c      **** 							 }else{
 10171              		.loc 1 1666 0
 10172 576c 1C0096E5 		ldr	r0, [r6, #28]
 10173 5770 FEFFFFEB 		bl	_txe_mutex_put
 10174              	.LVL1169:
 10175 5774 FF20A0E3 		mov	r2, #255
 10176 5778 0930A0E1 		mov	r3, r9
 10177 577c 24109DE5 		ldr	r1, [sp, #36]
 10178 5780 0200A0E1 		mov	r0, r2
 10179 5784 16FEFFEA 		b	.L736
 10180              	.L1076:
 10181              		.align	2
 10182              	.L1075:
 10183 5788 00000000 		.word	.LANCHOR0
 10184 578c 00000000 		.word	glDebugRspBuffer
 10185 5790 00000000 		.word	wIndex
 10186 5794 00000000 		.word	wValue
 10187 5798 00000000 		.word	bRequest
 10188 579c EC0D0000 		.word	.LC80
 10189 57a0 00000000 		.word	.LANCHOR1
 10190 57a4 54060000 		.word	.LC37
 10191 57a8 00000000 		.word	glDebugCmdChannel
 10192 57ac 800E0000 		.word	.LC83
 10193 57b0 AC0E0000 		.word	.LC84
 10194 57b4 00000000 		.word	glDebugRspChannel
 10195 57b8 580F0000 		.word	.LC88
 10196 57bc F40E0000 		.word	.LC86
 10197 57c0 00000000 		.word	glInterStaBuffer
 10198 57c4 00000000 		.word	glChHandleInterStat
 10199 57c8 14070000 		.word	.LC41
 10200 57cc D40E0000 		.word	.LC85
 10201 57d0 E0050000 		.word	.LC34
 10202 57d4 A4060000 		.word	.LC38
 10203 57d8 CC060000 		.word	.LC39
 10204 57dc 28000000 		.word	.LANCHOR0+40
 10205 57e0 F0060000 		.word	.LC40
 10206 57e4 00000000 		.word	cmdQu
 10207              	.LVL1170:
 10208              	.L1059:
 10209              	.LBE388:
 10210              	.LBE398:
 10211              	.LBB399:
 10212              	.LBB377:
 821:../uvc.c      **** 		 {
 10213              		.loc 1 821 0
 10214 57e8 810058E3 		cmp	r8, #129
 10215 57ec 3401000A 		beq	.L699
 10216 57f0 3001008A 		bhi	.L700
 10217 57f4 010058E3 		cmp	r8, #1
 10218 57f8 9A01001A 		bne	.L696
1253:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10219              		.loc 1 1253 0
 10220 57fc 2E208DE2 		add	r2, sp, #46
 10221 5800 2000A0E3 		mov	r0, #32
 10222 5804 30101FE5 		ldr	r1, .L1075+84
 10223 5808 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10224              	.LVL1171:
1255:../uvc.c      **** 			   {
 10225              		.loc 1 1255 0
 10226 580c 002050E2 		subs	r2, r0, #0
 10227 5810 F204001A 		bne	.L710
1257:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 10228              		.loc 1 1257 0
 10229 5814 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 10230              	.LVL1172:
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 10231              		.loc 1 1590 0
 10232 5818 0400A0E3 		mov	r0, #4
 10233              	.LVL1173:
1578:../uvc.c      **** 							 is60Hz = Data0;
 10234              		.loc 1 1578 0
 10235 581c 01304AE2 		sub	r3, r10, #1
 10236 5820 FF3003E2 		and	r3, r3, #255
1585:../uvc.c      **** 							 {
 10237              		.loc 1 1585 0
 10238 5824 020053E3 		cmp	r3, #2
1579:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 10239              		.loc 1 1579 0
 10240 5828 783084E5 		str	r3, [r4, #120]
1585:../uvc.c      **** 							 {
 10241              		.loc 1 1585 0
 10242 582c 0320A091 		movls	r2, r3
 10243              	.LVL1174:
1588:../uvc.c      **** 							 }
 10244              		.loc 1 1588 0
 10245 5830 78808485 		strhi	r8, [r4, #120]
 10246 5834 0820A081 		movhi	r2, r8
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 10247              		.loc 1 1590 0
 10248 5838 783095E5 		ldr	r3, [r5, #120]
 10249 583c 74101FE5 		ldr	r1, .L1075+72
1260:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10250              		.loc 1 1260 0
 10251 5840 2A90D4E5 		ldrb	r9, [r4, #42]	@ zero_extendqisi2
 10252              	.LVL1175:
1577:../uvc.c      **** 							 Data0 = Data0 - 1;
 10253              		.loc 1 1577 0
 10254 5844 EDA1C6E5 		strb	r10, [r6, #493]
1590:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 10255              		.loc 1 1590 0
 10256 5848 FEFFFFEB 		bl	CyU3PDebugPrint
 10257              	.LVL1176:
1591:../uvc.c      **** 							 {
 10258              		.loc 1 1591 0
 10259 584c 6C3095E5 		ldr	r3, [r5, #108]
 10260 5850 010053E3 		cmp	r3, #1
 10261 5854 6803000A 		beq	.L1071
 10262              	.L712:
1621:../uvc.c      **** 							 break;
 10263              		.loc 1 1621 0
 10264 5858 0100A0E3 		mov	r0, #1
 10265 585c FF10A0E3 		mov	r1, #255
 10266 5860 0920A0E1 		mov	r2, r9
 10267 5864 0A30A0E1 		mov	r3, r10
 10268 5868 F001C6E5 		strb	r0, [r6, #496]
 10269 586c 0190A0E1 		mov	r9, r1
 10270              	.LVL1177:
 10271 5870 B4FDFFEA 		b	.L706
 10272              	.LVL1178:
 10273              	.L1063:
 10274              	.LBE377:
 10275              	.LBE399:
 10276              	.LBE423:
 10277              	.LBE441:
 10278              	.LBB442:
 10279              	.LBB357:
 10280              	.LBB292:
 10281              	.LBB247:
1736:../uvc.c      **** 		 {
 10282              		.loc 1 1736 0
 10283 5874 810058E3 		cmp	r8, #129
 10284 5878 4D02000A 		beq	.L759
 10285 587c 4902008A 		bhi	.L760
 10286 5880 010058E3 		cmp	r8, #1
 10287 5884 5602001A 		bne	.L756
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10288              		.loc 1 1807 0
 10289 5888 B4101FE5 		ldr	r1, .L1075+84
 10290 588c 2E208DE2 		add	r2, sp, #46
 10291 5890 2000A0E3 		mov	r0, #32
 10292 5894 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10293              	.LVL1179:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10294              		.loc 1 1937 0
 10295 5898 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10296              		.loc 1 1938 0
 10297 589c 0020A0E3 		mov	r2, #0
 10298 58a0 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10299 58a4 0400A0E3 		mov	r0, #4
 10300 58a8 D8101FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10301              		.loc 1 1937 0
 10302 58ac 99C5C6E5 		strb	ip, [r6, #1433]
1938:../uvc.c      **** 			  		 break;
 10303              		.loc 1 1938 0
 10304 58b0 FEFFFFEB 		bl	CyU3PDebugPrint
 10305              	.LVL1180:
 10306 58b4 FF20A0E3 		mov	r2, #255
 10307 58b8 E9FDFFEA 		b	.L898
 10308              	.LVL1181:
 10309              	.L1066:
 10310              	.LBE247:
 10311              	.LBE292:
 10312              	.LBB293:
 10313              	.LBB261:
1736:../uvc.c      **** 		 {
 10314              		.loc 1 1736 0
 10315 58bc 810058E3 		cmp	r8, #129
 10316 58c0 EE02000A 		beq	.L902
 10317 58c4 EA02008A 		bhi	.L903
 10318 58c8 010058E3 		cmp	r8, #1
 10319 58cc 6702001A 		bne	.L899
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10320              		.loc 1 1807 0
 10321 58d0 FC101FE5 		ldr	r1, .L1075+84
 10322 58d4 2E208DE2 		add	r2, sp, #46
 10323 58d8 2000A0E3 		mov	r0, #32
1922:../uvc.c      **** 					  if(getData == 1)
 10324              		.loc 1 1922 0
 10325 58dc 00A11FE5 		ldr	r10, .L1075+92
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10326              		.loc 1 1807 0
 10327 58e0 20308DE5 		str	r3, [sp, #32]
 10328 58e4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10329              	.LVL1182:
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10330              		.loc 1 1809 0
 10331 58e8 2860D5E5 		ldrb	r6, [r5, #40]	@ zero_extendqisi2
 10332              	.LVL1183:
1810:../uvc.c      **** 			  value = Data1;
 10333              		.loc 1 1810 0
 10334 58ec 2920D5E5 		ldrb	r2, [r5, #41]	@ zero_extendqisi2
1922:../uvc.c      **** 					  if(getData == 1)
 10335              		.loc 1 1922 0
 10336 58f0 1C009AE5 		ldr	r0, [r10, #28]
 10337 58f4 0010E0E3 		mvn	r1, #0
1810:../uvc.c      **** 			  value = Data1;
 10338              		.loc 1 1810 0
 10339 58f8 24208DE5 		str	r2, [sp, #36]
 10340              	.LVL1184:
1922:../uvc.c      **** 					  if(getData == 1)
 10341              		.loc 1 1922 0
 10342 58fc FEFFFFEB 		bl	_txe_mutex_get
 10343              	.LVL1185:
1923:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 10344              		.loc 1 1923 0
 10345 5900 010056E3 		cmp	r6, #1
 10346 5904 20309DE5 		ldr	r3, [sp, #32]
1924:../uvc.c      **** 					  else if(getData == 0xff)
 10347              		.loc 1 1924 0
 10348 5908 0400A003 		moveq	r0, #4
1923:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 10349              		.loc 1 1923 0
 10350 590c 4403000A 		beq	.L1027
1925:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 10351              		.loc 1 1925 0
 10352 5910 FF0056E3 		cmp	r6, #255
 10353 5914 4103000A 		beq	.L1072
1928:../uvc.c      **** 					  //dataIdx++;
 10354              		.loc 1 1928 0
 10355 5918 0010A0E3 		mov	r1, #0
 10356 591c 0320A0E1 		mov	r2, r3
 10357 5920 00108DE5 		str	r1, [sp]
 10358 5924 04108DE5 		str	r1, [sp, #4]
 10359 5928 0B30A0E1 		mov	r3, fp
 10360 592c 0A00A0E1 		mov	r0, r10
 10361 5930 2310A0E3 		mov	r1, #35
 10362 5934 FEFFFFEB 		bl	cmdSet
 10363              	.LVL1186:
 10364              	.L911:
1931:../uvc.c      **** #endif
 10365              		.loc 1 1931 0
 10366 5938 1C009AE5 		ldr	r0, [r10, #28]
 10367 593c FEFFFFEB 		bl	_txe_mutex_put
 10368              	.LVL1187:
1933:../uvc.c      **** 					  break;
 10369              		.loc 1 1933 0
 10370 5940 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
 10371 5944 24A09DE5 		ldr	r10, [sp, #36]
 10372 5948 00108DE5 		str	r1, [sp]
 10373 594c 0A30A0E1 		mov	r3, r10
 10374 5950 0620A0E1 		mov	r2, r6
 10375 5954 0400A0E3 		mov	r0, #4
 10376 5958 8C111FE5 		ldr	r1, .L1075+76
 10377 595c FEFFFFEB 		bl	CyU3PDebugPrint
 10378              	.LVL1188:
 10379 5960 FF30A0E3 		mov	r3, #255
 10380 5964 72FEFFEA 		b	.L909
 10381              	.LVL1189:
 10382              	.L1069:
 10383              	.LBE261:
 10384              	.LBE293:
 10385              	.LBB294:
 10386              	.LBB284:
1736:../uvc.c      **** 		 {
 10387              		.loc 1 1736 0
 10388 5968 810058E3 		cmp	r8, #129
 10389 596c BC01000A 		beq	.L798
 10390 5970 B801008A 		bhi	.L799
 10391 5974 010058E3 		cmp	r8, #1
 10392 5978 AB02001A 		bne	.L795
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10393              		.loc 1 1807 0
 10394 597c A8111FE5 		ldr	r1, .L1075+84
 10395 5980 2E208DE2 		add	r2, sp, #46
 10396 5984 2000A0E3 		mov	r0, #32
 10397 5988 20308DE5 		str	r3, [sp, #32]
 10398 598c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10399              	.LVL1190:
1865:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10400              		.loc 1 1865 0
 10401 5990 B125D6E5 		ldrb	r2, [r6, #1457]	@ zero_extendqisi2
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10402              		.loc 1 1809 0
 10403 5994 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
1865:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10404              		.loc 1 1865 0
 10405 5998 010052E3 		cmp	r2, #1
 10406 599c 04005213 		cmpne	r2, #4
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10407              		.loc 1 1809 0
 10408 59a0 24108DE5 		str	r1, [sp, #36]
 10409              	.LVL1191:
1810:../uvc.c      **** 			  value = Data1;
 10410              		.loc 1 1810 0
 10411 59a4 29C0D5E5 		ldrb	ip, [r5, #41]	@ zero_extendqisi2
 10412              	.LVL1192:
1865:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10413              		.loc 1 1865 0
 10414 59a8 20309DE5 		ldr	r3, [sp, #32]
 10415 59ac 0D03001A 		bne	.L806
1864:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 10416              		.loc 1 1864 0
 10417 59b0 0C2481E1 		orr	r2, r1, ip, asl #8
1866:../uvc.c      **** 					  {
 10418              		.loc 1 1866 0
 10419 59b4 F90052E3 		cmp	r2, #249
 10420 59b8 0A03008A 		bhi	.L806
 10421              	.LVL1193:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 10422              		.loc 1 1870 0
 10423 59bc C80052E3 		cmp	r2, #200
 10424 59c0 3E03009A 		bls	.L1073
1871:../uvc.c      **** 							}else{
 10425              		.loc 1 1871 0
 10426 59c4 C80042E2 		sub	r0, r2, #200
 10427 59c8 0008A0E1 		mov	r0, r0, asl #16
 10428 59cc 2008A0E1 		mov	r0, r0, lsr #16
 10429              	.LVL1194:
 10430              	.L808:
 10431 59d0 641042E2 		sub	r1, r2, #100
 10432 59d4 0118A0E1 		mov	r1, r1, asl #16
 10433 59d8 2118A0E1 		mov	r1, r1, lsr #16
 10434              	.LVL1195:
 10435 59dc 3F0300EA 		b	.L810
 10436              	.LVL1196:
 10437              	.L1062:
 10438              	.LBE284:
 10439              	.LBE294:
 10440              	.LBB295:
 10441              	.LBB230:
1736:../uvc.c      **** 		 {
 10442              		.loc 1 1736 0
 10443 59e0 810056E3 		cmp	r6, #129
 10444 59e4 7C02000A 		beq	.L787
 10445 59e8 7802008A 		bhi	.L788
 10446 59ec 010056E3 		cmp	r6, #1
 10447 59f0 8501001A 		bne	.L784
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10448              		.loc 1 1807 0
 10449 59f4 20121FE5 		ldr	r1, .L1075+84
 10450 59f8 2E208DE2 		add	r2, sp, #46
 10451 59fc 2000A0E3 		mov	r0, #32
 10452 5a00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10453              	.LVL1197:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10454              		.loc 1 1937 0
 10455 5a04 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10456              		.loc 1 1938 0
 10457 5a08 0220A0E3 		mov	r2, #2
 10458 5a0c 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10459 5a10 0400A0E3 		mov	r0, #4
 10460 5a14 44121FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10461              		.loc 1 1937 0
 10462 5a18 C9C5C8E5 		strb	ip, [r8, #1481]
1938:../uvc.c      **** 			  		 break;
 10463              		.loc 1 1938 0
 10464 5a1c FEFFFFEB 		bl	CyU3PDebugPrint
 10465              	.LVL1198:
 10466 5a20 FF20A0E3 		mov	r2, #255
 10467 5a24 EBFDFFEA 		b	.L852
 10468              	.LVL1199:
 10469              	.L1061:
 10470              	.LBE230:
 10471              	.LBE295:
 10472              	.LBB296:
 10473              	.LBB214:
1736:../uvc.c      **** 		 {
 10474              		.loc 1 1736 0
 10475 5a28 810058E3 		cmp	r8, #129
 10476 5a2c AE01000A 		beq	.L834
 10477 5a30 AA01008A 		bhi	.L835
 10478 5a34 010058E3 		cmp	r8, #1
 10479 5a38 A302001A 		bne	.L831
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10480              		.loc 1 1807 0
 10481 5a3c 68121FE5 		ldr	r1, .L1075+84
 10482 5a40 2E208DE2 		add	r2, sp, #46
 10483 5a44 2000A0E3 		mov	r0, #32
 10484 5a48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10485              	.LVL1200:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10486              		.loc 1 1937 0
 10487 5a4c 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10488              		.loc 1 1938 0
 10489 5a50 0400A0E3 		mov	r0, #4
 10490 5a54 0020A0E1 		mov	r2, r0
 10491 5a58 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10492 5a5c 8C121FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10493              		.loc 1 1937 0
 10494 5a60 F9C5C6E5 		strb	ip, [r6, #1529]
1938:../uvc.c      **** 			  		 break;
 10495              		.loc 1 1938 0
 10496 5a64 FEFFFFEB 		bl	CyU3PDebugPrint
 10497              	.LVL1201:
 10498 5a68 FF20A0E3 		mov	r2, #255
 10499 5a6c 7CFDFFEA 		b	.L898
 10500              	.LVL1202:
 10501              	.L1070:
 10502              	.LBE214:
 10503              	.LBE296:
 10504              	.LBB297:
 10505              	.LBB222:
1736:../uvc.c      **** 		 {
 10506              		.loc 1 1736 0
 10507 5a70 810058E3 		cmp	r8, #129
 10508 5a74 B202000A 		beq	.L891
 10509 5a78 AE02008A 		bhi	.L892
 10510 5a7c 010058E3 		cmp	r8, #1
 10511 5a80 5601001A 		bne	.L888
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10512              		.loc 1 1807 0
 10513 5a84 B0121FE5 		ldr	r1, .L1075+84
 10514 5a88 2E208DE2 		add	r2, sp, #46
 10515 5a8c 2000A0E3 		mov	r0, #32
 10516 5a90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10517              	.LVL1203:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10518              		.loc 1 1937 0
 10519 5a94 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10520              		.loc 1 1938 0
 10521 5a98 0920A0E3 		mov	r2, #9
 10522 5a9c 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10523 5aa0 0400A0E3 		mov	r0, #4
 10524 5aa4 D4121FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10525              		.loc 1 1937 0
 10526 5aa8 71C6C6E5 		strb	ip, [r6, #1649]
1938:../uvc.c      **** 			  		 break;
 10527              		.loc 1 1938 0
 10528 5aac FEFFFFEB 		bl	CyU3PDebugPrint
 10529              	.LVL1204:
 10530 5ab0 FF20A0E3 		mov	r2, #255
 10531 5ab4 6AFDFFEA 		b	.L898
 10532              	.LVL1205:
 10533              	.L1067:
 10534              	.LBE222:
 10535              	.LBE297:
 10536              	.LBB298:
 10537              	.LBB269:
1736:../uvc.c      **** 		 {
 10538              		.loc 1 1736 0
 10539 5ab8 810058E3 		cmp	r8, #129
 10540 5abc 3001000A 		beq	.L880
 10541 5ac0 2C01008A 		bhi	.L881
 10542 5ac4 010058E3 		cmp	r8, #1
 10543 5ac8 8A02001A 		bne	.L877
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10544              		.loc 1 1807 0
 10545 5acc F8121FE5 		ldr	r1, .L1075+84
 10546 5ad0 2E208DE2 		add	r2, sp, #46
 10547 5ad4 2000A0E3 		mov	r0, #32
 10548 5ad8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10549              	.LVL1206:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10550              		.loc 1 1937 0
 10551 5adc 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10552              		.loc 1 1938 0
 10553 5ae0 0820A0E3 		mov	r2, #8
 10554 5ae4 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10555 5ae8 0400A0E3 		mov	r0, #4
 10556 5aec 1C131FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10557              		.loc 1 1937 0
 10558 5af0 59C6C6E5 		strb	ip, [r6, #1625]
1938:../uvc.c      **** 			  		 break;
 10559              		.loc 1 1938 0
 10560 5af4 FEFFFFEB 		bl	CyU3PDebugPrint
 10561              	.LVL1207:
 10562 5af8 FF20A0E3 		mov	r2, #255
 10563 5afc 58FDFFEA 		b	.L898
 10564              	.LVL1208:
 10565              	.L1055:
 10566              	.LBE269:
 10567              	.LBE298:
 10568              	.LBB299:
 10569              	.LBB205:
1736:../uvc.c      **** 		 {
 10570              		.loc 1 1736 0
 10571 5b00 810058E3 		cmp	r8, #129
 10572 5b04 F801000A 		beq	.L770
 10573 5b08 F401008A 		bhi	.L771
 10574 5b0c 010058E3 		cmp	r8, #1
 10575 5b10 8301001A 		bne	.L767
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10576              		.loc 1 1807 0
 10577 5b14 40131FE5 		ldr	r1, .L1075+84
 10578 5b18 2E208DE2 		add	r2, sp, #46
 10579 5b1c 2000A0E3 		mov	r0, #32
 10580 5b20 20308DE5 		str	r3, [sp, #32]
 10581 5b24 1CC08DE5 		str	ip, [sp, #28]
 10582 5b28 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10583              	.LVL1209:
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10584              		.loc 1 1809 0
 10585 5b2c 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 10586              	.LVL1210:
1819:../uvc.c      **** 				    getData = glEp0Buffer[0];
 10587              		.loc 1 1819 0
 10588 5b30 B485C6E5 		strb	r8, [r6, #1460]
 10589              	.LVL1211:
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 10590              		.loc 1 1818 0
 10591 5b34 B125C6E5 		strb	r2, [r6, #1457]
1822:../uvc.c      **** 						case 1:
 10592              		.loc 1 1822 0
 10593 5b38 011042E2 		sub	r1, r2, #1
 10594 5b3c 20309DE5 		ldr	r3, [sp, #32]
 10595 5b40 1CC09DE5 		ldr	ip, [sp, #28]
 10596 5b44 070051E3 		cmp	r1, #7
 10597 5b48 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 10598 5b4c 740300EA 		b	.L778
 10599              	.L780:
 10600 5b50 30690000 		.word	.L779
 10601 5b54 94690000 		.word	.L781
 10602 5b58 24690000 		.word	.L778
 10603 5b5c 14680000 		.word	.L782
 10604 5b60 24690000 		.word	.L778
 10605 5b64 24690000 		.word	.L778
 10606 5b68 24690000 		.word	.L778
 10607 5b6c 78680000 		.word	.L783
 10608              	.LVL1212:
 10609              	.L1065:
 10610              	.LBE205:
 10611              	.LBE299:
 10612              	.LBB300:
 10613              	.LBB254:
1736:../uvc.c      **** 		 {
 10614              		.loc 1 1736 0
 10615 5b70 810058E3 		cmp	r8, #129
 10616 5b74 6701000A 		beq	.L856
 10617 5b78 6301008A 		bhi	.L857
 10618 5b7c 010058E3 		cmp	r8, #1
 10619 5b80 1E02001A 		bne	.L853
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10620              		.loc 1 1807 0
 10621 5b84 B0131FE5 		ldr	r1, .L1075+84
 10622 5b88 2E208DE2 		add	r2, sp, #46
 10623 5b8c 2000A0E3 		mov	r0, #32
 10624 5b90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10625              	.LVL1213:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10626              		.loc 1 1937 0
 10627 5b94 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10628              		.loc 1 1938 0
 10629 5b98 0620A0E3 		mov	r2, #6
 10630 5b9c 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10631 5ba0 0400A0E3 		mov	r0, #4
 10632 5ba4 D4131FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10633              		.loc 1 1937 0
 10634 5ba8 29C6C6E5 		strb	ip, [r6, #1577]
1938:../uvc.c      **** 			  		 break;
 10635              		.loc 1 1938 0
 10636 5bac FEFFFFEB 		bl	CyU3PDebugPrint
 10637              	.LVL1214:
 10638 5bb0 FF20A0E3 		mov	r2, #255
 10639 5bb4 2AFDFFEA 		b	.L898
 10640              	.LVL1215:
 10641              	.L1064:
 10642              	.LBE254:
 10643              	.LBE300:
 10644              	.LBB301:
 10645              	.LBB238:
1736:../uvc.c      **** 		 {
 10646              		.loc 1 1736 0
 10647 5bb8 810056E3 		cmp	r6, #129
 10648 5bbc E001000A 		beq	.L845
 10649 5bc0 DC01008A 		bhi	.L846
 10650 5bc4 010056E3 		cmp	r6, #1
 10651 5bc8 F900001A 		bne	.L842
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10652              		.loc 1 1807 0
 10653 5bcc F8131FE5 		ldr	r1, .L1075+84
 10654 5bd0 2E208DE2 		add	r2, sp, #46
 10655 5bd4 2000A0E3 		mov	r0, #32
 10656 5bd8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10657              	.LVL1216:
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10658              		.loc 1 1937 0
 10659 5bdc 28C0D5E5 		ldrb	ip, [r5, #40]	@ zero_extendqisi2
1938:../uvc.c      **** 			  		 break;
 10660              		.loc 1 1938 0
 10661 5be0 0520A0E3 		mov	r2, #5
 10662 5be4 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 10663 5be8 0400A0E3 		mov	r0, #4
 10664 5bec 1C141FE5 		ldr	r1, .L1075+80
1937:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10665              		.loc 1 1937 0
 10666 5bf0 11C6C8E5 		strb	ip, [r8, #1553]
1938:../uvc.c      **** 			  		 break;
 10667              		.loc 1 1938 0
 10668 5bf4 FEFFFFEB 		bl	CyU3PDebugPrint
 10669              	.LVL1217:
 10670 5bf8 FF20A0E3 		mov	r2, #255
 10671 5bfc 75FDFFEA 		b	.L852
 10672              	.LVL1218:
 10673              	.L1068:
 10674              	.LBE238:
 10675              	.LBE301:
 10676              	.LBB302:
 10677              	.LBB275:
1736:../uvc.c      **** 		 {
 10678              		.loc 1 1736 0
 10679 5c00 810058E3 		cmp	r8, #129
 10680 5c04 2701000A 		beq	.L867
 10681 5c08 2301008A 		bhi	.L868
 10682 5c0c 010058E3 		cmp	r8, #1
 10683 5c10 D701001A 		bne	.L864
1807:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10684              		.loc 1 1807 0
 10685 5c14 2E208DE2 		add	r2, sp, #46
 10686 5c18 2000A0E3 		mov	r0, #32
 10687 5c1c 48141FE5 		ldr	r1, .L1075+84
 10688 5c20 20308DE5 		str	r3, [sp, #32]
 10689 5c24 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10690              	.LVL1219:
1899:../uvc.c      **** 					  {
 10691              		.loc 1 1899 0
 10692 5c28 B105D6E5 		ldrb	r0, [r6, #1457]	@ zero_extendqisi2
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10693              		.loc 1 1809 0
 10694 5c2c 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
1899:../uvc.c      **** 					  {
 10695              		.loc 1 1899 0
 10696 5c30 010050E3 		cmp	r0, #1
 10697 5c34 08005013 		cmpne	r0, #8
1809:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10698              		.loc 1 1809 0
 10699 5c38 24208DE5 		str	r2, [sp, #36]
 10700              	.LVL1220:
1899:../uvc.c      **** 					  {
 10701              		.loc 1 1899 0
 10702 5c3c 0000A013 		movne	r0, #0
 10703 5c40 0100A003 		moveq	r0, #1
1810:../uvc.c      **** 			  value = Data1;
 10704              		.loc 1 1810 0
 10705 5c44 29C0D5E5 		ldrb	ip, [r5, #41]	@ zero_extendqisi2
 10706              	.LVL1221:
1899:../uvc.c      **** 					  {
 10707              		.loc 1 1899 0
 10708 5c48 4F02000A 		beq	.L1074
1911:../uvc.c      **** 					  }
 10709              		.loc 1 1911 0
 10710 5c4c 0020A0E1 		mov	r2, r0
 10711 5c50 0810A0E1 		mov	r1, r8
 10712 5c54 FEFFFFEB 		bl	CyU3PUsbStall
 10713              	.LVL1222:
 10714              	.L876:
 10715 5c58 2830D5E5 		ldrb	r3, [r5, #40]	@ zero_extendqisi2
 10716 5c5c 2920D5E5 		ldrb	r2, [r5, #41]	@ zero_extendqisi2
1914:../uvc.c      **** 
 10717              		.loc 1 1914 0
 10718 5c60 FF10A0E3 		mov	r1, #255
 10719 5c64 EFFDFFEA 		b	.L874
 10720              	.LVL1223:
 10721              	.L848:
 10722              	.LBE275:
 10723              	.LBE302:
 10724              	.LBB303:
 10725              	.LBB239:
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10726              		.loc 1 1741 0
 10727 5c68 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10728              		.loc 1 1742 0
 10729 5c6c 0200A0E3 		mov	r0, #2
 10730 5c70 9C141FE5 		ldr	r1, .L1075+84
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10731              		.loc 1 1740 0
 10732 5c74 2890C5E5 		strb	r9, [r5, #40]
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10733              		.loc 1 1741 0
 10734 5c78 2930C5E5 		strb	r3, [r5, #41]
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10735              		.loc 1 1742 0
 10736 5c7c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10737              	.LVL1224:
 10738 5c80 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 10739 5c84 53FDFFEA 		b	.L852
 10740              	.LVL1225:
 10741              	.L870:
 10742              	.LBE239:
 10743              	.LBE303:
 10744              	.LBB304:
 10745              	.LBB276:
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10746              		.loc 1 1741 0
 10747 5c88 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10748              		.loc 1 1742 0
 10749 5c8c B8141FE5 		ldr	r1, .L1075+84
 10750 5c90 0200A0E3 		mov	r0, #2
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10751              		.loc 1 1741 0
 10752 5c94 2930C5E5 		strb	r3, [r5, #41]
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10753              		.loc 1 1740 0
 10754 5c98 2890C5E5 		strb	r9, [r5, #40]
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10755              		.loc 1 1742 0
 10756 5c9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10757              	.LVL1226:
1743:../uvc.c      **** 			  break;
 10758              		.loc 1 1743 0
 10759 5ca0 FF20A0E3 		mov	r2, #255
 10760 5ca4 0230A0E1 		mov	r3, r2
 10761 5ca8 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
 10762 5cac DDFDFFEA 		b	.L874
 10763              	.LVL1227:
 10764              	.L652:
 10765              	.LBE276:
 10766              	.LBE304:
 10767              	.LBE357:
 10768              	.LBE442:
4509:../uvc.c      **** 
 10769              		.loc 1 4509 0
 10770 5cb0 54D08DE2 		add	sp, sp, #84
 10771              		@ sp needed
 10772 5cb4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 10773              	.LVL1228:
 10774              	.L700:
 10775              	.LBB443:
 10776              	.LBB424:
 10777              	.LBB400:
 10778              	.LBB378:
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10779              		.loc 1 1184 0
 10780 5cb8 E321D6E5 		ldrb	r2, [r6, #483]	@ zero_extendqisi2
1185:../uvc.c      **** 			 }
 10781              		.loc 1 1185 0
 10782 5cbc E431D6E5 		ldrb	r3, [r6, #484]	@ zero_extendqisi2
 10783 5cc0 97FCFFEA 		b	.L1012
 10784              	.L699:
1124:../uvc.c      **** 
 10785              		.loc 1 1124 0
 10786 5cc4 6431D5E5 		ldrb	r3, [r5, #356]	@ zero_extendqisi2
 10787 5cc8 000053E3 		cmp	r3, #0
 10788 5ccc 6D02000A 		beq	.L707
1126:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 10789              		.loc 1 1126 0
 10790 5cd0 783095E5 		ldr	r3, [r5, #120]
1132:../uvc.c      **** 		 	 		 }else{
 10791              		.loc 1 1132 0
 10792 5cd4 EEB1D6E5 		ldrb	fp, [r6, #494]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 10793              		.loc 1 1126 0
 10794 5cd8 000053E3 		cmp	r3, #0
 10795 5cdc 0290A013 		movne	r9, #2
 10796 5ce0 0190A003 		moveq	r9, #1
 10797 5ce4 2890C5E5 		strb	r9, [r5, #40]
1132:../uvc.c      **** 		 	 		 }else{
 10798              		.loc 1 1132 0
 10799 5ce8 29B0C5E5 		strb	fp, [r5, #41]
 10800              	.LVL1229:
 10801              	.L709:
1165:../uvc.c      **** 
 10802              		.loc 1 1165 0
 10803 5cec 18151FE5 		ldr	r1, .L1075+84
 10804 5cf0 0A00A0E1 		mov	r0, r10
 10805 5cf4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10806              	.LVL1230:
 10807 5cf8 FF20A0E3 		mov	r2, #255
 10808 5cfc 0B10A0E1 		mov	r1, fp
 10809 5d00 0230A0E1 		mov	r3, r2
 10810 5d04 8FFCFFEA 		b	.L706
 10811              	.LVL1231:
 10812              	.L697:
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 10813              		.loc 1 1202 0
 10814 5d08 E521D6E5 		ldrb	r2, [r6, #485]	@ zero_extendqisi2
1203:../uvc.c      **** 			 }
 10815              		.loc 1 1203 0
 10816 5d0c E631D6E5 		ldrb	r3, [r6, #486]	@ zero_extendqisi2
 10817 5d10 83FCFFEA 		b	.L1012
 10818              	.LVL1232:
 10819              	.L684:
 10820              	.LBE378:
 10821              	.LBE400:
 10822              	.LBB401:
 10823              	.LBB369:
 826:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10824              		.loc 1 826 0
 10825 5d14 0030A0E3 		mov	r3, #0
 827:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10826              		.loc 1 827 0
 10827 5d18 0200A0E3 		mov	r0, #2
 10828 5d1c 48151FE5 		ldr	r1, .L1075+84
 825:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10829              		.loc 1 825 0
 10830 5d20 28A0C5E5 		strb	r10, [r5, #40]
 10831 5d24 37FBFFEA 		b	.L1009
 10832              	.LVL1233:
 10833              	.L732:
 10834              	.LBE369:
 10835              	.LBE401:
 10836              	.LBB402:
 10837              	.LBB389:
 826:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10838              		.loc 1 826 0
 10839 5d28 0030A0E3 		mov	r3, #0
 827:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10840              		.loc 1 827 0
 10841 5d2c 0200A0E3 		mov	r0, #2
 10842 5d30 5C151FE5 		ldr	r1, .L1075+84
 825:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10843              		.loc 1 825 0
 10844 5d34 2890C5E5 		strb	r9, [r5, #40]
 10845 5d38 A3FCFFEA 		b	.L1014
 10846              	.LVL1234:
 10847              	.L686:
 10848              	.LBE389:
 10849              	.LBE402:
 10850              	.LBB403:
 10851              	.LBB370:
1229:../uvc.c      **** 		 	 }
 10852              		.loc 1 1229 0
 10853 5d3c A131D6E5 		ldrb	r3, [r6, #417]	@ zero_extendqisi2
1231:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10854              		.loc 1 1231 0
 10855 5d40 6C151FE5 		ldr	r1, .L1075+84
 10856 5d44 0100A0E3 		mov	r0, #1
1229:../uvc.c      **** 		 	 }
 10857              		.loc 1 1229 0
 10858 5d48 2830C5E5 		strb	r3, [r5, #40]
1231:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10859              		.loc 1 1231 0
 10860 5d4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10861              	.LVL1235:
1232:../uvc.c      **** 			  Len = 1;
 10862              		.loc 1 1232 0
 10863 5d50 FF20A0E3 		mov	r2, #255
 10864 5d54 0230A0E1 		mov	r3, r2
 10865 5d58 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
 10866 5d5c 2EFBFFEA 		b	.L688
 10867              	.LVL1236:
 10868              	.L685:
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10869              		.loc 1 1217 0
 10870 5d60 A021D6E5 		ldrb	r2, [r6, #416]	@ zero_extendqisi2
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10871              		.loc 1 1216 0
 10872 5d64 9FC1D6E5 		ldrb	ip, [r6, #415]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10873              		.loc 1 1218 0
 10874 5d68 0030A0E3 		mov	r3, #0
1221:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10875              		.loc 1 1221 0
 10876 5d6c 98151FE5 		ldr	r1, .L1075+84
 10877 5d70 0A00A0E1 		mov	r0, r10
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10878              		.loc 1 1217 0
 10879 5d74 2920C5E5 		strb	r2, [r5, #41]
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10880              		.loc 1 1218 0
 10881 5d78 2A30C5E5 		strb	r3, [r5, #42]
1219:../uvc.c      **** 		 	 }
 10882              		.loc 1 1219 0
 10883 5d7c 2B30C5E5 		strb	r3, [r5, #43]
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10884              		.loc 1 1216 0
 10885 5d80 28C0C5E5 		strb	ip, [r5, #40]
1221:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10886              		.loc 1 1221 0
 10887 5d84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10888              	.LVL1237:
1222:../uvc.c      **** 			  break;
 10889              		.loc 1 1222 0
 10890 5d88 FF20A0E3 		mov	r2, #255
 10891 5d8c 0230A0E1 		mov	r3, r2
 10892 5d90 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
 10893 5d94 20FBFFEA 		b	.L688
 10894              	.LVL1238:
 10895              	.L726:
 10896              	.LBE370:
 10897              	.LBE403:
 10898              	.LBB404:
 10899              	.LBB390:
1707:../uvc.c      **** 			  break;
 10900              		.loc 1 1707 0
 10901 5d98 0000A0E3 		mov	r0, #0
 10902 5d9c 0020A0E1 		mov	r2, r0
 10903 5da0 0110A0E3 		mov	r1, #1
 10904 5da4 FEFFFFEB 		bl	CyU3PUsbStall
 10905              	.LVL1239:
 10906 5da8 FF20A0E3 		mov	r2, #255
 10907 5dac 0200A0E1 		mov	r0, r2
 10908 5db0 0210A0E1 		mov	r1, r2
 10909 5db4 0230A0E1 		mov	r3, r2
 10910 5db8 89FCFFEA 		b	.L736
 10911              	.LVL1240:
 10912              	.L678:
 10913              	.LBE390:
 10914              	.LBE404:
 10915              	.LBB405:
 10916              	.LBB371:
 10917 5dbc 0000A0E3 		mov	r0, #0
 10918 5dc0 0020A0E1 		mov	r2, r0
 10919 5dc4 0110A0E3 		mov	r1, #1
 10920 5dc8 FEFFFFEB 		bl	CyU3PUsbStall
 10921              	.LVL1241:
 10922 5dcc FF10A0E3 		mov	r1, #255
 10923 5dd0 0120A0E1 		mov	r2, r1
 10924 5dd4 0130A0E1 		mov	r3, r1
 10925 5dd8 0FFBFFEA 		b	.L688
 10926              	.LVL1242:
 10927              	.L703:
 10928              	.LBE371:
 10929              	.LBE405:
 10930              	.LBB406:
 10931              	.LBB379:
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10932              		.loc 1 1216 0
 10933 5ddc E7C1D6E5 		ldrb	ip, [r6, #487]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10934              		.loc 1 1217 0
 10935 5de0 E821D6E5 		ldrb	r2, [r6, #488]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10936              		.loc 1 1218 0
 10937 5de4 0030A0E3 		mov	r3, #0
1221:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10938              		.loc 1 1221 0
 10939 5de8 0A00A0E1 		mov	r0, r10
 10940 5dec 18161FE5 		ldr	r1, .L1075+84
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10941              		.loc 1 1216 0
 10942 5df0 28C0C5E5 		strb	ip, [r5, #40]
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10943              		.loc 1 1217 0
 10944 5df4 2920C5E5 		strb	r2, [r5, #41]
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10945              		.loc 1 1218 0
 10946 5df8 2A30C5E5 		strb	r3, [r5, #42]
1219:../uvc.c      **** 		 	 }
 10947              		.loc 1 1219 0
 10948 5dfc 2B30C5E5 		strb	r3, [r5, #43]
 10949 5e00 4BFCFFEA 		b	.L1013
 10950              	.L702:
 826:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10951              		.loc 1 826 0
 10952 5e04 0030A0E3 		mov	r3, #0
 827:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10953              		.loc 1 827 0
 10954 5e08 0200A0E3 		mov	r0, #2
 10955 5e0c 38161FE5 		ldr	r1, .L1075+84
 825:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10956              		.loc 1 825 0
 10957 5e10 28A0C5E5 		strb	r10, [r5, #40]
 10958 5e14 45FCFFEA 		b	.L1011
 10959              	.LVL1243:
 10960              	.L730:
 10961              	.LBE379:
 10962              	.LBE406:
 10963              	.LBB407:
 10964              	.LBB391:
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10965              		.loc 1 1184 0
 10966 5e18 2B22D6E5 		ldrb	r2, [r6, #555]	@ zero_extendqisi2
1185:../uvc.c      **** 			 }
 10967              		.loc 1 1185 0
 10968 5e1c 2C32D6E5 		ldrb	r3, [r6, #556]	@ zero_extendqisi2
 10969 5e20 66FCFFEA 		b	.L1015
 10970              	.L729:
1077:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10971              		.loc 1 1077 0
 10972 5e24 6731D5E5 		ldrb	r3, [r5, #359]	@ zero_extendqisi2
 10973 5e28 000053E3 		cmp	r3, #0
 10974 5e2c 0A02000A 		beq	.L737
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10975              		.loc 1 1078 0
 10976 5e30 85A5D6E5 		ldrb	r10, [r6, #1413]	@ zero_extendqisi2
1079:../uvc.c      **** 		 	 		 }else{
 10977              		.loc 1 1079 0
 10978 5e34 8665D6E5 		ldrb	r6, [r6, #1414]	@ zero_extendqisi2
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10979              		.loc 1 1078 0
 10980 5e38 FFA00AE2 		and	r10, r10, #255
1079:../uvc.c      **** 		 	 		 }else{
 10981              		.loc 1 1079 0
 10982 5e3c FF6006E2 		and	r6, r6, #255
1078:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10983              		.loc 1 1078 0
 10984 5e40 28A0C5E5 		strb	r10, [r5, #40]
1079:../uvc.c      **** 		 	 		 }else{
 10985              		.loc 1 1079 0
 10986 5e44 2960C5E5 		strb	r6, [r5, #41]
 10987              	.LVL1244:
 10988              	.L738:
1165:../uvc.c      **** 
 10989              		.loc 1 1165 0
 10990 5e48 74161FE5 		ldr	r1, .L1075+84
 10991 5e4c 0900A0E1 		mov	r0, r9
 10992 5e50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10993              	.LVL1245:
 10994 5e54 FF10A0E3 		mov	r1, #255
 10995 5e58 0A00A0E1 		mov	r0, r10
 10996 5e5c 0620A0E1 		mov	r2, r6
 10997 5e60 0130A0E1 		mov	r3, r1
 10998 5e64 5EFCFFEA 		b	.L736
 10999              	.LVL1246:
 11000              	.L696:
 11001              	.LBE391:
 11002              	.LBE407:
 11003              	.LBB408:
 11004              	.LBB380:
1707:../uvc.c      **** 			  break;
 11005              		.loc 1 1707 0
 11006 5e68 0000A0E3 		mov	r0, #0
 11007 5e6c 0020A0E1 		mov	r2, r0
 11008 5e70 0110A0E3 		mov	r1, #1
 11009 5e74 FEFFFFEB 		bl	CyU3PUsbStall
 11010              	.LVL1247:
 11011 5e78 FF10A0E3 		mov	r1, #255
 11012 5e7c 0190A0E1 		mov	r9, r1
 11013 5e80 0120A0E1 		mov	r2, r1
 11014 5e84 0130A0E1 		mov	r3, r1
 11015 5e88 2EFCFFEA 		b	.L706
 11016              	.LVL1248:
 11017              	.L704:
1229:../uvc.c      **** 		 	 }
 11018              		.loc 1 1229 0
 11019 5e8c E931D6E5 		ldrb	r3, [r6, #489]	@ zero_extendqisi2
1231:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11020              		.loc 1 1231 0
 11021 5e90 0100A0E3 		mov	r0, #1
 11022 5e94 C0161FE5 		ldr	r1, .L1075+84
1229:../uvc.c      **** 		 	 }
 11023              		.loc 1 1229 0
 11024 5e98 2830C5E5 		strb	r3, [r5, #40]
 11025 5e9c 24FCFFEA 		b	.L1013
 11026              	.LVL1249:
 11027              	.L734:
 11028              	.LBE380:
 11029              	.LBE408:
 11030              	.LBB409:
 11031              	.LBB392:
 11032 5ea0 3132D6E5 		ldrb	r3, [r6, #561]	@ zero_extendqisi2
1231:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11033              		.loc 1 1231 0
 11034 5ea4 0100A0E3 		mov	r0, #1
 11035 5ea8 D4161FE5 		ldr	r1, .L1075+84
1229:../uvc.c      **** 		 	 }
 11036              		.loc 1 1229 0
 11037 5eac 2830C5E5 		strb	r3, [r5, #40]
 11038 5eb0 46FCFFEA 		b	.L1016
 11039              	.L733:
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11040              		.loc 1 1216 0
 11041 5eb4 2FC2D6E5 		ldrb	ip, [r6, #559]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11042              		.loc 1 1217 0
 11043 5eb8 3022D6E5 		ldrb	r2, [r6, #560]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11044              		.loc 1 1218 0
 11045 5ebc 0030A0E3 		mov	r3, #0
1221:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11046              		.loc 1 1221 0
 11047 5ec0 0900A0E1 		mov	r0, r9
 11048 5ec4 F0161FE5 		ldr	r1, .L1075+84
1216:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11049              		.loc 1 1216 0
 11050 5ec8 28C0C5E5 		strb	ip, [r5, #40]
1217:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11051              		.loc 1 1217 0
 11052 5ecc 2920C5E5 		strb	r2, [r5, #41]
1218:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11053              		.loc 1 1218 0
 11054 5ed0 2A30C5E5 		strb	r3, [r5, #42]
1219:../uvc.c      **** 		 	 }
 11055              		.loc 1 1219 0
 11056 5ed4 2B30C5E5 		strb	r3, [r5, #43]
 11057 5ed8 3CFCFFEA 		b	.L1016
 11058              	.L727:
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11059              		.loc 1 1202 0
 11060 5edc 2D22D6E5 		ldrb	r2, [r6, #557]	@ zero_extendqisi2
1203:../uvc.c      **** 			 }
 11061              		.loc 1 1203 0
 11062 5ee0 2E32D6E5 		ldrb	r3, [r6, #558]	@ zero_extendqisi2
 11063 5ee4 35FCFFEA 		b	.L1015
 11064              	.LVL1250:
 11065              	.L682:
 11066              	.LBE392:
 11067              	.LBE409:
 11068              	.LBB410:
 11069              	.LBB372:
1184:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 11070              		.loc 1 1184 0
 11071 5ee8 9B21D6E5 		ldrb	r2, [r6, #411]	@ zero_extendqisi2
1185:../uvc.c      **** 			 }
 11072              		.loc 1 1185 0
 11073 5eec 9C31D6E5 		ldrb	r3, [r6, #412]	@ zero_extendqisi2
 11074 5ef0 C1FAFFEA 		b	.L1010
 11075              	.L681:
1007:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 11076              		.loc 1 1007 0
 11077 5ef4 6131D5E5 		ldrb	r3, [r5, #353]	@ zero_extendqisi2
 11078 5ef8 000053E3 		cmp	r3, #0
 11079 5efc D001000A 		beq	.L689
1008:../uvc.c      **** 		 	 		 }else{
 11080              		.loc 1 1008 0
 11081 5f00 A501D6E5 		ldrb	r0, [r6, #421]	@ zero_extendqisi2
 11082              	.LVL1251:
 11083              	.L690:
1015:../uvc.c      **** 						  Data0 = ~Data0;
 11084              		.loc 1 1015 0
 11085 5f04 800010E3 		tst	r0, #128
1016:../uvc.c      **** 					  }else{
 11086              		.loc 1 1016 0
 11087 5f08 0000E011 		mvnne	r0, r0
 11088              	.LVL1252:
1018:../uvc.c      **** 					  }
 11089              		.loc 1 1018 0
 11090 5f0c 80004002 		subeq	r0, r0, #128
 11091 5f10 FF6000E2 		and	r6, r0, #255
 11092              	.LVL1253:
1021:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11093              		.loc 1 1021 0
 11094 5f14 0030A0E3 		mov	r3, #0
1165:../uvc.c      **** 
 11095              		.loc 1 1165 0
 11096 5f18 44171FE5 		ldr	r1, .L1075+84
 11097 5f1c 0A00A0E1 		mov	r0, r10
1021:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11098              		.loc 1 1021 0
 11099 5f20 2930C5E5 		strb	r3, [r5, #41]
 11100              	.LVL1254:
1020:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11101              		.loc 1 1020 0
 11102 5f24 2860C5E5 		strb	r6, [r5, #40]
1165:../uvc.c      **** 
 11103              		.loc 1 1165 0
 11104 5f28 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11105              	.LVL1255:
 11106 5f2c FF20A0E3 		mov	r2, #255
 11107 5f30 0610A0E1 		mov	r1, r6
 11108 5f34 0230A0E1 		mov	r3, r2
 11109 5f38 B7FAFFEA 		b	.L688
 11110              	.LVL1256:
 11111              	.L679:
1202:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11112              		.loc 1 1202 0
 11113 5f3c 9D21D6E5 		ldrb	r2, [r6, #413]	@ zero_extendqisi2
1203:../uvc.c      **** 			 }
 11114              		.loc 1 1203 0
 11115 5f40 9E31D6E5 		ldrb	r3, [r6, #414]	@ zero_extendqisi2
 11116 5f44 ACFAFFEA 		b	.L1010
 11117              	.LVL1257:
 11118              	.L775:
 11119              	.LBE372:
 11120              	.LBE410:
 11121              	.LBE424:
 11122              	.LBE443:
 11123              	.LBB444:
 11124              	.LBB358:
 11125              	.LBB305:
 11126              	.LBB206:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11127              		.loc 1 1792 0
 11128 5f48 AD35D6E5 		ldrb	r3, [r6, #1453]	@ zero_extendqisi2
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11129              		.loc 1 1793 0
 11130 5f4c 0100A0E3 		mov	r0, #1
 11131 5f50 7C171FE5 		ldr	r1, .L1075+84
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11132              		.loc 1 1792 0
 11133 5f54 2830C5E5 		strb	r3, [r5, #40]
1794:../uvc.c      **** 			  Len = 1;
 11134              		.loc 1 1794 0
 11135 5f58 0190A0E3 		mov	r9, #1
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11136              		.loc 1 1793 0
 11137 5f5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11138              	.LVL1258:
 11139 5f60 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
1794:../uvc.c      **** 			  Len = 1;
 11140              		.loc 1 1794 0
 11141 5f64 FF30A0E3 		mov	r3, #255
 11142 5f68 75FBFFEA 		b	.L777
 11143              	.LVL1259:
 11144              	.L774:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11145              		.loc 1 1783 0
 11146 5f6c ABC5D6E5 		ldrb	ip, [r6, #1451]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11147              		.loc 1 1784 0
 11148 5f70 AC25D6E5 		ldrb	r2, [r6, #1452]	@ zero_extendqisi2
 11149 5f74 68FBFFEA 		b	.L1018
 11150              	.LVL1260:
 11151              	.L881:
 11152              	.LBE206:
 11153              	.LBE305:
 11154              	.LBB306:
 11155              	.LBB270:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11156              		.loc 1 1765 0
 11157 5f78 4FC6D6E5 		ldrb	ip, [r6, #1615]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11158              		.loc 1 1766 0
 11159 5f7c 5026D6E5 		ldrb	r2, [r6, #1616]	@ zero_extendqisi2
 11160 5f80 2EFCFFEA 		b	.L1026
 11161              	.L880:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11162              		.loc 1 1750 0
 11163 5f84 59A6D6E5 		ldrb	r10, [r6, #1625]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11164              		.loc 1 1751 0
 11165 5f88 5A26D6E5 		ldrb	r2, [r6, #1626]	@ zero_extendqisi2
 11166              	.LVL1261:
 11167              	.L1033:
 11168              	.LBE270:
 11169              	.LBE306:
 11170              	.LBB307:
 11171              	.LBB223:
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11172              		.loc 1 1752 0
 11173 5f8c 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 11174              		.loc 1 1758 0
 11175 5f90 0900A0E1 		mov	r0, r9
 11176 5f94 C0171FE5 		ldr	r1, .L1075+84
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11177              		.loc 1 1751 0
 11178 5f98 2920C5E5 		strb	r2, [r5, #41]
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11179              		.loc 1 1750 0
 11180 5f9c 28A0C5E5 		strb	r10, [r5, #40]
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11181              		.loc 1 1752 0
 11182 5fa0 2A30C5E5 		strb	r3, [r5, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11183              		.loc 1 1753 0
 11184 5fa4 2B30C5E5 		strb	r3, [r5, #43]
 11185              	.LVL1262:
1758:../uvc.c      **** 
 11186              		.loc 1 1758 0
 11187 5fa8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11188              	.LVL1263:
 11189 5fac 0A20A0E1 		mov	r2, r10
 11190 5fb0 2BFCFFEA 		b	.L898
 11191              	.LVL1264:
 11192              	.L842:
 11193              	.LBE223:
 11194              	.LBE307:
 11195              	.LBB308:
 11196              	.LBB240:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11197              		.loc 1 1943 0
 11198 5fb4 0000A0E3 		mov	r0, #0
 11199 5fb8 0020A0E1 		mov	r2, r0
 11200 5fbc 0110A0E3 		mov	r1, #1
 11201 5fc0 FEFFFFEB 		bl	CyU3PUsbStall
 11202              	.LVL1265:
1944:../uvc.c      **** 			  break;
 11203              		.loc 1 1944 0
 11204 5fc4 0520A0E3 		mov	r2, #5
 11205 5fc8 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11206 5fcc 0400A0E3 		mov	r0, #4
 11207 5fd0 F8171FE5 		ldr	r1, .L1075+88
 11208 5fd4 FEFFFFEB 		bl	CyU3PDebugPrint
 11209              	.LVL1266:
 11210 5fd8 FF20A0E3 		mov	r2, #255
 11211 5fdc 7DFCFFEA 		b	.L852
 11212              	.LVL1267:
 11213              	.L888:
 11214              	.LBE240:
 11215              	.LBE308:
 11216              	.LBB309:
 11217              	.LBB224:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11218              		.loc 1 1943 0
 11219 5fe0 0000A0E3 		mov	r0, #0
 11220 5fe4 0020A0E1 		mov	r2, r0
 11221 5fe8 0110A0E3 		mov	r1, #1
 11222 5fec FEFFFFEB 		bl	CyU3PUsbStall
 11223              	.LVL1268:
1944:../uvc.c      **** 			  break;
 11224              		.loc 1 1944 0
 11225 5ff0 0920A0E3 		mov	r2, #9
 11226 5ff4 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11227 5ff8 0400A0E3 		mov	r0, #4
 11228 5ffc 24181FE5 		ldr	r1, .L1075+88
 11229 6000 FEFFFFEB 		bl	CyU3PDebugPrint
 11230              	.LVL1269:
 11231 6004 FF20A0E3 		mov	r2, #255
 11232 6008 15FCFFEA 		b	.L898
 11233              	.LVL1270:
 11234              	.L784:
 11235              	.LBE224:
 11236              	.LBE309:
 11237              	.LBB310:
 11238              	.LBB231:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11239              		.loc 1 1943 0
 11240 600c 0000A0E3 		mov	r0, #0
 11241 6010 0020A0E1 		mov	r2, r0
 11242 6014 0110A0E3 		mov	r1, #1
 11243 6018 FEFFFFEB 		bl	CyU3PUsbStall
 11244              	.LVL1271:
1944:../uvc.c      **** 			  break;
 11245              		.loc 1 1944 0
 11246 601c 0220A0E3 		mov	r2, #2
 11247 6020 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11248 6024 0400A0E3 		mov	r0, #4
 11249 6028 50181FE5 		ldr	r1, .L1075+88
 11250 602c FEFFFFEB 		bl	CyU3PDebugPrint
 11251              	.LVL1272:
 11252 6030 FF20A0E3 		mov	r2, #255
 11253              	.LVL1273:
 11254 6034 67FCFFEA 		b	.L852
 11255              	.LVL1274:
 11256              	.L792:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11257              		.loc 1 1792 0
 11258 6038 C535D8E5 		ldrb	r3, [r8, #1477]	@ zero_extendqisi2
 11259              	.LVL1275:
 11260              	.L1036:
 11261              	.LBE231:
 11262              	.LBE310:
 11263              	.LBB311:
 11264              	.LBB241:
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11265              		.loc 1 1793 0
 11266 603c 0100A0E3 		mov	r0, #1
 11267 6040 6C181FE5 		ldr	r1, .L1075+84
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11268              		.loc 1 1792 0
 11269 6044 2830C5E5 		strb	r3, [r5, #40]
1794:../uvc.c      **** 			  Len = 1;
 11270              		.loc 1 1794 0
 11271 6048 0190A0E3 		mov	r9, #1
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11272              		.loc 1 1793 0
 11273 604c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11274              	.LVL1276:
 11275 6050 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 11276 6054 5FFCFFEA 		b	.L852
 11277              	.LVL1277:
 11278              	.L799:
 11279              	.LBE241:
 11280              	.LBE311:
 11281              	.LBB312:
 11282              	.LBB285:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11283              		.loc 1 1765 0
 11284 6058 D7C5D6E5 		ldrb	ip, [r6, #1495]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11285              		.loc 1 1766 0
 11286 605c D825D6E5 		ldrb	r2, [r6, #1496]	@ zero_extendqisi2
 11287 6060 E5FCFFEA 		b	.L1024
 11288              	.L798:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11289              		.loc 1 1750 0
 11290 6064 E1A5D6E5 		ldrb	r10, [r6, #1505]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11291              		.loc 1 1751 0
 11292 6068 E225D6E5 		ldrb	r2, [r6, #1506]	@ zero_extendqisi2
 11293              	.LVL1278:
 11294              	.L1032:
 11295              	.LBE285:
 11296              	.LBE312:
 11297              	.LBB313:
 11298              	.LBB277:
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11299              		.loc 1 1752 0
 11300 606c 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 11301              		.loc 1 1758 0
 11302 6070 9C181FE5 		ldr	r1, .L1075+84
 11303 6074 0900A0E1 		mov	r0, r9
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11304              		.loc 1 1751 0
 11305 6078 2920C5E5 		strb	r2, [r5, #41]
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11306              		.loc 1 1752 0
 11307 607c 2A30C5E5 		strb	r3, [r5, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11308              		.loc 1 1753 0
 11309 6080 2B30C5E5 		strb	r3, [r5, #43]
 11310              	.LVL1279:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11311              		.loc 1 1750 0
 11312 6084 28A0C5E5 		strb	r10, [r5, #40]
1758:../uvc.c      **** 
 11313              		.loc 1 1758 0
 11314 6088 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11315              	.LVL1280:
 11316 608c FF20A0E3 		mov	r2, #255
 11317 6090 0A10A0E1 		mov	r1, r10
 11318 6094 0230A0E1 		mov	r3, r2
 11319 6098 E2FCFFEA 		b	.L874
 11320              	.LVL1281:
 11321              	.L868:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11322              		.loc 1 1765 0
 11323 609c 37C6D6E5 		ldrb	ip, [r6, #1591]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11324              		.loc 1 1766 0
 11325 60a0 3826D6E5 		ldrb	r2, [r6, #1592]	@ zero_extendqisi2
 11326 60a4 D4FCFFEA 		b	.L1024
 11327              	.L867:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11328              		.loc 1 1750 0
 11329 60a8 41A6D6E5 		ldrb	r10, [r6, #1601]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11330              		.loc 1 1751 0
 11331 60ac 4226D6E5 		ldrb	r2, [r6, #1602]	@ zero_extendqisi2
 11332 60b0 EDFFFFEA 		b	.L1032
 11333              	.LVL1282:
 11334              	.L896:
 11335              	.LBE277:
 11336              	.LBE313:
 11337              	.LBB314:
 11338              	.LBB225:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11339              		.loc 1 1792 0
 11340 60b4 6D36D6E5 		ldrb	r3, [r6, #1645]	@ zero_extendqisi2
 11341              	.LVL1283:
 11342              	.L1034:
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11343              		.loc 1 1793 0
 11344 60b8 0100A0E3 		mov	r0, #1
 11345 60bc E8181FE5 		ldr	r1, .L1075+84
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11346              		.loc 1 1792 0
 11347 60c0 2830C5E5 		strb	r3, [r5, #40]
1794:../uvc.c      **** 			  Len = 1;
 11348              		.loc 1 1794 0
 11349 60c4 0190A0E3 		mov	r9, #1
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11350              		.loc 1 1793 0
 11351 60c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11352              	.LVL1284:
 11353 60cc 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
 11354 60d0 E3FBFFEA 		b	.L898
 11355              	.LVL1285:
 11356              	.L895:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11357              		.loc 1 1783 0
 11358 60d4 6BC6D6E5 		ldrb	ip, [r6, #1643]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11359              		.loc 1 1784 0
 11360 60d8 6C26D6E5 		ldrb	r2, [r6, #1644]	@ zero_extendqisi2
 11361 60dc D7FBFFEA 		b	.L1026
 11362              	.LVL1286:
 11363              	.L835:
 11364              	.LBE225:
 11365              	.LBE314:
 11366              	.LBB315:
 11367              	.LBB215:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11368              		.loc 1 1765 0
 11369 60e0 EFC5D6E5 		ldrb	ip, [r6, #1519]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11370              		.loc 1 1766 0
 11371 60e4 F025D6E5 		ldrb	r2, [r6, #1520]	@ zero_extendqisi2
 11372 60e8 D4FBFFEA 		b	.L1026
 11373              	.L834:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11374              		.loc 1 1750 0
 11375 60ec F9A5D6E5 		ldrb	r10, [r6, #1529]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11376              		.loc 1 1751 0
 11377 60f0 FA25D6E5 		ldrb	r2, [r6, #1530]	@ zero_extendqisi2
 11378 60f4 A4FFFFEA 		b	.L1033
 11379              	.LVL1287:
 11380              	.L850:
 11381              	.LBE215:
 11382              	.LBE315:
 11383              	.LBB316:
 11384              	.LBB242:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11385              		.loc 1 1792 0
 11386 60f8 0D36D8E5 		ldrb	r3, [r8, #1549]	@ zero_extendqisi2
 11387 60fc CEFFFFEA 		b	.L1036
 11388              	.L849:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11389              		.loc 1 1783 0
 11390 6100 0BC6D8E5 		ldrb	ip, [r8, #1547]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11391              		.loc 1 1784 0
 11392 6104 0C26D8E5 		ldrb	r2, [r8, #1548]	@ zero_extendqisi2
 11393 6108 29FCFFEA 		b	.L1022
 11394              	.LVL1288:
 11395              	.L857:
 11396              	.LBE242:
 11397              	.LBE316:
 11398              	.LBB317:
 11399              	.LBB255:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11400              		.loc 1 1765 0
 11401 610c 1FC6D6E5 		ldrb	ip, [r6, #1567]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11402              		.loc 1 1766 0
 11403 6110 2026D6E5 		ldrb	r2, [r6, #1568]	@ zero_extendqisi2
 11404 6114 C9FBFFEA 		b	.L1026
 11405              	.L856:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11406              		.loc 1 1750 0
 11407 6118 29A6D6E5 		ldrb	r10, [r6, #1577]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11408              		.loc 1 1751 0
 11409 611c 2A26D6E5 		ldrb	r2, [r6, #1578]	@ zero_extendqisi2
 11410 6120 99FFFFEA 		b	.L1033
 11411              	.LVL1289:
 11412              	.L767:
 11413              	.LBE255:
 11414              	.LBE317:
 11415              	.LBB318:
 11416              	.LBB207:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11417              		.loc 1 1943 0
 11418 6124 0000A0E3 		mov	r0, #0
 11419 6128 0020A0E1 		mov	r2, r0
 11420 612c 0110A0E3 		mov	r1, #1
 11421 6130 FEFFFFEB 		bl	CyU3PUsbStall
 11422              	.LVL1290:
1944:../uvc.c      **** 			  break;
 11423              		.loc 1 1944 0
 11424 6134 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11425 6138 0120A0E3 		mov	r2, #1
 11426 613c 0400A0E3 		mov	r0, #4
 11427 6140 68191FE5 		ldr	r1, .L1075+88
 11428 6144 FEFFFFEB 		bl	CyU3PDebugPrint
 11429              	.LVL1291:
 11430 6148 FF20A0E3 		mov	r2, #255
 11431 614c 0230A0E1 		mov	r3, r2
 11432 6150 FBFAFFEA 		b	.L777
 11433              	.LVL1292:
 11434              	.L757:
 11435              	.LBE207:
 11436              	.LBE318:
 11437              	.LBB319:
 11438              	.LBB248:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11439              		.loc 1 1774 0
 11440 6154 91C5D6E5 		ldrb	ip, [r6, #1425]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11441              		.loc 1 1775 0
 11442 6158 9225D6E5 		ldrb	r2, [r6, #1426]	@ zero_extendqisi2
 11443 615c B7FBFFEA 		b	.L1026
 11444              	.L764:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11445              		.loc 1 1792 0
 11446 6160 9535D6E5 		ldrb	r3, [r6, #1429]	@ zero_extendqisi2
 11447 6164 D3FFFFEA 		b	.L1034
 11448              	.L763:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11449              		.loc 1 1783 0
 11450 6168 93C5D6E5 		ldrb	ip, [r6, #1427]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11451              		.loc 1 1784 0
 11452 616c 9425D6E5 		ldrb	r2, [r6, #1428]	@ zero_extendqisi2
 11453 6170 B2FBFFEA 		b	.L1026
 11454              	.LVL1293:
 11455              	.L906:
 11456              	.LBE248:
 11457              	.LBE319:
 11458              	.LBB320:
 11459              	.LBB262:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11460              		.loc 1 1783 0
 11461 6174 83E6D6E5 		ldrb	lr, [r6, #1667]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11462              		.loc 1 1784 0
 11463 6178 84C6D6E5 		ldrb	ip, [r6, #1668]	@ zero_extendqisi2
 11464 617c 60FCFFEA 		b	.L1028
 11465              	.L905:
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11466              		.loc 1 1741 0
 11467 6180 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11468              		.loc 1 1742 0
 11469 6184 0200A0E3 		mov	r0, #2
 11470 6188 B4191FE5 		ldr	r1, .L1075+84
1743:../uvc.c      **** 			  break;
 11471              		.loc 1 1743 0
 11472 618c FFA0A0E3 		mov	r10, #255
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11473              		.loc 1 1741 0
 11474 6190 2930C5E5 		strb	r3, [r5, #41]
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11475              		.loc 1 1740 0
 11476 6194 2890C5E5 		strb	r9, [r5, #40]
1743:../uvc.c      **** 			  break;
 11477              		.loc 1 1743 0
 11478 6198 0A60A0E1 		mov	r6, r10
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11479              		.loc 1 1742 0
 11480 619c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11481              	.LVL1294:
 11482 61a0 2830D5E5 		ldrb	r3, [r5, #40]	@ zero_extendqisi2
 11483 61a4 62FCFFEA 		b	.L909
 11484              	.LVL1295:
 11485              	.L760:
 11486              	.LBE262:
 11487              	.LBE320:
 11488              	.LBB321:
 11489              	.LBB249:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11490              		.loc 1 1765 0
 11491 61a8 8FC5D6E5 		ldrb	ip, [r6, #1423]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11492              		.loc 1 1766 0
 11493 61ac 9025D6E5 		ldrb	r2, [r6, #1424]	@ zero_extendqisi2
 11494 61b0 A2FBFFEA 		b	.L1026
 11495              	.L759:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11496              		.loc 1 1750 0
 11497 61b4 99A5D6E5 		ldrb	r10, [r6, #1433]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11498              		.loc 1 1751 0
 11499 61b8 9A25D6E5 		ldrb	r2, [r6, #1434]	@ zero_extendqisi2
 11500 61bc 72FFFFEA 		b	.L1033
 11501              	.LVL1296:
 11502              	.L900:
 11503              	.LBE249:
 11504              	.LBE321:
 11505              	.LBB322:
 11506              	.LBB263:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11507              		.loc 1 1774 0
 11508 61c0 81E6D6E5 		ldrb	lr, [r6, #1665]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11509              		.loc 1 1775 0
 11510 61c4 82C6D6E5 		ldrb	ip, [r6, #1666]	@ zero_extendqisi2
 11511 61c8 4DFCFFEA 		b	.L1028
 11512              	.LVL1297:
 11513              	.L796:
 11514              	.LBE263:
 11515              	.LBE322:
 11516              	.LBB323:
 11517              	.LBB286:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11518              		.loc 1 1774 0
 11519 61cc D9C5D6E5 		ldrb	ip, [r6, #1497]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11520              		.loc 1 1775 0
 11521 61d0 DA25D6E5 		ldrb	r2, [r6, #1498]	@ zero_extendqisi2
 11522 61d4 88FCFFEA 		b	.L1024
 11523              	.LVL1298:
 11524              	.L785:
 11525              	.LBE286:
 11526              	.LBE323:
 11527              	.LBB324:
 11528              	.LBB232:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11529              		.loc 1 1774 0
 11530 61d8 C1C5D8E5 		ldrb	ip, [r8, #1473]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11531              		.loc 1 1775 0
 11532 61dc C225D8E5 		ldrb	r2, [r8, #1474]	@ zero_extendqisi2
 11533 61e0 F3FBFFEA 		b	.L1022
 11534              	.LVL1299:
 11535              	.L756:
 11536              	.LBE232:
 11537              	.LBE324:
 11538              	.LBB325:
 11539              	.LBB250:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11540              		.loc 1 1943 0
 11541 61e4 0000A0E3 		mov	r0, #0
 11542 61e8 0020A0E1 		mov	r2, r0
 11543 61ec 0110A0E3 		mov	r1, #1
 11544 61f0 FEFFFFEB 		bl	CyU3PUsbStall
 11545              	.LVL1300:
1944:../uvc.c      **** 			  break;
 11546              		.loc 1 1944 0
 11547 61f4 0020A0E3 		mov	r2, #0
 11548 61f8 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11549 61fc 0400A0E3 		mov	r0, #4
 11550 6200 281A1FE5 		ldr	r1, .L1075+88
 11551 6204 FEFFFFEB 		bl	CyU3PDebugPrint
 11552              	.LVL1301:
 11553 6208 FF20A0E3 		mov	r2, #255
 11554              	.LVL1302:
 11555 620c 94FBFFEA 		b	.L898
 11556              	.LVL1303:
 11557              	.L889:
 11558              	.LBE250:
 11559              	.LBE325:
 11560              	.LBB326:
 11561              	.LBB226:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11562              		.loc 1 1774 0
 11563 6210 69C6D6E5 		ldrb	ip, [r6, #1641]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11564              		.loc 1 1775 0
 11565 6214 6A26D6E5 		ldrb	r2, [r6, #1642]	@ zero_extendqisi2
 11566 6218 88FBFFEA 		b	.L1026
 11567              	.LVL1304:
 11568              	.L878:
 11569              	.LBE226:
 11570              	.LBE326:
 11571              	.LBB327:
 11572              	.LBB271:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11573              		.loc 1 1774 0
 11574 621c 51C6D6E5 		ldrb	ip, [r6, #1617]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11575              		.loc 1 1775 0
 11576 6220 5226D6E5 		ldrb	r2, [r6, #1618]	@ zero_extendqisi2
 11577 6224 85FBFFEA 		b	.L1026
 11578              	.LVL1305:
 11579              	.L773:
 11580              	.LBE271:
 11581              	.LBE327:
 11582              	.LBB328:
 11583              	.LBB208:
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11584              		.loc 1 1741 0
 11585 6228 0030A0E3 		mov	r3, #0
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11586              		.loc 1 1742 0
 11587 622c 0200A0E3 		mov	r0, #2
 11588 6230 5C1A1FE5 		ldr	r1, .L1075+84
1741:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11589              		.loc 1 1741 0
 11590 6234 2930C5E5 		strb	r3, [r5, #41]
1740:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11591              		.loc 1 1740 0
 11592 6238 2890C5E5 		strb	r9, [r5, #40]
1742:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11593              		.loc 1 1742 0
 11594 623c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11595              	.LVL1306:
 11596 6240 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
1743:../uvc.c      **** 			  break;
 11597              		.loc 1 1743 0
 11598 6244 FF30A0E3 		mov	r3, #255
 11599 6248 BDFAFFEA 		b	.L777
 11600              	.LVL1307:
 11601              	.L854:
 11602              	.LBE208:
 11603              	.LBE328:
 11604              	.LBB329:
 11605              	.LBB256:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11606              		.loc 1 1774 0
 11607 624c 21C6D6E5 		ldrb	ip, [r6, #1569]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11608              		.loc 1 1775 0
 11609 6250 2226D6E5 		ldrb	r2, [r6, #1570]	@ zero_extendqisi2
 11610 6254 79FBFFEA 		b	.L1026
 11611              	.LVL1308:
 11612              	.L768:
 11613              	.LBE256:
 11614              	.LBE329:
 11615              	.LBB330:
 11616              	.LBB209:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11617              		.loc 1 1774 0
 11618 6258 A9C5D6E5 		ldrb	ip, [r6, #1449]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11619              		.loc 1 1775 0
 11620 625c AA25D6E5 		ldrb	r2, [r6, #1450]	@ zero_extendqisi2
 11621 6260 ADFAFFEA 		b	.L1018
 11622              	.LVL1309:
 11623              	.L832:
 11624              	.LBE209:
 11625              	.LBE330:
 11626              	.LBB331:
 11627              	.LBB216:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11628              		.loc 1 1774 0
 11629 6264 F1C5D6E5 		ldrb	ip, [r6, #1521]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11630              		.loc 1 1775 0
 11631 6268 F225D6E5 		ldrb	r2, [r6, #1522]	@ zero_extendqisi2
 11632 626c 73FBFFEA 		b	.L1026
 11633              	.LVL1310:
 11634              	.L899:
 11635              	.LBE216:
 11636              	.LBE331:
 11637              	.LBB332:
 11638              	.LBB264:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11639              		.loc 1 1943 0
 11640 6270 0000A0E3 		mov	r0, #0
 11641 6274 0020A0E1 		mov	r2, r0
 11642 6278 0110A0E3 		mov	r1, #1
 11643 627c FEFFFFEB 		bl	CyU3PUsbStall
 11644              	.LVL1311:
1944:../uvc.c      **** 			  break;
 11645              		.loc 1 1944 0
 11646 6280 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11647 6284 0400A0E3 		mov	r0, #4
 11648 6288 B01A1FE5 		ldr	r1, .L1075+88
 11649 628c 0A20A0E3 		mov	r2, #10
 11650 6290 FEFFFFEB 		bl	CyU3PDebugPrint
 11651              	.LVL1312:
 11652 6294 FF30A0E3 		mov	r3, #255
 11653 6298 03A0A0E1 		mov	r10, r3
 11654 629c 0360A0E1 		mov	r6, r3
 11655 62a0 23FCFFEA 		b	.L909
 11656              	.LVL1313:
 11657              	.L907:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11658              		.loc 1 1792 0
 11659 62a4 8536D6E5 		ldrb	r3, [r6, #1669]	@ zero_extendqisi2
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11660              		.loc 1 1793 0
 11661 62a8 0100A0E3 		mov	r0, #1
 11662 62ac D81A1FE5 		ldr	r1, .L1075+84
1794:../uvc.c      **** 			  Len = 1;
 11663              		.loc 1 1794 0
 11664 62b0 FFA0A0E3 		mov	r10, #255
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11665              		.loc 1 1792 0
 11666 62b4 2830C5E5 		strb	r3, [r5, #40]
1794:../uvc.c      **** 			  Len = 1;
 11667              		.loc 1 1794 0
 11668 62b8 0A60A0E1 		mov	r6, r10
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11669              		.loc 1 1793 0
 11670 62bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11671              	.LVL1314:
1794:../uvc.c      **** 			  Len = 1;
 11672              		.loc 1 1794 0
 11673 62c0 0190A0E3 		mov	r9, #1
 11674 62c4 2830D5E5 		ldrb	r3, [r5, #40]	@ zero_extendqisi2
 11675 62c8 19FCFFEA 		b	.L909
 11676              	.LVL1315:
 11677              	.L861:
 11678              	.LBE264:
 11679              	.LBE332:
 11680              	.LBB333:
 11681              	.LBB257:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11682              		.loc 1 1792 0
 11683 62cc 2536D6E5 		ldrb	r3, [r6, #1573]	@ zero_extendqisi2
 11684 62d0 78FFFFEA 		b	.L1034
 11685              	.L860:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11686              		.loc 1 1783 0
 11687 62d4 23C6D6E5 		ldrb	ip, [r6, #1571]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11688              		.loc 1 1784 0
 11689 62d8 2426D6E5 		ldrb	r2, [r6, #1572]	@ zero_extendqisi2
 11690 62dc 57FBFFEA 		b	.L1026
 11691              	.LVL1316:
 11692              	.L771:
 11693              	.LBE257:
 11694              	.LBE333:
 11695              	.LBB334:
 11696              	.LBB210:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11697              		.loc 1 1765 0
 11698 62e0 A7C5D6E5 		ldrb	ip, [r6, #1447]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11699              		.loc 1 1766 0
 11700 62e4 A825D6E5 		ldrb	r2, [r6, #1448]	@ zero_extendqisi2
 11701 62e8 8BFAFFEA 		b	.L1018
 11702              	.L770:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11703              		.loc 1 1750 0
 11704 62ec B1A5D6E5 		ldrb	r10, [r6, #1457]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11705              		.loc 1 1751 0
 11706 62f0 B225D6E5 		ldrb	r2, [r6, #1458]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11707              		.loc 1 1752 0
 11708 62f4 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 11709              		.loc 1 1758 0
 11710 62f8 0900A0E1 		mov	r0, r9
 11711 62fc 281B1FE5 		ldr	r1, .L1075+84
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11712              		.loc 1 1751 0
 11713 6300 2920C5E5 		strb	r2, [r5, #41]
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11714              		.loc 1 1752 0
 11715 6304 2A30C5E5 		strb	r3, [r5, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11716              		.loc 1 1753 0
 11717 6308 2B30C5E5 		strb	r3, [r5, #43]
 11718              	.LVL1317:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11719              		.loc 1 1750 0
 11720 630c 28A0C5E5 		strb	r10, [r5, #40]
1758:../uvc.c      **** 
 11721              		.loc 1 1758 0
 11722 6310 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11723              	.LVL1318:
 11724 6314 0A20A0E1 		mov	r2, r10
 11725 6318 FF30A0E3 		mov	r3, #255
 11726 631c 88FAFFEA 		b	.L777
 11727              	.LVL1319:
 11728              	.L791:
 11729              	.LBE210:
 11730              	.LBE334:
 11731              	.LBB335:
 11732              	.LBB233:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11733              		.loc 1 1783 0
 11734 6320 C3C5D8E5 		ldrb	ip, [r8, #1475]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11735              		.loc 1 1784 0
 11736 6324 C425D8E5 		ldrb	r2, [r8, #1476]	@ zero_extendqisi2
 11737 6328 A1FBFFEA 		b	.L1022
 11738              	.LVL1320:
 11739              	.L871:
 11740              	.LBE233:
 11741              	.LBE335:
 11742              	.LBB336:
 11743              	.LBB278:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11744              		.loc 1 1783 0
 11745 632c 3BC6D6E5 		ldrb	ip, [r6, #1595]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11746              		.loc 1 1784 0
 11747 6330 3C26D6E5 		ldrb	r2, [r6, #1596]	@ zero_extendqisi2
 11748 6334 30FCFFEA 		b	.L1024
 11749              	.LVL1321:
 11750              	.L846:
 11751              	.LBE278:
 11752              	.LBE336:
 11753              	.LBB337:
 11754              	.LBB243:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11755              		.loc 1 1765 0
 11756 6338 07C6D8E5 		ldrb	ip, [r8, #1543]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11757              		.loc 1 1766 0
 11758 633c 0826D8E5 		ldrb	r2, [r8, #1544]	@ zero_extendqisi2
 11759 6340 9BFBFFEA 		b	.L1022
 11760              	.L845:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11761              		.loc 1 1750 0
 11762 6344 11A6D8E5 		ldrb	r10, [r8, #1553]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11763              		.loc 1 1751 0
 11764 6348 1226D8E5 		ldrb	r2, [r8, #1554]	@ zero_extendqisi2
 11765              	.LVL1322:
 11766              	.L1035:
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11767              		.loc 1 1752 0
 11768 634c 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 11769              		.loc 1 1758 0
 11770 6350 0900A0E1 		mov	r0, r9
 11771 6354 801B1FE5 		ldr	r1, .L1075+84
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11772              		.loc 1 1751 0
 11773 6358 2920C5E5 		strb	r2, [r5, #41]
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11774              		.loc 1 1750 0
 11775 635c 28A0C5E5 		strb	r10, [r5, #40]
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11776              		.loc 1 1752 0
 11777 6360 2A30C5E5 		strb	r3, [r5, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11778              		.loc 1 1753 0
 11779 6364 2B30C5E5 		strb	r3, [r5, #43]
 11780              	.LVL1323:
1758:../uvc.c      **** 
 11781              		.loc 1 1758 0
 11782 6368 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11783              	.LVL1324:
 11784 636c 0A20A0E1 		mov	r2, r10
 11785 6370 98FBFFEA 		b	.L852
 11786              	.LVL1325:
 11787              	.L864:
 11788              	.LBE243:
 11789              	.LBE337:
 11790              	.LBB338:
 11791              	.LBB279:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11792              		.loc 1 1943 0
 11793 6374 0000A0E3 		mov	r0, #0
 11794 6378 0020A0E1 		mov	r2, r0
 11795 637c 0110A0E3 		mov	r1, #1
 11796 6380 FEFFFFEB 		bl	CyU3PUsbStall
 11797              	.LVL1326:
1944:../uvc.c      **** 			  break;
 11798              		.loc 1 1944 0
 11799 6384 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11800 6388 B01B1FE5 		ldr	r1, .L1075+88
 11801 638c 0720A0E3 		mov	r2, #7
 11802 6390 0400A0E3 		mov	r0, #4
 11803 6394 FEFFFFEB 		bl	CyU3PDebugPrint
 11804              	.LVL1327:
 11805 6398 FF10A0E3 		mov	r1, #255
 11806 639c 0120A0E1 		mov	r2, r1
 11807 63a0 0130A0E1 		mov	r3, r1
 11808 63a4 1FFCFFEA 		b	.L874
 11809              	.LVL1328:
 11810              	.L872:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11811              		.loc 1 1792 0
 11812 63a8 3D36D6E5 		ldrb	r3, [r6, #1597]	@ zero_extendqisi2
 11813              	.LVL1329:
 11814              	.L1031:
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11815              		.loc 1 1793 0
 11816 63ac D81B1FE5 		ldr	r1, .L1075+84
 11817 63b0 0100A0E3 		mov	r0, #1
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11818              		.loc 1 1792 0
 11819 63b4 2830C5E5 		strb	r3, [r5, #40]
1793:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11820              		.loc 1 1793 0
 11821 63b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11822              	.LVL1330:
1794:../uvc.c      **** 			  Len = 1;
 11823              		.loc 1 1794 0
 11824 63bc FF20A0E3 		mov	r2, #255
 11825 63c0 0230A0E1 		mov	r3, r2
 11826 63c4 2810D5E5 		ldrb	r1, [r5, #40]	@ zero_extendqisi2
 11827 63c8 0190A0E3 		mov	r9, #1
 11828 63cc 15FCFFEA 		b	.L874
 11829              	.LVL1331:
 11830              	.L788:
 11831              	.LBE279:
 11832              	.LBE338:
 11833              	.LBB339:
 11834              	.LBB234:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11835              		.loc 1 1765 0
 11836 63d0 BFC5D8E5 		ldrb	ip, [r8, #1471]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11837              		.loc 1 1766 0
 11838 63d4 C025D8E5 		ldrb	r2, [r8, #1472]	@ zero_extendqisi2
 11839 63d8 75FBFFEA 		b	.L1022
 11840              	.L787:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11841              		.loc 1 1750 0
 11842 63dc C9A5D8E5 		ldrb	r10, [r8, #1481]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11843              		.loc 1 1751 0
 11844 63e0 CA25D8E5 		ldrb	r2, [r8, #1482]	@ zero_extendqisi2
 11845 63e4 D8FFFFEA 		b	.L1035
 11846              	.LVL1332:
 11847              	.L843:
 11848              	.LBE234:
 11849              	.LBE339:
 11850              	.LBB340:
 11851              	.LBB244:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11852              		.loc 1 1774 0
 11853 63e8 09C6D8E5 		ldrb	ip, [r8, #1545]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11854              		.loc 1 1775 0
 11855 63ec 0A26D8E5 		ldrb	r2, [r8, #1546]	@ zero_extendqisi2
 11856 63f0 6FFBFFEA 		b	.L1022
 11857              	.LVL1333:
 11858              	.L865:
 11859              	.LBE244:
 11860              	.LBE340:
 11861              	.LBB341:
 11862              	.LBB280:
1774:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11863              		.loc 1 1774 0
 11864 63f4 39C6D6E5 		ldrb	ip, [r6, #1593]	@ zero_extendqisi2
1775:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11865              		.loc 1 1775 0
 11866 63f8 3A26D6E5 		ldrb	r2, [r6, #1594]	@ zero_extendqisi2
 11867 63fc FEFBFFEA 		b	.L1024
 11868              	.LVL1334:
 11869              	.L853:
 11870              	.LBE280:
 11871              	.LBE341:
 11872              	.LBB342:
 11873              	.LBB258:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11874              		.loc 1 1943 0
 11875 6400 0000A0E3 		mov	r0, #0
 11876 6404 0020A0E1 		mov	r2, r0
 11877 6408 0110A0E3 		mov	r1, #1
 11878 640c FEFFFFEB 		bl	CyU3PUsbStall
 11879              	.LVL1335:
1944:../uvc.c      **** 			  break;
 11880              		.loc 1 1944 0
 11881 6410 0620A0E3 		mov	r2, #6
 11882 6414 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11883 6418 0400A0E3 		mov	r0, #4
 11884 641c 441C1FE5 		ldr	r1, .L1075+88
 11885 6420 FEFFFFEB 		bl	CyU3PDebugPrint
 11886              	.LVL1336:
 11887 6424 FF20A0E3 		mov	r2, #255
 11888              	.LVL1337:
 11889 6428 0DFBFFEA 		b	.L898
 11890              	.LVL1338:
 11891              	.L795:
 11892              	.LBE258:
 11893              	.LBE342:
 11894              	.LBB343:
 11895              	.LBB287:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11896              		.loc 1 1943 0
 11897 642c 0000A0E3 		mov	r0, #0
 11898 6430 0020A0E1 		mov	r2, r0
 11899 6434 0110A0E3 		mov	r1, #1
 11900 6438 FEFFFFEB 		bl	CyU3PUsbStall
 11901              	.LVL1339:
1944:../uvc.c      **** 			  break;
 11902              		.loc 1 1944 0
 11903 643c 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11904 6440 681C1FE5 		ldr	r1, .L1075+88
 11905 6444 0320A0E3 		mov	r2, #3
 11906 6448 0400A0E3 		mov	r0, #4
 11907 644c FEFFFFEB 		bl	CyU3PDebugPrint
 11908              	.LVL1340:
 11909 6450 FF10A0E3 		mov	r1, #255
 11910 6454 0120A0E1 		mov	r2, r1
 11911 6458 0130A0E1 		mov	r3, r1
 11912              	.LVL1341:
 11913 645c F1FBFFEA 		b	.L874
 11914              	.LVL1342:
 11915              	.L803:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11916              		.loc 1 1792 0
 11917 6460 DD35D6E5 		ldrb	r3, [r6, #1501]	@ zero_extendqisi2
 11918 6464 D0FFFFEA 		b	.L1031
 11919              	.L802:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11920              		.loc 1 1783 0
 11921 6468 DBC5D6E5 		ldrb	ip, [r6, #1499]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11922              		.loc 1 1784 0
 11923 646c DC25D6E5 		ldrb	r2, [r6, #1500]	@ zero_extendqisi2
 11924 6470 E1FBFFEA 		b	.L1024
 11925              	.LVL1343:
 11926              	.L903:
 11927              	.LBE287:
 11928              	.LBE343:
 11929              	.LBB344:
 11930              	.LBB265:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 11931              		.loc 1 1765 0
 11932 6474 7FE6D6E5 		ldrb	lr, [r6, #1663]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 11933              		.loc 1 1766 0
 11934 6478 80C6D6E5 		ldrb	ip, [r6, #1664]	@ zero_extendqisi2
 11935 647c A0FBFFEA 		b	.L1028
 11936              	.L902:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11937              		.loc 1 1750 0
 11938 6480 89B6D6E5 		ldrb	fp, [r6, #1673]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11939              		.loc 1 1751 0
 11940 6484 8A26D6E5 		ldrb	r2, [r6, #1674]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11941              		.loc 1 1752 0
 11942 6488 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 
 11943              		.loc 1 1758 0
 11944 648c 0900A0E1 		mov	r0, r9
 11945 6490 BC1C1FE5 		ldr	r1, .L1075+84
 11946 6494 FFA0A0E3 		mov	r10, #255
1752:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11947              		.loc 1 1752 0
 11948 6498 2A30C5E5 		strb	r3, [r5, #42]
1753:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11949              		.loc 1 1753 0
 11950 649c 2B30C5E5 		strb	r3, [r5, #43]
 11951              	.LVL1344:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11952              		.loc 1 1750 0
 11953 64a0 28B0C5E5 		strb	fp, [r5, #40]
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11954              		.loc 1 1751 0
 11955 64a4 2920C5E5 		strb	r2, [r5, #41]
1758:../uvc.c      **** 
 11956              		.loc 1 1758 0
 11957 64a8 0A60A0E1 		mov	r6, r10
 11958 64ac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11959              	.LVL1345:
 11960 64b0 0B30A0E1 		mov	r3, fp
 11961 64b4 9EFBFFEA 		b	.L909
 11962              	.LVL1346:
 11963              	.L839:
 11964              	.LBE265:
 11965              	.LBE344:
 11966              	.LBB345:
 11967              	.LBB217:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 11968              		.loc 1 1792 0
 11969 64b8 F535D6E5 		ldrb	r3, [r6, #1525]	@ zero_extendqisi2
 11970 64bc FDFEFFEA 		b	.L1034
 11971              	.L838:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11972              		.loc 1 1783 0
 11973 64c0 F3C5D6E5 		ldrb	ip, [r6, #1523]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11974              		.loc 1 1784 0
 11975 64c4 F425D6E5 		ldrb	r2, [r6, #1524]	@ zero_extendqisi2
 11976 64c8 DCFAFFEA 		b	.L1026
 11977              	.L831:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11978              		.loc 1 1943 0
 11979 64cc 0000A0E3 		mov	r0, #0
 11980 64d0 0020A0E1 		mov	r2, r0
 11981 64d4 0110A0E3 		mov	r1, #1
 11982 64d8 FEFFFFEB 		bl	CyU3PUsbStall
 11983              	.LVL1347:
1944:../uvc.c      **** 			  break;
 11984              		.loc 1 1944 0
 11985 64dc 0400A0E3 		mov	r0, #4
 11986 64e0 0020A0E1 		mov	r2, r0
 11987 64e4 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 11988 64e8 101D1FE5 		ldr	r1, .L1075+88
 11989 64ec FEFFFFEB 		bl	CyU3PDebugPrint
 11990              	.LVL1348:
 11991 64f0 FF20A0E3 		mov	r2, #255
 11992              	.LVL1349:
 11993 64f4 DAFAFFEA 		b	.L898
 11994              	.LVL1350:
 11995              	.L877:
 11996              	.LBE217:
 11997              	.LBE345:
 11998              	.LBB346:
 11999              	.LBB272:
1943:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 12000              		.loc 1 1943 0
 12001 64f8 0000A0E3 		mov	r0, #0
 12002 64fc 0020A0E1 		mov	r2, r0
 12003 6500 0110A0E3 		mov	r1, #1
 12004 6504 FEFFFFEB 		bl	CyU3PUsbStall
 12005              	.LVL1351:
1944:../uvc.c      **** 			  break;
 12006              		.loc 1 1944 0
 12007 6508 0820A0E3 		mov	r2, #8
 12008 650c 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
 12009 6510 0400A0E3 		mov	r0, #4
 12010 6514 3C1D1FE5 		ldr	r1, .L1075+88
 12011 6518 FEFFFFEB 		bl	CyU3PDebugPrint
 12012              	.LVL1352:
 12013 651c FF20A0E3 		mov	r2, #255
 12014              	.LVL1353:
 12015 6520 CFFAFFEA 		b	.L898
 12016              	.LVL1354:
 12017              	.L885:
1792:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 12018              		.loc 1 1792 0
 12019 6524 5536D6E5 		ldrb	r3, [r6, #1621]	@ zero_extendqisi2
 12020 6528 E2FEFFEA 		b	.L1034
 12021              	.L884:
1783:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 12022              		.loc 1 1783 0
 12023 652c 53C6D6E5 		ldrb	ip, [r6, #1619]	@ zero_extendqisi2
1784:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 12024              		.loc 1 1784 0
 12025 6530 5426D6E5 		ldrb	r2, [r6, #1620]	@ zero_extendqisi2
 12026 6534 C1FAFFEA 		b	.L1026
 12027              	.LVL1355:
 12028              	.L892:
 12029              	.LBE272:
 12030              	.LBE346:
 12031              	.LBB347:
 12032              	.LBB227:
1765:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 12033              		.loc 1 1765 0
 12034 6538 67C6D6E5 		ldrb	ip, [r6, #1639]	@ zero_extendqisi2
1766:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 12035              		.loc 1 1766 0
 12036 653c 6826D6E5 		ldrb	r2, [r6, #1640]	@ zero_extendqisi2
 12037 6540 BEFAFFEA 		b	.L1026
 12038              	.L891:
1750:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 12039              		.loc 1 1750 0
 12040 6544 71A6D6E5 		ldrb	r10, [r6, #1649]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 12041              		.loc 1 1751 0
 12042 6548 7226D6E5 		ldrb	r2, [r6, #1650]	@ zero_extendqisi2
 12043 654c 8EFEFFEA 		b	.L1033
 12044              	.LVL1356:
 12045              	.L740:
 12046              	.LBE227:
 12047              	.LBE347:
 12048              	.LBE358:
 12049              	.LBE444:
 12050              	.LBB445:
 12051              	.LBB425:
 12052              	.LBB411:
 12053              	.LBB393:
1668:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 12054              		.loc 1 1668 0
 12055 6550 FEFFFFEB 		bl	_txe_mutex_get
 12056              	.LVL1357:
1669:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12057              		.loc 1 1669 0
 12058 6554 0B20A0E1 		mov	r2, fp
 12059 6558 0A30A0E1 		mov	r3, r10
 12060 655c 0710A0E3 		mov	r1, #7
 12061 6560 00908DE5 		str	r9, [sp]
 12062 6564 04908DE5 		str	r9, [sp, #4]
 12063 6568 0600A0E1 		mov	r0, r6
 12064 656c FEFFFFEB 		bl	cmdSet
 12065              	.LVL1358:
1670:../uvc.c      **** 
 12066              		.loc 1 1670 0
 12067 6570 1C0096E5 		ldr	r0, [r6, #28]
 12068 6574 FEFFFFEB 		bl	_txe_mutex_put
 12069              	.LVL1359:
 12070 6578 FF20A0E3 		mov	r2, #255
 12071 657c 24109DE5 		ldr	r1, [sp, #36]
 12072 6580 0930A0E1 		mov	r3, r9
 12073 6584 0200A0E1 		mov	r0, r2
 12074 6588 95FAFFEA 		b	.L736
 12075              	.LVL1360:
 12076              	.L1074:
 12077              	.LBE393:
 12078              	.LBE411:
 12079              	.LBE425:
 12080              	.LBE445:
 12081              	.LBB446:
 12082              	.LBB359:
 12083              	.LBB348:
 12084              	.LBB281:
1902:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 12085              		.loc 1 1902 0
 12086 658c B0AD1FE5 		ldr	r10, .L1075+92
 12087 6590 0010E0E3 		mvn	r1, #0
 12088 6594 1C009AE5 		ldr	r0, [r10, #28]
 12089 6598 1CC08DE5 		str	ip, [sp, #28]
 12090 659c FEFFFFEB 		bl	_txe_mutex_get
 12091              	.LVL1361:
1903:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12092              		.loc 1 1903 0
 12093 65a0 24209DE5 		ldr	r2, [sp, #36]
 12094 65a4 20309DE5 		ldr	r3, [sp, #32]
 12095 65a8 0010A0E3 		mov	r1, #0
 12096 65ac 00208DE5 		str	r2, [sp]
 12097 65b0 04108DE5 		str	r1, [sp, #4]
 12098 65b4 0320A0E1 		mov	r2, r3
 12099 65b8 2210A0E3 		mov	r1, #34
 12100 65bc 0B30A0E1 		mov	r3, fp
 12101 65c0 0A00A0E1 		mov	r0, r10
 12102 65c4 FEFFFFEB 		bl	cmdSet
 12103              	.LVL1362:
1904:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 12104              		.loc 1 1904 0
 12105 65c8 1C009AE5 		ldr	r0, [r10, #28]
 12106 65cc FEFFFFEB 		bl	_txe_mutex_put
 12107              	.LVL1363:
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 12108              		.loc 1 1907 0
 12109 65d0 24309DE5 		ldr	r3, [sp, #36]
 12110 65d4 4136C6E5 		strb	r3, [r6, #1601]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 12111              		.loc 1 1908 0
 12112 65d8 1CC09DE5 		ldr	ip, [sp, #28]
1909:../uvc.c      **** 					  }else{
 12113              		.loc 1 1909 0
 12114 65dc 4486C6E5 		strb	r8, [r6, #1604]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 12115              		.loc 1 1908 0
 12116 65e0 42C6C6E5 		strb	ip, [r6, #1602]
 12117 65e4 9BFDFFEA 		b	.L876
 12118              	.LVL1364:
 12119              	.L806:
 12120              	.LBE281:
 12121              	.LBE348:
 12122              	.LBB349:
 12123              	.LBB288:
1893:../uvc.c      **** 					  }
 12124              		.loc 1 1893 0
 12125 65e8 0000A0E3 		mov	r0, #0
 12126 65ec 0020A0E1 		mov	r2, r0
 12127 65f0 0110A0E3 		mov	r1, #1
 12128 65f4 FEFFFFEB 		bl	CyU3PUsbStall
 12129              	.LVL1365:
 12130 65f8 96FDFFEA 		b	.L876
 12131              	.LVL1366:
 12132              	.L1071:
 12133              	.LBE288:
 12134              	.LBE349:
 12135              	.LBE359:
 12136              	.LBE446:
 12137              	.LBB447:
 12138              	.LBB426:
 12139              	.LBB412:
 12140              	.LBB381:
1594:../uvc.c      **** 			                         {
 12141              		.loc 1 1594 0
 12142 65fc 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 12143 6600 013043E2 		sub	r3, r3, #1
 12144 6604 030053E3 		cmp	r3, #3
 12145 6608 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12146 660c 91FCFFEA 		b	.L712
 12147              	.L714:
 12148 6610 406B0000 		.word	.L713
 12149 6614 F46A0000 		.word	.L715
 12150 6618 986A0000 		.word	.L716
 12151 661c 3C6A0000 		.word	.L717
 12152              	.LVL1367:
 12153              	.L1072:
 12154              	.LBE381:
 12155              	.LBE412:
 12156              	.LBE426:
 12157              	.LBE447:
 12158              	.LBB448:
 12159              	.LBB360:
 12160              	.LBB350:
 12161              	.LBB266:
1926:../uvc.c      **** 					  else
 12162              		.loc 1 1926 0
 12163 6620 0800A0E3 		mov	r0, #8
 12164              	.L1027:
 12165 6624 0010A0E3 		mov	r1, #0
 12166 6628 03008DE8 		stmia	sp, {r0, r1}
 12167 662c 0320A0E1 		mov	r2, r3
 12168 6630 0A00A0E1 		mov	r0, r10
 12169 6634 0B30A0E1 		mov	r3, fp
 12170 6638 2310A0E3 		mov	r1, #35
 12171 663c FEFFFFEB 		bl	cmdSet
 12172              	.LVL1368:
 12173 6640 BCFCFFEA 		b	.L911
 12174              	.LVL1369:
 12175              	.L689:
 12176              	.LBE266:
 12177              	.LBE350:
 12178              	.LBE360:
 12179              	.LBE448:
 12180              	.LBB449:
 12181              	.LBB427:
 12182              	.LBB413:
 12183              	.LBB373:
1010:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 12184              		.loc 1 1010 0
 12185 6644 0910A0E1 		mov	r1, r9
 12186 6648 FEFFFFEB 		bl	SensorGetControl
 12187              	.LVL1370:
1012:../uvc.c      **** 		 	 		 }
 12188              		.loc 1 1012 0
 12189 664c 0130A0E3 		mov	r3, #1
 12190 6650 6131C5E5 		strb	r3, [r5, #353]
1011:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12191              		.loc 1 1011 0
 12192 6654 A501C6E5 		strb	r0, [r6, #421]
 12193 6658 29FEFFEA 		b	.L690
 12194              	.LVL1371:
 12195              	.L737:
 12196              	.LBE373:
 12197              	.LBE413:
 12198              	.LBB414:
 12199              	.LBB394:
1081:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 12200              		.loc 1 1081 0
 12201 665c FEFFFFEB 		bl	SensorGetControl
 12202              	.LVL1372:
1084:../uvc.c      **** 		 	 		 }
 12203              		.loc 1 1084 0
 12204 6660 0120A0E3 		mov	r2, #1
 12205 6664 6721C5E5 		strb	r2, [r5, #359]
1082:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 12206              		.loc 1 1082 0
 12207 6668 8505C6E5 		strb	r0, [r6, #1413]
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12208              		.loc 1 1083 0
 12209 666c 8635D6E5 		ldrb	r3, [r6, #1414]	@ zero_extendqisi2
1084:../uvc.c      **** 		 	 		 }
 12210              		.loc 1 1084 0
 12211 6670 00A0A0E1 		mov	r10, r0
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12212              		.loc 1 1083 0
 12213 6674 FF3003E2 		and	r3, r3, #255
1084:../uvc.c      **** 		 	 		 }
 12214              		.loc 1 1084 0
 12215 6678 0360A0E1 		mov	r6, r3
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12216              		.loc 1 1083 0
 12217 667c 2930C5E5 		strb	r3, [r5, #41]
1081:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 12218              		.loc 1 1081 0
 12219 6680 2800C5E5 		strb	r0, [r5, #40]
 12220 6684 EFFDFFEA 		b	.L738
 12221              	.LVL1373:
 12222              	.L707:
 12223              	.LBE394:
 12224              	.LBE414:
 12225              	.LBB415:
 12226              	.LBB382:
1134:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 12227              		.loc 1 1134 0
 12228 6688 0100A0E3 		mov	r0, #1
 12229 668c FEFFFFEB 		bl	SensorGetControl
 12230              	.LVL1374:
1138:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12231              		.loc 1 1138 0
 12232 6690 EE31D6E5 		ldrb	r3, [r6, #494]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 		 }
 12233              		.loc 1 1139 0
 12234 6694 0120A0E3 		mov	r2, #1
 12235 6698 03B0A0E1 		mov	fp, r3
1138:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12236              		.loc 1 1138 0
 12237 669c 2930C5E5 		strb	r3, [r5, #41]
1139:../uvc.c      **** 		 	 		 }
 12238              		.loc 1 1139 0
 12239 66a0 6421C5E5 		strb	r2, [r5, #356]
1135:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 12240              		.loc 1 1135 0
 12241 66a4 A003A0E1 		mov	r0, r0, lsr #7
 12242              	.LVL1375:
1136:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 12243              		.loc 1 1136 0
 12244 66a8 023080E0 		add	r3, r0, r2
 12245 66ac FF3003E2 		and	r3, r3, #255
 12246 66b0 0390A0E1 		mov	r9, r3
 12247 66b4 2830C5E5 		strb	r3, [r5, #40]
1137:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12248              		.loc 1 1137 0
 12249 66b8 ED31C6E5 		strb	r3, [r6, #493]
 12250 66bc 8AFDFFEA 		b	.L709
 12251              	.LVL1376:
 12252              	.L1073:
 12253              	.LBE382:
 12254              	.LBE415:
 12255              	.LBE427:
 12256              	.LBE449:
 12257              	.LBB450:
 12258              	.LBB361:
 12259              	.LBB351:
 12260              	.LBB289:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12261              		.loc 1 1870 0
 12262 66c0 640052E3 		cmp	r2, #100
1873:../uvc.c      **** 							}
 12263              		.loc 1 1873 0
 12264 66c4 64106292 		rsbls	r1, r2, #100
 12265 66c8 C80062E2 		rsb	r0, r2, #200
 12266 66cc 0008A0E1 		mov	r0, r0, asl #16
 12267 66d0 0118A091 		movls	r1, r1, asl #16
 12268 66d4 2008A0E1 		mov	r0, r0, lsr #16
 12269              	.LVL1377:
 12270 66d8 2118A091 		movls	r1, r1, lsr #16
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12271              		.loc 1 1870 0
 12272 66dc BBFCFF8A 		bhi	.L808
 12273              	.LVL1378:
 12274              	.L810:
1875:../uvc.c      **** 								  diff = diffRd;
 12275              		.loc 1 1875 0
 12276 66e0 000051E1 		cmp	r1, r0
 12277 66e4 0010A021 		movcs	r1, r0
 12278              	.LVL1379:
 12279 66e8 02A0A033 		movcc	r10, #2
 12280              	.LVL1380:
 12281 66ec 01A0A023 		movcs	r10, #1
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12282              		.loc 1 1870 0
 12283 66f0 270052E3 		cmp	r2, #39
1873:../uvc.c      **** 							}
 12284              		.loc 1 1873 0
 12285 66f4 27006292 		rsbls	r0, r2, #39
1871:../uvc.c      **** 							}else{
 12286              		.loc 1 1871 0
 12287 66f8 27004282 		subhi	r0, r2, #39
 12288 66fc 0008A0E1 		mov	r0, r0, asl #16
 12289 6700 2008A0E1 		mov	r0, r0, lsr #16
 12290              	.LVL1381:
1875:../uvc.c      **** 								  diff = diffRd;
 12291              		.loc 1 1875 0
 12292 6704 000051E1 		cmp	r1, r0
 12293 6708 03A0A083 		movhi	r10, #3
 12294              	.LVL1382:
 12295 670c 0100A091 		movls	r0, r1
 12296              	.LVL1383:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12297              		.loc 1 1870 0
 12298 6710 140052E3 		cmp	r2, #20
1873:../uvc.c      **** 							}
 12299              		.loc 1 1873 0
 12300 6714 14106292 		rsbls	r1, r2, #20
1871:../uvc.c      **** 							}else{
 12301              		.loc 1 1871 0
 12302 6718 14104282 		subhi	r1, r2, #20
 12303 671c 0118A0E1 		mov	r1, r1, asl #16
 12304 6720 2118A0E1 		mov	r1, r1, lsr #16
 12305              	.LVL1384:
1875:../uvc.c      **** 								  diff = diffRd;
 12306              		.loc 1 1875 0
 12307 6724 000051E1 		cmp	r1, r0
 12308 6728 0010A021 		movcs	r1, r0
 12309              	.LVL1385:
 12310 672c 04A0A033 		movcc	r10, #4
 12311              	.LVL1386:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12312              		.loc 1 1870 0
 12313 6730 0A0052E3 		cmp	r2, #10
1873:../uvc.c      **** 							}
 12314              		.loc 1 1873 0
 12315 6734 0A006292 		rsbls	r0, r2, #10
1871:../uvc.c      **** 							}else{
 12316              		.loc 1 1871 0
 12317 6738 0A004282 		subhi	r0, r2, #10
 12318 673c 0008A0E1 		mov	r0, r0, asl #16
 12319 6740 2008A0E1 		mov	r0, r0, lsr #16
 12320              	.LVL1387:
1875:../uvc.c      **** 								  diff = diffRd;
 12321              		.loc 1 1875 0
 12322 6744 010050E1 		cmp	r0, r1
 12323 6748 0100A021 		movcs	r0, r1
 12324              	.LVL1388:
 12325 674c 05A0A033 		movcc	r10, #5
 12326              	.LVL1389:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12327              		.loc 1 1870 0
 12328 6750 050052E3 		cmp	r2, #5
1873:../uvc.c      **** 							}
 12329              		.loc 1 1873 0
 12330 6754 05106292 		rsbls	r1, r2, #5
1871:../uvc.c      **** 							}else{
 12331              		.loc 1 1871 0
 12332 6758 05104282 		subhi	r1, r2, #5
 12333 675c 0118A0E1 		mov	r1, r1, asl #16
 12334 6760 2118A0E1 		mov	r1, r1, lsr #16
 12335              	.LVL1390:
1875:../uvc.c      **** 								  diff = diffRd;
 12336              		.loc 1 1875 0
 12337 6764 000051E1 		cmp	r1, r0
 12338 6768 0010A021 		movcs	r1, r0
 12339              	.LVL1391:
 12340 676c 06A0A033 		movcc	r10, #6
 12341              	.LVL1392:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12342              		.loc 1 1870 0
 12343 6770 020052E3 		cmp	r2, #2
1873:../uvc.c      **** 							}
 12344              		.loc 1 1873 0
 12345 6774 02006292 		rsbls	r0, r2, #2
1871:../uvc.c      **** 							}else{
 12346              		.loc 1 1871 0
 12347 6778 02004282 		subhi	r0, r2, #2
 12348 677c 0008A0E1 		mov	r0, r0, asl #16
 12349 6780 2008A0E1 		mov	r0, r0, lsr #16
 12350              	.LVL1393:
1875:../uvc.c      **** 								  diff = diffRd;
 12351              		.loc 1 1875 0
 12352 6784 000051E1 		cmp	r1, r0
 12353 6788 0100A091 		movls	r0, r1
 12354              	.LVL1394:
 12355 678c 07A0A083 		movhi	r10, #7
 12356              	.LVL1395:
1870:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 12357              		.loc 1 1870 0
 12358 6790 010052E3 		cmp	r2, #1
1873:../uvc.c      **** 							}
 12359              		.loc 1 1873 0
 12360 6794 01206292 		rsbls	r2, r2, #1
1871:../uvc.c      **** 							}else{
 12361              		.loc 1 1871 0
 12362 6798 01204282 		subhi	r2, r2, #1
 12363 679c 0228A0E1 		mov	r2, r2, asl #16
 12364 67a0 2228A0E1 		mov	r2, r2, lsr #16
 12365              	.LVL1396:
1875:../uvc.c      **** 								  diff = diffRd;
 12366              		.loc 1 1875 0
 12367 67a4 000052E1 		cmp	r2, r0
1883:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 12368              		.loc 1 1883 0
 12369 67a8 CC2F1FE5 		ldr	r2, .L1075+92
 12370              	.LVL1397:
 12371 67ac 0010E0E3 		mvn	r1, #0
 12372 67b0 1C0092E5 		ldr	r0, [r2, #28]
 12373              	.LVL1398:
1875:../uvc.c      **** 								  diff = diffRd;
 12374              		.loc 1 1875 0
 12375 67b4 08A0A033 		movcc	r10, #8
 12376              	.LVL1399:
1883:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 12377              		.loc 1 1883 0
 12378 67b8 1CC08DE5 		str	ip, [sp, #28]
 12379 67bc 20308DE5 		str	r3, [sp, #32]
 12380 67c0 FEFFFFEB 		bl	_txe_mutex_get
 12381              	.LVL1400:
1884:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12382              		.loc 1 1884 0
 12383 67c4 20309DE5 		ldr	r3, [sp, #32]
 12384 67c8 0010A0E3 		mov	r1, #0
 12385 67cc 0320A0E1 		mov	r2, r3
 12386 67d0 04108DE5 		str	r1, [sp, #4]
 12387 67d4 0B30A0E1 		mov	r3, fp
 12388 67d8 0310A0E3 		mov	r1, #3
 12389 67dc 00A08DE5 		str	r10, [sp]
 12390 67e0 68049FE5 		ldr	r0, .L1077
 12391 67e4 FEFFFFEB 		bl	cmdSet
 12392              	.LVL1401:
1885:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 12393              		.loc 1 1885 0
 12394 67e8 60349FE5 		ldr	r3, .L1077
 12395 67ec 1C0093E5 		ldr	r0, [r3, #28]
 12396 67f0 FEFFFFEB 		bl	_txe_mutex_put
 12397              	.LVL1402:
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 12398              		.loc 1 1888 0
 12399 67f4 24109DE5 		ldr	r1, [sp, #36]
1891:../uvc.c      **** 					  }else{
 12400              		.loc 1 1891 0
 12401 67f8 0DA3C6E5 		strb	r10, [r6, #781]
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 12402              		.loc 1 1888 0
 12403 67fc E115C6E5 		strb	r1, [r6, #1505]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 12404              		.loc 1 1889 0
 12405 6800 1CC09DE5 		ldr	ip, [sp, #28]
1890:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 12406              		.loc 1 1890 0
 12407 6804 0130A0E3 		mov	r3, #1
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 12408              		.loc 1 1889 0
 12409 6808 E2C5C6E5 		strb	ip, [r6, #1506]
1890:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 12410              		.loc 1 1890 0
 12411 680c E435C6E5 		strb	r3, [r6, #1508]
 12412 6810 10FDFFEA 		b	.L876
 12413              	.LVL1403:
 12414              	.L782:
 12415              	.LBE289:
 12416              	.LBE351:
 12417              	.LBB352:
 12418              	.LBB211:
 12419              	.LBB197:
 12420              	.LBB198:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12421              		.loc 1 736 0
 12422 6814 34649FE5 		ldr	r6, .L1077
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12423              		.loc 1 737 0
 12424 6818 00A0A0E3 		mov	r10, #0
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12425              		.loc 1 736 0
 12426 681c 0010E0E3 		mvn	r1, #0
 12427 6820 1C0096E5 		ldr	r0, [r6, #28]
 12428 6824 FEFFFFEB 		bl	_txe_mutex_get
 12429              	.LVL1404:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12430              		.loc 1 737 0
 12431 6828 2010A0E3 		mov	r1, #32
 12432 682c 2720A0E3 		mov	r2, #39
 12433 6830 3030A0E3 		mov	r3, #48
 12434 6834 0600A0E1 		mov	r0, r6
 12435 6838 00A08DE5 		str	r10, [sp]
 12436 683c 04A08DE5 		str	r10, [sp, #4]
 12437 6840 FEFFFFEB 		bl	cmdSet
 12438              	.LVL1405:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12439              		.loc 1 738 0
 12440 6844 0130A0E3 		mov	r3, #1
 12441 6848 2520A0E3 		mov	r2, #37
 12442 684c 00308DE5 		str	r3, [sp]
 12443 6850 2110A0E3 		mov	r1, #33
 12444 6854 3030A0E3 		mov	r3, #48
 12445 6858 04A08DE5 		str	r10, [sp, #4]
 12446 685c 0600A0E1 		mov	r0, r6
 12447 6860 FEFFFFEB 		bl	cmdSet
 12448              	.LVL1406:
 739:../uvc.c      **** }
 12449              		.loc 1 739 0
 12450 6864 1C0096E5 		ldr	r0, [r6, #28]
 12451 6868 FEFFFFEB 		bl	_txe_mutex_put
 12452              	.LVL1407:
 12453 686c FF20A0E3 		mov	r2, #255
 12454 6870 0430A0E3 		mov	r3, #4
 12455 6874 32F9FFEA 		b	.L777
 12456              	.LVL1408:
 12457              	.L783:
 12458              	.LBE198:
 12459              	.LBE197:
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12460              		.loc 1 1841 0
 12461 6878 D0A39FE5 		ldr	r10, .L1077
1839:../uvc.c      **** 			  		    	dataIdx = 0;
 12462              		.loc 1 1839 0
 12463 687c 00B0A0E3 		mov	fp, #0
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12464              		.loc 1 1841 0
 12465 6880 1C009AE5 		ldr	r0, [r10, #28]
 12466 6884 0010E0E3 		mvn	r1, #0
1839:../uvc.c      **** 			  		    	dataIdx = 0;
 12467              		.loc 1 1839 0
 12468 6888 0DB3C6E5 		strb	fp, [r6, #781]
 12469              	.LVL1409:
1841:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12470              		.loc 1 1841 0
 12471 688c 20308DE5 		str	r3, [sp, #32]
 12472 6890 1CC08DE5 		str	ip, [sp, #28]
 12473 6894 FEFFFFEB 		bl	_txe_mutex_get
 12474              	.LVL1410:
1842:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12475              		.loc 1 1842 0
 12476 6898 1CC09DE5 		ldr	ip, [sp, #28]
 12477 689c 20309DE5 		ldr	r3, [sp, #32]
 12478 68a0 1010A0E3 		mov	r1, #16
 12479 68a4 0320A0E1 		mov	r2, r3
 12480 68a8 00B08DE5 		str	fp, [sp]
 12481 68ac 0C30A0E1 		mov	r3, ip
 12482 68b0 04B08DE5 		str	fp, [sp, #4]
 12483 68b4 0A00A0E1 		mov	r0, r10
 12484 68b8 FEFFFFEB 		bl	cmdSet
 12485              	.LVL1411:
1843:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 12486              		.loc 1 1843 0
 12487 68bc 1C009AE5 		ldr	r0, [r10, #28]
 12488 68c0 FEFFFFEB 		bl	_txe_mutex_put
 12489              	.LVL1412:
 12490              	.LBB199:
 12491              	.LBB200:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12492              		.loc 1 736 0
 12493 68c4 0010E0E3 		mvn	r1, #0
 12494 68c8 1C009AE5 		ldr	r0, [r10, #28]
 12495 68cc FEFFFFEB 		bl	_txe_mutex_get
 12496              	.LVL1413:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12497              		.loc 1 737 0
 12498 68d0 0130A0E3 		mov	r3, #1
 12499 68d4 00308DE5 		str	r3, [sp]
 12500 68d8 2010A0E3 		mov	r1, #32
 12501 68dc 2720A0E3 		mov	r2, #39
 12502 68e0 3030A0E3 		mov	r3, #48
 12503 68e4 04B08DE5 		str	fp, [sp, #4]
 12504 68e8 0A00A0E1 		mov	r0, r10
 12505 68ec FEFFFFEB 		bl	cmdSet
 12506              	.LVL1414:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12507              		.loc 1 738 0
 12508 68f0 0230A0E3 		mov	r3, #2
 12509 68f4 2520A0E3 		mov	r2, #37
 12510 68f8 00308DE5 		str	r3, [sp]
 12511 68fc 2110A0E3 		mov	r1, #33
 12512 6900 3030A0E3 		mov	r3, #48
 12513 6904 04B08DE5 		str	fp, [sp, #4]
 12514 6908 0A00A0E1 		mov	r0, r10
 12515 690c FEFFFFEB 		bl	cmdSet
 12516              	.LVL1415:
 739:../uvc.c      **** }
 12517              		.loc 1 739 0
 12518 6910 1C009AE5 		ldr	r0, [r10, #28]
 12519 6914 FEFFFFEB 		bl	_txe_mutex_put
 12520              	.LVL1416:
 12521 6918 FF20A0E3 		mov	r2, #255
 12522 691c 0830A0E3 		mov	r3, #8
 12523 6920 07F9FFEA 		b	.L777
 12524              	.LVL1417:
 12525              	.L778:
 12526 6924 0230A0E1 		mov	r3, r2
 12527              	.LBE200:
 12528              	.LBE199:
1822:../uvc.c      **** 						case 1:
 12529              		.loc 1 1822 0
 12530 6928 FF20A0E3 		mov	r2, #255
 12531 692c 04F9FFEA 		b	.L777
 12532              	.L779:
 12533              	.LVL1418:
 12534              	.LBB201:
 12535              	.LBB202:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12536              		.loc 1 736 0
 12537 6930 18639FE5 		ldr	r6, .L1077
 12538 6934 0010E0E3 		mvn	r1, #0
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12539              		.loc 1 737 0
 12540 6938 01A0A0E3 		mov	r10, #1
 12541 693c 00B0A0E3 		mov	fp, #0
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12542              		.loc 1 736 0
 12543 6940 1C0096E5 		ldr	r0, [r6, #28]
 12544 6944 FEFFFFEB 		bl	_txe_mutex_get
 12545              	.LVL1419:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12546              		.loc 1 737 0
 12547 6948 2010A0E3 		mov	r1, #32
 12548 694c 2720A0E3 		mov	r2, #39
 12549 6950 3030A0E3 		mov	r3, #48
 12550 6954 0600A0E1 		mov	r0, r6
 12551 6958 000C8DE8 		stmia	sp, {r10, fp}
 12552 695c FEFFFFEB 		bl	cmdSet
 12553              	.LVL1420:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12554              		.loc 1 738 0
 12555 6960 0230A0E3 		mov	r3, #2
 12556 6964 2520A0E3 		mov	r2, #37
 12557 6968 00308DE5 		str	r3, [sp]
 12558 696c 2110A0E3 		mov	r1, #33
 12559 6970 3030A0E3 		mov	r3, #48
 12560 6974 04B08DE5 		str	fp, [sp, #4]
 12561 6978 0600A0E1 		mov	r0, r6
 12562 697c FEFFFFEB 		bl	cmdSet
 12563              	.LVL1421:
 739:../uvc.c      **** }
 12564              		.loc 1 739 0
 12565 6980 1C0096E5 		ldr	r0, [r6, #28]
 12566 6984 FEFFFFEB 		bl	_txe_mutex_put
 12567              	.LVL1422:
 12568 6988 0A30A0E1 		mov	r3, r10
 12569 698c FF20A0E3 		mov	r2, #255
 12570 6990 EBF8FFEA 		b	.L777
 12571              	.LVL1423:
 12572              	.L781:
 12573              	.LBE202:
 12574              	.LBE201:
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12575              		.loc 1 1829 0
 12576 6994 B4A29FE5 		ldr	r10, .L1077
1827:../uvc.c      **** 							dataIdx = 0;
 12577              		.loc 1 1827 0
 12578 6998 00B0A0E3 		mov	fp, #0
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12579              		.loc 1 1829 0
 12580 699c 1C009AE5 		ldr	r0, [r10, #28]
 12581 69a0 0010E0E3 		mvn	r1, #0
1827:../uvc.c      **** 							dataIdx = 0;
 12582              		.loc 1 1827 0
 12583 69a4 0DB3C6E5 		strb	fp, [r6, #781]
 12584              	.LVL1424:
1829:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 12585              		.loc 1 1829 0
 12586 69a8 20308DE5 		str	r3, [sp, #32]
 12587 69ac 1CC08DE5 		str	ip, [sp, #28]
 12588 69b0 FEFFFFEB 		bl	_txe_mutex_get
 12589              	.LVL1425:
1830:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12590              		.loc 1 1830 0
 12591 69b4 1CC09DE5 		ldr	ip, [sp, #28]
 12592 69b8 20309DE5 		ldr	r3, [sp, #32]
 12593 69bc 1010A0E3 		mov	r1, #16
 12594 69c0 0320A0E1 		mov	r2, r3
 12595 69c4 00B08DE5 		str	fp, [sp]
 12596 69c8 0C30A0E1 		mov	r3, ip
 12597 69cc 04B08DE5 		str	fp, [sp, #4]
 12598 69d0 0A00A0E1 		mov	r0, r10
 12599 69d4 FEFFFFEB 		bl	cmdSet
 12600              	.LVL1426:
1831:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 12601              		.loc 1 1831 0
 12602 69d8 1C009AE5 		ldr	r0, [r10, #28]
 12603 69dc FEFFFFEB 		bl	_txe_mutex_put
 12604              	.LVL1427:
 12605              	.LBB203:
 12606              	.LBB204:
 736:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 12607              		.loc 1 736 0
 12608 69e0 0010E0E3 		mvn	r1, #0
 12609 69e4 1C009AE5 		ldr	r0, [r10, #28]
 12610 69e8 FEFFFFEB 		bl	_txe_mutex_get
 12611              	.LVL1428:
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 12612              		.loc 1 737 0
 12613 69ec 2010A0E3 		mov	r1, #32
 12614 69f0 2720A0E3 		mov	r2, #39
 12615 69f4 3030A0E3 		mov	r3, #48
 12616 69f8 00B08DE5 		str	fp, [sp]
 12617 69fc 04B08DE5 		str	fp, [sp, #4]
 12618 6a00 0A00A0E1 		mov	r0, r10
 12619 6a04 FEFFFFEB 		bl	cmdSet
 12620              	.LVL1429:
 738:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12621              		.loc 1 738 0
 12622 6a08 0130A0E3 		mov	r3, #1
 12623 6a0c 2520A0E3 		mov	r2, #37
 12624 6a10 00308DE5 		str	r3, [sp]
 12625 6a14 2110A0E3 		mov	r1, #33
 12626 6a18 3030A0E3 		mov	r3, #48
 12627 6a1c 04B08DE5 		str	fp, [sp, #4]
 12628 6a20 0A00A0E1 		mov	r0, r10
 12629 6a24 FEFFFFEB 		bl	cmdSet
 12630              	.LVL1430:
 739:../uvc.c      **** }
 12631              		.loc 1 739 0
 12632 6a28 1C009AE5 		ldr	r0, [r10, #28]
 12633 6a2c FEFFFFEB 		bl	_txe_mutex_put
 12634              	.LVL1431:
 12635 6a30 FF20A0E3 		mov	r2, #255
 12636 6a34 0230A0E3 		mov	r3, #2
 12637 6a38 C1F8FFEA 		b	.L777
 12638              	.LVL1432:
 12639              	.L717:
 12640              	.LBE204:
 12641              	.LBE203:
 12642              	.LBE211:
 12643              	.LBE352:
 12644              	.LBE361:
 12645              	.LBE450:
 12646              	.LBB451:
 12647              	.LBB428:
 12648              	.LBB416:
 12649              	.LBB383:
1612:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 12650              		.loc 1 1612 0
 12651 6a3c 782095E5 		ldr	r2, [r5, #120]
 12652 6a40 D234D6E5 		ldrb	r3, [r6, #1234]	@ zero_extendqisi2
 12653 6a44 000052E3 		cmp	r2, #0
 12654 6a48 F420A003 		moveq	r2, #244
 12655 6a4c 7420A013 		movne	r2, #116
 12656 6a50 032082E1 		orr	r2, r2, r3
 12657 6a54 3010A0E3 		mov	r1, #48
 12658 6a58 5230A0E3 		mov	r3, #82
 12659 6a5c 0100A0E3 		mov	r0, #1
 12660 6a60 FEFFFFEB 		bl	SensorSetIrisControl
 12661              	.LVL1433:
1613:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 12662              		.loc 1 1613 0
 12663 6a64 7D0FA0E3 		mov	r0, #500
 12664 6a68 FEFFFFEB 		bl	_tx_thread_sleep
 12665              	.LVL1434:
1614:../uvc.c      **** 			                         	default:
 12666              		.loc 1 1614 0
 12667 6a6c 781095E5 		ldr	r1, [r5, #120]
 12668 6a70 D224D6E5 		ldrb	r2, [r6, #1234]	@ zero_extendqisi2
 12669 6a74 000051E3 		cmp	r1, #0
 12670 6a78 F410A003 		moveq	r1, #244
 12671 6a7c 7410A013 		movne	r1, #116
 12672 6a80 022081E1 		orr	r2, r1, r2
 12673 6a84 783095E5 		ldr	r3, [r5, #120]
 12674 6a88 C4119FE5 		ldr	r1, .L1077+4
 12675 6a8c 0400A0E3 		mov	r0, #4
 12676 6a90 FEFFFFEB 		bl	CyU3PDebugPrint
 12677              	.LVL1435:
 12678 6a94 6FFBFFEA 		b	.L712
 12679              	.L716:
1607:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 12680              		.loc 1 1607 0
 12681 6a98 782095E5 		ldr	r2, [r5, #120]
 12682 6a9c D234D6E5 		ldrb	r3, [r6, #1234]	@ zero_extendqisi2
 12683 6aa0 000052E3 		cmp	r2, #0
 12684 6aa4 C420A003 		moveq	r2, #196
 12685 6aa8 4420A013 		movne	r2, #68
 12686 6aac 032082E1 		orr	r2, r2, r3
 12687 6ab0 3010A0E3 		mov	r1, #48
 12688 6ab4 5230A0E3 		mov	r3, #82
 12689 6ab8 0100A0E3 		mov	r0, #1
 12690 6abc FEFFFFEB 		bl	SensorSetIrisControl
 12691              	.LVL1436:
1608:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 12692              		.loc 1 1608 0
 12693 6ac0 7D0FA0E3 		mov	r0, #500
 12694 6ac4 FEFFFFEB 		bl	_tx_thread_sleep
 12695              	.LVL1437:
1609:../uvc.c      **** 			                         		break;
 12696              		.loc 1 1609 0
 12697 6ac8 781095E5 		ldr	r1, [r5, #120]
 12698 6acc D224D6E5 		ldrb	r2, [r6, #1234]	@ zero_extendqisi2
 12699 6ad0 000051E3 		cmp	r1, #0
 12700 6ad4 C410A003 		moveq	r1, #196
 12701 6ad8 4410A013 		movne	r1, #68
 12702 6adc 022081E1 		orr	r2, r1, r2
 12703 6ae0 783095E5 		ldr	r3, [r5, #120]
 12704 6ae4 68119FE5 		ldr	r1, .L1077+4
 12705 6ae8 0400A0E3 		mov	r0, #4
 12706 6aec FEFFFFEB 		bl	CyU3PDebugPrint
 12707              	.LVL1438:
 12708 6af0 58FBFFEA 		b	.L712
 12709              	.L715:
1602:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 12710              		.loc 1 1602 0
 12711 6af4 782095E5 		ldr	r2, [r5, #120]
 12712 6af8 3010A0E3 		mov	r1, #48
 12713 6afc 000052E3 		cmp	r2, #0
 12714 6b00 D420A003 		moveq	r2, #212
 12715 6b04 5420A013 		movne	r2, #84
 12716 6b08 5230A0E3 		mov	r3, #82
 12717 6b0c 0100A0E3 		mov	r0, #1
 12718 6b10 FEFFFFEB 		bl	SensorSetIrisControl
 12719              	.LVL1439:
1603:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 12720              		.loc 1 1603 0
 12721 6b14 7D0FA0E3 		mov	r0, #500
 12722 6b18 FEFFFFEB 		bl	_tx_thread_sleep
 12723              	.LVL1440:
1604:../uvc.c      **** 			                         		break;
 12724              		.loc 1 1604 0
 12725 6b1c 782095E5 		ldr	r2, [r5, #120]
 12726 6b20 2C119FE5 		ldr	r1, .L1077+4
 12727 6b24 000052E3 		cmp	r2, #0
 12728 6b28 783095E5 		ldr	r3, [r5, #120]
 12729 6b2c D420A003 		moveq	r2, #212
 12730 6b30 5420A013 		movne	r2, #84
 12731 6b34 0400A0E3 		mov	r0, #4
 12732 6b38 FEFFFFEB 		bl	CyU3PDebugPrint
 12733              	.LVL1441:
 12734 6b3c 45FBFFEA 		b	.L712
 12735              	.L713:
1597:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 12736              		.loc 1 1597 0
 12737 6b40 782095E5 		ldr	r2, [r5, #120]
 12738 6b44 3010A0E3 		mov	r1, #48
 12739 6b48 000052E3 		cmp	r2, #0
 12740 6b4c E420A003 		moveq	r2, #228
 12741 6b50 6420A013 		movne	r2, #100
 12742 6b54 5230A0E3 		mov	r3, #82
 12743 6b58 0100A0E3 		mov	r0, #1
 12744 6b5c FEFFFFEB 		bl	SensorSetIrisControl
 12745              	.LVL1442:
1598:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 12746              		.loc 1 1598 0
 12747 6b60 7D0FA0E3 		mov	r0, #500
 12748 6b64 FEFFFFEB 		bl	_tx_thread_sleep
 12749              	.LVL1443:
1599:../uvc.c      **** 			                         		break;
 12750              		.loc 1 1599 0
 12751 6b68 782095E5 		ldr	r2, [r5, #120]
 12752 6b6c E0109FE5 		ldr	r1, .L1077+4
 12753 6b70 000052E3 		cmp	r2, #0
 12754 6b74 783095E5 		ldr	r3, [r5, #120]
 12755 6b78 E420A003 		moveq	r2, #228
 12756 6b7c 6420A013 		movne	r2, #100
 12757 6b80 0400A0E3 		mov	r0, #4
 12758 6b84 FEFFFFEB 		bl	CyU3PDebugPrint
 12759              	.LVL1444:
 12760 6b88 32FBFFEA 		b	.L712
 12761              	.LVL1445:
 12762              	.L1046:
 12763              	.LBE383:
 12764              	.LBE416:
 12765              	.LBE428:
 12766              	.LBE451:
4423:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 12767              		.loc 1 4423 0
 12768 6b8c 0400A0E3 		mov	r0, #4
 12769              	.LVL1446:
 12770 6b90 C0109FE5 		ldr	r1, .L1077+8
 12771 6b94 0620A0E1 		mov	r2, r6
 12772 6b98 FEFFFFEB 		bl	CyU3PDebugPrint
 12773              	.LVL1447:
4424:../uvc.c      ****                 }
 12774              		.loc 1 4424 0
 12775 6b9c 0600A0E1 		mov	r0, r6
 12776 6ba0 FEFFFFEB 		bl	CyFxAppErrorHandler
 12777              	.LVL1448:
 12778              	.L693:
 12779              	.LBB452:
 12780              	.LBB429:
 12781              	.LBB417:
 12782              	.LBB374:
1699:../uvc.c      **** 			   }
 12783              		.loc 1 1699 0
 12784 6ba4 B0109FE5 		ldr	r1, .L1077+12
 12785 6ba8 0400A0E3 		mov	r0, #4
 12786              	.LVL1449:
 12787 6bac FEFFFFEB 		bl	CyU3PDebugPrint
 12788              	.LVL1450:
 12789 6bb0 FF10A0E3 		mov	r1, #255
 12790 6bb4 0120A0E1 		mov	r2, r1
 12791 6bb8 0130A0E1 		mov	r3, r1
 12792 6bbc 96F7FFEA 		b	.L688
 12793              	.LVL1451:
 12794              	.L739:
 12795              	.LBE374:
 12796              	.LBE417:
 12797              	.LBB418:
 12798              	.LBB395:
 12799 6bc0 94109FE5 		ldr	r1, .L1077+12
 12800 6bc4 0400A0E3 		mov	r0, #4
 12801              	.LVL1452:
 12802 6bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 12803              	.LVL1453:
 12804 6bcc FF20A0E3 		mov	r2, #255
 12805 6bd0 0200A0E1 		mov	r0, r2
 12806 6bd4 0210A0E1 		mov	r1, r2
 12807 6bd8 0230A0E1 		mov	r3, r2
 12808 6bdc 00F9FFEA 		b	.L736
 12809              	.LVL1454:
 12810              	.L710:
 12811              	.LBE395:
 12812              	.LBE418:
 12813              	.LBB419:
 12814              	.LBB384:
 12815 6be0 74109FE5 		ldr	r1, .L1077+12
 12816 6be4 0400A0E3 		mov	r0, #4
 12817              	.LVL1455:
 12818 6be8 FEFFFFEB 		bl	CyU3PDebugPrint
 12819              	.LVL1456:
 12820 6bec FF10A0E3 		mov	r1, #255
 12821 6bf0 0190A0E1 		mov	r9, r1
 12822 6bf4 0120A0E1 		mov	r2, r1
 12823 6bf8 0130A0E1 		mov	r3, r1
 12824 6bfc D1F8FFEA 		b	.L706
 12825              	.LVL1457:
 12826              	.L1048:
 12827 6c00 0060A0E1 		mov	r6, r0
 12828              	.LBE384:
 12829              	.LBE419:
 12830              	.LBE429:
 12831              	.LBE452:
4490:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 12832              		.loc 1 4490 0
 12833 6c04 54109FE5 		ldr	r1, .L1077+16
 12834 6c08 0400A0E3 		mov	r0, #4
 12835              	.LVL1458:
 12836 6c0c 0620A0E1 		mov	r2, r6
 12837 6c10 FEFFFFEB 		bl	CyU3PDebugPrint
 12838              	.LVL1459:
4491:../uvc.c      ****                 }
 12839              		.loc 1 4491 0
 12840 6c14 0600A0E1 		mov	r0, r6
 12841 6c18 FEFFFFEB 		bl	CyFxAppErrorHandler
 12842              	.LVL1460:
 12843              	.L1051:
 12844 6c1c 00A0A0E1 		mov	r10, r0
4404:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 12845              		.loc 1 4404 0
 12846 6c20 3C109FE5 		ldr	r1, .L1077+20
 12847 6c24 0900A0E1 		mov	r0, r9
 12848              	.LVL1461:
 12849 6c28 0A20A0E1 		mov	r2, r10
 12850 6c2c FEFFFFEB 		bl	CyU3PDebugPrint
 12851              	.LVL1462:
4405:../uvc.c      **** 					}
 12852              		.loc 1 4405 0
 12853 6c30 0A00A0E1 		mov	r0, r10
 12854 6c34 FEFFFFEB 		bl	CyFxAppErrorHandler
 12855              	.LVL1463:
 12856              	.L1056:
 12857 6c38 0290A0E1 		mov	r9, r2
4377:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 12858              		.loc 1 4377 0
 12859 6c3c 0A00A0E1 		mov	r0, r10
 12860              	.LVL1464:
 12861 6c40 1C109FE5 		ldr	r1, .L1077+20
 12862 6c44 FEFFFFEB 		bl	CyU3PDebugPrint
 12863              	.LVL1465:
4378:../uvc.c      **** 					}
 12864              		.loc 1 4378 0
 12865 6c48 0900A0E1 		mov	r0, r9
 12866 6c4c FEFFFFEB 		bl	CyFxAppErrorHandler
 12867              	.LVL1466:
 12868              	.L1078:
 12869              		.align	2
 12870              	.L1077:
 12871 6c50 00000000 		.word	cmdQu
 12872 6c54 00060000 		.word	.LC35
 12873 6c58 4C0E0000 		.word	.LC82
 12874 6c5c 24060000 		.word	.LC36
 12875 6c60 1C0F0000 		.word	.LC87
 12876 6c64 180E0000 		.word	.LC81
 12877              		.cfi_endproc
 12878              	.LFE26:
 12880              		.align	2
 12881              		.global	CyFxGpifCB
 12883              	CyFxGpifCB:
 12884              	.LFB13:
2487:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12885              		.loc 1 2487 0
 12886              		.cfi_startproc
 12887              		@ args = 0, pretend = 0, frame = 0
 12888              		@ frame_needed = 0, uses_anonymous_args = 0
2488:../uvc.c      ****     {
 12889              		.loc 1 2488 0
 12890 6c68 010050E3 		cmp	r0, #1
2487:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12891              		.loc 1 2487 0
 12892 6c6c 10402DE9 		stmfd	sp!, {r4, lr}
 12893              	.LCFI29:
 12894              		.cfi_def_cfa_offset 8
 12895              		.cfi_offset 4, -8
 12896              		.cfi_offset 14, -4
2488:../uvc.c      ****     {
 12897              		.loc 1 2488 0
 12898 6c70 1080BD18 		ldmnefd	sp!, {r4, pc}
 12899              	.LBB457:
 12900              	.LBB458:
2385:../uvc.c      ****     {
 12901              		.loc 1 2385 0
 12902 6c74 C4309FE5 		ldr	r3, .L1096
 12903 6c78 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12904 6c7c 030053E3 		cmp	r3, #3
 12905 6c80 1000000A 		beq	.L1095
2411:../uvc.c      ****     {
 12906              		.loc 1 2411 0
 12907 6c84 020053E3 		cmp	r3, #2
 12908 6c88 1080BD18 		ldmnefd	sp!, {r4, pc}
2413:../uvc.c      ****         {
 12909              		.loc 1 2413 0
 12910 6c8c 083041E2 		sub	r3, r1, #8
 12911 6c90 0A0053E3 		cmp	r3, #10
 12912 6c94 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12913 6c98 200000EA 		b	.L1088
 12914              	.L1090:
 12915 6c9c 186D0000 		.word	.L1083
 12916 6ca0 206D0000 		.word	.L1088
 12917 6ca4 206D0000 		.word	.L1088
 12918 6ca8 E86C0000 		.word	.L1079
 12919 6cac 206D0000 		.word	.L1088
 12920 6cb0 206D0000 		.word	.L1088
 12921 6cb4 206D0000 		.word	.L1088
 12922 6cb8 EC6C0000 		.word	.L1094
 12923 6cbc 206D0000 		.word	.L1088
 12924 6cc0 206D0000 		.word	.L1088
 12925 6cc4 E86C0000 		.word	.L1079
 12926              	.L1095:
2387:../uvc.c      ****         {
 12927              		.loc 1 2387 0
 12928 6cc8 0B1041E2 		sub	r1, r1, #11
 12929 6ccc 030051E3 		cmp	r1, #3
 12930 6cd0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12931 6cd4 150000EA 		b	.L1082
 12932              	.L1084:
 12933 6cd8 186D0000 		.word	.L1083
 12934 6cdc EC6C0000 		.word	.L1094
 12935 6ce0 E86C0000 		.word	.L1079
 12936 6ce4 E86C0000 		.word	.L1079
 12937              	.L1079:
 12938 6ce8 1080BDE8 		ldmfd	sp!, {r4, pc}
 12939              	.L1094:
2413:../uvc.c      ****         {
 12940              		.loc 1 2413 0
 12941 6cec 0110A0E3 		mov	r1, #1
 12942              	.L1085:
2470:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12943              		.loc 1 2470 0
 12944 6cf0 4C009FE5 		ldr	r0, .L1096+4
 12945 6cf4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
2471:../uvc.c      ****         {
 12946              		.loc 1 2471 0
 12947 6cf8 004050E2 		subs	r4, r0, #0
 12948 6cfc 1080BD08 		ldmeqfd	sp!, {r4, pc}
2473:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12949              		.loc 1 2473 0
 12950 6d00 0400A0E3 		mov	r0, #4
 12951 6d04 3C109FE5 		ldr	r1, .L1096+8
 12952 6d08 0420A0E1 		mov	r2, r4
 12953 6d0c FEFFFFEB 		bl	CyU3PDebugPrint
2474:../uvc.c      ****         }
 12954              		.loc 1 2474 0
 12955 6d10 0400A0E1 		mov	r0, r4
 12956 6d14 FEFFFFEB 		bl	CyFxAppErrorHandler
 12957              	.L1083:
2387:../uvc.c      ****         {
 12958              		.loc 1 2387 0
 12959 6d18 0010A0E3 		mov	r1, #0
 12960 6d1c F3FFFFEA 		b	.L1085
 12961              	.L1088:
2459:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12962              		.loc 1 2459 0
 12963 6d20 0120A0E1 		mov	r2, r1
 12964 6d24 0100A0E3 		mov	r0, #1
 12965 6d28 1C109FE5 		ldr	r1, .L1096+12
 12966 6d2c FEFFFFEB 		bl	CyU3PDebugPrint
 12967              	.L1082:
 12968              	.LBE458:
 12969              	.LBE457:
 12970              	.LBB459:
 12971              	.LBB460:
2494:../uvc.c      ****     }
 12972              		.loc 1 2494 0
 12973 6d30 0400A0E3 		mov	r0, #4
 12974 6d34 14109FE5 		ldr	r1, .L1096+16
 12975              	.LBE460:
 12976              	.LBE459:
2497:../uvc.c      **** 
 12977              		.loc 1 2497 0
 12978 6d38 1040BDE8 		ldmfd	sp!, {r4, lr}
 12979              	.LBB462:
 12980              	.LBB461:
2494:../uvc.c      ****     }
 12981              		.loc 1 2494 0
 12982 6d3c FEFFFFEA 		b	CyU3PDebugPrint
 12983              	.L1097:
 12984              		.align	2
 12985              	.L1096:
 12986 6d40 00000000 		.word	.LANCHOR0
 12987 6d44 00000000 		.word	glChHandleUVCStream
 12988 6d48 A40F0000 		.word	.LC90
 12989 6d4c 8C0F0000 		.word	.LC89
 12990 6d50 D40F0000 		.word	.LC91
 12991              	.LBE461:
 12992              	.LBE462:
 12993              		.cfi_endproc
 12994              	.LFE13:
 12996              		.align	2
 12997              		.global	CyFxApplicationDefine
 12999              	CyFxApplicationDefine:
 13000              	.LFB28:
4783:../uvc.c      **** }
4784:../uvc.c      **** 
4785:../uvc.c      **** 
4786:../uvc.c      **** /*
4787:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4788:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4789:../uvc.c      ****  */
4790:../uvc.c      **** void
4791:../uvc.c      **** CyFxApplicationDefine (
4792:../uvc.c      ****         void)
4793:../uvc.c      **** {
 13001              		.loc 1 4793 0
 13002              		.cfi_startproc
 13003              		@ args = 0, pretend = 0, frame = 32
 13004              		@ frame_needed = 0, uses_anonymous_args = 0
 13005              	.LVL1467:
 13006 6d54 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 13007              	.LCFI30:
 13008              		.cfi_def_cfa_offset 32
 13009              		.cfi_offset 4, -32
 13010              		.cfi_offset 5, -28
 13011              		.cfi_offset 6, -24
 13012              		.cfi_offset 7, -20
 13013              		.cfi_offset 8, -16
 13014              		.cfi_offset 9, -12
 13015              		.cfi_offset 10, -8
 13016              		.cfi_offset 14, -4
4794:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4795:../uvc.c      ****     uint32_t retThrdCreate;
4796:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4797:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4798:../uvc.c      **** 
4799:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4800:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 13017              		.loc 1 4800 0
 13018 6d58 010AA0E3 		mov	r0, #4096
4793:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 13019              		.loc 1 4793 0
 13020 6d5c 40D04DE2 		sub	sp, sp, #64
 13021              	.LCFI31:
 13022              		.cfi_def_cfa_offset 96
 13023              		.loc 1 4800 0
 13024 6d60 FEFFFFEB 		bl	CyU3PMemAlloc
 13025              	.LVL1468:
 13026 6d64 0070A0E1 		mov	r7, r0
 13027              	.LVL1469:
4801:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 13028              		.loc 1 4801 0
 13029 6d68 010AA0E3 		mov	r0, #4096
 13030              	.LVL1470:
 13031 6d6c FEFFFFEB 		bl	CyU3PMemAlloc
 13032              	.LVL1471:
 13033 6d70 0060A0E1 		mov	r6, r0
 13034              	.LVL1472:
4802:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 13035              		.loc 1 4802 0
 13036 6d74 010AA0E3 		mov	r0, #4096
 13037              	.LVL1473:
 13038 6d78 FEFFFFEB 		bl	CyU3PMemAlloc
 13039              	.LVL1474:
4803:../uvc.c      **** 
4804:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 13040              		.loc 1 4804 0
 13041 6d7c 000056E3 		cmp	r6, #0
 13042 6d80 00005713 		cmpne	r7, #0
 13043 6d84 00A0A013 		movne	r10, #0
 13044 6d88 01A0A003 		moveq	r10, #1
4802:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 13045              		.loc 1 4802 0
 13046 6d8c 0090A0E1 		mov	r9, r0
 13047              	.LVL1475:
 13048              		.loc 1 4804 0
 13049 6d90 0000001A 		bne	.L1109
 13050              	.LVL1476:
 13051              	.L1099:
 13052              	.L1101:
 13053 6d94 FEFFFFEA 		b	.L1101
 13054              	.LVL1477:
 13055              	.L1109:
 13056              		.loc 1 4804 0 is_stmt 0 discriminator 1
 13057 6d98 000050E3 		cmp	r0, #0
 13058 6d9c FCFFFF0A 		beq	.L1099
 13059              	.LVL1478:
4805:../uvc.c      ****         goto fatalErrorHandler;
4806:../uvc.c      **** 
4807:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4808:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4809:../uvc.c      ****     char *staName = "I2CstaQue";
4810:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 13060              		.loc 1 4810 0 is_stmt 1
 13061 6da0 F4309FE5 		ldr	r3, .L1110
 13062 6da4 20008DE2 		add	r0, sp, #32
 13063              	.LVL1479:
 13064 6da8 00308DE5 		str	r3, [sp]
 13065 6dac 4010A0E3 		mov	r1, #64
 13066 6db0 E8209FE5 		ldr	r2, .L1110+4
 13067 6db4 0A30A0E1 		mov	r3, r10
 13068 6db8 FEFFFFEB 		bl	cmdbufCreate
 13069              	.LVL1480:
 13070 6dbc 20E08DE2 		add	lr, sp, #32
 13071 6dc0 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 13072 6dc4 D8C09FE5 		ldr	ip, .L1110+8
4811:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4812:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4813:../uvc.c      **** 
4814:../uvc.c      **** 	/****** initialize command descriptor ***********/
4815:../uvc.c      **** 	cmdquInit(cmdQuptr);
4816:../uvc.c      **** 	cmdquInit(statQuptr);
4817:../uvc.c      **** 
4818:../uvc.c      ****     /* Create the UVC application thread. */
4819:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 13073              		.loc 1 4819 0
 13074 6dc8 0840A0E3 		mov	r4, #8
4810:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 13075              		.loc 1 4810 0
 13076 6dcc 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 13077 6dd0 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 13078              		.loc 1 4819 0
 13079 6dd4 0150A0E3 		mov	r5, #1
4810:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 13080              		.loc 1 4810 0
 13081 6dd8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4815:../uvc.c      **** 	cmdquInit(statQuptr);
 13082              		.loc 1 4815 0
 13083 6ddc 10004CE2 		sub	r0, ip, #16
 13084 6de0 FEFFFFEB 		bl	cmdquInit
 13085              	.LVL1481:
4816:../uvc.c      **** 
 13086              		.loc 1 4816 0
 13087 6de4 BC009FE5 		ldr	r0, .L1110+12
 13088 6de8 FEFFFFEB 		bl	cmdquInit
 13089              	.LVL1482:
 13090              		.loc 1 4819 0
 13091 6dec A880A0E3 		mov	r8, #168
 13092 6df0 012AA0E3 		mov	r2, #4096
 13093 6df4 0A30A0E1 		mov	r3, r10
 13094 6df8 14008DE9 		stmib	sp, {r2, r4}
 13095 6dfc A8009FE5 		ldr	r0, .L1110+16
 13096 6e00 00708DE5 		str	r7, [sp]
 13097 6e04 10A08DE5 		str	r10, [sp, #16]
 13098 6e08 0C408DE5 		str	r4, [sp, #12]
 13099 6e0c 14508DE5 		str	r5, [sp, #20]
 13100 6e10 18808DE5 		str	r8, [sp, #24]
 13101 6e14 94109FE5 		ldr	r1, .L1110+20
 13102 6e18 94209FE5 		ldr	r2, .L1110+24
 13103 6e1c FEFFFFEB 		bl	_txe_thread_create
 13104              	.LVL1483:
4820:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4821:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4822:../uvc.c      ****             0,                                          /* No input parameter to thread */
4823:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4824:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4825:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4826:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4827:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4828:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4829:../uvc.c      ****             );
4830:../uvc.c      ****     if (retThrdCreate != 0)
 13105              		.loc 1 4830 0
 13106 6e20 003050E2 		subs	r3, r0, #0
 13107 6e24 DAFFFF1A 		bne	.L1099
4831:../uvc.c      ****     {
4832:../uvc.c      ****         goto fatalErrorHandler;
4833:../uvc.c      ****     }
4834:../uvc.c      **** 
4835:../uvc.c      ****     /* Create the control request handling thread. */
4836:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 13108              		.loc 1 4836 0
 13109 6e28 027BA0E3 		mov	r7, #2048
 13110              	.LVL1484:
 13111 6e2c 10308DE5 		str	r3, [sp, #16]
 13112 6e30 00608DE5 		str	r6, [sp]
 13113 6e34 08408DE5 		str	r4, [sp, #8]
 13114 6e38 0C408DE5 		str	r4, [sp, #12]
 13115 6e3c 14508DE5 		str	r5, [sp, #20]
 13116 6e40 18808DE5 		str	r8, [sp, #24]
 13117 6e44 04708DE5 		str	r7, [sp, #4]
 13118 6e48 68009FE5 		ldr	r0, .L1110+28
 13119              	.LVL1485:
 13120 6e4c 68109FE5 		ldr	r1, .L1110+32
 13121 6e50 68209FE5 		ldr	r2, .L1110+36
 13122 6e54 FEFFFFEB 		bl	_txe_thread_create
 13123              	.LVL1486:
4837:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4838:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4839:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4840:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4841:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4842:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4843:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4844:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4845:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4846:../uvc.c      ****             );
4847:../uvc.c      ****     if (retThrdCreate != 0)
 13124              		.loc 1 4847 0
 13125 6e58 003050E2 		subs	r3, r0, #0
 13126 6e5c CCFFFF1A 		bne	.L1099
4848:../uvc.c      ****     {
4849:../uvc.c      ****         goto fatalErrorHandler;
4850:../uvc.c      ****     }
4851:../uvc.c      **** #if 1
4852:../uvc.c      ****     /* Create the I2C control command handling thread. */
4853:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 13127              		.loc 1 4853 0
 13128 6e60 00908DE5 		str	r9, [sp]
 13129 6e64 04708DE5 		str	r7, [sp, #4]
 13130 6e68 08408DE5 		str	r4, [sp, #8]
 13131 6e6c 0C408DE5 		str	r4, [sp, #12]
 13132 6e70 10308DE5 		str	r3, [sp, #16]
 13133 6e74 14508DE5 		str	r5, [sp, #20]
 13134 6e78 18808DE5 		str	r8, [sp, #24]
 13135 6e7c 40009FE5 		ldr	r0, .L1110+40
 13136              	.LVL1487:
 13137 6e80 40109FE5 		ldr	r1, .L1110+44
 13138 6e84 40209FE5 		ldr	r2, .L1110+48
 13139 6e88 FEFFFFEB 		bl	_txe_thread_create
 13140              	.LVL1488:
4854:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4855:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4856:../uvc.c      ****             0,                                          /* No input parameter to thread */
4857:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4858:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4859:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4860:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4861:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4862:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4863:../uvc.c      ****             );
4864:../uvc.c      ****     if (retThrdCreate != 0)
 13141              		.loc 1 4864 0
 13142 6e8c 000050E3 		cmp	r0, #0
 13143 6e90 BFFFFF1A 		bne	.L1099
4865:../uvc.c      ****     {
4866:../uvc.c      ****         goto fatalErrorHandler;
4867:../uvc.c      ****     }
4868:../uvc.c      **** #endif
4869:../uvc.c      **** 
4870:../uvc.c      ****     return;
4871:../uvc.c      **** 
4872:../uvc.c      **** fatalErrorHandler:
4873:../uvc.c      ****     /* Add custom recovery or debug actions here */
4874:../uvc.c      ****     /* Loop indefinitely */
4875:../uvc.c      ****     while (1);
4876:../uvc.c      **** }
 13144              		.loc 1 4876 0
 13145 6e94 40D08DE2 		add	sp, sp, #64
 13146              		@ sp needed
 13147 6e98 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 13148              	.LVL1489:
 13149              	.L1111:
 13150              		.align	2
 13151              	.L1110:
 13152 6e9c 00000000 		.word	cmdQuMux
 13153 6ea0 EC0F0000 		.word	.LC92
 13154 6ea4 00000000 		.word	cmdQu
 13155 6ea8 00000000 		.word	statQu
 13156 6eac A4010000 		.word	.LANCHOR0+420
 13157 6eb0 F80F0000 		.word	.LC93
 13158 6eb4 00000000 		.word	UVCAppThread_Entry
 13159 6eb8 4C020000 		.word	.LANCHOR0+588
 13160 6ebc 0C100000 		.word	.LC94
 13161 6ec0 00000000 		.word	UVCAppEP0Thread_Entry
 13162 6ec4 F4020000 		.word	.LANCHOR0+756
 13163 6ec8 24100000 		.word	.LC95
 13164 6ecc 00000000 		.word	I2cAppThread_Entry
 13165              		.cfi_endproc
 13166              	.LFE28:
 13168              		.section	.text.startup,"ax",%progbits
 13169              		.align	2
 13170              		.global	main
 13172              	main:
 13173              	.LFB29:
4877:../uvc.c      **** 
4878:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4879:../uvc.c      ****  * the ThreadX RTOS here.
4880:../uvc.c      ****  */
4881:../uvc.c      **** int
4882:../uvc.c      **** main (
4883:../uvc.c      ****         void)
4884:../uvc.c      **** {
 13174              		.loc 1 4884 0
 13175              		.cfi_startproc
 13176              		@ args = 0, pretend = 0, frame = 56
 13177              		@ frame_needed = 0, uses_anonymous_args = 0
 13178 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 13179              	.LCFI32:
 13180              		.cfi_def_cfa_offset 12
 13181              		.cfi_offset 4, -12
 13182              		.cfi_offset 5, -8
 13183              		.cfi_offset 14, -4
 13184 0004 3CD04DE2 		sub	sp, sp, #60
 13185              	.LCFI33:
 13186              		.cfi_def_cfa_offset 72
4885:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4886:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4887:../uvc.c      **** 
4888:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4889:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4890:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 13187              		.loc 1 4890 0
 13188 0008 0230A0E3 		mov	r3, #2
4891:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4892:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4893:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 13189              		.loc 1 4893 0
 13190 000c 0010A0E3 		mov	r1, #0
4894:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 13191              		.loc 1 4894 0
 13192 0010 0320A0E3 		mov	r2, #3
4889:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 13193              		.loc 1 4889 0
 13194 0014 0150A0E3 		mov	r5, #1
4895:../uvc.c      **** 
4896:../uvc.c      ****     /* Initialize the device */
4897:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 13195              		.loc 1 4897 0
 13196 0018 0D00A0E1 		mov	r0, sp
4889:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 13197              		.loc 1 4889 0
 13198 001c 00508DE5 		str	r5, [sp]
4890:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 13199              		.loc 1 4890 0
 13200 0020 0430CDE5 		strb	r3, [sp, #4]
4891:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 13201              		.loc 1 4891 0
 13202 0024 0530CDE5 		strb	r3, [sp, #5]
4892:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 13203              		.loc 1 4892 0
 13204 0028 0630CDE5 		strb	r3, [sp, #6]
4893:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 13205              		.loc 1 4893 0
 13206 002c 08108DE5 		str	r1, [sp, #8]
4894:../uvc.c      **** 
 13207              		.loc 1 4894 0
 13208 0030 0C20CDE5 		strb	r2, [sp, #12]
 13209              		.loc 1 4897 0
 13210 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 13211              	.LVL1490:
4898:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 13212              		.loc 1 4898 0
 13213 0038 004050E2 		subs	r4, r0, #0
 13214 003c 0000000A 		beq	.L1117
 13215              	.L1113:
 13216              	.L1114:
 13217 0040 FEFFFFEA 		b	.L1114
 13218              	.L1117:
4899:../uvc.c      ****     {
4900:../uvc.c      ****         goto handle_fatal_error;
4901:../uvc.c      ****     }
4902:../uvc.c      **** 
4903:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4904:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 13219              		.loc 1 4904 0
 13220 0044 0410A0E1 		mov	r1, r4
 13221 0048 0420A0E1 		mov	r2, r4
 13222 004c 0500A0E1 		mov	r0, r5
 13223              	.LVL1491:
 13224 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 13225              	.LVL1492:
4905:../uvc.c      **** 
4906:../uvc.c      ****     /* Configure the IO matrix for the device. */
4907:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4908:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4909:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4910:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4911:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4912:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4913:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4914:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4915:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4916:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4917:../uvc.c      **** 
4918:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 13226              		.loc 1 4918 0
 13227 0054 10008DE2 		add	r0, sp, #16
4908:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 13228              		.loc 1 4908 0
 13229 0058 2640CDE5 		strb	r4, [sp, #38]
4909:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 13230              		.loc 1 4909 0
 13231 005c 28408DE5 		str	r4, [sp, #40]
4910:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 13232              		.loc 1 4910 0
 13233 0060 2C408DE5 		str	r4, [sp, #44]
4911:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 13234              		.loc 1 4911 0
 13235 0064 30408DE5 		str	r4, [sp, #48]
4912:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 13236              		.loc 1 4912 0
 13237 0068 34408DE5 		str	r4, [sp, #52]
4915:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 13238              		.loc 1 4915 0
 13239 006c 1C408DE5 		str	r4, [sp, #28]
4916:../uvc.c      **** 
 13240              		.loc 1 4916 0
 13241 0070 20408DE5 		str	r4, [sp, #32]
4907:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 13242              		.loc 1 4907 0
 13243 0074 10508DE5 		str	r5, [sp, #16]
4913:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 13244              		.loc 1 4913 0
 13245 0078 14508DE5 		str	r5, [sp, #20]
4914:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 13246              		.loc 1 4914 0
 13247 007c 18508DE5 		str	r5, [sp, #24]
 13248              		.loc 1 4918 0
 13249 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 13250              	.LVL1493:
4919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 13251              		.loc 1 4919 0
 13252 0084 004050E2 		subs	r4, r0, #0
 13253 0088 ECFFFF1A 		bne	.L1113
4920:../uvc.c      ****     {
4921:../uvc.c      ****         goto handle_fatal_error;
4922:../uvc.c      ****     }
4923:../uvc.c      **** 
4924:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4925:../uvc.c      ****     CyU3PKernelEntry ();
 13254              		.loc 1 4925 0
 13255 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 13256              	.LVL1494:
4926:../uvc.c      **** 
4927:../uvc.c      ****     /* Dummy return to make the compiler happy */
4928:../uvc.c      ****     return 0;
4929:../uvc.c      **** 
4930:../uvc.c      **** handle_fatal_error:
4931:../uvc.c      ****     /* Cannot recover from this error. */
4932:../uvc.c      ****     while (1);
4933:../uvc.c      **** }
 13257              		.loc 1 4933 0
 13258 0090 0400A0E1 		mov	r0, r4
 13259 0094 3CD08DE2 		add	sp, sp, #60
 13260              		@ sp needed
 13261 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 13262              		.cfi_endproc
 13263              	.LFE29:
 13265              		.comm	I2CCmdTimer,44,4
 13266              		.comm	posTick,4,4
 13267              		.global	glUVCHeader
 13268              		.global	glProbeStilCtrl20
 13269              		.global	glProbeCtrl20
 13270              		.global	glProbeStilCtrl
 13271              		.global	glProbeCtrlFull
 13272              		.global	glProbeCtrl
 13273              		.comm	glDebugRspBuffer,4,4
 13274              		.comm	glDebugRspChannel,172,4
 13275              		.comm	glDebugCmdChannel,172,4
 13276              		.global	streamingStarted
 13277              		.global	streamingRecove
 13278              		.global	clearFeatureRqtReceived
 13279              		.global	usbSpeed
 13280              		.global	isUsbConnected
 13281              		.global	pbcpbak
 13282              		.global	pbcbak
 13283              		.global	pbbak
 13284              		.global	fbbak
 13285              		.global	pbc
 13286              		.global	pb
 13287              		.global	fb
 13288              		.comm	wLength,2,2
 13289              		.comm	wIndex,2,2
 13290              		.comm	wValue,2,2
 13291              		.comm	bRequest,1,1
 13292              		.comm	bmReqType,1,1
 13293              		.comm	imgHdMux,56,4
 13294              		.comm	timMux,56,4
 13295              		.comm	staQuMux,56,4
 13296              		.comm	cmdQuMux,56,4
 13297              		.comm	statQu,32,4
 13298              		.comm	cmdQu,32,4
 13299              		.global	testSnap
 13300              		.global	snapButFlag
 13301              		.comm	glInterStaBuffer,4,4
 13302              		.comm	glChHandleInterStat,172,4
 13303              		.comm	glChHandleStillStream,232,4
 13304              		.comm	glChHandleUVCStream,232,4
 13305              		.global	CyFxGpifConfig_usb2
 13306              		.global	CyFxGpifRegValue_usb2
 13307              		.global	CyFxGpifWavedataPosition_usb2
 13308              		.global	CyFxGpifWavedata_usb2
 13309              		.global	CyFxGpifTransition_usb2
 13310              		.global	CyFxGpifConfig
 13311              		.global	CyFxGpifRegValue
 13312              		.global	CyFxGpifWavedataPosition
 13313              		.global	CyFxGpifWavedata
 13314              		.global	CyFxGpifTransition
 13315              		.section	.rodata
 13316              		.align	2
 13317              		.set	.LANCHOR2,. + 0
 13320              	ShutSp:
 13321 0000 3582     		.short	-32203
 13322 0002 1B41     		.short	16667
 13323 0004 8D20     		.short	8333
 13324 0006 A00F     		.short	4000
 13325 0008 D007     		.short	2000
 13326 000a E803     		.short	1000
 13327 000c F401     		.short	500
 13328 000e C800     		.short	200
 13329 0010 6400     		.short	100
 13330 0012 0A00     		.short	10
 13331 0014 0000     		.short	0
 13332 0016 00000000 		.space	10
 13332      00000000 
 13332      0000
 13335              	CyFxGpifConfig:
 13336 0020 0F00     		.short	15
 13337 0022 0000     		.space	2
 13338 0024 00000000 		.word	CyFxGpifWavedata
 13339 0028 00000000 		.word	CyFxGpifWavedataPosition
 13340 002c 0500     		.short	5
 13341 002e 0000     		.space	2
 13342 0030 00000000 		.word	CyFxGpifTransition
 13343 0034 4C00     		.short	76
 13344 0036 0000     		.space	2
 13345 0038 00000000 		.word	CyFxGpifRegValue
 13348              	CyFxGpifConfig_usb2:
 13349 003c 9300     		.short	147
 13350 003e 0000     		.space	2
 13351 0040 00000000 		.word	CyFxGpifWavedata_usb2
 13352 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 13353 0048 0800     		.short	8
 13354 004a 0000     		.space	2
 13355 004c 00000000 		.word	CyFxGpifTransition_usb2
 13356 0050 4C00     		.short	76
 13357 0052 0000     		.space	2
 13358 0054 00000000 		.word	CyFxGpifRegValue_usb2
 13359              		.data
 13360              		.align	2
 13361              		.set	.LANCHOR1,. + 0
 13364              	ExUCtrlParArry:
 13365 0000 00       		.byte	0
 13366 0001 00       		.byte	0
 13367 0002 04       		.byte	4
 13368 0003 01       		.byte	1
 13369 0004 00       		.byte	0
 13370 0005 38       		.byte	56
 13371 0006 01       		.byte	1
 13372 0007 01       		.byte	1
 13373 0008 00       		.byte	0
 13374 0009 03       		.byte	3
 13375 000a 00       		.byte	0
 13376 000b 4E       		.byte	78
 13377 000c 00       		.byte	0
 13378 000d 4E       		.byte	78
 13379 000e 00       		.byte	0
 13380 000f 30       		.byte	48
 13381 0010 01       		.byte	1
 13382 0011 00       		.byte	0
 13383 0012 00       		.byte	0
 13384 0013 00000000 		.space	5
 13384      00
 13385 0018 00       		.byte	0
 13386 0019 00       		.byte	0
 13387 001a 01       		.byte	1
 13388 001b 00       		.byte	0
 13389 001c 00       		.byte	0
 13390 001d 00       		.byte	0
 13391 001e 00       		.byte	0
 13392 001f 01       		.byte	1
 13393 0020 00       		.byte	0
 13394 0021 03       		.byte	3
 13395 0022 00       		.byte	0
 13396 0023 00       		.byte	0
 13397 0024 00       		.byte	0
 13398 0025 00       		.byte	0
 13399 0026 00       		.byte	0
 13400 0027 30       		.byte	48
 13401 0028 01       		.byte	1
 13402 0029 00       		.byte	0
 13403 002a 00       		.byte	0
 13404 002b 00000000 		.space	5
 13404      00
 13405 0030 00       		.byte	0
 13406 0031 00       		.byte	0
 13407 0032 02       		.byte	2
 13408 0033 00       		.byte	0
 13409 0034 00       		.byte	0
 13410 0035 FF       		.byte	-1
 13411 0036 00       		.byte	0
 13412 0037 01       		.byte	1
 13413 0038 00       		.byte	0
 13414 0039 03       		.byte	3
 13415 003a 00       		.byte	0
 13416 003b 01       		.byte	1
 13417 003c 00       		.byte	0
 13418 003d 00       		.byte	0
 13419 003e 00       		.byte	0
 13420 003f 30       		.byte	48
 13421 0040 01       		.byte	1
 13422 0041 01       		.byte	1
 13423 0042 00       		.byte	0
 13424 0043 00000000 		.space	5
 13424      00
 13425 0048 00       		.byte	0
 13426 0049 00       		.byte	0
 13427 004a 02       		.byte	2
 13428 004b 00       		.byte	0
 13429 004c 00       		.byte	0
 13430 004d 00       		.byte	0
 13431 004e 00       		.byte	0
 13432 004f 00       		.byte	0
 13433 0050 00       		.byte	0
 13434 0051 03       		.byte	3
 13435 0052 00       		.byte	0
 13436 0053 00       		.byte	0
 13437 0054 00       		.byte	0
 13438 0055 00       		.byte	0
 13439 0056 00       		.byte	0
 13440 0057 30       		.byte	48
 13441 0058 01       		.byte	1
 13442 0059 01       		.byte	1
 13443 005a 00       		.byte	0
 13444 005b 00000000 		.space	5
 13444      00
 13445 0060 13       		.byte	19
 13446 0061 14       		.byte	20
 13447 0062 02       		.byte	2
 13448 0063 00       		.byte	0
 13449 0064 00       		.byte	0
 13450 0065 FF       		.byte	-1
 13451 0066 FF       		.byte	-1
 13452 0067 01       		.byte	1
 13453 0068 00       		.byte	0
 13454 0069 03       		.byte	3
 13455 006a 00       		.byte	0
 13456 006b 66       		.byte	102
 13457 006c 66       		.byte	102
 13458 006d 66       		.byte	102
 13459 006e 66       		.byte	102
 13460 006f 30       		.byte	48
 13461 0070 01       		.byte	1
 13462 0071 00       		.byte	0
 13463 0072 00       		.byte	0
 13464 0073 00000000 		.space	5
 13464      00
 13465 0078 11       		.byte	17
 13466 0079 00       		.byte	0
 13467 007a 02       		.byte	2
 13468 007b 01       		.byte	1
 13469 007c 00       		.byte	0
 13470 007d 03       		.byte	3
 13471 007e 00       		.byte	0
 13472 007f 01       		.byte	1
 13473 0080 00       		.byte	0
 13474 0081 03       		.byte	3
 13475 0082 00       		.byte	0
 13476 0083 80       		.byte	-128
 13477 0084 00       		.byte	0
 13478 0085 80       		.byte	-128
 13479 0086 00       		.byte	0
 13480 0087 30       		.byte	48
 13481 0088 01       		.byte	1
 13482 0089 01       		.byte	1
 13483 008a 00       		.byte	0
 13484 008b 00000000 		.space	5
 13484      00
 13485 0090 10       		.byte	16
 13486 0091 00       		.byte	0
 13487 0092 01       		.byte	1
 13488 0093 01       		.byte	1
 13489 0094 00       		.byte	0
 13490 0095 02       		.byte	2
 13491 0096 00       		.byte	0
 13492 0097 01       		.byte	1
 13493 0098 00       		.byte	0
 13494 0099 03       		.byte	3
 13495 009a 00       		.byte	0
 13496 009b 00       		.byte	0
 13497 009c 00       		.byte	0
 13498 009d 00       		.byte	0
 13499 009e 00       		.byte	0
 13500 009f 30       		.byte	48
 13501 00a0 01       		.byte	1
 13502 00a1 01       		.byte	1
 13503 00a2 00       		.byte	0
 13504 00a3 00000000 		.space	5
 13504      00
 13505 00a8 00       		.byte	0
 13506 00a9 00       		.byte	0
 13507 00aa 04       		.byte	4
 13508 00ab 01       		.byte	1
 13509 00ac 00       		.byte	0
 13510 00ad 38       		.byte	56
 13511 00ae 01       		.byte	1
 13512 00af 01       		.byte	1
 13513 00b0 00       		.byte	0
 13514 00b1 03       		.byte	3
 13515 00b2 00       		.byte	0
 13516 00b3 4E       		.byte	78
 13517 00b4 00       		.byte	0
 13518 00b5 4E       		.byte	78
 13519 00b6 00       		.byte	0
 13520 00b7 30       		.byte	48
 13521 00b8 01       		.byte	1
 13522 00b9 00       		.byte	0
 13523 00ba 00       		.byte	0
 13524 00bb 00000000 		.space	5
 13524      00
 13525 00c0 00       		.byte	0
 13526 00c1 00       		.byte	0
 13527 00c2 01       		.byte	1
 13528 00c3 00       		.byte	0
 13529 00c4 00       		.byte	0
 13530 00c5 00       		.byte	0
 13531 00c6 00       		.byte	0
 13532 00c7 01       		.byte	1
 13533 00c8 00       		.byte	0
 13534 00c9 03       		.byte	3
 13535 00ca 00       		.byte	0
 13536 00cb 00       		.byte	0
 13537 00cc 00       		.byte	0
 13538 00cd 00       		.byte	0
 13539 00ce 00       		.byte	0
 13540 00cf 30       		.byte	48
 13541 00d0 01       		.byte	1
 13542 00d1 00       		.byte	0
 13543 00d2 00       		.byte	0
 13544 00d3 00000000 		.space	5
 13544      00
 13545 00d8 00       		.byte	0
 13546 00d9 00       		.byte	0
 13547 00da 02       		.byte	2
 13548 00db 00       		.byte	0
 13549 00dc 00       		.byte	0
 13550 00dd 05       		.byte	5
 13551 00de 00       		.byte	0
 13552 00df 01       		.byte	1
 13553 00e0 00       		.byte	0
 13554 00e1 03       		.byte	3
 13555 00e2 00       		.byte	0
 13556 00e3 00       		.byte	0
 13557 00e4 00       		.byte	0
 13558 00e5 00       		.byte	0
 13559 00e6 00       		.byte	0
 13560 00e7 30       		.byte	48
 13561 00e8 01       		.byte	1
 13562 00e9 00       		.byte	0
 13563 00ea 00       		.byte	0
 13564 00eb 00000000 		.space	5
 13564      00
 13565 00f0 00       		.byte	0
 13566 00f1 00       		.byte	0
 13567 00f2 03       		.byte	3
 13568 00f3 00       		.byte	0
 13569 00f4 00       		.byte	0
 13570 00f5 0A       		.byte	10
 13571 00f6 00       		.byte	0
 13572 00f7 01       		.byte	1
 13573 00f8 00       		.byte	0
 13574 00f9 03       		.byte	3
 13575 00fa 00       		.byte	0
 13576 00fb 00       		.byte	0
 13577 00fc 00       		.byte	0
 13578 00fd 00       		.byte	0
 13579 00fe 00       		.byte	0
 13580 00ff 30       		.byte	48
 13581 0100 01       		.byte	1
 13582 0101 00       		.byte	0
 13583 0102 00       		.byte	0
 13584 0103 00000000 		.space	5
 13584      00
 13585 0108 00       		.byte	0
 13586 0109 00       		.byte	0
 13587 010a 02       		.byte	2
 13588 010b 00       		.byte	0
 13589 010c 00       		.byte	0
 13590 010d 40       		.byte	64
 13591 010e 00       		.byte	0
 13592 010f 01       		.byte	1
 13593 0110 00       		.byte	0
 13594 0111 03       		.byte	3
 13595 0112 00       		.byte	0
 13596 0113 0F       		.byte	15
 13597 0114 11       		.byte	17
 13598 0115 00       		.byte	0
 13599 0116 00       		.byte	0
 13600 0117 30       		.byte	48
 13601 0118 01       		.byte	1
 13602 0119 00       		.byte	0
 13603 011a 00       		.byte	0
 13604 011b 00000000 		.space	5
 13604      00
 13605 0120 00       		.byte	0
 13606 0121 00       		.byte	0
 13607 0122 02       		.byte	2
 13608 0123 00       		.byte	0
 13609 0124 00       		.byte	0
 13610 0125 64       		.byte	100
 13611 0126 00       		.byte	0
 13612 0127 01       		.byte	1
 13613 0128 00       		.byte	0
 13614 0129 03       		.byte	3
 13615 012a 00       		.byte	0
 13616 012b 00       		.byte	0
 13617 012c 00       		.byte	0
 13618 012d 00       		.byte	0
 13619 012e 00       		.byte	0
 13620 012f 30       		.byte	48
 13621 0130 01       		.byte	1
 13622 0131 00       		.byte	0
 13623 0132 00       		.byte	0
 13624 0133 00000000 		.space	5
 13624      00
 13625 0138 00       		.byte	0
 13626 0139 00       		.byte	0
 13627 013a 02       		.byte	2
 13628 013b 00       		.byte	0
 13629 013c 00       		.byte	0
 13630 013d 64       		.byte	100
 13631 013e 00       		.byte	0
 13632 013f 01       		.byte	1
 13633 0140 00       		.byte	0
 13634 0141 03       		.byte	3
 13635 0142 00       		.byte	0
 13636 0143 00       		.byte	0
 13637 0144 00       		.byte	0
 13638 0145 00       		.byte	0
 13639 0146 00       		.byte	0
 13640 0147 30       		.byte	48
 13641 0148 01       		.byte	1
 13642 0149 00       		.byte	0
 13643 014a 00       		.byte	0
 13644 014b 00000000 		.space	5
 13644      00
 13645 0150 00       		.byte	0
 13646 0151 00       		.byte	0
 13647 0152 02       		.byte	2
 13648 0153 00       		.byte	0
 13649 0154 00       		.byte	0
 13650 0155 64       		.byte	100
 13651 0156 00       		.byte	0
 13652 0157 01       		.byte	1
 13653 0158 00       		.byte	0
 13654 0159 03       		.byte	3
 13655 015a 00       		.byte	0
 13656 015b 00       		.byte	0
 13657 015c 00       		.byte	0
 13658 015d 00       		.byte	0
 13659 015e 00       		.byte	0
 13660 015f 30       		.byte	48
 13661 0160 01       		.byte	1
 13662 0161 00       		.byte	0
 13663 0162 00       		.byte	0
 13664 0163 00000000 		.space	5
 13664      00
 13665 0168 00       		.byte	0
 13666 0169 00       		.byte	0
 13667 016a 02       		.byte	2
 13668 016b 00       		.byte	0
 13669 016c 00       		.byte	0
 13670 016d 64       		.byte	100
 13671 016e 00       		.byte	0
 13672 016f 01       		.byte	1
 13673 0170 00       		.byte	0
 13674 0171 03       		.byte	3
 13675 0172 00       		.byte	0
 13676 0173 00       		.byte	0
 13677 0174 00       		.byte	0
 13678 0175 00       		.byte	0
 13679 0176 00       		.byte	0
 13680 0177 30       		.byte	48
 13681 0178 01       		.byte	1
 13682 0179 00       		.byte	0
 13683 017a 00       		.byte	0
 13684 017b 00000000 		.space	5
 13684      00
 13687              	CtrlParArry:
 13688 0180 10       		.byte	16
 13689 0181 10       		.byte	16
 13690 0182 02       		.byte	2
 13691 0183 00       		.byte	0
 13692 0184 00       		.byte	0
 13693 0185 03       		.byte	3
 13694 0186 00       		.byte	0
 13695 0187 01       		.byte	1
 13696 0188 00       		.byte	0
 13697 0189 03       		.byte	3
 13698 018a 00       		.byte	0
 13699 018b 03       		.byte	3
 13700 018c 00       		.byte	0
 13701 018d 03       		.byte	3
 13702 018e 00       		.byte	0
 13703 018f 30       		.byte	48
 13704 0190 01       		.byte	1
 13705 0191 00       		.byte	0
 13706 0192 00       		.byte	0
 13707 0193 00000000 		.space	5
 13707      00
 13708 0198 15       		.byte	21
 13709 0199 15       		.byte	21
 13710 019a 02       		.byte	2
 13711 019b 00       		.byte	0
 13712 019c 00       		.byte	0
 13713 019d FF       		.byte	-1
 13714 019e 00       		.byte	0
 13715 019f 01       		.byte	1
 13716 01a0 00       		.byte	0
 13717 01a1 03       		.byte	3
 13718 01a2 00       		.byte	0
 13719 01a3 76       		.byte	118
 13720 01a4 00       		.byte	0
 13721 01a5 76       		.byte	118
 13722 01a6 C7       		.byte	-57
 13723 01a7 30       		.byte	48
 13724 01a8 01       		.byte	1
 13725 01a9 01       		.byte	1
 13726 01aa 00       		.byte	0
 13727 01ab 00000000 		.space	5
 13727      00
 13728 01b0 04       		.byte	4
 13729 01b1 04       		.byte	4
 13730 01b2 02       		.byte	2
 13731 01b3 00       		.byte	0
 13732 01b4 00       		.byte	0
 13733 01b5 FF       		.byte	-1
 13734 01b6 00       		.byte	0
 13735 01b7 01       		.byte	1
 13736 01b8 00       		.byte	0
 13737 01b9 03       		.byte	3
 13738 01ba 00       		.byte	0
 13739 01bb 70       		.byte	112
 13740 01bc 00       		.byte	0
 13741 01bd 70       		.byte	112
 13742 01be 00       		.byte	0
 13743 01bf 30       		.byte	48
 13744 01c0 01       		.byte	1
 13745 01c1 01       		.byte	1
 13746 01c2 00       		.byte	0
 13747 01c3 00000000 		.space	5
 13747      00
 13748 01c8 00       		.byte	0
 13749 01c9 00       		.byte	0
 13750 01ca 02       		.byte	2
 13751 01cb 00       		.byte	0
 13752 01cc 00       		.byte	0
 13753 01cd 64       		.byte	100
 13754 01ce 00       		.byte	0
 13755 01cf 01       		.byte	1
 13756 01d0 00       		.byte	0
 13757 01d1 03       		.byte	3
 13758 01d2 00       		.byte	0
 13759 01d3 00       		.byte	0
 13760 01d4 00       		.byte	0
 13761 01d5 00       		.byte	0
 13762 01d6 00       		.byte	0
 13763 01d7 30       		.byte	48
 13764 01d8 01       		.byte	1
 13765 01d9 00       		.byte	0
 13766 01da 00       		.byte	0
 13767 01db 00000000 		.space	5
 13767      00
 13768 01e0 07       		.byte	7
 13769 01e1 07       		.byte	7
 13770 01e2 02       		.byte	2
 13771 01e3 00       		.byte	0
 13772 01e4 00       		.byte	0
 13773 01e5 01       		.byte	1
 13774 01e6 00       		.byte	0
 13775 01e7 01       		.byte	1
 13776 01e8 00       		.byte	0
 13777 01e9 03       		.byte	3
 13778 01ea 00       		.byte	0
 13779 01eb 01       		.byte	1
 13780 01ec 00       		.byte	0
 13781 01ed 01       		.byte	1
 13782 01ee 00       		.byte	0
 13783 01ef 30       		.byte	48
 13784 01f0 01       		.byte	1
 13785 01f1 00       		.byte	0
 13786 01f2 00       		.byte	0
 13787 01f3 00000000 		.space	5
 13787      00
 13788 01f8 DF       		.byte	-33
 13789 01f9 E1       		.byte	-31
 13790 01fa 02       		.byte	2
 13791 01fb 00       		.byte	0
 13792 01fc 00       		.byte	0
 13793 01fd FF       		.byte	-1
 13794 01fe 00       		.byte	0
 13795 01ff 01       		.byte	1
 13796 0200 00       		.byte	0
 13797 0201 03       		.byte	3
 13798 0202 00       		.byte	0
 13799 0203 80       		.byte	-128
 13800 0204 00       		.byte	0
 13801 0205 00       		.byte	0
 13802 0206 00       		.byte	0
 13803 0207 C6       		.byte	-58
 13804 0208 01       		.byte	1
 13805 0209 01       		.byte	1
 13806 020a 00       		.byte	0
 13807 020b 00000000 		.space	5
 13807      00
 13808 0210 85       		.byte	-123
 13809 0211 86       		.byte	-122
 13810 0212 02       		.byte	2
 13811 0213 00       		.byte	0
 13812 0214 00       		.byte	0
 13813 0215 64       		.byte	100
 13814 0216 00       		.byte	0
 13815 0217 01       		.byte	1
 13816 0218 00       		.byte	0
 13817 0219 03       		.byte	3
 13818 021a 00       		.byte	0
 13819 021b 32       		.byte	50
 13820 021c 00       		.byte	0
 13821 021d 32       		.byte	50
 13822 021e 00       		.byte	0
 13823 021f F2       		.byte	-14
 13824 0220 01       		.byte	1
 13825 0221 01       		.byte	1
 13826 0222 00       		.byte	0
 13827 0223 00000000 		.space	5
 13827      00
 13828 0228 06       		.byte	6
 13829 0229 06       		.byte	6
 13830 022a 02       		.byte	2
 13831 022b 00       		.byte	0
 13832 022c 00       		.byte	0
 13833 022d FF       		.byte	-1
 13834 022e 00       		.byte	0
 13835 022f 01       		.byte	1
 13836 0230 00       		.byte	0
 13837 0231 03       		.byte	3
 13838 0232 00       		.byte	0
 13839 0233 20       		.byte	32
 13840 0234 00       		.byte	0
 13841 0235 20       		.byte	32
 13842 0236 00       		.byte	0
 13843 0237 30       		.byte	48
 13844 0238 01       		.byte	1
 13845 0239 01       		.byte	1
 13846 023a 00       		.byte	0
 13847 023b 00000000 		.space	5
 13847      00
 13848 0240 00       		.byte	0
 13849 0241 00       		.byte	0
 13850 0242 02       		.byte	2
 13851 0243 00       		.byte	0
 13852 0244 00       		.byte	0
 13853 0245 64       		.byte	100
 13854 0246 00       		.byte	0
 13855 0247 01       		.byte	1
 13856 0248 00       		.byte	0
 13857 0249 03       		.byte	3
 13858 024a 00       		.byte	0
 13859 024b 00       		.byte	0
 13860 024c 00       		.byte	0
 13861 024d 00       		.byte	0
 13862 024e 00       		.byte	0
 13863 024f 30       		.byte	48
 13864 0250 01       		.byte	1
 13865 0251 00       		.byte	0
 13866 0252 00       		.byte	0
 13867 0253 00000000 		.space	5
 13867      00
 13868 0258 08       		.byte	8
 13869 0259 08       		.byte	8
 13870 025a 02       		.byte	2
 13871 025b 00       		.byte	0
 13872 025c 00       		.byte	0
 13873 025d 05       		.byte	5
 13874 025e 00       		.byte	0
 13875 025f 01       		.byte	1
 13876 0260 00       		.byte	0
 13877 0261 03       		.byte	3
 13878 0262 00       		.byte	0
 13879 0263 00       		.byte	0
 13880 0264 00       		.byte	0
 13881 0265 00       		.byte	0
 13882 0266 00       		.byte	0
 13883 0267 30       		.byte	48
 13884 0268 01       		.byte	1
 13885 0269 00       		.byte	0
 13886 026a 00       		.byte	0
 13887 026b 00000000 		.space	5
 13887      00
 13888 0270 00       		.byte	0
 13889 0271 00       		.byte	0
 13890 0272 02       		.byte	2
 13891 0273 00       		.byte	0
 13892 0274 00       		.byte	0
 13893 0275 40       		.byte	64
 13894 0276 00       		.byte	0
 13895 0277 01       		.byte	1
 13896 0278 00       		.byte	0
 13897 0279 03       		.byte	3
 13898 027a 00       		.byte	0
 13899 027b 00       		.byte	0
 13900 027c 00       		.byte	0
 13901 027d 00       		.byte	0
 13902 027e 00       		.byte	0
 13903 027f 30       		.byte	48
 13904 0280 01       		.byte	1
 13905 0281 00       		.byte	0
 13906 0282 00       		.byte	0
 13907 0283 00000000 		.space	5
 13907      00
 13908 0288 09       		.byte	9
 13909 0289 0A       		.byte	10
 13910 028a 04       		.byte	4
 13911 028b 00       		.byte	0
 13912 028c 00       		.byte	0
 13913 028d 40       		.byte	64
 13914 028e 00       		.byte	0
 13915 028f 01       		.byte	1
 13916 0290 00       		.byte	0
 13917 0291 03       		.byte	3
 13918 0292 00       		.byte	0
 13919 0293 20       		.byte	32
 13920 0294 38       		.byte	56
 13921 0295 20       		.byte	32
 13922 0296 38       		.byte	56
 13923 0297 30       		.byte	48
 13924 0298 01       		.byte	1
 13925 0299 00       		.byte	0
 13926 029a 00       		.byte	0
 13927 029b 00000000 		.space	5
 13927      00
 13928 02a0 00       		.byte	0
 13929 02a1 00       		.byte	0
 13930 02a2 02       		.byte	2
 13931 02a3 00       		.byte	0
 13932 02a4 00       		.byte	0
 13933 02a5 64       		.byte	100
 13934 02a6 00       		.byte	0
 13935 02a7 01       		.byte	1
 13936 02a8 00       		.byte	0
 13937 02a9 03       		.byte	3
 13938 02aa 00       		.byte	0
 13939 02ab 00       		.byte	0
 13940 02ac 00       		.byte	0
 13941 02ad 00       		.byte	0
 13942 02ae 00       		.byte	0
 13943 02af 30       		.byte	48
 13944 02b0 01       		.byte	1
 13945 02b1 00       		.byte	0
 13946 02b2 00       		.byte	0
 13947 02b3 00000000 		.space	5
 13947      00
 13948 02b8 00       		.byte	0
 13949 02b9 00       		.byte	0
 13950 02ba 02       		.byte	2
 13951 02bb 00       		.byte	0
 13952 02bc 00       		.byte	0
 13953 02bd 64       		.byte	100
 13954 02be 00       		.byte	0
 13955 02bf 01       		.byte	1
 13956 02c0 00       		.byte	0
 13957 02c1 03       		.byte	3
 13958 02c2 00       		.byte	0
 13959 02c3 00       		.byte	0
 13960 02c4 00       		.byte	0
 13961 02c5 00       		.byte	0
 13962 02c6 00       		.byte	0
 13963 02c7 30       		.byte	48
 13964 02c8 01       		.byte	1
 13965 02c9 00       		.byte	0
 13966 02ca 00       		.byte	0
 13967 02cb 00000000 		.space	5
 13967      00
 13968 02d0 2A       		.byte	42
 13969 02d1 2A       		.byte	42
 13970 02d2 02       		.byte	2
 13971 02d3 00       		.byte	0
 13972 02d4 00       		.byte	0
 13973 02d5 1B       		.byte	27
 13974 02d6 00       		.byte	0
 13975 02d7 01       		.byte	1
 13976 02d8 00       		.byte	0
 13977 02d9 03       		.byte	3
 13978 02da 00       		.byte	0
 13979 02db 00       		.byte	0
 13980 02dc 00       		.byte	0
 13981 02dd 00       		.byte	0
 13982 02de 00       		.byte	0
 13983 02df 30       		.byte	48
 13984 02e0 01       		.byte	1
 13985 02e1 00       		.byte	0
 13986 02e2 00       		.byte	0
 13987 02e3 00000000 		.space	5
 13987      00
 13988 02e8 00       		.byte	0
 13989 02e9 00       		.byte	0
 13990 02ea 02       		.byte	2
 13991 02eb 00       		.byte	0
 13992 02ec 00       		.byte	0
 13993 02ed 64       		.byte	100
 13994 02ee 00       		.byte	0
 13995 02ef 01       		.byte	1
 13996 02f0 00       		.byte	0
 13997 02f1 03       		.byte	3
 13998 02f2 00       		.byte	0
 13999 02f3 00       		.byte	0
 14000 02f4 00       		.byte	0
 14001 02f5 00       		.byte	0
 14002 02f6 00       		.byte	0
 14003 02f7 30       		.byte	48
 14004 02f8 01       		.byte	1
 14005 02f9 00       		.byte	0
 14006 02fa 00       		.byte	0
 14007 02fb 00000000 		.space	5
 14007      00
 14008 0300 00       		.byte	0
 14009 0301 00       		.byte	0
 14010 0302 02       		.byte	2
 14011 0303 00       		.byte	0
 14012 0304 00       		.byte	0
 14013 0305 12       		.byte	18
 14014 0306 00       		.byte	0
 14015 0307 01       		.byte	1
 14016 0308 00       		.byte	0
 14017 0309 03       		.byte	3
 14018 030a 00       		.byte	0
 14019 030b 00       		.byte	0
 14020 030c 00       		.byte	0
 14021 030d 00       		.byte	0
 14022 030e 00       		.byte	0
 14023 030f 30       		.byte	48
 14024 0310 01       		.byte	1
 14025 0311 00       		.byte	0
 14026 0312 00       		.byte	0
 14027 0313 00000000 		.space	5
 14027      00
 14028 0318 01       		.byte	1
 14029 0319 01       		.byte	1
 14030 031a 02       		.byte	2
 14031 031b 00       		.byte	0
 14032 031c 00       		.byte	0
 14033 031d 09       		.byte	9
 14034 031e 00       		.byte	0
 14035 031f 01       		.byte	1
 14036 0320 00       		.byte	0
 14037 0321 03       		.byte	3
 14038 0322 00       		.byte	0
 14039 0323 00       		.byte	0
 14040 0324 00       		.byte	0
 14041 0325 01       		.byte	1
 14042 0326 00       		.byte	0
 14043 0327 30       		.byte	48
 14044 0328 01       		.byte	1
 14045 0329 00       		.byte	0
 14046 032a 00       		.byte	0
 14047 032b 00000000 		.space	5
 14047      00
 14048 0330 05       		.byte	5
 14049 0331 05       		.byte	5
 14050 0332 02       		.byte	2
 14051 0333 00       		.byte	0
 14052 0334 00       		.byte	0
 14053 0335 03       		.byte	3
 14054 0336 00       		.byte	0
 14055 0337 01       		.byte	1
 14056 0338 00       		.byte	0
 14057 0339 03       		.byte	3
 14058 033a 00       		.byte	0
 14059 033b 00       		.byte	0
 14060 033c 00       		.byte	0
 14061 033d 00       		.byte	0
 14062 033e 00       		.byte	0
 14063 033f 30       		.byte	48
 14064 0340 01       		.byte	1
 14065 0341 00       		.byte	0
 14066 0342 00       		.byte	0
 14067 0343 00000000 		.space	5
 14067      00
 14068 0348 18       		.byte	24
 14069 0349 18       		.byte	24
 14070 034a 02       		.byte	2
 14071 034b 00       		.byte	0
 14072 034c 00       		.byte	0
 14073 034d 01       		.byte	1
 14074 034e 00       		.byte	0
 14075 034f 01       		.byte	1
 14076 0350 00       		.byte	0
 14077 0351 03       		.byte	3
 14078 0352 00       		.byte	0
 14079 0353 00       		.byte	0
 14080 0354 00       		.byte	0
 14081 0355 00       		.byte	0
 14082 0356 00       		.byte	0
 14083 0357 30       		.byte	48
 14084 0358 01       		.byte	1
 14085 0359 00       		.byte	0
 14086 035a 00       		.byte	0
 14087 035b 00000000 		.space	5
 14087      00
 14088 0360 19       		.byte	25
 14089 0361 19       		.byte	25
 14090 0362 01       		.byte	1
 14091 0363 00       		.byte	0
 14092 0364 00       		.byte	0
 14093 0365 40       		.byte	64
 14094 0366 00       		.byte	0
 14095 0367 01       		.byte	1
 14096 0368 00       		.byte	0
 14097 0369 03       		.byte	3
 14098 036a 00       		.byte	0
 14099 036b 20       		.byte	32
 14100 036c 00       		.byte	0
 14101 036d 20       		.byte	32
 14102 036e 00       		.byte	0
 14103 036f 30       		.byte	48
 14104 0370 01       		.byte	1
 14105 0371 00       		.byte	0
 14106 0372 00       		.byte	0
 14107 0373 00000000 		.space	5
 14107      00
 14108 0378 20       		.byte	32
 14109 0379 20       		.byte	32
 14110 037a 02       		.byte	2
 14111 037b 00       		.byte	0
 14112 037c 00       		.byte	0
 14113 037d 02       		.byte	2
 14114 037e 00       		.byte	0
 14115 037f 01       		.byte	1
 14116 0380 00       		.byte	0
 14117 0381 03       		.byte	3
 14118 0382 00       		.byte	0
 14119 0383 00       		.byte	0
 14120 0384 00       		.byte	0
 14121 0385 00       		.byte	0
 14122 0386 00       		.byte	0
 14123 0387 30       		.byte	48
 14124 0388 01       		.byte	1
 14125 0389 00       		.byte	0
 14126 038a 00       		.byte	0
 14127 038b 00000000 		.space	5
 14127      00
 14128 0390 22       		.byte	34
 14129 0391 22       		.byte	34
 14130 0392 02       		.byte	2
 14131 0393 00       		.byte	0
 14132 0394 00       		.byte	0
 14133 0395 3F       		.byte	63
 14134 0396 00       		.byte	0
 14135 0397 01       		.byte	1
 14136 0398 00       		.byte	0
 14137 0399 03       		.byte	3
 14138 039a 00       		.byte	0
 14139 039b 00       		.byte	0
 14140 039c 00       		.byte	0
 14141 039d 00       		.byte	0
 14142 039e 00       		.byte	0
 14143 039f 30       		.byte	48
 14144 03a0 01       		.byte	1
 14145 03a1 00       		.byte	0
 14146 03a2 00       		.byte	0
 14147 03a3 00000000 		.space	5
 14147      00
 14148 03a8 23       		.byte	35
 14149 03a9 23       		.byte	35
 14150 03aa 02       		.byte	2
 14151 03ab 00       		.byte	0
 14152 03ac 00       		.byte	0
 14153 03ad 64       		.byte	100
 14154 03ae 00       		.byte	0
 14155 03af 01       		.byte	1
 14156 03b0 00       		.byte	0
 14157 03b1 03       		.byte	3
 14158 03b2 00       		.byte	0
 14159 03b3 10       		.byte	16
 14160 03b4 00       		.byte	0
 14161 03b5 10       		.byte	16
 14162 03b6 00       		.byte	0
 14163 03b7 30       		.byte	48
 14164 03b8 01       		.byte	1
 14165 03b9 00       		.byte	0
 14166 03ba 00       		.byte	0
 14167 03bb 00000000 		.space	5
 14167      00
 14168 03c0 24       		.byte	36
 14169 03c1 24       		.byte	36
 14170 03c2 02       		.byte	2
 14171 03c3 00       		.byte	0
 14172 03c4 00       		.byte	0
 14173 03c5 64       		.byte	100
 14174 03c6 00       		.byte	0
 14175 03c7 01       		.byte	1
 14176 03c8 00       		.byte	0
 14177 03c9 03       		.byte	3
 14178 03ca 00       		.byte	0
 14179 03cb 10       		.byte	16
 14180 03cc 00       		.byte	0
 14181 03cd 10       		.byte	16
 14182 03ce 00       		.byte	0
 14183 03cf 30       		.byte	48
 14184 03d0 01       		.byte	1
 14185 03d1 00       		.byte	0
 14186 03d2 00       		.byte	0
 14187 03d3 00000000 		.space	5
 14187      00
 14188 03d8 02       		.byte	2
 14189 03d9 03       		.byte	3
 14190 03da 04       		.byte	4
 14191 03db 00       		.byte	0
 14192 03dc 00       		.byte	0
 14193 03dd 7F       		.byte	127
 14194 03de 00       		.byte	0
 14195 03df 01       		.byte	1
 14196 03e0 00       		.byte	0
 14197 03e1 03       		.byte	3
 14198 03e2 00       		.byte	0
 14199 03e3 00       		.byte	0
 14200 03e4 20       		.byte	32
 14201 03e5 00       		.byte	0
 14202 03e6 20       		.byte	32
 14203 03e7 30       		.byte	48
 14204 03e8 01       		.byte	1
 14205 03e9 00       		.byte	0
 14206 03ea 00       		.byte	0
 14207 03eb 00000000 		.space	5
 14207      00
 14208 03f0 04       		.byte	4
 14209 03f1 04       		.byte	4
 14210 03f2 02       		.byte	2
 14211 03f3 00       		.byte	0
 14212 03f4 00       		.byte	0
 14213 03f5 FF       		.byte	-1
 14214 03f6 00       		.byte	0
 14215 03f7 01       		.byte	1
 14216 03f8 00       		.byte	0
 14217 03f9 03       		.byte	3
 14218 03fa 00       		.byte	0
 14219 03fb 60       		.byte	96
 14220 03fc 00       		.byte	0
 14221 03fd 60       		.byte	96
 14222 03fe 00       		.byte	0
 14223 03ff 30       		.byte	48
 14224 0400 01       		.byte	1
 14225 0401 00       		.byte	0
 14226 0402 00       		.byte	0
 14227 0403 00000000 		.space	5
 14227      00
 14228 0408 00       		.byte	0
 14229 0409 00       		.byte	0
 14230 040a 02       		.byte	2
 14231 040b 00       		.byte	0
 14232 040c 00       		.byte	0
 14233 040d 19       		.byte	25
 14234 040e 00       		.byte	0
 14235 040f 01       		.byte	1
 14236 0410 00       		.byte	0
 14237 0411 03       		.byte	3
 14238 0412 00       		.byte	0
 14239 0413 00       		.byte	0
 14240 0414 00       		.byte	0
 14241 0415 00       		.byte	0
 14242 0416 00       		.byte	0
 14243 0417 30       		.byte	48
 14244 0418 01       		.byte	1
 14245 0419 00       		.byte	0
 14246 041a 00       		.byte	0
 14247 041b 00000000 		.space	5
 14247      00
 14248 0420 10       		.byte	16
 14249 0421 10       		.byte	16
 14250 0422 02       		.byte	2
 14251 0423 00       		.byte	0
 14252 0424 00       		.byte	0
 14253 0425 06       		.byte	6
 14254 0426 00       		.byte	0
 14255 0427 01       		.byte	1
 14256 0428 00       		.byte	0
 14257 0429 03       		.byte	3
 14258 042a 00       		.byte	0
 14259 042b 03       		.byte	3
 14260 042c 00       		.byte	0
 14261 042d 03       		.byte	3
 14262 042e 00       		.byte	0
 14263 042f 30       		.byte	48
 14264 0430 01       		.byte	1
 14265 0431 00       		.byte	0
 14266 0432 00       		.byte	0
 14267 0433 00000000 		.space	5
 14267      00
 14268 0438 00       		.byte	0
 14269 0439 00       		.byte	0
 14270 043a 02       		.byte	2
 14271 043b 00       		.byte	0
 14272 043c 00       		.byte	0
 14273 043d 03       		.byte	3
 14274 043e 00       		.byte	0
 14275 043f 01       		.byte	1
 14276 0440 00       		.byte	0
 14277 0441 03       		.byte	3
 14278 0442 00       		.byte	0
 14279 0443 00       		.byte	0
 14280 0444 00       		.byte	0
 14281 0445 00       		.byte	0
 14282 0446 00       		.byte	0
 14283 0447 30       		.byte	48
 14284 0448 01       		.byte	1
 14285 0449 00       		.byte	0
 14286 044a 00       		.byte	0
 14287 044b 00000000 		.space	5
 14287      00
 14288 0450 50       		.byte	80
 14289 0451 50       		.byte	80
 14290 0452 01       		.byte	1
 14291 0453 00       		.byte	0
 14292 0454 00       		.byte	0
 14293 0455 03       		.byte	3
 14294 0456 00       		.byte	0
 14295 0457 01       		.byte	1
 14296 0458 00       		.byte	0
 14297 0459 03       		.byte	3
 14298 045a 00       		.byte	0
 14299 045b 00       		.byte	0
 14300 045c 00       		.byte	0
 14301 045d 00       		.byte	0
 14302 045e 00       		.byte	0
 14303 045f 30       		.byte	48
 14304 0460 01       		.byte	1
 14305 0461 00       		.byte	0
 14306 0462 00       		.byte	0
 14307 0463 00000000 		.space	5
 14307      00
 14308 0468 00       		.byte	0
 14309 0469 00       		.byte	0
 14310 046a 0B       		.byte	11
 14311 046b 00       		.byte	0
 14312 046c 00       		.byte	0
 14313 046d FF       		.byte	-1
 14314 046e FF       		.byte	-1
 14315 046f 01       		.byte	1
 14316 0470 00       		.byte	0
 14317 0471 03       		.byte	3
 14318 0472 00       		.byte	0
 14319 0473 00       		.byte	0
 14320 0474 00       		.byte	0
 14321 0475 00       		.byte	0
 14322 0476 00       		.byte	0
 14323 0477 00       		.byte	0
 14324 0478 01       		.byte	1
 14325 0479 00       		.byte	0
 14326 047a 00       		.byte	0
 14327 047b 00000000 		.space	5
 14327      00
 14330              	glProbeCtrlFull:
 14331 0480 00       		.byte	0
 14332 0481 00       		.byte	0
 14333 0482 01       		.byte	1
 14334 0483 01       		.byte	1
 14335 0484 15       		.byte	21
 14336 0485 16       		.byte	22
 14337 0486 05       		.byte	5
 14338 0487 00       		.byte	0
 14339 0488 00       		.byte	0
 14340 0489 00       		.byte	0
 14341 048a 00       		.byte	0
 14342 048b 00       		.byte	0
 14343 048c 00       		.byte	0
 14344 048d 00       		.byte	0
 14345 048e 00       		.byte	0
 14346 048f 00       		.byte	0
 14347 0490 00       		.byte	0
 14348 0491 00       		.byte	0
 14349 0492 00       		.byte	0
 14350 0493 C6       		.byte	-58
 14351 0494 99       		.byte	-103
 14352 0495 00       		.byte	0
 14353 0496 00       		.byte	0
 14354 0497 40       		.byte	64
 14355 0498 00       		.byte	0
 14356 0499 00       		.byte	0
 14357 049a 0000     		.space	2
 14360              	glProbeCtrl20:
 14361 049c 00       		.byte	0
 14362 049d 00       		.byte	0
 14363 049e 01       		.byte	1
 14364 049f 01       		.byte	1
 14365 04a0 80       		.byte	-128
 14366 04a1 1A       		.byte	26
 14367 04a2 06       		.byte	6
 14368 04a3 00       		.byte	0
 14369 04a4 00       		.byte	0
 14370 04a5 00       		.byte	0
 14371 04a6 00       		.byte	0
 14372 04a7 00       		.byte	0
 14373 04a8 00       		.byte	0
 14374 04a9 00       		.byte	0
 14375 04aa 00       		.byte	0
 14376 04ab 00       		.byte	0
 14377 04ac 00       		.byte	0
 14378 04ad 00       		.byte	0
 14379 04ae 00       		.byte	0
 14380 04af D2       		.byte	-46
 14381 04b0 0F       		.byte	15
 14382 04b1 00       		.byte	0
 14383 04b2 00       		.byte	0
 14384 04b3 40       		.byte	64
 14385 04b4 00       		.byte	0
 14386 04b5 00       		.byte	0
 14387 04b6 0000     		.space	2
 14390              	glProbeCtrl:
 14391 04b8 00       		.byte	0
 14392 04b9 00       		.byte	0
 14393 04ba 01       		.byte	1
 14394 04bb 01       		.byte	1
 14395 04bc 15       		.byte	21
 14396 04bd 16       		.byte	22
 14397 04be 05       		.byte	5
 14398 04bf 00       		.byte	0
 14399 04c0 00       		.byte	0
 14400 04c1 00       		.byte	0
 14401 04c2 00       		.byte	0
 14402 04c3 00       		.byte	0
 14403 04c4 00       		.byte	0
 14404 04c5 00       		.byte	0
 14405 04c6 00       		.byte	0
 14406 04c7 00       		.byte	0
 14407 04c8 00       		.byte	0
 14408 04c9 00       		.byte	0
 14409 04ca 00       		.byte	0
 14410 04cb 48       		.byte	72
 14411 04cc 3F       		.byte	63
 14412 04cd 00       		.byte	0
 14413 04ce 00       		.byte	0
 14414 04cf 40       		.byte	64
 14415 04d0 00       		.byte	0
 14416 04d1 00       		.byte	0
 14419              	ROIMode:
 14420 04d2 01       		.byte	1
 14421 04d3 00       		.space	1
 14424              	glProbeStilCtrl:
 14425 04d4 01       		.byte	1
 14426 04d5 02       		.byte	2
 14427 04d6 00       		.byte	0
 14428 04d7 00       		.byte	0
 14429 04d8 C6       		.byte	-58
 14430 04d9 99       		.byte	-103
 14431 04da 00       		.byte	0
 14432 04db 00       		.byte	0
 14433 04dc 40       		.byte	64
 14434 04dd 00       		.byte	0
 14435 04de 00       		.byte	0
 14436 04df 00       		.space	1
 14439              	glProbeStilCtrl20:
 14440 04e0 01       		.byte	1
 14441 04e1 01       		.byte	1
 14442 04e2 00       		.byte	0
 14443 04e3 00       		.byte	0
 14444 04e4 D2       		.byte	-46
 14445 04e5 0F       		.byte	15
 14446 04e6 00       		.byte	0
 14447 04e7 00       		.byte	0
 14448 04e8 40       		.byte	64
 14449 04e9 00       		.byte	0
 14450 04ea 00       		.byte	0
 14451 04eb 00       		.space	1
 14454              	glUVCHeader:
 14455 04ec 0C       		.byte	12
 14456 04ed 8C       		.byte	-116
 14457 04ee 00       		.byte	0
 14458 04ef 00       		.byte	0
 14459 04f0 00       		.byte	0
 14460 04f1 00       		.byte	0
 14461 04f2 00       		.byte	0
 14462 04f3 00       		.byte	0
 14463 04f4 00       		.byte	0
 14464 04f5 00       		.byte	0
 14465 04f6 00       		.byte	0
 14466 04f7 00       		.byte	0
 14469              	dbgIdx:
 14470 04f8 02       		.byte	2
 14473              	valIdx:
 14474 04f9 01       		.byte	1
 14475 04fa 0000     		.space	2
 14478              	EXTBLCWinPos:
 14479 04fc 14       		.byte	20
 14480 04fd 13       		.byte	19
 14481 04fe 02       		.byte	2
 14482 04ff 00       		.byte	0
 14483 0500 00       		.byte	0
 14484 0501 FF       		.byte	-1
 14485 0502 FF       		.byte	-1
 14486 0503 01       		.byte	1
 14487 0504 00       		.byte	0
 14488 0505 03       		.byte	3
 14489 0506 00       		.byte	0
 14490 0507 66       		.byte	102
 14491 0508 66       		.byte	102
 14492 0509 66       		.byte	102
 14493 050a 66       		.byte	102
 14494 050b 30       		.byte	48
 14495 050c 01       		.byte	1
 14496 050d 00       		.byte	0
 14497 050e 0000     		.space	2
 14500              	EXTBLCWeight:
 14501 0510 11       		.byte	17
 14502 0511 11       		.byte	17
 14503 0512 02       		.byte	2
 14504 0513 00       		.byte	0
 14505 0514 00       		.byte	0
 14506 0515 FF       		.byte	-1
 14507 0516 00       		.byte	0
 14508 0517 01       		.byte	1
 14509 0518 00       		.byte	0
 14510 0519 03       		.byte	3
 14511 051a 00       		.byte	0
 14512 051b 80       		.byte	-128
 14513 051c 00       		.byte	0
 14514 051d 80       		.byte	-128
 14515 051e 00       		.byte	0
 14516 051f 30       		.byte	48
 14517 0520 01       		.byte	1
 14518 0521 00       		.byte	0
 14519 0522 0000     		.space	2
 14522              	EXTShutter:
 14523 0524 00       		.byte	0
 14524 0525 02       		.byte	2
 14525 0526 02       		.byte	2
 14526 0527 00       		.byte	0
 14527 0528 00       		.byte	0
 14528 0529 08       		.byte	8
 14529 052a 00       		.byte	0
 14530 052b 01       		.byte	1
 14531 052c 00       		.byte	0
 14532 052d 03       		.byte	3
 14533 052e 00       		.byte	0
 14534 052f 00       		.byte	0
 14535 0530 00       		.byte	0
 14536 0531 00       		.byte	0
 14537 0532 00       		.byte	0
 14538 0533 30       		.byte	48
 14539 0534 01       		.byte	1
 14540 0535 00       		.byte	0
 14541 0536 0000     		.space	2
 14544              	EXTShutlev:
 14545 0538 02       		.byte	2
 14546 0539 12       		.byte	18
 14547 053a 02       		.byte	2
 14548 053b 00       		.byte	0
 14549 053c 00       		.byte	0
 14550 053d FF       		.byte	-1
 14551 053e 7F       		.byte	127
 14552 053f 01       		.byte	1
 14553 0540 00       		.byte	0
 14554 0541 03       		.byte	3
 14555 0542 00       		.byte	0
 14556 0543 3F       		.byte	63
 14557 0544 00       		.byte	0
 14558 0545 3F       		.byte	63
 14559 0546 00       		.byte	0
 14560 0547 30       		.byte	48
 14561 0548 01       		.byte	1
 14562 0549 00       		.byte	0
 14563 054a 0000     		.space	2
 14566              	EXTAexModGainlev:
 14567 054c 00       		.byte	0
 14568 054d 03       		.byte	3
 14569 054e 04       		.byte	4
 14570 054f 00       		.byte	0
 14571 0550 00       		.byte	0
 14572 0551 03       		.byte	3
 14573 0552 7F       		.byte	127
 14574 0553 01       		.byte	1
 14575 0554 00       		.byte	0
 14576 0555 03       		.byte	3
 14577 0556 00       		.byte	0
 14578 0557 00       		.byte	0
 14579 0558 3F       		.byte	63
 14580 0559 00       		.byte	0
 14581 055a 3F       		.byte	63
 14582 055b 30       		.byte	48
 14583 055c 01       		.byte	1
 14584 055d 00       		.byte	0
 14585 055e 0000     		.space	2
 14588              	WBMenuCmpArry:
 14589 0560 20       		.byte	32
 14590 0561 0F       		.byte	15
 14591 0562 38       		.byte	56
 14592 0563 F0       		.byte	-16
 14595              	PUCBLC:
 14596 0564 10       		.byte	16
 14597 0565 11       		.byte	17
 14598 0566 02       		.byte	2
 14599 0567 00       		.byte	0
 14600 0568 00       		.byte	0
 14601 0569 03       		.byte	3
 14602 056a 00       		.byte	0
 14603 056b 01       		.byte	1
 14604 056c 00       		.byte	0
 14605 056d 03       		.byte	3
 14606 056e 00       		.byte	0
 14607 056f 03       		.byte	3
 14608 0570 00       		.byte	0
 14609 0571 03       		.byte	3
 14610 0572 00       		.byte	0
 14611 0573 30       		.byte	48
 14612 0574 01       		.byte	1
 14613 0575 00       		.byte	0
 14614 0576 0000     		.space	2
 14617              	PUCSharp:
 14618 0578 06       		.byte	6
 14619 0579 07       		.byte	7
 14620 057a 02       		.byte	2
 14621 057b 00       		.byte	0
 14622 057c 00       		.byte	0
 14623 057d 08       		.byte	8
 14624 057e 00       		.byte	0
 14625 057f 01       		.byte	1
 14626 0580 00       		.byte	0
 14627 0581 03       		.byte	3
 14628 0582 00       		.byte	0
 14629 0583 00       		.byte	0
 14630 0584 00       		.byte	0
 14631 0585 00       		.byte	0
 14632 0586 00       		.byte	0
 14633 0587 30       		.byte	48
 14634 0588 01       		.byte	1
 14635 0589 00       		.byte	0
 14636 058a 0000     		.space	2
 14639              	CTCtrlParArry:
 14640 058c 00       		.byte	0
 14641 058d 00       		.byte	0
 14642 058e 01       		.byte	1
 14643 058f 00       		.byte	0
 14644 0590 00       		.byte	0
 14645 0591 03       		.byte	3
 14646 0592 00       		.byte	0
 14647 0593 01       		.byte	1
 14648 0594 00       		.byte	0
 14649 0595 03       		.byte	3
 14650 0596 00       		.byte	0
 14651 0597 03       		.byte	3
 14652 0598 00       		.byte	0
 14653 0599 03       		.byte	3
 14654 059a 00       		.byte	0
 14655 059b 30       		.byte	48
 14656 059c 01       		.byte	1
 14657 059d 00       		.byte	0
 14658 059e 00       		.byte	0
 14659 059f 00000000 		.space	5
 14659      00
 14660 05a4 00       		.byte	0
 14661 05a5 00       		.byte	0
 14662 05a6 01       		.byte	1
 14663 05a7 01       		.byte	1
 14664 05a8 00       		.byte	0
 14665 05a9 0F       		.byte	15
 14666 05aa 00       		.byte	0
 14667 05ab 0F       		.byte	15
 14668 05ac 00       		.byte	0
 14669 05ad 03       		.byte	3
 14670 05ae 00       		.byte	0
 14671 05af 02       		.byte	2
 14672 05b0 00       		.byte	0
 14673 05b1 02       		.byte	2
 14674 05b2 00       		.byte	0
 14675 05b3 30       		.byte	48
 14676 05b4 01       		.byte	1
 14677 05b5 01       		.byte	1
 14678 05b6 00       		.byte	0
 14679 05b7 00000000 		.space	5
 14679      00
 14680 05bc 02       		.byte	2
 14681 05bd 00       		.byte	0
 14682 05be 01       		.byte	1
 14683 05bf 00       		.byte	0
 14684 05c0 00       		.byte	0
 14685 05c1 01       		.byte	1
 14686 05c2 00       		.byte	0
 14687 05c3 01       		.byte	1
 14688 05c4 00       		.byte	0
 14689 05c5 03       		.byte	3
 14690 05c6 00       		.byte	0
 14691 05c7 00       		.byte	0
 14692 05c8 00       		.byte	0
 14693 05c9 00       		.byte	0
 14694 05ca 00       		.byte	0
 14695 05cb 30       		.byte	48
 14696 05cc 01       		.byte	1
 14697 05cd 01       		.byte	1
 14698 05ce 00       		.byte	0
 14699 05cf 00000000 		.space	5
 14699      00
 14700 05d4 00       		.byte	0
 14701 05d5 00       		.byte	0
 14702 05d6 04       		.byte	4
 14703 05d7 01       		.byte	1
 14704 05d8 00       		.byte	0
 14705 05d9 38       		.byte	56
 14706 05da 01       		.byte	1
 14707 05db 01       		.byte	1
 14708 05dc 00       		.byte	0
 14709 05dd 03       		.byte	3
 14710 05de 00       		.byte	0
 14711 05df 4E       		.byte	78
 14712 05e0 00       		.byte	0
 14713 05e1 4E       		.byte	78
 14714 05e2 00       		.byte	0
 14715 05e3 30       		.byte	48
 14716 05e4 01       		.byte	1
 14717 05e5 00       		.byte	0
 14718 05e6 00       		.byte	0
 14719 05e7 00000000 		.space	5
 14719      00
 14720 05ec 04       		.byte	4
 14721 05ed 00       		.byte	0
 14722 05ee 01       		.byte	1
 14723 05ef 00       		.byte	0
 14724 05f0 00       		.byte	0
 14725 05f1 00       		.byte	0
 14726 05f2 00       		.byte	0
 14727 05f3 01       		.byte	1
 14728 05f4 00       		.byte	0
 14729 05f5 03       		.byte	3
 14730 05f6 00       		.byte	0
 14731 05f7 00       		.byte	0
 14732 05f8 00       		.byte	0
 14733 05f9 00       		.byte	0
 14734 05fa 00       		.byte	0
 14735 05fb 30       		.byte	48
 14736 05fc 01       		.byte	1
 14737 05fd 00       		.byte	0
 14738 05fe 00       		.byte	0
 14739 05ff 00000000 		.space	5
 14739      00
 14740 0604 05       		.byte	5
 14741 0605 00       		.byte	0
 14742 0606 02       		.byte	2
 14743 0607 00       		.byte	0
 14744 0608 00       		.byte	0
 14745 0609 FF       		.byte	-1
 14746 060a 00       		.byte	0
 14747 060b 01       		.byte	1
 14748 060c 00       		.byte	0
 14749 060d 03       		.byte	3
 14750 060e 00       		.byte	0
 14751 060f 01       		.byte	1
 14752 0610 00       		.byte	0
 14753 0611 00       		.byte	0
 14754 0612 00       		.byte	0
 14755 0613 30       		.byte	48
 14756 0614 01       		.byte	1
 14757 0615 01       		.byte	1
 14758 0616 00       		.byte	0
 14759 0617 00000000 		.space	5
 14759      00
 14760 061c 06       		.byte	6
 14761 061d 00       		.byte	0
 14762 061e 02       		.byte	2
 14763 061f 00       		.byte	0
 14764 0620 00       		.byte	0
 14765 0621 00       		.byte	0
 14766 0622 00       		.byte	0
 14767 0623 00       		.byte	0
 14768 0624 00       		.byte	0
 14769 0625 03       		.byte	3
 14770 0626 00       		.byte	0
 14771 0627 00       		.byte	0
 14772 0628 00       		.byte	0
 14773 0629 00       		.byte	0
 14774 062a 00       		.byte	0
 14775 062b 30       		.byte	48
 14776 062c 01       		.byte	1
 14777 062d 01       		.byte	1
 14778 062e 00       		.byte	0
 14779 062f 00000000 		.space	5
 14779      00
 14780 0634 23       		.byte	35
 14781 0635 00       		.byte	0
 14782 0636 02       		.byte	2
 14783 0637 00       		.byte	0
 14784 0638 00       		.byte	0
 14785 0639 30       		.byte	48
 14786 063a 00       		.byte	0
 14787 063b 01       		.byte	1
 14788 063c 00       		.byte	0
 14789 063d 03       		.byte	3
 14790 063e 0A       		.byte	10
 14791 063f 00       		.byte	0
 14792 0640 00       		.byte	0
 14793 0641 0A       		.byte	10
 14794 0642 00       		.byte	0
 14795 0643 30       		.byte	48
 14796 0644 01       		.byte	1
 14797 0645 01       		.byte	1
 14798 0646 00       		.byte	0
 14799 0647 00000000 		.space	5
 14799      00
 14800 064c 08       		.byte	8
 14801 064d 00       		.byte	0
 14802 064e 01       		.byte	1
 14803 064f 00       		.byte	0
 14804 0650 00       		.byte	0
 14805 0651 7F       		.byte	127
 14806 0652 00       		.byte	0
 14807 0653 01       		.byte	1
 14808 0654 00       		.byte	0
 14809 0655 03       		.byte	3
 14810 0656 00       		.byte	0
 14811 0657 00       		.byte	0
 14812 0658 00       		.byte	0
 14813 0659 00       		.byte	0
 14814 065a 00       		.byte	0
 14815 065b 30       		.byte	48
 14816 065c 01       		.byte	1
 14817 065d 00       		.byte	0
 14818 065e 00       		.byte	0
 14819 065f 00000000 		.space	5
 14819      00
 14820 0664 09       		.byte	9
 14821 0665 00       		.byte	0
 14822 0666 02       		.byte	2
 14823 0667 00       		.byte	0
 14824 0668 00       		.byte	0
 14825 0669 05       		.byte	5
 14826 066a 00       		.byte	0
 14827 066b 01       		.byte	1
 14828 066c 00       		.byte	0
 14829 066d 03       		.byte	3
 14830 066e 00       		.byte	0
 14831 066f 00       		.byte	0
 14832 0670 00       		.byte	0
 14833 0671 00       		.byte	0
 14834 0672 00       		.byte	0
 14835 0673 30       		.byte	48
 14836 0674 01       		.byte	1
 14837 0675 00       		.byte	0
 14838 0676 00       		.byte	0
 14839 0677 00000000 		.space	5
 14839      00
 14840 067c 10       		.byte	16
 14841 067d 00       		.byte	0
 14842 067e 03       		.byte	3
 14843 067f 00       		.byte	0
 14844 0680 00       		.byte	0
 14845 0681 00       		.byte	0
 14846 0682 00       		.byte	0
 14847 0683 00       		.byte	0
 14848 0684 00       		.byte	0
 14849 0685 03       		.byte	3
 14850 0686 00       		.byte	0
 14851 0687 00       		.byte	0
 14852 0688 00       		.byte	0
 14853 0689 00       		.byte	0
 14854 068a 00       		.byte	0
 14855 068b 30       		.byte	48
 14856 068c 01       		.byte	1
 14857 068d 00       		.byte	0
 14858 068e 00       		.byte	0
 14859 068f 00000000 		.space	5
 14859      00
 14860 0694 00       		.byte	0
 14861 0695 00       		.byte	0
 14862 0696 02       		.byte	2
 14863 0697 00       		.byte	0
 14864 0698 00       		.byte	0
 14865 0699 40       		.byte	64
 14866 069a 00       		.byte	0
 14867 069b 01       		.byte	1
 14868 069c 00       		.byte	0
 14869 069d 03       		.byte	3
 14870 069e 00       		.byte	0
 14871 069f 0F       		.byte	15
 14872 06a0 11       		.byte	17
 14873 06a1 00       		.byte	0
 14874 06a2 00       		.byte	0
 14875 06a3 30       		.byte	48
 14876 06a4 01       		.byte	1
 14877 06a5 00       		.byte	0
 14878 06a6 00       		.byte	0
 14879 06a7 00000000 		.space	5
 14879      00
 14880 06ac 00       		.byte	0
 14881 06ad 00       		.byte	0
 14882 06ae 02       		.byte	2
 14883 06af 00       		.byte	0
 14884 06b0 00       		.byte	0
 14885 06b1 64       		.byte	100
 14886 06b2 00       		.byte	0
 14887 06b3 01       		.byte	1
 14888 06b4 00       		.byte	0
 14889 06b5 03       		.byte	3
 14890 06b6 00       		.byte	0
 14891 06b7 00       		.byte	0
 14892 06b8 00       		.byte	0
 14893 06b9 00       		.byte	0
 14894 06ba 00       		.byte	0
 14895 06bb 30       		.byte	48
 14896 06bc 01       		.byte	1
 14897 06bd 00       		.byte	0
 14898 06be 00       		.byte	0
 14899 06bf 00000000 		.space	5
 14899      00
 14900 06c4 00       		.byte	0
 14901 06c5 00       		.byte	0
 14902 06c6 02       		.byte	2
 14903 06c7 00       		.byte	0
 14904 06c8 00       		.byte	0
 14905 06c9 64       		.byte	100
 14906 06ca 00       		.byte	0
 14907 06cb 01       		.byte	1
 14908 06cc 00       		.byte	0
 14909 06cd 03       		.byte	3
 14910 06ce 00       		.byte	0
 14911 06cf 00       		.byte	0
 14912 06d0 00       		.byte	0
 14913 06d1 00       		.byte	0
 14914 06d2 00       		.byte	0
 14915 06d3 30       		.byte	48
 14916 06d4 01       		.byte	1
 14917 06d5 00       		.byte	0
 14918 06d6 00       		.byte	0
 14919 06d7 00000000 		.space	5
 14919      00
 14920 06dc 00       		.byte	0
 14921 06dd 00       		.byte	0
 14922 06de 02       		.byte	2
 14923 06df 00       		.byte	0
 14924 06e0 00       		.byte	0
 14925 06e1 64       		.byte	100
 14926 06e2 00       		.byte	0
 14927 06e3 01       		.byte	1
 14928 06e4 00       		.byte	0
 14929 06e5 03       		.byte	3
 14930 06e6 00       		.byte	0
 14931 06e7 00       		.byte	0
 14932 06e8 00       		.byte	0
 14933 06e9 00       		.byte	0
 14934 06ea 00       		.byte	0
 14935 06eb 30       		.byte	48
 14936 06ec 01       		.byte	1
 14937 06ed 00       		.byte	0
 14938 06ee 00       		.byte	0
 14939 06ef 00000000 		.space	5
 14939      00
 14940 06f4 00       		.byte	0
 14941 06f5 00       		.byte	0
 14942 06f6 02       		.byte	2
 14943 06f7 00       		.byte	0
 14944 06f8 00       		.byte	0
 14945 06f9 64       		.byte	100
 14946 06fa 00       		.byte	0
 14947 06fb 01       		.byte	1
 14948 06fc 00       		.byte	0
 14949 06fd 03       		.byte	3
 14950 06fe 00       		.byte	0
 14951 06ff 00       		.byte	0
 14952 0700 00       		.byte	0
 14953 0701 00       		.byte	0
 14954 0702 00       		.byte	0
 14955 0703 30       		.byte	48
 14956 0704 01       		.byte	1
 14957 0705 00       		.byte	0
 14958 0706 00       		.byte	0
 14959 0707 00000000 		.space	5
 14959      00
 14962              	snapButFlag:
 14963 070c 01       		.byte	1
 14964 070d 000000   		.space	3
 14967              	CyFxGpifRegValue_usb2:
 14968 0710 08830080 		.word	-2147450104
 14969 0714 67000000 		.word	103
 14970 0718 01000000 		.word	1
 14971 071c 46000000 		.word	70
 14972 0720 00000000 		.word	0
 14973 0724 00000000 		.word	0
 14974 0728 02000000 		.word	2
 14975 072c 82000000 		.word	130
 14976 0730 82070000 		.word	1922
 14977 0734 40040000 		.word	1088
 14978 0738 FCFF0000 		.word	65532
 14979 073c 28000000 		.word	40
 14980 0740 00000000 		.word	0
 14981 0744 00000000 		.word	0
 14982 0748 00000000 		.word	0
 14983 074c 00000000 		.word	0
 14984 0750 01000000 		.word	1
 14985 0754 00000000 		.word	0
 14986 0758 00000000 		.word	0
 14987 075c 00000000 		.word	0
 14988 0760 00000000 		.word	0
 14989 0764 00000000 		.word	0
 14990 0768 00000000 		.word	0
 14991 076c 00000000 		.word	0
 14992 0770 00000000 		.word	0
 14993 0774 00000000 		.word	0
 14994 0778 00000000 		.word	0
 14995 077c 00000000 		.word	0
 14996 0780 00000000 		.word	0
 14997 0784 06000000 		.word	6
 14998 0788 00000000 		.word	0
 14999 078c FFFF0000 		.word	65535
 15000 0790 09010000 		.word	265
 15001 0794 00000000 		.word	0
 15002 0798 F71F0000 		.word	8183
 15003 079c 00000000 		.word	0
 15004 07a0 FFFF0000 		.word	65535
 15005 07a4 09010000 		.word	265
 15006 07a8 00000000 		.word	0
 15007 07ac F71F0000 		.word	8183
 15008 07b0 00000000 		.word	0
 15009 07b4 00000000 		.word	0
 15010 07b8 00000000 		.word	0
 15011 07bc 00000000 		.word	0
 15012 07c0 00000000 		.word	0
 15013 07c4 00000000 		.word	0
 15014 07c8 00000000 		.word	0
 15015 07cc 00000000 		.word	0
 15016 07d0 00000000 		.word	0
 15017 07d4 00000000 		.word	0
 15018 07d8 00000000 		.word	0
 15019 07dc 00000000 		.word	0
 15020 07e0 00000000 		.word	0
 15021 07e4 00000000 		.word	0
 15022 07e8 00000000 		.word	0
 15023 07ec 00000000 		.word	0
 15024 07f0 00000000 		.word	0
 15025 07f4 00000000 		.word	0
 15026 07f8 00000000 		.word	0
 15027 07fc 00000000 		.word	0
 15028 0800 00000000 		.word	0
 15029 0804 00000000 		.word	0
 15030 0808 00000000 		.word	0
 15031 080c 00040180 		.word	-2147417088
 15032 0810 01040180 		.word	-2147417087
 15033 0814 02040180 		.word	-2147417086
 15034 0818 03040180 		.word	-2147417085
 15035 081c 00000000 		.word	0
 15036 0820 00000000 		.word	0
 15037 0824 00000000 		.word	0
 15038 0828 00000000 		.word	0
 15039 082c 00000000 		.word	0
 15040 0830 00000000 		.word	0
 15041 0834 00000000 		.word	0
 15042 0838 00000000 		.word	0
 15043 083c C1FFFFFF 		.word	-63
 15046              	CyFxGpifWavedataPosition_usb2:
 15047 0840 00       		.byte	0
 15048 0841 01       		.byte	1
 15049 0842 02       		.byte	2
 15050 0843 03       		.byte	3
 15051 0844 04       		.byte	4
 15052 0845 05       		.byte	5
 15053 0846 06       		.byte	6
 15054 0847 07       		.byte	7
 15055 0848 08       		.byte	8
 15056 0849 09       		.byte	9
 15057 084a 0A       		.byte	10
 15058 084b 08       		.byte	8
 15059 084c 0B       		.byte	11
 15060 084d 0C       		.byte	12
 15061 084e 0D       		.byte	13
 15062 084f 08       		.byte	8
 15063 0850 0E       		.byte	14
 15064 0851 0F       		.byte	15
 15065 0852 08       		.byte	8
 15066 0853 08       		.byte	8
 15067 0854 08       		.byte	8
 15068 0855 08       		.byte	8
 15069 0856 08       		.byte	8
 15070 0857 08       		.byte	8
 15071 0858 08       		.byte	8
 15072 0859 08       		.byte	8
 15073 085a 08       		.byte	8
 15074 085b 08       		.byte	8
 15075 085c 08       		.byte	8
 15076 085d 08       		.byte	8
 15077 085e 08       		.byte	8
 15078 085f 08       		.byte	8
 15079 0860 08       		.byte	8
 15080 0861 08       		.byte	8
 15081 0862 08       		.byte	8
 15082 0863 08       		.byte	8
 15083 0864 08       		.byte	8
 15084 0865 08       		.byte	8
 15085 0866 08       		.byte	8
 15086 0867 08       		.byte	8
 15087 0868 08       		.byte	8
 15088 0869 08       		.byte	8
 15089 086a 08       		.byte	8
 15090 086b 08       		.byte	8
 15091 086c 08       		.byte	8
 15092 086d 08       		.byte	8
 15093 086e 08       		.byte	8
 15094 086f 08       		.byte	8
 15095 0870 08       		.byte	8
 15096 0871 08       		.byte	8
 15097 0872 08       		.byte	8
 15098 0873 08       		.byte	8
 15099 0874 08       		.byte	8
 15100 0875 08       		.byte	8
 15101 0876 08       		.byte	8
 15102 0877 08       		.byte	8
 15103 0878 08       		.byte	8
 15104 0879 08       		.byte	8
 15105 087a 08       		.byte	8
 15106 087b 08       		.byte	8
 15107 087c 08       		.byte	8
 15108 087d 08       		.byte	8
 15109 087e 08       		.byte	8
 15110 087f 08       		.byte	8
 15111 0880 08       		.byte	8
 15112 0881 08       		.byte	8
 15113 0882 08       		.byte	8
 15114 0883 08       		.byte	8
 15115 0884 08       		.byte	8
 15116 0885 08       		.byte	8
 15117 0886 08       		.byte	8
 15118 0887 08       		.byte	8
 15119 0888 08       		.byte	8
 15120 0889 08       		.byte	8
 15121 088a 08       		.byte	8
 15122 088b 08       		.byte	8
 15123 088c 08       		.byte	8
 15124 088d 08       		.byte	8
 15125 088e 08       		.byte	8
 15126 088f 08       		.byte	8
 15127 0890 08       		.byte	8
 15128 0891 08       		.byte	8
 15129 0892 08       		.byte	8
 15130 0893 08       		.byte	8
 15131 0894 08       		.byte	8
 15132 0895 08       		.byte	8
 15133 0896 08       		.byte	8
 15134 0897 08       		.byte	8
 15135 0898 08       		.byte	8
 15136 0899 08       		.byte	8
 15137 089a 08       		.byte	8
 15138 089b 08       		.byte	8
 15139 089c 08       		.byte	8
 15140 089d 08       		.byte	8
 15141 089e 08       		.byte	8
 15142 089f 08       		.byte	8
 15143 08a0 08       		.byte	8
 15144 08a1 08       		.byte	8
 15145 08a2 08       		.byte	8
 15146 08a3 08       		.byte	8
 15147 08a4 08       		.byte	8
 15148 08a5 08       		.byte	8
 15149 08a6 08       		.byte	8
 15150 08a7 08       		.byte	8
 15151 08a8 08       		.byte	8
 15152 08a9 08       		.byte	8
 15153 08aa 08       		.byte	8
 15154 08ab 08       		.byte	8
 15155 08ac 08       		.byte	8
 15156 08ad 08       		.byte	8
 15157 08ae 08       		.byte	8
 15158 08af 08       		.byte	8
 15159 08b0 08       		.byte	8
 15160 08b1 08       		.byte	8
 15161 08b2 08       		.byte	8
 15162 08b3 08       		.byte	8
 15163 08b4 08       		.byte	8
 15164 08b5 08       		.byte	8
 15165 08b6 08       		.byte	8
 15166 08b7 08       		.byte	8
 15167 08b8 08       		.byte	8
 15168 08b9 08       		.byte	8
 15169 08ba 08       		.byte	8
 15170 08bb 08       		.byte	8
 15171 08bc 08       		.byte	8
 15172 08bd 08       		.byte	8
 15173 08be 08       		.byte	8
 15174 08bf 08       		.byte	8
 15175 08c0 00       		.byte	0
 15176 08c1 01       		.byte	1
 15177 08c2 02       		.byte	2
 15178 08c3 10       		.byte	16
 15179 08c4 04       		.byte	4
 15180 08c5 05       		.byte	5
 15181 08c6 06       		.byte	6
 15182 08c7 07       		.byte	7
 15183 08c8 08       		.byte	8
 15184 08c9 09       		.byte	9
 15185 08ca 0A       		.byte	10
 15186 08cb 08       		.byte	8
 15187 08cc 11       		.byte	17
 15188 08cd 0C       		.byte	12
 15189 08ce 0D       		.byte	13
 15190 08cf 08       		.byte	8
 15191 08d0 0E       		.byte	14
 15192 08d1 0F       		.byte	15
 15193 08d2 08       		.byte	8
 15194 08d3 00       		.space	1
 15197              	CyFxGpifWavedata_usb2:
 15198 08d4 0181731E 		.word	510886145
 15199 08d8 00000000 		.word	0
 15200 08dc 00000080 		.word	-2147483648
 15201 08e0 00000000 		.word	0
 15202 08e4 00000000 		.word	0
 15203 08e8 00000000 		.word	0
 15204 08ec 0201703E 		.word	1047527682
 15205 08f0 00010000 		.word	256
 15206 08f4 A00000C0 		.word	-1073741664
 15207 08f8 00000000 		.word	0
 15208 08fc 00000000 		.word	0
 15209 0900 00000000 		.word	0
 15210 0904 0394731E 		.word	510891011
 15211 0908 04000020 		.word	536870916
 15212 090c 60004080 		.word	-2143289248
 15213 0910 00000000 		.word	0
 15214 0914 00000000 		.word	0
 15215 0918 00000000 		.word	0
 15216 091c 0620702E 		.word	779100166
 15217 0920 0C000000 		.word	12
 15218 0924 00000080 		.word	-2147483648
 15219 0928 0620702E 		.word	779100166
 15220 092c 0C000000 		.word	12
 15221 0930 00000080 		.word	-2147483648
 15222 0934 0394731E 		.word	510891011
 15223 0938 04000020 		.word	536870916
 15224 093c 60004080 		.word	-2143289248
 15225 0940 0620702E 		.word	779100166
 15226 0944 0C000000 		.word	12
 15227 0948 00000080 		.word	-2147483648
 15228 094c 0C93731E 		.word	510890764
 15229 0950 04000024 		.word	603979780
 15230 0954 90004080 		.word	-2143289200
 15231 0958 0D20702E 		.word	779100173
 15232 095c 0C000000 		.word	12
 15233 0960 00000080 		.word	-2147483648
 15234 0964 0780724E 		.word	1316126727
 15235 0968 0A000000 		.word	10
 15236 096c 00000080 		.word	-2147483648
 15237 0970 08000000 		.word	8
 15238 0974 00000000 		.word	0
 15239 0978 00010080 		.word	-2147483392
 15240 097c 0920702E 		.word	779100169
 15241 0980 0C010000 		.word	268
 15242 0984 00000080 		.word	-2147483648
 15243 0988 0A01701E 		.word	510656778
 15244 098c 0E000100 		.word	65550
 15245 0990 00000080 		.word	-2147483648
 15246 0994 00000000 		.word	0
 15247 0998 00000000 		.word	0
 15248 099c 00000000 		.word	0
 15249 09a0 00000000 		.word	0
 15250 09a4 00000000 		.word	0
 15251 09a8 00000000 		.word	0
 15252 09ac 0394731E 		.word	510891011
 15253 09b0 04000020 		.word	536870916
 15254 09b4 60004080 		.word	-2143289248
 15255 09b8 08000000 		.word	8
 15256 09bc 00000000 		.word	0
 15257 09c0 00010080 		.word	-2147483392
 15258 09c4 0B000000 		.word	11
 15259 09c8 00000000 		.word	0
 15260 09cc 00010080 		.word	-2147483392
 15261 09d0 0C93731E 		.word	510890764
 15262 09d4 04000024 		.word	603979780
 15263 09d8 90004080 		.word	-2143289200
 15264 09dc 0D20702E 		.word	779100173
 15265 09e0 0C000000 		.word	12
 15266 09e4 00000080 		.word	-2147483648
 15267 09e8 0D20702E 		.word	779100173
 15268 09ec 0C000000 		.word	12
 15269 09f0 00000080 		.word	-2147483648
 15270 09f4 0E60724E 		.word	1316118542
 15271 09f8 0A000000 		.word	10
 15272 09fc 00000080 		.word	-2147483648
 15273 0a00 0F000000 		.word	15
 15274 0a04 00000000 		.word	0
 15275 0a08 00010080 		.word	-2147483392
 15276 0a0c 1020702E 		.word	779100176
 15277 0a10 0C010000 		.word	268
 15278 0a14 00000080 		.word	-2147483648
 15279 0a18 1101701E 		.word	510656785
 15280 0a1c 0E000100 		.word	65550
 15281 0a20 00000080 		.word	-2147483648
 15282 0a24 0C93731E 		.word	510890764
 15283 0a28 04000024 		.word	603979780
 15284 0a2c 90004080 		.word	-2143289200
 15285 0a30 0F000000 		.word	15
 15286 0a34 00000000 		.word	0
 15287 0a38 00010080 		.word	-2147483392
 15288 0a3c 12000000 		.word	18
 15289 0a40 00000000 		.word	0
 15290 0a44 00010080 		.word	-2147483392
 15291 0a48 0394731E 		.word	510891011
 15292 0a4c 04000020 		.word	536870916
 15293 0a50 60004080 		.word	-2143289248
 15294 0a54 0480732E 		.word	779321348
 15295 0a58 02010000 		.word	258
 15296 0a5c 0000C0C0 		.word	-1061158912
 15297 0a60 0580732E 		.word	779321349
 15298 0a64 02010000 		.word	258
 15299 0a68 0000C0C0 		.word	-1061158912
 15300 0a6c 0580732E 		.word	779321349
 15301 0a70 02010000 		.word	258
 15302 0a74 0000C0C0 		.word	-1061158912
 15303 0a78 0480732E 		.word	779321348
 15304 0a7c 02010000 		.word	258
 15305 0a80 0000C0C0 		.word	-1061158912
 15308              	CyFxGpifTransition_usb2:
 15309 0a84 0000     		.short	0
 15310 0a86 5555     		.short	21845
 15311 0a88 AAAA     		.short	-21846
 15312 0a8a 8888     		.short	-30584
 15313 0a8c 1111     		.short	4369
 15314 0a8e 4444     		.short	17476
 15315 0a90 3333     		.short	13107
 15316 0a92 CCCC     		.short	-13108
 15319              	CyFxGpifRegValue:
 15320 0a94 08830080 		.word	-2147450104
 15321 0a98 67000000 		.word	103
 15322 0a9c 00000000 		.word	0
 15323 0aa0 46000000 		.word	70
 15324 0aa4 00000000 		.word	0
 15325 0aa8 00000000 		.word	0
 15326 0aac 02000000 		.word	2
 15327 0ab0 82000000 		.word	130
 15328 0ab4 82070000 		.word	1922
 15329 0ab8 40040000 		.word	1088
 15330 0abc FCFF0000 		.word	65532
 15331 0ac0 28000000 		.word	40
 15332 0ac4 00000000 		.word	0
 15333 0ac8 00000000 		.word	0
 15334 0acc 00000000 		.word	0
 15335 0ad0 00000000 		.word	0
 15336 0ad4 01000000 		.word	1
 15337 0ad8 00000000 		.word	0
 15338 0adc 00000000 		.word	0
 15339 0ae0 00000000 		.word	0
 15340 0ae4 00000000 		.word	0
 15341 0ae8 00000000 		.word	0
 15342 0aec 00000000 		.word	0
 15343 0af0 00000000 		.word	0
 15344 0af4 00000000 		.word	0
 15345 0af8 00000000 		.word	0
 15346 0afc 00000000 		.word	0
 15347 0b00 00000000 		.word	0
 15348 0b04 00000000 		.word	0
 15349 0b08 06000000 		.word	6
 15350 0b0c 00000000 		.word	0
 15351 0b10 FFFF0000 		.word	65535
 15352 0b14 09010000 		.word	265
 15353 0b18 00000000 		.word	0
 15354 0b1c F71F0000 		.word	8183
 15355 0b20 00000000 		.word	0
 15356 0b24 FFFF0000 		.word	65535
 15357 0b28 09010000 		.word	265
 15358 0b2c 00000000 		.word	0
 15359 0b30 F71F0000 		.word	8183
 15360 0b34 00000000 		.word	0
 15361 0b38 00000000 		.word	0
 15362 0b3c 00000000 		.word	0
 15363 0b40 00000000 		.word	0
 15364 0b44 00000000 		.word	0
 15365 0b48 00000000 		.word	0
 15366 0b4c 00000000 		.word	0
 15367 0b50 00000000 		.word	0
 15368 0b54 00000000 		.word	0
 15369 0b58 00000000 		.word	0
 15370 0b5c 00000000 		.word	0
 15371 0b60 00000000 		.word	0
 15372 0b64 00000000 		.word	0
 15373 0b68 00000000 		.word	0
 15374 0b6c 00000000 		.word	0
 15375 0b70 00000000 		.word	0
 15376 0b74 00000000 		.word	0
 15377 0b78 00000000 		.word	0
 15378 0b7c 00000000 		.word	0
 15379 0b80 00000000 		.word	0
 15380 0b84 00000000 		.word	0
 15381 0b88 00000000 		.word	0
 15382 0b8c 00000000 		.word	0
 15383 0b90 00040180 		.word	-2147417088
 15384 0b94 01040180 		.word	-2147417087
 15385 0b98 02040180 		.word	-2147417086
 15386 0b9c 03040180 		.word	-2147417085
 15387 0ba0 00000000 		.word	0
 15388 0ba4 00000000 		.word	0
 15389 0ba8 00000000 		.word	0
 15390 0bac 00000000 		.word	0
 15391 0bb0 00000000 		.word	0
 15392 0bb4 00000000 		.word	0
 15393 0bb8 00000000 		.word	0
 15394 0bbc 00000000 		.word	0
 15395 0bc0 C1FFFFFF 		.word	-63
 15398              	CyFxGpifWavedataPosition:
 15399 0bc4 00       		.byte	0
 15400 0bc5 01       		.byte	1
 15401 0bc6 02       		.byte	2
 15402 0bc7 03       		.byte	3
 15403 0bc8 04       		.byte	4
 15404 0bc9 05       		.byte	5
 15405 0bca 06       		.byte	6
 15406 0bcb 07       		.byte	7
 15407 0bcc 08       		.byte	8
 15408 0bcd 09       		.byte	9
 15409 0bce 0A       		.byte	10
 15410 0bcf 0B       		.byte	11
 15411 0bd0 0B       		.byte	11
 15412 0bd1 0B       		.byte	11
 15413 0bd2 0B       		.byte	11
 15414 0bd3 00       		.space	1
 15417              	CyFxGpifWavedata:
 15418 0bd4 0181731E 		.word	510886145
 15419 0bd8 00000000 		.word	0
 15420 0bdc 00000080 		.word	-2147483648
 15421 0be0 00000000 		.word	0
 15422 0be4 00000000 		.word	0
 15423 0be8 00000000 		.word	0
 15424 0bec 0201702E 		.word	779092226
 15425 0bf0 00010000 		.word	256
 15426 0bf4 A0000080 		.word	-2147483488
 15427 0bf8 00000000 		.word	0
 15428 0bfc 00000000 		.word	0
 15429 0c00 00000000 		.word	0
 15430 0c04 0380722E 		.word	779255811
 15431 0c08 02010020 		.word	536871170
 15432 0c0c 60000080 		.word	-2147483552
 15433 0c10 00000000 		.word	0
 15434 0c14 00000000 		.word	0
 15435 0c18 00000000 		.word	0
 15436 0c1c 0460722E 		.word	779247620
 15437 0c20 02010024 		.word	603980034
 15438 0c24 90000080 		.word	-2147483504
 15439 0c28 0594731E 		.word	510891013
 15440 0c2c 06000000 		.word	6
 15441 0c30 00000080 		.word	-2147483648
 15442 0c34 0380722E 		.word	779255811
 15443 0c38 02010020 		.word	536871170
 15444 0c3c 60000080 		.word	-2147483552
 15445 0c40 0693731E 		.word	510890758
 15446 0c44 06000000 		.word	6
 15447 0c48 00000080 		.word	-2147483648
 15448 0c4c 0720703E 		.word	1047535623
 15449 0c50 08010000 		.word	264
 15450 0c54 00000080 		.word	-2147483648
 15451 0c58 0820703E 		.word	1047535624
 15452 0c5c 08010000 		.word	264
 15453 0c60 00000080 		.word	-2147483648
 15454 0c64 0920703E 		.word	1047535625
 15455 0c68 08010000 		.word	264
 15456 0c6c 00000080 		.word	-2147483648
 15457 0c70 0A20703E 		.word	1047535626
 15458 0c74 08010000 		.word	264
 15459 0c78 00000080 		.word	-2147483648
 15460 0c7c 0380722E 		.word	779255811
 15461 0c80 02010020 		.word	536871170
 15462 0c84 60000080 		.word	-2147483552
 15463 0c88 0B000000 		.word	11
 15464 0c8c 00000000 		.word	0
 15465 0c90 00010080 		.word	-2147483392
 15466 0c94 0460722E 		.word	779247620
 15467 0c98 02010024 		.word	603980034
 15468 0c9c 90000080 		.word	-2147483504
 15469 0ca0 0D000000 		.word	13
 15470 0ca4 00000000 		.word	0
 15471 0ca8 00010080 		.word	-2147483392
 15472 0cac 0460722E 		.word	779247620
 15473 0cb0 02010024 		.word	603980034
 15474 0cb4 90000080 		.word	-2147483504
 15475 0cb8 0C000000 		.word	12
 15476 0cbc 00000000 		.word	0
 15477 0cc0 00010080 		.word	-2147483392
 15478 0cc4 0380722E 		.word	779255811
 15479 0cc8 02010020 		.word	536871170
 15480 0ccc 60000080 		.word	-2147483552
 15481 0cd0 0E000000 		.word	14
 15482 0cd4 00000000 		.word	0
 15483 0cd8 00010080 		.word	-2147483392
 15484 0cdc 00000000 		.word	0
 15485 0ce0 00000000 		.word	0
 15486 0ce4 00000000 		.word	0
 15487 0ce8 00000000 		.word	0
 15488 0cec 00000000 		.word	0
 15489 0cf0 00000000 		.word	0
 15492              	CyFxGpifTransition:
 15493 0cf4 0000     		.short	0
 15494 0cf6 5555     		.short	21845
 15495 0cf8 8888     		.short	-30584
 15496 0cfa AAAA     		.short	-21846
 15497 0cfc 3333     		.short	13107
 15498 0cfe 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15499              		.align	2
 15500              	.LC0:
 15501 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15501      706F732D 
 15501      74696D65 
 15501      72202564 
 15501      2025640D 
 15502 0016 0000     		.space	2
 15503              	.LC1:
 15504 0018 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15504      7065722D 
 15504      74696D65 
 15504      72202564 
 15504      0D0A00
 15505 002b 00       		.space	1
 15506              	.LC2:
 15507 002c 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15507      636F6D6D 
 15507      616E6420 
 15507      71756575 
 15507      65206973 
 15508 004f 00       		.space	1
 15509              	.LC3:
 15510 0050 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15510      6F207374 
 15510      7265616D 
 15510      20474554 
 15510      20726571 
 15511 0075 000000   		.space	3
 15512              	.LC4:
 15513 0078 436C6561 		.ascii	"Clear feature request detected (fake)..\015\012\000"
 15513      72206665 
 15513      61747572 
 15513      65207265 
 15513      71756573 
 15514 00a2 0000     		.space	2
 15515              	.LC5:
 15516 00a4 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15516      74686520 
 15516      76696465 
 15516      6F206D6F 
 15516      64652066 
 15517 00c5 000000   		.space	3
 15518              	.LC6:
 15519 00c8 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15519      74686520 
 15519      76696465 
 15519      6F206D6F 
 15519      64652066 
 15520 00ed 000000   		.space	3
 15521              	.LC7:
 15522 00f0 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15522      43595F46 
 15522      585F5556 
 15522      435F5354 
 15522      5245414D 
 15523 0116 0000     		.space	2
 15524              	.LC8:
 15525 0118 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15525      55564320 
 15525      7374696C 
 15525      6C205072 
 15525      6F622873 
 15526 0143 00       		.space	1
 15527              	.LC9:
 15528 0144 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15528      74686520 
 15528      7374696C 
 15528      6C206D6F 
 15528      64652066 
 15529 0165 000000   		.space	3
 15530              	.LC10:
 15531 0168 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15531      7374696C 
 15531      6C20636F 
 15531      6D6D6974 
 15531      20636F6E 
 15532              	.LC11:
 15533 0190 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15533      43595F46 
 15533      585F5556 
 15533      435F5354 
 15533      494C5F45 
 15534              	.LC12:
 15535 01b4 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15535      55564320 
 15535      7374696C 
 15535      6C207472 
 15535      69676765 
 15536 01dd 000000   		.space	3
 15537              	.LC13:
 15538 01e0 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15538      7374696C 
 15538      6C207472 
 15538      69676765 
 15538      7220636F 
 15539 0207 00       		.space	1
 15540              	.LC14:
 15541 0208 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15541      7220696E 
 15541      206D756C 
 15541      74696368 
 15541      616E6E65 
 15542 023b 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15542      2025782C 
 15542      20646D61 
 15542      446F6E65 
 15542      20256420 
 15543              	.LC15:
 15544 0254 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15544      5420656E 
 15544      636F756E 
 15544      74657265 
 15544      642E2E2E 
 15545              	.LC16:
 15546 0274 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15546      454E4420 
 15546      656E636F 
 15546      756E7465 
 15546      7265642E 
 15547 0296 0000     		.space	2
 15548              	.LC17:
 15549 0298 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15549      64697363 
 15549      6F6E6E65 
 15549      63746564 
 15549      2E2E2E30 
 15550 02b7 00       		.space	1
 15551              	.LC18:
 15552 02b8 626D5265 		.ascii	"bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wInd"
 15552      71547970 
 15552      65203D20 
 15552      30782578 
 15552      20625265 
 15553 02eb 6578203D 		.ascii	"ex = 0x%x wLength = 0x%x isflag 0x%x\015\012\000"
 15553      20307825 
 15553      7820774C 
 15553      656E6774 
 15553      68203D20 
 15554 0312 0000     		.space	2
 15555              	.LC19:
 15556 0314 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15556      43595F46 
 15556      585F5556 
 15556      435F5649 
 15556      44454F5F 
 15557 0347 0A00     		.ascii	"\012\000"
 15558 0349 000000   		.space	3
 15559              	.LC20:
 15560 034c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15560      43595F46 
 15560      585F5556 
 15560      435F5649 
 15560      44454F5F 
 15561 037f 00       		.ascii	"\000"
 15562              	.LC21:
 15563 0380 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15563      726E6174 
 15563      65207365 
 15563      7474696E 
 15563      6720302E 
 15564              	.LC22:
 15565 0398 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15565      72206665 
 15565      61747572 
 15565      65207265 
 15565      71756573 
 15566 03bb 00       		.space	1
 15567              	.LC23:
 15568 03bc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15568      49324320 
 15568      636F6D6D 
 15568      616E6420 
 15568      69732030 
 15569 03ef 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15569      78257820 
 15569      30782578 
 15569      20307825 
 15569      78203078 
 15570              	.LC24:
 15571 0408 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15571      49324320 
 15571      636F6D6D 
 15571      616E6420 
 15571      73657474 
 15572 042e 0000     		.space	2
 15573              	.LC25:
 15574 0430 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15574      73687574 
 15574      74657220 
 15574      73657420 
 15574      76616C75 
 15575 045a 0000     		.space	2
 15576              	.LC26:
 15577 045c 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 15577      20736875 
 15577      74746572 
 15577      20737065 
 15577      65642E20 
 15578 0481 000000   		.space	3
 15579              	.LC27:
 15580 0484 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 15580      20736875 
 15580      74746572 
 15580      20737065 
 15580      6564322E 
 15581 04aa 0000     		.space	2
 15582              	.LC28:
 15583 04ac 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 15583      206C6967 
 15583      68742063 
 15583      6F6D7065 
 15583      6E736174 
 15584 04df 25640D0A 		.ascii	"%d\015\012\000"
 15584      00
 15585              	.LC29:
 15586 04e4 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15586      49324320 
 15586      63757272 
 15586      656E7420 
 15586      64617461 
 15587 0517 64202564 		.ascii	"d %d\015\012\000"
 15587      0D0A00
 15588 051e 0000     		.space	2
 15589              	.LC30:
 15590 0520 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15590      26414743 
 15590      2073656E 
 15590      7420746F 
 15590      20686F73 
 15591 0546 0000     		.space	2
 15592              	.LC31:
 15593 0548 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15593      73687574 
 15593      74657226 
 15593      6578706F 
 15593      73757265 
 15594 0573 00       		.space	1
 15595              	.LC32:
 15596 0574 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15596      26414743 
 15596      20676F74 
 15596      74656E20 
 15596      66726F6D 
 15597 05a5 0A00     		.ascii	"\012\000"
 15598 05a7 00       		.space	1
 15599              	.LC33:
 15600 05a8 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15600      74657220 
 15600      6C657665 
 15600      6C20676F 
 15600      7474656E 
 15601 05db 25640D0A 		.ascii	"%d\015\012\000"
 15601      00
 15602              	.LC34:
 15603 05e0 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15603      75656E63 
 15603      79207365 
 15603      7474696E 
 15603      67206973 
 15604 05fe 0000     		.space	2
 15605              	.LC35:
 15606 0600 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15606      20746865 
 15606      20766964 
 15606      656F206D 
 15606      6F646520 
 15607 0622 0000     		.space	2
 15608              	.LC36:
 15609 0624 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15609      67657420 
 15609      64617461 
 15609      2066726F 
 15609      6D20686F 
 15610 0651 000000   		.space	3
 15611              	.LC37:
 15612 0654 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15612      52657175 
 15612      65737420 
 15612      30782578 
 15612      20706172 
 15613 0687 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15613      6E642074 
 15613      6F20686F 
 15613      73742030 
 15613      78257820 
 15614 06a2 0000     		.space	2
 15615              	.LC38:
 15616 06a4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15616      204F7020 
 15616      72656365 
 15616      69766573 
 15616      20284354 
 15617 06cb 00       		.space	1
 15618              	.LC39:
 15619 06cc 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15619      756C7420 
 15619      73656C65 
 15619      63746F72 
 15619      20284354 
 15620 06ee 0000     		.space	2
 15621              	.LC40:
 15622 06f0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15622      756C7420 
 15622      72657175 
 15622      65737420 
 15622      28435429 
 15623 0711 000000   		.space	3
 15624              	.LC41:
 15625 0714 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15625      52657175 
 15625      65737420 
 15625      30782578 
 15625      20706172 
 15626 0747 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15626      20307825 
 15626      78202F20 
 15626      73656E64 
 15626      20746F20 
 15627 0774 00       		.ascii	"\000"
 15628 0775 000000   		.space	3
 15629              	.LC42:
 15630 0778 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15630      73657420 
 15630      64656620 
 15630      64617461 
 15630      20307825 
 15631 0797 00       		.space	1
 15632              	.LC43:
 15633 0798 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15633      73657420 
 15633      64656620 
 15633      64617461 
 15633      20307825 
 15634 07cb 2E0D0A00 		.ascii	".\015\012\000"
 15635 07cf 00       		.space	1
 15636              	.LC44:
 15637 07d0 4572726F 		.ascii	"Error handler...\015\012\000"
 15637      72206861 
 15637      6E646C65 
 15637      722E2E2E 
 15637      0D0A00
 15638 07e3 00       		.space	1
 15639              	.LC45:
 15640 07e4 55415254 		.ascii	"UART initialization failed!\012\000"
 15640      20696E69 
 15640      7469616C 
 15640      697A6174 
 15640      696F6E20 
 15641 0801 000000   		.space	3
 15642              	.LC46:
 15643 0804 49324320 		.ascii	"I2C initialization failed!\012\000"
 15643      696E6974 
 15643      69616C69 
 15643      7A617469 
 15643      6F6E2066 
 15644              	.LC47:
 15645 0820 49324320 		.ascii	"I2C configuration failed!\012\000"
 15645      636F6E66 
 15645      69677572 
 15645      6174696F 
 15645      6E206661 
 15646 083b 00       		.space	1
 15647              	.LC48:
 15648 083c 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15648      43726561 
 15648      74652045 
 15648      76656E74 
 15648      20666169 
 15649 0866 0000     		.space	2
 15650              	.LC49:
 15651 0868 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15651      20496E69 
 15651      74206661 
 15651      696C6564 
 15651      2C204572 
 15652 088b 00       		.space	1
 15653              	.LC50:
 15654 088c 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15654      204F7665 
 15654      72726964 
 15654      65206661 
 15654      696C6564 
 15655 08b3 00       		.space	1
 15656              	.LC51:
 15657 08b4 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15657      28323029 
 15657      204F7665 
 15657      72726964 
 15657      65206661 
 15658 08df 00       		.space	1
 15659              	.LC52:
 15660 08e0 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15660      28323429 
 15660      204F7665 
 15660      72726964 
 15660      65206661 
 15661 090b 00       		.space	1
 15662              	.LC53:
 15663 090c 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15663      20536574 
 15663      20287265 
 15663      73657420 
 15663      32322920 
 15664 093e 00       		.ascii	"\000"
 15665 093f 00       		.space	1
 15666              	.LC54:
 15667 0940 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15667      20536574 
 15667      2028706F 
 15667      77657220 
 15667      32302920 
 15668 0972 00       		.ascii	"\000"
 15669 0973 00       		.space	1
 15670              	.LC55:
 15671 0974 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15671      20536574 
 15671      2028736E 
 15671      61702073 
 15671      686F7420 
 15672 09a7 25640A00 		.ascii	"%d\012\000"
 15673 09ab 00       		.space	1
 15674              	.LC56:
 15675 09ac 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15675      46756E63 
 15675      74696F6E 
 15675      20466169 
 15675      6C656420 
 15676 09db 00       		.space	1
 15677              	.LC57:
 15678 09dc 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15678      46756E63 
 15678      74696F6E 
 15678      20466169 
 15678      6C656420 
 15679 0a0b 00       		.space	1
 15680              	.LC58:
 15681 0a0c 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15681      53657420 
 15681      456E6470 
 15681      6F696E74 
 15681      20636F6E 
 15682 0a3c 00       		.ascii	"\000"
 15683 0a3d 000000   		.space	3
 15684              	.LC59:
 15685 0a40 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15685      496E7465 
 15685      72727570 
 15685      74205374 
 15685      61747573 
 15686 0a73 20436F64 		.ascii	" Code = %d\012\000"
 15686      65203D20 
 15686      25640A00 
 15687 0a7f 00       		.space	1
 15688              	.LC60:
 15689 0a80 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15689      65642074 
 15689      6F20616C 
 15689      6C6F6361 
 15689      7465206D 
 15690 0ab3 65720D0A 		.ascii	"er\015\012\000"
 15690      00
 15691              	.LC61:
 15692 0ab8 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15692      4368616E 
 15692      6E656C20 
 15692      43726561 
 15692      74696F6E 
 15693 0ae6 0000     		.space	2
 15694              	.LC62:
 15695 0ae8 44656275 		.ascii	"Debug Command endpoint config failed, Error code = "
 15695      6720436F 
 15695      6D6D616E 
 15695      6420656E 
 15695      64706F69 
 15696 0b1b 25640A00 		.ascii	"%d\012\000"
 15697 0b1f 00       		.space	1
 15698              	.LC63:
 15699 0b20 44656275 		.ascii	"Debug Response endpoint config failed, Error code ="
 15699      67205265 
 15699      73706F6E 
 15699      73652065 
 15699      6E64706F 
 15700 0b53 2025640A 		.ascii	" %d\012\000"
 15700      00
 15701              	.LC64:
 15702 0b58 44656275 		.ascii	"Debug Command channel create failed, Error code = %"
 15702      6720436F 
 15702      6D6D616E 
 15702      64206368 
 15702      616E6E65 
 15703 0b8b 640A00   		.ascii	"d\012\000"
 15704 0b8e 0000     		.space	2
 15705              	.LC65:
 15706 0b90 44656275 		.ascii	"Debug channel SetXfer failed, Error code = %d\012\000"
 15706      67206368 
 15706      616E6E65 
 15706      6C205365 
 15706      74586665 
 15707 0bbf 00       		.space	1
 15708              	.LC66:
 15709 0bc0 44656275 		.ascii	"Debug Response channel create failed, Error code = "
 15709      67205265 
 15709      73706F6E 
 15709      73652063 
 15709      68616E6E 
 15710 0bf3 25640A00 		.ascii	"%d\012\000"
 15711 0bf7 00       		.space	1
 15712              	.LC67:
 15713 0bf8 4661696C 		.ascii	"Failed to allocate memory for debug buffer\015\012\000"
 15713      65642074 
 15713      6F20616C 
 15713      6C6F6361 
 15713      7465206D 
 15714 0c25 000000   		.space	3
 15715              	.LC68:
 15716 0c28 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15716      436F6E6E 
 15716      65637420 
 15716      6661696C 
 15716      65642C20 
 15717 0c4d 000000   		.space	3
 15718              	.LC69:
 15719 0c50 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15719      74686520 
 15719      76696465 
 15719      6F206D6F 
 15719      64652066 
 15720 0c72 0000     		.space	2
 15721              	.LC70:
 15722 0c74 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15722      4368616E 
 15722      6E656C20 
 15722      52657365 
 15722      74204661 
 15723 0c9f 00       		.space	1
 15724              	.LC71:
 15725 0ca0 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15725      4368616E 
 15725      6E656C20 
 15725      53657420 
 15725      5472616E 
 15726 0cd1 00       		.ascii	"\000"
 15727 0cd2 0000     		.space	2
 15728              	.LC72:
 15729 0cd4 636C6561 		.ascii	"clear feature stream set %x\012\000"
 15729      72206665 
 15729      61747572 
 15729      65207374 
 15729      7265616D 
 15730 0cf1 000000   		.space	3
 15731              	.LC73:
 15732 0cf4 70726520 		.ascii	"pre wait stream set %x\012\000"
 15732      77616974 
 15732      20737472 
 15732      65616D20 
 15732      73657420 
 15733              	.LC74:
 15734 0d0c 706F7374 		.ascii	"post wait stream set %x\012\000"
 15734      20776169 
 15734      74207374 
 15734      7265616D 
 15734      20736574 
 15735 0d25 000000   		.space	3
 15736              	.LC75:
 15737 0d28 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15737      4368616E 
 15737      6E656C20 
 15737      53657420 
 15737      5472616E 
 15738 0d59 0A00     		.ascii	"\012\000"
 15739 0d5b 00       		.space	1
 15740              	.LC76:
 15741 0d5c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15741      75706572 
 15741      20677069 
 15741      6600
 15742 0d6a 0000     		.space	2
 15743              	.LC77:
 15744 0d6c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15744      69676820 
 15744      67706966 
 15744      00
 15745 0d79 000000   		.space	3
 15746              	.LC78:
 15747 0d7c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15747      696E6720 
 15747      47504946 
 15747      20436F6E 
 15747      66696775 
 15748 0daf 0A00     		.ascii	"\012\000"
 15749 0db1 000000   		.space	3
 15750              	.LC79:
 15751 0db4 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15751      74696E67 
 15751      20475049 
 15751      46207374 
 15751      61746520 
 15752 0de7 0D0A00   		.ascii	"\015\012\000"
 15753 0dea 0000     		.space	2
 15754              	.LC80:
 15755 0dec 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15755      64656661 
 15755      756C7420 
 15755      73657475 
 15755      70207265 
 15756              	.LC81:
 15757 0e18 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15757      65642074 
 15757      6F207365 
 15757      6E642069 
 15757      6E746572 
 15758 0e49 0A00     		.ascii	"\012\000"
 15759 0e4b 00       		.space	1
 15760              	.LC82:
 15761 0e4c 4661696C 		.ascii	"Failed to receive debug command, Error code = %d\015"
 15761      65642074 
 15761      6F207265 
 15761      63656976 
 15761      65206465 
 15762 0e7d 0A00     		.ascii	"\012\000"
 15763 0e7f 00       		.space	1
 15764              	.LC83:
 15765 0e80 44656275 		.ascii	"Debug interface conut %d data %d %d %d\015\012\000"
 15765      6720696E 
 15765      74657266 
 15765      61636520 
 15765      636F6E75 
 15766 0ea9 000000   		.space	3
 15767              	.LC84:
 15768 0eac 44656275 		.ascii	"Debug responsR conut %d data %d %d %d\015\012\000"
 15768      67207265 
 15768      73706F6E 
 15768      73522063 
 15768      6F6E7574 
 15769              	.LC85:
 15770 0ed4 44656275 		.ascii	"Debug write %d data %d %d %d\015\012\000"
 15770      67207772 
 15770      69746520 
 15770      25642064 
 15770      61746120 
 15771 0ef3 00       		.space	1
 15772              	.LC86:
 15773 0ef4 44656275 		.ascii	"Debug respons conut %d data %d %d %d\015\012\000"
 15773      67207265 
 15773      73706F6E 
 15773      7320636F 
 15773      6E757420 
 15774 0f1b 00       		.space	1
 15775              	.LC87:
 15776 0f1c 4661696C 		.ascii	"Failed to free up command OUT EP buffer, Error code"
 15776      65642074 
 15776      6F206672 
 15776      65652075 
 15776      7020636F 
 15777 0f4f 203D2025 		.ascii	" = %d\015\012\000"
 15777      640D0A00 
 15778 0f57 00       		.space	1
 15779              	.LC88:
 15780 0f58 4661696C 		.ascii	"Failed to send debug response, Error code = %d\015\012"
 15780      65642074 
 15780      6F207365 
 15780      6E642064 
 15780      65627567 
 15781 0f88 00       		.ascii	"\000"
 15782 0f89 000000   		.space	3
 15783              	.LC89:
 15784 0f8c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15784      6F6D6D69 
 15784      74656F66 
 15784      20737461 
 15784      7465203D 
 15785              	.LC90:
 15786 0fa4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15786      6E656C20 
 15786      53657420 
 15786      57726170 
 15786      55702066 
 15787 0fd1 000000   		.space	3
 15788              	.LC91:
 15789 0fd4 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15789      69742045 
 15789      4F462066 
 15789      61696C65 
 15789      64210D0A 
 15790 0fe9 000000   		.space	3
 15791              	.LC92:
 15792 0fec 49324363 		.ascii	"I2CcmdQue\000"
 15792      6D645175 
 15792      6500
 15793 0ff6 0000     		.space	2
 15794              	.LC93:
 15795 0ff8 33303A55 		.ascii	"30:UVC App Thread\000"
 15795      56432041 
 15795      70702054 
 15795      68726561 
 15795      6400
 15796 100a 0000     		.space	2
 15797              	.LC94:
 15798 100c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15798      56432041 
 15798      70702045 
 15798      50302054 
 15798      68726561 
 15799 1022 0000     		.space	2
 15800              	.LC95:
 15801 1024 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15801      32432041 
 15801      70702043 
 15801      54524C20 
 15801      54687265 
 15802 103b 00       		.bss
 15803              		.align	2
 15804              		.set	.LANCHOR0,. + 0
 15807              	glFxUVCEvent:
 15808 0000 00000000 		.space	40
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15811              	glEp0Buffer:
 15812 0028 00000000 		.space	32
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15815              	usbSpeed:
 15816 0048 00       		.space	1
 15817 0049 000000   		.space	3
 15820              	glCommitCtrl:
 15821 004c 00000000 		.space	32
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15824              	gpif_initialized:
 15825 006c 00000000 		.space	4
 15828              	streamingStarted:
 15829 0070 00000000 		.space	4
 15832              	clearFeatureRqtReceived:
 15833 0074 00000000 		.space	4
 15836              	is60Hz:
 15837 0078 00000000 		.space	4
 15840              	setRes:
 15841 007c 00       		.space	1
 15844              	setstilRes:
 15845 007d 00       		.space	1
 15848              	stiflag:
 15849 007e 00       		.space	1
 15850 007f 00       		.space	1
 15853              	fb:
 15854 0080 0000     		.space	2
 15857              	pb:
 15858 0082 0000     		.space	2
 15861              	pbc:
 15862 0084 0000     		.space	2
 15863 0086 0000     		.space	2
 15866              	hitFV:
 15867 0088 00000000 		.space	4
 15870              	prodCount:
 15871 008c 0000     		.space	2
 15874              	consCount:
 15875 008e 0000     		.space	2
 15878              	debugData:
 15879 0090 00000000 		.space	128
 15879      00000000 
 15879      00000000 
 15879      00000000 
 15879      00000000 
 15882              	isUsbConnected:
 15883 0110 00000000 		.space	4
 15886              	I2CCMDArry:
 15887 0114 00000000 		.space	12
 15887      00000000 
 15887      00000000 
 15890              	value:
 15891 0120 00000000 		.space	64
 15891      00000000 
 15891      00000000 
 15891      00000000 
 15891      00000000 
 15894              	curFlag:
 15895 0160 00000000 		.space	64
 15895      00000000 
 15895      00000000 
 15895      00000000 
 15895      00000000 
 15898              	CamMode:
 15899 01a0 00       		.space	1
 15902              	IMcount.8206:
 15903 01a1 00       		.space	1
 15904 01a2 0000     		.space	2
 15907              	uvcAppThread:
 15908 01a4 00000000 		.space	168
 15908      00000000 
 15908      00000000 
 15908      00000000 
 15908      00000000 
 15911              	uvcAppEP0Thread:
 15912 024c 00000000 		.space	168
 15912      00000000 
 15912      00000000 
 15912      00000000 
 15912      00000000 
 15915              	i2cAppThread:
 15916 02f4 00000000 		.space	168
 15916      00000000 
 15916      00000000 
 15916      00000000 
 15916      00000000 
 15919              	stream_start:
 15920 039c 00000000 		.space	4
 15923              	streamingRecove:
 15924 03a0 00000000 		.space	4
 15927              	pbcpbak:
 15928 03a4 0000     		.space	2
 15931              	pbcbak:
 15932 03a6 0000     		.space	2
 15935              	pbbak:
 15936 03a8 0000     		.space	2
 15939              	fbbak:
 15940 03aa 0000     		.space	2
 15943              	testSnap:
 15944 03ac 00       		.space	1
 15945 03ad 000000   		.text
 15946              	.Letext0:
 15947              		.file 2 "c:\\program files\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\stdint.
 15948              		.file 3 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3types.
 15949              		.file 4 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx3_api.
 15950              		.file 5 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_port.h"
 15951              		.file 6 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_api.h"
 15952              		.file 7 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3dma.h"
 15953              		.file 8 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3system
 15954              		.file 9 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3error.
 15955              		.file 10 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3usbco
 15956              		.file 11 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3usb.h
 15957              		.file 12 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3lpp.h
 15958              		.file 13 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3uart.
 15959              		.file 14 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3gpif.
 15960              		.file 15 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3i2c.h
 15961              		.file 16 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3gpio.
 15962              		.file 17 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3pib.h
 15963              		.file 18 "../sensor.h"
 15964              		.file 19 "../cmdqu.h"
 15965              		.file 20 "../uvc.h"
 15966              		.file 21 "../cyfxgpif2config.h"
 15967              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15968              		.file 23 "C:\\Program Files\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3os.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:66     .text:0000003c I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:235    .text:0000019c $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:241    .text:000001ac $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:354    .text:0000027c $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:365    .text:0000029c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:367    .text:0000029c CyFxUvcAppDebugCallback
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:393    .text:000002b4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:399    .text:000002b8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:401    .text:000002b8 UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:765    .text:000005fc $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:772    .text:0000060c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:791    .text:00000644 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:798    .text:00000654 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1194   .text:00000a4c $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1218   .text:00000aa0 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1221   .text:00000aa0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1456   .text:00000c30 $d
                            *COM*:00000038 imgHdMux
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1466   .text:00000c4c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1468   .text:00000c4c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1696   .text:00000dd4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1707   .text:00000de4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:1709   .text:00000de4 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2152   .text:00001158 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2172   .text:0000118c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2175   .text:0000118c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2527   .text:00001498 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2536   .text:000014b0 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2539   .text:000014b0 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2607   .text:0000152c getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2632   .text:00001548 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2645   .text:00001570 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2746   .text:00001648 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2754   .text:0000165c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2757   .text:0000165c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2949   .text:000017d4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:2991   .text:00001870 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:3044   .text:000018e8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:3085   .text:00001984 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:4491   .text:000025f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:4514   .text:00002644 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:4885   .text:00002988 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:4891   .text:00002998 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:5450   .text:00002e4c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:5597   .text:00002f74 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:5610   .text:00002f9c $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6026   .text:000033cc $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6037   .text:000033ec $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6307   .text:00003680 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6319   .text:000036a4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6322   .text:000036a4 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6623   .text:00003960 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6630   .text:00003970 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6633   .text:00003970 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6677   .text:000039b4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6682   .text:000039bc $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6685   .text:000039bc CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6713   .text:000039d8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6717   .text:000039dc $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:6720   .text:000039dc UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:7732   .text:00004244 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:7738   .text:00004254 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:8281   .text:000046c8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12883  .text:00006c68 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glDebugCmdChannel
                            *COM*:000000ac glDebugRspChannel
                            *COM*:00000004 glDebugRspBuffer
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:8356   .text:000047e0 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:8359   .text:000047e0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:8417   .text:00004848 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:8425   .text:00004858 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:10183  .text:00005788 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:10214  .text:000057e8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:10600  .text:00005b50 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:10615  .text:00005b70 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12148  .text:00006610 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12163  .text:00006620 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12871  .text:00006c50 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12880  .text:00006c68 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12915  .text:00006c9c $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12928  .text:00006cc8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12933  .text:00006cd8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12938  .text:00006ce8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12986  .text:00006d40 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12996  .text:00006d54 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:12999  .text:00006d54 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13152  .text:00006e9c $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13169  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13172  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14454  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14439  .data:000004e0 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14360  .data:0000049c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14424  .data:000004d4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14330  .data:00000480 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14390  .data:000004b8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15828  .bss:00000070 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15923  .bss:000003a0 streamingRecove
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15832  .bss:00000074 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15815  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15882  .bss:00000110 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15927  .bss:000003a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15931  .bss:000003a6 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15935  .bss:000003a8 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15939  .bss:000003aa fbbak
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15861  .bss:00000084 pbc
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15857  .bss:00000082 pb
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15853  .bss:00000080 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15943  .bss:000003ac testSnap
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14962  .data:0000070c snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13348  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14967  .data:00000710 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15046  .data:00000840 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15197  .data:000008d4 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15308  .data:00000a84 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13335  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15319  .data:00000a94 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15398  .data:00000bc4 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15417  .data:00000bd4 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15492  .data:00000cf4 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13316  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13320  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13360  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13364  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:13687  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14419  .data:000004d2 ROIMode
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14469  .data:000004f8 dbgIdx
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14473  .data:000004f9 valIdx
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14478  .data:000004fc EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14500  .data:00000510 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14522  .data:00000524 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14544  .data:00000538 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14566  .data:0000054c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14588  .data:00000560 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14595  .data:00000564 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14617  .data:00000578 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:14639  .data:0000058c CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15499  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15803  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15807  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15811  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15820  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15824  .bss:0000006c gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15836  .bss:00000078 is60Hz
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15840  .bss:0000007c setRes
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15844  .bss:0000007d setstilRes
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15848  .bss:0000007e stiflag
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15866  .bss:00000088 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15870  .bss:0000008c prodCount
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15874  .bss:0000008e consCount
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15878  .bss:00000090 debugData
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15886  .bss:00000114 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15890  .bss:00000120 value
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15894  .bss:00000160 curFlag
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15898  .bss:000001a0 CamMode
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15902  .bss:000001a1 IMcount.8206
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15907  .bss:000001a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15911  .bss:0000024c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15915  .bss:000002f4 i2cAppThread
C:\Users\wcheng\AppData\Local\Temp\cc9DCI1Q.s:15919  .bss:0000039c stream_start
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
_txe_timer_create
_tx_time_get
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
SensorRead2B
SensorWrite2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PUsbSetEpPktMode
CyU3PDmaChannelSetXfer
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PDmaChannelGetBuffer
CyU3PDmaChannelDiscardBuffer
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PGpioSimpleGetValue
SensorRead
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
