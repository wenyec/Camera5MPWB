   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 0xFF,				//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x12/*ShutterFineReg*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl EXTAGCMaxLimit =
1083:../uvc.c      **** 		{AGCMaxLimtReg,			//Reg1: the command register address1
1084:../uvc.c      **** 		 AGCMaxLimtReg,			//Reg2: the command register address2
1085:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1086:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1087:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1088:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1089:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1090:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1091:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1092:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1093:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1094:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1095:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1096:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1097:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1098:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1099:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1100:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1101:../uvc.c      **** 		}; //
1102:../uvc.c      **** 
1103:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1104:../uvc.c      **** 		&EXTShutter,
1105:../uvc.c      **** 		&EXTSensUp,
1106:../uvc.c      **** 		&EXTMirror,
1107:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1108:../uvc.c      **** 		&EXT3DNoiseLev,
1109:../uvc.c      **** 		&EXTDayNightMode,
1110:../uvc.c      **** 		&EXTDayNightdely,
1111:../uvc.c      **** 		&EXTDayNightlev,
1112:../uvc.c      **** 		&EXTNightDaylev,
1113:../uvc.c      **** 		&EXTAexModGainlev,
1114:../uvc.c      **** 		&EXTExpReflev,
1115:../uvc.c      **** 		&EXTShutlev,
1116:../uvc.c      **** 		&EXTCamMode,
1117:../uvc.c      **** 		0, //&EXTSnapshot,
1118:../uvc.c      **** 		&EXTSensorPare,
1119:../uvc.c      **** 		&EXTI2Ccmd,
1120:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1121:../uvc.c      **** 		0, //&Ext1CtlID1,
1122:../uvc.c      **** 		0, //&Ext1CtlID2,
1123:../uvc.c      **** 		0, //&Ext1CtlID3,
1124:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1125:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1126:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1127:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1128:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1129:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1130:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1131:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1132:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1133:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1134:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1135:../uvc.c      **** 		&EXTAGCMaxLimit, 	// AGC Maximum Gain limitation &Ext1AGCMaxLimetCtlID15,
1136:../uvc.c      **** 		0
1137:../uvc.c      **** };
1138:../uvc.c      **** 
1139:../uvc.c      **** #endif //end of the new control structure
1140:../uvc.c      **** 
1141:../uvc.c      **** #ifndef CAM720
1142:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1143:../uvc.c      **** #else
1144:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1145:../uvc.c      **** #endif
1146:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1147:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1148:../uvc.c      **** 
1149:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1150:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1151:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1152:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1153:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1154:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1155:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1156:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1157:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1158:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1159:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1160:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1161:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1162:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1163:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1164:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1165:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1166:../uvc.c      **** };
1167:../uvc.c      **** 
1168:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1169:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1170:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1171:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1172:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1173:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1174:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1175:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1176:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1177:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1178:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1179:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1180:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1181:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1182:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1183:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1184:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1185:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1186:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1187:../uvc.c      **** };
1188:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1189:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1190:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1191:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1192:../uvc.c      **** /*
1193:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1194:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1195:../uvc.c      ****  */
1196:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1197:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1198:../uvc.c      **** };
1199:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1200:../uvc.c      **** 		0
1201:../uvc.c      **** };
1202:../uvc.c      **** 
1203:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1204:../uvc.c      **** 
1205:../uvc.c      **** void I2CCmdHandler(){
1206:../uvc.c      **** 	uint8_t buf[2];
1207:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1208:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1209:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1210:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1211:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1212:../uvc.c      **** 	uint8_t i;
1213:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1214:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1215:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1216:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1217:../uvc.c      **** 	{
1218:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1219:../uvc.c      **** 		if(is60Hz==CyFalse)
1220:../uvc.c      **** 			{
1221:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1224:../uvc.c      **** 
1225:../uvc.c      **** 	}
1226:../uvc.c      **** 	if(CmdType == 0)//I2C read
1227:../uvc.c      **** 	{
1228:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1229:../uvc.c      **** #if 0 //for debugging
1230:../uvc.c      **** 		/* test still image operation */
1231:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1232:../uvc.c      **** 			snapButFlag = 0; //press
1233:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1234:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1235:../uvc.c      **** 			snapButFlag = 0xf; //release
1236:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1237:../uvc.c      **** 		}
1238:../uvc.c      **** 
1239:../uvc.c      **** 		/* end of the test */
1240:../uvc.c      **** #endif
1241:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1242:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1243:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1244:../uvc.c      **** 				if(CmdDataLen == 2){
1245:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1246:../uvc.c      **** 				}
1247:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1248:../uvc.c      **** 		}else{//not support currently
1249:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1250:../uvc.c      **** 		}
1251:../uvc.c      **** 	}else if(CmdType == 1){
1252:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1253:../uvc.c      **** 			if(CmdRegLen == 2){
1254:../uvc.c      **** 				for(i = 0; i<4; i++)
1255:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1256:../uvc.c      **** 			}
1257:../uvc.c      **** 			else{
1258:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1259:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1260:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1261:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1262:../uvc.c      **** 				}
1263:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1264:../uvc.c      **** 			}
1265:../uvc.c      **** 		}else{//not support currently
1266:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1267:../uvc.c      **** 		}
1268:../uvc.c      **** 
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /************************************
1273:../uvc.c      ****  * set Iris mode
1274:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1275:../uvc.c      ****  */
1276:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1277:../uvc.c      **** 	uint8_t dataIdx = 0;
1278:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1280:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1281:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1282:../uvc.c      **** }
1283:../uvc.c      **** 
1284:../uvc.c      **** 
1285:../uvc.c      **** 
1286:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1287:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1288:../uvc.c      **** 	uint16_t NumLn;
1289:../uvc.c      **** 	uint16_t fRate, shutTm;
1290:../uvc.c      **** 	uint8_t LnVal;
1291:../uvc.c      **** 	switch (Data){
1292:../uvc.c      **** 	case 1:
1293:../uvc.c      **** 	case 2:
1294:../uvc.c      **** 	case 3:
1295:../uvc.c      **** 	case 4:
1296:../uvc.c      **** 	case 5:
1297:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1298:../uvc.c      **** 		fRate = 30;
1299:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1300:../uvc.c      **** 		if(NumLn > 1944)
1301:../uvc.c      **** 			NumLn =1944;
1302:../uvc.c      **** 		else if(NumLn < 8)
1303:../uvc.c      **** 			NumLn = 8;
1304:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1305:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1306:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	case 6:
1309:../uvc.c      **** 	case 7:
1310:../uvc.c      **** 	case 8:
1311:../uvc.c      **** 	case 9:
1312:../uvc.c      **** 	case 10:
1313:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1314:../uvc.c      **** 		fRate = 30;
1315:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1316:../uvc.c      **** 		if(NumLn > 1944)
1317:../uvc.c      **** 			NumLn =1944;
1318:../uvc.c      **** 		else if(NumLn < 8)
1319:../uvc.c      **** 			NumLn = 8;
1320:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1321:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1322:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1323:../uvc.c      **** 		break;
1324:../uvc.c      **** 	case 0: //auto
1325:../uvc.c      **** 	default:
1326:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1327:../uvc.c      **** 		LnVal = 1;
1328:../uvc.c      **** 		break;
1329:../uvc.c      **** 	}
1330:../uvc.c      **** 	return LnVal;
1331:../uvc.c      **** }
1332:../uvc.c      **** 
1333:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1334:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1335:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1336:../uvc.c      ****     uint16_t readCount;
1337:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1338:../uvc.c      ****     uint8_t devAdd;
1339:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1340:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1341:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1344:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1345:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1346:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1347:../uvc.c      ****     }else{
1348:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1349:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1350:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1351:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1352:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1353:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1354:../uvc.c      ****     }
1355:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1356:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1357:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1358:../uvc.c      **** #endif
1359:../uvc.c      ****     reqData = bRequest;
1360:../uvc.c      ****     /*
1361:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1362:../uvc.c      ****      */
1363:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1364:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1365:../uvc.c      ****     	//goto EndofSet;
1366:../uvc.c      ****     //}
1367:../uvc.c      ****     switch (bRequest)
1368:../uvc.c      **** 		 {
1369:../uvc.c      **** 
1370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1371:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1372:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1373:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1374:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1375:../uvc.c      **** 			  break;
1376:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1377:../uvc.c      **** 
1378:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1379:../uvc.c      **** 				 switch(CtrlID)
1380:../uvc.c      **** 				 {
1381:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1382:../uvc.c      **** 						 if(curFlag[CtrlID]){
1383:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1384:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1385:../uvc.c      **** 						 }else{
1386:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1387:../uvc.c      **** 							if(Data0&0x80)
1388:../uvc.c      **** 								glEp0Buffer[0] = 1;
1389:../uvc.c      **** 							else
1390:../uvc.c      **** 								glEp0Buffer[0] = 0;
1391:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1392:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1393:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1394:../uvc.c      **** 						 }
1395:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1396:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1397:../uvc.c      **** 						 break;
1398:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1399:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1400:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1401:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1402:../uvc.c      **** 			 	 		 }else{
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
1405:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
1406:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1408:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1409:../uvc.c      **** 			 	 		 }
1410:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1412:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1413:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1414:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], pEXTSenCtrl[C
1415:../uvc.c      **** 						 break;
1416:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1417:../uvc.c      **** #if 0 //not be used
1418:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1419:../uvc.c      **** 
1420:../uvc.c      **** 						 if(CamMode == 1){//720p
1421:../uvc.c      **** 							if(sendData >= 3){
1422:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1423:../uvc.c      **** 								sendData = 0; //set back to default
1424:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1425:../uvc.c      **** 							}
1426:../uvc.c      **** 							sendData += 4;
1427:../uvc.c      **** 						 }
1428:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1429:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1430:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1431:../uvc.c      **** #endif
1432:../uvc.c      **** 						 break;
1433:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1434:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1435:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1436:../uvc.c      **** 				 		 }
1437:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1439:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1440:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1441:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1442:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1443:../uvc.c      **** 	#endif
1444:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1445:../uvc.c      **** 				 		 {
1446:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1447:../uvc.c      **** 				 		 }
1448:../uvc.c      **** 				 		 break;
1449:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1450:../uvc.c      **** 			 	 		 sendData = SensorGetControl(RegAdd1, devAdd);
1451:../uvc.c      **** 			 	 		// sendData &= 0x70;
1452:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];// keep original data.
1453:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
1455:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1456:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1457:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1458:../uvc.c      **** 	 	 				 break;
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
1460:../uvc.c      **** 	 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1464:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1465:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1466:../uvc.c      **** 	 	 				 break;
1467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1468:../uvc.c      **** 				 	 case ExtShutCtlID0:
1469:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1470:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1471:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1472:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1473:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1474:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1475:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1476:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1477:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1478:../uvc.c      **** 			 	 	 case Ext1AGCMaxLimetCtlID15:
1479:../uvc.c      **** 					 case ExtExRefCtlID10:
1480:../uvc.c      **** 			 	 	 default:
1481:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1482:../uvc.c      **** 			 	 			 if(Len == 2)
1483:../uvc.c      **** 			 	 			 {
1484:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1486:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1487:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1488:../uvc.c      **** 			 	 			 }else if(Len == 4){
1489:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1490:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1491:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1492:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1493:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1494:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1495:../uvc.c      **** 			 	 			 }
1496:../uvc.c      **** 			 	 		 }else{
1497:../uvc.c      **** 			 	 			 if(Len == 2)
1498:../uvc.c      **** 			 	 			 {
1499:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1504:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1505:../uvc.c      **** 			 	 			 }else if(Len == 4){
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1514:../uvc.c      **** 			 	 			 }
1515:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1516:../uvc.c      **** 			 	 		 }
1517:../uvc.c      **** 			 	 		 break;
1518:../uvc.c      **** 			 	 }
1519:../uvc.c      **** 		 	 }
1520:../uvc.c      **** 		 	 else{
1521:../uvc.c      **** 				 switch(CtrlID)
1522:../uvc.c      **** 				 {
1523:../uvc.c      **** 					 case BrgtCtlID1:
1524:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1525:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1526:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1527:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1528:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1529:../uvc.c      **** 						 }else{
1530:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1531:../uvc.c      **** 						 }
1532:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1533:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1534:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1535:../uvc.c      **** 						 */
1536:../uvc.c      **** 						 if(curFlag[CtrlID]){
1537:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1538:../uvc.c      **** 						 }else{
1539:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1542:../uvc.c      **** 						 }
1543:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1544:../uvc.c      **** 						 /*//new implementation 8/23/2016
1545:../uvc.c      **** 						 if(Data0&0x80){
1546:../uvc.c      **** 							  Data0 = ~Data0;
1547:../uvc.c      **** 						  }else{
1548:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1549:../uvc.c      **** 						  }
1550:../uvc.c      **** 						  */
1551:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1554:../uvc.c      **** 						 break;
1555:../uvc.c      **** 					 case HueCtlID5:
1556:../uvc.c      **** 						 if(curFlag[CtrlID]){
1557:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1558:../uvc.c      **** 						 }else{
1559:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1560:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1562:../uvc.c      **** 						 }
1563:../uvc.c      **** 
1564:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1566:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1567:../uvc.c      **** 						 break;
1568:../uvc.c      **** 					 case MFreqCtlID4:
1569:../uvc.c      **** 
1570:../uvc.c      **** 						 if(curFlag[CtrlID]){
1571:../uvc.c      **** 
1572:../uvc.c      **** 							 if(is60Hz)
1573:../uvc.c      **** 								 glEp0Buffer[0] = 0;//CtrlParArry[CtrlID][13];//ext_control array;
1574:../uvc.c      **** 							 else
1575:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1576:../uvc.c      **** 
1577:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1578:../uvc.c      **** 						 }else{
1579:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1580:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1581:../uvc.c      **** 							//glEp0Buffer[0]++;
1582:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1584:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1585:../uvc.c      **** 						 }
1586:../uvc.c      **** 
1587:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1588:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1589:../uvc.c      **** 						 break;
1590:../uvc.c      **** 					 case WBTLevCtlID11:
1591:../uvc.c      **** 						 if(curFlag[CtrlID]){
1592:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1593:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1594:../uvc.c      **** 						 }else{
1595:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1600:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1601:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1602:../uvc.c      **** 						 }
1603:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1605:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1606:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1607:../uvc.c      **** 						 break;
1608:../uvc.c      **** 					 case ShapCtlID7:
1609:../uvc.c      **** 						 if(curFlag[CtrlID]){
1610:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1611:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1612:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1613:../uvc.c      **** 			 	 		 }else{
1614:../uvc.c      **** 			 	 			 if(Len == 2)
1615:../uvc.c      **** 			 	 			 {
1616:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1619:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1620:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1621:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1622:../uvc.c      **** 			 	 			 }
1623:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1624:../uvc.c      **** 			 	 		 }
1625:../uvc.c      **** 						 break;
1626:../uvc.c      **** 					 case BLCCtlID0:
1627:../uvc.c      **** 					 case ConsCtlID2:
1628:../uvc.c      **** 					 case WBTMdCtlID9:
1629:../uvc.c      **** 					 case SaturCtlID6:
1630:../uvc.c      **** 					 default:
1631:../uvc.c      **** 						 if(curFlag[CtrlID]){
1632:../uvc.c      **** 			 	 			 if(Len == 2)
1633:../uvc.c      **** 			 	 			 {
1634:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1635:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1637:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1638:../uvc.c      **** 			 	 			 }else if(Len == 4){
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1642:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1643:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1644:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1645:../uvc.c      **** 			 	 			 }
1646:../uvc.c      **** 			 	 		 }else{
1647:../uvc.c      **** 			 	 			 if(Len == 2)
1648:../uvc.c      **** 			 	 			 {
1649:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1652:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1653:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1654:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1655:../uvc.c      **** 			 	 			 }else if(Len == 4){
1656:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1658:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1660:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1661:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1662:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1663:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1664:../uvc.c      **** 			 	 			 }
1665:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1666:../uvc.c      **** 			 	 		 }
1667:../uvc.c      **** 						 break;
1668:../uvc.c      **** 				 }
1669:../uvc.c      **** 		 	 }
1670:../uvc.c      **** 
1671:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1672:../uvc.c      **** 
1673:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1674:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1675:../uvc.c      **** //#endif
1676:../uvc.c      **** 			  break;
1677:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1678:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1679:../uvc.c      **** 		 		 if(Len == 2){
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1683:../uvc.c      **** 		 		 }else //if(Len == 4)
1684:../uvc.c      **** 		 		 {
1685:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1687:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1689:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1690:../uvc.c      **** 				 }
1691:../uvc.c      **** 			 }else{
1692:../uvc.c      **** 			 	 if(Len ==2){
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1695:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1696:../uvc.c      **** 				 }else{
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1699:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1702:../uvc.c      **** 				 }
1703:../uvc.c      **** 			 }
1704:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1705:../uvc.c      **** 		 	 if(Len == 2){
1706:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1707:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1708:../uvc.c      **** 		 	 }else{
1709:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1710:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1711:../uvc.c      **** 			  }
1712:../uvc.c      **** 			  break;
1713:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1714:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1715:../uvc.c      **** 		 		 if(Len == 2){
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1719:../uvc.c      **** 		 		 }else //if(Len == 4)
1720:../uvc.c      **** 		 		 {
1721:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1725:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1726:../uvc.c      **** 				 }
1727:../uvc.c      **** 			 }else{
1728:../uvc.c      **** 			 	 if(Len ==2){
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1732:../uvc.c      **** 				 }else{
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1734:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1735:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1736:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1737:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1738:../uvc.c      **** 				 }
1739:../uvc.c      **** 			 }
1740:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1741:../uvc.c      **** 				  if(Len == 2){
1742:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1744:../uvc.c      **** 				  }else{
1745:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1746:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1747:../uvc.c      **** 				  }
1748:../uvc.c      **** 				  break;
1749:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1750:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1751:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1755:../uvc.c      **** 		 	 }
1756:../uvc.c      **** 		 	 else{
1757:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1761:../uvc.c      **** 		 	 }
1762:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1764:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1765:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1766:../uvc.c      **** 			  break;
1767:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1768:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1769:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1773:../uvc.c      **** 		 	 }
1774:../uvc.c      **** 		 	 else{
1775:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1778:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1779:../uvc.c      **** 		 	 }
1780:../uvc.c      **** 		 	 Len = 1;
1781:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1783:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1785:../uvc.c      **** 		 	 break;
1786:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1787:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1788:../uvc.c      **** 		 		 if(Len == 2){
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1792:../uvc.c      **** 		 		 }else //if(Len == 4)
1793:../uvc.c      **** 		 		 {
1794:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1799:../uvc.c      **** 				 }
1800:../uvc.c      **** 			 }else{
1801:../uvc.c      **** 			 	 if(Len ==2){
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1805:../uvc.c      **** 				 }else{
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1808:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1811:../uvc.c      **** 				 }
1812:../uvc.c      **** 			 }
1813:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1814:../uvc.c      **** 		 	 if(Len == 2){
1815:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1816:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1817:../uvc.c      **** 		 	 }else{
1818:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1820:../uvc.c      **** 		 	 }
1821:../uvc.c      **** 		 	 break;
1822:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1823:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
1825:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1826:../uvc.c      **** 			   {
1827:../uvc.c      **** 				 if(Len == 2){
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
1830:../uvc.c      **** 				 }else{
1831:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1832:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
1833:../uvc.c      **** 				 }
1834:../uvc.c      **** 				 dataIdx = 0;
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
1837:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
1838:../uvc.c      **** 					 switch(CtrlID)
1839:../uvc.c      **** 					 {
1840:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1841:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1842:../uvc.c      **** 							 if(Data0 == 1){
1843:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1844:../uvc.c      **** 							 }else{
1845:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1846:../uvc.c      **** 							 }
1847:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1850:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1851:../uvc.c      **** 							 break;
1852:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
1853:../uvc.c      **** 	#if 0 // not be used
1854:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
1855:../uvc.c      **** 
1856:../uvc.c      **** 							 if(CamMode == 1){//720p
1857:../uvc.c      **** 								if(sendData >= 3){
1858:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1859:../uvc.c      **** 									sendData = 0; //set back to default
1860:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
1861:../uvc.c      **** 								}
1862:../uvc.c      **** 								sendData += 4;
1863:../uvc.c      **** 							 }
1864:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1865:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
1866:../uvc.c      **** 							 glEp0Buffer[1] = 0;
1867:../uvc.c      **** 	#endif
1868:../uvc.c      **** 							 break;
1869:../uvc.c      **** 					 	 case ExtSensorParCtlID14:
1870:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
1872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
1875:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1876:../uvc.c      **** 							 break;
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
1878:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1879:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1880:../uvc.c      **** 					 		 }
1881:../uvc.c      **** 					 		 I2CCmdHandler();
1882:../uvc.c      **** 							 break;
1883:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
1884:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1885:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
1886:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
1887:../uvc.c      **** 								 if(1 || Data0 == 2 || Data0 == 3){
1888:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
1889:../uvc.c      **** 								 }
1890:../uvc.c      **** 							 }else{//if it's not GC settings, the Ex Mode does need to set.
1891:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = SensorGetControl(RegAdd0, devAdd);
1892:../uvc.c      **** 								 if((pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo&0x03) != Data0)
1893:../uvc.c      **** 								 {
1894:../uvc.c      **** 									 Data0 = Data0 | (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo & 0xFC);//exposure mode bit0:1 (ke
1895:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
1896:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1897:../uvc.c      **** 									 dataIdx++;
1898:../uvc.c      **** 								 }
1899:../uvc.c      **** 							 }
1900:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1901:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1902:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1903:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
1904:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
1905:../uvc.c      **** 							 break;
1906:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
1907:../uvc.c      **** 	#if 1	// register setting directly
1908:../uvc.c      **** 						     if(1||(EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in
1909:../uvc.c      **** 						     {
1910:../uvc.c      **** 						    	 Data1 = SensorGetControl(RegAdd0, devAdd);
1911:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
1912:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1913:../uvc.c      **** 						    	 dataIdx = 0;
1914:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1915:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1916:../uvc.c      **** 								 //dataIdx++;
1917:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1918:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1919:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting 
1920:../uvc.c      **** 						     }
1921:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1922:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1923:../uvc.c      **** 						     break;
1924:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
1925:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1926:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
1927:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1928:../uvc.c      **** 								 if(1 || EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1929:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1930:../uvc.c      **** 									 //dataIdx++;
1931:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
1932:../uvc.c      **** 								 }
1933:../uvc.c      **** 							 }
1934:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1935:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1936:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1937:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1938:../uvc.c      **** 							 break;
1939:../uvc.c      **** 
1940:../uvc.c      **** 	#else	// old fashion
1941:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1942:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1943:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1944:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1945:../uvc.c      **** 									 }else{
1946:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1947:../uvc.c      **** 									 }
1948:../uvc.c      **** 								 }
1949:../uvc.c      **** 							 }else{
1950:../uvc.c      **** 								 Data1 = Data0 - 1;
1951:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1952:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1953:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1954:../uvc.c      **** 									 }else{
1955:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1956:../uvc.c      **** 									 }
1957:../uvc.c      **** 								 }
1958:../uvc.c      **** 								 if(Data1 < 8){
1959:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1960:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1961:../uvc.c      **** 								 }else{
1962:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1963:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1964:../uvc.c      **** 								 }
1965:../uvc.c      **** 							 }
1966:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1967:../uvc.c      **** 							 dataIdx = 0;
1968:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1969:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1970:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1971:../uvc.c      **** 							 if(AxMode){
1972:../uvc.c      **** 								 dataIdx++;
1973:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1974:../uvc.c      **** 								 dataIdx++;
1975:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1976:../uvc.c      **** 							 }
1977:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1978:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1979:../uvc.c      **** 							 break;
1980:../uvc.c      **** 	#endif
1981:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
1982:../uvc.c      **** 	#if 0 //seperate version
1983:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
1984:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1985:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1986:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1987:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1988:../uvc.c      **** 							 }else{ //disable BLD window
1989:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1990:../uvc.c      **** 							 }
1991:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1992:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1993:../uvc.c      **** 							 dataIdx++;
1994:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1995:../uvc.c      **** 							 dataIdx++;
1996:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1997:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1998:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1999:../uvc.c      **** 							 dataIdx++;
2000:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2001:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2002:../uvc.c      **** 	#else //combination version
2003:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2004:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2005:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2006:../uvc.c      **** 							 dataIdx++;
2007:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2008:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2009:../uvc.c      **** 							 getData1 = Data1;
2010:../uvc.c      **** 	#endif
2011:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2012:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2013:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2014:../uvc.c      **** 							 break;
2015:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2016:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2017:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
2018:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
2019:../uvc.c      **** 								 Data0 |= Data1;
2020:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
2021:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2022:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2023:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2024:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2025:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2026:../uvc.c      **** 							 }
2027:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2028:../uvc.c      **** 
2029:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2030:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2031:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2032:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2033:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2034:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2035:../uvc.c      **** 				 	 	 case Ext1AGCMaxLimetCtlID15:
2036:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2037:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2038:../uvc.c      **** 						 case ExtExRefCtlID10:
2039:../uvc.c      **** 				 	 	 default:
2040:../uvc.c      **** 				 	 			 if(Len == 2)
2041:../uvc.c      **** 				 	 			 {
2042:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2043:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2044:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2045:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2046:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2047:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2048:../uvc.c      **** 									 }
2049:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2050:../uvc.c      **** 				 	 			 }else if(Len == 4){
2051:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2052:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2053:../uvc.c      **** 									 {
2054:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2055:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2056:../uvc.c      **** 										 dataIdx++;
2057:../uvc.c      **** 									 }
2058:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2059:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2060:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2061:../uvc.c      **** 									 }
2062:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2063:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2064:../uvc.c      **** 
2065:../uvc.c      **** 				 	 			 }
2066:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2067:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2068:../uvc.c      **** 				 	 			 break;
2069:../uvc.c      **** 					 }
2070:../uvc.c      **** 			 	 }
2071:../uvc.c      **** 			 	 else{
2072:../uvc.c      **** 					 switch(CtrlID)
2073:../uvc.c      **** 					 {
2074:../uvc.c      **** 						 case BrgtCtlID1:
2075:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2076:../uvc.c      **** 								 dataIdx = 0;
2077:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2078:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2079:../uvc.c      **** 								  if(Data0&0x80){
2080:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2081:../uvc.c      **** 								  }else{
2082:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2083:../uvc.c      **** 								  }
2084:../uvc.c      **** 								 Data1 |= ~0x03;
2085:../uvc.c      **** 								 Data1 &= 0xC7;
2086:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2087:../uvc.c      **** 							  	 dataIdx++;
2088:../uvc.c      **** 
2089:../uvc.c      **** 								 Data0 = (Data0 << 2);
2090:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2091:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2092:../uvc.c      **** 
2093:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2094:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2095:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2096:../uvc.c      **** 	#endif
2097:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2098:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2099:../uvc.c      **** 								 /*// new I2C command. direct using Data0 coming from host. 8/23/2016
2100:../uvc.c      **** 								 if(Data0&0x80){
2101:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2102:../uvc.c      **** 								  }else{
2103:../uvc.c      **** 									  Data0 = ~Data0;
2104:../uvc.c      **** 								  }
2105:../uvc.c      **** 								  */
2106:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2107:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2108:../uvc.c      **** 
2109:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2110:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2111:../uvc.c      **** 							 break;
2112:../uvc.c      **** 						 case HueCtlID5://not being used
2113:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2114:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2115:../uvc.c      **** 							 dataIdx++;
2116:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2117:../uvc.c      **** 							 dataIdx++;
2118:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2119:../uvc.c      **** 							 dataIdx++;
2120:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2121:../uvc.c      **** 							 dataIdx++;
2122:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2123:../uvc.c      **** 							 dataIdx++;
2124:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2125:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2126:../uvc.c      **** 
2127:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2128:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2129:../uvc.c      **** 							 break;
2130:../uvc.c      **** 						 case MFreqCtlID4:
2131:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2132:../uvc.c      **** 							 //Data0 = Data0 - 1;
2133:../uvc.c      **** 							 //is60Hz = Data0;
2134:../uvc.c      **** 							 if(Data0 <= 0)  //for specific check. if it's minor value, set to 0.
2135:../uvc.c      **** 							 {
2136:../uvc.c      **** 								 Data0 = 0;  // 60Hz (PAL)
2137:../uvc.c      **** 								 is60Hz = CyTrue;
2138:../uvc.c      **** 							 }
2139:../uvc.c      **** 							 else if(Data0 >= 1)
2140:../uvc.c      **** 							 {
2141:../uvc.c      **** 								 Data0 = 1;  // 50Hz (NTSC)
2142:../uvc.c      **** 								 is60Hz = CyFalse;
2143:../uvc.c      **** 							 }
2144:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2145:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2146:../uvc.c      **** 							 {
2147:../uvc.c      **** 			                       switch (setRes)
2148:../uvc.c      **** 			                         {
2149:../uvc.c      **** 			                         	case 1: //1944
2150:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2151:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2152:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2153:../uvc.c      **** 			                         		break;
2154:../uvc.c      **** 			                         	case 2: //1080
2155:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2156:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2157:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2158:../uvc.c      **** 			                         		break;
2159:../uvc.c      **** 			                         	case 3: //720
2160:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2161:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2162:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2163:../uvc.c      **** 			                         		break;
2164:../uvc.c      **** 			                         	case 4: //VGA
2165:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2166:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2167:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2168:../uvc.c      **** 			                         	default:
2169:../uvc.c      **** 			                         		break;
2170:../uvc.c      **** 			                         }
2171:../uvc.c      **** 							 }
2172:../uvc.c      **** 
2173:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2174:../uvc.c      **** 							 break;
2175:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2176:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2177:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2178:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2179:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2180:../uvc.c      **** 							 dataIdx++;
2181:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2182:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2183:../uvc.c      **** 
2184:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2185:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2186:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2187:../uvc.c      **** 							 break;
2188:../uvc.c      **** 						 case BLCCtlID0:
2189:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2190:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2191:../uvc.c      **** 							 {
2192:../uvc.c      **** 								 if(Data0 < 3){
2193:../uvc.c      **** 					 				 Data0 += 4;
2194:../uvc.c      **** 					 			 }else{
2195:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2196:../uvc.c      **** 									Data0 = 4; //set to default.
2197:../uvc.c      **** 					 			 }
2198:../uvc.c      **** 					 		 }else{
2199:../uvc.c      **** 					 			 Data0 |= EXTBLCGrid.UVCCurVLo << 7;
2200:../uvc.c      **** 					 		 }
2201:../uvc.c      **** 
2202:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2203:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2204:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2205:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2206:../uvc.c      **** 					 		 break;
2207:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2208:../uvc.c      **** 
2209:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2210:../uvc.c      **** 							 if(Data0 != 0){
2211:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2212:../uvc.c      **** 	#ifdef COLOR
2213:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2214:../uvc.c      **** 	#else
2215:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2216:../uvc.c      **** 								 dataIdx++;
2217:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2218:../uvc.c      **** 	#endif
2219:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2220:../uvc.c      **** 							 }else{
2221:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2222:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2223:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2224:../uvc.c      **** 							 }
2225:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2226:../uvc.c      **** 							 break;
2227:../uvc.c      **** 						 case ConsCtlID2:
2228:../uvc.c      **** 						 case WBTMdCtlID9:
2229:../uvc.c      **** 						 case SaturCtlID6:
2230:../uvc.c      **** 						 default:
2231:../uvc.c      **** 			 	 			 if(Len == 2)
2232:../uvc.c      **** 			 	 			 {
2233:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2234:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2235:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2236:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2237:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2238:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2239:../uvc.c      **** 								 }
2240:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2241:../uvc.c      **** 			 	 			 }else if(Len == 4){
2242:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2243:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2244:../uvc.c      **** 								 {
2245:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2246:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2247:../uvc.c      **** 									 dataIdx++;
2248:../uvc.c      **** 								 }
2249:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2250:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2251:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2252:../uvc.c      **** 								 }
2253:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2254:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2255:../uvc.c      **** 
2256:../uvc.c      **** 			 	 			 }
2257:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2258:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2259:../uvc.c      **** 			 	 			 break;
2260:../uvc.c      **** 					 }
2261:../uvc.c      **** 			 	 }
2262:../uvc.c      **** 			   }else{
2263:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2264:../uvc.c      **** 			   }
2265:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2266:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2267:../uvc.c      **** #endif
2268:../uvc.c      **** 
2269:../uvc.c      **** 			  break;
2270:../uvc.c      **** 		  default:
2271:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2272:../uvc.c      **** 			  break;
2273:../uvc.c      **** 		 }
2274:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2275:../uvc.c      **** }
2276:../uvc.c      **** /************** CT control requests handler *************************/
2277:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2278:../uvc.c      **** 
2279:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2280:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2281:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2282:../uvc.c      ****     uint16_t readCount;
2283:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2284:../uvc.c      ****     uint16_t diff, value, diffRd;
2285:../uvc.c      ****     uint8_t i, shutter, index;
2286:../uvc.c      ****     diff = 0xffff;
2287:../uvc.c      ****     shutter = 1;
2288:../uvc.c      ****     index = 1;
2289:../uvc.c      **** 
2290:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2291:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2292:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2293:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2294:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2295:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2296:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2297:../uvc.c      **** #endif
2298:../uvc.c      ****     reqData = bRequest;
2299:../uvc.c      **** 
2300:../uvc.c      ****     switch (bRequest)
2301:../uvc.c      **** 		 {
2302:../uvc.c      **** 
2303:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2304:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2305:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2306:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2307:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2308:../uvc.c      **** 			  break;
2309:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2310:../uvc.c      **** 
2311:../uvc.c      **** 			 switch(CtrlID)
2312:../uvc.c      **** 			 {
2313:../uvc.c      **** 				 default:
2314:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2315:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2316:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2317:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2318:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2319:../uvc.c      **** 					 break;
2320:../uvc.c      **** 			 }
2321:../uvc.c      **** 
2322:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2323:../uvc.c      **** 
2324:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2325:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2326:../uvc.c      **** #endif
2327:../uvc.c      **** 			  break;
2328:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2329:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2330:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2331:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2332:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2333:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2334:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2335:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2336:../uvc.c      **** 			  break;
2337:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2338:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2339:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2340:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2341:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2342:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2343:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2344:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2345:../uvc.c      **** 			  break;
2346:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2347:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2348:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2349:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2350:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2351:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2352:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2353:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2354:../uvc.c      **** 			  break;
2355:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2356:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2357:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2358:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2359:../uvc.c      **** 			  Len = 1;
2360:../uvc.c      **** 			  break;
2361:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2362:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2363:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2364:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2365:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2366:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2367:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2368:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2369:../uvc.c      **** 			  break;
2370:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2371:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2372:../uvc.c      **** 			  glEp0Buffer, &readCount);
2373:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2374:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2375:../uvc.c      **** 			  value = Data1;
2376:../uvc.c      **** 
2377:../uvc.c      **** 			  switch(CtrlID)
2378:../uvc.c      **** 			  {
2379:../uvc.c      **** 		  	      case AutoExMCtlID1:
2380:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2381:../uvc.c      **** 
2382:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2383:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2384:../uvc.c      **** 				    getData = glEp0Buffer[0];
2385:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2386:../uvc.c      **** 		  		    switch (getData){
2387:../uvc.c      **** 						case 1:
2388:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2389:../uvc.c      **** 							break;
2390:../uvc.c      **** 						case 2:
2391:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2392:../uvc.c      **** 							dataIdx = 0;
2393:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2394:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2395:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2396:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2397:../uvc.c      **** 
2398:../uvc.c      **** 							break;
2399:../uvc.c      **** 						case 4:
2400:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2401:../uvc.c      **** 							break;
2402:../uvc.c      **** 						case 8:
2403:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2404:../uvc.c      **** 			  		    	dataIdx = 0;
2405:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2406:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2407:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2408:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2409:../uvc.c      **** 							break;
2410:../uvc.c      **** 		  		    }
2411:../uvc.c      **** #if 0
2412:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2413:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2414:../uvc.c      **** 						  dataIdx = 0;
2415:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2416:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2417:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2418:../uvc.c      **** 		  		    }
2419:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2420:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2421:../uvc.c      **** 		  		    }
2422:../uvc.c      **** #endif
2423:../uvc.c      **** 				    break;
2424:../uvc.c      **** 
2425:../uvc.c      **** 			  	  case ExTmACtlID3:
2426:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2427:../uvc.c      **** 
2428:../uvc.c      **** 					  value = (value << 8)|Data0;
2429:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2430:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2431:../uvc.c      **** 					  {
2432:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2433:../uvc.c      **** 						  {
2434:../uvc.c      **** 							if(value > ShutValueArry[i]){
2435:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2436:../uvc.c      **** 							}else{
2437:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2438:../uvc.c      **** 							}
2439:../uvc.c      **** 							  if(diff > diffRd){
2440:../uvc.c      **** 								  diff = diffRd;
2441:../uvc.c      **** 								  index = i;
2442:../uvc.c      **** 							  }
2443:../uvc.c      **** 						  }
2444:../uvc.c      **** 						  shutter = shutter+index;
2445:../uvc.c      **** 
2446:../uvc.c      **** 						  dataIdx = 0;
2447:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2448:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2449:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2450:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2451:../uvc.c      **** 
2452:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2453:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2454:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2455:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2456:../uvc.c      **** 					  }else{
2457:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2458:../uvc.c      **** 					  }
2459:../uvc.c      **** 					  getData = glEp0Buffer[0];
2460:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2461:../uvc.c      **** 					  break;
2462:../uvc.c      **** 			  	  case IriACtlID7:
2463:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2464:../uvc.c      **** 					  {
2465:../uvc.c      **** 							 dataIdx = 0;
2466:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2467:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2468:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2469:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2470:../uvc.c      **** 
2471:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2472:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2473:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2474:../uvc.c      **** 					  }else{
2475:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2476:../uvc.c      **** 					  }
2477:../uvc.c      **** 					  getData = glEp0Buffer[0];
2478:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2479:../uvc.c      **** 
2480:../uvc.c      **** 					  break;
2481:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2482:../uvc.c      **** 					  getData = glEp0Buffer[0];
2483:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2484:../uvc.c      **** #if 1
2485:../uvc.c      **** 					  dataIdx = 0;
2486:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2487:../uvc.c      **** 					  if(getData == 1)
2488:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2489:../uvc.c      **** 					  else if(getData == 0xff)
2490:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2491:../uvc.c      **** 					  else
2492:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2493:../uvc.c      **** 					  //dataIdx++;
2494:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2495:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2496:../uvc.c      **** #endif
2497:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2498:../uvc.c      **** 					  break;
2499:../uvc.c      **** 
2500:../uvc.c      **** 			  	  default:
2501:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2502:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2503:../uvc.c      **** 			  		 break;
2504:../uvc.c      **** 			  }
2505:../uvc.c      **** 			  break;
2506:../uvc.c      **** 		  default:
2507:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2508:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2509:../uvc.c      **** 			  break;
2510:../uvc.c      **** 		 }
2511:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2512:../uvc.c      **** 
2513:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2514:../uvc.c      **** }
2515:../uvc.c      **** 
2516:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2517:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2518:../uvc.c      **** {
2519:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2520:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2521:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2522:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2523:../uvc.c      **** 
2524:../uvc.c      ****     CtrlID = BrgtCtlID1;
2525:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2526:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2527:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2528:../uvc.c      ****     Data1 = Data0;
2529:../uvc.c      **** 
2530:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2531:../uvc.c      ****     if(Data1&0x80){
2532:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2533:../uvc.c      ****     }else{
2534:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2535:../uvc.c      ****     }
2536:../uvc.c      ****     Data0 = (Data0 << 2);
2537:../uvc.c      **** 
2538:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2539:../uvc.c      **** 
2540:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2541:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2542:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2543:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2544:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2545:../uvc.c      **** 
2546:../uvc.c      ****     CtrlID = ConsCtlID2;
2547:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2548:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2549:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2550:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2551:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2552:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2553:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2554:../uvc.c      **** 
2555:../uvc.c      ****     CtrlID = HueCtlID5;
2556:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2557:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2558:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2562:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2563:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2564:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2565:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2566:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2567:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2568:../uvc.c      **** 
2569:../uvc.c      ****     CtrlID = SaturCtlID6;
2570:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2571:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2572:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2573:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2574:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2575:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2576:../uvc.c      **** 
2577:../uvc.c      ****     CtrlID = ShapCtlID7;
2578:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2579:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2580:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2581:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2582:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2583:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2584:../uvc.c      **** 
2585:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2586:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2587:../uvc.c      **** 	return;
2588:../uvc.c      **** }
2589:../uvc.c      **** 
2590:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2591:../uvc.c      **** void
2592:../uvc.c      **** CyFxUVCAddHeader (
2593:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2594:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2595:../uvc.c      ****         )
2596:../uvc.c      **** {
2597:../uvc.c      ****     /* Copy header to buffer */
2598:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2599:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2600:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2601:../uvc.c      **** 
2602:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2603:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2604:../uvc.c      ****     {
2605:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2606:../uvc.c      ****     }
2607:../uvc.c      **** }
2608:../uvc.c      **** 
2609:../uvc.c      **** 
2610:../uvc.c      **** /* Application Error Handler */
2611:../uvc.c      **** void
2612:../uvc.c      **** CyFxAppErrorHandler (
2613:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2614:../uvc.c      ****         )
2615:../uvc.c      **** {
2616:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2617:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2618:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2619:../uvc.c      **** 
2620:../uvc.c      ****        This function can be modified to take additional error handling actions such
2621:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2622:../uvc.c      ****      */
2623:../uvc.c      ****     for (;;)
2624:../uvc.c      ****     {
2625:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2626:../uvc.c      ****         CyU3PThreadSleep (1000);
2627:../uvc.c      ****     }
2628:../uvc.c      **** }
2629:../uvc.c      **** 
2630:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2631:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2632:../uvc.c      ****  */
2633:../uvc.c      **** static void
2634:../uvc.c      **** CyFxUVCApplnAbortHandler (
2635:../uvc.c      ****         void)
2636:../uvc.c      **** {
2637:../uvc.c      **** 	uint32_t flag;
2638:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2639:../uvc.c      **** 	{
2640:../uvc.c      ****         /* Clear the Video Stream Request Event */
2641:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2642:../uvc.c      **** 
2643:../uvc.c      ****         /* Set Video Stream Abort Event */
2644:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2645:../uvc.c      **** 	}
2646:../uvc.c      **** }
2647:../uvc.c      **** 
2648:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2649:../uvc.c      **** static void
2650:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2651:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2652:../uvc.c      ****         uint16_t             evdata  /* Event data */
2653:../uvc.c      ****         )
2654:../uvc.c      **** {
2655:../uvc.c      ****     switch (evtype)
2656:../uvc.c      ****     {
2657:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2658:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2659:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2660:../uvc.c      ****             gpif_initialized = 0;
2661:../uvc.c      ****             streamingStarted = CyFalse;
2662:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2663:../uvc.c      ****             break;
2664:../uvc.c      **** 
2665:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2666:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2667:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2668:../uvc.c      ****             gpif_initialized = 0;
2669:../uvc.c      ****             streamingStarted = CyFalse;
2670:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2671:../uvc.c      ****             break;
2672:../uvc.c      **** 
2673:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2674:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2675:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2676:../uvc.c      ****             gpif_initialized = 0;
2677:../uvc.c      ****             isUsbConnected = CyFalse;
2678:../uvc.c      ****             streamingStarted = CyFalse;
2679:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2680:../uvc.c      ****             break;
2681:../uvc.c      **** 
2682:../uvc.c      **** #ifdef BACKFLOW_DETECT
2683:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2684:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2685:../uvc.c      ****             break;
2686:../uvc.c      **** #endif
2687:../uvc.c      **** 
2688:../uvc.c      ****         default:
2689:../uvc.c      ****             break;
2690:../uvc.c      ****     }
2691:../uvc.c      **** }
2692:../uvc.c      **** 
2693:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2694:../uvc.c      **** static CyBool_t
2695:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2696:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2697:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2698:../uvc.c      ****         )
2699:../uvc.c      **** {
2700:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2701:../uvc.c      ****     uint32_t status;
2702:../uvc.c      **** 
2703:../uvc.c      ****     /* Obtain Request Type and Request */
2704:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2705:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2706:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2707:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2708:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2709:../uvc.c      **** 
2710:../uvc.c      ****     /* Check for UVC Class Requests */
2711:../uvc.c      ****     switch (bmReqType)
2712:../uvc.c      ****     {
2713:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2714:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2715:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2716:../uvc.c      ****             switch (wIndex & 0xFF)
2717:../uvc.c      ****             {
2718:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2719:../uvc.c      ****                     {
2720:../uvc.c      ****                         uvcHandleReq = CyTrue;
2721:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2722:../uvc.c      ****                                 CYU3P_EVENT_OR);
2723:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2724:../uvc.c      ****                         {
2725:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2726:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2727:../uvc.c      ****                         }
2728:../uvc.c      ****                     }
2729:../uvc.c      ****                     break;
2730:../uvc.c      **** 
2731:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2732:../uvc.c      ****                     {
2733:../uvc.c      ****                         uvcHandleReq = CyTrue;
2734:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2735:../uvc.c      ****                                 CYU3P_EVENT_OR);
2736:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2737:../uvc.c      ****                         {
2738:../uvc.c      ****                             /* Error handling */
2739:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2740:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2741:../uvc.c      ****                         }
2742:../uvc.c      ****                     }
2743:../uvc.c      ****                     break;
2744:../uvc.c      **** 
2745:../uvc.c      ****                 default:
2746:../uvc.c      ****                     break;
2747:../uvc.c      ****             }
2748:../uvc.c      ****             break;
2749:../uvc.c      **** 
2750:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2751:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2752:../uvc.c      ****             {
2753:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2754:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2755:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2756:../uvc.c      ****                 {
2757:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2758:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2759:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2760:../uvc.c      ****                     gpif_initialized = 0;
2761:../uvc.c      ****                     streamingStarted = CyFalse;
2762:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2763:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2764:../uvc.c      ****                     CyU3PBusyWait (100);
2765:../uvc.c      **** 
2766:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2767:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2768:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2769:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2770:../uvc.c      ****                     CyU3PBusyWait (100);
2771:../uvc.c      **** 
2772:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2773:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2774:../uvc.c      ****                     uvcHandleReq = CyTrue;
2775:../uvc.c      ****                     /* Complete Control request handshake */
2776:../uvc.c      ****                     CyU3PUsbAckSetup ();
2777:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2778:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2779:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2780:../uvc.c      **** 
2781:../uvc.c      ****                 }
2782:../uvc.c      ****             }
2783:../uvc.c      ****             break;
2784:../uvc.c      **** 
2785:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2786:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2787:../uvc.c      ****             {
2788:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2789:../uvc.c      ****                 {
2790:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2791:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2792:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2793:../uvc.c      ****                 	 * has started. */
2794:../uvc.c      ****                     if (streamingStarted == CyTrue)
2795:../uvc.c      ****                     {
2796:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2797:../uvc.c      **** 
2798:../uvc.c      ****                         /* Disable the GPIF state machine. */
2799:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2800:../uvc.c      ****                         gpif_initialized = 0;
2801:../uvc.c      ****                         streamingStarted = CyFalse;
2802:../uvc.c      **** 
2803:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2804:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2805:../uvc.c      ****                         CyU3PBusyWait (100);
2806:../uvc.c      **** 
2807:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2808:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2809:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2810:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2811:../uvc.c      ****                         CyU3PBusyWait (100);
2812:../uvc.c      **** 
2813:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2814:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2815:../uvc.c      **** 
2816:../uvc.c      ****                         uvcHandleReq = CyTrue;
2817:../uvc.c      ****                         /* Complete Control request handshake */
2818:../uvc.c      ****                         CyU3PUsbAckSetup ();
2819:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2820:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2821:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2822:../uvc.c      ****                     }
2823:../uvc.c      ****                     else
2824:../uvc.c      ****                     {
2825:../uvc.c      ****                         uvcHandleReq = CyTrue;
2826:../uvc.c      ****                         CyU3PUsbAckSetup ();
2827:../uvc.c      ****                     }
2828:../uvc.c      ****                 }
2829:../uvc.c      ****             }
2830:../uvc.c      ****             break;
2831:../uvc.c      **** 
2832:../uvc.c      ****         default:
2833:../uvc.c      ****             break;
2834:../uvc.c      ****     }
2835:../uvc.c      **** 
2836:../uvc.c      ****     /* Return status of request handling to the USB driver */
2837:../uvc.c      ****     return uvcHandleReq;
2838:../uvc.c      **** }
2839:../uvc.c      **** 
2840:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2841:../uvc.c      **** 
2842:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2843:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2844:../uvc.c      ****  */
2845:../uvc.c      **** void
2846:../uvc.c      **** CyFxUvcApplnDmaCallback (
2847:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2848:../uvc.c      ****         CyU3PDmaCbType_t      type,
2849:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2850:../uvc.c      ****         )
2851:../uvc.c      **** {
2852:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2853:../uvc.c      **** #if 1
2854:../uvc.c      ****     CyU3PReturnStatus_t status;
2855:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2856:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2857:../uvc.c      **** 
2858:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2859:../uvc.c      ****     {
2860:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2861:../uvc.c      ****             {
2862:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2863:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2864:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2865:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2866:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2867:../uvc.c      ****                 	stiflag = 0x03;
2868:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2869:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2870:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2871:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2872:../uvc.c      ****                 }
2873:../uvc.c      **** #endif
2874:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2875:../uvc.c      ****                 fb++;
2876:../uvc.c      ****             }
2877:../uvc.c      ****             else
2878:../uvc.c      ****             {
2879:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2880:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2881:../uvc.c      ****                 pb++;
2882:../uvc.c      ****                 pbc = input->buffer_p.count;
2883:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2884:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2885:../uvc.c      ****                 //lineCount = 0; //res test
2886:../uvc.c      **** #if 1   //remove the still flag clearing here
2887:../uvc.c      ****                 if(stiflag == 0x0F){
2888:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2889:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2890:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2891:../uvc.c      ****                 	stiflag = 0xAA;
2892:../uvc.c      ****                 }
2893:../uvc.c      **** #endif
2894:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2895:../uvc.c      ****             }
2896:../uvc.c      **** 
2897:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2898:../uvc.c      ****             prodCount++;
2899:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2900:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2901:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2902:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2903:../uvc.c      ****             {
2904:../uvc.c      ****                 prodCount--;
2905:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2906:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2907:../uvc.c      ****             }
2908:../uvc.c      ****     }
2909:../uvc.c      **** #endif
2910:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2911:../uvc.c      ****     {
2912:../uvc.c      ****         consCount++;
2913:../uvc.c      ****         streamingStarted = CyTrue;
2914:../uvc.c      ****     }
2915:../uvc.c      **** }
2916:../uvc.c      **** 
2917:../uvc.c      **** /*
2918:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2919:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2920:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2921:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2922:../uvc.c      ****  * to commit the buffer.
2923:../uvc.c      ****  */
2924:../uvc.c      **** static uint8_t
2925:../uvc.c      **** CyFxUvcAppCommitEOF (
2926:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2927:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2928:../uvc.c      ****         )
2929:../uvc.c      **** {
2930:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2931:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2932:../uvc.c      **** 
2933:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2934:../uvc.c      **** 
2935:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2936:../uvc.c      ****     {
2937:../uvc.c      ****         switch (stateId)
2938:../uvc.c      ****         {
2939:../uvc.c      **** 
2940:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2941:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2942:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2943:../uvc.c      ****                 break;
2944:../uvc.c      **** 
2945:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2946:../uvc.c      ****                 socket = 0;
2947:../uvc.c      ****                 break;
2948:../uvc.c      **** 
2949:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2950:../uvc.c      ****                 socket = 1;
2951:../uvc.c      ****                 break;
2952:../uvc.c      **** 
2953:../uvc.c      ****             default:
2954:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2955:../uvc.c      ****                 /* Unexpected current state. Return error. */
2956:../uvc.c      ****             	//lineCount++;
2957:../uvc.c      ****             	return 1;
2958:../uvc.c      ****         }
2959:../uvc.c      ****     }
2960:../uvc.c      **** 
2961:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2962:../uvc.c      ****     {
2963:../uvc.c      ****         switch (stateId)
2964:../uvc.c      ****         {
2965:../uvc.c      **** #ifndef CAM720
2966:../uvc.c      **** #ifdef GPIFIIM
2967:../uvc.c      ****             case 13:
2968:../uvc.c      ****             case 24:
2969:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2970:../uvc.c      ****                 break;
2971:../uvc.c      **** 
2972:../uvc.c      ****             case 8:
2973:../uvc.c      ****                 socket = 0;
2974:../uvc.c      ****                 break;
2975:../uvc.c      **** 
2976:../uvc.c      ****             case 20:
2977:../uvc.c      ****                 socket = 1;
2978:../uvc.c      ****                 break;
2979:../uvc.c      **** #else
2980:../uvc.c      ****             case 11:
2981:../uvc.c      ****             case 18:
2982:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2983:../uvc.c      ****                 break;
2984:../uvc.c      **** 
2985:../uvc.c      ****             case 8:
2986:../uvc.c      ****                 socket = 0;
2987:../uvc.c      ****                 break;
2988:../uvc.c      **** 
2989:../uvc.c      ****             case 15:
2990:../uvc.c      ****                 socket = 1;
2991:../uvc.c      ****                 break;
2992:../uvc.c      **** #endif
2993:../uvc.c      **** #else
2994:../uvc.c      ****             case 11:
2995:../uvc.c      ****             case 18:
2996:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2997:../uvc.c      ****                 break;
2998:../uvc.c      **** 
2999:../uvc.c      ****             case 8:
3000:../uvc.c      ****                 socket = 0;
3001:../uvc.c      ****                 break;
3002:../uvc.c      **** 
3003:../uvc.c      ****             case 15:
3004:../uvc.c      ****                 socket = 1;
3005:../uvc.c      ****                 break;
3006:../uvc.c      **** 
3007:../uvc.c      **** #endif
3008:../uvc.c      ****              default:
3009:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3010:../uvc.c      ****                 /* Unexpected current state. Return error. */
3011:../uvc.c      ****                return 1;
3012:../uvc.c      ****         }
3013:../uvc.c      ****     }
3014:../uvc.c      **** 
3015:../uvc.c      ****     if (socket != 0xFF)
3016:../uvc.c      ****     {
3017:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3018:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3019:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3020:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3021:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3022:../uvc.c      ****         {
3023:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3024:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3025:../uvc.c      ****         }
3026:../uvc.c      ****     }
3027:../uvc.c      **** 
3028:../uvc.c      ****     return 0;
3029:../uvc.c      **** }
3030:../uvc.c      **** 
3031:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3032:../uvc.c      **** void
3033:../uvc.c      **** CyFxGpifCB (
3034:../uvc.c      ****         CyU3PGpifEventType event,
3035:../uvc.c      ****         uint8_t currentState
3036:../uvc.c      ****         )
3037:../uvc.c      **** {
3038:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3039:../uvc.c      ****     {
3040:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3041:../uvc.c      ****     	           in the UVC implementation. */
3042:../uvc.c      ****     	//hitFV = CyTrue;
3043:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3044:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3045:../uvc.c      ****     }
3046:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3047:../uvc.c      **** }
3048:../uvc.c      **** 
3049:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3050:../uvc.c      **** static void
3051:../uvc.c      **** CyFxUVCApplnDebugInit (
3052:../uvc.c      ****         void)
3053:../uvc.c      **** {
3054:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3055:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3056:../uvc.c      **** 
3057:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3058:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3059:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3060:../uvc.c      ****     {
3061:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3062:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3063:../uvc.c      ****     }
3064:../uvc.c      **** 
3065:../uvc.c      ****     /* Set UART Configuration */
3066:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3067:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3068:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3069:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3070:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3071:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3072:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3073:../uvc.c      **** 
3074:../uvc.c      ****     /* Set the UART configuration */
3075:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3076:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3077:../uvc.c      ****     {
3078:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3079:../uvc.c      ****     }
3080:../uvc.c      **** 
3081:../uvc.c      ****     /* Set the UART transfer */
3082:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3083:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3084:../uvc.c      ****     {
3085:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3086:../uvc.c      ****     }
3087:../uvc.c      **** 
3088:../uvc.c      ****     /* Initialize the Debug logger module. */
3089:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3090:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3091:../uvc.c      ****     {
3092:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3093:../uvc.c      ****     }
3094:../uvc.c      **** 
3095:../uvc.c      ****     /* Disable log message headers. */
3096:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3097:../uvc.c      **** }
3098:../uvc.c      **** 
3099:../uvc.c      **** /* I2C initialization. */
3100:../uvc.c      **** static void
3101:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3102:../uvc.c      **** {
3103:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3104:../uvc.c      ****     CyU3PReturnStatus_t status;
3105:../uvc.c      **** 
3106:../uvc.c      ****     status = CyU3PI2cInit ();
3107:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3108:../uvc.c      ****     {
3109:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3110:../uvc.c      ****         CyFxAppErrorHandler (status);
3111:../uvc.c      ****     }
3112:../uvc.c      **** 
3113:../uvc.c      ****     /*  Set I2C Configuration */
3114:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3115:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3116:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3117:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3118:../uvc.c      **** 
3119:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3120:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3121:../uvc.c      ****     {
3122:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3123:../uvc.c      ****         CyFxAppErrorHandler (status);
3124:../uvc.c      ****     }
3125:../uvc.c      **** }
3126:../uvc.c      **** 
3127:../uvc.c      **** #ifdef BACKFLOW_DETECT
3128:../uvc.c      **** static void CyFxUvcAppPibCallback (
3129:../uvc.c      ****         CyU3PPibIntrType cbType,
3130:../uvc.c      ****         uint16_t cbArg)
3131:../uvc.c      **** {
3132:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3133:../uvc.c      ****     {
3134:../uvc.c      ****         if (!back_flow_detected)
3135:../uvc.c      ****         {
3136:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3137:../uvc.c      ****             back_flow_detected = 1;
3138:../uvc.c      ****         }
3139:../uvc.c      ****     }
3140:../uvc.c      **** }
3141:../uvc.c      **** #endif
3142:../uvc.c      **** 
3143:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3144:../uvc.c      **** static void
3145:../uvc.c      **** CyFxUvcAppDebugCallback (
3146:../uvc.c      ****         CyU3PDmaChannel   *handle,
3147:../uvc.c      ****         CyU3PDmaCbType_t   type,
3148:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3149:../uvc.c      **** {
3150:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3151:../uvc.c      ****     {
3152:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3153:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3154:../uvc.c      ****     }
3155:../uvc.c      **** }
3156:../uvc.c      **** #endif
3157:../uvc.c      **** 
3158:../uvc.c      **** #if 0
3159:../uvc.c      **** static void CyFxAppIntEpCb(
3160:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3161:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3162:../uvc.c      **** 		uint8_t  ebNum)
3163:../uvc.c      **** 		{
3164:../uvc.c      **** 			//CyBool_t value;
3165:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3166:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3167:../uvc.c      **** 
3168:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3169:../uvc.c      **** 		}
3170:../uvc.c      **** #endif
3171:../uvc.c      **** 
3172:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3173:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3174:../uvc.c      ****    configures the DMA module for the UVC Application */
3175:../uvc.c      **** static void
3176:../uvc.c      **** CyFxUVCApplnInit (void)
3177:../uvc.c      **** {
3178:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3179:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3180:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3181:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3182:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3183:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3184:../uvc.c      **** 
3185:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3186:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3187:../uvc.c      **** 
3188:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3189:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3190:../uvc.c      **** #endif
3191:../uvc.c      **** 
3192:../uvc.c      ****     /* Create UVC event group */
3193:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3194:../uvc.c      ****     if (apiRetStatus != 0)
3195:../uvc.c      ****     {
3196:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3197:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3198:../uvc.c      ****     }
3199:../uvc.c      **** 
3200:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3201:../uvc.c      ****     CyFxUvcAppPTZInit ();
3202:../uvc.c      **** #endif
3203:../uvc.c      **** 
3204:../uvc.c      ****     isUsbConnected = CyFalse;
3205:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3206:../uvc.c      **** 
3207:../uvc.c      ****     /* Init the GPIO module */
3208:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3209:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3210:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3211:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3212:../uvc.c      ****     gpioClock.halfDiv    = 0;
3213:../uvc.c      **** 
3214:../uvc.c      ****     /* Initialize Gpio interface */
3215:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3216:../uvc.c      ****     if (apiRetStatus != 0)
3217:../uvc.c      ****     {
3218:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3219:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3220:../uvc.c      ****     }
3221:../uvc.c      **** 
3222:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3223:../uvc.c      ****      * must use GpioOverride to configure it */
3224:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3225:../uvc.c      ****     if (apiRetStatus != 0)
3226:../uvc.c      ****     {
3227:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3228:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3229:../uvc.c      ****     }
3230:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3231:../uvc.c      ****     if (apiRetStatus != 0)
3232:../uvc.c      ****     {
3233:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3235:../uvc.c      ****     }
3236:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3237:../uvc.c      ****     if (apiRetStatus != 0)
3238:../uvc.c      ****     {
3239:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3240:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3241:../uvc.c      ****     }
3242:../uvc.c      **** 
3243:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3244:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3245:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3246:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3247:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3248:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3249:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3250:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3251:../uvc.c      ****     {
3252:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3253:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3254:../uvc.c      ****     }
3255:../uvc.c      **** 
3256:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3257:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3258:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3259:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3260:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3261:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3262:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3263:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3264:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3265:../uvc.c      ****     {
3266:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3267:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3268:../uvc.c      ****     }
3269:../uvc.c      **** 
3270:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3271:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3272:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3273:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3274:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3275:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3276:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3277:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3278:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3279:../uvc.c      ****     {
3280:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3281:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3282:../uvc.c      ****     }
3283:../uvc.c      **** 
3284:../uvc.c      ****     /* Initialize the P-port. */
3285:../uvc.c      ****     pibclock.clkDiv      = 2;
3286:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3287:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3288:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3289:../uvc.c      **** 
3290:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3291:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3292:../uvc.c      ****     {
3293:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3294:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3295:../uvc.c      ****     }
3296:../uvc.c      **** 
3297:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3298:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3299:../uvc.c      **** 
3300:../uvc.c      **** #ifdef BACKFLOW_DETECT
3301:../uvc.c      ****     back_flow_detected = 0;
3302:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3303:../uvc.c      **** #endif
3304:../uvc.c      **** 
3305:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3306:../uvc.c      ****     SensorReset ();
3307:../uvc.c      ****     CyU3PThreadSleep(5000);
3308:../uvc.c      ****     //SensorInit ();
3309:../uvc.c      **** 
3310:../uvc.c      ****     /* USB initialization. */
3311:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3312:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3313:../uvc.c      ****     {
3314:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3315:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3316:../uvc.c      ****     }
3317:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3318:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3319:../uvc.c      **** 
3320:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3321:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3322:../uvc.c      **** 
3323:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3324:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3325:../uvc.c      **** 
3326:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3327:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3328:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3329:../uvc.c      **** 
3330:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3331:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3332:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3333:../uvc.c      **** 
3334:../uvc.c      ****     /* Configuration descriptors. */
3335:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3336:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3337:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3338:../uvc.c      **** 
3339:../uvc.c      ****     /* String Descriptors */
3340:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3341:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3342:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3343:../uvc.c      **** 
3344:../uvc.c      ****     /* Configure the status interrupt endpoint.
3345:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3346:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3347:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3348:../uvc.c      ****      */
3349:../uvc.c      ****     endPointConfig.enable   = 1;
3350:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3351:../uvc.c      ****     endPointConfig.pcktSize = 64;
3352:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3353:../uvc.c      ****     endPointConfig.streams  = 0;
3354:../uvc.c      ****     endPointConfig.burstLen = 1;
3355:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3356:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3357:../uvc.c      ****     {
3358:../uvc.c      ****         /* Error Handling */
3359:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3360:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3361:../uvc.c      ****     }
3362:../uvc.c      **** 
3363:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3364:../uvc.c      ****     dmaInterConfig.size           = 1024;
3365:../uvc.c      ****     dmaInterConfig.count          = 1;
3366:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3367:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3368:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3369:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3370:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3371:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3372:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3373:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3374:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3375:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3376:../uvc.c      ****             &dmaInterConfig);
3377:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3378:../uvc.c      ****     {
3379:../uvc.c      ****         /* Error handling */
3380:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3381:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3382:../uvc.c      ****     }
3383:../uvc.c      **** 
3384:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3385:../uvc.c      ****     if (glInterStaBuffer == 0)
3386:../uvc.c      ****     {
3387:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3388:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3389:../uvc.c      ****     }
3390:../uvc.c      **** 
3391:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3392:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3393:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3394:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3395:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3396:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3397:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3398:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3399:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3400:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3401:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3402:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3403:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3404:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3405:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3406:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3407:../uvc.c      ****             &dmaMultiConfig);
3408:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3409:../uvc.c      ****     {
3410:../uvc.c      ****         /* Error handling */
3411:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3412:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3413:../uvc.c      ****     }
3414:../uvc.c      **** 
3415:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3416:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3417:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3418:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3419:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3420:../uvc.c      ****      */
3421:../uvc.c      **** 
3422:../uvc.c      ****     endPointConfig.enable   = 1;
3423:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3424:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3425:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3426:../uvc.c      ****     endPointConfig.streams  = 0;
3427:../uvc.c      ****     endPointConfig.burstLen = 1;
3428:../uvc.c      **** 
3429:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3430:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3431:../uvc.c      ****     {
3432:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3433:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3434:../uvc.c      ****     }
3435:../uvc.c      **** 
3436:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3437:../uvc.c      **** 
3438:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3440:../uvc.c      ****     {
3441:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3443:../uvc.c      ****     }
3444:../uvc.c      **** 
3445:../uvc.c      ****     channelConfig.size           = 1024;
3446:../uvc.c      ****     channelConfig.count          = 1;
3447:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3448:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3449:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3450:../uvc.c      ****     channelConfig.prodHeader     = 0;
3451:../uvc.c      ****     channelConfig.prodFooter     = 0;
3452:../uvc.c      ****     channelConfig.consHeader     = 0;
3453:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3454:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3455:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3456:../uvc.c      **** 
3457:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3458:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3459:../uvc.c      ****     {
3460:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3461:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3462:../uvc.c      ****     }
3463:../uvc.c      **** 
3464:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3465:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3466:../uvc.c      ****     {
3467:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3468:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3469:../uvc.c      ****     }
3470:../uvc.c      **** 
3471:../uvc.c      ****     channelConfig.size           = 1024;
3472:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3473:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3474:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3475:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3476:../uvc.c      ****     channelConfig.prodHeader     = 0;
3477:../uvc.c      ****     channelConfig.prodFooter     = 0;
3478:../uvc.c      ****     channelConfig.consHeader     = 0;
3479:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3480:../uvc.c      ****     channelConfig.notification   = 0;
3481:../uvc.c      ****     channelConfig.cb             = 0;
3482:../uvc.c      **** 
3483:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3484:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3485:../uvc.c      ****     {
3486:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3487:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3488:../uvc.c      ****     }
3489:../uvc.c      **** 
3490:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3491:../uvc.c      ****     if (glDebugRspBuffer == 0)
3492:../uvc.c      ****     {
3493:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3494:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3495:../uvc.c      ****     }
3496:../uvc.c      **** #endif
3497:../uvc.c      **** 
3498:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3499:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3500:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3501:../uvc.c      ****     {
3502:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3503:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3504:../uvc.c      ****     }
3505:../uvc.c      **** 
3506:../uvc.c      ****     CyU3PBusyWait(100);
3507:../uvc.c      **** 
3508:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3509:../uvc.c      **** 
3510:../uvc.c      ****     endPointConfig.enable   = 1;
3511:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3512:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3513:../uvc.c      ****     {
3514:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3515:../uvc.c      ****     	endPointConfig.burstLen = 16;
3516:../uvc.c      ****     }
3517:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3518:../uvc.c      ****     {
3519:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3520:../uvc.c      ****     	endPointConfig.burstLen = 1;
3521:../uvc.c      ****     }
3522:../uvc.c      ****     endPointConfig.streams  = 0;
3523:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3524:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3525:../uvc.c      ****     {
3526:../uvc.c      ****         /* Error Handling */
3527:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3529:../uvc.c      ****     }
3530:../uvc.c      **** #if 0    //for still image method 3 using
3531:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3532:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3533:../uvc.c      ****     {
3534:../uvc.c      ****         /* Error Handling */
3535:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3536:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3537:../uvc.c      ****     }
3538:../uvc.c      **** #endif
3539:../uvc.c      **** 
3540:../uvc.c      **** }
3541:../uvc.c      **** 
3542:../uvc.c      **** /*
3543:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3544:../uvc.c      ****  * streaming session is started.
3545:../uvc.c      ****  */
3546:../uvc.c      **** static void
3547:../uvc.c      **** CyFxUvcAppGpifInit (
3548:../uvc.c      ****         void)
3549:../uvc.c      **** {
3550:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3551:../uvc.c      **** 
3552:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3553:../uvc.c      ****     {
3554:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3555:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3556:../uvc.c      ****     }
3557:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3558:../uvc.c      ****     {
3559:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3560:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3561:../uvc.c      ****     }
3562:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3563:../uvc.c      ****     {
3564:../uvc.c      ****         /* Error Handling */
3565:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3566:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3567:../uvc.c      ****     }
3568:../uvc.c      **** 
3569:../uvc.c      ****     /* Start the state machine from the designated start state. */
3570:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3571:../uvc.c      ****     {
3572:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3573:../uvc.c      ****     }
3574:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3575:../uvc.c      ****     {
3576:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3577:../uvc.c      ****     }
3578:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3579:../uvc.c      ****     {
3580:../uvc.c      ****         /* Error Handling */
3581:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3582:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3583:../uvc.c      ****     }
3584:../uvc.c      **** }
3585:../uvc.c      **** 
3586:../uvc.c      **** /*
3587:../uvc.c      ****  * Entry function for the UVC Application Thread
3588:../uvc.c      ****  */
3589:../uvc.c      **** 
3590:../uvc.c      **** uint32_t posTick;
3591:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3592:../uvc.c      **** 
3593:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3593 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3594:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3594 0
  28 0000 28209FE5 		ldr	r2, .L2
3593:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3593 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3594 0
  36 0008 002092E5 		ldr	r2, [r2]
3593:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3593 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3594 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3595:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3595 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3596:../uvc.c      **** }
  49              		.loc 1 3596 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3595:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3595 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3597:../uvc.c      **** 
3598:../uvc.c      **** 
3599:../uvc.c      **** void
3600:../uvc.c      **** UVCAppThread_Entry (
3601:../uvc.c      ****         uint32_t input)
3602:../uvc.c      **** {
3603:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3604:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3605:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3606:../uvc.c      ****     uint8_t i = 0;
3607:../uvc.c      ****     uint32_t flag;
3608:../uvc.c      ****     uint32_t prinflag = 0;
3609:../uvc.c      **** static uint8_t IMcount = 0;
3610:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3611:../uvc.c      ****     uint32_t frameCnt = 0;
3612:../uvc.c      **** #endif
3613:../uvc.c      ****     /* Initialize the Uart Debug Module */
3614:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3615:../uvc.c      **** 
3616:../uvc.c      ****     /* Initialize the I2C interface */
3617:../uvc.c      **** 	while (i++ < 6){
3618:../uvc.c      **** 		CyU3PThreadSleep(500);
3619:../uvc.c      **** 	}
3620:../uvc.c      **** 
3621:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3622:../uvc.c      **** 
3623:../uvc.c      ****     /* Initialize the UVC Application */
3624:../uvc.c      ****     CyFxUVCApplnInit ();
3625:../uvc.c      ****     /*
3626:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3627:../uvc.c      **** 
3628:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3629:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3630:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3631:../uvc.c      **** 
3632:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3633:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3634:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3635:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3636:../uvc.c      **** 
3637:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3638:../uvc.c      ****        of handling the abort request.
3639:../uvc.c      ****      */
3640:../uvc.c      **** 
3641:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3642:../uvc.c      ****     //CyU3PThreadSleep(1000);
3643:../uvc.c      **** 
3644:../uvc.c      ****     for (;;)
3645:../uvc.c      ****     {
3646:../uvc.c      ****         /* Waiting for the Video Stream Event */
3647:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3648:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3649:../uvc.c      ****         {
3650:../uvc.c      **** #if 0 //test for new firmware no video bring up
3651:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3652:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3653:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3654:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3655:../uvc.c      ****             {
3656:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3657:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3658:../uvc.c      ****                 {
3659:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3660:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3661:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3662:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3663:../uvc.c      **** #endif
3664:../uvc.c      **** #endif
3665:../uvc.c      ****                     }
3666:../uvc.c      ****                 else
3667:../uvc.c      ****                 {
3668:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3669:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3670:../uvc.c      **** #ifdef USB_LOWRES_IMG
3671:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3672:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3673:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3674:../uvc.c      **** #endif
3675:../uvc.c      **** #endif
3676:../uvc.c      ****                 }
3677:../uvc.c      **** 
3678:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3679:../uvc.c      ****                 prodCount++;
3680:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3681:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3682:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3683:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3684:../uvc.c      ****                 {
3685:../uvc.c      ****                     prodCount--;
3686:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3687:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3688:../uvc.c      ****                 }
3689:../uvc.c      ****             }
3690:../uvc.c      **** #endif
3691:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3692:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3693:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3694:../uvc.c      ****             {
3695:../uvc.c      ****             	if(0&&(prinflag == 0)){
3696:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3697:../uvc.c      ****             		prinflag = 1;
3698:../uvc.c      ****             	}
3699:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3700:../uvc.c      ****             	fb=0;
3701:../uvc.c      ****             	pb=0;
3702:../uvc.c      ****             	pbc=0;
3703:../uvc.c      ****                 prodCount = 0;
3704:../uvc.c      ****                 consCount = 0;
3705:../uvc.c      ****                 hitFV     = CyFalse;
3706:../uvc.c      **** 
3707:../uvc.c      **** #ifdef BACKFLOW_DETECT
3708:../uvc.c      ****                 back_flow_detected = 0;
3709:../uvc.c      **** #endif
3710:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3711:../uvc.c      ****                 frameCnt++;
3712:../uvc.c      **** #endif
3713:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3714:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3715:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3716:../uvc.c      ****                 //}
3717:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3718:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3719:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3720:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3721:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3722:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3723:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3724:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3725:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3726:../uvc.c      ****                 		stiflag = 0xFF;
3727:../uvc.c      ****                 		IMcount = 0;
3728:../uvc.c      ****                 	}
3729:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3730:../uvc.c      **** 
3731:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3732:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3733:../uvc.c      ****                 		stiflag = 0x0F;
3734:../uvc.c      ****                 		IMcount = 0;
3735:../uvc.c      ****                 		}
3736:../uvc.c      ****                  		/*if(IMcount > 0x4){
3737:../uvc.c      ****                 			stiflag = 0x0F;
3738:../uvc.c      ****                 			IMcount = 0;
3739:../uvc.c      ****                 		}*/
3740:../uvc.c      **** 
3741:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3742:../uvc.c      ****                     //CyU3PThreadSleep(400);
3743:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3744:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3745:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3746:../uvc.c      **** 
3747:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3748:../uvc.c      ****                 	{
3749:../uvc.c      ****                     switch (setRes)
3750:../uvc.c      ****                      {
3751:../uvc.c      ****                  	case 1: //1944
3752:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
3753:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3754:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
3755:../uvc.c      ****                  		break;
3756:../uvc.c      ****                  	case 2: //1080
3757:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
3758:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3759:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
3760:../uvc.c      ****                  		break;
3761:../uvc.c      ****                  	case 3: //720
3762:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
3763:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3764:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
3765:../uvc.c      ****                  		break;
3766:../uvc.c      ****                  	case 4: //VGA
3767:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
3768:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3769:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
3770:../uvc.c      ****                  		break;
3771:../uvc.c      ****                  	default:
3772:../uvc.c      ****                  		break;
3773:../uvc.c      ****                      }
3774:../uvc.c      ****                     IMcount = 0;
3775:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3776:../uvc.c      ****                 	stiflag = 0x0;
3777:../uvc.c      ****                 	}
3778:../uvc.c      ****                 }
3779:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3780:../uvc.c      ****                 /* Reset the DMA channel. */
3781:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3782:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3783:../uvc.c      ****                 {
3784:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3785:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3786:../uvc.c      ****                 }
3787:../uvc.c      **** 
3788:../uvc.c      ****                 /* Start Channel Immediately */
3789:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3790:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3791:../uvc.c      ****                 {
3792:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3793:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3794:../uvc.c      ****                 }
3795:../uvc.c      **** 
3796:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3797:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3798:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3799:../uvc.c      ****                 }
3800:../uvc.c      ****         }
3801:../uvc.c      ****         else
3802:../uvc.c      ****         {
3803:../uvc.c      ****             /* If we have a stream abort request pending. */
3804:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3805:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3806:../uvc.c      ****             {
3807:../uvc.c      ****                 hitFV     = CyFalse;
3808:../uvc.c      ****                 prodCount = 0;
3809:../uvc.c      ****                 consCount = 0;
3810:../uvc.c      ****                 if(0&&(prinflag == 0)){
3811:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3812:../uvc.c      ****                 	prinflag = 1;
3813:../uvc.c      ****                 }
3814:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3815:../uvc.c      ****                 fb=0;
3816:../uvc.c      ****                 pb=0;
3817:../uvc.c      ****                 pbc=0;
3818:../uvc.c      **** 
3819:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3820:../uvc.c      ****                 {
3821:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3822:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3823:../uvc.c      ****                     {
3824:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3825:../uvc.c      ****                     }
3826:../uvc.c      **** 
3827:../uvc.c      ****                     /* Flush the Endpoint memory */
3828:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3829:../uvc.c      ****                 }
3830:../uvc.c      **** 
3831:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3832:../uvc.c      ****             }
3833:../uvc.c      ****             else
3834:../uvc.c      ****             {
3835:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3836:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3837:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3838:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3839:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3840:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3841:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3842:../uvc.c      ****                 {
3843:../uvc.c      ****                     /* Error handling */
3844:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3845:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3846:../uvc.c      ****                 }
3847:../uvc.c      **** 
3848:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3849:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3850:../uvc.c      ****                 {
3851:../uvc.c      **** #if 0
3852:../uvc.c      ****                 	//for start up of the AF Lens
3853:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3854:../uvc.c      ****                     CyU3PThreadSleep(500);
3855:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3856:../uvc.c      ****                     CyU3PThreadSleep(500);
3857:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3858:../uvc.c      ****                    	CyU3PThreadSleep(300);
3859:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3860:../uvc.c      ****                     CyU3PThreadSleep(500);
3861:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3862:../uvc.c      ****                     CyU3PThreadSleep(500);
3863:../uvc.c      **** #endif
3864:../uvc.c      **** #if 0
3865:../uvc.c      ****                     switch (setRes)
3866:../uvc.c      ****                     {
3867:../uvc.c      ****                     	case 1: //1944
3868:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3869:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3870:../uvc.c      ****                     		break;
3871:../uvc.c      ****                     	case 2: //1080
3872:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3873:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3874:../uvc.c      ****                     		break;
3875:../uvc.c      ****                     	case 3: //720
3876:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3877:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3878:../uvc.c      ****                     		break;
3879:../uvc.c      ****                     	default:
3880:../uvc.c      ****                     		break;
3881:../uvc.c      ****                     }
3882:../uvc.c      **** #endif
3883:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3884:../uvc.c      **** 
3885:../uvc.c      ****                     gpif_initialized = CyTrue;
3886:../uvc.c      ****                     CyU3PThreadSleep(200);
3887:../uvc.c      ****                     
3888:../uvc.c      ****                 }
3889:../uvc.c      ****                 else
3890:../uvc.c      ****                 {
3891:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3892:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3893:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3894:../uvc.c      ****                 }
3895:../uvc.c      ****             }
3896:../uvc.c      ****         }
3897:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3898:../uvc.c      **** 
3899:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3900:../uvc.c      ****         CyU3PThreadRelinquish ();
3901:../uvc.c      ****     }
3902:../uvc.c      **** }
3903:../uvc.c      **** 
3904:../uvc.c      **** /*
3905:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3906:../uvc.c      ****  */
3907:../uvc.c      **** 
3908:../uvc.c      **** static void
3909:../uvc.c      **** UVCHandleProcessingUnitRqts (
3910:../uvc.c      ****         void)
3911:../uvc.c      **** {
3912:../uvc.c      ****     uint8_t CtrlAdd;
3913:../uvc.c      **** #ifdef DbgInfo
3914:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3915:../uvc.c      **** #endif
3916:../uvc.c      ****     switch (wValue)
3917:../uvc.c      ****     {
3918:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3919:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3920:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3921:../uvc.c      ****     		break;
3922:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3923:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3924:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3925:../uvc.c      ****     		break;
3926:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3927:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3928:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3929:../uvc.c      **** 			break;
3930:../uvc.c      **** 
3931:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3932:../uvc.c      **** 
3933:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3934:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3935:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3936:../uvc.c      ****       		break;
3937:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3938:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3939:../uvc.c      ****      		ControlHandle(HueCtlID5);
3940:../uvc.c      ****      		break;
3941:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3942:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3943:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3944:../uvc.c      ****           		break;
3945:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3946:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3947:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3948:../uvc.c      ****           		break;
3949:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3950:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3951:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3952:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3953:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3954:../uvc.c      ****     		break;
3955:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3956:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3957:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3958:../uvc.c      ****     		break;
3959:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3960:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3961:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3962:../uvc.c      ****     		break;
3963:../uvc.c      **** 
3964:../uvc.c      ****         default:
3965:../uvc.c      ****             /*
3966:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3967:../uvc.c      ****              * other controls.
3968:../uvc.c      ****              */
3969:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3970:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3971:../uvc.c      ****             break;
3972:../uvc.c      ****     }
3973:../uvc.c      **** }
3974:../uvc.c      **** 
3975:../uvc.c      **** /*
3976:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3977:../uvc.c      ****  */
3978:../uvc.c      **** static void
3979:../uvc.c      **** UVCHandleCameraTerminalRqts (
3980:../uvc.c      ****         void)
3981:../uvc.c      **** {
3982:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3983:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3984:../uvc.c      ****     uint16_t readCount;
3985:../uvc.c      ****     uint16_t zoomVal;
3986:../uvc.c      ****     int32_t  panVal, tiltVal;
3987:../uvc.c      ****     CyBool_t sendData = CyFalse;
3988:../uvc.c      **** #endif
3989:../uvc.c      ****     uint8_t CtrlAdd;
3990:../uvc.c      **** 
3991:../uvc.c      ****     switch (wValue)
3992:../uvc.c      ****     {
3993:../uvc.c      **** #if 0 // cancel the CT controls
3994:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3995:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3996:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3997:../uvc.c      ****     		break;
3998:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3999:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
4000:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
4001:../uvc.c      ****     		break;
4002:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
4003:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
4004:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
4005:../uvc.c      **** 			break;
4006:../uvc.c      **** 
4007:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4008:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4009:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4010:../uvc.c      **** 			break;
4011:../uvc.c      **** 
4012:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4013:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4014:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4015:../uvc.c      ****       		break;
4016:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4017:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4018:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4019:../uvc.c      ****      		break;
4020:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4021:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4022:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4023:../uvc.c      ****           		break;
4024:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4025:../uvc.c      ****           		break;
4026:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4027:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4028:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4029:../uvc.c      ****      		break;
4030:../uvc.c      **** 
4031:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4032:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4033:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4034:../uvc.c      ****     		break;
4035:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4036:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4037:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4038:../uvc.c      ****     		break;
4039:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4040:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4041:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4042:../uvc.c      ****     		break;
4043:../uvc.c      **** #endif
4044:../uvc.c      ****         default:
4045:../uvc.c      ****             /*
4046:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4047:../uvc.c      ****              * other controls.
4048:../uvc.c      ****              */
4049:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4050:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4051:../uvc.c      ****             break;
4052:../uvc.c      ****     }
4053:../uvc.c      **** 
4054:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4055:../uvc.c      ****     switch (wValue)
4056:../uvc.c      ****     {
4057:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4058:../uvc.c      ****             switch (bRequest)
4059:../uvc.c      ****             {
4060:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4061:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4062:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4063:../uvc.c      ****                     break;
4064:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4065:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4066:../uvc.c      ****                     sendData = CyTrue;
4067:../uvc.c      ****                     break;
4068:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4069:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4070:../uvc.c      ****                     sendData = CyTrue;
4071:../uvc.c      ****                     break;
4072:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4073:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4074:../uvc.c      ****                     sendData = CyTrue;
4075:../uvc.c      ****                     break;
4076:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4077:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4078:../uvc.c      ****                     sendData = CyTrue;
4079:../uvc.c      ****                     break;
4080:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4081:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4082:../uvc.c      ****                     sendData = CyTrue;
4083:../uvc.c      ****                     break;
4084:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4085:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4086:../uvc.c      ****                             glEp0Buffer, &readCount);
4087:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4088:../uvc.c      ****                     {
4089:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4090:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4091:../uvc.c      ****                     }
4092:../uvc.c      ****                     break;
4093:../uvc.c      ****                 default:
4094:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4095:../uvc.c      ****                     break;
4096:../uvc.c      ****             }
4097:../uvc.c      **** 
4098:../uvc.c      ****             if (sendData)
4099:../uvc.c      ****             {
4100:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4101:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4102:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4103:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4104:../uvc.c      ****             }
4105:../uvc.c      ****             break;
4106:../uvc.c      **** 
4107:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4108:../uvc.c      ****             switch (bRequest)
4109:../uvc.c      ****             {
4110:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4111:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4112:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4113:../uvc.c      ****                     break;
4114:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4115:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4116:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4117:../uvc.c      ****                     sendData = CyTrue;
4118:../uvc.c      ****                     break;
4119:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4120:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4121:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4122:../uvc.c      ****                     sendData = CyTrue;
4123:../uvc.c      ****                     break;
4124:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4125:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4126:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4127:../uvc.c      ****                     sendData = CyTrue;
4128:../uvc.c      ****                     break;
4129:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4130:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4131:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4132:../uvc.c      ****                     sendData = CyTrue;
4133:../uvc.c      ****                     break;
4134:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4135:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4136:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4137:../uvc.c      ****                     sendData = CyTrue;
4138:../uvc.c      ****                     break;
4139:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4140:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4141:../uvc.c      ****                             glEp0Buffer, &readCount);
4142:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4143:../uvc.c      ****                     {
4144:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4145:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4146:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4147:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4148:../uvc.c      **** 
4149:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4150:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4151:../uvc.c      ****                     }
4152:../uvc.c      ****                     break;
4153:../uvc.c      ****                 default:
4154:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4155:../uvc.c      ****                     break;
4156:../uvc.c      ****             }
4157:../uvc.c      **** 
4158:../uvc.c      ****             if (sendData)
4159:../uvc.c      ****             {
4160:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4161:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4162:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4163:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4164:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4165:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4166:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4167:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4168:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4169:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4170:../uvc.c      ****             }
4171:../uvc.c      ****             break;
4172:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4173:../uvc.c      ****         default:
4174:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4175:../uvc.c      ****             break;
4176:../uvc.c      ****     }
4177:../uvc.c      **** #endif
4178:../uvc.c      **** }
4179:../uvc.c      **** 
4180:../uvc.c      **** /*
4181:../uvc.c      ****  * Handler for UVC Interface control requests.
4182:../uvc.c      ****  */
4183:../uvc.c      **** static void
4184:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4185:../uvc.c      ****         void)
4186:../uvc.c      **** {
4187:../uvc.c      **** 
4188:../uvc.c      ****     switch (wValue)
4189:../uvc.c      ****     {
4190:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4191:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4192:../uvc.c      ****     		break;
4193:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4194:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4195:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4196:../uvc.c      ****     		break;
4197:../uvc.c      ****     	default:
4198:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4199:../uvc.c      ****      		break;
4200:../uvc.c      ****     }
4201:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4202:../uvc.c      **** 
4203:../uvc.c      **** }
4204:../uvc.c      **** 
4205:../uvc.c      **** /*
4206:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4207:../uvc.c      ****  */
4208:../uvc.c      **** static void
4209:../uvc.c      **** UVCHandleExtensionUnitRqts (
4210:../uvc.c      ****         void)
4211:../uvc.c      **** {
4212:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4213:../uvc.c      **** 
4214:../uvc.c      **** #ifdef DbgInfo
4215:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4216:../uvc.c      **** #endif
4217:../uvc.c      ****     switch (wValue)
4218:../uvc.c      ****     {
4219:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4220:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4221:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4222:../uvc.c      ****     		break;
4223:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4224:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4225:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4226:../uvc.c      ****     		break;
4227:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4228:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4229:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4230:../uvc.c      ****      		break;
4231:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4232:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4233:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4234:../uvc.c      ****     		break;
4235:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4236:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4237:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4238:../uvc.c      ****     		break;
4239:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4240:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4241:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4242:../uvc.c      ****      		break;
4243:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4244:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4245:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4246:../uvc.c      ****     		break;
4247:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4248:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4249:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4250:../uvc.c      ****     		break;
4251:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4252:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4253:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4254:../uvc.c      ****      		break;
4255:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4256:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4257:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4258:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4259:../uvc.c      ****     		}else/* no support for 1080p camera */
4260:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4261:../uvc.c      ****     		break;
4262:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4263:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4264:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4265:../uvc.c      ****     		break;
4266:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4267:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4268:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4269:../uvc.c      ****     		break;
4270:../uvc.c      **** 
4271:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4272:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4273:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4274:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4275:../uvc.c      ****     		break;
4276:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4277:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4278:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4279:../uvc.c      ****     		//break;
4280:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4281:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4282:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4283:../uvc.c      ****     		break;
4284:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4285:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4286:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4287:../uvc.c      ****     		break;
4288:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4289:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4290:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4291:../uvc.c      ****     		break;
4292:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4293:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4294:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4295:../uvc.c      ****     		break;
4296:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4297:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4298:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4299:../uvc.c      ****     		break;
4300:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4301:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4302:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4303:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4304:../uvc.c      ****     		break;
4305:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4306:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4307:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4308:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4309:../uvc.c      ****     		break;
4310:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4311:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4312:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4313:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4314:../uvc.c      ****     		break;
4315:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4316:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4317:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4318:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4319:../uvc.c      ****    		break;
4320:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4321:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4322:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4323:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4324:../uvc.c      ****     		break;
4325:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4326:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4327:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4328:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4329:../uvc.c      ****     		break;
4330:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4331:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4332:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4333:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4334:../uvc.c      ****     		break;
4335:../uvc.c      **** 		case CY_FX_EXT_CONTROL_28AGC_MAX: //AGC Maximum limitation CONTROL28
4336:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4337:../uvc.c      ****       		ControlHandle(Ext1AGCMaxLimetCtlID15);
4338:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
4339:../uvc.c      ****     		break;
4340:../uvc.c      **** 
4341:../uvc.c      ****    	default:
4342:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4343:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4344:../uvc.c      ****     		break;
4345:../uvc.c      ****     }
4346:../uvc.c      **** 
4347:../uvc.c      **** }
4348:../uvc.c      **** 
4349:../uvc.c      **** /*
4350:../uvc.c      ****  * Handler for the video streaming control requests.
4351:../uvc.c      ****  */
4352:../uvc.c      **** static void
4353:../uvc.c      **** UVCHandleVideoStreamingRqts (
4354:../uvc.c      ****         void)
4355:../uvc.c      **** {
  67              		.loc 1 4355 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4356:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4357:../uvc.c      ****     uint16_t readCount;
4358:../uvc.c      **** 
4359:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4359 0
  73 003c A8369FE5 		ldr	r3, .L133
4355:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4355 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4359 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4355:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4355 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4359 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4360:../uvc.c      ****     {
4361:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4362:../uvc.c      ****             switch (bRequest)
4363:../uvc.c      ****             {
4364:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4365:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4366:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4367:../uvc.c      ****                     break;
4368:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4369:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4370:../uvc.c      ****                     glEp0Buffer[1] = 0;
4371:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4372:../uvc.c      ****                     break;
4373:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4374:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4375:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4376:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4377:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4378:../uvc.c      ****                     {
4379:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4380:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4381:../uvc.c      **** 
4382:../uvc.c      ****                     }
4383:../uvc.c      ****                     else
4384:../uvc.c      ****                     {
4385:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4386:../uvc.c      ****                     }
4387:../uvc.c      ****                     break;
4388:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4389:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4390:../uvc.c      ****                             glCommitCtrl, &readCount);
4391:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4392:../uvc.c      ****                     {
4393:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4394:../uvc.c      ****                         {
4395:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4396:../uvc.c      ****                                active data structure. */
4397:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4398:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4399:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4400:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4401:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4402:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4403:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4404:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4405:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4406:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4407:../uvc.c      **** #if 0
4408:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4409:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4410:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4411:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4412:../uvc.c      **** #endif
4413:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4414:../uvc.c      ****                        }
4415:../uvc.c      ****                     }
4416:../uvc.c      ****                     break;
4417:../uvc.c      ****                 default:
4418:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4419:../uvc.c      ****                     break;
4420:../uvc.c      ****             }
4421:../uvc.c      ****             break;
4422:../uvc.c      **** 
4423:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4424:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4424 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4425:../uvc.c      ****             {
4426:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4427:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4428:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4429:../uvc.c      ****                     break;
4430:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4431:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4432:../uvc.c      ****                     glEp0Buffer[1] = 0;
4433:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4434:../uvc.c      ****                     break;
4435:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4436:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4437:../uvc.c      ****                     {
4438:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4439:../uvc.c      ****                     }
4440:../uvc.c      ****                     else
4441:../uvc.c      ****                     {
4442:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4443:../uvc.c      ****                     }
4444:../uvc.c      ****                     break;
4445:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4446:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4447:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4448:../uvc.c      ****                        */
4449:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4450:../uvc.c      ****                             glCommitCtrl, &readCount);
4451:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4452:../uvc.c      ****                     {
4453:../uvc.c      ****                         switch (glCommitCtrl[3])
4454:../uvc.c      ****                          {
4455:../uvc.c      ****                          	case 1: //1944
4456:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
4457:../uvc.c      ****                          		CyU3PThreadSleep(500);
4458:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4459:../uvc.c      ****                          		break;
4460:../uvc.c      ****                          	case 2: //1080
4461:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
4462:../uvc.c      ****                          		CyU3PThreadSleep(500);
4463:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4464:../uvc.c      ****                          		break;
4465:../uvc.c      ****                          	case 3: //720
4466:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
4467:../uvc.c      ****                          		CyU3PThreadSleep(500);
4468:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4469:../uvc.c      ****                          		break;
4470:../uvc.c      ****                          	case 4: //VGA
4471:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
4472:../uvc.c      ****                          		CyU3PThreadSleep(500);
4473:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4474:../uvc.c      ****                          		break;
4475:../uvc.c      ****                          	default:
4476:../uvc.c      ****                          		break;
4477:../uvc.c      ****                          }
4478:../uvc.c      ****                         setRes = glCommitCtrl[3];
4479:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4480:../uvc.c      **** 
4481:../uvc.c      **** #if 0
4482:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4483:../uvc.c      ****                         {
4484:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4485:../uvc.c      ****                         }
4486:../uvc.c      ****                         else
4487:../uvc.c      ****                         {
4488:../uvc.c      ****                             SensorScaling_VGA ();
4489:../uvc.c      ****                         }
4490:../uvc.c      **** #endif
4491:../uvc.c      ****                         /* We can start streaming video now. */
4492:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4493:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4494:../uvc.c      ****                         {
4495:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4496:../uvc.c      ****                         }
4497:../uvc.c      ****                     }
4498:../uvc.c      ****                     break;
4499:../uvc.c      **** 
4500:../uvc.c      ****                 default:
4501:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4502:../uvc.c      ****                     break;
4503:../uvc.c      ****             }
4504:../uvc.c      ****             break;
4505:../uvc.c      **** 
4506:../uvc.c      **** /* still image streaming handler */
4507:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4508:../uvc.c      ****                 switch (bRequest)
4509:../uvc.c      ****                 {
4510:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4511:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4512:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4513:../uvc.c      ****                         break;
4514:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4515:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4516:../uvc.c      ****                         glEp0Buffer[1] = 0;
4517:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4518:../uvc.c      ****                         break;
4519:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4520:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4521:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4522:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4523:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4524:../uvc.c      ****                         {
4525:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4526:../uvc.c      ****                         }
4527:../uvc.c      ****                         else
4528:../uvc.c      ****                         {
4529:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4530:../uvc.c      ****                         }
4531:../uvc.c      ****                         break;
4532:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4533:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4534:../uvc.c      ****                                 glCommitCtrl, &readCount);
4535:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4536:../uvc.c      ****                         {
4537:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4538:../uvc.c      ****                             {
4539:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4540:../uvc.c      ****                                    active data structure. */
4541:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4542:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4543:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4544:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4545:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4546:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4547:../uvc.c      ****                             }
4548:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4549:../uvc.c      ****                         }
4550:../uvc.c      ****                         break;
4551:../uvc.c      ****                     default:
4552:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4553:../uvc.c      ****                         break;
4554:../uvc.c      ****                 }
4555:../uvc.c      ****                 break;
4556:../uvc.c      **** 
4557:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4558:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4558 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4559:../uvc.c      ****                 {
4560:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4561:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4562:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4563:../uvc.c      ****                         break;
4564:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4565:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4566:../uvc.c      ****                         glEp0Buffer[1] = 0;
4567:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4568:../uvc.c      ****                         break;
4569:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4570:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4571:../uvc.c      ****                         {
4572:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4573:../uvc.c      ****                         }
4574:../uvc.c      ****                         else
4575:../uvc.c      ****                         {
4576:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4577:../uvc.c      ****                         }
4578:../uvc.c      ****                         break;
4579:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4580:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4581:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4582:../uvc.c      ****                            */
4583:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4584:../uvc.c      ****                                 glCommitCtrl, &readCount);
4585:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4586:../uvc.c      ****                         {
4587:../uvc.c      ****     #if 0
4588:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4589:../uvc.c      ****                             {
4590:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4591:../uvc.c      ****                             }
4592:../uvc.c      ****                             else
4593:../uvc.c      ****                             {
4594:../uvc.c      ****                                 SensorScaling_VGA ();
4595:../uvc.c      ****                             }
4596:../uvc.c      ****                             /* We can start streaming video now. */
4597:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4598:../uvc.c      **** 
4599:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4600:../uvc.c      ****                             {
4601:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4602:../uvc.c      ****                             }
4603:../uvc.c      **** 	#endif
4604:../uvc.c      ****                            switch (glCommitCtrl[1])
4605:../uvc.c      ****                              {
4606:../uvc.c      ****                              	case 4: //1944
4607:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
4608:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4609:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4610:../uvc.c      ****                              		break;
4611:../uvc.c      ****                              	case 3: //1080
4612:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
4613:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4614:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4615:../uvc.c      ****                              		break;
4616:../uvc.c      ****                              	case 2: //720
4617:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
4618:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4619:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4620:../uvc.c      ****                              		break;
4621:../uvc.c      ****                             	case 1: //VGA
4622:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4623:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4624:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4625:../uvc.c      ****                              		break;
4626:../uvc.c      ****                               	default:
4627:../uvc.c      ****                              		break;
4628:../uvc.c      ****                              }
4629:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4630:../uvc.c      **** 
4631:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4632:../uvc.c      **** 
4633:../uvc.c      ****                         }
4634:../uvc.c      ****                         break;
4635:../uvc.c      **** 
4636:../uvc.c      ****                     default:
4637:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4638:../uvc.c      ****                         break;
4639:../uvc.c      ****                 }
4640:../uvc.c      ****                 break;
4641:../uvc.c      **** 
4642:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4643:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4644:../uvc.c      ****             	switch (bRequest)
4645:../uvc.c      ****                 {
4646:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4647:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4647 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4648:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4648 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4649:../uvc.c      ****                         break;
4650:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4651:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4652:../uvc.c      ****                         glEp0Buffer[1] = 0;
4653:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4654:../uvc.c      ****                         break;
4655:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4656:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4657:../uvc.c      ****                         {
4658:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4659:../uvc.c      ****                         }
4660:../uvc.c      ****                         else
4661:../uvc.c      ****                         {
4662:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4663:../uvc.c      ****                         }
4664:../uvc.c      ****                         break;
4665:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4666:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4667:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4668:../uvc.c      ****                            */
4669:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4670:../uvc.c      ****                                 glCommitCtrl, &readCount);
4671:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4672:../uvc.c      ****                         {
4673:../uvc.c      ****     #if 1
4674:../uvc.c      ****                             /* We can start still streaming video now. */
4675:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4676:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4677:../uvc.c      ****                             {
4678:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4679:../uvc.c      ****                             }
4680:../uvc.c      ****     #endif
4681:../uvc.c      ****                             else{
4682:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4683:../uvc.c      ****                             //stillcont = 0;
4684:../uvc.c      ****                             }
4685:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4686:../uvc.c      ****                         }else{
4687:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4688:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4689:../uvc.c      ****                         }
4690:../uvc.c      ****                         break;
4691:../uvc.c      **** 
4692:../uvc.c      ****                     default:
4693:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4694:../uvc.c      ****                         break;
4695:../uvc.c      ****                 }
4696:../uvc.c      ****                 break;
4697:../uvc.c      **** 
4698:../uvc.c      ****         default:
4699:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4700:../uvc.c      ****             break;
4701:../uvc.c      ****     }
4702:../uvc.c      **** }
 117              		.loc 1 4702 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4359:../uvc.c      ****     {
 122              		.loc 1 4359 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4644:../uvc.c      ****                 {
 127              		.loc 1 4644 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4699:../uvc.c      ****             break;
 138              		.loc 1 4699 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4702 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4362:../uvc.c      ****             {
 151              		.loc 1 4362 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4508:../uvc.c      ****                 {
 161              		.loc 1 4508 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4565:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4565 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4652:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4652 0
 170 0124 0020A0E3 		mov	r2, #0
4653:../uvc.c      ****                         break;
 171              		.loc 1 4653 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4651:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4651 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4652:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4652 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4653:../uvc.c      ****                         break;
 178              		.loc 1 4653 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4702 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4558:../uvc.c      ****                 {
 186              		.loc 1 4558 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4583:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4583 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4585:../uvc.c      ****                         {
 201              		.loc 1 4585 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4604:../uvc.c      ****                              {
 204              		.loc 1 4604 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4508:../uvc.c      ****                 {
 217              		.loc 1 4508 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4523:../uvc.c      ****                         {
 227              		.loc 1 4523 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4525:../uvc.c      ****                         }
 229              		.loc 1 4525 0
 230 01c4 0B00A0E3 		mov	r0, #11
4523:../uvc.c      ****                         {
 231              		.loc 1 4523 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4525:../uvc.c      ****                         }
 234              		.loc 1 4525 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4529:../uvc.c      ****                         }
 236              		.loc 1 4529 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4508:../uvc.c      ****                 {
 242              		.loc 1 4508 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4533:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4533 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4535:../uvc.c      ****                         {
 254              		.loc 1 4535 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4537:../uvc.c      ****                             {
 257              		.loc 1 4537 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4541:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4541 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4542:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4542 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4541:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4541 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4542:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4542 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4548:../uvc.c      ****                         }
 272              		.loc 1 4548 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4362:../uvc.c      ****             {
 283              		.loc 1 4362 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4389:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4389 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4391:../uvc.c      ****                     {
 295              		.loc 1 4391 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4393:../uvc.c      ****                         {
 298              		.loc 1 4393 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4397:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4397 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4398:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4398 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4399:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4399 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4400:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4400 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4401:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4401 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4402:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4402 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4397:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4397 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4398:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4398 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4399:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4399 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4400:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4400 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4401:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4401 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4402:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4402 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4436:../uvc.c      ****                     {
 331              		.loc 1 4436 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4385:../uvc.c      ****                     }
 337              		.loc 1 4385 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4644:../uvc.c      ****                 {
 344              		.loc 1 4644 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4669:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4669 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4671:../uvc.c      ****                         {
 354              		.loc 1 4671 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4675:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4675 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4676:../uvc.c      ****                             {
 363              		.loc 1 4676 0
 364 030c 002050E2 		subs	r2, r0, #0
4682:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4682 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4676:../uvc.c      ****                             {
 368              		.loc 1 4676 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4685:../uvc.c      ****                         }else{
 372              		.loc 1 4685 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4424:../uvc.c      ****             {
 384              		.loc 1 4424 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4449:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4449 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4451:../uvc.c      ****                     {
 394              		.loc 1 4451 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4453:../uvc.c      ****                          {
 397              		.loc 1 4453 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4438:../uvc.c      ****                     }
 410              		.loc 1 4438 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4471:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4471 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4472:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4472 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4473:../uvc.c      ****                          		break;
 436              		.loc 1 4473 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4479:../uvc.c      **** 
 451              		.loc 1 4479 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4478:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4478 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4479:../uvc.c      **** 
 457              		.loc 1 4479 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4492:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4492 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4493:../uvc.c      ****                         {
 466              		.loc 1 4493 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4495:../uvc.c      ****                         }
 469              		.loc 1 4495 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4612:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4612 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4614:../uvc.c      ****                              		break;
 489              		.loc 1 4614 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4631:../uvc.c      **** 
 501              		.loc 1 4631 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4629:../uvc.c      **** 
 506              		.loc 1 4629 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4631:../uvc.c      **** 
 508              		.loc 1 4631 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4617:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4617 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4619:../uvc.c      ****                              		break;
 529              		.loc 1 4619 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
4624:../uvc.c      ****                              		break;
 537              		.loc 1 4624 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4625:../uvc.c      ****                               	default:
 544              		.loc 1 4625 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4622:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4622 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4624:../uvc.c      ****                              		break;
 562              		.loc 1 4624 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4466:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4466 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4467:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4467 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4468:../uvc.c      ****                          		break;
 590              		.loc 1 4468 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4461:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4461 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4462:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4462 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4463:../uvc.c      ****                          		break;
 615              		.loc 1 4463 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4464:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4464 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4456:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4456 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4457:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4457 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4458:../uvc.c      ****                          		break;
 645              		.loc 1 4458 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4459:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4459 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4607:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4607 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4609:../uvc.c      ****                              		break;
 671              		.loc 1 4609 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4610:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4610 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4651:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4651 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4377:../uvc.c      ****                     {
 691              		.loc 1 4377 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4379:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4379 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4380:../uvc.c      **** 
 701              		.loc 1 4380 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4687:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4687 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4688:../uvc.c      ****                         }
 718              		.loc 1 4688 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4678:../uvc.c      ****                             }
 727              		.loc 1 4678 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4453:../uvc.c      ****                          {
 736              		.loc 1 4453 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4703:../uvc.c      **** 
4704:../uvc.c      **** /*
4705:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4706:../uvc.c      ****  */
4707:../uvc.c      **** void
4708:../uvc.c      **** UVCAppEP0Thread_Entry (
4709:../uvc.c      ****         uint32_t input)
4710:../uvc.c      **** {
4711:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4712:../uvc.c      ****     uint32_t eventFlag;
4713:../uvc.c      **** 	CyBool_t value;
4714:../uvc.c      **** 	CyBool_t *valueptr = &value;
4715:../uvc.c      **** 
4716:../uvc.c      **** 
4717:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4718:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4719:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4720:../uvc.c      **** 
4721:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4722:../uvc.c      **** #endif
4723:../uvc.c      **** 
4724:../uvc.c      ****     /* for interrupt status test */
4725:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4726:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4727:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4728:../uvc.c      **** 
4729:../uvc.c      ****     for (;;)
4730:../uvc.c      ****     {
4731:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4732:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4733:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4734:../uvc.c      ****         {
4735:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4736:../uvc.c      ****             if (!isUsbConnected)
4737:../uvc.c      ****             {
4738:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4739:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4740:../uvc.c      ****                 {
4741:../uvc.c      ****                     isUsbConnected = CyTrue;
4742:../uvc.c      ****                 }
4743:../uvc.c      ****             }
4744:../uvc.c      **** //#ifdef DbgInfo
4745:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4746:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4747:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4748:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4749:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4750:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4751:../uvc.c      **** //#endif
4752:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4753:../uvc.c      ****             {
4754:../uvc.c      ****             	switch ((wIndex >> 8))
4755:../uvc.c      ****                 {
4756:../uvc.c      **** 
4757:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4758:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4759:../uvc.c      ****                         break;
4760:../uvc.c      **** 
4761:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4762:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4763:../uvc.c      ****                         break;
4764:../uvc.c      **** 
4765:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4766:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4767:../uvc.c      ****                         break;
4768:../uvc.c      **** 
4769:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4770:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4771:../uvc.c      ****                         break;
4772:../uvc.c      **** 
4773:../uvc.c      ****                     default:
4774:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4775:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4776:../uvc.c      ****                         break;
4777:../uvc.c      ****                 }
4778:../uvc.c      ****             }
4779:../uvc.c      **** 
4780:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4781:../uvc.c      ****             {
4782:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4783:../uvc.c      **** 
4784:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4785:../uvc.c      ****                 {
4786:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4787:../uvc.c      ****                 }
4788:../uvc.c      ****                 else
4789:../uvc.c      ****                 {
4790:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4791:../uvc.c      ****                 }
4792:../uvc.c      ****             }
4793:../uvc.c      **** 
4794:../uvc.c      ****             /* handle interrupt status event */
4795:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4796:../uvc.c      ****             {
4797:../uvc.c      **** 
4798:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4799:../uvc.c      ****             	/** preparing interrupt status data **/
4800:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4801:../uvc.c      **** 
4802:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4803:../uvc.c      **** 
4804:../uvc.c      **** #if 0 //for real button
4805:../uvc.c      **** 				if(value&&(!snapButFlag)){
4806:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4807:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4808:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4809:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4810:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4811:../uvc.c      **** 
4812:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4813:../uvc.c      **** 					interStabuf.size   = 1024;
4814:../uvc.c      **** 					interStabuf.status = 0;
4815:../uvc.c      **** 
4816:../uvc.c      **** 					interStabuf.count = 4;
4817:../uvc.c      **** 
4818:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4819:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4820:../uvc.c      **** 
4821:../uvc.c      **** 					/** send a interrupt status data **/
4822:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4823:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4824:../uvc.c      **** 					{
4825:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4826:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4827:../uvc.c      **** 					}
4828:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4829:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4830:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4831:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4832:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4833:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4834:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4835:../uvc.c      **** 
4836:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4837:../uvc.c      **** 					interStabuf.size   = 1024;
4838:../uvc.c      **** 					interStabuf.status = 0;
4839:../uvc.c      **** 
4840:../uvc.c      **** 					interStabuf.count = 4;
4841:../uvc.c      **** 
4842:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4843:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4844:../uvc.c      **** 
4845:../uvc.c      **** 					/** send a interrupt status data **/
4846:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4847:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4848:../uvc.c      **** 					{
4849:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4850:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4851:../uvc.c      **** 					}
4852:../uvc.c      **** 
4853:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4854:../uvc.c      **** 					stiflag = 0xFF;
4855:../uvc.c      **** 				}
4856:../uvc.c      **** #else			//for botton simulation
4857:../uvc.c      **** 				if(snapButFlag == 0x0f){
4858:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4859:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4860:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4861:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4862:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4863:../uvc.c      **** 
4864:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4865:../uvc.c      **** 					interStabuf.size   = 1024;
4866:../uvc.c      **** 					interStabuf.status = 0;
4867:../uvc.c      **** 
4868:../uvc.c      **** 					interStabuf.count = 4;
4869:../uvc.c      **** 
4870:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4871:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4872:../uvc.c      **** 
4873:../uvc.c      **** 					/** send a interrupt status data **/
4874:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4875:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4876:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4877:../uvc.c      **** 					{
4878:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4879:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4880:../uvc.c      **** 					}
4881:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4882:../uvc.c      **** 
4883:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4884:../uvc.c      **** 				}else if(!snapButFlag){
4885:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4886:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4887:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4888:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4889:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4890:../uvc.c      **** 
4891:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4892:../uvc.c      **** 					interStabuf.size   = 1024;
4893:../uvc.c      **** 					interStabuf.status = 0;
4894:../uvc.c      **** 
4895:../uvc.c      **** 					interStabuf.count = 4;
4896:../uvc.c      **** 
4897:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4898:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4899:../uvc.c      **** 
4900:../uvc.c      **** 					/** send a interrupt status data **/
4901:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4902:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4903:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4904:../uvc.c      **** 					{
4905:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4906:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4907:../uvc.c      **** 					}
4908:../uvc.c      **** 
4909:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4910:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4911:../uvc.c      **** 				}
4912:../uvc.c      **** #endif
4913:../uvc.c      **** 
4914:../uvc.c      ****             }
4915:../uvc.c      **** 
4916:../uvc.c      **** 
4917:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4918:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4919:../uvc.c      ****             {
4920:../uvc.c      ****                 /* Get the command buffer */
4921:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4922:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4923:../uvc.c      ****                 {
4924:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4925:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4926:../uvc.c      ****                 }
4927:../uvc.c      **** 
4928:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4929:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4930:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4931:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4932:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4933:../uvc.c      ****                  * register value high byte and register value low byte.
4934:../uvc.c      ****                  */
4935:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4936:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4937:../uvc.c      ****                 {
4938:../uvc.c      ****                     if (dmaInfo.count == 3)
4939:../uvc.c      ****                     {
4940:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4941:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4942:../uvc.c      ****                         dmaInfo.count = 3;
4943:../uvc.c      ****                     }
4944:../uvc.c      ****                     else if (dmaInfo.count == 4)
4945:../uvc.c      ****                     {
4946:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4947:../uvc.c      ****                         {
4948:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4949:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4950:../uvc.c      ****                         }
4951:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4952:../uvc.c      ****                     }
4953:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4954:../uvc.c      ****                 }
4955:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4956:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4957:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4958:../uvc.c      ****                  */
4959:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4960:../uvc.c      ****                 {
4961:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4962:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4963:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4964:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4965:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4966:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4967:../uvc.c      ****                         	break;
4968:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4969:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4970:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4971:../uvc.c      ****                         	break;*/
4972:../uvc.c      ****                     dmaInfo.count -= 2;
4973:../uvc.c      ****                 }
4974:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4975:../uvc.c      ****                 else
4976:../uvc.c      ****                 {
4977:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4978:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4979:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4980:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4981:../uvc.c      ****                 }
4982:../uvc.c      **** 
4983:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4984:../uvc.c      ****                 dmaInfo.size   = 1024;
4985:../uvc.c      ****                 dmaInfo.status = 0;
4986:../uvc.c      **** 
4987:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4988:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4989:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4990:../uvc.c      ****                 {
4991:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4992:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4993:../uvc.c      ****                 }
4994:../uvc.c      **** 
4995:../uvc.c      ****                 /* Wait until the response has gone out. */
4996:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4997:../uvc.c      **** 
4998:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4999:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5000:../uvc.c      ****                 {
5001:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
5002:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5003:../uvc.c      ****                 }
5004:../uvc.c      ****             }
5005:../uvc.c      **** #endif
5006:../uvc.c      ****         }
5007:../uvc.c      ****         /* Allow other ready threads to run. */
5008:../uvc.c      ****         CyU3PThreadRelinquish ();
5009:../uvc.c      ****     }
5010:../uvc.c      **** }
5011:../uvc.c      **** 
5012:../uvc.c      **** /*
5013:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5014:../uvc.c      ****  * added 10/2013
5015:../uvc.c      ****  */
5016:../uvc.c      **** /*
5017:../uvc.c      **** static uint8_t timeDelay[64] = {
5018:../uvc.c      **** 
5019:../uvc.c      **** };
5020:../uvc.c      **** */
5021:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5021 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5022:../uvc.c      **** 
5023:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5024:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5025:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5026:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5027:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5028:../uvc.c      **** 	uint32_t flag = 0;
5029:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5030:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5031:../uvc.c      **** 	uint8_t i;
5032:../uvc.c      **** 	uint16_t delaytime;
5033:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5034:../uvc.c      **** 
5035:../uvc.c      **** #if 0 //for test the command queue
5036:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5037:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5038:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5039:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5040:../uvc.c      **** 		lcCmdDes += 1;
5041:../uvc.c      **** 	}
5042:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5043:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5044:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5045:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5046:../uvc.c      **** 		lcCmdDes += 1;
5047:../uvc.c      **** 	}
5048:../uvc.c      **** 
5049:../uvc.c      **** #endif
5050:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5051:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5051 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5021:../uvc.c      **** 
 786              		.loc 1 5021 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5028:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5028 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5051 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5028:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5028 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5051 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5052:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5052 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5053:../uvc.c      **** 	CyU3PThreadSleep(50);
5054:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5055:../uvc.c      **** 
5056:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5056 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5052:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5052 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5053:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5053 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5054:../uvc.c      **** 
 823              		.loc 1 5054 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5056 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5057:../uvc.c      ****         /* Allow other ready threads to run. */
5058:../uvc.c      **** 
5059:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5059 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5056:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5056 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5060:../uvc.c      **** 	}
5061:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5061 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5062:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5063:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5064:../uvc.c      **** 	//CyU3PThreadSleep(100);
5065:../uvc.c      **** 	//SetCurCmd();
5066:../uvc.c      **** 	/*********** the loop of the thread ***********/
5067:../uvc.c      **** 	for(;;){
5068:../uvc.c      **** 
5069:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5069 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5070:../uvc.c      **** /*  // for test GPIO output
5071:../uvc.c      **** 		if(trigger)
5072:../uvc.c      **** 		{
5073:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5074:../uvc.c      **** 			{
5075:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5076:../uvc.c      **** 			}
5077:../uvc.c      **** 
5078:../uvc.c      **** 		}else{
5079:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5080:../uvc.c      **** 			{
5081:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5082:../uvc.c      **** 			}
5083:../uvc.c      **** 
5084:../uvc.c      **** 		}
5085:../uvc.c      **** */
5086:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5086 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5087:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5088:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5089:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5090:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5091:../uvc.c      **** 				i = 0;
5092:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5092 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5093:../uvc.c      **** 					i++;
5094:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5095:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5096:../uvc.c      **** 				}
5097:../uvc.c      **** #if 0
5098:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5099:../uvc.c      **** 				i = lcStaDes->curNum;
5100:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5101:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5102:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5103:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5104:../uvc.c      **** 
5105:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5106:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5107:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5108:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5109:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5110:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5111:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5112:../uvc.c      **** #endif
5113:../uvc.c      **** 				//}
5114:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5115:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5116:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5117:../uvc.c      **** 				/* setting delay */
5118:../uvc.c      **** 				delaytime = 300;
5119:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5120:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5121:../uvc.c      **** 			} //end of the if condition statment
5122:../uvc.c      **** #endif
5123:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5123 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5124:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5125:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5125 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5126:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5126 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5127:../uvc.c      **** 
5128:../uvc.c      **** 				/*
5129:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5130:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5131:../uvc.c      **** 				*/
5132:../uvc.c      **** 
5133:../uvc.c      **** 				/* find a available command */
5134:../uvc.c      **** 				i = 0;
5135:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5135 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5135 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5136:../uvc.c      **** 					i++;
5137:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5137 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5135:../uvc.c      **** 					i++;
 905              		.loc 1 5135 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5138:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5139:../uvc.c      **** 				}
5140:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5141:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5142:../uvc.c      **** 					i = lcCmdDes->curNum;
5143:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5144:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5145:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5146:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5147:../uvc.c      **** #if 1
5148:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5148 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5143:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5143 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5144:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5144 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5145:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5145 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5146:../uvc.c      **** #if 1
 927              		.loc 1 5146 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5148 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5149:../uvc.c      **** 						case 0x20:
5150:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5151:../uvc.c      **** 							delaytime = 500;
5152:../uvc.c      **** 							break;
5153:../uvc.c      **** 						case 0x21:
5154:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5155:../uvc.c      **** 							delaytime = 500;
5156:../uvc.c      **** 							break;
5157:../uvc.c      **** 						case 0x22:
5158:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5159:../uvc.c      **** 							delaytime = 300;
5160:../uvc.c      **** 							break;
5161:../uvc.c      **** 						case 0x23:
5162:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5162 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5163:../uvc.c      **** 							delaytime = 300;
5164:../uvc.c      **** 							break;
 945              		.loc 1 5164 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5165:../uvc.c      **** 						default:
5166:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5167:../uvc.c      **** 							break;
5168:../uvc.c      **** 					}
5169:../uvc.c      **** #endif
5170:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5171:../uvc.c      **** 					/** timer's ticket modify **/
5172:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5173:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5173 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5174:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5174 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5175:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5176:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5177:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5178:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5179:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5180:../uvc.c      **** #endif
5181:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5181 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5182:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5183:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5184:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5185:../uvc.c      **** 						}else{
5186:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5187:../uvc.c      **** 						}
5188:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5189:../uvc.c      **** 					}else{
5190:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5190 0
 964 08d4 013083E2 		add	r3, r3, #1
5191:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5191 0
 966 08d8 0F20A0E3 		mov	r2, #15
5190:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5190 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5191 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5192:../uvc.c      **** 					}
5193:../uvc.c      **** 				}else{
5194:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5195:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5196:../uvc.c      **** //					CyU3PDebugPrint (4, "I2C thread beat pace 0x%x\r\n",
5197:../uvc.c      **** //							1000);
5198:../uvc.c      **** 				}
5199:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5199 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5200:../uvc.c      **** 			}
5201:../uvc.c      **** /*
5202:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5203:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5204:../uvc.c      **** */
5205:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5206:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5207:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5208:../uvc.c      **** #endif
5209:../uvc.c      **** 
5210:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5211:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5212:../uvc.c      **** #if 0
5213:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5214:../uvc.c      **** 
5215:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5216:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5217:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5218:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5219:../uvc.c      **** 			    i = 0;
5220:../uvc.c      **** 				 switch(cmdCopyIdx)
5221:../uvc.c      **** 				 {
5222:../uvc.c      **** 					 case BrgtCtlID1:
5223:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5224:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5225:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5226:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5227:../uvc.c      **** 							 i++;
5228:../uvc.c      **** 						 }
5229:../uvc.c      **** 						 else{
5230:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5231:../uvc.c      **** 						 }
5232:../uvc.c      **** 
5233:../uvc.c      **** 						 CyU3PBusyWait(500);
5234:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5235:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5236:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5237:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5238:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5239:../uvc.c      **** 						 }
5240:../uvc.c      **** 						 else{
5241:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5242:../uvc.c      **** 						 }
5243:../uvc.c      **** 						 break;
5244:../uvc.c      **** 					 case HueCtlID5:
5245:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5246:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5247:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5248:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5249:../uvc.c      **** 						 }
5250:../uvc.c      **** 						 else{
5251:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5252:../uvc.c      **** 						 }
5253:../uvc.c      **** 						 break;
5254:../uvc.c      **** 					 case SaturCtlID6:
5255:../uvc.c      **** 					 case WBTLevCtlID10:
5256:../uvc.c      **** 					 default:
5257:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5258:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5259:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5260:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5261:../uvc.c      **** 						 }
5262:../uvc.c      **** 						 else{
5263:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5264:../uvc.c      **** 						 }
5265:../uvc.c      **** 						 break;
5266:../uvc.c      **** 				 }
5267:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5268:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5269:../uvc.c      **** 			}
5270:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5271:../uvc.c      **** #endif
5272:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5273:../uvc.c      **** 		/* Allow other ready threads to run. */
5274:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5275:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5275 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5276:../uvc.c      **** 		}
 980              		.loc 1 5276 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5154:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5154 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5156:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5156 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5150:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5150 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5152:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5152 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5194:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5194 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5195:../uvc.c      **** //					CyU3PDebugPrint (4, "I2C thread beat pace 0x%x\r\n",
 1010              		.loc 1 5195 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5183:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5183 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5182:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5182 0
 1020 0934 0020A0E3 		mov	r2, #0
5183:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5183 0
 1022 0938 230053E3 		cmp	r3, #35
5184:../uvc.c      **** 						}else{
 1023              		.loc 1 5184 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5186:../uvc.c      **** 						}
 1026              		.loc 1 5186 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5184:../uvc.c      **** 						}else{
 1028              		.loc 1 5184 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5186:../uvc.c      **** 						}
 1030              		.loc 1 5186 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5184:../uvc.c      **** 						}else{
 1032              		.loc 1 5184 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5186:../uvc.c      **** 						}
 1034              		.loc 1 5186 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5188:../uvc.c      **** 					}else{
 1036              		.loc 1 5188 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5182:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5182 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5188:../uvc.c      **** 					}else{
 1040              		.loc 1 5188 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5166:../uvc.c      **** 							break;
 1045              		.loc 1 5166 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5167:../uvc.c      **** 					}
 1049              		.loc 1 5167 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2851:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2851 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2858:../uvc.c      ****     {
 1075              		.loc 1 2858 0
 1076 0994 080051E3 		cmp	r1, #8
2851:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2851 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2858:../uvc.c      ****     {
 1089              		.loc 1 2858 0
 1090 09a4 0B00000A 		beq	.L174
2910:../uvc.c      ****     {
 1091              		.loc 1 2910 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2912:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2912 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2913:../uvc.c      ****     }
 1096              		.loc 1 2913 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2912:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2912 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2913:../uvc.c      ****     }
 1102              		.loc 1 2913 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2912:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2912 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2915:../uvc.c      **** 
 1111              		.loc 1 2915 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2860:../uvc.c      ****             {
 1117              		.loc 1 2860 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2874:../uvc.c      ****                 fb++;
 1121              		.loc 1 2874 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2860:../uvc.c      ****             {
 1123              		.loc 1 2860 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2598:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2598 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2860:../uvc.c      ****             {
 1132              		.loc 1 2860 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2598:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2598 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2599:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2599 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2600:../uvc.c      **** 
 1147              		.loc 1 2600 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2605:../uvc.c      ****     }
 1151              		.loc 1 2605 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2881:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2881 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2605:../uvc.c      ****     }
 1159              		.loc 1 2605 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2887:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2887 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2881:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2881 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2882:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2882 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2881:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2881 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2887:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2887 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2881:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2881 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2882:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2882 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2599:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2599 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2887:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2887 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2894:../uvc.c      ****             }
 1187              		.loc 1 2894 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2898 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2899:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2899 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2898 0
 1196 0a54 013082E2 		add	r3, r2, #1
2899:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2899 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2898 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2899:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2899 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2898 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2899:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2899 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2898 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2899:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2899 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2898:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2898 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2902:../uvc.c      ****             {
 1215              		.loc 1 2902 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2904:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2904 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2905:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2905 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2904:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2904 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2905:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2905 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2598:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2598 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2875:../uvc.c      ****             }
 1246              		.loc 1 2875 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2598:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2598 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2874:../uvc.c      ****                 fb++;
 1255              		.loc 1 2874 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2599:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2599 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2600:../uvc.c      **** 
 1266              		.loc 1 2600 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2875:../uvc.c      ****             }
 1272              		.loc 1 2875 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2888:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2888 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2889:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2889 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2890:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2890 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2889:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2889 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2890:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2890 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2891:../uvc.c      ****                 }
 1295              		.loc 1 2891 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2654:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2654 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2655:../uvc.c      ****     {
 1322              		.loc 1 2655 0
 1323 0b40 020050E3 		cmp	r0, #2
2654:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2654 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2655:../uvc.c      ****     {
 1336              		.loc 1 2655 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2691:../uvc.c      **** 
 1344              		.loc 1 2691 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2674:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2674 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2676:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2676 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2674:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2674 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2675:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2675 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2676:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2676 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2638:../uvc.c      **** 	{
 1372              		.loc 1 2638 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2676:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2676 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2677:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2677 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2678:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2678 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2638:../uvc.c      **** 	{
 1388              		.loc 1 2638 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2641:../uvc.c      **** 
 1395              		.loc 1 2641 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2644:../uvc.c      **** 	}
 1401              		.loc 1 2644 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2658:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2658 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2660:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2660 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2659:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2659 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2660:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2660 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2638:../uvc.c      **** 	{
 1433              		.loc 1 2638 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2660:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2660 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2661:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2661 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2638:../uvc.c      **** 	{
 1447              		.loc 1 2638 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2641:../uvc.c      **** 
 1454              		.loc 1 2641 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2644:../uvc.c      **** 	}
 1460              		.loc 1 2644 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2666:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2666 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2668:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2668 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2666:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2666 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2667:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2667 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2668:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2668 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2638:../uvc.c      **** 	{
 1493              		.loc 1 2638 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2668:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2668 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2669:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2669 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2638:../uvc.c      **** 	{
 1507              		.loc 1 2638 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2641:../uvc.c      **** 
 1514              		.loc 1 2641 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2644:../uvc.c      **** 	}
 1520              		.loc 1 2644 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2699:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2699 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2708:../uvc.c      **** 
 1560              		.loc 1 2708 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2705:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2705 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2707:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2707 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2704:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2704 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2706:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2706 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2707:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2707 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2704:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2704 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2705:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2705 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2707:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2707 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2708:../uvc.c      **** 
 1579              		.loc 1 2708 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2706:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2706 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2711:../uvc.c      ****     {
 1584              		.loc 1 2711 0
 1585 0d00 020054E3 		cmp	r4, #2
2699:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2699 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2705:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2705 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2707:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2707 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2708:../uvc.c      **** 
 1594              		.loc 1 2708 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2704:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2704 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2706:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2706 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2711:../uvc.c      ****     {
 1600              		.loc 1 2711 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2700:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2700 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2838:../uvc.c      **** 
 1612              		.loc 1 2838 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2711:../uvc.c      ****     {
 1618              		.loc 1 2711 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2751:../uvc.c      ****             {
 1621              		.loc 1 2751 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2755:../uvc.c      ****                 {
 1624              		.loc 1 2755 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2755:../uvc.c      ****                 {
 1627              		.loc 1 2755 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2760:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2760 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2758:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2758 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2759:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2759 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2763:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2763 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2760:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2760 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2761:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2761 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2763:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2763 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2764:../uvc.c      **** 
 1652              		.loc 1 2764 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2767:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2767 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2768:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2768 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2769:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2769 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2770:../uvc.c      **** 
 1669              		.loc 1 2770 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2773:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2773 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2776:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2776 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2638:../uvc.c      **** 	{
 1684              		.loc 1 2638 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2778:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2778 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2638:../uvc.c      **** 	{
 1696              		.loc 1 2638 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2641:../uvc.c      **** 
 1703              		.loc 1 2641 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2644:../uvc.c      **** 	}
 1709              		.loc 1 2644 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2716:../uvc.c      ****             {
 1722              		.loc 1 2716 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2734:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2734 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2736:../uvc.c      ****                         {
 1736              		.loc 1 2736 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2720:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2720 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2838:../uvc.c      **** 
 1744              		.loc 1 2838 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2786:../uvc.c      ****             {
 1750              		.loc 1 2786 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2788:../uvc.c      ****                 {
 1753              		.loc 1 2788 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2794:../uvc.c      ****                     {
 1756              		.loc 1 2794 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2826:../uvc.c      ****                     }
 1762              		.loc 1 2826 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2825:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2825 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2721:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2721 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2723:../uvc.c      ****                         {
 1777              		.loc 1 2723 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2725:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2725 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2726:../uvc.c      ****                         }
 1786              		.loc 1 2726 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2739:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2739 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2740:../uvc.c      ****                         }
 1801              		.loc 1 2740 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2733:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2733 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2796:../uvc.c      **** 
 1812              		.loc 1 2796 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2799:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2799 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2800:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2800 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2804:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2804 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2800:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2800 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2801:../uvc.c      **** 
 1829              		.loc 1 2801 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2804:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2804 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2805:../uvc.c      **** 
 1834              		.loc 1 2805 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2808:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2808 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2809:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2809 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2810:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2810 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2811:../uvc.c      **** 
 1851              		.loc 1 2811 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2814:../uvc.c      **** 
 1855              		.loc 1 2814 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2818:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2818 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2638:../uvc.c      **** 	{
 1866              		.loc 1 2638 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2820:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2820 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2638:../uvc.c      **** 	{
 1878              		.loc 1 2638 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2641:../uvc.c      **** 
 1885              		.loc 1 2641 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2644:../uvc.c      **** 	}
 1891              		.loc 1 2644 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1205:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1205 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1208 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1205:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1205 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1213 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1208 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1209:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1209 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1210:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1210 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1213 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1216:../uvc.c      **** 	{
 1980              		.loc 1 1216 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1226:../uvc.c      **** 	{
 1985              		.loc 1 1226 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1251:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1251 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1270:../uvc.c      **** 
 1993              		.loc 1 1270 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1253 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1258 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1258 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1263:../uvc.c      **** 			}
 2018              		.loc 1 1263 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1270:../uvc.c      **** 
 2025              		.loc 1 1270 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1242 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1228:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1228 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1242 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1228:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1228 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1242 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1243 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1244:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1244 0
 2051 10c4 020056E3 		cmp	r6, #2
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1243 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1245:../uvc.c      **** 				}
 2054              		.loc 1 1245 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1228:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1228 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1245:../uvc.c      **** 				}
 2058              		.loc 1 1245 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1247:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1247 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1270:../uvc.c      **** 
 2063              		.loc 1 1270 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1216:../uvc.c      **** 	{
 2069              		.loc 1 1216 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1218:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1218 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1219:../uvc.c      **** 			{
 2081              		.loc 1 1219 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1223:../uvc.c      **** 
 2083              		.loc 1 1223 0
 2084 1114 0400A0E3 		mov	r0, #4
1219:../uvc.c      **** 			{
 2085              		.loc 1 1219 0
 2086 1118 000051E3 		cmp	r1, #0
1221:../uvc.c      **** 			}
 2087              		.loc 1 1221 0
 2088 111c 80208203 		orreq	r2, r2, #128
1223:../uvc.c      **** 
 2089              		.loc 1 1223 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1221:../uvc.c      **** 			}
 2092              		.loc 1 1221 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1223:../uvc.c      **** 
 2094              		.loc 1 1223 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1253 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1255:../uvc.c      **** 			}
 2103              		.loc 1 1255 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1254:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1254 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1258 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1259:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1259 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1260:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1260 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1261:../uvc.c      **** 				}
 2142              		.loc 1 1261 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1276 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1276 0
 2180 11d8 0040A0E1 		mov	r4, r0
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1279 0
 2182 11dc 0060A0E3 		mov	r6, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1278 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1279 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1280 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1281:../uvc.c      **** }
 2213              		.loc 1 1281 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1282:../uvc.c      **** 
 2215              		.loc 1 1282 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1281:../uvc.c      **** }
 2220              		.loc 1 1281 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1286 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1291:../uvc.c      **** 	case 1:
 2236              		.loc 1 1291 0
 2237 1248 013040E2 		sub	r3, r0, #1
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1286 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1291:../uvc.c      **** 	case 1:
 2249              		.loc 1 1291 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1313:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1313 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1315:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1315 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1316:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1316 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1315:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1315 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1316:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1316 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1318:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1318 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1321 0
 2298 12d8 0150A0E3 		mov	r5, #1
1322:../uvc.c      **** 		break;
 2299              		.loc 1 1322 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1321 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1322:../uvc.c      **** 		break;
 2305              		.loc 1 1322 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1331:../uvc.c      **** 
 2310              		.loc 1 1331 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1297:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1297 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1299:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1299 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1300:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1300 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1299:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1299 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1300:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1300 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1327:../uvc.c      **** 		break;
 2345              		.loc 1 1327 0
 2346 133c 0140A0E3 		mov	r4, #1
1326:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1326 0
 2348 1340 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 
 2349              		.loc 1 1331 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1326:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1326 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1331:../uvc.c      **** 
 2355              		.loc 1 1331 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1333 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 32
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1341 0
 2399 137c C07F9FE5 		ldr	r7, .L438
1340:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1340 0
 2401 1380 0F0050E3 		cmp	r0, #15
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1341 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1348 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1333 0
 2408 1390 3CD04DE2 		sub	sp, sp, #60
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 96
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1348 0
 2412 1394 00C0D3E5 		ldrb	ip, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1349 0
 2414 1398 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1350 0
 2416 139c 0FB0D3E5 		ldrb	fp, [r3, #15]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1351 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 2419              		.loc 1 1359 0
 2420 13a4 9C3F9FE5 		ldr	r3, .L438+4
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2421              		.loc 1 1349 0
 2422 13a8 FF2002E2 		and	r2, r2, #255
1359:../uvc.c      ****     /*
 2423              		.loc 1 1359 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2425              		.loc 1 1333 0
 2426 13b0 0050A0E1 		mov	r5, r0
1367:../uvc.c      **** 		 {
 2427              		.loc 1 1367 0
 2428 13b4 830056E3 		cmp	r6, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2429              		.loc 1 1348 0
 2430 13b8 FFC00CE2 		and	ip, ip, #255
 2431              	.LVL269:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2432              		.loc 1 1349 0
 2433 13bc 20208DE5 		str	r2, [sp, #32]
 2434              	.LVL270:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2435              		.loc 1 1350 0
 2436 13c0 FFB00BE2 		and	fp, fp, #255
 2437              	.LVL271:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2438              		.loc 1 1351 0
 2439 13c4 FF8008E2 		and	r8, r8, #255
 2440              	.LVL272:
1367:../uvc.c      **** 		 {
 2441              		.loc 1 1367 0
 2442 13c8 B200000A 		beq	.L275
 2443 13cc 1500009A 		bls	.L423
 2444 13d0 850056E3 		cmp	r6, #133
 2445 13d4 A300000A 		beq	.L280
 2446 13d8 BD00003A 		bcc	.L281
 2447 13dc 860056E3 		cmp	r6, #134
 2448 13e0 6600000A 		beq	.L282
 2449 13e4 870056E3 		cmp	r6, #135
 2450 13e8 9500001A 		bne	.L274
1787:../uvc.c      **** 		 		 if(Len == 2){
 2451              		.loc 1 1787 0
 2452 13ec 0F0050E3 		cmp	r0, #15
1789:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2453              		.loc 1 1789 0
 2454 13f0 005187E0 		add	r5, r7, r0, asl #2
1787:../uvc.c      **** 		 		 if(Len == 2){
 2455              		.loc 1 1787 0
 2456 13f4 C400009A 		bls	.L328
1788:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2457              		.loc 1 1788 0
 2458 13f8 020058E3 		cmp	r8, #2
 2459 13fc 0801000A 		beq	.L424
1794:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2460              		.loc 1 1794 0
 2461 1400 202015E5 		ldr	r2, [r5, #-32]
 2462 1404 844F9FE5 		ldr	r4, .L438+76
 2463 1408 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1795:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2464              		.loc 1 1795 0
 2465 140c 0030A0E3 		mov	r3, #0
1794:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2466              		.loc 1 1794 0
 2467 1410 2810C4E5 		strb	r1, [r4, #40]
1795:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2468              		.loc 1 1795 0
 2469 1414 2930C4E5 		strb	r3, [r4, #41]
1796:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2470              		.loc 1 1796 0
 2471 1418 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1797:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2472              		.loc 1 1797 0
 2473 141c 2B30C4E5 		strb	r3, [r4, #43]
1796:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2474              		.loc 1 1796 0
 2475 1420 2A20C4E5 		strb	r2, [r4, #42]
 2476 1424 E70000EA 		b	.L331
 2477              	.L423:
1367:../uvc.c      **** 		 {
 2478              		.loc 1 1367 0
 2479 1428 810056E3 		cmp	r6, #129
 2480 142c 6E00000A 		beq	.L277
 2481 1430 4300008A 		bhi	.L278
 2482 1434 010056E3 		cmp	r6, #1
 2483 1438 8100001A 		bne	.L274
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2484              		.loc 1 1823 0
 2485 143c 4C4F9FE5 		ldr	r4, .L438+76
 2486 1440 36208DE2 		add	r2, sp, #54
 2487 1444 2000A0E3 		mov	r0, #32
 2488              	.LVL273:
 2489 1448 281084E2 		add	r1, r4, #40
 2490 144c 18C08DE5 		str	ip, [sp, #24]
 2491 1450 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2492              	.LVL274:
1825:../uvc.c      **** 			   {
 2493              		.loc 1 1825 0
 2494 1454 18C09DE5 		ldr	ip, [sp, #24]
 2495 1458 002050E2 		subs	r2, r0, #0
 2496 145c 6504001A 		bne	.L333
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2497              		.loc 1 1827 0
 2498 1460 020058E3 		cmp	r8, #2
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2499              		.loc 1 1828 0
 2500 1464 2800D405 		ldreqb	r0, [r4, #40]	@ zero_extendqisi2
 2501              	.LVL275:
1829:../uvc.c      **** 				 }else{
 2502              		.loc 1 1829 0
 2503 1468 2910D405 		ldreqb	r1, [r4, #41]	@ zero_extendqisi2
1831:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2504              		.loc 1 1831 0
 2505 146c 2820D415 		ldrneb	r2, [r4, #40]	@ zero_extendqisi2
 2506              	.LVL276:
1832:../uvc.c      **** 				 }
 2507              		.loc 1 1832 0
 2508 1470 2A30D415 		ldrneb	r3, [r4, #42]	@ zero_extendqisi2
1829:../uvc.c      **** 				 }else{
 2509              		.loc 1 1829 0
 2510 1474 28108D05 		streq	r1, [sp, #40]
 2511 1478 0210A011 		movne	r1, r2
 2512 147c 0010A001 		moveq	r1, r0
1832:../uvc.c      **** 				 }
 2513              		.loc 1 1832 0
 2514 1480 28308D15 		strne	r3, [sp, #40]
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2515              		.loc 1 1828 0
 2516 1484 24008D05 		streq	r0, [sp, #36]
 2517              	.LVL277:
1831:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2518              		.loc 1 1831 0
 2519 1488 24208D15 		strne	r2, [sp, #36]
 2520              	.LVL278:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2521              		.loc 1 1835 0
 2522 148c 20009DE5 		ldr	r0, [sp, #32]
 2523 1490 28209DE5 		ldr	r2, [sp, #40]
 2524 1494 01088DE8 		stmia	sp, {r0, fp}
 2525 1498 0C108DE5 		str	r1, [sp, #12]
 2526 149c 10208DE5 		str	r2, [sp, #16]
 2527 14a0 0C30A0E1 		mov	r3, ip
 2528 14a4 08808DE5 		str	r8, [sp, #8]
 2529 14a8 0400A0E3 		mov	r0, #4
 2530 14ac 981E9FE5 		ldr	r1, .L438+8
 2531 14b0 0520A0E1 		mov	r2, r5
 2532 14b4 18C08DE5 		str	ip, [sp, #24]
 2533 14b8 FEFFFFEB 		bl	CyU3PDebugPrint
 2534              	.LVL279:
1837:../uvc.c      **** 					 switch(CtrlID)
 2535              		.loc 1 1837 0
 2536 14bc 0F0055E3 		cmp	r5, #15
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2537              		.loc 1 1835 0
 2538 14c0 24909DE5 		ldr	r9, [sp, #36]
 2539 14c4 28A09DE5 		ldr	r10, [sp, #40]
1837:../uvc.c      **** 					 switch(CtrlID)
 2540              		.loc 1 1837 0
 2541 14c8 18C09DE5 		ldr	ip, [sp, #24]
 2542 14cc C500009A 		bls	.L336
1838:../uvc.c      **** 					 {
 2543              		.loc 1 1838 0
 2544 14d0 104045E2 		sub	r4, r5, #16
 2545 14d4 180054E3 		cmp	r4, #24
 2546 14d8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2547 14dc EC0300EA 		b	.L337
 2548              	.L339:
 2549 14e0 A4220000 		.word	.L338
 2550 14e4 94240000 		.word	.L337
 2551 14e8 94240000 		.word	.L337
 2552 14ec 94240000 		.word	.L337
 2553 14f0 94240000 		.word	.L337
 2554 14f4 94240000 		.word	.L337
 2555 14f8 94240000 		.word	.L337
 2556 14fc 94240000 		.word	.L337
 2557 1500 94240000 		.word	.L337
 2558 1504 FC210000 		.word	.L340
 2559 1508 94240000 		.word	.L337
 2560 150c 70210000 		.word	.L341
 2561 1510 B81F0000 		.word	.L393
 2562 1514 94240000 		.word	.L337
 2563 1518 C41F0000 		.word	.L342
 2564 151c 20240000 		.word	.L343
 2565 1520 94240000 		.word	.L337
 2566 1524 94240000 		.word	.L337
 2567 1528 94240000 		.word	.L337
 2568 152c 94240000 		.word	.L337
 2569 1530 94230000 		.word	.L344
 2570 1534 94240000 		.word	.L337
 2571 1538 14210000 		.word	.L345
 2572 153c 94240000 		.word	.L337
 2573 1540 30200000 		.word	.L346
 2574              	.LVL280:
 2575              	.L278:
1678:../uvc.c      **** 		 		 if(Len == 2){
 2576              		.loc 1 1678 0
 2577 1544 0F0050E3 		cmp	r0, #15
1680:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2578              		.loc 1 1680 0
 2579 1548 005187E0 		add	r5, r7, r0, asl #2
1678:../uvc.c      **** 		 		 if(Len == 2){
 2580              		.loc 1 1678 0
 2581 154c 8800009A 		bls	.L314
1679:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2582              		.loc 1 1679 0
 2583 1550 020058E3 		cmp	r8, #2
 2584 1554 CB00000A 		beq	.L425
1685:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2585              		.loc 1 1685 0
 2586 1558 202015E5 		ldr	r2, [r5, #-32]
 2587 155c 2C4E9FE5 		ldr	r4, .L438+76
 2588 1560 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1686:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2589              		.loc 1 1686 0
 2590 1564 0030A0E3 		mov	r3, #0
1685:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2591              		.loc 1 1685 0
 2592 1568 2810C4E5 		strb	r1, [r4, #40]
1686:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2593              		.loc 1 1686 0
 2594 156c 2930C4E5 		strb	r3, [r4, #41]
1687:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2595              		.loc 1 1687 0
 2596 1570 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1688:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2597              		.loc 1 1688 0
 2598 1574 2B30C4E5 		strb	r3, [r4, #43]
1687:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2599              		.loc 1 1687 0
 2600 1578 2A20C4E5 		strb	r2, [r4, #42]
 2601 157c 910000EA 		b	.L331
 2602              	.L282:
 2603              	.LVL281:
1768:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2604              		.loc 1 1768 0
 2605 1580 0F0050E3 		cmp	r0, #15
1769:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2606              		.loc 1 1769 0
 2607 1584 005187E0 		add	r5, r7, r0, asl #2
 2608 1588 20301585 		ldrhi	r3, [r5, #-32]
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2609              		.loc 1 1775 0
 2610 158c 20319595 		ldrls	r3, [r5, #288]
 2611 1590 F84D9FE5 		ldr	r4, .L438+76
 2612 1594 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2613              		.loc 1 1781 0
 2614 1598 0100A0E3 		mov	r0, #1
 2615              	.LVL282:
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2616              		.loc 1 1776 0
 2617 159c 0030A0E3 		mov	r3, #0
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2618              		.loc 1 1775 0
 2619 15a0 2820C4E5 		strb	r2, [r4, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2620              		.loc 1 1776 0
 2621 15a4 2930C4E5 		strb	r3, [r4, #41]
1777:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2622              		.loc 1 1777 0
 2623 15a8 2A30C4E5 		strb	r3, [r4, #42]
1778:../uvc.c      **** 		 	 }
 2624              		.loc 1 1778 0
 2625 15ac 2B30C4E5 		strb	r3, [r4, #43]
 2626              	.LVL283:
 2627              	.L415:
1813:../uvc.c      **** 		 	 if(Len == 2){
 2628              		.loc 1 1813 0
 2629 15b0 981D9FE5 		ldr	r1, .L438+12
 2630 15b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2631              	.LVL284:
 2632 15b8 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2633 15bc 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2634 15c0 0090A0E3 		mov	r9, #0
 2635 15c4 09A0A0E1 		mov	r10, r9
 2636              	.LVL285:
 2637              	.L284:
2274:../uvc.c      **** }
 2638              		.loc 1 2274 0
 2639 15c8 00A08DE5 		str	r10, [sp]
 2640 15cc A0008DE9 		stmib	sp, {r5, r7}
 2641 15d0 7C1D9FE5 		ldr	r1, .L438+16
 2642 15d4 0620A0E1 		mov	r2, r6
 2643 15d8 0930A0E1 		mov	r3, r9
 2644 15dc 0400A0E3 		mov	r0, #4
 2645 15e0 FEFFFFEB 		bl	CyU3PDebugPrint
 2646              	.LVL286:
2275:../uvc.c      **** /************** CT control requests handler *************************/
 2647              		.loc 1 2275 0
 2648 15e4 3CD08DE2 		add	sp, sp, #60
 2649              		@ sp needed
 2650 15e8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2651              	.LVL287:
 2652              	.L277:
1378:../uvc.c      **** 				 switch(CtrlID)
 2653              		.loc 1 1378 0
 2654 15ec 0F0050E3 		cmp	r0, #15
 2655 15f0 5000009A 		bls	.L285
1379:../uvc.c      **** 				 {
 2656              		.loc 1 1379 0
 2657 15f4 193040E2 		sub	r3, r0, #25
 2658 15f8 0F0053E3 		cmp	r3, #15
 2659 15fc 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2660 1600 900300EA 		b	.L286
 2661              	.L288:
 2662 1604 D01A0000 		.word	.L287
 2663 1608 48240000 		.word	.L286
 2664 160c 48240000 		.word	.L286
 2665 1610 48190000 		.word	.L303
 2666 1614 48240000 		.word	.L286
 2667 1618 48240000 		.word	.L286
 2668 161c 4C1B0000 		.word	.L290
 2669 1620 48240000 		.word	.L286
 2670 1624 48240000 		.word	.L286
 2671 1628 48240000 		.word	.L286
 2672 162c 48240000 		.word	.L286
 2673 1630 481A0000 		.word	.L291
 2674 1634 48240000 		.word	.L286
 2675 1638 101A0000 		.word	.L292
 2676 163c 48240000 		.word	.L286
 2677 1640 901A0000 		.word	.L293
 2678              	.L274:
2271:../uvc.c      **** 			  break;
 2679              		.loc 1 2271 0
 2680 1644 0000A0E3 		mov	r0, #0
 2681              	.LVL288:
 2682 1648 0020A0E1 		mov	r2, r0
 2683 164c 0110A0E3 		mov	r1, #1
2272:../uvc.c      **** 		 }
 2684              		.loc 1 2272 0
 2685 1650 FF70A0E3 		mov	r7, #255
 2686 1654 0090A0E3 		mov	r9, #0
2271:../uvc.c      **** 			  break;
 2687              		.loc 1 2271 0
 2688 1658 FEFFFFEB 		bl	CyU3PUsbStall
 2689              	.LVL289:
2272:../uvc.c      **** 		 }
 2690              		.loc 1 2272 0
 2691 165c 0750A0E1 		mov	r5, r7
 2692 1660 09A0A0E1 		mov	r10, r9
 2693 1664 D7FFFFEA 		b	.L284
 2694              	.LVL290:
 2695              	.L280:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2696              		.loc 1 1371 0
 2697 1668 204D9FE5 		ldr	r4, .L438+76
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2698              		.loc 1 1372 0
 2699 166c 0030A0E3 		mov	r3, #0
 2700 1670 0390A0E1 		mov	r9, r3
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2701              		.loc 1 1373 0
 2702 1674 281084E2 		add	r1, r4, #40
 2703 1678 0200A0E3 		mov	r0, #2
 2704              	.LVL291:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2705              		.loc 1 1371 0
 2706 167c 2880C4E5 		strb	r8, [r4, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2707              		.loc 1 1372 0
 2708 1680 2930C4E5 		strb	r3, [r4, #41]
 2709 1684 09A0A0E1 		mov	r10, r9
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2710              		.loc 1 1373 0
 2711 1688 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2712              	.LVL292:
1375:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2713              		.loc 1 1375 0
 2714 168c FF70A0E3 		mov	r7, #255
 2715 1690 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2716 1694 CBFFFFEA 		b	.L284
 2717              	.LVL293:
 2718              	.L275:
1714:../uvc.c      **** 		 		 if(Len == 2){
 2719              		.loc 1 1714 0
 2720 1698 0F0050E3 		cmp	r0, #15
1716:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2721              		.loc 1 1716 0
 2722 169c 005187E0 		add	r5, r7, r0, asl #2
1714:../uvc.c      **** 		 		 if(Len == 2){
 2723              		.loc 1 1714 0
 2724 16a0 3E00009A 		bls	.L319
1715:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2725              		.loc 1 1715 0
 2726 16a4 020058E3 		cmp	r8, #2
 2727 16a8 6500000A 		beq	.L426
1721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2728              		.loc 1 1721 0
 2729 16ac 202015E5 		ldr	r2, [r5, #-32]
 2730 16b0 D84C9FE5 		ldr	r4, .L438+76
 2731 16b4 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1722:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2732              		.loc 1 1722 0
 2733 16b8 0030A0E3 		mov	r3, #0
1721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2734              		.loc 1 1721 0
 2735 16bc 2810C4E5 		strb	r1, [r4, #40]
1722:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2736              		.loc 1 1722 0
 2737 16c0 2930C4E5 		strb	r3, [r4, #41]
1723:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2738              		.loc 1 1723 0
 2739 16c4 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1724:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2740              		.loc 1 1724 0
 2741 16c8 2B30C4E5 		strb	r3, [r4, #43]
1723:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2742              		.loc 1 1723 0
 2743 16cc 2A20C4E5 		strb	r2, [r4, #42]
 2744 16d0 3C0000EA 		b	.L331
 2745              	.L281:
1750:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2746              		.loc 1 1750 0
 2747 16d4 0F0050E3 		cmp	r0, #15
1751:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2748              		.loc 1 1751 0
 2749 16d8 005187E0 		add	r5, r7, r0, asl #2
 2750 16dc 20201585 		ldrhi	r2, [r5, #-32]
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2751              		.loc 1 1757 0
 2752 16e0 20219595 		ldrls	r2, [r5, #288]
 2753 16e4 A44C9FE5 		ldr	r4, .L438+76
 2754 16e8 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2755              		.loc 1 1759 0
 2756 16ec 0030A0E3 		mov	r3, #0
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2757              		.loc 1 1757 0
 2758 16f0 2810C4E5 		strb	r1, [r4, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2759              		.loc 1 1758 0
 2760 16f4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2761              		.loc 1 1762 0
 2762 16f8 0800A0E1 		mov	r0, r8
 2763              	.LVL294:
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2764              		.loc 1 1759 0
 2765 16fc 2A30C4E5 		strb	r3, [r4, #42]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2766              		.loc 1 1758 0
 2767 1700 2920C4E5 		strb	r2, [r4, #41]
1760:../uvc.c      **** 		 	 }
 2768              		.loc 1 1760 0
 2769 1704 2B30C4E5 		strb	r3, [r4, #43]
 2770 1708 A8FFFFEA 		b	.L415
 2771              	.LVL295:
 2772              	.L328:
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2773              		.loc 1 1801 0
 2774 170c 020058E3 		cmp	r8, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2775              		.loc 1 1802 0
 2776 1710 203195E5 		ldr	r3, [r5, #288]
 2777 1714 744C9FE5 		ldr	r4, .L438+76
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2778              		.loc 1 1801 0
 2779 1718 5500000A 		beq	.L427
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2780              		.loc 1 1806 0
 2781 171c 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2782              		.loc 1 1809 0
 2783 1720 0020A0E3 		mov	r2, #0
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2784              		.loc 1 1806 0
 2785 1724 2810C4E5 		strb	r1, [r4, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2786              		.loc 1 1808 0
 2787 1728 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2788              		.loc 1 1809 0
 2789 172c 2B20C4E5 		strb	r2, [r4, #43]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2790              		.loc 1 1808 0
 2791 1730 2930C4E5 		strb	r3, [r4, #41]
 2792 1734 230000EA 		b	.L331
 2793              	.L285:
1521:../uvc.c      **** 				 {
 2794              		.loc 1 1521 0
 2795 1738 013040E2 		sub	r3, r0, #1
 2796 173c 0A0053E3 		cmp	r3, #10
 2797 1740 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2798 1744 030200EA 		b	.L304
 2799              	.L306:
 2800 1748 D8190000 		.word	.L305
 2801 174c 581F0000 		.word	.L304
 2802 1750 581F0000 		.word	.L304
 2803 1754 9C190000 		.word	.L307
 2804 1758 60190000 		.word	.L308
 2805 175c 581F0000 		.word	.L304
 2806 1760 40190000 		.word	.L309
 2807 1764 581F0000 		.word	.L304
 2808 1768 581F0000 		.word	.L304
 2809 176c 581F0000 		.word	.L304
 2810 1770 B8180000 		.word	.L310
 2811              	.L314:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2812              		.loc 1 1692 0
 2813 1774 020058E3 		cmp	r8, #2
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2814              		.loc 1 1693 0
 2815 1778 203195E5 		ldr	r3, [r5, #288]
 2816 177c 0C4C9FE5 		ldr	r4, .L438+76
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2817              		.loc 1 1692 0
 2818 1780 4700000A 		beq	.L428
1697:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2819              		.loc 1 1697 0
 2820 1784 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1700:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2821              		.loc 1 1700 0
 2822 1788 0020A0E3 		mov	r2, #0
1697:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2823              		.loc 1 1697 0
 2824 178c 2810C4E5 		strb	r1, [r4, #40]
1699:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2825              		.loc 1 1699 0
 2826 1790 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1700:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2827              		.loc 1 1700 0
 2828 1794 2B20C4E5 		strb	r2, [r4, #43]
1699:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2829              		.loc 1 1699 0
 2830 1798 2930C4E5 		strb	r3, [r4, #41]
 2831 179c 090000EA 		b	.L331
 2832              	.L319:
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2833              		.loc 1 1728 0
 2834 17a0 020058E3 		cmp	r8, #2
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2835              		.loc 1 1729 0
 2836 17a4 203195E5 		ldr	r3, [r5, #288]
 2837 17a8 E04B9FE5 		ldr	r4, .L438+76
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2838              		.loc 1 1728 0
 2839 17ac 2B00000A 		beq	.L429
1733:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2840              		.loc 1 1733 0
 2841 17b0 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1736:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2842              		.loc 1 1736 0
 2843 17b4 0020A0E3 		mov	r2, #0
1733:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2844              		.loc 1 1733 0
 2845 17b8 2810C4E5 		strb	r1, [r4, #40]
1735:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2846              		.loc 1 1735 0
 2847 17bc 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1736:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2848              		.loc 1 1736 0
 2849 17c0 2B20C4E5 		strb	r2, [r4, #43]
1735:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2850              		.loc 1 1735 0
 2851 17c4 2930C4E5 		strb	r3, [r4, #41]
 2852              	.L331:
1813:../uvc.c      **** 		 	 if(Len == 2){
 2853              		.loc 1 1813 0
 2854 17c8 0800A0E1 		mov	r0, r8
 2855              	.LVL296:
 2856 17cc 7C1B9FE5 		ldr	r1, .L438+12
 2857 17d0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2858              	.LVL297:
 2859 17d4 0090A0E3 		mov	r9, #0
 2860 17d8 09A0A0E1 		mov	r10, r9
 2861 17dc 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2862 17e0 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2863 17e4 77FFFFEA 		b	.L284
 2864              	.LVL298:
 2865              	.L336:
2072:../uvc.c      **** 					 {
 2866              		.loc 1 2072 0
 2867 17e8 0B0055E3 		cmp	r5, #11
 2868 17ec 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2869 17f0 200300EA 		b	.L361
 2870              	.L363:
 2871 17f4 E41E0000 		.word	.L362
 2872 17f8 841E0000 		.word	.L364
 2873 17fc 78240000 		.word	.L361
 2874 1800 78240000 		.word	.L361
 2875 1804 141E0000 		.word	.L365
 2876 1808 C01C0000 		.word	.L366
 2877 180c 78240000 		.word	.L361
 2878 1810 301C0000 		.word	.L367
 2879 1814 78240000 		.word	.L361
 2880 1818 78240000 		.word	.L361
 2881 181c 78240000 		.word	.L361
 2882 1820 9C1B0000 		.word	.L368
 2883              	.LVL299:
 2884              	.L424:
1789:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2885              		.loc 1 1789 0
 2886 1824 203015E5 		ldr	r3, [r5, #-32]
 2887 1828 604B9FE5 		ldr	r4, .L438+76
 2888 182c 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2889 1830 2820C4E5 		strb	r2, [r4, #40]
1790:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2890              		.loc 1 1790 0
 2891 1834 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2892 1838 2930C4E5 		strb	r3, [r4, #41]
 2893              	.L330:
1813:../uvc.c      **** 		 	 if(Len == 2){
 2894              		.loc 1 1813 0
 2895 183c 0200A0E3 		mov	r0, #2
 2896              	.LVL300:
 2897 1840 5AFFFFEA 		b	.L415
 2898              	.LVL301:
 2899              	.L426:
1716:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2900              		.loc 1 1716 0
 2901 1844 203015E5 		ldr	r3, [r5, #-32]
 2902 1848 404B9FE5 		ldr	r4, .L438+76
 2903 184c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2904 1850 2820C4E5 		strb	r2, [r4, #40]
1717:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2905              		.loc 1 1717 0
 2906 1854 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2907 1858 2930C4E5 		strb	r3, [r4, #41]
 2908 185c F6FFFFEA 		b	.L330
 2909              	.L429:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2910              		.loc 1 1729 0
 2911 1860 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2912 1864 2820C4E5 		strb	r2, [r4, #40]
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2913              		.loc 1 1730 0
 2914 1868 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2915 186c 2930C4E5 		strb	r3, [r4, #41]
 2916 1870 F1FFFFEA 		b	.L330
 2917              	.L427:
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2918              		.loc 1 1802 0
 2919 1874 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2920 1878 2820C4E5 		strb	r2, [r4, #40]
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2921              		.loc 1 1803 0
 2922 187c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2923 1880 2930C4E5 		strb	r3, [r4, #41]
 2924 1884 ECFFFFEA 		b	.L330
 2925              	.L425:
1680:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2926              		.loc 1 1680 0
 2927 1888 203015E5 		ldr	r3, [r5, #-32]
 2928 188c FC4A9FE5 		ldr	r4, .L438+76
 2929 1890 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2930 1894 2820C4E5 		strb	r2, [r4, #40]
1681:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2931              		.loc 1 1681 0
 2932 1898 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2933 189c 2930C4E5 		strb	r3, [r4, #41]
 2934 18a0 E5FFFFEA 		b	.L330
 2935              	.L428:
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2936              		.loc 1 1693 0
 2937 18a4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2938 18a8 2820C4E5 		strb	r2, [r4, #40]
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2939              		.loc 1 1694 0
 2940 18ac 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2941 18b0 2930C4E5 		strb	r3, [r4, #41]
 2942 18b4 E0FFFFEA 		b	.L330
 2943              	.L310:
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2944              		.loc 1 1595 0
 2945 18b8 0C00A0E1 		mov	r0, ip
 2946              	.LVL302:
 2947 18bc 0B10A0E1 		mov	r1, fp
 2948 18c0 FEFFFFEB 		bl	SensorGetControl
 2949              	.LVL303:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2950              		.loc 1 1596 0
 2951 18c4 0B10A0E1 		mov	r1, fp
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2952              		.loc 1 1597 0
 2953 18c8 C04A9FE5 		ldr	r4, .L438+76
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2954              		.loc 1 1595 0
 2955 18cc 0030A0E1 		mov	r3, r0
 2956              	.LVL304:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2957              		.loc 1 1596 0
 2958 18d0 20009DE5 		ldr	r0, [sp, #32]
 2959              	.LVL305:
 2960 18d4 1C308DE5 		str	r3, [sp, #28]
 2961 18d8 FEFFFFEB 		bl	SensorGetControl
 2962              	.LVL306:
 2963 18dc 1C309DE5 		ldr	r3, [sp, #28]
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2964              		.loc 1 1598 0
 2965 18e0 A41A9FE5 		ldr	r1, .L438+72
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2966              		.loc 1 1603 0
 2967 18e4 0020A0E3 		mov	r2, #0
 2968 18e8 0350A0E1 		mov	r5, r3
1607:../uvc.c      **** 					 case ShapCtlID7:
 2969              		.loc 1 1607 0
 2970 18ec 0390A0E1 		mov	r9, r3
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2971              		.loc 1 1597 0
 2972 18f0 2830C4E5 		strb	r3, [r4, #40]
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2973              		.loc 1 1598 0
 2974 18f4 8435C1E5 		strb	r3, [r1, #1412]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2975              		.loc 1 1603 0
 2976 18f8 2920C4E5 		strb	r2, [r4, #41]
1604:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2977              		.loc 1 1604 0
 2978 18fc 2B20C4E5 		strb	r2, [r4, #43]
 2979 1900 0070A0E1 		mov	r7, r0
1607:../uvc.c      **** 					 case ShapCtlID7:
 2980              		.loc 1 1607 0
 2981 1904 00A0A0E1 		mov	r10, r0
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2982              		.loc 1 1599 0
 2983 1908 2A00C4E5 		strb	r0, [r4, #42]
1600:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 2984              		.loc 1 1600 0
 2985 190c 8605C1E5 		strb	r0, [r1, #1414]
 2986              	.LVL307:
 2987              	.L294:
1671:../uvc.c      **** 
 2988              		.loc 1 1671 0
 2989 1910 0800A0E1 		mov	r0, r8
 2990 1914 341A9FE5 		ldr	r1, .L438+12
 2991 1918 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2992              	.LVL308:
1674:../uvc.c      **** //#endif
 2993              		.loc 1 1674 0
 2994 191c 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2995 1920 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 2996 1924 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 2997 1928 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 2998 192c 03018DE8 		stmia	sp, {r0, r1, r8}
 2999 1930 201A9FE5 		ldr	r1, .L438+20
 3000 1934 0400A0E3 		mov	r0, #4
 3001 1938 FEFFFFEB 		bl	CyU3PDebugPrint
 3002              	.LVL309:
1676:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 3003              		.loc 1 1676 0
 3004 193c 21FFFFEA 		b	.L284
 3005              	.LVL310:
 3006              	.L309:
1614:../uvc.c      **** 			 	 			 {
 3007              		.loc 1 1614 0
 3008 1940 020058E3 		cmp	r8, #2
 3009 1944 F603000A 		beq	.L430
 3010              	.L303:
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3011              		.loc 1 1397 0
 3012 1948 FF70A0E3 		mov	r7, #255
 3013 194c 0090A0E3 		mov	r9, #0
 3014 1950 0750A0E1 		mov	r5, r7
 3015 1954 09A0A0E1 		mov	r10, r9
 3016 1958 304A9FE5 		ldr	r4, .L438+76
 3017 195c EBFFFFEA 		b	.L294
 3018              	.L308:
1559:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3019              		.loc 1 1559 0
 3020 1960 0C00A0E1 		mov	r0, ip
 3021              	.LVL311:
 3022 1964 0B10A0E1 		mov	r1, fp
 3023 1968 FEFFFFEB 		bl	SensorGetControl
 3024              	.LVL312:
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3025              		.loc 1 1564 0
 3026 196c 1C4A9FE5 		ldr	r4, .L438+76
1560:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3027              		.loc 1 1560 0
 3028 1970 142A9FE5 		ldr	r2, .L438+72
1565:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3029              		.loc 1 1565 0
 3030 1974 0030A0E3 		mov	r3, #0
 3031 1978 2930C4E5 		strb	r3, [r4, #41]
 3032 197c 03A0A0E1 		mov	r10, r3
1567:../uvc.c      **** 					 case MFreqCtlID4:
 3033              		.loc 1 1567 0
 3034 1980 FF70A0E3 		mov	r7, #255
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3035              		.loc 1 1564 0
 3036 1984 805040E2 		sub	r5, r0, #128
 3037 1988 FF5005E2 		and	r5, r5, #255
1560:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3038              		.loc 1 1560 0
 3039 198c 6905C2E5 		strb	r0, [r2, #1385]
 3040 1990 0090A0E1 		mov	r9, r0
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3041              		.loc 1 1564 0
 3042 1994 2850C4E5 		strb	r5, [r4, #40]
 3043              	.LVL313:
1567:../uvc.c      **** 					 case MFreqCtlID4:
 3044              		.loc 1 1567 0
 3045 1998 DCFFFFEA 		b	.L294
 3046              	.LVL314:
 3047              	.L307:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 3048              		.loc 1 1579 0
 3049 199c 0B10A0E1 		mov	r1, fp
 3050 19a0 0100A0E3 		mov	r0, #1
 3051              	.LVL315:
 3052 19a4 FEFFFFEB 		bl	SensorGetControl
 3053              	.LVL316:
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3054              		.loc 1 1582 0
 3055 19a8 DC399FE5 		ldr	r3, .L438+72
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 3056              		.loc 1 1580 0
 3057 19ac DC499FE5 		ldr	r4, .L438+76
 3058 19b0 00A0A0E3 		mov	r10, #0
 3059 19b4 A053A0E1 		mov	r5, r0, lsr #7
 3060 19b8 FF5005E2 		and	r5, r5, #255
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3061              		.loc 1 1582 0
 3062 19bc 7D55C3E5 		strb	r5, [r3, #1405]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3063              		.loc 1 1583 0
 3064 19c0 7E75D3E5 		ldrb	r7, [r3, #1406]	@ zero_extendqisi2
 3065 19c4 0090A0E1 		mov	r9, r0
 3066 19c8 FF7007E2 		and	r7, r7, #255
 3067 19cc 2970C4E5 		strb	r7, [r4, #41]
 3068              	.LVL317:
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 3069              		.loc 1 1580 0
 3070 19d0 2850C4E5 		strb	r5, [r4, #40]
1589:../uvc.c      **** 					 case WBTLevCtlID11:
 3071              		.loc 1 1589 0
 3072 19d4 CDFFFFEA 		b	.L294
 3073              	.LVL318:
 3074              	.L305:
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3075              		.loc 1 1539 0
 3076 19d8 0C00A0E1 		mov	r0, ip
 3077              	.LVL319:
 3078 19dc 0B10A0E1 		mov	r1, fp
 3079 19e0 FEFFFFEB 		bl	SensorGetControl
 3080              	.LVL320:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3081              		.loc 1 1551 0
 3082 19e4 A4499FE5 		ldr	r4, .L438+76
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3083              		.loc 1 1540 0
 3084 19e8 9C299FE5 		ldr	r2, .L438+72
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3085              		.loc 1 1552 0
 3086 19ec 0030A0E3 		mov	r3, #0
 3087 19f0 2930C4E5 		strb	r3, [r4, #41]
 3088 19f4 03A0A0E1 		mov	r10, r3
1554:../uvc.c      **** 					 case HueCtlID5:
 3089              		.loc 1 1554 0
 3090 19f8 FF70A0E3 		mov	r7, #255
 3091 19fc 0050A0E1 		mov	r5, r0
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3092              		.loc 1 1540 0
 3093 1a00 5505C2E5 		strb	r0, [r2, #1365]
 3094              	.LVL321:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3095              		.loc 1 1551 0
 3096 1a04 2800C4E5 		strb	r0, [r4, #40]
1554:../uvc.c      **** 					 case HueCtlID5:
 3097              		.loc 1 1554 0
 3098 1a08 0090A0E1 		mov	r9, r0
 3099 1a0c BFFFFFEA 		b	.L294
 3100              	.LVL322:
 3101              	.L292:
1386:../uvc.c      **** 							if(Data0&0x80)
 3102              		.loc 1 1386 0
 3103 1a10 0C00A0E1 		mov	r0, ip
 3104              	.LVL323:
 3105 1a14 0B10A0E1 		mov	r1, fp
 3106 1a18 FEFFFFEB 		bl	SensorGetControl
 3107              	.LVL324:
 3108 1a1c 6C499FE5 		ldr	r4, .L438+76
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3109              		.loc 1 1391 0
 3110 1a20 64399FE5 		ldr	r3, .L438+72
1392:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3111              		.loc 1 1392 0
 3112 1a24 0070A0E3 		mov	r7, #0
 3113 1a28 2970C4E5 		strb	r7, [r4, #41]
 3114 1a2c 07A0A0E1 		mov	r10, r7
1387:../uvc.c      **** 								glEp0Buffer[0] = 1;
 3115              		.loc 1 1387 0
 3116 1a30 FF5000E2 		and	r5, r0, #255
 3117 1a34 A553A0E1 		mov	r5, r5, lsr #7
 3118              	.LVL325:
 3119 1a38 0090A0E1 		mov	r9, r0
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3120              		.loc 1 1391 0
 3121 1a3c 0555C3E5 		strb	r5, [r3, #1285]
 3122 1a40 2850C4E5 		strb	r5, [r4, #40]
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3123              		.loc 1 1397 0
 3124 1a44 B1FFFFEA 		b	.L294
 3125              	.LVL326:
 3126              	.L291:
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3127              		.loc 1 1460 0
 3128 1a48 0C00A0E1 		mov	r0, ip
 3129              	.LVL327:
 3130 1a4c 0B10A0E1 		mov	r1, fp
 3131 1a50 FEFFFFEB 		bl	SensorGetControl
 3132              	.LVL328:
 3133 1a54 34499FE5 		ldr	r4, .L438+76
1461:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3134              		.loc 1 1461 0
 3135 1a58 2C599FE5 		ldr	r5, .L438+72
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3136              		.loc 1 1462 0
 3137 1a5c 0B10A0E1 		mov	r1, fp
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3138              		.loc 1 1460 0
 3139 1a60 0030A0E1 		mov	r3, r0
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3140              		.loc 1 1462 0
 3141 1a64 20009DE5 		ldr	r0, [sp, #32]
1461:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3142              		.loc 1 1461 0
 3143 1a68 4135C5E5 		strb	r3, [r5, #1345]
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3144              		.loc 1 1460 0
 3145 1a6c 2830C4E5 		strb	r3, [r4, #40]
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3146              		.loc 1 1462 0
 3147 1a70 FEFFFFEB 		bl	SensorGetControl
 3148              	.LVL329:
1463:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3149              		.loc 1 1463 0
 3150 1a74 4205C5E5 		strb	r0, [r5, #1346]
 3151              	.LVL330:
 3152 1a78 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 3153 1a7c 0070A0E1 		mov	r7, r0
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3154              		.loc 1 1462 0
 3155 1a80 2900C4E5 		strb	r0, [r4, #41]
 3156              	.LVL331:
 3157              	.L410:
 3158 1a84 0090A0E3 		mov	r9, #0
 3159 1a88 09A0A0E1 		mov	r10, r9
1466:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 3160              		.loc 1 1466 0
 3161 1a8c 9FFFFFEA 		b	.L294
 3162              	.LVL332:
 3163              	.L293:
1450:../uvc.c      **** 			 	 		// sendData &= 0x70;
 3164              		.loc 1 1450 0
 3165 1a90 20009DE5 		ldr	r0, [sp, #32]
 3166              	.LVL333:
 3167 1a94 0B10A0E1 		mov	r1, fp
 3168 1a98 FEFFFFEB 		bl	SensorGetControl
 3169              	.LVL334:
1452:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
 3170              		.loc 1 1452 0
 3171 1a9c EC489FE5 		ldr	r4, .L438+76
 3172 1aa0 E4389FE5 		ldr	r3, .L438+72
 3173 1aa4 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3174              		.loc 1 1454 0
 3175 1aa8 0070A0E3 		mov	r7, #0
1452:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
 3176              		.loc 1 1452 0
 3177 1aac 2D25C3E5 		strb	r2, [r3, #1325]
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3178              		.loc 1 1454 0
 3179 1ab0 2970C4E5 		strb	r7, [r4, #41]
1455:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3180              		.loc 1 1455 0
 3181 1ab4 2E75C3E5 		strb	r7, [r3, #1326]
 3182 1ab8 0790A0E1 		mov	r9, r7
 3183 1abc 07A0A0E1 		mov	r10, r7
1453:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3184              		.loc 1 1453 0
 3185 1ac0 2002A0E1 		mov	r0, r0, lsr #4
 3186              	.LVL335:
 3187 1ac4 FF5000E2 		and	r5, r0, #255
 3188              	.LVL336:
 3189 1ac8 2850C4E5 		strb	r5, [r4, #40]
1458:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3190              		.loc 1 1458 0
 3191 1acc 8FFFFFEA 		b	.L294
 3192              	.LVL337:
 3193              	.L287:
1403:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
 3194              		.loc 1 1403 0
 3195 1ad0 0C00A0E1 		mov	r0, ip
 3196              	.LVL338:
 3197 1ad4 0B10A0E1 		mov	r1, fp
 3198 1ad8 FEFFFFEB 		bl	SensorGetControl
 3199              	.LVL339:
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3200              		.loc 1 1405 0
 3201 1adc AC489FE5 		ldr	r4, .L438+76
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3202              		.loc 1 1404 0
 3203 1ae0 A4789FE5 		ldr	r7, .L438+72
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3204              		.loc 1 1406 0
 3205 1ae4 0B10A0E1 		mov	r1, fp
1403:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
 3206              		.loc 1 1403 0
 3207 1ae8 0030A0E1 		mov	r3, r0
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3208              		.loc 1 1405 0
 3209 1aec 032003E2 		and	r2, r3, #3
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3210              		.loc 1 1406 0
 3211 1af0 20009DE5 		ldr	r0, [sp, #32]
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3212              		.loc 1 1404 0
 3213 1af4 1935C7E5 		strb	r3, [r7, #1305]
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3214              		.loc 1 1405 0
 3215 1af8 2820C4E5 		strb	r2, [r4, #40]
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3216              		.loc 1 1406 0
 3217 1afc FEFFFFEB 		bl	SensorGetControl
 3218              	.LVL340:
1414:../uvc.c      **** 						 break;
 3219              		.loc 1 1414 0
 3220 1b00 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
1410:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3221              		.loc 1 1410 0
 3222 1b04 00E0A0E3 		mov	lr, #0
1414:../uvc.c      **** 						 break;
 3223              		.loc 1 1414 0
 3224 1b08 1910A0E3 		mov	r1, #25
 3225 1b0c 0E90A0E1 		mov	r9, lr
 3226 1b10 0520A0E1 		mov	r2, r5
 3227 1b14 09A0A0E1 		mov	r10, r9
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3228              		.loc 1 1406 0
 3229 1b18 00C0A0E1 		mov	ip, r0
1407:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
 3230              		.loc 1 1407 0
 3231 1b1c 1A05C7E5 		strb	r0, [r7, #1306]
1414:../uvc.c      **** 						 break;
 3232              		.loc 1 1414 0
 3233 1b20 1935D7E5 		ldrb	r3, [r7, #1305]	@ zero_extendqisi2
 3234 1b24 00008DE5 		str	r0, [sp]
 3235 1b28 04108DE5 		str	r1, [sp, #4]
 3236 1b2c 0070A0E1 		mov	r7, r0
 3237 1b30 24189FE5 		ldr	r1, .L438+24
 3238 1b34 0400A0E3 		mov	r0, #4
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3239              		.loc 1 1406 0
 3240 1b38 2AC0C4E5 		strb	ip, [r4, #42]
1410:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3241              		.loc 1 1410 0
 3242 1b3c 29E0C4E5 		strb	lr, [r4, #41]
1411:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3243              		.loc 1 1411 0
 3244 1b40 2BE0C4E5 		strb	lr, [r4, #43]
 3245              	.LVL341:
1414:../uvc.c      **** 						 break;
 3246              		.loc 1 1414 0
 3247 1b44 FEFFFFEB 		bl	CyU3PDebugPrint
 3248              	.LVL342:
1415:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3249              		.loc 1 1415 0
 3250 1b48 70FFFFEA 		b	.L294
 3251              	.LVL343:
 3252              	.L290:
1434:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3253              		.loc 1 1434 0 discriminator 1
 3254 1b4c 000058E3 		cmp	r8, #0
 3255 1b50 0300000A 		beq	.L298
 3256 1b54 F4079FE5 		ldr	r0, .L438+12
 3257              	.LVL344:
 3258 1b58 0820A0E1 		mov	r2, r8
 3259 1b5c 6C1080E2 		add	r1, r0, #108
 3260 1b60 FEFFFFEB 		bl	memcpy
 3261              	.LVL345:
 3262              	.L298:
1437:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3263              		.loc 1 1437 0
 3264 1b64 24489FE5 		ldr	r4, .L438+76
1444:../uvc.c      **** 				 		 {
 3265              		.loc 1 1444 0
 3266 1b68 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1437:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3267              		.loc 1 1437 0
 3268 1b6c 3150D4E5 		ldrb	r5, [r4, #49]	@ zero_extendqisi2
 3269              	.LVL346:
1444:../uvc.c      **** 				 		 {
 3270              		.loc 1 1444 0
 3271 1b70 FF0053E3 		cmp	r3, #255
1438:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3272              		.loc 1 1438 0
 3273 1b74 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3274              	.LVL347:
1444:../uvc.c      **** 				 		 {
 3275              		.loc 1 1444 0
 3276 1b78 C1FFFF0A 		beq	.L410
1446:../uvc.c      **** 				 		 }
 3277              		.loc 1 1446 0
 3278 1b7c 0400A0E3 		mov	r0, #4
 3279 1b80 D8179FE5 		ldr	r1, .L438+28
 3280 1b84 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3281 1b88 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3282 1b8c FEFFFFEB 		bl	CyU3PDebugPrint
 3283              	.LVL348:
 3284 1b90 0090A0E3 		mov	r9, #0
 3285 1b94 09A0A0E1 		mov	r10, r9
 3286 1b98 5CFFFFEA 		b	.L294
 3287              	.LVL349:
 3288              	.L368:
2178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3289              		.loc 1 2178 0
 3290 1b9c E4479FE5 		ldr	r4, .L438+68
 3291 1ba0 0010E0E3 		mvn	r1, #0
 3292 1ba4 1C0094E5 		ldr	r0, [r4, #28]
 3293 1ba8 18C08DE5 		str	ip, [sp, #24]
 3294 1bac FEFFFFEB 		bl	_txe_mutex_get
 3295              	.LVL350:
2179:../uvc.c      **** 							 dataIdx++;
 3296              		.loc 1 2179 0
 3297 1bb0 24009DE5 		ldr	r0, [sp, #36]
 3298 1bb4 18C09DE5 		ldr	ip, [sp, #24]
 3299 1bb8 0030A0E3 		mov	r3, #0
 3300 1bbc 0C20A0E1 		mov	r2, ip
 3301 1bc0 00008DE5 		str	r0, [sp]
 3302 1bc4 04308DE5 		str	r3, [sp, #4]
 3303 1bc8 0B10A0E3 		mov	r1, #11
 3304 1bcc 0B30A0E1 		mov	r3, fp
 3305 1bd0 0400A0E1 		mov	r0, r4
 3306 1bd4 FEFFFFEB 		bl	cmdSet
 3307              	.LVL351:
2181:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3308              		.loc 1 2181 0
 3309 1bd8 28C09DE5 		ldr	ip, [sp, #40]
 3310 1bdc 0180A0E3 		mov	r8, #1
 3311              	.LVL352:
 3312 1be0 00C08DE5 		str	ip, [sp]
 3313 1be4 20209DE5 		ldr	r2, [sp, #32]
 3314 1be8 0B30A0E1 		mov	r3, fp
 3315 1bec 0B10A0E3 		mov	r1, #11
 3316 1bf0 0400A0E1 		mov	r0, r4
 3317 1bf4 04808DE5 		str	r8, [sp, #4]
 3318 1bf8 FEFFFFEB 		bl	cmdSet
 3319              	.LVL353:
2182:../uvc.c      **** 
 3320              		.loc 1 2182 0
 3321 1bfc 1C0094E5 		ldr	r0, [r4, #28]
 3322 1c00 FEFFFFEB 		bl	_txe_mutex_put
 3323              	.LVL354:
2184:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3324              		.loc 1 2184 0
 3325 1c04 80379FE5 		ldr	r3, .L438+72
 3326 1c08 24C09DE5 		ldr	ip, [sp, #36]
2186:../uvc.c      **** 							 break;
 3327              		.loc 1 2186 0
 3328 1c0c 055187E0 		add	r5, r7, r5, asl #2
 3329 1c10 202195E5 		ldr	r2, [r5, #288]
2184:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3330              		.loc 1 2184 0
 3331 1c14 84C5C3E5 		strb	ip, [r3, #1412]
2185:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3332              		.loc 1 2185 0
 3333 1c18 28C09DE5 		ldr	ip, [sp, #40]
2187:../uvc.c      **** 						 case BLCCtlID0:
 3334              		.loc 1 2187 0
 3335 1c1c FF70A0E3 		mov	r7, #255
2186:../uvc.c      **** 							 break;
 3336              		.loc 1 2186 0
 3337 1c20 1180C2E5 		strb	r8, [r2, #17]
2185:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3338              		.loc 1 2185 0
 3339 1c24 86C5C3E5 		strb	ip, [r3, #1414]
2187:../uvc.c      **** 						 case BLCCtlID0:
 3340              		.loc 1 2187 0
 3341 1c28 0750A0E1 		mov	r5, r7
 3342 1c2c 65FEFFEA 		b	.L284
 3343              	.LVL355:
 3344              	.L367:
2210:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3345              		.loc 1 2210 0
 3346 1c30 24209DE5 		ldr	r2, [sp, #36]
2209:../uvc.c      **** 							 if(Data0 != 0){
 3347              		.loc 1 2209 0
 3348 1c34 055187E0 		add	r5, r7, r5, asl #2
 3349 1c38 205195E5 		ldr	r5, [r5, #288]
2211:../uvc.c      **** 	#ifdef COLOR
 3350              		.loc 1 2211 0
 3351 1c3c 44479FE5 		ldr	r4, .L438+68
2210:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3352              		.loc 1 2210 0
 3353 1c40 000052E3 		cmp	r2, #0
2209:../uvc.c      **** 							 if(Data0 != 0){
 3354              		.loc 1 2209 0
 3355 1c44 0D20C5E5 		strb	r2, [r5, #13]
2211:../uvc.c      **** 	#ifdef COLOR
 3356              		.loc 1 2211 0
 3357 1c48 0010E0E3 		mvn	r1, #0
 3358 1c4c 1C0094E5 		ldr	r0, [r4, #28]
 3359 1c50 18C08DE5 		str	ip, [sp, #24]
2210:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3360              		.loc 1 2210 0
 3361 1c54 A902000A 		beq	.L385
2211:../uvc.c      **** 	#ifdef COLOR
 3362              		.loc 1 2211 0
 3363 1c58 FEFFFFEB 		bl	_txe_mutex_get
 3364              	.LVL356:
2215:../uvc.c      **** 								 dataIdx++;
 3365              		.loc 1 2215 0
 3366 1c5c 18C09DE5 		ldr	ip, [sp, #24]
 3367 1c60 0170A0E3 		mov	r7, #1
 3368 1c64 0030A0E3 		mov	r3, #0
 3369 1c68 0C20A0E1 		mov	r2, ip
 3370 1c6c 04308DE5 		str	r3, [sp, #4]
 3371 1c70 0400A0E1 		mov	r0, r4
 3372 1c74 00708DE5 		str	r7, [sp]
 3373 1c78 0710A0E3 		mov	r1, #7
 3374 1c7c 0B30A0E1 		mov	r3, fp
 3375 1c80 FEFFFFEB 		bl	cmdSet
 3376              	.LVL357:
2217:../uvc.c      **** 	#endif
 3377              		.loc 1 2217 0
 3378 1c84 24C09DE5 		ldr	ip, [sp, #36]
 3379 1c88 20209DE5 		ldr	r2, [sp, #32]
 3380 1c8c 04708DE5 		str	r7, [sp, #4]
 3381 1c90 00C08DE5 		str	ip, [sp]
 3382              	.LVL358:
 3383              	.L413:
2222:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3384              		.loc 1 2222 0
 3385 1c94 0B30A0E1 		mov	r3, fp
 3386 1c98 0400A0E1 		mov	r0, r4
 3387 1c9c 0710A0E3 		mov	r1, #7
 3388 1ca0 FEFFFFEB 		bl	cmdSet
 3389              	.LVL359:
2223:../uvc.c      **** 							 }
 3390              		.loc 1 2223 0
 3391 1ca4 1C0094E5 		ldr	r0, [r4, #28]
 3392 1ca8 FEFFFFEB 		bl	_txe_mutex_put
 3393              	.LVL360:
 3394              	.L416:
2225:../uvc.c      **** 							 break;
 3395              		.loc 1 2225 0
 3396 1cac 0130A0E3 		mov	r3, #1
2226:../uvc.c      **** 						 case ConsCtlID2:
 3397              		.loc 1 2226 0
 3398 1cb0 FF70A0E3 		mov	r7, #255
2225:../uvc.c      **** 							 break;
 3399              		.loc 1 2225 0
 3400 1cb4 1130C5E5 		strb	r3, [r5, #17]
 3401              	.LVL361:
2226:../uvc.c      **** 						 case ConsCtlID2:
 3402              		.loc 1 2226 0
 3403 1cb8 0750A0E1 		mov	r5, r7
 3404 1cbc 41FEFFEA 		b	.L284
 3405              	.LVL362:
 3406              	.L366:
2113:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3407              		.loc 1 2113 0
 3408 1cc0 C0869FE5 		ldr	r8, .L438+68
 3409              	.LVL363:
 3410 1cc4 0010E0E3 		mvn	r1, #0
 3411 1cc8 1C0098E5 		ldr	r0, [r8, #28]
 3412 1ccc 18C08DE5 		str	ip, [sp, #24]
 3413 1cd0 FEFFFFEB 		bl	_txe_mutex_get
 3414              	.LVL364:
2114:../uvc.c      **** 							 dataIdx++;
 3415              		.loc 1 2114 0
 3416 1cd4 24009DE5 		ldr	r0, [sp, #36]
 3417 1cd8 18C09DE5 		ldr	ip, [sp, #24]
 3418 1cdc 801040E2 		sub	r1, r0, #128
 3419 1ce0 FF1001E2 		and	r1, r1, #255
 3420 1ce4 0030A0E3 		mov	r3, #0
 3421 1ce8 0C20A0E1 		mov	r2, ip
 3422 1cec 00108DE5 		str	r1, [sp]
 3423 1cf0 04308DE5 		str	r3, [sp, #4]
 3424 1cf4 0510A0E3 		mov	r1, #5
 3425 1cf8 0B30A0E1 		mov	r3, fp
 3426 1cfc 0800A0E1 		mov	r0, r8
 3427 1d00 FEFFFFEB 		bl	cmdSet
 3428              	.LVL365:
2116:../uvc.c      **** 							 dataIdx++;
 3429              		.loc 1 2116 0
 3430 1d04 24C09DE5 		ldr	ip, [sp, #36]
 3431 1d08 0510A0E3 		mov	r1, #5
 3432 1d0c 76304CE2 		sub	r3, ip, #118
 3433 1d10 FF3003E2 		and	r3, r3, #255
 3434 1d14 01C0A0E3 		mov	ip, #1
 3435 1d18 04C08DE5 		str	ip, [sp, #4]
 3436 1d1c 00308DE5 		str	r3, [sp]
 3437 1d20 DC20A0E3 		mov	r2, #220
 3438 1d24 0B30A0E1 		mov	r3, fp
 3439 1d28 0800A0E1 		mov	r0, r8
 3440 1d2c 18C08DE5 		str	ip, [sp, #24]
 3441 1d30 FEFFFFEB 		bl	cmdSet
 3442              	.LVL366:
2118:../uvc.c      **** 							 dataIdx++;
 3443              		.loc 1 2118 0
 3444 1d34 24009DE5 		ldr	r0, [sp, #36]
 3445 1d38 0230A0E3 		mov	r3, #2
 3446 1d3c 7E2080E2 		add	r2, r0, #126
 3447 1d40 FF2002E2 		and	r2, r2, #255
 3448 1d44 00208DE5 		str	r2, [sp]
 3449 1d48 04308DE5 		str	r3, [sp, #4]
 3450 1d4c 0510A0E3 		mov	r1, #5
 3451 1d50 DE20A0E3 		mov	r2, #222
 3452 1d54 0B30A0E1 		mov	r3, fp
 3453 1d58 0800A0E1 		mov	r0, r8
 3454 1d5c FEFFFFEB 		bl	cmdSet
 3455              	.LVL367:
2120:../uvc.c      **** 							 dataIdx++;
 3456              		.loc 1 2120 0
 3457 1d60 24109DE5 		ldr	r1, [sp, #36]
 3458 1d64 0330A0E3 		mov	r3, #3
 3459 1d68 722081E2 		add	r2, r1, #114
 3460 1d6c FF2002E2 		and	r2, r2, #255
 3461 1d70 00208DE5 		str	r2, [sp]
 3462 1d74 04308DE5 		str	r3, [sp, #4]
 3463 1d78 0510A0E3 		mov	r1, #5
 3464 1d7c E020A0E3 		mov	r2, #224
 3465 1d80 0B30A0E1 		mov	r3, fp
 3466 1d84 0800A0E1 		mov	r0, r8
 3467 1d88 FEFFFFEB 		bl	cmdSet
 3468              	.LVL368:
2122:../uvc.c      **** 							 dataIdx++;
 3469              		.loc 1 2122 0
 3470 1d8c 24309DE5 		ldr	r3, [sp, #36]
 3471 1d90 0510A0E3 		mov	r1, #5
 3472 1d94 6F2043E2 		sub	r2, r3, #111
 3473 1d98 FF2002E2 		and	r2, r2, #255
 3474 1d9c 0430A0E3 		mov	r3, #4
 3475 1da0 00208DE5 		str	r2, [sp]
 3476 1da4 04308DE5 		str	r3, [sp, #4]
 3477 1da8 DD20A0E3 		mov	r2, #221
 3478 1dac 0B30A0E1 		mov	r3, fp
 3479 1db0 0800A0E1 		mov	r0, r8
 3480 1db4 FEFFFFEB 		bl	cmdSet
 3481              	.LVL369:
2124:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3482              		.loc 1 2124 0
 3483 1db8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3484 1dbc 0510A0E3 		mov	r1, #5
 3485 1dc0 7F0080E2 		add	r0, r0, #127
 3486 1dc4 FF0000E2 		and	r0, r0, #255
 3487 1dc8 20209DE5 		ldr	r2, [sp, #32]
 3488 1dcc 0B30A0E1 		mov	r3, fp
 3489 1dd0 00008DE5 		str	r0, [sp]
 3490 1dd4 04108DE5 		str	r1, [sp, #4]
 3491 1dd8 0800A0E1 		mov	r0, r8
 3492 1ddc FEFFFFEB 		bl	cmdSet
 3493              	.LVL370:
2125:../uvc.c      **** 
 3494              		.loc 1 2125 0
 3495 1de0 1C0098E5 		ldr	r0, [r8, #28]
 3496 1de4 FEFFFFEB 		bl	_txe_mutex_put
 3497              	.LVL371:
2127:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3498              		.loc 1 2127 0
 3499 1de8 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3500 1dec 055187E0 		add	r5, r7, r5, asl #2
 3501 1df0 203195E5 		ldr	r3, [r5, #288]
 3502 1df4 802042E2 		sub	r2, r2, #128
 3503 1df8 FF2002E2 		and	r2, r2, #255
 3504 1dfc 0D20C3E5 		strb	r2, [r3, #13]
2128:../uvc.c      **** 							 break;
 3505              		.loc 1 2128 0
 3506 1e00 18C09DE5 		ldr	ip, [sp, #24]
2129:../uvc.c      **** 						 case MFreqCtlID4:
 3507              		.loc 1 2129 0
 3508 1e04 FF70A0E3 		mov	r7, #255
 3509 1e08 0750A0E1 		mov	r5, r7
2128:../uvc.c      **** 							 break;
 3510              		.loc 1 2128 0
 3511 1e0c 11C0C3E5 		strb	ip, [r3, #17]
2129:../uvc.c      **** 						 case MFreqCtlID4:
 3512              		.loc 1 2129 0
 3513 1e10 ECFDFFEA 		b	.L284
 3514              	.LVL372:
 3515              	.L365:
2134:../uvc.c      **** 							 {
 3516              		.loc 1 2134 0
 3517 1e14 24C09DE5 		ldr	ip, [sp, #36]
2131:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3518              		.loc 1 2131 0
 3519 1e18 055187E0 		add	r5, r7, r5, asl #2
 3520 1e1c 205195E5 		ldr	r5, [r5, #288]
2134:../uvc.c      **** 							 {
 3521              		.loc 1 2134 0
 3522 1e20 00005CE3 		cmp	ip, #0
2137:../uvc.c      **** 							 }
 3523              		.loc 1 2137 0
 3524 1e24 0130A003 		moveq	r3, #1
2142:../uvc.c      **** 							 }
 3525              		.loc 1 2142 0
 3526 1e28 0030A013 		movne	r3, #0
 3527 1e2c 0C90A001 		moveq	r9, ip
 3528 1e30 0190A013 		movne	r9, #1
2131:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3529              		.loc 1 2131 0
 3530 1e34 0DC0C5E5 		strb	ip, [r5, #13]
 3531              	.LVL373:
2144:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3532              		.loc 1 2144 0
 3533 1e38 0920A0E1 		mov	r2, r9
2142:../uvc.c      **** 							 }
 3534              		.loc 1 2142 0
 3535 1e3c 6C3084E5 		str	r3, [r4, #108]
 3536              	.LVL374:
2144:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3537              		.loc 1 2144 0
 3538 1e40 0400A0E3 		mov	r0, #4
 3539 1e44 6C3094E5 		ldr	r3, [r4, #108]
 3540 1e48 14159FE5 		ldr	r1, .L438+32
 3541 1e4c FEFFFFEB 		bl	CyU3PDebugPrint
 3542              	.LVL375:
2145:../uvc.c      **** 							 {
 3543              		.loc 1 2145 0
 3544 1e50 883094E5 		ldr	r3, [r4, #136]
2144:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3545              		.loc 1 2144 0
 3546 1e54 34259FE5 		ldr	r2, .L438+76
2145:../uvc.c      **** 							 {
 3547              		.loc 1 2145 0
 3548 1e58 010053E3 		cmp	r3, #1
 3549 1e5c 92FFFF1A 		bne	.L416
2147:../uvc.c      **** 			                         {
 3550              		.loc 1 2147 0
 3551 1e60 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 3552 1e64 013043E2 		sub	r3, r3, #1
 3553 1e68 030053E3 		cmp	r3, #3
 3554 1e6c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3555 1e70 8DFFFFEA 		b	.L416
 3556              	.L373:
 3557 1e74 AC250000 		.word	.L372
 3558 1e78 60250000 		.word	.L374
 3559 1e7c 00250000 		.word	.L375
 3560 1e80 A0240000 		.word	.L376
 3561              	.LVL376:
 3562              	.L364:
2097:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3563              		.loc 1 2097 0
 3564 1e84 FC449FE5 		ldr	r4, .L438+68
 3565 1e88 0010E0E3 		mvn	r1, #0
 3566 1e8c 1C0094E5 		ldr	r0, [r4, #28]
 3567 1e90 FEFFFFEB 		bl	_txe_mutex_get
 3568              	.LVL377:
2106:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3569              		.loc 1 2106 0
 3570 1e94 24C09DE5 		ldr	ip, [sp, #36]
 3571 1e98 0010A0E3 		mov	r1, #0
 3572 1e9c 00C08DE5 		str	ip, [sp]
 3573 1ea0 20209DE5 		ldr	r2, [sp, #32]
 3574 1ea4 0B30A0E1 		mov	r3, fp
 3575 1ea8 04108DE5 		str	r1, [sp, #4]
 3576 1eac 0400A0E1 		mov	r0, r4
 3577 1eb0 0110A0E3 		mov	r1, #1
 3578 1eb4 FEFFFFEB 		bl	cmdSet
 3579              	.LVL378:
2109:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3580              		.loc 1 2109 0
 3581 1eb8 055187E0 		add	r5, r7, r5, asl #2
2107:../uvc.c      **** 
 3582              		.loc 1 2107 0
 3583 1ebc 1C0094E5 		ldr	r0, [r4, #28]
 3584 1ec0 FEFFFFEB 		bl	_txe_mutex_put
 3585              	.LVL379:
2109:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3586              		.loc 1 2109 0
 3587 1ec4 203195E5 		ldr	r3, [r5, #288]
 3588 1ec8 24C09DE5 		ldr	ip, [sp, #36]
2110:../uvc.c      **** 							 break;
 3589              		.loc 1 2110 0
 3590 1ecc 0120A0E3 		mov	r2, #1
2111:../uvc.c      **** 						 case HueCtlID5://not being used
 3591              		.loc 1 2111 0
 3592 1ed0 FF70A0E3 		mov	r7, #255
2109:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3593              		.loc 1 2109 0
 3594 1ed4 0DC0C3E5 		strb	ip, [r3, #13]
2111:../uvc.c      **** 						 case HueCtlID5://not being used
 3595              		.loc 1 2111 0
 3596 1ed8 0750A0E1 		mov	r5, r7
2110:../uvc.c      **** 							 break;
 3597              		.loc 1 2110 0
 3598 1edc 1120C3E5 		strb	r2, [r3, #17]
 3599              	.LVL380:
2111:../uvc.c      **** 						 case HueCtlID5://not being used
 3600              		.loc 1 2111 0
 3601 1ee0 B8FDFFEA 		b	.L284
 3602              	.LVL381:
 3603              	.L362:
2189:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3604              		.loc 1 2189 0
 3605 1ee4 055187E0 		add	r5, r7, r5, asl #2
2199:../uvc.c      **** 					 		 }
 3606              		.loc 1 2199 0
 3607 1ee8 9C349FE5 		ldr	r3, .L438+72
2189:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3608              		.loc 1 2189 0
 3609 1eec 24009DE5 		ldr	r0, [sp, #36]
 3610 1ef0 205195E5 		ldr	r5, [r5, #288]
2199:../uvc.c      **** 					 		 }
 3611              		.loc 1 2199 0
 3612 1ef4 24109DE5 		ldr	r1, [sp, #36]
2189:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3613              		.loc 1 2189 0
 3614 1ef8 0D00C5E5 		strb	r0, [r5, #13]
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3615              		.loc 1 2202 0
 3616 1efc 84449FE5 		ldr	r4, .L438+68
2199:../uvc.c      **** 					 		 }
 3617              		.loc 1 2199 0
 3618 1f00 0595D3E5 		ldrb	r9, [r3, #1285]	@ zero_extendqisi2
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3619              		.loc 1 2202 0
 3620 1f04 1C0094E5 		ldr	r0, [r4, #28]
2199:../uvc.c      **** 					 		 }
 3621              		.loc 1 2199 0
 3622 1f08 899381E1 		orr	r9, r1, r9, asl #7
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3623              		.loc 1 2202 0
 3624 1f0c 0010E0E3 		mvn	r1, #0
 3625 1f10 18C08DE5 		str	ip, [sp, #24]
 3626 1f14 FEFFFFEB 		bl	_txe_mutex_get
 3627              	.LVL382:
2203:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3628              		.loc 1 2203 0
 3629 1f18 18C09DE5 		ldr	ip, [sp, #24]
2199:../uvc.c      **** 					 		 }
 3630              		.loc 1 2199 0
 3631 1f1c FF9009E2 		and	r9, r9, #255
 3632              	.LVL383:
2203:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3633              		.loc 1 2203 0
 3634 1f20 0010A0E3 		mov	r1, #0
 3635 1f24 0C20A0E1 		mov	r2, ip
 3636 1f28 0B30A0E1 		mov	r3, fp
 3637 1f2c 0400A0E1 		mov	r0, r4
 3638 1f30 00908DE5 		str	r9, [sp]
 3639 1f34 04108DE5 		str	r1, [sp, #4]
 3640              	.LVL384:
 3641              	.L414:
 3642 1f38 FEFFFFEB 		bl	cmdSet
 3643              	.LVL385:
2204:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3644              		.loc 1 2204 0
 3645 1f3c 1C0094E5 		ldr	r0, [r4, #28]
 3646 1f40 FEFFFFEB 		bl	_txe_mutex_put
 3647              	.LVL386:
2206:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3648              		.loc 1 2206 0
 3649 1f44 FF70A0E3 		mov	r7, #255
2205:../uvc.c      **** 					 		 break;
 3650              		.loc 1 2205 0
 3651 1f48 0130A0E3 		mov	r3, #1
 3652 1f4c 1130C5E5 		strb	r3, [r5, #17]
 3653              	.LVL387:
2206:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3654              		.loc 1 2206 0
 3655 1f50 0750A0E1 		mov	r5, r7
 3656 1f54 9BFDFFEA 		b	.L284
 3657              	.LVL388:
 3658              	.L304:
1631:../uvc.c      **** 			 	 			 if(Len == 2)
 3659              		.loc 1 1631 0
 3660 1f58 007087E0 		add	r7, r7, r0
 3661 1f5c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 3662 1f60 DC439FE5 		ldr	r4, .L438
 3663 1f64 000053E3 		cmp	r3, #0
 3664 1f68 AA01000A 		beq	.L311
1632:../uvc.c      **** 			 	 			 {
 3665              		.loc 1 1632 0
 3666 1f6c 020058E3 		cmp	r8, #2
 3667 1f70 3A02000A 		beq	.L431
1638:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3668              		.loc 1 1638 0
 3669 1f74 040058E3 		cmp	r8, #4
 3670 1f78 72FEFF1A 		bne	.L303
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3671              		.loc 1 1639 0
 3672 1f7c 004184E0 		add	r4, r4, r0, asl #2
 3673 1f80 202194E5 		ldr	r2, [r4, #288]
 3674              	.L409:
 3675 1f84 0D50D2E5 		ldrb	r5, [r2, #13]	@ zero_extendqisi2
 3676 1f88 00449FE5 		ldr	r4, .L438+76
1640:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3677              		.loc 1 1640 0
 3678 1f8c 0030A0E3 		mov	r3, #0
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3679              		.loc 1 1639 0
 3680 1f90 FF5005E2 		and	r5, r5, #255
 3681 1f94 2850C4E5 		strb	r5, [r4, #40]
1640:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3682              		.loc 1 1640 0
 3683 1f98 2930C4E5 		strb	r3, [r4, #41]
1641:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3684              		.loc 1 1641 0
 3685 1f9c 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3686 1fa0 0390A0E1 		mov	r9, r3
 3687 1fa4 FF7007E2 		and	r7, r7, #255
 3688 1fa8 2A70C4E5 		strb	r7, [r4, #42]
1642:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3689              		.loc 1 1642 0
 3690 1fac 2B30C4E5 		strb	r3, [r4, #43]
 3691              	.LVL389:
 3692 1fb0 03A0A0E1 		mov	r10, r3
 3693 1fb4 55FEFFEA 		b	.L294
 3694              	.LVL390:
 3695              	.L393:
1838:../uvc.c      **** 					 {
 3696              		.loc 1 1838 0
 3697 1fb8 FF70A0E3 		mov	r7, #255
 3698 1fbc 0750A0E1 		mov	r5, r7
 3699 1fc0 80FDFFEA 		b	.L284
 3700              	.L342:
1870:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3701              		.loc 1 1870 0
 3702 1fc4 BC539FE5 		ldr	r5, .L438+68
 3703 1fc8 0010E0E3 		mvn	r1, #0
 3704 1fcc 1C0095E5 		ldr	r0, [r5, #28]
 3705 1fd0 18C08DE5 		str	ip, [sp, #24]
 3706 1fd4 FEFFFFEB 		bl	_txe_mutex_get
 3707              	.LVL391:
1871:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3708              		.loc 1 1871 0
 3709 1fd8 18C09DE5 		ldr	ip, [sp, #24]
 3710 1fdc 24009DE5 		ldr	r0, [sp, #36]
 3711 1fe0 0080A0E3 		mov	r8, #0
 3712              	.LVL392:
 3713 1fe4 0C20A0E1 		mov	r2, ip
 3714 1fe8 0B30A0E1 		mov	r3, fp
 3715 1fec 00008DE5 		str	r0, [sp]
 3716 1ff0 1E10A0E3 		mov	r1, #30
 3717 1ff4 0500A0E1 		mov	r0, r5
 3718 1ff8 04808DE5 		str	r8, [sp, #4]
 3719 1ffc FEFFFFEB 		bl	cmdSet
 3720              	.LVL393:
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3721              		.loc 1 1873 0
 3722 2000 044187E0 		add	r4, r7, r4, asl #2
1872:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3723              		.loc 1 1872 0
 3724 2004 1C0095E5 		ldr	r0, [r5, #28]
 3725 2008 FEFFFFEB 		bl	_txe_mutex_put
 3726              	.LVL394:
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3727              		.loc 1 1873 0
 3728 200c 203094E5 		ldr	r3, [r4, #32]
 3729 2010 24C09DE5 		ldr	ip, [sp, #36]
1875:../uvc.c      **** 							 break;
 3730              		.loc 1 1875 0
 3731 2014 0120A0E3 		mov	r2, #1
1876:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3732              		.loc 1 1876 0
 3733 2018 FF70A0E3 		mov	r7, #255
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3734              		.loc 1 1873 0
 3735 201c 0DC0C3E5 		strb	ip, [r3, #13]
1876:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3736              		.loc 1 1876 0
 3737 2020 0750A0E1 		mov	r5, r7
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3738              		.loc 1 1874 0
 3739 2024 0E80C3E5 		strb	r8, [r3, #14]
1875:../uvc.c      **** 							 break;
 3740              		.loc 1 1875 0
 3741 2028 1120C3E5 		strb	r2, [r3, #17]
 3742              	.LVL395:
1876:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3743              		.loc 1 1876 0
 3744 202c 65FDFFEA 		b	.L284
 3745              	.LVL396:
 3746              	.L346:
2016:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
 3747              		.loc 1 2016 0
 3748 2030 044187E0 		add	r4, r7, r4, asl #2
 3749 2034 207094E5 		ldr	r7, [r4, #32]
 3750 2038 24009DE5 		ldr	r0, [sp, #36]
 3751 203c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3752 2040 000053E1 		cmp	r3, r0
 3753 2044 2100000A 		beq	.L355
2017:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
 3754              		.loc 1 2017 0
 3755 2048 0C00A0E1 		mov	r0, ip
 3756 204c 0B10A0E1 		mov	r1, fp
 3757 2050 18C08DE5 		str	ip, [sp, #24]
 3758 2054 FEFFFFEB 		bl	SensorGetControl
 3759              	.LVL397:
2018:../uvc.c      **** 								 Data0 |= Data1;
 3760              		.loc 1 2018 0
 3761 2058 24109DE5 		ldr	r1, [sp, #36]
2021:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3762              		.loc 1 2021 0
 3763 205c 24439FE5 		ldr	r4, .L438+68
2018:../uvc.c      **** 								 Data0 |= Data1;
 3764              		.loc 1 2018 0
 3765 2060 0132A0E1 		mov	r3, r1, asl #4
 3766 2064 FF3003E2 		and	r3, r3, #255
2021:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3767              		.loc 1 2021 0
 3768 2068 0010E0E3 		mvn	r1, #0
2022:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3769              		.loc 1 2022 0
 3770 206c 0090A0E3 		mov	r9, #0
2018:../uvc.c      **** 								 Data0 |= Data1;
 3771              		.loc 1 2018 0
 3772 2070 0F0000E2 		and	r0, r0, #15
 3773              	.LVL398:
2019:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
 3774              		.loc 1 2019 0
 3775 2074 033080E1 		orr	r3, r0, r3
2020:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3776              		.loc 1 2020 0
 3777 2078 0D30C7E5 		strb	r3, [r7, #13]
2018:../uvc.c      **** 								 Data0 |= Data1;
 3778              		.loc 1 2018 0
 3779 207c 28008DE5 		str	r0, [sp, #40]
 3780              	.LVL399:
2021:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3781              		.loc 1 2021 0
 3782 2080 1C0094E5 		ldr	r0, [r4, #28]
2019:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
 3783              		.loc 1 2019 0
 3784 2084 24308DE5 		str	r3, [sp, #36]
 3785              	.LVL400:
2021:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3786              		.loc 1 2021 0
 3787 2088 FEFFFFEB 		bl	_txe_mutex_get
 3788              	.LVL401:
2022:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3789              		.loc 1 2022 0
 3790 208c 18C09DE5 		ldr	ip, [sp, #24]
 3791 2090 24209DE5 		ldr	r2, [sp, #36]
 3792 2094 2810A0E3 		mov	r1, #40
 3793 2098 0B30A0E1 		mov	r3, fp
 3794 209c 00208DE5 		str	r2, [sp]
 3795 20a0 04908DE5 		str	r9, [sp, #4]
 3796 20a4 0C20A0E1 		mov	r2, ip
 3797 20a8 0400A0E1 		mov	r0, r4
 3798 20ac FEFFFFEB 		bl	cmdSet
 3799              	.LVL402:
2023:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3800              		.loc 1 2023 0
 3801 20b0 1C0094E5 		ldr	r0, [r4, #28]
 3802 20b4 FEFFFFEB 		bl	_txe_mutex_put
 3803              	.LVL403:
2024:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3804              		.loc 1 2024 0
 3805 20b8 0E90C7E5 		strb	r9, [r7, #14]
2025:../uvc.c      **** 							 }
 3806              		.loc 1 2025 0
 3807 20bc 1C0094E5 		ldr	r0, [r4, #28]
 3808 20c0 FEFFFFEB 		bl	_txe_mutex_put
 3809              	.LVL404:
 3810 20c4 24909DE5 		ldr	r9, [sp, #36]
 3811 20c8 28A09DE5 		ldr	r10, [sp, #40]
 3812 20cc 18C09DE5 		ldr	ip, [sp, #24]
 3813              	.L355:
2027:../uvc.c      **** 
 3814              		.loc 1 2027 0
 3815 20d0 0130A0E3 		mov	r3, #1
 3816 20d4 1130C7E5 		strb	r3, [r7, #17]
 3817              	.L347:
2040:../uvc.c      **** 				 	 			 {
 3818              		.loc 1 2040 0
 3819 20d8 020058E3 		cmp	r8, #2
 3820 20dc 8E01000A 		beq	.L432
2050:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3821              		.loc 1 2050 0
 3822 20e0 040058E3 		cmp	r8, #4
 3823 20e4 B601000A 		beq	.L433
 3824              	.LVL405:
 3825              	.L389:
2258:../uvc.c      **** 			 	 			 break;
 3826              		.loc 1 2258 0
 3827 20e8 0E00D7E5 		ldrb	r0, [r7, #14]	@ zero_extendqisi2
 3828 20ec 0D10D7E5 		ldrb	r1, [r7, #13]	@ zero_extendqisi2
2257:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3829              		.loc 1 2257 0
 3830 20f0 24209DE5 		ldr	r2, [sp, #36]
 3831 20f4 03018DE8 		stmia	sp, {r0, r1, r8}
 3832 20f8 28309DE5 		ldr	r3, [sp, #40]
 3833 20fc 0400A0E3 		mov	r0, #4
 3834 2100 60129FE5 		ldr	r1, .L438+36
 3835 2104 FEFFFFEB 		bl	CyU3PDebugPrint
 3836              	.LVL406:
2259:../uvc.c      **** 					 }
 3837              		.loc 1 2259 0
 3838 2108 FF70A0E3 		mov	r7, #255
 3839 210c 0750A0E1 		mov	r5, r7
 3840 2110 2CFDFFEA 		b	.L284
 3841              	.LVL407:
 3842              	.L345:
1841:../uvc.c      **** 							 if(Data0 == 1){
 3843              		.loc 1 1841 0
 3844 2114 044187E0 		add	r4, r7, r4, asl #2
1842:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3845              		.loc 1 1842 0
 3846 2118 24309DE5 		ldr	r3, [sp, #36]
1841:../uvc.c      **** 							 if(Data0 == 1){
 3847              		.loc 1 1841 0
 3848 211c 205094E5 		ldr	r5, [r4, #32]
1842:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3849              		.loc 1 1842 0
 3850 2120 010053E3 		cmp	r3, #1
1841:../uvc.c      **** 							 if(Data0 == 1){
 3851              		.loc 1 1841 0
 3852 2124 0D30C5E5 		strb	r3, [r5, #13]
1843:../uvc.c      **** 							 }else{
 3853              		.loc 1 1843 0
 3854 2128 5C329FE5 		ldr	r3, .L438+72
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3855              		.loc 1 1847 0
 3856 212c 54429FE5 		ldr	r4, .L438+68
1843:../uvc.c      **** 							 }else{
 3857              		.loc 1 1843 0
 3858 2130 A995D3E5 		ldrb	r9, [r3, #1449]	@ zero_extendqisi2
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3859              		.loc 1 1847 0
 3860 2134 0010E0E3 		mvn	r1, #0
 3861 2138 1C0094E5 		ldr	r0, [r4, #28]
1843:../uvc.c      **** 							 }else{
 3862              		.loc 1 1843 0
 3863 213c 80908903 		orreq	r9, r9, #128
 3864              	.LVL408:
1845:../uvc.c      **** 							 }
 3865              		.loc 1 1845 0
 3866 2140 7F900912 		andne	r9, r9, #127
 3867              	.LVL409:
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3868              		.loc 1 1847 0
 3869 2144 18C08DE5 		str	ip, [sp, #24]
 3870 2148 FEFFFFEB 		bl	_txe_mutex_get
 3871              	.LVL410:
1848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3872              		.loc 1 1848 0
 3873 214c 18C09DE5 		ldr	ip, [sp, #24]
 3874 2150 0010A0E3 		mov	r1, #0
 3875 2154 04108DE5 		str	r1, [sp, #4]
 3876 2158 00908DE5 		str	r9, [sp]
 3877 215c 0C20A0E1 		mov	r2, ip
 3878 2160 0B30A0E1 		mov	r3, fp
 3879 2164 0400A0E1 		mov	r0, r4
 3880 2168 2610A0E3 		mov	r1, #38
 3881 216c 71FFFFEA 		b	.L414
 3882              	.LVL411:
 3883              	.L341:
1925:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3884              		.loc 1 1925 0
 3885 2170 10C29FE5 		ldr	ip, .L438+68
 3886 2174 0010E0E3 		mvn	r1, #0
 3887 2178 1C009CE5 		ldr	r0, [ip, #28]
1926:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3888              		.loc 1 1926 0
 3889 217c 044187E0 		add	r4, r7, r4, asl #2
1925:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3890              		.loc 1 1925 0
 3891 2180 2CC08DE5 		str	ip, [sp, #44]
 3892 2184 FEFFFFEB 		bl	_txe_mutex_get
 3893              	.LVL412:
1926:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3894              		.loc 1 1926 0
 3895 2188 203094E5 		ldr	r3, [r4, #32]
 3896 218c 24C09DE5 		ldr	ip, [sp, #36]
 3897 2190 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 3898 2194 0C0052E1 		cmp	r2, ip
 3899 2198 0800000A 		beq	.L354
1931:../uvc.c      **** 								 }
 3900              		.loc 1 1931 0
 3901 219c 0010A0E3 		mov	r1, #0
1927:../uvc.c      **** 								 if(1 || EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3902              		.loc 1 1927 0
 3903 21a0 0DC0C3E5 		strb	ip, [r3, #13]
1931:../uvc.c      **** 								 }
 3904              		.loc 1 1931 0
 3905 21a4 20209DE5 		ldr	r2, [sp, #32]
 3906 21a8 04108DE5 		str	r1, [sp, #4]
 3907 21ac 00C08DE5 		str	ip, [sp]
 3908 21b0 0B30A0E1 		mov	r3, fp
 3909 21b4 2C009DE5 		ldr	r0, [sp, #44]
 3910 21b8 1B10A0E3 		mov	r1, #27
 3911 21bc FEFFFFEB 		bl	cmdSet
 3912              	.LVL413:
 3913              	.L354:
1935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3914              		.loc 1 1935 0
 3915 21c0 2CC09DE5 		ldr	ip, [sp, #44]
1936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3916              		.loc 1 1936 0
 3917 21c4 FF70A0E3 		mov	r7, #255
1935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3918              		.loc 1 1935 0
 3919 21c8 1C009CE5 		ldr	r0, [ip, #28]
 3920 21cc FEFFFFEB 		bl	_txe_mutex_put
 3921              	.LVL414:
1937:../uvc.c      **** 							 break;
 3922              		.loc 1 1937 0
 3923 21d0 B4119FE5 		ldr	r1, .L438+72
1936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3924              		.loc 1 1936 0
 3925 21d4 0400A0E3 		mov	r0, #4
1937:../uvc.c      **** 							 break;
 3926              		.loc 1 1937 0
 3927 21d8 1925D1E5 		ldrb	r2, [r1, #1305]	@ zero_extendqisi2
 3928 21dc 1A35D1E5 		ldrb	r3, [r1, #1306]	@ zero_extendqisi2
 3929 21e0 D115D1E5 		ldrb	r1, [r1, #1489]	@ zero_extendqisi2
1936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3930              		.loc 1 1936 0
 3931 21e4 08708DE5 		str	r7, [sp, #8]
 3932 21e8 82008DE8 		stmia	sp, {r1, r7}
 3933 21ec 78119FE5 		ldr	r1, .L438+40
 3934 21f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3935              	.LVL415:
1938:../uvc.c      **** 
 3936              		.loc 1 1938 0
 3937 21f4 0750A0E1 		mov	r5, r7
 3938 21f8 F2FCFFEA 		b	.L284
 3939              	.L340:
1884:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
 3940              		.loc 1 1884 0
 3941 21fc 84019FE5 		ldr	r0, .L438+68
 3942 2200 0010E0E3 		mvn	r1, #0
 3943 2204 2C008DE5 		str	r0, [sp, #44]
1885:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3944              		.loc 1 1885 0
 3945 2208 044187E0 		add	r4, r7, r4, asl #2
1884:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
 3946              		.loc 1 1884 0
 3947 220c 1C0090E5 		ldr	r0, [r0, #28]
 3948 2210 18C08DE5 		str	ip, [sp, #24]
 3949 2214 FEFFFFEB 		bl	_txe_mutex_get
 3950              	.LVL416:
1885:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3951              		.loc 1 1885 0
 3952 2218 204094E5 		ldr	r4, [r4, #32]
 3953 221c 28109DE5 		ldr	r1, [sp, #40]
 3954 2220 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
 3955 2224 18C09DE5 		ldr	ip, [sp, #24]
 3956 2228 010053E1 		cmp	r3, r1
 3957 222c 9701000A 		beq	.L352
 3958 2230 01C0A0E1 		mov	ip, r1
1888:../uvc.c      **** 								 }
 3959              		.loc 1 1888 0
 3960 2234 0010A0E3 		mov	r1, #0
1886:../uvc.c      **** 								 if(1 || Data0 == 2 || Data0 == 3){
 3961              		.loc 1 1886 0
 3962 2238 0EC0C4E5 		strb	ip, [r4, #14]
1888:../uvc.c      **** 								 }
 3963              		.loc 1 1888 0
 3964 223c 20209DE5 		ldr	r2, [sp, #32]
 3965 2240 04108DE5 		str	r1, [sp, #4]
 3966 2244 00C08DE5 		str	ip, [sp]
 3967 2248 0B30A0E1 		mov	r3, fp
 3968 224c 2C009DE5 		ldr	r0, [sp, #44]
 3969 2250 1910A0E3 		mov	r1, #25
 3970 2254 FEFFFFEB 		bl	cmdSet
 3971              	.LVL417:
 3972              	.L353:
1901:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3973              		.loc 1 1901 0
 3974 2258 2CC09DE5 		ldr	ip, [sp, #44]
1900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3975              		.loc 1 1900 0
 3976 225c 0130A0E3 		mov	r3, #1
 3977 2260 1130C4E5 		strb	r3, [r4, #17]
1901:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3978              		.loc 1 1901 0
 3979 2264 1C009CE5 		ldr	r0, [ip, #28]
 3980 2268 FEFFFFEB 		bl	_txe_mutex_put
 3981              	.LVL418:
1904:../uvc.c      **** 							 break;
 3982              		.loc 1 1904 0
 3983 226c 18119FE5 		ldr	r1, .L438+72
1903:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 3984              		.loc 1 1903 0
 3985 2270 0D20D4E5 		ldrb	r2, [r4, #13]	@ zero_extendqisi2
1902:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 3986              		.loc 1 1902 0
 3987 2274 28C09DE5 		ldr	ip, [sp, #40]
1903:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 3988              		.loc 1 1903 0
 3989 2278 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
1904:../uvc.c      **** 							 break;
 3990              		.loc 1 1904 0
 3991 227c BD15D1E5 		ldrb	r1, [r1, #1469]	@ zero_extendqisi2
1902:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 3992              		.loc 1 1902 0
 3993 2280 0400A0E3 		mov	r0, #4
 3994 2284 00108DE5 		str	r1, [sp]
 3995 2288 04908DE5 		str	r9, [sp, #4]
 3996 228c 08C08DE5 		str	ip, [sp, #8]
 3997 2290 D8109FE5 		ldr	r1, .L438+44
 3998 2294 FEFFFFEB 		bl	CyU3PDebugPrint
 3999              	.LVL419:
1905:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 4000              		.loc 1 1905 0
 4001 2298 FF70A0E3 		mov	r7, #255
 4002 229c 0750A0E1 		mov	r5, r7
 4003 22a0 C8FCFFEA 		b	.L284
 4004              	.LVL420:
 4005              	.L338:
1910:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
 4006              		.loc 1 1910 0
 4007 22a4 0C00A0E1 		mov	r0, ip
 4008 22a8 0B10A0E1 		mov	r1, fp
 4009 22ac 18C08DE5 		str	ip, [sp, #24]
 4010 22b0 FEFFFFEB 		bl	SensorGetControl
 4011              	.LVL421:
1914:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4012              		.loc 1 1914 0
 4013 22b4 CC509FE5 		ldr	r5, .L438+68
1912:../uvc.c      **** 						    	 dataIdx = 0;
 4014              		.loc 1 1912 0
 4015 22b8 044187E0 		add	r4, r7, r4, asl #2
 4016 22bc 204094E5 		ldr	r4, [r4, #32]
1914:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4017              		.loc 1 1914 0
 4018 22c0 0010E0E3 		mvn	r1, #0
1912:../uvc.c      **** 						    	 dataIdx = 0;
 4019              		.loc 1 1912 0
 4020 22c4 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
1923:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
 4021              		.loc 1 1923 0
 4022 22c8 FF70A0E3 		mov	r7, #255
1910:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
 4023              		.loc 1 1910 0
 4024 22cc 00A0A0E1 		mov	r10, r0
 4025              	.LVL422:
1911:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4026              		.loc 1 1911 0
 4027 22d0 7090C0E3 		bic	r9, r0, #112
 4028 22d4 24009DE5 		ldr	r0, [sp, #36]
 4029              	.LVL423:
 4030 22d8 009289E1 		orr	r9, r9, r0, asl #4
1914:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4031              		.loc 1 1914 0
 4032 22dc 1C0095E5 		ldr	r0, [r5, #28]
 4033 22e0 FEFFFFEB 		bl	_txe_mutex_get
 4034              	.LVL424:
1917:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4035              		.loc 1 1917 0
 4036 22e4 18C09DE5 		ldr	ip, [sp, #24]
1911:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4037              		.loc 1 1911 0
 4038 22e8 FF9009E2 		and	r9, r9, #255
 4039              	.LVL425:
1917:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4040              		.loc 1 1917 0
 4041 22ec 0010A0E3 		mov	r1, #0
 4042 22f0 0C20A0E1 		mov	r2, ip
 4043 22f4 0B30A0E1 		mov	r3, fp
 4044 22f8 0500A0E1 		mov	r0, r5
 4045 22fc 04108DE5 		str	r1, [sp, #4]
 4046 2300 00908DE5 		str	r9, [sp]
 4047 2304 1010A0E3 		mov	r1, #16
 4048 2308 FEFFFFEB 		bl	cmdSet
 4049              	.LVL426:
1918:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting 
 4050              		.loc 1 1918 0
 4051 230c 1C0095E5 		ldr	r0, [r5, #28]
 4052 2310 FEFFFFEB 		bl	_txe_mutex_put
 4053              	.LVL427:
1922:../uvc.c      **** 						     break;
 4054              		.loc 1 1922 0
 4055 2314 70309FE5 		ldr	r3, .L438+72
1919:../uvc.c      **** 						     }
 4056              		.loc 1 1919 0
 4057 2318 0D90C4E5 		strb	r9, [r4, #13]
1922:../uvc.c      **** 						     break;
 4058              		.loc 1 1922 0
 4059 231c 1925D3E5 		ldrb	r2, [r3, #1305]	@ zero_extendqisi2
 4060 2320 BD35D3E5 		ldrb	r3, [r3, #1469]	@ zero_extendqisi2
1921:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4061              		.loc 1 1921 0
 4062 2324 0400A0E3 		mov	r0, #4
 4063 2328 0C008DE8 		stmia	sp, {r2, r3}
 4064 232c 40109FE5 		ldr	r1, .L438+48
 4065 2330 0930A0E1 		mov	r3, r9
 4066 2334 0A20A0E1 		mov	r2, r10
 4067 2338 FEFFFFEB 		bl	CyU3PDebugPrint
 4068              	.LVL428:
1923:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
 4069              		.loc 1 1923 0
 4070 233c 0750A0E1 		mov	r5, r7
 4071 2340 A0FCFFEA 		b	.L284
 4072              	.L439:
 4073              		.align	2
 4074              	.L438:
 4075 2344 00000000 		.word	.LANCHOR2
 4076 2348 00000000 		.word	bRequest
 4077 234c 68040000 		.word	.LC27
 4078 2350 28000000 		.word	.LANCHOR0+40
 4079 2354 2C060000 		.word	.LC35
 4080 2358 38040000 		.word	.LC26
 4081 235c D4030000 		.word	.LC24
 4082 2360 FC030000 		.word	.LC25
 4083 2364 B8050000 		.word	.LC32
 4084 2368 64050000 		.word	.LC31
 4085 236c 2C050000 		.word	.LC30
 4086 2370 CC040000 		.word	.LC28
 4087 2374 00050000 		.word	.LC29
 4088 2378 94000000 		.word	.LANCHOR0+148
 4089 237c 00000000 		.word	.LANCHOR2
 4090 2380 D8050000 		.word	.LC33
 4091 2384 FC050000 		.word	.LC34
 4092 2388 00000000 		.word	cmdQu
 4093 238c 00000000 		.word	.LANCHOR1
 4094 2390 00000000 		.word	.LANCHOR0
 4095              	.LVL429:
 4096              	.L344:
2004:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 4097              		.loc 1 2004 0
 4098 2394 14401FE5 		ldr	r4, .L438+68
 4099 2398 0010E0E3 		mvn	r1, #0
 4100 239c 1C0094E5 		ldr	r0, [r4, #28]
 4101 23a0 18C08DE5 		str	ip, [sp, #24]
 4102 23a4 FEFFFFEB 		bl	_txe_mutex_get
 4103              	.LVL430:
2005:../uvc.c      **** 							 dataIdx++;
 4104              		.loc 1 2005 0
 4105 23a8 24009DE5 		ldr	r0, [sp, #36]
 4106 23ac 18C09DE5 		ldr	ip, [sp, #24]
 4107 23b0 0030A0E3 		mov	r3, #0
 4108 23b4 0C20A0E1 		mov	r2, ip
 4109 23b8 00008DE5 		str	r0, [sp]
 4110 23bc 04308DE5 		str	r3, [sp, #4]
 4111 23c0 2410A0E3 		mov	r1, #36
 4112 23c4 0B30A0E1 		mov	r3, fp
 4113 23c8 0400A0E1 		mov	r0, r4
 4114 23cc FEFFFFEB 		bl	cmdSet
 4115              	.LVL431:
2007:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4116              		.loc 1 2007 0
 4117 23d0 28C09DE5 		ldr	ip, [sp, #40]
 4118 23d4 0180A0E3 		mov	r8, #1
 4119              	.LVL432:
 4120 23d8 00C08DE5 		str	ip, [sp]
 4121 23dc 0B30A0E1 		mov	r3, fp
 4122 23e0 20209DE5 		ldr	r2, [sp, #32]
 4123 23e4 2410A0E3 		mov	r1, #36
 4124 23e8 0400A0E1 		mov	r0, r4
 4125 23ec 04808DE5 		str	r8, [sp, #4]
 4126 23f0 FEFFFFEB 		bl	cmdSet
 4127              	.LVL433:
2008:../uvc.c      **** 							 getData1 = Data1;
 4128              		.loc 1 2008 0
 4129 23f4 1C0094E5 		ldr	r0, [r4, #28]
 4130 23f8 FEFFFFEB 		bl	_txe_mutex_put
 4131              	.LVL434:
2011:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 4132              		.loc 1 2011 0
 4133 23fc 78301FE5 		ldr	r3, .L438+72
 4134 2400 24C09DE5 		ldr	ip, [sp, #36]
2014:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4135              		.loc 1 2014 0
 4136 2404 FF70A0E3 		mov	r7, #255
2011:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 4137              		.loc 1 2011 0
 4138 2408 41C5C3E5 		strb	ip, [r3, #1345]
2012:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 4139              		.loc 1 2012 0
 4140 240c 28C09DE5 		ldr	ip, [sp, #40]
2014:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4141              		.loc 1 2014 0
 4142 2410 0750A0E1 		mov	r5, r7
2012:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 4143              		.loc 1 2012 0
 4144 2414 42C5C3E5 		strb	ip, [r3, #1346]
2013:../uvc.c      **** 							 break;
 4145              		.loc 1 2013 0
 4146 2418 4585C3E5 		strb	r8, [r3, #1349]
2014:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4147              		.loc 1 2014 0
 4148 241c 69FCFFEA 		b	.L284
 4149              	.LVL435:
 4150              	.L343:
1878:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 4151              		.loc 1 1878 0 discriminator 1
 4152 2420 000058E3 		cmp	r8, #0
 4153 2424 0300000A 		beq	.L351
 4154 2428 B8001FE5 		ldr	r0, .L438+52
 4155 242c 0820A0E1 		mov	r2, r8
 4156 2430 6C1040E2 		sub	r1, r0, #108
 4157 2434 FEFFFFEB 		bl	memcpy
 4158              	.LVL436:
 4159              	.L351:
1882:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4160              		.loc 1 1882 0
 4161 2438 FF70A0E3 		mov	r7, #255
1881:../uvc.c      **** 							 break;
 4162              		.loc 1 1881 0
 4163 243c FEFFFFEB 		bl	I2CCmdHandler
 4164              	.LVL437:
1882:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4165              		.loc 1 1882 0
 4166 2440 0750A0E1 		mov	r5, r7
 4167 2444 5FFCFFEA 		b	.L284
 4168              	.LVL438:
 4169              	.L286:
1481:../uvc.c      **** 			 	 			 if(Len == 2)
 4170              		.loc 1 1481 0
 4171 2448 007087E0 		add	r7, r7, r0
 4172 244c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 4173 2450 DC401FE5 		ldr	r4, .L438+56
 4174 2454 000053E3 		cmp	r3, #0
 4175 2458 8B00000A 		beq	.L299
1482:../uvc.c      **** 			 	 			 {
 4176              		.loc 1 1482 0
 4177 245c 020058E3 		cmp	r8, #2
 4178 2460 2201000A 		beq	.L434
1488:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 4179              		.loc 1 1488 0
 4180 2464 040058E3 		cmp	r8, #4
 4181 2468 36FDFF1A 		bne	.L303
1489:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4182              		.loc 1 1489 0
 4183 246c 004184E0 		add	r4, r4, r0, asl #2
 4184 2470 202014E5 		ldr	r2, [r4, #-32]
 4185 2474 C2FEFFEA 		b	.L409
 4186              	.LVL439:
 4187              	.L361:
2231:../uvc.c      **** 			 	 			 {
 4188              		.loc 1 2231 0
 4189 2478 020058E3 		cmp	r8, #2
 4190 247c C200000A 		beq	.L435
2241:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 4191              		.loc 1 2241 0
 4192 2480 040058E3 		cmp	r8, #4
 4193 2484 1C01000A 		beq	.L390
 4194 2488 055187E0 		add	r5, r7, r5, asl #2
 4195 248c 207195E5 		ldr	r7, [r5, #288]
 4196 2490 14FFFFEA 		b	.L389
 4197              	.L337:
 4198 2494 044187E0 		add	r4, r7, r4, asl #2
 4199 2498 207094E5 		ldr	r7, [r4, #32]
 4200 249c 0DFFFFEA 		b	.L347
 4201              	.LVL440:
 4202              	.L376:
2165:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4203              		.loc 1 2165 0
 4204 24a0 1C711FE5 		ldr	r7, .L438+72
 4205 24a4 6C2094E5 		ldr	r2, [r4, #108]
 4206 24a8 5230D7E5 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 4207 24ac 000052E3 		cmp	r2, #0
 4208 24b0 B020A003 		moveq	r2, #176
 4209 24b4 3020A013 		movne	r2, #48
 4210 24b8 032082E1 		orr	r2, r2, r3
 4211 24bc 3010A0E3 		mov	r1, #48
 4212 24c0 5230A0E3 		mov	r3, #82
 4213 24c4 0100A0E3 		mov	r0, #1
 4214 24c8 FEFFFFEB 		bl	SensorSetIrisControl
 4215              	.LVL441:
2166:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4216              		.loc 1 2166 0
 4217 24cc 7D0FA0E3 		mov	r0, #500
 4218 24d0 FEFFFFEB 		bl	_tx_thread_sleep
 4219              	.LVL442:
2167:../uvc.c      **** 			                         	default:
 4220              		.loc 1 2167 0
 4221 24d4 6C1094E5 		ldr	r1, [r4, #108]
 4222 24d8 5220D7E5 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 4223 24dc 000051E3 		cmp	r1, #0
 4224 24e0 B010A003 		moveq	r1, #176
 4225 24e4 3010A013 		movne	r1, #48
 4226 24e8 022081E1 		orr	r2, r1, r2
 4227 24ec 6C3094E5 		ldr	r3, [r4, #108]
 4228 24f0 78111FE5 		ldr	r1, .L438+60
 4229 24f4 0400A0E3 		mov	r0, #4
 4230 24f8 FEFFFFEB 		bl	CyU3PDebugPrint
 4231              	.LVL443:
 4232 24fc EAFDFFEA 		b	.L416
 4233              	.L375:
2160:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4234              		.loc 1 2160 0
 4235 2500 7C711FE5 		ldr	r7, .L438+72
 4236 2504 6C2094E5 		ldr	r2, [r4, #108]
 4237 2508 5230D7E5 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 4238 250c 000052E3 		cmp	r2, #0
 4239 2510 8020A003 		moveq	r2, #128
 4240 2514 0020A013 		movne	r2, #0
 4241 2518 032082E1 		orr	r2, r2, r3
 4242 251c 3010A0E3 		mov	r1, #48
 4243 2520 5230A0E3 		mov	r3, #82
 4244 2524 0100A0E3 		mov	r0, #1
 4245 2528 FEFFFFEB 		bl	SensorSetIrisControl
 4246              	.LVL444:
2161:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4247              		.loc 1 2161 0
 4248 252c 7D0FA0E3 		mov	r0, #500
 4249 2530 FEFFFFEB 		bl	_tx_thread_sleep
 4250              	.LVL445:
2162:../uvc.c      **** 			                         		break;
 4251              		.loc 1 2162 0
 4252 2534 6C1094E5 		ldr	r1, [r4, #108]
 4253 2538 5220D7E5 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 4254 253c 000051E3 		cmp	r1, #0
 4255 2540 8010A003 		moveq	r1, #128
 4256 2544 0010A013 		movne	r1, #0
 4257 2548 022081E1 		orr	r2, r1, r2
 4258 254c 6C3094E5 		ldr	r3, [r4, #108]
 4259 2550 D8111FE5 		ldr	r1, .L438+60
 4260 2554 0400A0E3 		mov	r0, #4
 4261 2558 FEFFFFEB 		bl	CyU3PDebugPrint
 4262              	.LVL446:
2163:../uvc.c      **** 			                         	case 4: //VGA
 4263              		.loc 1 2163 0
 4264 255c D2FDFFEA 		b	.L416
 4265              	.L374:
2155:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4266              		.loc 1 2155 0
 4267 2560 6C2094E5 		ldr	r2, [r4, #108]
 4268 2564 3010A0E3 		mov	r1, #48
 4269 2568 000052E3 		cmp	r2, #0
 4270 256c 9220A003 		moveq	r2, #146
 4271 2570 1220A013 		movne	r2, #18
 4272 2574 5230A0E3 		mov	r3, #82
 4273 2578 0100A0E3 		mov	r0, #1
 4274 257c FEFFFFEB 		bl	SensorSetIrisControl
 4275              	.LVL447:
2156:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4276              		.loc 1 2156 0
 4277 2580 7D0FA0E3 		mov	r0, #500
 4278 2584 FEFFFFEB 		bl	_tx_thread_sleep
 4279              	.LVL448:
2157:../uvc.c      **** 			                         		break;
 4280              		.loc 1 2157 0
 4281 2588 6C2094E5 		ldr	r2, [r4, #108]
 4282 258c 14121FE5 		ldr	r1, .L438+60
 4283 2590 000052E3 		cmp	r2, #0
 4284 2594 6C3094E5 		ldr	r3, [r4, #108]
 4285 2598 9220A003 		moveq	r2, #146
 4286 259c 1220A013 		movne	r2, #18
 4287 25a0 0400A0E3 		mov	r0, #4
 4288 25a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4289              	.LVL449:
2158:../uvc.c      **** 			                         	case 3: //720
 4290              		.loc 1 2158 0
 4291 25a8 BFFDFFEA 		b	.L416
 4292              	.L372:
2150:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4293              		.loc 1 2150 0
 4294 25ac 6C2094E5 		ldr	r2, [r4, #108]
 4295 25b0 3010A0E3 		mov	r1, #48
 4296 25b4 000052E3 		cmp	r2, #0
 4297 25b8 A220A003 		moveq	r2, #162
 4298 25bc 2220A013 		movne	r2, #34
 4299 25c0 5230A0E3 		mov	r3, #82
 4300 25c4 0100A0E3 		mov	r0, #1
 4301 25c8 FEFFFFEB 		bl	SensorSetIrisControl
 4302              	.LVL450:
2151:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4303              		.loc 1 2151 0
 4304 25cc 7D0FA0E3 		mov	r0, #500
 4305 25d0 FEFFFFEB 		bl	_tx_thread_sleep
 4306              	.LVL451:
2152:../uvc.c      **** 			                         		break;
 4307              		.loc 1 2152 0
 4308 25d4 6C2094E5 		ldr	r2, [r4, #108]
 4309 25d8 60121FE5 		ldr	r1, .L438+60
 4310 25dc 000052E3 		cmp	r2, #0
 4311 25e0 6C3094E5 		ldr	r3, [r4, #108]
 4312 25e4 A220A003 		moveq	r2, #162
 4313 25e8 2220A013 		movne	r2, #34
 4314 25ec 0400A0E3 		mov	r0, #4
 4315 25f0 FEFFFFEB 		bl	CyU3PDebugPrint
 4316              	.LVL452:
2153:../uvc.c      **** 			                         	case 2: //1080
 4317              		.loc 1 2153 0
 4318 25f4 ACFDFFEA 		b	.L416
 4319              	.LVL453:
 4320              	.L333:
2263:../uvc.c      **** 			   }
 4321              		.loc 1 2263 0
 4322 25f8 0400A0E3 		mov	r0, #4
 4323              	.LVL454:
 4324 25fc 80121FE5 		ldr	r1, .L438+64
 4325 2600 FEFFFFEB 		bl	CyU3PDebugPrint
 4326              	.LVL455:
 4327 2604 FF70A0E3 		mov	r7, #255
 4328 2608 0090A0E3 		mov	r9, #0
 4329 260c 0750A0E1 		mov	r5, r7
 4330 2610 09A0A0E1 		mov	r10, r9
 4331 2614 EBFBFFEA 		b	.L284
 4332              	.LVL456:
 4333              	.L311:
1647:../uvc.c      **** 			 	 			 {
 4334              		.loc 1 1647 0
 4335 2618 020058E3 		cmp	r8, #2
 4336 261c CE00000A 		beq	.L436
1655:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4337              		.loc 1 1655 0
 4338 2620 040058E3 		cmp	r8, #4
 4339 2624 C7FCFF1A 		bne	.L303
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4340              		.loc 1 1656 0
 4341 2628 0B10A0E1 		mov	r1, fp
 4342 262c 20009DE5 		ldr	r0, [sp, #32]
 4343              	.LVL457:
 4344 2630 1C308DE5 		str	r3, [sp, #28]
 4345 2634 18C08DE5 		str	ip, [sp, #24]
 4346 2638 FEFFFFEB 		bl	SensorGetControl
 4347              	.LVL458:
1657:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4348              		.loc 1 1657 0
 4349 263c 054184E0 		add	r4, r4, r5, asl #2
 4350 2640 205194E5 		ldr	r5, [r4, #288]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4351              		.loc 1 1658 0
 4352 2644 18C09DE5 		ldr	ip, [sp, #24]
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4353              		.loc 1 1656 0
 4354 2648 C0421FE5 		ldr	r4, .L438+76
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4355              		.loc 1 1658 0
 4356 264c 0B10A0E1 		mov	r1, fp
 4357 2650 0090A0E3 		mov	r9, #0
 4358 2654 09A0A0E1 		mov	r10, r9
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4359              		.loc 1 1656 0
 4360 2658 0020A0E1 		mov	r2, r0
 4361 265c 2820C4E5 		strb	r2, [r4, #40]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4362              		.loc 1 1658 0
 4363 2660 0C00A0E1 		mov	r0, ip
1657:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4364              		.loc 1 1657 0
 4365 2664 0D20C5E5 		strb	r2, [r5, #13]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4366              		.loc 1 1658 0
 4367 2668 FEFFFFEB 		bl	SensorGetControl
 4368              	.LVL459:
 4369 266c 2A00C4E5 		strb	r0, [r4, #42]
1659:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4370              		.loc 1 1659 0
 4371 2670 0E00C5E5 		strb	r0, [r5, #14]
1660:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4372              		.loc 1 1660 0
 4373 2674 1C309DE5 		ldr	r3, [sp, #28]
 4374 2678 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 4375 267c 0070A0E1 		mov	r7, r0
 4376 2680 2930C4E5 		strb	r3, [r4, #41]
1661:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4377              		.loc 1 1661 0
 4378 2684 2B30C4E5 		strb	r3, [r4, #43]
 4379              	.LVL460:
 4380 2688 A0FCFFEA 		b	.L294
 4381              	.LVL461:
 4382              	.L299:
1497:../uvc.c      **** 			 	 			 {
 4383              		.loc 1 1497 0
 4384 268c 020058E3 		cmp	r8, #2
 4385 2690 C200000A 		beq	.L437
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4386              		.loc 1 1505 0
 4387 2694 040058E3 		cmp	r8, #4
 4388 2698 AAFCFF1A 		bne	.L303
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4389              		.loc 1 1506 0
 4390 269c 0B10A0E1 		mov	r1, fp
 4391 26a0 20009DE5 		ldr	r0, [sp, #32]
 4392              	.LVL462:
 4393 26a4 1C308DE5 		str	r3, [sp, #28]
 4394 26a8 18C08DE5 		str	ip, [sp, #24]
 4395 26ac FEFFFFEB 		bl	SensorGetControl
 4396              	.LVL463:
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4397              		.loc 1 1507 0
 4398 26b0 054184E0 		add	r4, r4, r5, asl #2
 4399 26b4 205014E5 		ldr	r5, [r4, #-32]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4400              		.loc 1 1508 0
 4401 26b8 18C09DE5 		ldr	ip, [sp, #24]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4402              		.loc 1 1506 0
 4403 26bc 34431FE5 		ldr	r4, .L438+76
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4404              		.loc 1 1508 0
 4405 26c0 0B10A0E1 		mov	r1, fp
 4406 26c4 0090A0E3 		mov	r9, #0
 4407 26c8 09A0A0E1 		mov	r10, r9
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4408              		.loc 1 1506 0
 4409 26cc 0020A0E1 		mov	r2, r0
 4410 26d0 2820C4E5 		strb	r2, [r4, #40]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4411              		.loc 1 1508 0
 4412 26d4 0C00A0E1 		mov	r0, ip
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4413              		.loc 1 1507 0
 4414 26d8 0D20C5E5 		strb	r2, [r5, #13]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4415              		.loc 1 1508 0
 4416 26dc FEFFFFEB 		bl	SensorGetControl
 4417              	.LVL464:
 4418 26e0 2A00C4E5 		strb	r0, [r4, #42]
1509:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4419              		.loc 1 1509 0
 4420 26e4 0E00C5E5 		strb	r0, [r5, #14]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4421              		.loc 1 1510 0
 4422 26e8 1C309DE5 		ldr	r3, [sp, #28]
 4423 26ec 0070A0E1 		mov	r7, r0
 4424 26f0 2930C4E5 		strb	r3, [r4, #41]
1511:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4425              		.loc 1 1511 0
 4426 26f4 2B30C4E5 		strb	r3, [r4, #43]
 4427              	.LVL465:
 4428 26f8 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 4429 26fc 83FCFFEA 		b	.L294
 4430              	.LVL466:
 4431              	.L385:
2221:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4432              		.loc 1 2221 0
 4433 2700 FEFFFFEB 		bl	_txe_mutex_get
 4434              	.LVL467:
2222:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4435              		.loc 1 2222 0
 4436 2704 24009DE5 		ldr	r0, [sp, #36]
 4437 2708 18C09DE5 		ldr	ip, [sp, #24]
 4438 270c 00008DE5 		str	r0, [sp]
 4439 2710 04008DE5 		str	r0, [sp, #4]
 4440 2714 0C20A0E1 		mov	r2, ip
 4441 2718 5DFDFFEA 		b	.L413
 4442              	.L432:
2042:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4443              		.loc 1 2042 0
 4444 271c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4445 2720 24009DE5 		ldr	r0, [sp, #36]
 4446 2724 000053E1 		cmp	r3, r0
 4447 2728 1400000A 		beq	.L388
2043:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4448              		.loc 1 2043 0
 4449 272c AC431FE5 		ldr	r4, .L438+68
 4450 2730 0010E0E3 		mvn	r1, #0
 4451 2734 1C0094E5 		ldr	r0, [r4, #28]
 4452 2738 18C08DE5 		str	ip, [sp, #24]
 4453 273c FEFFFFEB 		bl	_txe_mutex_get
 4454              	.LVL468:
2044:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4455              		.loc 1 2044 0
 4456 2740 24109DE5 		ldr	r1, [sp, #36]
 4457 2744 00108DE5 		str	r1, [sp]
 4458              	.L417:
2235:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4459              		.loc 1 2235 0
 4460 2748 18C09DE5 		ldr	ip, [sp, #24]
 4461 274c 0510A0E1 		mov	r1, r5
 4462 2750 0C20A0E1 		mov	r2, ip
 4463 2754 00C0A0E3 		mov	ip, #0
 4464 2758 04C08DE5 		str	ip, [sp, #4]
 4465 275c 0B30A0E1 		mov	r3, fp
 4466 2760 0400A0E1 		mov	r0, r4
 4467 2764 FEFFFFEB 		bl	cmdSet
 4468              	.LVL469:
2236:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4469              		.loc 1 2236 0
 4470 2768 1C0094E5 		ldr	r0, [r4, #28]
 4471 276c FEFFFFEB 		bl	_txe_mutex_put
 4472              	.LVL470:
2237:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4473              		.loc 1 2237 0
 4474 2770 24C09DE5 		ldr	ip, [sp, #36]
2238:../uvc.c      **** 								 }
 4475              		.loc 1 2238 0
 4476 2774 0000A0E3 		mov	r0, #0
2237:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4477              		.loc 1 2237 0
 4478 2778 0DC0C7E5 		strb	ip, [r7, #13]
 4479              	.LVL471:
2238:../uvc.c      **** 								 }
 4480              		.loc 1 2238 0
 4481 277c 0E00C7E5 		strb	r0, [r7, #14]
 4482              	.L388:
2240:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4483              		.loc 1 2240 0
 4484 2780 0130A0E3 		mov	r3, #1
 4485 2784 1130C7E5 		strb	r3, [r7, #17]
 4486 2788 56FEFFEA 		b	.L389
 4487              	.LVL472:
 4488              	.L435:
2233:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4489              		.loc 1 2233 0
 4490 278c 057187E0 		add	r7, r7, r5, asl #2
 4491 2790 207197E5 		ldr	r7, [r7, #288]
 4492 2794 24109DE5 		ldr	r1, [sp, #36]
 4493 2798 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4494 279c 010053E1 		cmp	r3, r1
 4495 27a0 F6FFFF0A 		beq	.L388
2234:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4496              		.loc 1 2234 0
 4497 27a4 24441FE5 		ldr	r4, .L438+68
 4498 27a8 0010E0E3 		mvn	r1, #0
 4499 27ac 1C0094E5 		ldr	r0, [r4, #28]
 4500 27b0 18C08DE5 		str	ip, [sp, #24]
 4501 27b4 FEFFFFEB 		bl	_txe_mutex_get
 4502              	.LVL473:
2235:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4503              		.loc 1 2235 0
 4504 27b8 24209DE5 		ldr	r2, [sp, #36]
 4505 27bc 00208DE5 		str	r2, [sp]
 4506 27c0 E0FFFFEA 		b	.L417
 4507              	.L433:
2051:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4508              		.loc 1 2051 0
 4509 27c4 44141FE5 		ldr	r1, .L438+68
 4510 27c8 2C108DE5 		str	r1, [sp, #44]
 4511 27cc 2C209DE5 		ldr	r2, [sp, #44]
 4512 27d0 0010E0E3 		mvn	r1, #0
 4513 27d4 1C0092E5 		ldr	r0, [r2, #28]
 4514 27d8 18C08DE5 		str	ip, [sp, #24]
 4515 27dc FEFFFFEB 		bl	_txe_mutex_get
 4516              	.LVL474:
 4517              	.L422:
2243:../uvc.c      **** 								 {
 4518              		.loc 1 2243 0
 4519 27e0 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4520 27e4 24009DE5 		ldr	r0, [sp, #36]
 4521 27e8 18C09DE5 		ldr	ip, [sp, #24]
 4522 27ec 000053E1 		cmp	r3, r0
2246:../uvc.c      **** 									 dataIdx++;
 4523              		.loc 1 2246 0
 4524 27f0 0030A0E3 		mov	r3, #0
2243:../uvc.c      **** 								 {
 4525              		.loc 1 2243 0
 4526 27f4 0700000A 		beq	.L391
2245:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4527              		.loc 1 2245 0
 4528 27f8 0D00C7E5 		strb	r0, [r7, #13]
 4529              	.LVL475:
2246:../uvc.c      **** 									 dataIdx++;
 4530              		.loc 1 2246 0
 4531 27fc 0C20A0E1 		mov	r2, ip
 4532 2800 09008DE8 		stmia	sp, {r0, r3}
 4533 2804 2C009DE5 		ldr	r0, [sp, #44]
 4534 2808 0B30A0E1 		mov	r3, fp
 4535 280c 0510A0E1 		mov	r1, r5
 4536 2810 FEFFFFEB 		bl	cmdSet
 4537              	.LVL476:
2247:../uvc.c      **** 								 }
 4538              		.loc 1 2247 0
 4539 2814 0130A0E3 		mov	r3, #1
 4540              	.LVL477:
 4541              	.L391:
2249:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4542              		.loc 1 2249 0
 4543 2818 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4544 281c 28C09DE5 		ldr	ip, [sp, #40]
 4545 2820 0C0052E1 		cmp	r2, ip
 4546 2824 0700000A 		beq	.L392
2250:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4547              		.loc 1 2250 0
 4548 2828 0EC0C7E5 		strb	ip, [r7, #14]
2251:../uvc.c      **** 								 }
 4549              		.loc 1 2251 0
 4550 282c 0510A0E1 		mov	r1, r5
 4551 2830 04308DE5 		str	r3, [sp, #4]
 4552 2834 00C08DE5 		str	ip, [sp]
 4553 2838 20209DE5 		ldr	r2, [sp, #32]
 4554 283c 0B30A0E1 		mov	r3, fp
 4555              	.LVL478:
 4556 2840 C0041FE5 		ldr	r0, .L438+68
 4557 2844 FEFFFFEB 		bl	cmdSet
 4558              	.LVL479:
 4559              	.L392:
2253:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4560              		.loc 1 2253 0
 4561 2848 0130A0E3 		mov	r3, #1
 4562 284c 1130C7E5 		strb	r3, [r7, #17]
2254:../uvc.c      **** 
 4563              		.loc 1 2254 0
 4564 2850 2CC09DE5 		ldr	ip, [sp, #44]
 4565 2854 1C009CE5 		ldr	r0, [ip, #28]
 4566 2858 FEFFFFEB 		bl	_txe_mutex_put
 4567              	.LVL480:
 4568 285c 21FEFFEA 		b	.L389
 4569              	.LVL481:
 4570              	.L431:
1634:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4571              		.loc 1 1634 0
 4572 2860 004184E0 		add	r4, r4, r0, asl #2
 4573 2864 203194E5 		ldr	r3, [r4, #288]
 4574              	.L408:
 4575 2868 0D50D3E5 		ldrb	r5, [r3, #13]	@ zero_extendqisi2
 4576 286c E4441FE5 		ldr	r4, .L438+76
 4577 2870 FF5005E2 		and	r5, r5, #255
 4578 2874 2850C4E5 		strb	r5, [r4, #40]
1635:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4579              		.loc 1 1635 0
 4580 2878 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4581 287c 0090A0E3 		mov	r9, #0
 4582 2880 FF7007E2 		and	r7, r7, #255
 4583 2884 2970C4E5 		strb	r7, [r4, #41]
 4584              	.LVL482:
 4585 2888 09A0A0E1 		mov	r10, r9
 4586 288c 1FFCFFEA 		b	.L294
 4587              	.LVL483:
 4588              	.L352:
1891:../uvc.c      **** 								 if((pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo&0x03) != Data0)
 4589              		.loc 1 1891 0
 4590 2890 0C00A0E1 		mov	r0, ip
 4591 2894 0B10A0E1 		mov	r1, fp
 4592 2898 18C08DE5 		str	ip, [sp, #24]
 4593 289c FEFFFFEB 		bl	SensorGetControl
 4594              	.LVL484:
 4595 28a0 0D00C4E5 		strb	r0, [r4, #13]
1892:../uvc.c      **** 								 {
 4596              		.loc 1 1892 0
 4597 28a4 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
 4598 28a8 24009DE5 		ldr	r0, [sp, #36]
 4599 28ac 033003E2 		and	r3, r3, #3
 4600 28b0 030050E1 		cmp	r0, r3
 4601 28b4 18C09DE5 		ldr	ip, [sp, #24]
 4602 28b8 66FEFF0A 		beq	.L353
1894:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
 4603              		.loc 1 1894 0
 4604 28bc 0D90D4E5 		ldrb	r9, [r4, #13]	@ zero_extendqisi2
1896:../uvc.c      **** 									 dataIdx++;
 4605              		.loc 1 1896 0
 4606 28c0 0010A0E3 		mov	r1, #0
1894:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
 4607              		.loc 1 1894 0
 4608 28c4 FC9009E2 		and	r9, r9, #252
 4609 28c8 099080E1 		orr	r9, r0, r9
 4610              	.LVL485:
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4611              		.loc 1 1895 0
 4612 28cc 0D90C4E5 		strb	r9, [r4, #13]
1896:../uvc.c      **** 									 dataIdx++;
 4613              		.loc 1 1896 0
 4614 28d0 0C20A0E1 		mov	r2, ip
 4615 28d4 04108DE5 		str	r1, [sp, #4]
 4616 28d8 0B30A0E1 		mov	r3, fp
 4617 28dc 2C009DE5 		ldr	r0, [sp, #44]
 4618 28e0 00908DE5 		str	r9, [sp]
 4619 28e4 1910A0E3 		mov	r1, #25
 4620 28e8 FEFFFFEB 		bl	cmdSet
 4621              	.LVL486:
 4622 28ec 59FEFFEA 		b	.L353
 4623              	.LVL487:
 4624              	.L434:
1484:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4625              		.loc 1 1484 0
 4626 28f0 004184E0 		add	r4, r4, r0, asl #2
 4627 28f4 203014E5 		ldr	r3, [r4, #-32]
 4628 28f8 DAFFFFEA 		b	.L408
 4629              	.LVL488:
 4630              	.L390:
2242:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4631              		.loc 1 2242 0
 4632 28fc 7C151FE5 		ldr	r1, .L438+68
 4633 2900 80251FE5 		ldr	r2, .L438+68
 4634 2904 2C108DE5 		str	r1, [sp, #44]
 4635 2908 1C0092E5 		ldr	r0, [r2, #28]
 4636 290c 0010E0E3 		mvn	r1, #0
2243:../uvc.c      **** 								 {
 4637              		.loc 1 2243 0
 4638 2910 057187E0 		add	r7, r7, r5, asl #2
2242:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4639              		.loc 1 2242 0
 4640 2914 18C08DE5 		str	ip, [sp, #24]
 4641 2918 FEFFFFEB 		bl	_txe_mutex_get
 4642              	.LVL489:
2243:../uvc.c      **** 								 {
 4643              		.loc 1 2243 0
 4644 291c 207197E5 		ldr	r7, [r7, #288]
 4645 2920 AEFFFFEA 		b	.L422
 4646              	.LVL490:
 4647              	.L430:
1616:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4648              		.loc 1 1616 0
 4649 2924 20009DE5 		ldr	r0, [sp, #32]
 4650              	.LVL491:
 4651 2928 0B10A0E1 		mov	r1, fp
 4652 292c FEFFFFEB 		bl	SensorGetControl
 4653              	.LVL492:
 4654 2930 A8451FE5 		ldr	r4, .L438+76
1617:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4655              		.loc 1 1617 0
 4656 2934 B0351FE5 		ldr	r3, .L438+72
1618:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4657              		.loc 1 1618 0
 4658 2938 0070A0E3 		mov	r7, #0
 4659 293c 2970C4E5 		strb	r7, [r4, #41]
 4660 2940 0790A0E1 		mov	r9, r7
 4661 2944 07A0A0E1 		mov	r10, r7
1617:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4662              		.loc 1 1617 0
 4663 2948 9505C3E5 		strb	r0, [r3, #1429]
1616:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4664              		.loc 1 1616 0
 4665 294c 2800C4E5 		strb	r0, [r4, #40]
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4666              		.loc 1 1619 0
 4667 2950 9675C3E5 		strb	r7, [r3, #1430]
 4668              	.LVL493:
 4669 2954 0050A0E1 		mov	r5, r0
 4670 2958 ECFBFFEA 		b	.L294
 4671              	.LVL494:
 4672              	.L436:
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4673              		.loc 1 1649 0
 4674 295c 0C00A0E1 		mov	r0, ip
 4675              	.LVL495:
 4676 2960 0B10A0E1 		mov	r1, fp
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4677              		.loc 1 1650 0
 4678 2964 054184E0 		add	r4, r4, r5, asl #2
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4679              		.loc 1 1649 0
 4680 2968 1C308DE5 		str	r3, [sp, #28]
 4681 296c FEFFFFEB 		bl	SensorGetControl
 4682              	.LVL496:
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4683              		.loc 1 1650 0
 4684 2970 202194E5 		ldr	r2, [r4, #288]
 4685              	.L407:
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4686              		.loc 1 1649 0
 4687 2974 EC451FE5 		ldr	r4, .L438+76
 4688 2978 0090A0E3 		mov	r9, #0
 4689 297c 2800C4E5 		strb	r0, [r4, #40]
 4690 2980 1C309DE5 		ldr	r3, [sp, #28]
 4691 2984 0050A0E1 		mov	r5, r0
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4692              		.loc 1 1650 0
 4693 2988 0D00C2E5 		strb	r0, [r2, #13]
 4694              	.LVL497:
 4695 298c 0370A0E1 		mov	r7, r3
1651:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4696              		.loc 1 1651 0
 4697 2990 2930C4E5 		strb	r3, [r4, #41]
 4698 2994 09A0A0E1 		mov	r10, r9
1652:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4699              		.loc 1 1652 0
 4700 2998 0E30C2E5 		strb	r3, [r2, #14]
 4701              	.LVL498:
 4702 299c DBFBFFEA 		b	.L294
 4703              	.LVL499:
 4704              	.L437:
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4705              		.loc 1 1499 0
 4706 29a0 0C00A0E1 		mov	r0, ip
 4707              	.LVL500:
 4708 29a4 0B10A0E1 		mov	r1, fp
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4709              		.loc 1 1500 0
 4710 29a8 054184E0 		add	r4, r4, r5, asl #2
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4711              		.loc 1 1499 0
 4712 29ac 1C308DE5 		str	r3, [sp, #28]
 4713 29b0 FEFFFFEB 		bl	SensorGetControl
 4714              	.LVL501:
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4715              		.loc 1 1500 0
 4716 29b4 202014E5 		ldr	r2, [r4, #-32]
 4717 29b8 EDFFFFEA 		b	.L407
 4718              		.cfi_endproc
 4719              	.LFE3:
 4721              		.align	2
 4722              		.global	CTControlHandle
 4724              	CTControlHandle:
 4725              	.LFB4:
2279:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4726              		.loc 1 2279 0
 4727              		.cfi_startproc
 4728              		@ args = 0, pretend = 0, frame = 24
 4729              		@ frame_needed = 0, uses_anonymous_args = 0
 4730              	.LVL502:
 4731 29bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4732              	.LCFI19:
 4733              		.cfi_def_cfa_offset 36
 4734              		.cfi_offset 4, -36
 4735              		.cfi_offset 5, -32
 4736              		.cfi_offset 6, -28
 4737              		.cfi_offset 7, -24
 4738              		.cfi_offset 8, -20
 4739              		.cfi_offset 9, -16
 4740              		.cfi_offset 10, -12
 4741              		.cfi_offset 11, -8
 4742              		.cfi_offset 14, -4
2298:../uvc.c      **** 
 4743              		.loc 1 2298 0
 4744 29c0 28B89FE5 		ldr	fp, .L478
2290:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4745              		.loc 1 2290 0
 4746 29c4 28389FE5 		ldr	r3, .L478+4
2298:../uvc.c      **** 
 4747              		.loc 1 2298 0
 4748 29c8 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2290:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4749              		.loc 1 2290 0
 4750 29cc 8080A0E1 		mov	r8, r0, asl #1
 4751 29d0 002088E0 		add	r2, r8, r0
 4752 29d4 822183E0 		add	r2, r3, r2, asl #3
2300:../uvc.c      **** 		 {
 4753              		.loc 1 2300 0
 4754 29d8 830055E3 		cmp	r5, #131
2279:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4755              		.loc 1 2279 0
 4756 29dc 34D04DE2 		sub	sp, sp, #52
 4757              	.LCFI20:
 4758              		.cfi_def_cfa_offset 88
2279:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4759              		.loc 1 2279 0
 4760 29e0 0060A0E1 		mov	r6, r0
2290:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4761              		.loc 1 2290 0
 4762 29e4 E795D2E5 		ldrb	r9, [r2, #1511]	@ zero_extendqisi2
 4763              	.LVL503:
2291:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4764              		.loc 1 2291 0
 4765 29e8 D8A5D2E5 		ldrb	r10, [r2, #1496]	@ zero_extendqisi2
 4766              	.LVL504:
2293:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4767              		.loc 1 2293 0
 4768 29ec DA75D2E5 		ldrb	r7, [r2, #1498]	@ zero_extendqisi2
 4769              	.LVL505:
2300:../uvc.c      **** 		 {
 4770              		.loc 1 2300 0
 4771 29f0 8000000A 		beq	.L442
 4772 29f4 2600009A 		bls	.L476
 4773 29f8 850055E3 		cmp	r5, #133
 4774 29fc 7200000A 		beq	.L447
 4775 2a00 5000003A 		bcc	.L448
 4776 2a04 860055E3 		cmp	r5, #134
 4777 2a08 4300000A 		beq	.L449
 4778 2a0c 870055E3 		cmp	r5, #135
 4779 2a10 5F00001A 		bne	.L441
2362:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4780              		.loc 1 2362 0
 4781 2a14 E3C5D2E5 		ldrb	ip, [r2, #1507]	@ zero_extendqisi2
 4782 2a18 D8479FE5 		ldr	r4, .L478+8
2363:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4783              		.loc 1 2363 0
 4784 2a1c E425D2E5 		ldrb	r2, [r2, #1508]	@ zero_extendqisi2
 4785              	.LVL506:
 4786              	.L475:
2340:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4787              		.loc 1 2340 0
 4788 2a20 0A1056E2 		subs	r1, r6, #10
 4789 2a24 006071E2 		rsbs	r6, r1, #0
 4790 2a28 0160B6E0 		adcs	r6, r6, r1
2342:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4791              		.loc 1 2342 0
 4792 2a2c 0030A0E3 		mov	r3, #0
 4793              	.LVL507:
2343:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4794              		.loc 1 2343 0
 4795 2a30 281084E2 		add	r1, r4, #40
 4796 2a34 0700A0E1 		mov	r0, r7
 4797              	.LVL508:
2340:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4798              		.loc 1 2340 0
 4799 2a38 2A60C4E5 		strb	r6, [r4, #42]
2338:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4800              		.loc 1 2338 0
 4801 2a3c 28C0C4E5 		strb	ip, [r4, #40]
2339:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4802              		.loc 1 2339 0
 4803 2a40 2920C4E5 		strb	r2, [r4, #41]
2342:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4804              		.loc 1 2342 0
 4805 2a44 2B30C4E5 		strb	r3, [r4, #43]
2343:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4806              		.loc 1 2343 0
 4807 2a48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4808              	.LVL509:
 4809 2a4c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2345:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4810              		.loc 1 2345 0
 4811 2a50 FF80A0E3 		mov	r8, #255
 4812 2a54 0860A0E1 		mov	r6, r8
 4813              	.LVL510:
 4814              	.L451:
2513:../uvc.c      **** }
 4815              		.loc 1 2513 0
 4816 2a58 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4817 2a5c FFC0A0E3 		mov	ip, #255
 4818 2a60 04108DE5 		str	r1, [sp, #4]
 4819 2a64 10108DE5 		str	r1, [sp, #16]
 4820 2a68 08008DE5 		str	r0, [sp, #8]
 4821 2a6c 00808DE5 		str	r8, [sp]
 4822 2a70 14708DE5 		str	r7, [sp, #20]
 4823 2a74 0520A0E1 		mov	r2, r5
 4824 2a78 0630A0E1 		mov	r3, r6
 4825 2a7c 0CC08DE5 		str	ip, [sp, #12]
 4826 2a80 74179FE5 		ldr	r1, .L478+12
 4827 2a84 0400A0E3 		mov	r0, #4
 4828 2a88 FEFFFFEB 		bl	CyU3PDebugPrint
 4829              	.LVL511:
2514:../uvc.c      **** 
 4830              		.loc 1 2514 0
 4831 2a8c 34D08DE2 		add	sp, sp, #52
 4832              		@ sp needed
 4833 2a90 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4834              	.LVL512:
 4835              	.L476:
2300:../uvc.c      **** 		 {
 4836              		.loc 1 2300 0
 4837 2a94 810055E3 		cmp	r5, #129
 4838 2a98 2E00000A 		beq	.L444
 4839 2a9c 1A00008A 		bhi	.L445
 4840 2aa0 010055E3 		cmp	r5, #1
 4841 2aa4 3A00001A 		bne	.L441
2371:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4842              		.loc 1 2371 0
 4843 2aa8 48479FE5 		ldr	r4, .L478+8
 4844 2aac 2E208DE2 		add	r2, sp, #46
 4845              	.LVL513:
 4846 2ab0 2000A0E3 		mov	r0, #32
 4847              	.LVL514:
 4848 2ab4 281084E2 		add	r1, r4, #40
 4849 2ab8 18308DE5 		str	r3, [sp, #24]
 4850 2abc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4851              	.LVL515:
2373:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4852              		.loc 1 2373 0
 4853 2ac0 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2377:../uvc.c      **** 			  {
 4854              		.loc 1 2377 0
 4855 2ac4 012046E2 		sub	r2, r6, #1
2373:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4856              		.loc 1 2373 0
 4857 2ac8 1CC08DE5 		str	ip, [sp, #28]
 4858              	.LVL516:
2374:../uvc.c      **** 			  value = Data1;
 4859              		.loc 1 2374 0
 4860 2acc 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2377:../uvc.c      **** 			  {
 4861              		.loc 1 2377 0
 4862 2ad0 18309DE5 		ldr	r3, [sp, #24]
2374:../uvc.c      **** 			  value = Data1;
 4863              		.loc 1 2374 0
 4864 2ad4 20C08DE5 		str	ip, [sp, #32]
 4865              	.LVL517:
2377:../uvc.c      **** 			  {
 4866              		.loc 1 2377 0
 4867 2ad8 090052E3 		cmp	r2, #9
 4868 2adc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4869 2ae0 1D0100EA 		b	.L452
 4870              	.L454:
 4871 2ae4 142F0000 		.word	.L453
 4872 2ae8 5C2F0000 		.word	.L452
 4873 2aec 142D0000 		.word	.L455
 4874 2af0 5C2F0000 		.word	.L452
 4875 2af4 5C2F0000 		.word	.L452
 4876 2af8 5C2F0000 		.word	.L452
 4877 2afc 842C0000 		.word	.L456
 4878 2b00 5C2F0000 		.word	.L452
 4879 2b04 5C2F0000 		.word	.L452
 4880 2b08 082C0000 		.word	.L457
 4881              	.LVL518:
 4882              	.L445:
2329:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4883              		.loc 1 2329 0
 4884 2b0c DBC5D2E5 		ldrb	ip, [r2, #1499]	@ zero_extendqisi2
 4885 2b10 E0469FE5 		ldr	r4, .L478+8
2330:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4886              		.loc 1 2330 0
 4887 2b14 DC25D2E5 		ldrb	r2, [r2, #1500]	@ zero_extendqisi2
 4888              	.LVL519:
 4889 2b18 C0FFFFEA 		b	.L475
 4890              	.LVL520:
 4891              	.L449:
2356:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4892              		.loc 1 2356 0
 4893 2b1c D4469FE5 		ldr	r4, .L478+8
 4894 2b20 E135D2E5 		ldrb	r3, [r2, #1505]	@ zero_extendqisi2
 4895 2b24 0410A0E1 		mov	r1, r4
 4896 2b28 2830E1E5 		strb	r3, [r1, #40]!
2357:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4897              		.loc 1 2357 0
 4898 2b2c 0100A0E3 		mov	r0, #1
 4899              	.LVL521:
2360:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4900              		.loc 1 2360 0
 4901 2b30 FF80A0E3 		mov	r8, #255
2357:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4902              		.loc 1 2357 0
 4903 2b34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4904              	.LVL522:
2360:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4905              		.loc 1 2360 0
 4906 2b38 0860A0E1 		mov	r6, r8
 4907 2b3c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4908 2b40 0170A0E3 		mov	r7, #1
 4909 2b44 C3FFFFEA 		b	.L451
 4910              	.LVL523:
 4911              	.L448:
2347:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4912              		.loc 1 2347 0
 4913 2b48 DFC5D2E5 		ldrb	ip, [r2, #1503]	@ zero_extendqisi2
 4914 2b4c A4469FE5 		ldr	r4, .L478+8
2348:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4915              		.loc 1 2348 0
 4916 2b50 E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 4917              	.LVL524:
 4918 2b54 B1FFFFEA 		b	.L475
 4919              	.LVL525:
 4920              	.L444:
2314:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4921              		.loc 1 2314 0
 4922 2b58 98469FE5 		ldr	r4, .L478+8
 4923 2b5c E595D2E5 		ldrb	r9, [r2, #1509]	@ zero_extendqisi2
2315:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4924              		.loc 1 2315 0
 4925 2b60 E6C5D2E5 		ldrb	ip, [r2, #1510]	@ zero_extendqisi2
2316:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4926              		.loc 1 2316 0
 4927 2b64 0030A0E3 		mov	r3, #0
2322:../uvc.c      **** 
 4928              		.loc 1 2322 0
 4929 2b68 281084E2 		add	r1, r4, #40
 4930 2b6c 0700A0E1 		mov	r0, r7
 4931              	.LVL526:
2327:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4932              		.loc 1 2327 0
 4933 2b70 FF80A0E3 		mov	r8, #255
2315:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4934              		.loc 1 2315 0
 4935 2b74 29C0C4E5 		strb	ip, [r4, #41]
2314:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4936              		.loc 1 2314 0
 4937 2b78 2890C4E5 		strb	r9, [r4, #40]
2316:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4938              		.loc 1 2316 0
 4939 2b7c 2A30C4E5 		strb	r3, [r4, #42]
2317:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4940              		.loc 1 2317 0
 4941 2b80 2B30C4E5 		strb	r3, [r4, #43]
 4942              	.LVL527:
2327:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4943              		.loc 1 2327 0
 4944 2b84 0860A0E1 		mov	r6, r8
 4945              	.LVL528:
2322:../uvc.c      **** 
 4946              		.loc 1 2322 0
 4947 2b88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4948              	.LVL529:
 4949 2b8c 0900A0E1 		mov	r0, r9
2327:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4950              		.loc 1 2327 0
 4951 2b90 B0FFFFEA 		b	.L451
 4952              	.LVL530:
 4953              	.L441:
2507:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4954              		.loc 1 2507 0
 4955 2b94 0000A0E3 		mov	r0, #0
 4956              	.LVL531:
 4957 2b98 0020A0E1 		mov	r2, r0
 4958              	.LVL532:
 4959 2b9c 0110A0E3 		mov	r1, #1
 4960 2ba0 FEFFFFEB 		bl	CyU3PUsbStall
 4961              	.LVL533:
2508:../uvc.c      **** 			  break;
 4962              		.loc 1 2508 0
 4963 2ba4 0620A0E1 		mov	r2, r6
 4964 2ba8 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 4965 2bac 0400A0E3 		mov	r0, #4
 4966 2bb0 48169FE5 		ldr	r1, .L478+16
 4967 2bb4 FEFFFFEB 		bl	CyU3PDebugPrint
 4968              	.LVL534:
2509:../uvc.c      **** 		 }
 4969              		.loc 1 2509 0
 4970 2bb8 FF00A0E3 		mov	r0, #255
 4971 2bbc 34469FE5 		ldr	r4, .L478+8
 4972 2bc0 0080A0E1 		mov	r8, r0
 4973 2bc4 0060A0E1 		mov	r6, r0
 4974 2bc8 A2FFFFEA 		b	.L451
 4975              	.LVL535:
 4976              	.L447:
2304:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4977              		.loc 1 2304 0
 4978 2bcc 24469FE5 		ldr	r4, .L478+8
2305:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4979              		.loc 1 2305 0
 4980 2bd0 0030A0E3 		mov	r3, #0
2306:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4981              		.loc 1 2306 0
 4982 2bd4 281084E2 		add	r1, r4, #40
 4983 2bd8 0200A0E3 		mov	r0, #2
 4984              	.LVL536:
2308:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4985              		.loc 1 2308 0
 4986 2bdc FF80A0E3 		mov	r8, #255
2304:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4987              		.loc 1 2304 0
 4988 2be0 2870C4E5 		strb	r7, [r4, #40]
2305:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4989              		.loc 1 2305 0
 4990 2be4 2930C4E5 		strb	r3, [r4, #41]
2308:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4991              		.loc 1 2308 0
 4992 2be8 0860A0E1 		mov	r6, r8
 4993              	.LVL537:
2306:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4994              		.loc 1 2306 0
 4995 2bec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4996              	.LVL538:
 4997 2bf0 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2308:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4998              		.loc 1 2308 0
 4999 2bf4 97FFFFEA 		b	.L451
 5000              	.LVL539:
 5001              	.L442:
2338:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5002              		.loc 1 2338 0
 5003 2bf8 DDC5D2E5 		ldrb	ip, [r2, #1501]	@ zero_extendqisi2
 5004 2bfc F4459FE5 		ldr	r4, .L478+8
2339:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5005              		.loc 1 2339 0
 5006 2c00 DE25D2E5 		ldrb	r2, [r2, #1502]	@ zero_extendqisi2
 5007              	.LVL540:
 5008 2c04 85FFFFEA 		b	.L475
 5009              	.LVL541:
 5010              	.L457:
2486:../uvc.c      **** 					  if(getData == 1)
 5011              		.loc 1 2486 0
 5012 2c08 F4659FE5 		ldr	r6, .L478+20
 5013 2c0c 0010E0E3 		mvn	r1, #0
 5014 2c10 1C0096E5 		ldr	r0, [r6, #28]
 5015 2c14 FEFFFFEB 		bl	_txe_mutex_get
 5016              	.LVL542:
2487:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5017              		.loc 1 2487 0
 5018 2c18 1CC09DE5 		ldr	ip, [sp, #28]
 5019 2c1c 01005CE3 		cmp	ip, #1
2488:../uvc.c      **** 					  else if(getData == 0xff)
 5020              		.loc 1 2488 0
 5021 2c20 0400A003 		moveq	r0, #4
2487:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5022              		.loc 1 2487 0
 5023 2c24 6901000A 		beq	.L474
2489:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5024              		.loc 1 2489 0
 5025 2c28 FF005CE3 		cmp	ip, #255
 5026 2c2c 6601000A 		beq	.L477
2492:../uvc.c      **** 					  //dataIdx++;
 5027              		.loc 1 2492 0
 5028 2c30 0010A0E3 		mov	r1, #0
 5029 2c34 00108DE5 		str	r1, [sp]
 5030 2c38 04108DE5 		str	r1, [sp, #4]
 5031 2c3c 0A20A0E1 		mov	r2, r10
 5032 2c40 0930A0E1 		mov	r3, r9
 5033 2c44 0600A0E1 		mov	r0, r6
 5034 2c48 2310A0E3 		mov	r1, #35
 5035 2c4c FEFFFFEB 		bl	cmdSet
 5036              	.LVL543:
 5037              	.L469:
2495:../uvc.c      **** #endif
 5038              		.loc 1 2495 0
 5039 2c50 1C0096E5 		ldr	r0, [r6, #28]
 5040 2c54 FEFFFFEB 		bl	_txe_mutex_put
 5041              	.LVL544:
2497:../uvc.c      **** 					  break;
 5042              		.loc 1 2497 0
 5043 2c58 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5044 2c5c 1C609DE5 		ldr	r6, [sp, #28]
 5045 2c60 20809DE5 		ldr	r8, [sp, #32]
 5046 2c64 00108DE5 		str	r1, [sp]
 5047 2c68 0620A0E1 		mov	r2, r6
 5048 2c6c 0830A0E1 		mov	r3, r8
 5049 2c70 0400A0E3 		mov	r0, #4
 5050 2c74 8C159FE5 		ldr	r1, .L478+24
 5051 2c78 FEFFFFEB 		bl	CyU3PDebugPrint
 5052              	.LVL545:
2498:../uvc.c      **** 
 5053              		.loc 1 2498 0
 5054 2c7c FF00A0E3 		mov	r0, #255
 5055 2c80 74FFFFEA 		b	.L451
 5056              	.LVL546:
 5057              	.L456:
2463:../uvc.c      **** 					  {
 5058              		.loc 1 2463 0
 5059 2c84 FD05D3E5 		ldrb	r0, [r3, #1533]	@ zero_extendqisi2
 5060 2c88 64C59FE5 		ldr	ip, .L478+4
 5061 2c8c 010050E3 		cmp	r0, #1
 5062 2c90 08005013 		cmpne	r0, #8
 5063 2c94 0000A013 		movne	r0, #0
 5064 2c98 0100A003 		moveq	r0, #1
 5065 2c9c 4601001A 		bne	.L466
 5066              	.LVL547:
2466:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5067              		.loc 1 2466 0
 5068 2ca0 5CB59FE5 		ldr	fp, .L478+20
 5069 2ca4 0010E0E3 		mvn	r1, #0
 5070 2ca8 1C009BE5 		ldr	r0, [fp, #28]
 5071 2cac 18C08DE5 		str	ip, [sp, #24]
 5072 2cb0 FEFFFFEB 		bl	_txe_mutex_get
 5073              	.LVL548:
2467:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5074              		.loc 1 2467 0
 5075 2cb4 1C009DE5 		ldr	r0, [sp, #28]
 5076 2cb8 0010A0E3 		mov	r1, #0
 5077 2cbc 0A20A0E1 		mov	r2, r10
 5078 2cc0 0930A0E1 		mov	r3, r9
 5079 2cc4 00008DE5 		str	r0, [sp]
 5080 2cc8 04108DE5 		str	r1, [sp, #4]
 5081 2ccc 0B00A0E1 		mov	r0, fp
 5082 2cd0 2210A0E3 		mov	r1, #34
 5083 2cd4 FEFFFFEB 		bl	cmdSet
 5084              	.LVL549:
2468:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5085              		.loc 1 2468 0
 5086 2cd8 1C009BE5 		ldr	r0, [fp, #28]
 5087 2cdc FEFFFFEB 		bl	_txe_mutex_put
 5088              	.LVL550:
2471:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5089              		.loc 1 2471 0
 5090 2ce0 18C09DE5 		ldr	ip, [sp, #24]
 5091 2ce4 1C109DE5 		ldr	r1, [sp, #28]
2472:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5092              		.loc 1 2472 0
 5093 2ce8 20209DE5 		ldr	r2, [sp, #32]
2471:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5094              		.loc 1 2471 0
 5095 2cec 066088E0 		add	r6, r8, r6
 5096 2cf0 86C18CE0 		add	ip, ip, r6, asl #3
2473:../uvc.c      **** 					  }else{
 5097              		.loc 1 2473 0
 5098 2cf4 0130A0E3 		mov	r3, #1
2471:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5099              		.loc 1 2471 0
 5100 2cf8 E515CCE5 		strb	r1, [ip, #1509]
2472:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5101              		.loc 1 2472 0
 5102 2cfc E625CCE5 		strb	r2, [ip, #1510]
2473:../uvc.c      **** 					  }else{
 5103              		.loc 1 2473 0
 5104 2d00 E835CCE5 		strb	r3, [ip, #1512]
 5105              	.LVL551:
 5106              	.L467:
 5107 2d04 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5108 2d08 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2480:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5109              		.loc 1 2480 0
 5110 2d0c FF00A0E3 		mov	r0, #255
 5111 2d10 50FFFFEA 		b	.L451
 5112              	.LVL552:
 5113              	.L455:
2429:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5114              		.loc 1 2429 0
 5115 2d14 FD35D3E5 		ldrb	r3, [r3, #1533]	@ zero_extendqisi2
 5116 2d18 010053E3 		cmp	r3, #1
 5117 2d1c 04005313 		cmpne	r3, #4
 5118 2d20 2001001A 		bne	.L464
2428:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5119              		.loc 1 2428 0
 5120 2d24 1CC09DE5 		ldr	ip, [sp, #28]
 5121 2d28 20009DE5 		ldr	r0, [sp, #32]
 5122 2d2c 00348CE1 		orr	r3, ip, r0, asl #8
2430:../uvc.c      **** 					  {
 5123              		.loc 1 2430 0
 5124 2d30 F90053E3 		cmp	r3, #249
 5125 2d34 1B01008A 		bhi	.L464
 5126              	.LVL553:
2435:../uvc.c      **** 							}else{
 5127              		.loc 1 2435 0
 5128 2d38 C80043E2 		sub	r0, r3, #200
 5129 2d3c C80053E3 		cmp	r3, #200
2437:../uvc.c      **** 							}
 5130              		.loc 1 2437 0
 5131 2d40 C82063E2 		rsb	r2, r3, #200
 5132 2d44 C0149FE5 		ldr	r1, .L478+28
 5133 2d48 0208A091 		movls	r0, r2, asl #16
 5134 2d4c 0008A081 		movhi	r0, r0, asl #16
 5135 2d50 642063E2 		rsb	r2, r3, #100
 5136 2d54 640053E3 		cmp	r3, #100
2435:../uvc.c      **** 							}else{
 5137              		.loc 1 2435 0
 5138 2d58 64C043E2 		sub	ip, r3, #100
 5139 2d5c 2008A0E1 		mov	r0, r0, lsr #16
 5140 2d60 0C28A081 		movhi	r2, ip, asl #16
 5141 2d64 0228A091 		movls	r2, r2, asl #16
 5142 2d68 010050E1 		cmp	r0, r1
 5143 2d6c 00E0A031 		movcc	lr, r0
 5144 2d70 01E0A021 		movcs	lr, r1
 5145 2d74 010050E1 		cmp	r0, r1
 5146 2d78 27C043E2 		sub	ip, r3, #39
2437:../uvc.c      **** 							}
 5147              		.loc 1 2437 0
 5148 2d7c 271063E2 		rsb	r1, r3, #39
 5149 2d80 00B0A033 		movcc	fp, #0
 5150 2d84 01B0A023 		movcs	fp, #1
 5151 2d88 270053E3 		cmp	r3, #39
2435:../uvc.c      **** 							}else{
 5152              		.loc 1 2435 0
 5153 2d8c 140043E2 		sub	r0, r3, #20
 5154 2d90 01C8A091 		movls	ip, r1, asl #16
 5155 2d94 2228A0E1 		mov	r2, r2, lsr #16
2437:../uvc.c      **** 							}
 5156              		.loc 1 2437 0
 5157 2d98 141063E2 		rsb	r1, r3, #20
 5158 2d9c 0CC8A081 		movhi	ip, ip, asl #16
 5159 2da0 140053E3 		cmp	r3, #20
 5160 2da4 0018A081 		movhi	r1, r0, asl #16
 5161 2da8 0118A091 		movls	r1, r1, asl #16
 5162 2dac 0E0052E1 		cmp	r2, lr
2435:../uvc.c      **** 							}else{
 5163              		.loc 1 2435 0
 5164 2db0 0A0043E2 		sub	r0, r3, #10
 5165 2db4 01B0A033 		movcc	fp, #1
 5166 2db8 2CC8A0E1 		mov	ip, ip, lsr #16
 5167 2dbc 02005EE1 		cmp	lr, r2
 5168 2dc0 0E20A031 		movcc	r2, lr
 5169 2dc4 0A0053E3 		cmp	r3, #10
 5170 2dc8 21E8A0E1 		mov	lr, r1, lsr #16
2437:../uvc.c      **** 							}
 5171              		.loc 1 2437 0
 5172 2dcc 0A1063E2 		rsb	r1, r3, #10
 5173 2dd0 0118A091 		movls	r1, r1, asl #16
 5174 2dd4 0018A081 		movhi	r1, r0, asl #16
 5175 2dd8 0C0052E1 		cmp	r2, ip
 5176 2ddc 02B0A083 		movhi	fp, #2
 5177 2de0 24B08DE5 		str	fp, [sp, #36]
2435:../uvc.c      **** 							}else{
 5178              		.loc 1 2435 0
 5179 2de4 050043E2 		sub	r0, r3, #5
 5180 2de8 02005CE1 		cmp	ip, r2
 5181 2dec 0C20A031 		movcc	r2, ip
 5182 2df0 21B8A0E1 		mov	fp, r1, lsr #16
2437:../uvc.c      **** 							}
 5183              		.loc 1 2437 0
 5184 2df4 05C063E2 		rsb	ip, r3, #5
 5185 2df8 050053E3 		cmp	r3, #5
 5186 2dfc 24109DE5 		ldr	r1, [sp, #36]
 5187 2e00 00C8A081 		movhi	ip, r0, asl #16
 5188 2e04 0CC8A091 		movls	ip, ip, asl #16
 5189 2e08 0E0052E1 		cmp	r2, lr
 5190 2e0c 0310A083 		movhi	r1, #3
 5191 2e10 24108DE5 		str	r1, [sp, #36]
 5192 2e14 02005EE1 		cmp	lr, r2
 5193 2e18 0E00A031 		movcc	r0, lr
 5194 2e1c 0200A021 		movcs	r0, r2
 5195 2e20 021063E2 		rsb	r1, r3, #2
2435:../uvc.c      **** 							}else{
 5196              		.loc 1 2435 0
 5197 2e24 022043E2 		sub	r2, r3, #2
 5198 2e28 020053E3 		cmp	r3, #2
 5199 2e2c 0128A091 		movls	r2, r1, asl #16
 5200 2e30 0228A081 		movhi	r2, r2, asl #16
 5201 2e34 0B0050E1 		cmp	r0, fp
 5202 2e38 24E09DE5 		ldr	lr, [sp, #36]
 5203 2e3c 2CC8A0E1 		mov	ip, ip, lsr #16
 5204 2e40 04E0A083 		movhi	lr, #4
 5205 2e44 00005BE1 		cmp	fp, r0
 5206 2e48 0B00A031 		movcc	r0, fp
 5207 2e4c 00005CE1 		cmp	ip, r0
 5208 2e50 0C10A031 		movcc	r1, ip
 5209 2e54 0010A021 		movcs	r1, r0
 5210 2e58 0C0050E1 		cmp	r0, ip
 5211 2e5c 05E0A083 		movhi	lr, #5
 5212 2e60 01C043E2 		sub	ip, r3, #1
 5213 2e64 010053E3 		cmp	r3, #1
2437:../uvc.c      **** 							}
 5214              		.loc 1 2437 0
 5215 2e68 010063E2 		rsb	r0, r3, #1
 5216 2e6c 0C38A081 		movhi	r3, ip, asl #16
2447:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5217              		.loc 1 2447 0
 5218 2e70 8CC39FE5 		ldr	ip, .L478+20
 5219 2e74 2228A0E1 		mov	r2, r2, lsr #16
 5220 2e78 0038A091 		movls	r3, r0, asl #16
 5221 2e7c 010052E1 		cmp	r2, r1
 5222 2e80 0200A031 		movcc	r0, r2
 5223 2e84 0100A021 		movcs	r0, r1
 5224 2e88 020051E1 		cmp	r1, r2
 5225 2e8c 0E20A091 		movls	r2, lr
 5226 2e90 0620A083 		movhi	r2, #6
 5227              	.LVL554:
 5228 2e94 0010E0E3 		mvn	r1, #0
 5229              	.LVL555:
 5230 2e98 230850E1 		cmp	r0, r3, lsr #16
 5231 2e9c 1C009CE5 		ldr	r0, [ip, #28]
 5232 2ea0 02B0A091 		movls	fp, r2
 5233 2ea4 07B0A083 		movhi	fp, #7
 5234              	.LVL556:
 5235 2ea8 18C08DE5 		str	ip, [sp, #24]
 5236 2eac FEFFFFEB 		bl	_txe_mutex_get
 5237              	.LVL557:
2448:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5238              		.loc 1 2448 0
 5239 2eb0 18C09DE5 		ldr	ip, [sp, #24]
2444:../uvc.c      **** 
 5240              		.loc 1 2444 0
 5241 2eb4 01B08BE2 		add	fp, fp, #1
 5242              	.LVL558:
2448:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5243              		.loc 1 2448 0
 5244 2eb8 0010A0E3 		mov	r1, #0
 5245 2ebc 0A20A0E1 		mov	r2, r10
 5246 2ec0 0930A0E1 		mov	r3, r9
 5247 2ec4 0C00A0E1 		mov	r0, ip
 5248 2ec8 04108DE5 		str	r1, [sp, #4]
 5249 2ecc 00B08DE5 		str	fp, [sp]
 5250 2ed0 0310A0E3 		mov	r1, #3
 5251 2ed4 FEFFFFEB 		bl	cmdSet
 5252              	.LVL559:
2449:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5253              		.loc 1 2449 0
 5254 2ed8 18C09DE5 		ldr	ip, [sp, #24]
 5255 2edc 1C009CE5 		ldr	r0, [ip, #28]
 5256 2ee0 FEFFFFEB 		bl	_txe_mutex_put
 5257              	.LVL560:
2455:../uvc.c      **** 					  }else{
 5258              		.loc 1 2455 0
 5259 2ee4 08C39FE5 		ldr	ip, .L478+4
2452:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5260              		.loc 1 2452 0
 5261 2ee8 04239FE5 		ldr	r2, .L478+4
2455:../uvc.c      **** 					  }else{
 5262              		.loc 1 2455 0
 5263 2eec 79B3CCE5 		strb	fp, [ip, #889]
2452:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5264              		.loc 1 2452 0
 5265 2ef0 1CC09DE5 		ldr	ip, [sp, #28]
 5266 2ef4 063088E0 		add	r3, r8, r6
 5267 2ef8 833182E0 		add	r3, r2, r3, asl #3
 5268 2efc E5C5C3E5 		strb	ip, [r3, #1509]
2453:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5269              		.loc 1 2453 0
 5270 2f00 20C09DE5 		ldr	ip, [sp, #32]
2454:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5271              		.loc 1 2454 0
 5272 2f04 0120A0E3 		mov	r2, #1
2453:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5273              		.loc 1 2453 0
 5274 2f08 E6C5C3E5 		strb	ip, [r3, #1510]
2454:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5275              		.loc 1 2454 0
 5276 2f0c E825C3E5 		strb	r2, [r3, #1512]
2455:../uvc.c      **** 					  }else{
 5277              		.loc 1 2455 0
 5278 2f10 7BFFFFEA 		b	.L467
 5279              	.LVL561:
 5280              	.L453:
2386:../uvc.c      **** 						case 1:
 5281              		.loc 1 2386 0
 5282 2f14 1CC09DE5 		ldr	ip, [sp, #28]
2382:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5283              		.loc 1 2382 0
 5284 2f18 066088E0 		add	r6, r8, r6
 5285 2f1c 866183E0 		add	r6, r3, r6, asl #3
2383:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5286              		.loc 1 2383 0
 5287 2f20 0110A0E3 		mov	r1, #1
2386:../uvc.c      **** 						case 1:
 5288              		.loc 1 2386 0
 5289 2f24 01204CE2 		sub	r2, ip, #1
2382:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5290              		.loc 1 2382 0
 5291 2f28 E5C5C6E5 		strb	ip, [r6, #1509]
2383:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5292              		.loc 1 2383 0
 5293 2f2c E815C6E5 		strb	r1, [r6, #1512]
 5294              	.LVL562:
2386:../uvc.c      **** 						case 1:
 5295              		.loc 1 2386 0
 5296 2f30 070052E3 		cmp	r2, #7
 5297 2f34 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5298 2f38 960000EA 		b	.L458
 5299              	.L460:
 5300 2f3c 34310000 		.word	.L459
 5301 2f40 98300000 		.word	.L461
 5302 2f44 98310000 		.word	.L458
 5303 2f48 30300000 		.word	.L462
 5304 2f4c 98310000 		.word	.L458
 5305 2f50 98310000 		.word	.L458
 5306 2f54 98310000 		.word	.L458
 5307 2f58 902F0000 		.word	.L463
 5308              	.LVL563:
 5309              	.L452:
2501:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5310              		.loc 1 2501 0
 5311 2f5c 1CC09DE5 		ldr	ip, [sp, #28]
 5312 2f60 068088E0 		add	r8, r8, r6
 5313 2f64 888183E0 		add	r8, r3, r8, asl #3
2502:../uvc.c      **** 			  		 break;
 5314              		.loc 1 2502 0
 5315 2f68 0620A0E1 		mov	r2, r6
 5316 2f6c 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5317 2f70 0400A0E3 		mov	r0, #4
 5318 2f74 94129FE5 		ldr	r1, .L478+32
2501:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5319              		.loc 1 2501 0
 5320 2f78 E5C5C8E5 		strb	ip, [r8, #1509]
2502:../uvc.c      **** 			  		 break;
 5321              		.loc 1 2502 0
 5322 2f7c FEFFFFEB 		bl	CyU3PDebugPrint
 5323              	.LVL564:
2503:../uvc.c      **** 			  }
 5324              		.loc 1 2503 0
 5325 2f80 FF00A0E3 		mov	r0, #255
 5326 2f84 0080A0E1 		mov	r8, r0
 5327 2f88 0060A0E1 		mov	r6, r0
 5328 2f8c B1FEFFEA 		b	.L451
 5329              	.LVL565:
 5330              	.L463:
2405:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5331              		.loc 1 2405 0
 5332 2f90 6C629FE5 		ldr	r6, .L478+20
2403:../uvc.c      **** 			  		    	dataIdx = 0;
 5333              		.loc 1 2403 0
 5334 2f94 0080A0E3 		mov	r8, #0
2405:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5335              		.loc 1 2405 0
 5336 2f98 1C0096E5 		ldr	r0, [r6, #28]
 5337 2f9c 0010E0E3 		mvn	r1, #0
2403:../uvc.c      **** 			  		    	dataIdx = 0;
 5338              		.loc 1 2403 0
 5339 2fa0 7983C3E5 		strb	r8, [r3, #889]
 5340              	.LVL566:
2405:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5341              		.loc 1 2405 0
 5342 2fa4 FEFFFFEB 		bl	_txe_mutex_get
 5343              	.LVL567:
2406:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5344              		.loc 1 2406 0
 5345 2fa8 0A20A0E1 		mov	r2, r10
 5346 2fac 0930A0E1 		mov	r3, r9
 5347 2fb0 1010A0E3 		mov	r1, #16
 5348 2fb4 00808DE5 		str	r8, [sp]
 5349 2fb8 04808DE5 		str	r8, [sp, #4]
 5350 2fbc 0600A0E1 		mov	r0, r6
 5351 2fc0 FEFFFFEB 		bl	cmdSet
 5352              	.LVL568:
2407:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5353              		.loc 1 2407 0
 5354 2fc4 1C0096E5 		ldr	r0, [r6, #28]
 5355 2fc8 FEFFFFEB 		bl	_txe_mutex_put
 5356              	.LVL569:
 5357              	.LBB82:
 5358              	.LBB83:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5359              		.loc 1 1278 0
 5360 2fcc 1C0096E5 		ldr	r0, [r6, #28]
 5361 2fd0 0010E0E3 		mvn	r1, #0
 5362 2fd4 FEFFFFEB 		bl	_txe_mutex_get
 5363              	.LVL570:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5364              		.loc 1 1279 0
 5365 2fd8 0130A0E3 		mov	r3, #1
 5366 2fdc 04808DE5 		str	r8, [sp, #4]
 5367 2fe0 0600A0E1 		mov	r0, r6
 5368 2fe4 00308DE5 		str	r3, [sp]
 5369 2fe8 2010A0E3 		mov	r1, #32
 5370 2fec 2720A0E3 		mov	r2, #39
 5371 2ff0 3030A0E3 		mov	r3, #48
 5372 2ff4 FEFFFFEB 		bl	cmdSet
 5373              	.LVL571:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5374              		.loc 1 1280 0
 5375 2ff8 0230A0E3 		mov	r3, #2
 5376 2ffc 04808DE5 		str	r8, [sp, #4]
 5377 3000 0600A0E1 		mov	r0, r6
 5378 3004 00308DE5 		str	r3, [sp]
 5379 3008 2110A0E3 		mov	r1, #33
 5380 300c 2520A0E3 		mov	r2, #37
 5381 3010 3030A0E3 		mov	r3, #48
 5382 3014 FEFFFFEB 		bl	cmdSet
 5383              	.LVL572:
1281:../uvc.c      **** }
 5384              		.loc 1 1281 0
 5385 3018 1C0096E5 		ldr	r0, [r6, #28]
 5386 301c FEFFFFEB 		bl	_txe_mutex_put
 5387              	.LVL573:
 5388 3020 FF00A0E3 		mov	r0, #255
 5389 3024 0080A0E1 		mov	r8, r0
 5390 3028 0860A0E3 		mov	r6, #8
 5391 302c 89FEFFEA 		b	.L451
 5392              	.LVL574:
 5393              	.L462:
 5394              	.LBE83:
 5395              	.LBE82:
 5396              	.LBB84:
 5397              	.LBB85:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5398              		.loc 1 1278 0
 5399 3030 CC619FE5 		ldr	r6, .L478+20
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5400              		.loc 1 1279 0
 5401 3034 0080A0E3 		mov	r8, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5402              		.loc 1 1278 0
 5403 3038 0010E0E3 		mvn	r1, #0
 5404 303c 1C0096E5 		ldr	r0, [r6, #28]
 5405 3040 FEFFFFEB 		bl	_txe_mutex_get
 5406              	.LVL575:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5407              		.loc 1 1279 0
 5408 3044 0600A0E1 		mov	r0, r6
 5409 3048 00808DE5 		str	r8, [sp]
 5410 304c 04808DE5 		str	r8, [sp, #4]
 5411 3050 2010A0E3 		mov	r1, #32
 5412 3054 2720A0E3 		mov	r2, #39
 5413 3058 3030A0E3 		mov	r3, #48
 5414 305c FEFFFFEB 		bl	cmdSet
 5415              	.LVL576:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5416              		.loc 1 1280 0
 5417 3060 0130A0E3 		mov	r3, #1
 5418 3064 04808DE5 		str	r8, [sp, #4]
 5419 3068 0600A0E1 		mov	r0, r6
 5420 306c 00308DE5 		str	r3, [sp]
 5421 3070 2110A0E3 		mov	r1, #33
 5422 3074 2520A0E3 		mov	r2, #37
 5423 3078 3030A0E3 		mov	r3, #48
 5424 307c FEFFFFEB 		bl	cmdSet
 5425              	.LVL577:
1281:../uvc.c      **** }
 5426              		.loc 1 1281 0
 5427 3080 1C0096E5 		ldr	r0, [r6, #28]
 5428 3084 FEFFFFEB 		bl	_txe_mutex_put
 5429              	.LVL578:
 5430 3088 FF00A0E3 		mov	r0, #255
 5431 308c 0080A0E1 		mov	r8, r0
 5432 3090 0460A0E3 		mov	r6, #4
 5433 3094 6FFEFFEA 		b	.L451
 5434              	.LVL579:
 5435              	.L461:
 5436              	.LBE85:
 5437              	.LBE84:
2393:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5438              		.loc 1 2393 0
 5439 3098 64619FE5 		ldr	r6, .L478+20
2391:../uvc.c      **** 							dataIdx = 0;
 5440              		.loc 1 2391 0
 5441 309c 0080A0E3 		mov	r8, #0
2393:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5442              		.loc 1 2393 0
 5443 30a0 1C0096E5 		ldr	r0, [r6, #28]
 5444 30a4 0010E0E3 		mvn	r1, #0
2391:../uvc.c      **** 							dataIdx = 0;
 5445              		.loc 1 2391 0
 5446 30a8 7983C3E5 		strb	r8, [r3, #889]
 5447              	.LVL580:
2393:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5448              		.loc 1 2393 0
 5449 30ac FEFFFFEB 		bl	_txe_mutex_get
 5450              	.LVL581:
2394:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5451              		.loc 1 2394 0
 5452 30b0 0A20A0E1 		mov	r2, r10
 5453 30b4 0930A0E1 		mov	r3, r9
 5454 30b8 1010A0E3 		mov	r1, #16
 5455 30bc 00808DE5 		str	r8, [sp]
 5456 30c0 04808DE5 		str	r8, [sp, #4]
 5457 30c4 0600A0E1 		mov	r0, r6
 5458 30c8 FEFFFFEB 		bl	cmdSet
 5459              	.LVL582:
2395:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5460              		.loc 1 2395 0
 5461 30cc 1C0096E5 		ldr	r0, [r6, #28]
 5462 30d0 FEFFFFEB 		bl	_txe_mutex_put
 5463              	.LVL583:
 5464              	.LBB86:
 5465              	.LBB87:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5466              		.loc 1 1278 0
 5467 30d4 1C0096E5 		ldr	r0, [r6, #28]
 5468 30d8 0010E0E3 		mvn	r1, #0
 5469 30dc FEFFFFEB 		bl	_txe_mutex_get
 5470              	.LVL584:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5471              		.loc 1 1279 0
 5472 30e0 00808DE5 		str	r8, [sp]
 5473 30e4 04808DE5 		str	r8, [sp, #4]
 5474 30e8 0600A0E1 		mov	r0, r6
 5475 30ec 2010A0E3 		mov	r1, #32
 5476 30f0 2720A0E3 		mov	r2, #39
 5477 30f4 3030A0E3 		mov	r3, #48
 5478 30f8 FEFFFFEB 		bl	cmdSet
 5479              	.LVL585:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5480              		.loc 1 1280 0
 5481 30fc 0130A0E3 		mov	r3, #1
 5482 3100 04808DE5 		str	r8, [sp, #4]
 5483 3104 0600A0E1 		mov	r0, r6
 5484 3108 00308DE5 		str	r3, [sp]
 5485 310c 2110A0E3 		mov	r1, #33
 5486 3110 2520A0E3 		mov	r2, #37
 5487 3114 3030A0E3 		mov	r3, #48
 5488 3118 FEFFFFEB 		bl	cmdSet
 5489              	.LVL586:
1281:../uvc.c      **** }
 5490              		.loc 1 1281 0
 5491 311c 1C0096E5 		ldr	r0, [r6, #28]
 5492 3120 FEFFFFEB 		bl	_txe_mutex_put
 5493              	.LVL587:
 5494 3124 FF00A0E3 		mov	r0, #255
 5495 3128 0080A0E1 		mov	r8, r0
 5496 312c 0260A0E3 		mov	r6, #2
 5497 3130 48FEFFEA 		b	.L451
 5498              	.LVL588:
 5499              	.L459:
 5500              	.LBE87:
 5501              	.LBE86:
 5502              	.LBB88:
 5503              	.LBB89:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5504              		.loc 1 1278 0
 5505 3134 C8809FE5 		ldr	r8, .L478+20
 5506 3138 0010E0E3 		mvn	r1, #0
 5507 313c 1C0098E5 		ldr	r0, [r8, #28]
 5508 3140 FEFFFFEB 		bl	_txe_mutex_get
 5509              	.LVL589:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5510              		.loc 1 1279 0
 5511 3144 0090A0E3 		mov	r9, #0
 5512              	.LVL590:
 5513 3148 0160A0E3 		mov	r6, #1
 5514 314c 0800A0E1 		mov	r0, r8
 5515 3150 2010A0E3 		mov	r1, #32
 5516 3154 2720A0E3 		mov	r2, #39
 5517 3158 3030A0E3 		mov	r3, #48
 5518 315c 40028DE8 		stmia	sp, {r6, r9}
 5519 3160 FEFFFFEB 		bl	cmdSet
 5520              	.LVL591:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5521              		.loc 1 1280 0
 5522 3164 0230A0E3 		mov	r3, #2
 5523 3168 0800A0E1 		mov	r0, r8
 5524 316c 00308DE5 		str	r3, [sp]
 5525 3170 2110A0E3 		mov	r1, #33
 5526 3174 2520A0E3 		mov	r2, #37
 5527 3178 3030A0E3 		mov	r3, #48
 5528 317c 04908DE5 		str	r9, [sp, #4]
 5529 3180 FEFFFFEB 		bl	cmdSet
 5530              	.LVL592:
1281:../uvc.c      **** }
 5531              		.loc 1 1281 0
 5532 3184 1C0098E5 		ldr	r0, [r8, #28]
 5533 3188 FEFFFFEB 		bl	_txe_mutex_put
 5534              	.LVL593:
 5535 318c FF00A0E3 		mov	r0, #255
 5536 3190 0080A0E1 		mov	r8, r0
 5537 3194 2FFEFFEA 		b	.L451
 5538              	.LVL594:
 5539              	.L458:
 5540              	.LBE89:
 5541              	.LBE88:
2386:../uvc.c      **** 						case 1:
 5542              		.loc 1 2386 0
 5543 3198 FF00A0E3 		mov	r0, #255
 5544 319c 0C60A0E1 		mov	r6, ip
 5545 31a0 0080A0E1 		mov	r8, r0
 5546 31a4 2BFEFFEA 		b	.L451
 5547              	.LVL595:
 5548              	.L464:
2457:../uvc.c      **** 					  }
 5549              		.loc 1 2457 0
 5550 31a8 0000A0E3 		mov	r0, #0
 5551 31ac 0020A0E1 		mov	r2, r0
 5552 31b0 0110A0E3 		mov	r1, #1
 5553 31b4 FEFFFFEB 		bl	CyU3PUsbStall
 5554              	.LVL596:
 5555 31b8 D1FEFFEA 		b	.L467
 5556              	.LVL597:
 5557              	.L466:
2475:../uvc.c      **** 					  }
 5558              		.loc 1 2475 0
 5559 31bc 0020A0E1 		mov	r2, r0
 5560 31c0 0110A0E3 		mov	r1, #1
 5561 31c4 FEFFFFEB 		bl	CyU3PUsbStall
 5562              	.LVL598:
 5563 31c8 CDFEFFEA 		b	.L467
 5564              	.LVL599:
 5565              	.L477:
2490:../uvc.c      **** 					  else
 5566              		.loc 1 2490 0
 5567 31cc 0800A0E3 		mov	r0, #8
 5568              	.L474:
 5569 31d0 0010A0E3 		mov	r1, #0
 5570 31d4 03008DE8 		stmia	sp, {r0, r1}
 5571 31d8 0A20A0E1 		mov	r2, r10
 5572 31dc 0930A0E1 		mov	r3, r9
 5573 31e0 0600A0E1 		mov	r0, r6
 5574 31e4 2310A0E3 		mov	r1, #35
 5575 31e8 FEFFFFEB 		bl	cmdSet
 5576              	.LVL600:
 5577 31ec 97FEFFEA 		b	.L469
 5578              	.L479:
 5579              		.align	2
 5580              	.L478:
 5581 31f0 00000000 		.word	bRequest
 5582 31f4 00000000 		.word	.LANCHOR1
 5583 31f8 00000000 		.word	.LANCHOR0
 5584 31fc EC060000 		.word	.LC39
 5585 3200 C8060000 		.word	.LC38
 5586 3204 00000000 		.word	cmdQu
 5587 3208 7C060000 		.word	.LC36
 5588 320c FFFF0000 		.word	65535
 5589 3210 A4060000 		.word	.LC37
 5590              		.cfi_endproc
 5591              	.LFE4:
 5593              		.align	2
 5594              		.global	CamDefSet
 5596              	CamDefSet:
 5597              	.LFB5:
2518:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5598              		.loc 1 2518 0
 5599              		.cfi_startproc
 5600              		@ args = 0, pretend = 0, frame = 24
 5601              		@ frame_needed = 0, uses_anonymous_args = 0
 5602              	.LVL601:
 5603 3214 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5604              	.LCFI21:
 5605              		.cfi_def_cfa_offset 36
 5606              		.cfi_offset 4, -36
 5607              		.cfi_offset 5, -32
 5608              		.cfi_offset 6, -28
 5609              		.cfi_offset 7, -24
 5610              		.cfi_offset 8, -20
 5611              		.cfi_offset 9, -16
 5612              		.cfi_offset 10, -12
 5613              		.cfi_offset 11, -8
 5614              		.cfi_offset 14, -4
2525:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5615              		.loc 1 2525 0
 5616 3218 B0429FE5 		ldr	r4, .L483
2530:../uvc.c      ****     if(Data1&0x80){
 5617              		.loc 1 2530 0
 5618 321c B0229FE5 		ldr	r2, .L483+4
2527:../uvc.c      ****     Data1 = Data0;
 5619              		.loc 1 2527 0
 5620 3220 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2518:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5621              		.loc 1 2518 0
 5622 3224 2CD04DE2 		sub	sp, sp, #44
 5623              	.LCFI22:
 5624              		.cfi_def_cfa_offset 80
2530:../uvc.c      ****     if(Data1&0x80){
 5625              		.loc 1 2530 0
 5626 3228 1C0092E5 		ldr	r0, [r2, #28]
 5627 322c 0010E0E3 		mvn	r1, #0
2532:../uvc.c      ****     }else{
 5628              		.loc 1 2532 0
 5629 3230 2563A0E1 		mov	r6, r5, lsr #6
2526:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5630              		.loc 1 2526 0
 5631 3234 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2525:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5632              		.loc 1 2525 0
 5633 3238 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5634              	.LVL602:
2530:../uvc.c      ****     if(Data1&0x80){
 5635              		.loc 1 2530 0
 5636 323c FEFFFFEB 		bl	_txe_mutex_get
 5637              	.LVL603:
2531:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5638              		.loc 1 2531 0
 5639 3240 800015E3 		tst	r5, #128
2532:../uvc.c      ****     }else{
 5640              		.loc 1 2532 0
 5641 3244 01600612 		andne	r6, r6, #1
 5642 3248 0660E011 		mvnne	r6, r6
 5643 324c 3B600612 		andne	r6, r6, #59
 5644 3250 0660E011 		mvnne	r6, r6
 5645 3254 FF600612 		andne	r6, r6, #255
 5646              	.LVL604:
2534:../uvc.c      ****     }
 5647              		.loc 1 2534 0
 5648 3258 C6608603 		orreq	r6, r6, #198
 5649              	.LVL605:
2538:../uvc.c      **** 
 5650              		.loc 1 2538 0
 5651 325c 0080A0E3 		mov	r8, #0
2536:../uvc.c      **** 
 5652              		.loc 1 2536 0
 5653 3260 0551A0E1 		mov	r5, r5, asl #2
 5654              	.LVL606:
 5655 3264 FF5005E2 		and	r5, r5, #255
 5656              	.LVL607:
2541:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5657              		.loc 1 2541 0
 5658 3268 01A0A0E3 		mov	r10, #1
2538:../uvc.c      **** 
 5659              		.loc 1 2538 0
 5660 326c 00608DE5 		str	r6, [sp]
 5661 3270 0920A0E1 		mov	r2, r9
 5662 3274 0730A0E1 		mov	r3, r7
 5663 3278 04808DE5 		str	r8, [sp, #4]
 5664 327c 0110A0E3 		mov	r1, #1
 5665 3280 4C029FE5 		ldr	r0, .L483+4
 5666 3284 FEFFFFEB 		bl	cmdSet
 5667              	.LVL608:
2541:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5668              		.loc 1 2541 0
 5669 3288 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5670 328c 0730A0E1 		mov	r3, r7
 5671 3290 0A10A0E1 		mov	r1, r10
 5672 3294 00508DE5 		str	r5, [sp]
 5673 3298 04A08DE5 		str	r10, [sp, #4]
 5674 329c 30029FE5 		ldr	r0, .L483+4
 5675 32a0 FEFFFFEB 		bl	cmdSet
 5676              	.LVL609:
2544:../uvc.c      **** 
 5677              		.loc 1 2544 0
 5678 32a4 0620A0E1 		mov	r2, r6
 5679 32a8 0530A0E1 		mov	r3, r5
 5680 32ac 24129FE5 		ldr	r1, .L483+8
 5681 32b0 0400A0E3 		mov	r0, #4
2543:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5682              		.loc 1 2543 0
 5683 32b4 1262C4E5 		strb	r6, [r4, #530]
2542:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5684              		.loc 1 2542 0
 5685 32b8 1152C4E5 		strb	r5, [r4, #529]
2544:../uvc.c      **** 
 5686              		.loc 1 2544 0
 5687 32bc FEFFFFEB 		bl	CyU3PDebugPrint
 5688              	.LVL610:
2549:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5689              		.loc 1 2549 0
 5690 32c0 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5691              	.LVL611:
2550:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5692              		.loc 1 2550 0
 5693 32c4 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5694 32c8 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5695 32cc 40018DE8 		stmia	sp, {r6, r8}
 5696 32d0 FC019FE5 		ldr	r0, .L483+4
 5697 32d4 0210A0E3 		mov	r1, #2
 5698 32d8 FEFFFFEB 		bl	cmdSet
 5699              	.LVL612:
2553:../uvc.c      **** 
 5700              		.loc 1 2553 0
 5701 32dc 0620A0E1 		mov	r2, r6
 5702 32e0 0530A0E1 		mov	r3, r5
 5703 32e4 EC119FE5 		ldr	r1, .L483+8
 5704 32e8 0400A0E3 		mov	r0, #4
2551:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5705              		.loc 1 2551 0
 5706 32ec 2952C4E5 		strb	r5, [r4, #553]
2552:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5707              		.loc 1 2552 0
 5708 32f0 6954C4E5 		strb	r5, [r4, #1129]
2553:../uvc.c      **** 
 5709              		.loc 1 2553 0
 5710 32f4 FEFFFFEB 		bl	CyU3PDebugPrint
 5711              	.LVL613:
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5712              		.loc 1 2558 0
 5713 32f8 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2557:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5714              		.loc 1 2557 0
 5715 32fc 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5716              	.LVL614:
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5717              		.loc 1 2559 0
 5718 3300 80C047E2 		sub	ip, r7, #128
 5719 3304 FF300CE2 		and	r3, ip, #255
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5720              		.loc 1 2560 0
 5721 3308 76E047E2 		sub	lr, r7, #118
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5722              		.loc 1 2559 0
 5723 330c 18308DE5 		str	r3, [sp, #24]
 5724 3310 08018DE8 		stmia	sp, {r3, r8}
 5725 3314 B8019FE5 		ldr	r0, .L483+4
 5726 3318 0630A0E1 		mov	r3, r6
 5727 331c 0510A0E3 		mov	r1, #5
 5728 3320 DF20A0E3 		mov	r2, #223
 5729 3324 14C08DE5 		str	ip, [sp, #20]
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5730              		.loc 1 2560 0
 5731 3328 1CE08DE5 		str	lr, [sp, #28]
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5732              		.loc 1 2559 0
 5733 332c FEFFFFEB 		bl	cmdSet
 5734              	.LVL615:
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5735              		.loc 1 2560 0
 5736 3330 1C209DE5 		ldr	r2, [sp, #28]
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5737              		.loc 1 2561 0
 5738 3334 7EE087E2 		add	lr, r7, #126
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5739              		.loc 1 2560 0
 5740 3338 FF3002E2 		and	r3, r2, #255
 5741 333c 08048DE8 		stmia	sp, {r3, r10}
 5742 3340 8C019FE5 		ldr	r0, .L483+4
 5743 3344 0630A0E1 		mov	r3, r6
 5744 3348 0510A0E3 		mov	r1, #5
 5745 334c DC20A0E3 		mov	r2, #220
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5746              		.loc 1 2561 0
 5747 3350 20E08DE5 		str	lr, [sp, #32]
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5748              		.loc 1 2560 0
 5749 3354 FEFFFFEB 		bl	cmdSet
 5750              	.LVL616:
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5751              		.loc 1 2561 0
 5752 3358 20209DE5 		ldr	r2, [sp, #32]
2562:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5753              		.loc 1 2562 0
 5754 335c 72E087E2 		add	lr, r7, #114
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5755              		.loc 1 2561 0
 5756 3360 FF3002E2 		and	r3, r2, #255
 5757 3364 0220A0E3 		mov	r2, #2
 5758 3368 00308DE5 		str	r3, [sp]
 5759 336c 04208DE5 		str	r2, [sp, #4]
 5760 3370 0630A0E1 		mov	r3, r6
 5761 3374 0510A0E3 		mov	r1, #5
 5762 3378 DE20A0E3 		mov	r2, #222
 5763 337c 50019FE5 		ldr	r0, .L483+4
2562:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5764              		.loc 1 2562 0
 5765 3380 24E08DE5 		str	lr, [sp, #36]
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5766              		.loc 1 2561 0
 5767 3384 FEFFFFEB 		bl	cmdSet
 5768              	.LVL617:
2562:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5769              		.loc 1 2562 0
 5770 3388 24209DE5 		ldr	r2, [sp, #36]
2563:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5771              		.loc 1 2563 0
 5772 338c 6FB047E2 		sub	fp, r7, #111
2562:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5773              		.loc 1 2562 0
 5774 3390 FF3002E2 		and	r3, r2, #255
 5775 3394 0320A0E3 		mov	r2, #3
 5776 3398 00308DE5 		str	r3, [sp]
 5777 339c 04208DE5 		str	r2, [sp, #4]
 5778 33a0 0630A0E1 		mov	r3, r6
 5779 33a4 0510A0E3 		mov	r1, #5
 5780 33a8 E020A0E3 		mov	r2, #224
 5781 33ac 20019FE5 		ldr	r0, .L483+4
 5782 33b0 FEFFFFEB 		bl	cmdSet
 5783              	.LVL618:
2563:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5784              		.loc 1 2563 0
 5785 33b4 0490A0E3 		mov	r9, #4
 5786 33b8 FF300BE2 		and	r3, fp, #255
2564:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5787              		.loc 1 2564 0
 5788 33bc 7F7087E2 		add	r7, r7, #127
 5789              	.LVL619:
2563:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5790              		.loc 1 2563 0
 5791 33c0 00308DE5 		str	r3, [sp]
 5792 33c4 04908DE5 		str	r9, [sp, #4]
 5793 33c8 0630A0E1 		mov	r3, r6
 5794 33cc 0510A0E3 		mov	r1, #5
 5795 33d0 DD20A0E3 		mov	r2, #221
 5796 33d4 F8009FE5 		ldr	r0, .L483+4
 5797 33d8 FEFFFFEB 		bl	cmdSet
 5798              	.LVL620:
2564:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5799              		.loc 1 2564 0
 5800 33dc FF2007E2 		and	r2, r7, #255
 5801 33e0 0510A0E3 		mov	r1, #5
 5802 33e4 0630A0E1 		mov	r3, r6
 5803 33e8 00208DE5 		str	r2, [sp]
 5804 33ec 04108DE5 		str	r1, [sp, #4]
 5805 33f0 E120A0E3 		mov	r2, #225
 5806 33f4 D8009FE5 		ldr	r0, .L483+4
 5807 33f8 FEFFFFEB 		bl	cmdSet
 5808              	.LVL621:
2566:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5809              		.loc 1 2566 0
 5810 33fc 14C09DE5 		ldr	ip, [sp, #20]
 5811 3400 24E09DE5 		ldr	lr, [sp, #36]
 5812 3404 20309DE5 		ldr	r3, [sp, #32]
 5813 3408 0C20A0E1 		mov	r2, ip
2565:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5814              		.loc 1 2565 0
 5815 340c 18C09DE5 		ldr	ip, [sp, #24]
2566:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5816              		.loc 1 2566 0
 5817 3410 04E08DE5 		str	lr, [sp, #4]
 5818 3414 00308DE5 		str	r3, [sp]
 5819 3418 0C708DE5 		str	r7, [sp, #12]
 5820 341c 1C309DE5 		ldr	r3, [sp, #28]
 5821 3420 08B08DE5 		str	fp, [sp, #8]
 5822 3424 0900A0E1 		mov	r0, r9
 5823 3428 AC109FE5 		ldr	r1, .L483+12
2565:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5824              		.loc 1 2565 0
 5825 342c 71C2C4E5 		strb	ip, [r4, #625]
2566:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5826              		.loc 1 2566 0
 5827 3430 FEFFFFEB 		bl	CyU3PDebugPrint
 5828              	.LVL622:
2571:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5829              		.loc 1 2571 0
 5830 3434 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5831              	.LVL623:
2570:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5832              		.loc 1 2570 0
 5833 3438 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5834              	.LVL624:
2572:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5835              		.loc 1 2572 0
 5836 343c 00608DE5 		str	r6, [sp]
 5837 3440 0730A0E1 		mov	r3, r7
 5838 3444 04808DE5 		str	r8, [sp, #4]
 5839 3448 0610A0E3 		mov	r1, #6
 5840 344c 8520A0E3 		mov	r2, #133
 5841 3450 7C009FE5 		ldr	r0, .L483+4
 5842 3454 FEFFFFEB 		bl	cmdSet
 5843              	.LVL625:
2573:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5844              		.loc 1 2573 0
 5845 3458 40048DE8 		stmia	sp, {r6, r10}
 5846 345c 70009FE5 		ldr	r0, .L483+4
 5847 3460 0730A0E1 		mov	r3, r7
 5848 3464 0610A0E3 		mov	r1, #6
 5849 3468 8620A0E3 		mov	r2, #134
 5850 346c FEFFFFEB 		bl	cmdSet
 5851              	.LVL626:
2575:../uvc.c      **** 
 5852              		.loc 1 2575 0
 5853 3470 0620A0E1 		mov	r2, r6
 5854 3474 0530A0E1 		mov	r3, r5
 5855 3478 0900A0E1 		mov	r0, r9
 5856 347c 54109FE5 		ldr	r1, .L483+8
2574:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5857              		.loc 1 2574 0
 5858 3480 8962C4E5 		strb	r6, [r4, #649]
2575:../uvc.c      **** 
 5859              		.loc 1 2575 0
 5860 3484 FEFFFFEB 		bl	CyU3PDebugPrint
 5861              	.LVL627:
2580:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5862              		.loc 1 2580 0
 5863 3488 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5864              	.LVL628:
2581:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5865              		.loc 1 2581 0
 5866 348c 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5867 3490 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5868 3494 40018DE8 		stmia	sp, {r6, r8}
 5869 3498 34009FE5 		ldr	r0, .L483+4
 5870 349c 0710A0E3 		mov	r1, #7
 5871 34a0 FEFFFFEB 		bl	cmdSet
 5872              	.LVL629:
2583:../uvc.c      **** 
 5873              		.loc 1 2583 0
 5874 34a4 0620A0E1 		mov	r2, r6
 5875 34a8 0530A0E1 		mov	r3, r5
 5876 34ac 0900A0E1 		mov	r0, r9
 5877 34b0 20109FE5 		ldr	r1, .L483+8
2582:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5878              		.loc 1 2582 0
 5879 34b4 A152C4E5 		strb	r5, [r4, #673]
2583:../uvc.c      **** 
 5880              		.loc 1 2583 0
 5881 34b8 FEFFFFEB 		bl	CyU3PDebugPrint
 5882              	.LVL630:
2585:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5883              		.loc 1 2585 0
 5884 34bc 10209FE5 		ldr	r2, .L483+4
 5885 34c0 1C0092E5 		ldr	r0, [r2, #28]
2588:../uvc.c      **** 
 5886              		.loc 1 2588 0
 5887 34c4 2CD08DE2 		add	sp, sp, #44
 5888              		@ sp needed
 5889 34c8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5890              	.LVL631:
2585:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5891              		.loc 1 2585 0
 5892 34cc FEFFFFEA 		b	_txe_mutex_put
 5893              	.LVL632:
 5894              	.L484:
 5895              		.align	2
 5896              	.L483:
 5897 34d0 00000000 		.word	.LANCHOR1
 5898 34d4 00000000 		.word	statQu
 5899 34d8 50070000 		.word	.LC40
 5900 34dc 70070000 		.word	.LC41
 5901              		.cfi_endproc
 5902              	.LFE5:
 5904              		.align	2
 5905              		.global	CyFxUVCAddHeader
 5907              	CyFxUVCAddHeader:
 5908              	.LFB6:
2596:../uvc.c      ****     /* Copy header to buffer */
 5909              		.loc 1 2596 0
 5910              		.cfi_startproc
 5911              		@ args = 0, pretend = 0, frame = 0
 5912              		@ frame_needed = 0, uses_anonymous_args = 0
 5913              	.LVL633:
 5914 34e0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5915              	.LCFI23:
 5916              		.cfi_def_cfa_offset 16
 5917              		.cfi_offset 3, -16
 5918              		.cfi_offset 4, -12
 5919              		.cfi_offset 5, -8
 5920              		.cfi_offset 14, -4
2596:../uvc.c      ****     /* Copy header to buffer */
 5921              		.loc 1 2596 0
 5922 34e4 0040A0E1 		mov	r4, r0
 5923 34e8 0150A0E1 		mov	r5, r1
2598:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5924              		.loc 1 2598 0
 5925 34ec 30009FE5 		ldr	r0, .L490
 5926              	.LVL634:
 5927 34f0 0010E0E3 		mvn	r1, #0
 5928              	.LVL635:
 5929 34f4 FEFFFFEB 		bl	_txe_mutex_get
 5930              	.LVL636:
2599:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5931              		.loc 1 2599 0
 5932 34f8 0400A0E1 		mov	r0, r4
 5933 34fc 24109FE5 		ldr	r1, .L490+4
 5934 3500 0C20A0E3 		mov	r2, #12
 5935 3504 FEFFFFEB 		bl	CyU3PMemCopy
 5936              	.LVL637:
2600:../uvc.c      **** 
 5937              		.loc 1 2600 0
 5938 3508 14009FE5 		ldr	r0, .L490
 5939 350c FEFFFFEB 		bl	_txe_mutex_put
 5940              	.LVL638:
2603:../uvc.c      ****     {
 5941              		.loc 1 2603 0
 5942 3510 020015E3 		tst	r5, #2
2605:../uvc.c      ****     }
 5943              		.loc 1 2605 0
 5944 3514 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5945 3518 02308313 		orrne	r3, r3, #2
 5946 351c 0130C415 		strneb	r3, [r4, #1]
 5947 3520 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5948              	.L491:
 5949              		.align	2
 5950              	.L490:
 5951 3524 00000000 		.word	imgHdMux
 5952 3528 EC040000 		.word	.LANCHOR1+1260
 5953              		.cfi_endproc
 5954              	.LFE6:
 5956              		.align	2
 5957              		.global	CyFxAppErrorHandler
 5959              	CyFxAppErrorHandler:
 5960              	.LFB7:
2615:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 5961              		.loc 1 2615 0
 5962              		.cfi_startproc
 5963              		@ Volatile: function does not return.
 5964              		@ args = 0, pretend = 0, frame = 0
 5965              		@ frame_needed = 0, uses_anonymous_args = 0
 5966              	.LVL639:
 5967 352c 08402DE9 		stmfd	sp!, {r3, lr}
 5968              	.LCFI24:
 5969              		.cfi_def_cfa_offset 8
 5970              		.cfi_offset 3, -8
 5971              		.cfi_offset 14, -4
 5972              	.LVL640:
 5973              	.L493:
2625:../uvc.c      ****         CyU3PThreadSleep (1000);
 5974              		.loc 1 2625 0 discriminator 1
 5975 3530 10109FE5 		ldr	r1, .L494
 5976 3534 0400A0E3 		mov	r0, #4
 5977 3538 FEFFFFEB 		bl	CyU3PDebugPrint
 5978              	.LVL641:
2626:../uvc.c      ****     }
 5979              		.loc 1 2626 0 discriminator 1
 5980 353c FA0FA0E3 		mov	r0, #1000
 5981 3540 FEFFFFEB 		bl	_tx_thread_sleep
 5982              	.LVL642:
 5983 3544 F9FFFFEA 		b	.L493
 5984              	.L495:
 5985              		.align	2
 5986              	.L494:
 5987 3548 A8070000 		.word	.LC42
 5988              		.cfi_endproc
 5989              	.LFE7:
 5991              		.align	2
 5992              		.global	UVCAppThread_Entry
 5994              	UVCAppThread_Entry:
 5995              	.LFB19:
3602:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 5996              		.loc 1 3602 0
 5997              		.cfi_startproc
 5998              		@ args = 0, pretend = 0, frame = 128
 5999              		@ frame_needed = 0, uses_anonymous_args = 0
 6000              	.LVL643:
 6001 354c F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6002              	.LCFI25:
 6003              		.cfi_def_cfa_offset 32
 6004              		.cfi_offset 4, -32
 6005              		.cfi_offset 5, -28
 6006              		.cfi_offset 6, -24
 6007              		.cfi_offset 7, -20
 6008              		.cfi_offset 8, -16
 6009              		.cfi_offset 9, -12
 6010              		.cfi_offset 10, -8
 6011              		.cfi_offset 14, -4
 6012 3550 88D04DE2 		sub	sp, sp, #136
 6013              	.LCFI26:
 6014              		.cfi_def_cfa_offset 168
 6015              	.LBB98:
 6016              	.LBB99:
3058:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6017              		.loc 1 3058 0
 6018 3554 FEFFFFEB 		bl	CyU3PUartInit
 6019              	.LVL644:
3059:../uvc.c      ****     {
 6020              		.loc 1 3059 0
 6021 3558 004050E2 		subs	r4, r0, #0
 6022 355c 2902001A 		bne	.L577
3066:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6023              		.loc 1 3066 0
 6024 3560 582A9FE5 		ldr	r2, .L608
3067:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6025              		.loc 1 3067 0
 6026 3564 0130A0E3 		mov	r3, #1
3075:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6027              		.loc 1 3075 0
 6028 3568 0410A0E1 		mov	r1, r4
 6029 356c 60008DE2 		add	r0, sp, #96
 6030              	.LVL645:
3068:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6031              		.loc 1 3068 0
 6032 3570 7540CDE5 		strb	r4, [sp, #117]
3070:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6033              		.loc 1 3070 0
 6034 3574 64408DE5 		str	r4, [sp, #100]
3071:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6035              		.loc 1 3071 0
 6036 3578 68408DE5 		str	r4, [sp, #104]
3066:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6037              		.loc 1 3066 0
 6038 357c 70208DE5 		str	r2, [sp, #112]
3067:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6039              		.loc 1 3067 0
 6040 3580 7430CDE5 		strb	r3, [sp, #116]
3069:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6041              		.loc 1 3069 0
 6042 3584 60308DE5 		str	r3, [sp, #96]
3072:../uvc.c      **** 
 6043              		.loc 1 3072 0
 6044 3588 6C308DE5 		str	r3, [sp, #108]
3075:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6045              		.loc 1 3075 0
 6046 358c FEFFFFEB 		bl	CyU3PUartSetConfig
 6047              	.LVL646:
3076:../uvc.c      ****     {
 6048              		.loc 1 3076 0
 6049 3590 000050E3 		cmp	r0, #0
 6050 3594 B201001A 		bne	.L576
3082:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6051              		.loc 1 3082 0
 6052 3598 0000E0E3 		mvn	r0, #0
 6053              	.LVL647:
 6054 359c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6055              	.LVL648:
3083:../uvc.c      ****     {
 6056              		.loc 1 3083 0
 6057 35a0 000050E3 		cmp	r0, #0
 6058 35a4 AE01001A 		bne	.L576
3089:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6059              		.loc 1 3089 0
 6060 35a8 0300A0E3 		mov	r0, #3
 6061              	.LVL649:
 6062 35ac 0410A0E3 		mov	r1, #4
 6063 35b0 FEFFFFEB 		bl	CyU3PDebugInit
 6064              	.LVL650:
3090:../uvc.c      ****     {
 6065              		.loc 1 3090 0
 6066 35b4 000050E3 		cmp	r0, #0
 6067 35b8 A901001A 		bne	.L576
3096:../uvc.c      **** }
 6068              		.loc 1 3096 0
 6069 35bc FEFFFFEB 		bl	CyU3PDebugPreamble
 6070              	.LVL651:
 6071 35c0 0640A0E3 		mov	r4, #6
 6072              	.LVL652:
 6073              	.L502:
 6074              	.LBE99:
 6075              	.LBE98:
3618:../uvc.c      **** 	}
 6076              		.loc 1 3618 0
 6077 35c4 7D0FA0E3 		mov	r0, #500
 6078 35c8 014044E2 		sub	r4, r4, #1
 6079 35cc FEFFFFEB 		bl	_tx_thread_sleep
 6080              	.LVL653:
3617:../uvc.c      **** 		CyU3PThreadSleep(500);
 6081              		.loc 1 3617 0
 6082 35d0 FF4014E2 		ands	r4, r4, #255
 6083 35d4 FAFFFF1A 		bne	.L502
 6084              	.LBB101:
 6085              	.LBB102:
3106:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6086              		.loc 1 3106 0
 6087 35d8 FEFFFFEB 		bl	CyU3PI2cInit
 6088              	.LVL654:
3107:../uvc.c      ****     {
 6089              		.loc 1 3107 0
 6090 35dc 005050E2 		subs	r5, r0, #0
 6091 35e0 3002001A 		bne	.L578
3114:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6092              		.loc 1 3114 0
 6093 35e4 D8299FE5 		ldr	r2, .L608+4
3116:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6094              		.loc 1 3116 0
 6095 35e8 0030E0E3 		mvn	r3, #0
3119:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6096              		.loc 1 3119 0
 6097 35ec 60008DE2 		add	r0, sp, #96
 6098              	.LVL655:
 6099 35f0 0410A0E1 		mov	r1, r4
3115:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6100              		.loc 1 3115 0
 6101 35f4 64408DE5 		str	r4, [sp, #100]
3114:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6102              		.loc 1 3114 0
 6103 35f8 60208DE5 		str	r2, [sp, #96]
3116:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6104              		.loc 1 3116 0
 6105 35fc 68308DE5 		str	r3, [sp, #104]
3117:../uvc.c      **** 
 6106              		.loc 1 3117 0
 6107 3600 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3119:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6108              		.loc 1 3119 0
 6109 3604 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6110              	.LVL656:
3120:../uvc.c      ****     {
 6111              		.loc 1 3120 0
 6112 3608 005050E2 		subs	r5, r0, #0
 6113 360c 2002001A 		bne	.L579
 6114              	.LBE102:
 6115              	.LBE101:
 6116              	.LBB104:
 6117              	.LBB105:
3193:../uvc.c      ****     if (apiRetStatus != 0)
 6118              		.loc 1 3193 0
 6119 3610 B0799FE5 		ldr	r7, .L608+8
 6120 3614 0410A0E1 		mov	r1, r4
 6121 3618 0700A0E1 		mov	r0, r7
 6122              	.LVL657:
 6123 361c 2820A0E3 		mov	r2, #40
 6124 3620 FEFFFFEB 		bl	_txe_event_flags_create
 6125              	.LVL658:
3194:../uvc.c      ****     {
 6126              		.loc 1 3194 0
 6127 3624 005050E2 		subs	r5, r0, #0
 6128              	.LVL659:
 6129 3628 1302001A 		bne	.L580
3208:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6130              		.loc 1 3208 0
 6131 362c 0230A0E3 		mov	r3, #2
3211:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6132              		.loc 1 3211 0
 6133 3630 0320A0E3 		mov	r2, #3
3215:../uvc.c      ****     if (apiRetStatus != 0)
 6134              		.loc 1 3215 0
 6135 3634 14008DE2 		add	r0, sp, #20
 6136              	.LVL660:
 6137 3638 0410A0E1 		mov	r1, r4
3204:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6138              		.loc 1 3204 0
 6139 363c 8C4087E5 		str	r4, [r7, #140]
3205:../uvc.c      **** 
 6140              		.loc 1 3205 0
 6141 3640 904087E5 		str	r4, [r7, #144]
3210:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6142              		.loc 1 3210 0
 6143 3644 1C40CDE5 		strb	r4, [sp, #28]
3212:../uvc.c      **** 
 6144              		.loc 1 3212 0
 6145 3648 18408DE5 		str	r4, [sp, #24]
3208:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6146              		.loc 1 3208 0
 6147 364c 1430CDE5 		strb	r3, [sp, #20]
3209:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6148              		.loc 1 3209 0
 6149 3650 1530CDE5 		strb	r3, [sp, #21]
3211:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6150              		.loc 1 3211 0
 6151 3654 1D20CDE5 		strb	r2, [sp, #29]
3215:../uvc.c      ****     if (apiRetStatus != 0)
 6152              		.loc 1 3215 0
 6153 3658 FEFFFFEB 		bl	CyU3PGpioInit
 6154              	.LVL661:
3216:../uvc.c      ****     {
 6155              		.loc 1 3216 0
 6156 365c 005050E2 		subs	r5, r0, #0
 6157 3660 FF01001A 		bne	.L581
3224:../uvc.c      ****     if (apiRetStatus != 0)
 6158              		.loc 1 3224 0
 6159 3664 1600A0E3 		mov	r0, #22
 6160              	.LVL662:
 6161 3668 0110A0E3 		mov	r1, #1
 6162 366c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6163              	.LVL663:
3225:../uvc.c      ****     {
 6164              		.loc 1 3225 0
 6165 3670 005050E2 		subs	r5, r0, #0
 6166 3674 3A02001A 		bne	.L582
3230:../uvc.c      ****     if (apiRetStatus != 0)
 6167              		.loc 1 3230 0
 6168 3678 1400A0E3 		mov	r0, #20
 6169              	.LVL664:
 6170 367c 0110A0E3 		mov	r1, #1
 6171 3680 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6172              	.LVL665:
3231:../uvc.c      ****     {
 6173              		.loc 1 3231 0
 6174 3684 005050E2 		subs	r5, r0, #0
 6175 3688 2F02001A 		bne	.L583
3236:../uvc.c      ****     if (apiRetStatus != 0)
 6176              		.loc 1 3236 0
 6177 368c 1800A0E3 		mov	r0, #24
 6178              	.LVL666:
 6179 3690 0110A0E3 		mov	r1, #1
 6180 3694 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6181              	.LVL667:
3237:../uvc.c      ****     {
 6182              		.loc 1 3237 0
 6183 3698 005050E2 		subs	r5, r0, #0
 6184 369c 2402001A 		bne	.L584
3244:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6185              		.loc 1 3244 0
 6186 36a0 0150A0E3 		mov	r5, #1
3249:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6187              		.loc 1 3249 0
 6188 36a4 30108DE2 		add	r1, sp, #48
 6189 36a8 1600A0E3 		mov	r0, #22
 6190              	.LVL668:
3247:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6191              		.loc 1 3247 0
 6192 36ac 3C408DE5 		str	r4, [sp, #60]
3248:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6193              		.loc 1 3248 0
 6194 36b0 4040CDE5 		strb	r4, [sp, #64]
3244:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6195              		.loc 1 3244 0
 6196 36b4 30508DE5 		str	r5, [sp, #48]
3245:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6197              		.loc 1 3245 0
 6198 36b8 34508DE5 		str	r5, [sp, #52]
3246:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6199              		.loc 1 3246 0
 6200 36bc 38508DE5 		str	r5, [sp, #56]
3249:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6201              		.loc 1 3249 0
 6202 36c0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6203              	.LVL669:
3250:../uvc.c      ****     {
 6204              		.loc 1 3250 0
 6205 36c4 006050E2 		subs	r6, r0, #0
 6206 36c8 1302001A 		bne	.L585
3263:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6207              		.loc 1 3263 0
 6208 36cc 1400A0E3 		mov	r0, #20
 6209              	.LVL670:
 6210 36d0 30108DE2 		add	r1, sp, #48
3261:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6211              		.loc 1 3261 0
 6212 36d4 3C408DE5 		str	r4, [sp, #60]
3262:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6213              		.loc 1 3262 0
 6214 36d8 4040CDE5 		strb	r4, [sp, #64]
3258:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6215              		.loc 1 3258 0
 6216 36dc 30508DE5 		str	r5, [sp, #48]
3259:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6217              		.loc 1 3259 0
 6218 36e0 34508DE5 		str	r5, [sp, #52]
3260:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6219              		.loc 1 3260 0
 6220 36e4 38508DE5 		str	r5, [sp, #56]
3263:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6221              		.loc 1 3263 0
 6222 36e8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6223              	.LVL671:
3264:../uvc.c      ****     {
 6224              		.loc 1 3264 0
 6225 36ec 004050E2 		subs	r4, r0, #0
 6226 36f0 0302001A 		bne	.L586
3272:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6227              		.loc 1 3272 0
 6228 36f4 0030A0E3 		mov	r3, #0
3277:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6229              		.loc 1 3277 0
 6230 36f8 30108DE2 		add	r1, sp, #48
3275:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6231              		.loc 1 3275 0
 6232 36fc 0150A0E3 		mov	r5, #1
3277:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6233              		.loc 1 3277 0
 6234 3700 1800A0E3 		mov	r0, #24
 6235              	.LVL672:
3272:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6236              		.loc 1 3272 0
 6237 3704 30308DE5 		str	r3, [sp, #48]
3273:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6238              		.loc 1 3273 0
 6239 3708 34308DE5 		str	r3, [sp, #52]
3274:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6240              		.loc 1 3274 0
 6241 370c 38308DE5 		str	r3, [sp, #56]
3276:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6242              		.loc 1 3276 0
 6243 3710 4030CDE5 		strb	r3, [sp, #64]
3275:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6244              		.loc 1 3275 0
 6245 3714 3C508DE5 		str	r5, [sp, #60]
3277:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6246              		.loc 1 3277 0
 6247 3718 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6248              	.LVL673:
3278:../uvc.c      ****     {
 6249              		.loc 1 3278 0
 6250 371c 004050E2 		subs	r4, r0, #0
 6251 3720 F101001A 		bne	.L587
3285:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6252              		.loc 1 3285 0
 6253 3724 0260A0E3 		mov	r6, #2
3286:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6254              		.loc 1 3286 0
 6255 3728 0380A0E3 		mov	r8, #3
3290:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6256              		.loc 1 3290 0
 6257 372c 0500A0E1 		mov	r0, r5
 6258              	.LVL674:
 6259 3730 20108DE2 		add	r1, sp, #32
3287:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6260              		.loc 1 3287 0
 6261 3734 28408DE5 		str	r4, [sp, #40]
3288:../uvc.c      **** 
 6262              		.loc 1 3288 0
 6263 3738 24408DE5 		str	r4, [sp, #36]
3285:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6264              		.loc 1 3285 0
 6265 373c B062CDE1 		strh	r6, [sp, #32]	@ movhi
3286:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6266              		.loc 1 3286 0
 6267 3740 2C80CDE5 		strb	r8, [sp, #44]
3290:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6268              		.loc 1 3290 0
 6269 3744 FEFFFFEB 		bl	CyU3PPibInit
 6270              	.LVL675:
3291:../uvc.c      ****     {
 6271              		.loc 1 3291 0
 6272 3748 004050E2 		subs	r4, r0, #0
 6273 374c E001001A 		bne	.L588
3298:../uvc.c      **** 
 6274              		.loc 1 3298 0
 6275 3750 74089FE5 		ldr	r0, .L608+12
 6276              	.LVL676:
 6277 3754 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6278              	.LVL677:
3306:../uvc.c      ****     CyU3PThreadSleep(5000);
 6279              		.loc 1 3306 0
 6280 3758 FEFFFFEB 		bl	SensorReset
 6281              	.LVL678:
3307:../uvc.c      ****     //SensorInit ();
 6282              		.loc 1 3307 0
 6283 375c 6C089FE5 		ldr	r0, .L608+16
 6284 3760 FEFFFFEB 		bl	_tx_thread_sleep
 6285              	.LVL679:
3311:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6286              		.loc 1 3311 0
 6287 3764 FEFFFFEB 		bl	CyU3PUsbStart
 6288              	.LVL680:
3312:../uvc.c      ****     {
 6289              		.loc 1 3312 0
 6290 3768 004050E2 		subs	r4, r0, #0
 6291 376c D201001A 		bne	.L589
3318:../uvc.c      **** 
 6292              		.loc 1 3318 0
 6293 3770 0410A0E1 		mov	r1, r4
 6294 3774 58089FE5 		ldr	r0, .L608+20
 6295              	.LVL681:
 6296 3778 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6297              	.LVL682:
3321:../uvc.c      **** 
 6298              		.loc 1 3321 0
 6299 377c 54089FE5 		ldr	r0, .L608+24
 6300 3780 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6301              	.LVL683:
3327:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6302              		.loc 1 3327 0
 6303 3784 0410A0E1 		mov	r1, r4
 6304 3788 4C289FE5 		ldr	r2, .L608+28
 6305 378c 0500A0E1 		mov	r0, r5
 6306 3790 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6307              	.LVL684:
3328:../uvc.c      **** 
 6308              		.loc 1 3328 0
 6309 3794 0410A0E1 		mov	r1, r4
 6310 3798 0400A0E1 		mov	r0, r4
 6311 379c 3C289FE5 		ldr	r2, .L608+32
 6312 37a0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6313              	.LVL685:
3331:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6314              		.loc 1 3331 0
 6315 37a4 0410A0E1 		mov	r1, r4
 6316 37a8 34289FE5 		ldr	r2, .L608+36
 6317 37ac 0600A0E1 		mov	r0, r6
 6318 37b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6319              	.LVL686:
3332:../uvc.c      **** 
 6320              		.loc 1 3332 0
 6321 37b4 0410A0E1 		mov	r1, r4
 6322 37b8 28289FE5 		ldr	r2, .L608+40
 6323 37bc 0700A0E3 		mov	r0, #7
 6324 37c0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6325              	.LVL687:
3335:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6326              		.loc 1 3335 0
 6327 37c4 0410A0E1 		mov	r1, r4
 6328 37c8 1C289FE5 		ldr	r2, .L608+44
 6329 37cc 0400A0E3 		mov	r0, #4
 6330 37d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6331              	.LVL688:
3336:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6332              		.loc 1 3336 0
 6333 37d4 0410A0E1 		mov	r1, r4
 6334 37d8 10289FE5 		ldr	r2, .L608+48
 6335 37dc 0800A0E1 		mov	r0, r8
 6336 37e0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6337              	.LVL689:
3337:../uvc.c      **** 
 6338              		.loc 1 3337 0
 6339 37e4 0410A0E1 		mov	r1, r4
 6340 37e8 04289FE5 		ldr	r2, .L608+52
 6341 37ec 0600A0E3 		mov	r0, #6
 6342 37f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6343              	.LVL690:
3340:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6344              		.loc 1 3340 0
 6345 37f4 0410A0E1 		mov	r1, r4
 6346 37f8 F8279FE5 		ldr	r2, .L608+56
 6347 37fc 0500A0E3 		mov	r0, #5
 6348 3800 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6349              	.LVL691:
3341:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6350              		.loc 1 3341 0
 6351 3804 0510A0E1 		mov	r1, r5
 6352 3808 EC279FE5 		ldr	r2, .L608+60
 6353 380c 0500A0E3 		mov	r0, #5
 6354 3810 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6355              	.LVL692:
3342:../uvc.c      **** 
 6356              		.loc 1 3342 0
 6357 3814 0610A0E1 		mov	r1, r6
 6358 3818 E0279FE5 		ldr	r2, .L608+64
 6359 381c 0500A0E3 		mov	r0, #5
 6360 3820 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6361              	.LVL693:
3351:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6362              		.loc 1 3351 0
 6363 3824 4030A0E3 		mov	r3, #64
3355:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6364              		.loc 1 3355 0
 6365 3828 08108DE2 		add	r1, sp, #8
 6366 382c 8200A0E3 		mov	r0, #130
3352:../uvc.c      ****     endPointConfig.streams  = 0;
 6367              		.loc 1 3352 0
 6368 3830 1340CDE5 		strb	r4, [sp, #19]
3353:../uvc.c      ****     endPointConfig.burstLen = 1;
 6369              		.loc 1 3353 0
 6370 3834 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3349:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6371              		.loc 1 3349 0
 6372 3838 08508DE5 		str	r5, [sp, #8]
3350:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6373              		.loc 1 3350 0
 6374 383c 0C80CDE5 		strb	r8, [sp, #12]
3354:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6375              		.loc 1 3354 0
 6376 3840 1250CDE5 		strb	r5, [sp, #18]
3351:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6377              		.loc 1 3351 0
 6378 3844 B031CDE1 		strh	r3, [sp, #16]	@ movhi
3355:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6379              		.loc 1 3355 0
 6380 3848 FEFFFFEB 		bl	CyU3PSetEpConfig
 6381              	.LVL694:
3356:../uvc.c      ****     {
 6382              		.loc 1 3356 0
 6383 384c 004050E2 		subs	r4, r0, #0
3359:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6384              		.loc 1 3359 0
 6385 3850 0400A013 		movne	r0, #4
 6386              	.LVL695:
3356:../uvc.c      ****     {
 6387              		.loc 1 3356 0
 6388 3854 7101001A 		bne	.L574
3364:../uvc.c      ****     dmaInterConfig.count          = 1;
 6389              		.loc 1 3364 0
 6390 3858 A4C79FE5 		ldr	ip, .L608+68
 6391 385c 413BA0E3 		mov	r3, #66560
3373:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6392              		.loc 1 3373 0
 6393 3860 1080A0E3 		mov	r8, #16
3375:../uvc.c      ****             &dmaInterConfig);
 6394              		.loc 1 3375 0
 6395 3864 9C079FE5 		ldr	r0, .L608+72
 6396 3868 0410A0E3 		mov	r1, #4
 6397 386c 44208DE2 		add	r2, sp, #68
3364:../uvc.c      ****     dmaInterConfig.count          = 1;
 6398              		.loc 1 3364 0
 6399 3870 4C408DE5 		str	r4, [sp, #76]
 6400 3874 50408DE5 		str	r4, [sp, #80]
3372:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6401              		.loc 1 3372 0
 6402 3878 5440CDE5 		strb	r4, [sp, #84]
3374:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6403              		.loc 1 3374 0
 6404 387c 5C408DE5 		str	r4, [sp, #92]
3364:../uvc.c      ****     dmaInterConfig.count          = 1;
 6405              		.loc 1 3364 0
 6406 3880 48C08DE5 		str	ip, [sp, #72]
 6407 3884 44308DE5 		str	r3, [sp, #68]
3373:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6408              		.loc 1 3373 0
 6409 3888 58808DE5 		str	r8, [sp, #88]
3375:../uvc.c      ****             &dmaInterConfig);
 6410              		.loc 1 3375 0
 6411 388c FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6412              	.LVL696:
3377:../uvc.c      ****     {
 6413              		.loc 1 3377 0
 6414 3890 004050E2 		subs	r4, r0, #0
 6415 3894 BE01001A 		bne	.L590
3384:../uvc.c      ****     if (glInterStaBuffer == 0)
 6416              		.loc 1 3384 0
 6417 3898 010BA0E3 		mov	r0, #1024
 6418              	.LVL697:
 6419 389c FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6420              	.LVL698:
 6421 38a0 64379FE5 		ldr	r3, .L608+76
3385:../uvc.c      ****     {
 6422              		.loc 1 3385 0
 6423 38a4 000050E3 		cmp	r0, #0
3384:../uvc.c      ****     if (glInterStaBuffer == 0)
 6424              		.loc 1 3384 0
 6425 38a8 000083E5 		str	r0, [r3]
3385:../uvc.c      ****     {
 6426              		.loc 1 3385 0
 6427 38ac BE01000A 		beq	.L591
3392:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6428              		.loc 1 3392 0
 6429 38b0 0410A0E1 		mov	r1, r4
 6430 38b4 0420A0E1 		mov	r2, r4
 6431 38b8 3830A0E3 		mov	r3, #56
 6432 38bc 4C079FE5 		ldr	r0, .L608+80
 6433 38c0 FEFFFFEB 		bl	_txe_mutex_create
 6434              	.LVL699:
3397:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6435              		.loc 1 3397 0
 6436 38c4 48179FE5 		ldr	r1, .L608+84
3398:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6437              		.loc 1 3398 0
 6438 38c8 48279FE5 		ldr	r2, .L608+88
3405:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6439              		.loc 1 3405 0
 6440 38cc 48A79FE5 		ldr	r10, .L608+92
3394:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6441              		.loc 1 3394 0
 6442 38d0 0480A0E3 		mov	r8, #4
3396:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6443              		.loc 1 3396 0
 6444 38d4 01ECA0E3 		mov	lr, #256
3400:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6445              		.loc 1 3400 0
 6446 38d8 0CC0A0E3 		mov	ip, #12
3404:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6447              		.loc 1 3404 0
 6448 38dc 1830A0E3 		mov	r3, #24
3397:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6449              		.loc 1 3397 0
 6450 38e0 B816CDE1 		strh	r1, [sp, #104]	@ movhi
3398:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6451              		.loc 1 3398 0
 6452 38e4 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3393:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6453              		.loc 1 3393 0
 6454 38e8 0199A0E3 		mov	r9, #16384
3406:../uvc.c      ****             &dmaMultiConfig);
 6455              		.loc 1 3406 0
 6456 38ec 2C079FE5 		ldr	r0, .L608+96
 6457 38f0 0710A0E3 		mov	r1, #7
 6458 38f4 60208DE2 		add	r2, sp, #96
3399:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6459              		.loc 1 3399 0
 6460 38f8 B647CDE1 		strh	r4, [sp, #118]	@ movhi
3402:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6461              		.loc 1 3402 0
 6462 38fc BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3403:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6463              		.loc 1 3403 0
 6464 3900 7E40CDE5 		strb	r4, [sp, #126]
3395:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6465              		.loc 1 3395 0
 6466 3904 B466CDE1 		strh	r6, [sp, #100]	@ movhi
3405:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6467              		.loc 1 3405 0
 6468 3908 84A08DE5 		str	r10, [sp, #132]
3393:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6469              		.loc 1 3393 0
 6470 390c B096CDE1 		strh	r9, [sp, #96]	@ movhi
3394:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6471              		.loc 1 3394 0
 6472 3910 B286CDE1 		strh	r8, [sp, #98]	@ movhi
3401:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6473              		.loc 1 3401 0
 6474 3914 BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3396:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6475              		.loc 1 3396 0
 6476 3918 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3400:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6477              		.loc 1 3400 0
 6478 391c B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3404:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6479              		.loc 1 3404 0
 6480 3920 80308DE5 		str	r3, [sp, #128]
3406:../uvc.c      ****             &dmaMultiConfig);
 6481              		.loc 1 3406 0
 6482 3924 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6483              	.LVL700:
3408:../uvc.c      ****     {
 6484              		.loc 1 3408 0
 6485 3928 004050E2 		subs	r4, r0, #0
 6486 392c 9201001A 		bne	.L592
3499:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6487              		.loc 1 3499 0
 6488 3930 0500A0E1 		mov	r0, r5
 6489              	.LVL701:
 6490 3934 0510A0E1 		mov	r1, r5
 6491 3938 FEFFFFEB 		bl	CyU3PConnectState
 6492              	.LVL702:
3500:../uvc.c      ****     {
 6493              		.loc 1 3500 0
 6494 393c 004050E2 		subs	r4, r0, #0
 6495 3940 3B01001A 		bne	.L593
3506:../uvc.c      **** 
 6496              		.loc 1 3506 0
 6497 3944 6400A0E3 		mov	r0, #100
 6498              	.LVL703:
 6499 3948 FEFFFFEB 		bl	CyFx3BusyWait
 6500              	.LVL704:
3508:../uvc.c      **** 
 6501              		.loc 1 3508 0
 6502 394c FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6503              	.LVL705:
3523:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6504              		.loc 1 3523 0
 6505 3950 08108DE2 		add	r1, sp, #8
3522:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6506              		.loc 1 3522 0
 6507 3954 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3510:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6508              		.loc 1 3510 0
 6509 3958 08508DE5 		str	r5, [sp, #8]
3511:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6510              		.loc 1 3511 0
 6511 395c 0C60CDE5 		strb	r6, [sp, #12]
3515:../uvc.c      ****     }
 6512              		.loc 1 3515 0
 6513 3960 030050E3 		cmp	r0, #3
3508:../uvc.c      **** 
 6514              		.loc 1 3508 0
 6515 3964 0030A0E1 		mov	r3, r0
3515:../uvc.c      ****     }
 6516              		.loc 1 3515 0
 6517 3968 01C0A013 		movne	ip, #1
 6518 396c 10C0A003 		moveq	ip, #16
 6519 3970 022CA013 		movne	r2, #512
 6520 3974 012BA003 		moveq	r2, #1024
3523:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6521              		.loc 1 3523 0
 6522 3978 8300A0E3 		mov	r0, #131
3508:../uvc.c      **** 
 6523              		.loc 1 3508 0
 6524 397c 4830C7E5 		strb	r3, [r7, #72]
 6525 3980 12C0CDE5 		strb	ip, [sp, #18]
 6526 3984 B021CDE1 		strh	r2, [sp, #16]	@ movhi
3523:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6527              		.loc 1 3523 0
 6528 3988 FEFFFFEB 		bl	CyU3PSetEpConfig
 6529              	.LVL706:
3524:../uvc.c      ****     {
 6530              		.loc 1 3524 0
 6531 398c 004050E2 		subs	r4, r0, #0
 6532              	.LBE105:
 6533              	.LBE104:
3647:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6534              		.loc 1 3647 0
 6535 3990 30469F05 		ldreq	r4, .L608+8
 6536              	.LBB110:
 6537              	.LBB106:
3524:../uvc.c      ****     {
 6538              		.loc 1 3524 0
 6539 3994 0C00000A 		beq	.L553
 6540 3998 1F0100EA 		b	.L607
 6541              	.LVL707:
 6542              	.L596:
 6543              	.LBE106:
 6544              	.LBE110:
3693:../uvc.c      ****             {
 6545              		.loc 1 3693 0
 6546 399c 7C3094E5 		ldr	r3, [r4, #124]
 6547 39a0 050053E1 		cmp	r3, r5
 6548 39a4 0300000A 		beq	.L523
3693:../uvc.c      ****             {
 6549              		.loc 1 3693 0 is_stmt 0 discriminator 1
 6550 39a8 B028D4E1 		ldrh	r2, [r4, #128]
 6551 39ac B238D4E1 		ldrh	r3, [r4, #130]
 6552 39b0 030052E1 		cmp	r2, r3
 6553 39b4 3B00000A 		beq	.L595
 6554              	.L523:
3897:../uvc.c      **** 
 6555              		.loc 1 3897 0 is_stmt 1
 6556 39b8 4010A0E3 		mov	r1, #64
 6557 39bc 0020A0E3 		mov	r2, #0
 6558 39c0 00069FE5 		ldr	r0, .L608+8
 6559 39c4 FEFFFFEB 		bl	_txe_event_flags_set
 6560              	.LVL708:
3900:../uvc.c      ****     }
 6561              		.loc 1 3900 0
 6562 39c8 FEFFFFEB 		bl	_txe_thread_relinquish
 6563              	.LVL709:
 6564              	.L553:
3647:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6565              		.loc 1 3647 0
 6566 39cc 0050A0E3 		mov	r5, #0
 6567 39d0 00508DE5 		str	r5, [sp]
 6568 39d4 EC059FE5 		ldr	r0, .L608+8
 6569 39d8 0110A0E3 		mov	r1, #1
 6570 39dc 0220A0E3 		mov	r2, #2
 6571 39e0 60308DE2 		add	r3, sp, #96
 6572 39e4 FEFFFFEB 		bl	_txe_event_flags_get
 6573              	.LVL710:
 6574 39e8 006050E2 		subs	r6, r0, #0
 6575 39ec EAFFFF0A 		beq	.L596
3804:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6576              		.loc 1 3804 0
 6577 39f0 00508DE5 		str	r5, [sp]
 6578 39f4 CC059FE5 		ldr	r0, .L608+8
 6579 39f8 0210A0E3 		mov	r1, #2
 6580 39fc 0320A0E3 		mov	r2, #3
 6581 3a00 60308DE2 		add	r3, sp, #96
 6582 3a04 FEFFFFEB 		bl	_txe_event_flags_get
 6583              	.LVL711:
 6584 3a08 000050E3 		cmp	r0, #0
 6585 3a0c 0B00001A 		bne	.L545
3819:../uvc.c      ****                 {
 6586              		.loc 1 3819 0
 6587 3a10 903094E5 		ldr	r3, [r4, #144]
3807:../uvc.c      ****                 prodCount = 0;
 6588              		.loc 1 3807 0
 6589 3a14 7C0084E5 		str	r0, [r4, #124]
3819:../uvc.c      ****                 {
 6590              		.loc 1 3819 0
 6591 3a18 000053E3 		cmp	r3, #0
3808:../uvc.c      ****                 consCount = 0;
 6592              		.loc 1 3808 0
 6593 3a1c B008C4E1 		strh	r0, [r4, #128]	@ movhi
3815:../uvc.c      ****                 pb=0;
 6594              		.loc 1 3815 0
 6595 3a20 B407C4E1 		strh	r0, [r4, #116]	@ movhi
3809:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6596              		.loc 1 3809 0
 6597 3a24 B208C4E1 		strh	r0, [r4, #130]	@ movhi
3816:../uvc.c      ****                 pbc=0;
 6598              		.loc 1 3816 0
 6599 3a28 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3817:../uvc.c      **** 
 6600              		.loc 1 3817 0
 6601 3a2c B807C4E1 		strh	r0, [r4, #120]	@ movhi
3819:../uvc.c      ****                 {
 6602              		.loc 1 3819 0
 6603 3a30 4600000A 		beq	.L597
 6604              	.L546:
3831:../uvc.c      ****             }
 6605              		.loc 1 3831 0
 6606 3a34 0030A0E3 		mov	r3, #0
 6607 3a38 903087E5 		str	r3, [r7, #144]
 6608 3a3c DDFFFFEA 		b	.L523
 6609              	.L545:
3836:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6610              		.loc 1 3836 0
 6611 3a40 0030E0E3 		mvn	r3, #0
 6612 3a44 00308DE5 		str	r3, [sp]
 6613 3a48 0110A0E3 		mov	r1, #1
 6614 3a4c 0220A0E3 		mov	r2, #2
 6615 3a50 60308DE2 		add	r3, sp, #96
 6616 3a54 6C059FE5 		ldr	r0, .L608+8
 6617 3a58 FEFFFFEB 		bl	_txe_event_flags_get
 6618              	.LVL712:
3840:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6619              		.loc 1 3840 0
 6620 3a5c 0510A0E1 		mov	r1, r5
 6621 3a60 0520A0E1 		mov	r2, r5
 6622 3a64 B4059FE5 		ldr	r0, .L608+96
 6623 3a68 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6624              	.LVL713:
3841:../uvc.c      ****                 {
 6625              		.loc 1 3841 0
 6626 3a6c 005050E2 		subs	r5, r0, #0
 6627 3a70 9D00001A 		bne	.L598
3849:../uvc.c      ****                 {
 6628              		.loc 1 3849 0
 6629 3a74 883094E5 		ldr	r3, [r4, #136]
 6630 3a78 000053E3 		cmp	r3, #0
 6631 3a7c 2B00001A 		bne	.L544
 6632              	.LVL714:
 6633              	.LBB111:
 6634              	.LBB112:
3552:../uvc.c      ****     {
 6635              		.loc 1 3552 0
 6636 3a80 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6637 3a84 030053E3 		cmp	r3, #3
 6638 3a88 5E00000A 		beq	.L599
3557:../uvc.c      ****     {
 6639              		.loc 1 3557 0
 6640 3a8c 020053E3 		cmp	r3, #2
 6641 3a90 7400000A 		beq	.L600
 6642              	.LVL715:
 6643              	.L551:
 6644              	.LBE112:
 6645              	.LBE111:
3885:../uvc.c      ****                     CyU3PThreadSleep(200);
 6646              		.loc 1 3885 0
 6647 3a94 0130A0E3 		mov	r3, #1
3886:../uvc.c      ****                     
 6648              		.loc 1 3886 0
 6649 3a98 C800A0E3 		mov	r0, #200
3885:../uvc.c      ****                     CyU3PThreadSleep(200);
 6650              		.loc 1 3885 0
 6651 3a9c 883087E5 		str	r3, [r7, #136]
3886:../uvc.c      ****                     
 6652              		.loc 1 3886 0
 6653 3aa0 FEFFFFEB 		bl	_tx_thread_sleep
 6654              	.LVL716:
 6655 3aa4 C3FFFFEA 		b	.L523
 6656              	.L595:
3719:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6657              		.loc 1 3719 0
 6658 3aa8 74559FE5 		ldr	r5, .L608+100
3718:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6659              		.loc 1 3718 0
 6660 3aac 5C059FE5 		ldr	r0, .L608+80
 6661 3ab0 0010E0E3 		mvn	r1, #0
3703:../uvc.c      ****                 consCount = 0;
 6662              		.loc 1 3703 0
 6663 3ab4 B068C4E1 		strh	r6, [r4, #128]	@ movhi
3700:../uvc.c      ****             	pb=0;
 6664              		.loc 1 3700 0
 6665 3ab8 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3704:../uvc.c      ****                 hitFV     = CyFalse;
 6666              		.loc 1 3704 0
 6667 3abc B268C4E1 		strh	r6, [r4, #130]	@ movhi
3701:../uvc.c      ****             	pbc=0;
 6668              		.loc 1 3701 0
 6669 3ac0 B667C4E1 		strh	r6, [r4, #118]	@ movhi
3702:../uvc.c      ****                 prodCount = 0;
 6670              		.loc 1 3702 0
 6671 3ac4 B867C4E1 		strh	r6, [r4, #120]	@ movhi
3705:../uvc.c      **** 
 6672              		.loc 1 3705 0
 6673 3ac8 7C6084E5 		str	r6, [r4, #124]
3718:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6674              		.loc 1 3718 0
 6675 3acc FEFFFFEB 		bl	_txe_mutex_get
 6676              	.LVL717:
3719:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6677              		.loc 1 3719 0
 6678 3ad0 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6679 3ad4 013023E2 		eor	r3, r3, #1
 6680 3ad8 ED34C5E5 		strb	r3, [r5, #1261]
3721:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6681              		.loc 1 3721 0
 6682 3adc 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6683 3ae0 F00053E3 		cmp	r3, #240
 6684 3ae4 3B00000A 		beq	.L601
 6685              	.L524:
3729:../uvc.c      **** 
 6686              		.loc 1 3729 0
 6687 3ae8 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6688 3aec FF0053E3 		cmp	r3, #255
 6689 3af0 1D00000A 		beq	.L602
3741:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6690              		.loc 1 3741 0
 6691 3af4 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6692 3af8 AA0053E3 		cmp	r3, #170
 6693 3afc 2700000A 		beq	.L603
 6694              	.L525:
3779:../uvc.c      ****                 /* Reset the DMA channel. */
 6695              		.loc 1 3779 0
 6696 3b00 08059FE5 		ldr	r0, .L608+80
 6697 3b04 FEFFFFEB 		bl	_txe_mutex_put
 6698              	.LVL718:
3781:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6699              		.loc 1 3781 0
 6700 3b08 10059FE5 		ldr	r0, .L608+96
 6701 3b0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6702              	.LVL719:
3782:../uvc.c      ****                 {
 6703              		.loc 1 3782 0
 6704 3b10 005050E2 		subs	r5, r0, #0
 6705 3b14 7A00001A 		bne	.L604
3789:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6706              		.loc 1 3789 0
 6707 3b18 0510A0E1 		mov	r1, r5
 6708 3b1c 0520A0E1 		mov	r2, r5
 6709 3b20 F8049FE5 		ldr	r0, .L608+96
 6710              	.LVL720:
 6711 3b24 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6712              	.LVL721:
3790:../uvc.c      ****                 {
 6713              		.loc 1 3790 0
 6714 3b28 005050E2 		subs	r5, r0, #0
 6715 3b2c 6800001A 		bne	.L605
 6716              	.L544:
3798:../uvc.c      ****                 }
 6717              		.loc 1 3798 0
 6718 3b30 DC049FE5 		ldr	r0, .L608+84
 6719              	.LVL722:
 6720 3b34 0230A0E3 		mov	r3, #2
 6721 3b38 0010A0E3 		mov	r1, #0
 6722 3b3c 00308DE5 		str	r3, [sp]
 6723 3b40 0020A0E1 		mov	r2, r0
 6724 3b44 0130A0E1 		mov	r3, r1
 6725 3b48 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6726              	.LVL723:
 6727 3b4c 99FFFFEA 		b	.L523
 6728              	.LVL724:
 6729              	.L597:
3821:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6730              		.loc 1 3821 0
 6731 3b50 C8049FE5 		ldr	r0, .L608+96
 6732 3b54 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6733              	.LVL725:
3822:../uvc.c      ****                     {
 6734              		.loc 1 3822 0
 6735 3b58 000050E3 		cmp	r0, #0
 6736 3b5c 4000001A 		bne	.L576
3828:../uvc.c      ****                 }
 6737              		.loc 1 3828 0
 6738 3b60 8300A0E3 		mov	r0, #131
 6739              	.LVL726:
 6740 3b64 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6741              	.LVL727:
 6742 3b68 B1FFFFEA 		b	.L546
 6743              	.L602:
3731:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6744              		.loc 1 3731 0
 6745 3b6c A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6746 3b70 020053E3 		cmp	r3, #2
 6747 3b74 013083E2 		add	r3, r3, #1
 6748 3b78 A030C4E5 		strb	r3, [r4, #160]
 6749 3b7c DFFFFF9A 		bls	.L525
3732:../uvc.c      ****                 		stiflag = 0x0F;
 6750              		.loc 1 3732 0
 6751 3b80 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3733:../uvc.c      ****                 		IMcount = 0;
 6752              		.loc 1 3733 0
 6753 3b84 0F30A0E3 		mov	r3, #15
3732:../uvc.c      ****                 		stiflag = 0x0F;
 6754              		.loc 1 3732 0
 6755 3b88 201081E3 		orr	r1, r1, #32
3734:../uvc.c      ****                 		}
 6756              		.loc 1 3734 0
 6757 3b8c 0020A0E3 		mov	r2, #0
3732:../uvc.c      ****                 		stiflag = 0x0F;
 6758              		.loc 1 3732 0
 6759 3b90 ED14C5E5 		strb	r1, [r5, #1261]
3734:../uvc.c      ****                 		}
 6760              		.loc 1 3734 0
 6761 3b94 A020C4E5 		strb	r2, [r4, #160]
3733:../uvc.c      ****                 		IMcount = 0;
 6762              		.loc 1 3733 0
 6763 3b98 7230C4E5 		strb	r3, [r4, #114]
 6764 3b9c D7FFFFEA 		b	.L525
 6765              	.L603:
3747:../uvc.c      ****                 	{
 6766              		.loc 1 3747 0
 6767 3ba0 A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6768 3ba4 020053E3 		cmp	r3, #2
 6769 3ba8 013083E2 		add	r3, r3, #1
 6770 3bac A030C4E5 		strb	r3, [r4, #160]
 6771 3bb0 D2FFFF9A 		bls	.L525
3749:../uvc.c      ****                      {
 6772              		.loc 1 3749 0
 6773 3bb4 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6774 3bb8 013043E2 		sub	r3, r3, #1
 6775 3bbc 030053E3 		cmp	r3, #3
 6776 3bc0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6777 3bc4 3E0000EA 		b	.L529
 6778              	.L531:
 6779 3bc8 843C0000 		.word	.L530
 6780 3bcc 703D0000 		.word	.L532
 6781 3bd0 B43D0000 		.word	.L533
 6782 3bd4 1C3D0000 		.word	.L534
 6783              	.L601:
3721:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6784              		.loc 1 3721 0 discriminator 1
 6785 3bd8 00608DE5 		str	r6, [sp]
 6786 3bdc E4039FE5 		ldr	r0, .L608+8
 6787 3be0 8010A0E3 		mov	r1, #128
 6788 3be4 0320A0E3 		mov	r2, #3
 6789 3be8 60308DE2 		add	r3, sp, #96
 6790 3bec FEFFFFEB 		bl	_txe_event_flags_get
 6791              	.LVL728:
 6792 3bf0 000050E3 		cmp	r0, #0
 6793 3bf4 BBFFFF1A 		bne	.L524
3726:../uvc.c      ****                 		IMcount = 0;
 6794              		.loc 1 3726 0
 6795 3bf8 0030E0E3 		mvn	r3, #0
3727:../uvc.c      ****                 	}
 6796              		.loc 1 3727 0
 6797 3bfc A000C4E5 		strb	r0, [r4, #160]
3726:../uvc.c      ****                 		IMcount = 0;
 6798              		.loc 1 3726 0
 6799 3c00 7230C4E5 		strb	r3, [r4, #114]
3727:../uvc.c      ****                 	}
 6800              		.loc 1 3727 0
 6801 3c04 BDFFFFEA 		b	.L525
 6802              	.LVL729:
 6803              	.L599:
 6804              	.LBB115:
 6805              	.LBB113:
3554:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6806              		.loc 1 3554 0
 6807 3c08 18149FE5 		ldr	r1, .L608+104
 6808 3c0c 0100A0E3 		mov	r0, #1
 6809              	.LVL730:
 6810 3c10 FEFFFFEB 		bl	CyU3PDebugPrint
 6811              	.LVL731:
3555:../uvc.c      ****     }
 6812              		.loc 1 3555 0
 6813 3c14 10049FE5 		ldr	r0, .L608+108
 6814 3c18 FEFFFFEB 		bl	CyU3PGpifLoad
 6815              	.LVL732:
 6816 3c1c 0050A0E1 		mov	r5, r0
 6817              	.LVL733:
 6818              	.L550:
3562:../uvc.c      ****     {
 6819              		.loc 1 3562 0
 6820 3c20 000055E3 		cmp	r5, #0
 6821 3c24 8800001A 		bne	.L606
 6822              	.LVL734:
3574:../uvc.c      ****     {
 6823              		.loc 1 3574 0
 6824 3c28 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6825 3c2c 023043E2 		sub	r3, r3, #2
 6826 3c30 FF3003E2 		and	r3, r3, #255
 6827 3c34 010053E3 		cmp	r3, #1
 6828 3c38 95FFFF8A 		bhi	.L551
3572:../uvc.c      ****     }
 6829              		.loc 1 3572 0
 6830 3c3c 0500A0E1 		mov	r0, r5
 6831 3c40 0510A0E1 		mov	r1, r5
 6832 3c44 FEFFFFEB 		bl	CyU3PGpifSMStart
 6833              	.LVL735:
3578:../uvc.c      ****     {
 6834              		.loc 1 3578 0
 6835 3c48 005050E2 		subs	r5, r0, #0
 6836 3c4c 90FFFF0A 		beq	.L551
3581:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6837              		.loc 1 3581 0
 6838 3c50 0400A0E3 		mov	r0, #4
 6839              	.LVL736:
 6840 3c54 D4139FE5 		ldr	r1, .L608+112
 6841 3c58 0520A0E1 		mov	r2, r5
 6842 3c5c FEFFFFEB 		bl	CyU3PDebugPrint
 6843              	.LVL737:
3582:../uvc.c      ****     }
 6844              		.loc 1 3582 0
 6845 3c60 0500A0E1 		mov	r0, r5
 6846              	.LVL738:
 6847              	.L576:
3566:../uvc.c      ****     }
 6848              		.loc 1 3566 0
 6849 3c64 FEFFFFEB 		bl	CyFxAppErrorHandler
 6850              	.LVL739:
 6851              	.L600:
3559:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6852              		.loc 1 3559 0
 6853 3c68 C4139FE5 		ldr	r1, .L608+116
 6854 3c6c 0100A0E3 		mov	r0, #1
 6855              	.LVL740:
 6856 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
 6857              	.LVL741:
3560:../uvc.c      ****     }
 6858              		.loc 1 3560 0
 6859 3c74 BC039FE5 		ldr	r0, .L608+120
 6860 3c78 FEFFFFEB 		bl	CyU3PGpifLoad
 6861              	.LVL742:
 6862 3c7c 0050A0E1 		mov	r5, r0
 6863              	.LVL743:
 6864 3c80 E6FFFFEA 		b	.L550
 6865              	.LVL744:
 6866              	.L530:
 6867              	.LBE113:
 6868              	.LBE115:
3752:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6869              		.loc 1 3752 0
 6870 3c84 6C2097E5 		ldr	r2, [r7, #108]
 6871 3c88 3010A0E3 		mov	r1, #48
 6872 3c8c 000052E3 		cmp	r2, #0
 6873 3c90 A220A003 		moveq	r2, #162
 6874 3c94 2220A013 		movne	r2, #34
 6875 3c98 5230A0E3 		mov	r3, #82
 6876 3c9c 0100A0E3 		mov	r0, #1
 6877 3ca0 FEFFFFEB 		bl	SensorSetIrisControl
 6878              	.LVL745:
3754:../uvc.c      ****                  		break;
 6879              		.loc 1 3754 0
 6880 3ca4 6C2097E5 		ldr	r2, [r7, #108]
 6881 3ca8 0400A0E3 		mov	r0, #4
 6882 3cac 000052E3 		cmp	r2, #0
 6883 3cb0 6C3097E5 		ldr	r3, [r7, #108]
 6884 3cb4 A220A003 		moveq	r2, #162
 6885 3cb8 2220A013 		movne	r2, #34
 6886 3cbc 78139FE5 		ldr	r1, .L608+124
 6887 3cc0 FEFFFFEB 		bl	CyU3PDebugPrint
 6888              	.LVL746:
 6889              	.L529:
3774:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6890              		.loc 1 3774 0
 6891 3cc4 0030A0E3 		mov	r3, #0
 6892 3cc8 A030C7E5 		strb	r3, [r7, #160]
3776:../uvc.c      ****                 	}
 6893              		.loc 1 3776 0
 6894 3ccc 7230C7E5 		strb	r3, [r7, #114]
 6895 3cd0 8AFFFFEA 		b	.L525
 6896              	.LVL747:
 6897              	.L605:
3792:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6898              		.loc 1 3792 0
 6899 3cd4 0400A0E3 		mov	r0, #4
 6900              	.LVL748:
 6901 3cd8 60139FE5 		ldr	r1, .L608+128
 6902 3cdc 0520A0E1 		mov	r2, r5
 6903 3ce0 FEFFFFEB 		bl	CyU3PDebugPrint
 6904              	.LVL749:
3793:../uvc.c      ****                 }
 6905              		.loc 1 3793 0
 6906 3ce4 0500A0E1 		mov	r0, r5
 6907 3ce8 FEFFFFEB 		bl	CyFxAppErrorHandler
 6908              	.LVL750:
 6909              	.L598:
3844:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6910              		.loc 1 3844 0
 6911 3cec 0400A0E3 		mov	r0, #4
 6912              	.LVL751:
 6913 3cf0 4C139FE5 		ldr	r1, .L608+132
 6914 3cf4 0520A0E1 		mov	r2, r5
 6915 3cf8 FEFFFFEB 		bl	CyU3PDebugPrint
 6916              	.LVL752:
3845:../uvc.c      ****                 }
 6917              		.loc 1 3845 0
 6918 3cfc 0500A0E1 		mov	r0, r5
 6919 3d00 FEFFFFEB 		bl	CyFxAppErrorHandler
 6920              	.LVL753:
 6921              	.L604:
3784:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6922              		.loc 1 3784 0
 6923 3d04 0400A0E3 		mov	r0, #4
 6924              	.LVL754:
 6925 3d08 38139FE5 		ldr	r1, .L608+136
 6926 3d0c 0520A0E1 		mov	r2, r5
 6927 3d10 FEFFFFEB 		bl	CyU3PDebugPrint
 6928              	.LVL755:
3785:../uvc.c      ****                 }
 6929              		.loc 1 3785 0
 6930 3d14 0500A0E1 		mov	r0, r5
 6931 3d18 FEFFFFEB 		bl	CyFxAppErrorHandler
 6932              	.LVL756:
 6933              	.L534:
3767:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6934              		.loc 1 3767 0
 6935 3d1c 6C2097E5 		ldr	r2, [r7, #108]
 6936 3d20 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6937 3d24 000052E3 		cmp	r2, #0
 6938 3d28 B020A003 		moveq	r2, #176
 6939 3d2c 3020A013 		movne	r2, #48
 6940 3d30 032082E1 		orr	r2, r2, r3
 6941 3d34 3010A0E3 		mov	r1, #48
 6942 3d38 5230A0E3 		mov	r3, #82
 6943 3d3c 0100A0E3 		mov	r0, #1
 6944 3d40 FEFFFFEB 		bl	SensorSetIrisControl
 6945              	.LVL757:
3769:../uvc.c      ****                  		break;
 6946              		.loc 1 3769 0
 6947 3d44 6C1097E5 		ldr	r1, [r7, #108]
 6948 3d48 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6949 3d4c 000051E3 		cmp	r1, #0
 6950 3d50 B010A003 		moveq	r1, #176
 6951 3d54 3010A013 		movne	r1, #48
 6952 3d58 022081E1 		orr	r2, r1, r2
 6953 3d5c 6C3097E5 		ldr	r3, [r7, #108]
 6954 3d60 D4129FE5 		ldr	r1, .L608+124
 6955 3d64 0400A0E3 		mov	r0, #4
 6956 3d68 FEFFFFEB 		bl	CyU3PDebugPrint
 6957              	.LVL758:
3770:../uvc.c      ****                  	default:
 6958              		.loc 1 3770 0
 6959 3d6c D4FFFFEA 		b	.L529
 6960              	.L532:
3757:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6961              		.loc 1 3757 0
 6962 3d70 6C2097E5 		ldr	r2, [r7, #108]
 6963 3d74 3010A0E3 		mov	r1, #48
 6964 3d78 000052E3 		cmp	r2, #0
 6965 3d7c 9220A003 		moveq	r2, #146
 6966 3d80 1220A013 		movne	r2, #18
 6967 3d84 5230A0E3 		mov	r3, #82
 6968 3d88 0100A0E3 		mov	r0, #1
 6969 3d8c FEFFFFEB 		bl	SensorSetIrisControl
 6970              	.LVL759:
3759:../uvc.c      ****                  		break;
 6971              		.loc 1 3759 0
 6972 3d90 6C2097E5 		ldr	r2, [r7, #108]
 6973 3d94 A0129FE5 		ldr	r1, .L608+124
 6974 3d98 000052E3 		cmp	r2, #0
 6975 3d9c 6C3097E5 		ldr	r3, [r7, #108]
 6976 3da0 9220A003 		moveq	r2, #146
 6977 3da4 1220A013 		movne	r2, #18
 6978 3da8 0400A0E3 		mov	r0, #4
 6979 3dac FEFFFFEB 		bl	CyU3PDebugPrint
 6980              	.LVL760:
3760:../uvc.c      ****                  	case 3: //720
 6981              		.loc 1 3760 0
 6982 3db0 C3FFFFEA 		b	.L529
 6983              	.L533:
3762:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6984              		.loc 1 3762 0
 6985 3db4 6C2097E5 		ldr	r2, [r7, #108]
 6986 3db8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6987 3dbc 000052E3 		cmp	r2, #0
 6988 3dc0 8020A003 		moveq	r2, #128
 6989 3dc4 0020A013 		movne	r2, #0
 6990 3dc8 032082E1 		orr	r2, r2, r3
 6991 3dcc 3010A0E3 		mov	r1, #48
 6992 3dd0 5230A0E3 		mov	r3, #82
 6993 3dd4 0100A0E3 		mov	r0, #1
 6994 3dd8 FEFFFFEB 		bl	SensorSetIrisControl
 6995              	.LVL761:
3764:../uvc.c      ****                  		break;
 6996              		.loc 1 3764 0
 6997 3ddc 6C1097E5 		ldr	r1, [r7, #108]
 6998 3de0 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6999 3de4 000051E3 		cmp	r1, #0
 7000 3de8 8010A003 		moveq	r1, #128
 7001 3dec 0010A013 		movne	r1, #0
 7002 3df0 022081E1 		orr	r2, r1, r2
 7003 3df4 6C3097E5 		ldr	r3, [r7, #108]
 7004 3df8 3C129FE5 		ldr	r1, .L608+124
 7005 3dfc 0400A0E3 		mov	r0, #4
 7006 3e00 FEFFFFEB 		bl	CyU3PDebugPrint
 7007              	.LVL762:
3765:../uvc.c      ****                  	case 4: //VGA
 7008              		.loc 1 3765 0
 7009 3e04 AEFFFFEA 		b	.L529
 7010              	.LVL763:
 7011              	.L577:
 7012              	.LBB116:
 7013              	.LBB100:
3061:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7014              		.loc 1 3061 0
 7015 3e08 0400A0E3 		mov	r0, #4
 7016              	.LVL764:
 7017 3e0c 38129FE5 		ldr	r1, .L608+140
 7018 3e10 FEFFFFEB 		bl	CyU3PDebugPrint
 7019              	.LVL765:
3062:../uvc.c      ****     }
 7020              		.loc 1 3062 0
 7021 3e14 0400A0E1 		mov	r0, r4
 7022 3e18 FEFFFFEB 		bl	CyFxAppErrorHandler
 7023              	.LVL766:
 7024              	.L607:
 7025              	.LBE100:
 7026              	.LBE116:
 7027              	.LBB117:
 7028              	.LBB107:
3527:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7029              		.loc 1 3527 0
 7030 3e1c 0800A0E1 		mov	r0, r8
 7031              	.LVL767:
 7032              	.L574:
 7033 3e20 28129FE5 		ldr	r1, .L608+144
 7034 3e24 0420A0E1 		mov	r2, r4
 7035 3e28 FEFFFFEB 		bl	CyU3PDebugPrint
 7036              	.LVL768:
3528:../uvc.c      ****     }
 7037              		.loc 1 3528 0
 7038 3e2c 0400A0E1 		mov	r0, r4
 7039 3e30 8BFFFFEA 		b	.L576
 7040              	.LVL769:
 7041              	.L593:
3502:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7042              		.loc 1 3502 0
 7043 3e34 0800A0E1 		mov	r0, r8
 7044              	.LVL770:
 7045 3e38 14129FE5 		ldr	r1, .L608+148
 7046 3e3c 0420A0E1 		mov	r2, r4
 7047 3e40 FEFFFFEB 		bl	CyU3PDebugPrint
 7048              	.LVL771:
3503:../uvc.c      ****     }
 7049              		.loc 1 3503 0
 7050 3e44 0400A0E1 		mov	r0, r4
 7051 3e48 FEFFFFEB 		bl	CyFxAppErrorHandler
 7052              	.LVL772:
 7053              	.L606:
 7054              	.LBE107:
 7055              	.LBE117:
 7056              	.LBB118:
 7057              	.LBB114:
3565:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7058              		.loc 1 3565 0
 7059 3e4c 0400A0E3 		mov	r0, #4
 7060              	.LVL773:
 7061 3e50 00129FE5 		ldr	r1, .L608+152
 7062 3e54 0520A0E1 		mov	r2, r5
 7063 3e58 FEFFFFEB 		bl	CyU3PDebugPrint
 7064              	.LVL774:
3566:../uvc.c      ****     }
 7065              		.loc 1 3566 0
 7066 3e5c 0500A0E1 		mov	r0, r5
 7067 3e60 7FFFFFEA 		b	.L576
 7068              	.LVL775:
 7069              	.L581:
 7070              	.LBE114:
 7071              	.LBE118:
 7072              	.LBB119:
 7073              	.LBB108:
3218:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7074              		.loc 1 3218 0
 7075 3e64 0400A0E3 		mov	r0, #4
 7076              	.LVL776:
 7077 3e68 EC119FE5 		ldr	r1, .L608+156
 7078 3e6c 0520A0E1 		mov	r2, r5
 7079 3e70 FEFFFFEB 		bl	CyU3PDebugPrint
 7080              	.LVL777:
3219:../uvc.c      ****     }
 7081              		.loc 1 3219 0
 7082 3e74 0500A0E1 		mov	r0, r5
 7083 3e78 FEFFFFEB 		bl	CyFxAppErrorHandler
 7084              	.LVL778:
 7085              	.L580:
3196:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7086              		.loc 1 3196 0
 7087 3e7c 0400A0E3 		mov	r0, #4
 7088              	.LVL779:
 7089 3e80 D8119FE5 		ldr	r1, .L608+160
 7090 3e84 0520A0E1 		mov	r2, r5
 7091 3e88 FEFFFFEB 		bl	CyU3PDebugPrint
 7092              	.LVL780:
3197:../uvc.c      ****     }
 7093              		.loc 1 3197 0
 7094 3e8c 0500A0E1 		mov	r0, r5
 7095 3e90 FEFFFFEB 		bl	CyFxAppErrorHandler
 7096              	.LVL781:
 7097              	.L579:
 7098              	.LBE108:
 7099              	.LBE119:
 7100              	.LBB120:
 7101              	.LBB103:
3122:../uvc.c      ****         CyFxAppErrorHandler (status);
 7102              		.loc 1 3122 0
 7103 3e94 0400A0E3 		mov	r0, #4
 7104              	.LVL782:
 7105 3e98 C4119FE5 		ldr	r1, .L608+164
 7106 3e9c FEFFFFEB 		bl	CyU3PDebugPrint
 7107              	.LVL783:
3123:../uvc.c      ****     }
 7108              		.loc 1 3123 0
 7109 3ea0 0500A0E1 		mov	r0, r5
 7110 3ea4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7111              	.LVL784:
 7112              	.L578:
3109:../uvc.c      ****         CyFxAppErrorHandler (status);
 7113              		.loc 1 3109 0
 7114 3ea8 0400A0E3 		mov	r0, #4
 7115              	.LVL785:
 7116 3eac B4119FE5 		ldr	r1, .L608+168
 7117 3eb0 FEFFFFEB 		bl	CyU3PDebugPrint
 7118              	.LVL786:
3110:../uvc.c      ****     }
 7119              		.loc 1 3110 0
 7120 3eb4 0500A0E1 		mov	r0, r5
 7121 3eb8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7122              	.LVL787:
 7123              	.L589:
 7124              	.LBE103:
 7125              	.LBE120:
 7126              	.LBB121:
 7127              	.LBB109:
3314:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7128              		.loc 1 3314 0
 7129 3ebc 0400A0E3 		mov	r0, #4
 7130              	.LVL788:
 7131 3ec0 A4119FE5 		ldr	r1, .L608+172
 7132 3ec4 0420A0E1 		mov	r2, r4
 7133 3ec8 FEFFFFEB 		bl	CyU3PDebugPrint
 7134              	.LVL789:
3315:../uvc.c      ****     }
 7135              		.loc 1 3315 0
 7136 3ecc 0400A0E1 		mov	r0, r4
 7137 3ed0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7138              	.LVL790:
 7139              	.L588:
3293:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7140              		.loc 1 3293 0
 7141 3ed4 0400A0E3 		mov	r0, #4
 7142              	.LVL791:
 7143 3ed8 90119FE5 		ldr	r1, .L608+176
 7144 3edc 0420A0E1 		mov	r2, r4
 7145 3ee0 FEFFFFEB 		bl	CyU3PDebugPrint
 7146              	.LVL792:
3294:../uvc.c      ****     }
 7147              		.loc 1 3294 0
 7148 3ee4 0400A0E1 		mov	r0, r4
 7149 3ee8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7150              	.LVL793:
 7151              	.L587:
3280:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7152              		.loc 1 3280 0
 7153 3eec 0400A0E3 		mov	r0, #4
 7154              	.LVL794:
 7155 3ef0 7C119FE5 		ldr	r1, .L608+180
 7156 3ef4 0420A0E1 		mov	r2, r4
 7157 3ef8 FEFFFFEB 		bl	CyU3PDebugPrint
 7158              	.LVL795:
3281:../uvc.c      ****     }
 7159              		.loc 1 3281 0
 7160 3efc 0400A0E1 		mov	r0, r4
 7161 3f00 FEFFFFEB 		bl	CyFxAppErrorHandler
 7162              	.LVL796:
 7163              	.L586:
3266:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7164              		.loc 1 3266 0
 7165 3f04 0400A0E3 		mov	r0, #4
 7166              	.LVL797:
 7167 3f08 68119FE5 		ldr	r1, .L608+184
 7168 3f0c 0420A0E1 		mov	r2, r4
 7169 3f10 FEFFFFEB 		bl	CyU3PDebugPrint
 7170              	.LVL798:
3267:../uvc.c      ****     }
 7171              		.loc 1 3267 0
 7172 3f14 0400A0E1 		mov	r0, r4
 7173 3f18 FEFFFFEB 		bl	CyFxAppErrorHandler
 7174              	.LVL799:
 7175              	.L585:
3252:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7176              		.loc 1 3252 0
 7177 3f1c 0400A0E3 		mov	r0, #4
 7178              	.LVL800:
 7179 3f20 54119FE5 		ldr	r1, .L608+188
 7180 3f24 0620A0E1 		mov	r2, r6
 7181 3f28 FEFFFFEB 		bl	CyU3PDebugPrint
 7182              	.LVL801:
3253:../uvc.c      ****     }
 7183              		.loc 1 3253 0
 7184 3f2c 0600A0E1 		mov	r0, r6
 7185 3f30 FEFFFFEB 		bl	CyFxAppErrorHandler
 7186              	.LVL802:
 7187              	.L584:
3239:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7188              		.loc 1 3239 0
 7189 3f34 0400A0E3 		mov	r0, #4
 7190              	.LVL803:
 7191 3f38 40119FE5 		ldr	r1, .L608+192
 7192 3f3c 0520A0E1 		mov	r2, r5
 7193 3f40 FEFFFFEB 		bl	CyU3PDebugPrint
 7194              	.LVL804:
3240:../uvc.c      ****     }
 7195              		.loc 1 3240 0
 7196 3f44 0500A0E1 		mov	r0, r5
 7197 3f48 FEFFFFEB 		bl	CyFxAppErrorHandler
 7198              	.LVL805:
 7199              	.L583:
3233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7200              		.loc 1 3233 0
 7201 3f4c 0400A0E3 		mov	r0, #4
 7202              	.LVL806:
 7203 3f50 2C119FE5 		ldr	r1, .L608+196
 7204 3f54 0520A0E1 		mov	r2, r5
 7205 3f58 FEFFFFEB 		bl	CyU3PDebugPrint
 7206              	.LVL807:
3234:../uvc.c      ****     }
 7207              		.loc 1 3234 0
 7208 3f5c 0500A0E1 		mov	r0, r5
 7209 3f60 FEFFFFEB 		bl	CyFxAppErrorHandler
 7210              	.LVL808:
 7211              	.L582:
3227:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7212              		.loc 1 3227 0
 7213 3f64 0400A0E3 		mov	r0, #4
 7214              	.LVL809:
 7215 3f68 18119FE5 		ldr	r1, .L608+200
 7216 3f6c 0520A0E1 		mov	r2, r5
 7217 3f70 FEFFFFEB 		bl	CyU3PDebugPrint
 7218              	.LVL810:
3228:../uvc.c      ****     }
 7219              		.loc 1 3228 0
 7220 3f74 0500A0E1 		mov	r0, r5
 7221 3f78 FEFFFFEB 		bl	CyFxAppErrorHandler
 7222              	.LVL811:
 7223              	.L592:
3411:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7224              		.loc 1 3411 0
 7225 3f7c 0800A0E1 		mov	r0, r8
 7226              	.LVL812:
 7227 3f80 04119FE5 		ldr	r1, .L608+204
 7228 3f84 0420A0E1 		mov	r2, r4
 7229 3f88 FEFFFFEB 		bl	CyU3PDebugPrint
 7230              	.LVL813:
3412:../uvc.c      ****     }
 7231              		.loc 1 3412 0
 7232 3f8c 0400A0E1 		mov	r0, r4
 7233 3f90 FEFFFFEB 		bl	CyFxAppErrorHandler
 7234              	.LVL814:
 7235              	.L590:
3380:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7236              		.loc 1 3380 0
 7237 3f94 0400A0E3 		mov	r0, #4
 7238              	.LVL815:
 7239 3f98 F0109FE5 		ldr	r1, .L608+208
 7240 3f9c 0420A0E1 		mov	r2, r4
 7241 3fa0 FEFFFFEB 		bl	CyU3PDebugPrint
 7242              	.LVL816:
3381:../uvc.c      ****     }
 7243              		.loc 1 3381 0
 7244 3fa4 0400A0E1 		mov	r0, r4
 7245 3fa8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7246              	.LVL817:
 7247              	.L591:
3387:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7248              		.loc 1 3387 0
 7249 3fac 0400A0E3 		mov	r0, #4
 7250 3fb0 DC109FE5 		ldr	r1, .L608+212
 7251 3fb4 FEFFFFEB 		bl	CyU3PDebugPrint
 7252              	.LVL818:
3388:../uvc.c      ****     }
 7253              		.loc 1 3388 0
 7254 3fb8 0800A0E1 		mov	r0, r8
 7255 3fbc FEFFFFEB 		bl	CyFxAppErrorHandler
 7256              	.LVL819:
 7257              	.L609:
 7258              		.align	2
 7259              	.L608:
 7260 3fc0 00C20100 		.word	115200
 7261 3fc4 A0860100 		.word	100000
 7262 3fc8 00000000 		.word	.LANCHOR0
 7263 3fcc 00000000 		.word	CyFxGpifCB
 7264 3fd0 88130000 		.word	5000
 7265 3fd4 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7266 3fd8 00000000 		.word	CyFxUVCApplnUSBEventCB
 7267 3fdc 00000000 		.word	CyFxUSBDeviceDscr
 7268 3fe0 00000000 		.word	CyFxUSBDeviceDscrSS
 7269 3fe4 00000000 		.word	CyFxUSBDeviceQualDscr
 7270 3fe8 00000000 		.word	CyFxUSBBOSDscr
 7271 3fec 00000000 		.word	CyFxUSBHSConfigDscr
 7272 3ff0 00000000 		.word	CyFxUSBFSConfigDscr
 7273 3ff4 00000000 		.word	CyFxUSBSSConfigDscr
 7274 3ff8 00000000 		.word	CyFxUSBStringLangIDDscr
 7275 3ffc 00000000 		.word	CyFxUSBManufactureDscr
 7276 4000 00000000 		.word	CyFxUSBProductDscr
 7277 4004 013F0203 		.word	50478849
 7278 4008 00000000 		.word	glChHandleInterStat
 7279 400c 00000000 		.word	glInterStaBuffer
 7280 4010 00000000 		.word	imgHdMux
 7281 4014 01010000 		.word	257
 7282 4018 03030000 		.word	771
 7283 401c 00000000 		.word	CyFxUvcApplnDmaCallback
 7284 4020 00000000 		.word	glChHandleUVCStream
 7285 4024 00000000 		.word	.LANCHOR1
 7286 4028 A00B0000 		.word	.LC65
 7287 402c A0010000 		.word	.LANCHOR2+416
 7288 4030 F80B0000 		.word	.LC68
 7289 4034 B00B0000 		.word	.LC66
 7290 4038 BC010000 		.word	.LANCHOR2+444
 7291 403c E80A0000 		.word	.LC61
 7292 4040 380B0000 		.word	.LC63
 7293 4044 6C0B0000 		.word	.LC64
 7294 4048 0C0B0000 		.word	.LC62
 7295 404c BC070000 		.word	.LC43
 7296 4050 E4090000 		.word	.LC56
 7297 4054 C00A0000 		.word	.LC60
 7298 4058 C00B0000 		.word	.LC67
 7299 405c 40080000 		.word	.LC47
 7300 4060 14080000 		.word	.LC46
 7301 4064 F8070000 		.word	.LC45
 7302 4068 DC070000 		.word	.LC44
 7303 406c B4090000 		.word	.LC55
 7304 4070 84090000 		.word	.LC54
 7305 4074 4C090000 		.word	.LC53
 7306 4078 18090000 		.word	.LC52
 7307 407c E4080000 		.word	.LC51
 7308 4080 B8080000 		.word	.LC50
 7309 4084 8C080000 		.word	.LC49
 7310 4088 64080000 		.word	.LC48
 7311 408c 900A0000 		.word	.LC59
 7312 4090 180A0000 		.word	.LC57
 7313 4094 580A0000 		.word	.LC58
 7314              	.LBE109:
 7315              	.LBE121:
 7316              		.cfi_endproc
 7317              	.LFE19:
 7319              		.align	2
 7320              		.global	UVCAppEP0Thread_Entry
 7322              	UVCAppEP0Thread_Entry:
 7323              	.LFB25:
4710:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7324              		.loc 1 4710 0
 7325              		.cfi_startproc
 7326              		@ args = 0, pretend = 0, frame = 64
 7327              		@ frame_needed = 0, uses_anonymous_args = 0
 7328              	.LVL820:
 7329 4098 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7330              	.LCFI27:
 7331              		.cfi_def_cfa_offset 36
 7332              		.cfi_offset 4, -36
 7333              		.cfi_offset 5, -32
 7334              		.cfi_offset 6, -28
 7335              		.cfi_offset 7, -24
 7336              		.cfi_offset 8, -20
 7337              		.cfi_offset 9, -16
 7338              		.cfi_offset 10, -12
 7339              		.cfi_offset 11, -8
 7340              		.cfi_offset 14, -4
 7341 409c E08F9FE5 		ldr	r8, .L904
 7342 40a0 E0BF9FE5 		ldr	fp, .L904+4
 7343 40a4 E06F9FE5 		ldr	r6, .L904+8
4784:../uvc.c      ****                 {
 7344              		.loc 1 4784 0
 7345 40a8 E0AF9FE5 		ldr	r10, .L904+12
 7346              	.LBB142:
 7347              	.LBB143:
4217:../uvc.c      ****     {
 7348              		.loc 1 4217 0
 7349 40ac E07F9FE5 		ldr	r7, .L904+16
 7350              	.LBE143:
 7351              	.LBE142:
4710:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7352              		.loc 1 4710 0
 7353 40b0 5CD04DE2 		sub	sp, sp, #92
 7354              	.LCFI28:
 7355              		.cfi_def_cfa_offset 128
 7356              	.LVL821:
4732:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7357              		.loc 1 4732 0
 7358 40b4 0890A0E1 		mov	r9, r8
 7359              	.LVL822:
 7360              	.L815:
 7361 40b8 0030E0E3 		mvn	r3, #0
 7362 40bc 00308DE5 		str	r3, [sp]
 7363 40c0 BC0F9FE5 		ldr	r0, .L904
 7364 40c4 4C10A0E3 		mov	r1, #76
 7365 40c8 0120A0E3 		mov	r2, #1
 7366 40cc 44308DE2 		add	r3, sp, #68
 7367 40d0 FEFFFFEB 		bl	_txe_event_flags_get
 7368              	.LVL823:
 7369 40d4 000050E3 		cmp	r0, #0
 7370 40d8 3700001A 		bne	.L612
4736:../uvc.c      ****             {
 7371              		.loc 1 4736 0
 7372 40dc 8C3099E5 		ldr	r3, [r9, #140]
 7373 40e0 000053E3 		cmp	r3, #0
 7374 40e4 9900000A 		beq	.L873
 7375              	.L614:
4745:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7376              		.loc 1 4745 0
 7377 40e8 44309DE5 		ldr	r3, [sp, #68]
 7378 40ec 0C0013E3 		tst	r3, #12
 7379 40f0 8100001A 		bne	.L874
 7380              	.L616:
4752:../uvc.c      ****             {
 7381              		.loc 1 4752 0
 7382 40f4 040013E3 		tst	r3, #4
 7383 40f8 1B00000A 		beq	.L617
4754:../uvc.c      ****                 {
 7384              		.loc 1 4754 0
 7385 40fc B020DAE1 		ldrh	r2, [r10]
 7386 4100 2224A0E1 		mov	r2, r2, lsr #8
 7387 4104 030052E3 		cmp	r2, #3
 7388 4108 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7389 410c 110000EA 		b	.L618
 7390              	.L620:
 7391 4110 58410000 		.word	.L618
 7392 4114 8C420000 		.word	.L621
 7393 4118 C4410000 		.word	.L622
 7394 411c A8420000 		.word	.L623
 7395              	.L626:
 7396              	.LBB168:
 7397              	.LBB169:
3916:../uvc.c      ****     {
 7398              		.loc 1 3916 0
 7399 4120 0A0C52E3 		cmp	r2, #2560
 7400 4124 3F01000A 		beq	.L632
 7401 4128 2E01009A 		bls	.L875
 7402 412c 0D0C52E3 		cmp	r2, #3328
 7403 4130 3C01000A 		beq	.L632
 7404 4134 0E0C52E3 		cmp	r2, #3584
 7405 4138 3201000A 		beq	.L636
 7406 413c 030B52E3 		cmp	r2, #3072
 7407 4140 9101000A 		beq	.L876
 7408              	.L624:
3969:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7409              		.loc 1 3969 0
 7410 4144 883F9FE5 		ldr	r3, .L904+80
 7411 4148 0400A0E3 		mov	r0, #4
 7412 414c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7413 4150 401F9FE5 		ldr	r1, .L904+20
 7414 4154 FEFFFFEB 		bl	CyU3PDebugPrint
 7415              	.LVL824:
 7416              	.L618:
 7417              	.LBE169:
 7418              	.LBE168:
4775:../uvc.c      ****                         break;
 7419              		.loc 1 4775 0
 7420 4158 0000A0E3 		mov	r0, #0
 7421 415c 0020A0E1 		mov	r2, r0
 7422 4160 0110A0E3 		mov	r1, #1
 7423 4164 FEFFFFEB 		bl	CyU3PUsbStall
 7424              	.LVL825:
 7425 4168 44309DE5 		ldr	r3, [sp, #68]
 7426              	.L617:
4780:../uvc.c      ****             {
 7427              		.loc 1 4780 0
 7428 416c 080013E3 		tst	r3, #8
 7429 4170 0700000A 		beq	.L809
4784:../uvc.c      ****                 {
 7430              		.loc 1 4784 0
 7431 4174 B030DAE1 		ldrh	r3, [r10]
 7432 4178 010053E3 		cmp	r3, #1
 7433 417c 7900000A 		beq	.L810
4786:../uvc.c      ****                 }
 7434              		.loc 1 4786 0
 7435 4180 0000A0E3 		mov	r0, #0
 7436 4184 0020A0E1 		mov	r2, r0
 7437 4188 0110A0E3 		mov	r1, #1
 7438 418c FEFFFFEB 		bl	CyU3PUsbStall
 7439              	.LVL826:
 7440 4190 44309DE5 		ldr	r3, [sp, #68]
 7441              	.L809:
4795:../uvc.c      ****             {
 7442              		.loc 1 4795 0
 7443 4194 400013E3 		tst	r3, #64
 7444 4198 0700000A 		beq	.L612
4800:../uvc.c      **** 
 7445              		.loc 1 4800 0
 7446 419c 1800A0E3 		mov	r0, #24
 7447 41a0 48108DE2 		add	r1, sp, #72
 7448              	.LVL827:
 7449 41a4 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7450              	.LVL828:
4857:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7451              		.loc 1 4857 0
 7452 41a8 9237DBE5 		ldrb	r3, [fp, #1938]	@ zero_extendqisi2
 7453 41ac 0F0053E3 		cmp	r3, #15
 7454 41b0 8F00000A 		beq	.L877
4884:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7455              		.loc 1 4884 0
 7456 41b4 000053E3 		cmp	r3, #0
 7457 41b8 6D00000A 		beq	.L878
 7458              	.L612:
5008:../uvc.c      ****     }
 7459              		.loc 1 5008 0
 7460 41bc FEFFFFEB 		bl	_txe_thread_relinquish
 7461              	.LVL829:
5009:../uvc.c      **** }
 7462              		.loc 1 5009 0
 7463 41c0 BCFFFFEA 		b	.L815
 7464              	.L622:
 7465              	.LBB281:
 7466              	.LBB272:
3916:../uvc.c      ****     {
 7467              		.loc 1 3916 0
 7468 41c4 B020D7E1 		ldrh	r2, [r7]
 7469 41c8 060C52E3 		cmp	r2, #1536
 7470 41cc 6A01000A 		beq	.L625
 7471 41d0 D2FFFF8A 		bhi	.L626
 7472 41d4 030C52E3 		cmp	r2, #768
 7473 41d8 9201000A 		beq	.L627
 7474 41dc D400008A 		bhi	.L628
 7475 41e0 010C52E3 		cmp	r2, #256
 7476 41e4 3A01000A 		beq	.L629
 7477 41e8 020C52E3 		cmp	r2, #512
 7478 41ec D4FFFF1A 		bne	.L624
 7479              	.LVL830:
 7480              	.LBB170:
 7481              	.LBB171:
1359:../uvc.c      ****     /*
 7482              		.loc 1 1359 0
 7483 41f0 DC3E9FE5 		ldr	r3, .L904+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7484              		.loc 1 1348 0
 7485 41f4 4805DBE5 		ldrb	r0, [fp, #1352]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7486              		.loc 1 1359 0
 7487 41f8 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7488              		.loc 1 1349 0
 7489 41fc 4915DBE5 		ldrb	r1, [fp, #1353]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7490              		.loc 1 1350 0
 7491 4200 5725DBE5 		ldrb	r2, [fp, #1367]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7492              		.loc 1 1351 0
 7493 4204 4A35DBE5 		ldrb	r3, [fp, #1354]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7494              		.loc 1 1349 0
 7495 4208 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7496              		.loc 1 1350 0
 7497 420c FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7498              		.loc 1 1367 0
 7499 4210 830055E3 		cmp	r5, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7500              		.loc 1 1348 0
 7501 4214 FFC000E2 		and	ip, r0, #255
 7502              	.LVL831:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7503              		.loc 1 1349 0
 7504 4218 2C108DE5 		str	r1, [sp, #44]
 7505              	.LVL832:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7506              		.loc 1 1350 0
 7507 421c 28208DE5 		str	r2, [sp, #40]
 7508              	.LVL833:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7509              		.loc 1 1351 0
 7510 4220 FF3003E2 		and	r3, r3, #255
 7511              	.LVL834:
1367:../uvc.c      **** 		 {
 7512              		.loc 1 1367 0
 7513 4224 C004000A 		beq	.L658
 7514 4228 FB02009A 		bls	.L879
 7515 422c 850055E3 		cmp	r5, #133
 7516 4230 9904000A 		beq	.L663
 7517 4234 8E04003A 		bcc	.L664
 7518 4238 860055E3 		cmp	r5, #134
 7519 423c FE03000A 		beq	.L665
 7520 4240 870055E3 		cmp	r5, #135
 7521 4244 0F05001A 		bne	.L657
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7522              		.loc 1 1801 0
 7523 4248 020053E3 		cmp	r3, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7524              		.loc 1 1802 0
 7525 424c 53C5DBE5 		ldrb	ip, [fp, #1363]	@ zero_extendqisi2
 7526              	.LVL835:
1813:../uvc.c      **** 		 	 if(Len == 2){
 7527              		.loc 1 1813 0
 7528 4250 0300A0E1 		mov	r0, r3
 7529              	.LVL836:
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7530              		.loc 1 1803 0
 7531 4254 5425DBE5 		ldrb	r2, [fp, #1364]	@ zero_extendqisi2
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7532              		.loc 1 1801 0
 7533 4258 7203000A 		beq	.L857
 7534              	.L670:
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7535              		.loc 1 1809 0
 7536 425c 0030A0E3 		mov	r3, #0
 7537              	.LVL837:
1813:../uvc.c      **** 		 	 if(Len == 2){
 7538              		.loc 1 1813 0
 7539 4260 7C1E9FE5 		ldr	r1, .L904+96
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7540              		.loc 1 1806 0
 7541 4264 28C0C8E5 		strb	ip, [r8, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7542              		.loc 1 1808 0
 7543 4268 2920C8E5 		strb	r2, [r8, #41]
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7544              		.loc 1 1809 0
 7545 426c 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 7546              		.loc 1 1819 0
 7547 4270 24308DE5 		str	r3, [sp, #36]
 7548 4274 0040A0E3 		mov	r4, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 7549              		.loc 1 1813 0
 7550 4278 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7551              	.LVL838:
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7552              		.loc 1 1818 0
 7553 427c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 7554              	.LVL839:
1819:../uvc.c      **** 		 	 }
 7555              		.loc 1 1819 0
 7556 4280 2A30D8E5 		ldrb	r3, [r8, #42]	@ zero_extendqisi2
 7557              	.LVL840:
 7558 4284 24C09DE5 		ldr	ip, [sp, #36]
 7559 4288 180300EA 		b	.L667
 7560              	.LVL841:
 7561              	.L621:
 7562              	.LBE171:
 7563              	.LBE170:
 7564              	.LBE272:
 7565              	.LBE281:
 7566              	.LBB282:
 7567              	.LBB283:
4049:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7568              		.loc 1 4049 0
 7569 428c 403E9FE5 		ldr	r3, .L904+80
 7570 4290 001E9FE5 		ldr	r1, .L904+20
 7571 4294 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7572 4298 B020D7E1 		ldrh	r2, [r7]
 7573 429c 0400A0E3 		mov	r0, #4
 7574 42a0 FEFFFFEB 		bl	CyU3PDebugPrint
 7575              	.LVL842:
 7576 42a4 ABFFFFEA 		b	.L618
 7577              	.L623:
 7578              	.LBE283:
 7579              	.LBE282:
 7580              	.LBB284:
 7581              	.LBB158:
4217:../uvc.c      ****     {
 7582              		.loc 1 4217 0
 7583 42a8 B030D7E1 		ldrh	r3, [r7]
 7584 42ac E04D9FE5 		ldr	r4, .L904+16
 7585 42b0 0D0C53E3 		cmp	r3, #3328
 7586 42b4 1603000A 		beq	.L752
 7587 42b8 6F00008A 		bhi	.L753
 7588 42bc 060C53E3 		cmp	r3, #1536
 7589 42c0 3103000A 		beq	.L754
 7590 42c4 8F00009A 		bls	.L880
 7591 42c8 090C53E3 		cmp	r3, #2304
 7592 42cc 2A03000A 		beq	.L762
 7593 42d0 6001009A 		bls	.L881
 7594 42d4 0B0C53E3 		cmp	r3, #2816
 7595 42d8 2303000A 		beq	.L766
 7596 42dc 030B53E3 		cmp	r3, #3072
 7597 42e0 9F01000A 		beq	.L767
 7598 42e4 0A0C53E3 		cmp	r3, #2560
 7599 42e8 9AFFFF1A 		bne	.L618
 7600              	.LVL843:
4258:../uvc.c      ****     		}else/* no support for 1080p camera */
 7601              		.loc 1 4258 0
 7602 42ec 1900A0E3 		mov	r0, #25
 7603 42f0 FEFFFFEB 		bl	ControlHandle
 7604              	.LVL844:
 7605 42f4 44309DE5 		ldr	r3, [sp, #68]
 7606 42f8 9BFFFFEA 		b	.L617
 7607              	.L874:
 7608              	.LBE158:
 7609              	.LBE284:
4746:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7610              		.loc 1 4746 0
 7611 42fc 980D9FE5 		ldr	r0, .L904+24
 7612 4300 CC1D9FE5 		ldr	r1, .L904+80
 7613 4304 942D9FE5 		ldr	r2, .L904+28
 7614 4308 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7615 430c 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7616 4310 B010D2E1 		ldrh	r1, [r2]
 7617 4314 B0C0D7E1 		ldrh	ip, [r7]
 7618 4318 00008DE5 		str	r0, [sp]
 7619 431c B000DAE1 		ldrh	r0, [r10]
 7620 4320 10108DE5 		str	r1, [sp, #16]
 7621 4324 0010A0E3 		mov	r1, #0
 7622 4328 0C008DE5 		str	r0, [sp, #12]
 7623 432c 14108DE5 		str	r1, [sp, #20]
 7624 4330 4820D8E5 		ldrb	r2, [r8, #72]	@ zero_extendqisi2
 7625 4334 04E08DE5 		str	lr, [sp, #4]
 7626 4338 08C08DE5 		str	ip, [sp, #8]
 7627 433c 0400A0E3 		mov	r0, #4
 7628 4340 5C1D9FE5 		ldr	r1, .L904+32
 7629 4344 FEFFFFEB 		bl	CyU3PDebugPrint
 7630              	.LVL845:
 7631 4348 44309DE5 		ldr	r3, [sp, #68]
 7632 434c 68FFFFEA 		b	.L616
 7633              	.L873:
4738:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7634              		.loc 1 4738 0
 7635 4350 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7636              	.LVL846:
4739:../uvc.c      ****                 {
 7637              		.loc 1 4739 0
 7638 4354 000050E3 		cmp	r0, #0
4741:../uvc.c      ****                 }
 7639              		.loc 1 4741 0
 7640 4358 0130A013 		movne	r3, #1
4738:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7641              		.loc 1 4738 0
 7642 435c 4800C9E5 		strb	r0, [r9, #72]
4741:../uvc.c      ****                 }
 7643              		.loc 1 4741 0
 7644 4360 8C308915 		strne	r3, [r9, #140]
 7645 4364 5FFFFFEA 		b	.L614
 7646              	.L810:
4790:../uvc.c      ****                 }
 7647              		.loc 1 4790 0
 7648 4368 33EFFFEB 		bl	UVCHandleVideoStreamingRqts
 7649              	.LVL847:
 7650 436c 44309DE5 		ldr	r3, [sp, #68]
 7651 4370 87FFFFEA 		b	.L809
 7652              	.L878:
4886:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7653              		.loc 1 4886 0
 7654 4374 002096E5 		ldr	r2, [r6]
 7655 4378 0210A0E3 		mov	r1, #2
 7656 437c 0010C2E5 		strb	r1, [r2]
4887:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7657              		.loc 1 4887 0
 7658 4380 002096E5 		ldr	r2, [r6]
 7659 4384 0140A0E3 		mov	r4, #1
 7660 4388 0140C2E5 		strb	r4, [r2, #1]
4888:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7661              		.loc 1 4888 0
 7662 438c 001096E5 		ldr	r1, [r6]
4892:../uvc.c      **** 					interStabuf.status = 0;
 7663              		.loc 1 4892 0
 7664 4390 012BA0E3 		mov	r2, #1024
4888:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7665              		.loc 1 4888 0
 7666 4394 0230C1E5 		strb	r3, [r1, #2]
4889:../uvc.c      **** 
 7667              		.loc 1 4889 0
 7668 4398 001096E5 		ldr	r1, [r6]
4895:../uvc.c      **** 
 7669              		.loc 1 4895 0
 7670 439c 0450A0E3 		mov	r5, #4
4889:../uvc.c      **** 
 7671              		.loc 1 4889 0
 7672 43a0 0340C1E5 		strb	r4, [r1, #3]
4891:../uvc.c      **** 					interStabuf.size   = 1024;
 7673              		.loc 1 4891 0
 7674 43a4 001096E5 		ldr	r1, [r6]
4898:../uvc.c      **** 
 7675              		.loc 1 4898 0
 7676 43a8 F80C9FE5 		ldr	r0, .L904+36
4891:../uvc.c      **** 					interStabuf.size   = 1024;
 7677              		.loc 1 4891 0
 7678 43ac 4C108DE5 		str	r1, [sp, #76]
4898:../uvc.c      **** 
 7679              		.loc 1 4898 0
 7680 43b0 0010E0E3 		mvn	r1, #0
4893:../uvc.c      **** 
 7681              		.loc 1 4893 0
 7682 43b4 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4892:../uvc.c      **** 					interStabuf.status = 0;
 7683              		.loc 1 4892 0
 7684 43b8 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4895:../uvc.c      **** 
 7685              		.loc 1 4895 0
 7686 43bc B055CDE1 		strh	r5, [sp, #80]	@ movhi
4898:../uvc.c      **** 
 7687              		.loc 1 4898 0
 7688 43c0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7689              	.LVL848:
4901:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7690              		.loc 1 4901 0
 7691 43c4 DC0C9FE5 		ldr	r0, .L904+36
 7692 43c8 4C108DE2 		add	r1, sp, #76
 7693 43cc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7694              	.LVL849:
4903:../uvc.c      **** 					{
 7695              		.loc 1 4903 0
 7696 43d0 000050E3 		cmp	r0, #0
 7697 43d4 3D01001A 		bne	.L882
4909:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7698              		.loc 1 4909 0
 7699 43d8 0500A0E3 		mov	r0, #5
 7700              	.LVL850:
 7701 43dc 3010A0E3 		mov	r1, #48
 7702 43e0 0420A0E1 		mov	r2, r4
 7703 43e4 FEFFFFEB 		bl	SensorSetControl
 7704              	.LVL851:
4910:../uvc.c      **** 				}
 7705              		.loc 1 4910 0
 7706 43e8 98CC9FE5 		ldr	ip, .L904+4
 7707 43ec 9247CCE5 		strb	r4, [ip, #1938]
 7708 43f0 71FFFFEA 		b	.L612
 7709              	.L877:
4859:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7710              		.loc 1 4859 0
 7711 43f4 003096E5 		ldr	r3, [r6]
 7712 43f8 0220A0E3 		mov	r2, #2
 7713 43fc 0020C3E5 		strb	r2, [r3]
4860:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7714              		.loc 1 4860 0
 7715 4400 003096E5 		ldr	r3, [r6]
 7716 4404 0140A0E3 		mov	r4, #1
 7717 4408 0140C3E5 		strb	r4, [r3, #1]
4861:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7718              		.loc 1 4861 0
 7719 440c 002096E5 		ldr	r2, [r6]
 7720 4410 0030A0E3 		mov	r3, #0
 7721 4414 0230C2E5 		strb	r3, [r2, #2]
4862:../uvc.c      **** 
 7722              		.loc 1 4862 0
 7723 4418 001096E5 		ldr	r1, [r6]
4868:../uvc.c      **** 
 7724              		.loc 1 4868 0
 7725 441c 04C0A0E3 		mov	ip, #4
4862:../uvc.c      **** 
 7726              		.loc 1 4862 0
 7727 4420 0330C1E5 		strb	r3, [r1, #3]
4864:../uvc.c      **** 					interStabuf.size   = 1024;
 7728              		.loc 1 4864 0
 7729 4424 001096E5 		ldr	r1, [r6]
4865:../uvc.c      **** 					interStabuf.status = 0;
 7730              		.loc 1 4865 0
 7731 4428 012BA0E3 		mov	r2, #1024
4864:../uvc.c      **** 					interStabuf.size   = 1024;
 7732              		.loc 1 4864 0
 7733 442c 4C108DE5 		str	r1, [sp, #76]
4871:../uvc.c      **** 
 7734              		.loc 1 4871 0
 7735 4430 700C9FE5 		ldr	r0, .L904+36
 7736 4434 0010E0E3 		mvn	r1, #0
4865:../uvc.c      **** 					interStabuf.status = 0;
 7737              		.loc 1 4865 0
 7738 4438 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4868:../uvc.c      **** 
 7739              		.loc 1 4868 0
 7740 443c B0C5CDE1 		strh	ip, [sp, #80]	@ movhi
4871:../uvc.c      **** 
 7741              		.loc 1 4871 0
 7742 4440 1CC08DE5 		str	ip, [sp, #28]
4866:../uvc.c      **** 
 7743              		.loc 1 4866 0
 7744 4444 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4871:../uvc.c      **** 
 7745              		.loc 1 4871 0
 7746 4448 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7747              	.LVL852:
4874:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7748              		.loc 1 4874 0
 7749 444c 540C9FE5 		ldr	r0, .L904+36
 7750 4450 4C108DE2 		add	r1, sp, #76
 7751 4454 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7752              	.LVL853:
4876:../uvc.c      **** 					{
 7753              		.loc 1 4876 0
 7754 4458 1CC09DE5 		ldr	ip, [sp, #28]
 7755 445c 002050E2 		subs	r2, r0, #0
 7756 4460 E502001A 		bne	.L883
4881:../uvc.c      **** 
 7757              		.loc 1 4881 0
 7758 4464 0500A0E3 		mov	r0, #5
 7759              	.LVL854:
 7760 4468 3010A0E3 		mov	r1, #48
 7761 446c FEFFFFEB 		bl	SensorSetControl
 7762              	.LVL855:
4883:../uvc.c      **** 				}else if(!snapButFlag){
 7763              		.loc 1 4883 0
 7764 4470 103C9FE5 		ldr	r3, .L904+4
 7765 4474 9247C3E5 		strb	r4, [r3, #1938]
 7766 4478 4FFFFFEA 		b	.L612
 7767              	.L753:
 7768              	.LBB285:
 7769              	.LBB159:
4217:../uvc.c      ****     {
 7770              		.loc 1 4217 0
 7771 447c 150C53E3 		cmp	r3, #5376
 7772 4480 D302000A 		beq	.L769
 7773 4484 0C00008A 		bhi	.L770
 7774 4488 110C53E3 		cmp	r3, #4352
 7775 448c CC02000A 		beq	.L771
 7776 4490 0601009A 		bls	.L884
 7777 4494 130C53E3 		cmp	r3, #4864
 7778 4498 A102000A 		beq	.L775
 7779 449c 050B53E3 		cmp	r3, #5120
 7780 44a0 3301000A 		beq	.L776
 7781 44a4 120C53E3 		cmp	r3, #4608
 7782 44a8 2AFFFF1A 		bne	.L618
 7783              	.LVL856:
4294:../uvc.c      ****     		break;
 7784              		.loc 1 4294 0
 7785 44ac 2500A0E3 		mov	r0, #37
 7786 44b0 FEFFFFEB 		bl	ControlHandle
 7787              	.LVL857:
 7788 44b4 44309DE5 		ldr	r3, [sp, #68]
 7789 44b8 2BFFFFEA 		b	.L617
 7790              	.L770:
4217:../uvc.c      ****     {
 7791              		.loc 1 4217 0
 7792 44bc 060B53E3 		cmp	r3, #6144
 7793 44c0 B502000A 		beq	.L778
 7794 44c4 EB00009A 		bls	.L885
 7795 44c8 1B0C53E3 		cmp	r3, #6912
 7796 44cc 9C02000A 		beq	.L782
 7797 44d0 070B53E3 		cmp	r3, #7168
 7798 44d4 0A01000A 		beq	.L783
 7799 44d8 1A0C53E3 		cmp	r3, #6656
 7800 44dc 1DFFFF1A 		bne	.L618
4327:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7801              		.loc 1 4327 0
 7802 44e0 2D00A0E3 		mov	r0, #45
 7803 44e4 FEFFFFEB 		bl	ControlHandle
 7804              	.LVL858:
4328:../uvc.c      ****     		break;
 7805              		.loc 1 4328 0
 7806 44e8 E43B9FE5 		ldr	r3, .L904+80
 7807 44ec B020D4E1 		ldrh	r2, [r4]
 7808 44f0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7809 44f4 0400A0E3 		mov	r0, #4
 7810 44f8 AC1B9FE5 		ldr	r1, .L904+40
 7811 44fc FEFFFFEB 		bl	CyU3PDebugPrint
 7812              	.LVL859:
 7813 4500 44309DE5 		ldr	r3, [sp, #68]
 7814 4504 18FFFFEA 		b	.L617
 7815              	.L880:
4217:../uvc.c      ****     {
 7816              		.loc 1 4217 0
 7817 4508 030C53E3 		cmp	r3, #768
 7818 450c 8802000A 		beq	.L756
 7819 4510 C800008A 		bhi	.L757
 7820 4514 010C53E3 		cmp	r3, #256
 7821 4518 F500000A 		beq	.L758
 7822 451c 020C53E3 		cmp	r3, #512
 7823 4520 0CFFFF1A 		bne	.L618
 7824              	.LVL860:
4225:../uvc.c      ****     		break;
 7825              		.loc 1 4225 0
 7826 4524 1100A0E3 		mov	r0, #17
 7827 4528 FEFFFFEB 		bl	ControlHandle
 7828              	.LVL861:
 7829 452c 44309DE5 		ldr	r3, [sp, #68]
 7830 4530 0DFFFFEA 		b	.L617
 7831              	.L628:
 7832              	.LBE159:
 7833              	.LBE285:
 7834              	.LBB286:
 7835              	.LBB273:
3916:../uvc.c      ****     {
 7836              		.loc 1 3916 0
 7837 4534 010B52E3 		cmp	r2, #1024
 7838 4538 0BFFFF0A 		beq	.L617
 7839 453c 050C52E3 		cmp	r2, #1280
 7840 4540 FFFEFF1A 		bne	.L624
 7841              	.LVL862:
 7842              	.LBB179:
 7843              	.LBB180:
1359:../uvc.c      ****     /*
 7844              		.loc 1 1359 0
 7845 4544 883B9FE5 		ldr	r3, .L904+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7846              		.loc 1 1348 0
 7847 4548 7025DBE5 		ldrb	r2, [fp, #1392]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7848              		.loc 1 1359 0
 7849 454c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7850              		.loc 1 1349 0
 7851 4550 71C5DBE5 		ldrb	ip, [fp, #1393]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7852              		.loc 1 1359 0
 7853 4554 24308DE5 		str	r3, [sp, #36]
1367:../uvc.c      **** 		 {
 7854              		.loc 1 1367 0
 7855 4558 24E09DE5 		ldr	lr, [sp, #36]
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7856              		.loc 1 1350 0
 7857 455c 7F45DBE5 		ldrb	r4, [fp, #1407]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7858              		.loc 1 1351 0
 7859 4560 7235DBE5 		ldrb	r3, [fp, #1394]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7860              		.loc 1 1348 0
 7861 4564 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7862              		.loc 1 1367 0
 7863 4568 83005EE3 		cmp	lr, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7864              		.loc 1 1348 0
 7865 456c 2C208DE5 		str	r2, [sp, #44]
 7866              	.LVL863:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7867              		.loc 1 1349 0
 7868 4570 FFC00CE2 		and	ip, ip, #255
 7869              	.LVL864:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7870              		.loc 1 1350 0
 7871 4574 FF4004E2 		and	r4, r4, #255
 7872              	.LVL865:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7873              		.loc 1 1351 0
 7874 4578 FF3003E2 		and	r3, r3, #255
 7875              	.LVL866:
1367:../uvc.c      **** 		 {
 7876              		.loc 1 1367 0
 7877 457c D203000A 		beq	.L675
 7878 4580 5F01009A 		bls	.L886
 7879 4584 24C09DE5 		ldr	ip, [sp, #36]
 7880              	.LVL867:
 7881 4588 85005CE3 		cmp	ip, #133
 7882 458c 8504000A 		beq	.L680
 7883 4590 AD03003A 		bcc	.L681
 7884 4594 86005CE3 		cmp	ip, #134
 7885 4598 1703000A 		beq	.L682
 7886 459c 87005CE3 		cmp	ip, #135
 7887 45a0 7504001A 		bne	.L674
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7888              		.loc 1 1801 0
 7889 45a4 020053E3 		cmp	r3, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7890              		.loc 1 1802 0
 7891 45a8 7BC5DBE5 		ldrb	ip, [fp, #1403]	@ zero_extendqisi2
1813:../uvc.c      **** 		 	 if(Len == 2){
 7892              		.loc 1 1813 0
 7893 45ac 0300A0E1 		mov	r0, r3
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7894              		.loc 1 1803 0
 7895 45b0 7C25DBE5 		ldrb	r2, [fp, #1404]	@ zero_extendqisi2
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7896              		.loc 1 1801 0
 7897 45b4 AE02000A 		beq	.L860
 7898              	.L687:
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7899              		.loc 1 1809 0
 7900 45b8 0030A0E3 		mov	r3, #0
 7901              	.LVL868:
1813:../uvc.c      **** 		 	 if(Len == 2){
 7902              		.loc 1 1813 0
 7903 45bc 201B9FE5 		ldr	r1, .L904+96
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7904              		.loc 1 1806 0
 7905 45c0 28C0C8E5 		strb	ip, [r8, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7906              		.loc 1 1808 0
 7907 45c4 2920C8E5 		strb	r2, [r8, #41]
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7908              		.loc 1 1809 0
 7909 45c8 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 7910              		.loc 1 1819 0
 7911 45cc 28308DE5 		str	r3, [sp, #40]
 7912 45d0 0050A0E3 		mov	r5, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 7913              		.loc 1 1813 0
 7914 45d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7915              	.LVL869:
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7916              		.loc 1 1818 0
 7917 45d8 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 7918              	.LVL870:
1819:../uvc.c      **** 		 	 }
 7919              		.loc 1 1819 0
 7920 45dc 2A40D8E5 		ldrb	r4, [r8, #42]	@ zero_extendqisi2
 7921              	.LVL871:
 7922 45e0 28109DE5 		ldr	r1, [sp, #40]
 7923 45e4 790100EA 		b	.L684
 7924              	.LVL872:
 7925              	.L875:
 7926              	.LBE180:
 7927              	.LBE179:
3916:../uvc.c      ****     {
 7928              		.loc 1 3916 0
 7929 45e8 070C52E3 		cmp	r2, #1792
 7930 45ec 0900000A 		beq	.L634
 7931 45f0 020B52E3 		cmp	r2, #2048
 7932 45f4 D2FEFF1A 		bne	.L624
 7933              	.LVL873:
3947:../uvc.c      ****           		break;
 7934              		.loc 1 3947 0
 7935 45f8 0700A0E3 		mov	r0, #7
 7936 45fc FEFFFFEB 		bl	ControlHandle
 7937              	.LVL874:
 7938 4600 44309DE5 		ldr	r3, [sp, #68]
 7939 4604 D8FEFFEA 		b	.L617
 7940              	.L636:
 7941              	.LVL875:
3961:../uvc.c      ****     		break;
 7942              		.loc 1 3961 0
 7943 4608 0E00A0E3 		mov	r0, #14
 7944 460c FEFFFFEB 		bl	ControlHandle
 7945              	.LVL876:
 7946 4610 44309DE5 		ldr	r3, [sp, #68]
 7947 4614 D4FEFFEA 		b	.L617
 7948              	.L634:
 7949              	.LVL877:
3943:../uvc.c      ****           		break;
 7950              		.loc 1 3943 0
 7951 4618 0600A0E3 		mov	r0, #6
 7952 461c FEFFFFEB 		bl	ControlHandle
 7953              	.LVL878:
 7954 4620 44309DE5 		ldr	r3, [sp, #68]
 7955 4624 D0FEFFEA 		b	.L617
 7956              	.L632:
 7957              	.LVL879:
 7958              	.LBB190:
 7959              	.LBB191:
1359:../uvc.c      ****     /*
 7960              		.loc 1 1359 0
 7961 4628 A43A9FE5 		ldr	r3, .L904+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7962              		.loc 1 1348 0
 7963 462c 5817DBE5 		ldrb	r1, [fp, #1880]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7964              		.loc 1 1359 0
 7965 4630 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7966              		.loc 1 1349 0
 7967 4634 5957DBE5 		ldrb	r5, [fp, #1881]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7968              		.loc 1 1359 0
 7969 4638 28308DE5 		str	r3, [sp, #40]
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7970              		.loc 1 1350 0
 7971 463c 6727DBE5 		ldrb	r2, [fp, #1895]	@ zero_extendqisi2
1367:../uvc.c      **** 		 {
 7972              		.loc 1 1367 0
 7973 4640 28C09DE5 		ldr	ip, [sp, #40]
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7974              		.loc 1 1351 0
 7975 4644 5A37DBE5 		ldrb	r3, [fp, #1882]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7976              		.loc 1 1348 0
 7977 4648 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7978              		.loc 1 1350 0
 7979 464c FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7980              		.loc 1 1367 0
 7981 4650 83005CE3 		cmp	ip, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7982              		.loc 1 1348 0
 7983 4654 30108DE5 		str	r1, [sp, #48]
 7984              	.LVL880:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7985              		.loc 1 1349 0
 7986 4658 FF5005E2 		and	r5, r5, #255
 7987              	.LVL881:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7988              		.loc 1 1350 0
 7989 465c 2C208DE5 		str	r2, [sp, #44]
 7990              	.LVL882:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7991              		.loc 1 1351 0
 7992 4660 FF3003E2 		and	r3, r3, #255
 7993              	.LVL883:
1367:../uvc.c      **** 		 {
 7994              		.loc 1 1367 0
 7995 4664 A603000A 		beq	.L708
 7996 4668 F200009A 		bls	.L887
 7997 466c 28C09DE5 		ldr	ip, [sp, #40]
 7998 4670 85005CE3 		cmp	ip, #133
 7999 4674 0D04000A 		beq	.L713
 8000 4678 1804003A 		bcc	.L714
 8001 467c 86005CE3 		cmp	ip, #134
 8002 4680 B502000A 		beq	.L715
 8003 4684 87005CE3 		cmp	ip, #135
 8004 4688 5204001A 		bne	.L707
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8005              		.loc 1 1802 0
 8006 468c F4E99FE5 		ldr	lr, .L904+4
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8007              		.loc 1 1801 0
 8008 4690 020053E3 		cmp	r3, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8009              		.loc 1 1802 0
 8010 4694 63C7DEE5 		ldrb	ip, [lr, #1891]	@ zero_extendqisi2
1813:../uvc.c      **** 		 	 if(Len == 2){
 8011              		.loc 1 1813 0
 8012 4698 0300A0E1 		mov	r0, r3
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8013              		.loc 1 1803 0
 8014 469c 6427DEE5 		ldrb	r2, [lr, #1892]	@ zero_extendqisi2
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8015              		.loc 1 1801 0
 8016 46a0 9D03000A 		beq	.L862
 8017              	.L722:
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8018              		.loc 1 1809 0
 8019 46a4 0030A0E3 		mov	r3, #0
 8020              	.LVL884:
1813:../uvc.c      **** 		 	 if(Len == 2){
 8021              		.loc 1 1813 0
 8022 46a8 341A9FE5 		ldr	r1, .L904+96
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8023              		.loc 1 1806 0
 8024 46ac 28C0C8E5 		strb	ip, [r8, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8025              		.loc 1 1808 0
 8026 46b0 2920C8E5 		strb	r2, [r8, #41]
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8027              		.loc 1 1809 0
 8028 46b4 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 8029              		.loc 1 1819 0
 8030 46b8 24308DE5 		str	r3, [sp, #36]
 8031 46bc 0040A0E3 		mov	r4, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 8032              		.loc 1 1813 0
 8033 46c0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8034              	.LVL885:
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8035              		.loc 1 1818 0
 8036 46c4 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 8037              	.LVL886:
1819:../uvc.c      **** 		 	 }
 8038              		.loc 1 1819 0
 8039 46c8 2A50D8E5 		ldrb	r5, [r8, #42]	@ zero_extendqisi2
 8040              	.LVL887:
 8041 46cc 24109DE5 		ldr	r1, [sp, #36]
 8042 46d0 070100EA 		b	.L717
 8043              	.LVL888:
 8044              	.L629:
 8045              	.LBE191:
 8046              	.LBE190:
 8047              	.LBB203:
 8048              	.LBB204:
1359:../uvc.c      ****     /*
 8049              		.loc 1 1359 0
 8050 46d4 F8299FE5 		ldr	r2, .L904+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8051              		.loc 1 1348 0
 8052 46d8 9C35DBE5 		ldrb	r3, [fp, #1436]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8053              		.loc 1 1359 0
 8054 46dc 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8055              		.loc 1 1349 0
 8056 46e0 9D45DBE5 		ldrb	r4, [fp, #1437]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8057              		.loc 1 1350 0
 8058 46e4 AB55DBE5 		ldrb	r5, [fp, #1451]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8059              		.loc 1 1351 0
 8060 46e8 9EC5DBE5 		ldrb	ip, [fp, #1438]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8061              		.loc 1 1348 0
 8062 46ec FF3003E2 		and	r3, r3, #255
1367:../uvc.c      **** 		 {
 8063              		.loc 1 1367 0
 8064 46f0 830052E3 		cmp	r2, #131
1359:../uvc.c      ****     /*
 8065              		.loc 1 1359 0
 8066 46f4 24208DE5 		str	r2, [sp, #36]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8067              		.loc 1 1348 0
 8068 46f8 2C308DE5 		str	r3, [sp, #44]
 8069              	.LVL889:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8070              		.loc 1 1349 0
 8071 46fc FF4004E2 		and	r4, r4, #255
 8072              	.LVL890:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8073              		.loc 1 1350 0
 8074 4700 FF5005E2 		and	r5, r5, #255
 8075              	.LVL891:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8076              		.loc 1 1351 0
 8077 4704 FFC00CE2 		and	ip, ip, #255
 8078              	.LVL892:
1367:../uvc.c      **** 		 {
 8079              		.loc 1 1367 0
 8080 4708 9A03000A 		beq	.L639
 8081 470c 3301009A 		bls	.L888
 8082 4710 24009DE5 		ldr	r0, [sp, #36]
 8083 4714 850050E3 		cmp	r0, #133
 8084 4718 AF03000A 		beq	.L644
 8085 471c A303003A 		bcc	.L645
 8086 4720 860050E3 		cmp	r0, #134
 8087 4724 9D02000A 		beq	.L646
 8088 4728 870050E3 		cmp	r0, #135
 8089 472c 3C03001A 		bne	.L638
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8090              		.loc 1 1801 0
 8091 4730 02005CE3 		cmp	ip, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8092              		.loc 1 1802 0
 8093 4734 A725DB05 		ldreqb	r2, [fp, #1447]	@ zero_extendqisi2
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8094              		.loc 1 1803 0
 8095 4738 A835DB05 		ldreqb	r3, [fp, #1448]	@ zero_extendqisi2
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8096              		.loc 1 1801 0
 8097 473c 3304000A 		beq	.L855
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8098              		.loc 1 1806 0
 8099 4740 A7E5DBE5 		ldrb	lr, [fp, #1447]	@ zero_extendqisi2
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8100              		.loc 1 1808 0
 8101 4744 A825DBE5 		ldrb	r2, [fp, #1448]	@ zero_extendqisi2
 8102              	.L854:
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8103              		.loc 1 1809 0
 8104 4748 0030A0E3 		mov	r3, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 8105              		.loc 1 1813 0
 8106 474c 0C00A0E1 		mov	r0, ip
 8107 4750 8C199FE5 		ldr	r1, .L904+96
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8108              		.loc 1 1806 0
 8109 4754 28E0C8E5 		strb	lr, [r8, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8110              		.loc 1 1808 0
 8111 4758 2920C8E5 		strb	r2, [r8, #41]
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8112              		.loc 1 1809 0
 8113 475c 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 8114              		.loc 1 1819 0
 8115 4760 28308DE5 		str	r3, [sp, #40]
1813:../uvc.c      **** 		 	 if(Len == 2){
 8116              		.loc 1 1813 0
 8117 4764 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8118              	.LVL893:
1819:../uvc.c      **** 		 	 }
 8119              		.loc 1 1819 0
 8120 4768 00C0A0E3 		mov	ip, #0
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8121              		.loc 1 1818 0
 8122 476c 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 8123              	.LVL894:
1819:../uvc.c      **** 		 	 }
 8124              		.loc 1 1819 0
 8125 4770 2A40D8E5 		ldrb	r4, [r8, #42]	@ zero_extendqisi2
 8126              	.LVL895:
 8127 4774 28E09DE5 		ldr	lr, [sp, #40]
 8128 4778 530100EA 		b	.L648
 8129              	.LVL896:
 8130              	.L625:
 8131              	.LBE204:
 8132              	.LBE203:
3939:../uvc.c      ****      		break;
 8133              		.loc 1 3939 0
 8134 477c 0500A0E3 		mov	r0, #5
 8135 4780 FEFFFFEB 		bl	ControlHandle
 8136              	.LVL897:
 8137 4784 44309DE5 		ldr	r3, [sp, #68]
 8138 4788 77FEFFEA 		b	.L617
 8139              	.L876:
 8140              	.LVL898:
 8141              	.LBB215:
 8142              	.LBB216:
1359:../uvc.c      ****     /*
 8143              		.loc 1 1359 0
 8144 478c 40399FE5 		ldr	r3, .L904+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8145              		.loc 1 1348 0
 8146 4790 6C07DBE5 		ldrb	r0, [fp, #1900]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8147              		.loc 1 1359 0
 8148 4794 0040D3E5 		ldrb	r4, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8149              		.loc 1 1349 0
 8150 4798 6D17DBE5 		ldrb	r1, [fp, #1901]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8151              		.loc 1 1350 0
 8152 479c 7B27DBE5 		ldrb	r2, [fp, #1915]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8153              		.loc 1 1351 0
 8154 47a0 6E37DBE5 		ldrb	r3, [fp, #1902]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8155              		.loc 1 1349 0
 8156 47a4 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8157              		.loc 1 1350 0
 8158 47a8 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8159              		.loc 1 1367 0
 8160 47ac 830054E3 		cmp	r4, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8161              		.loc 1 1348 0
 8162 47b0 FFC000E2 		and	ip, r0, #255
 8163              	.LVL899:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8164              		.loc 1 1349 0
 8165 47b4 2C108DE5 		str	r1, [sp, #44]
 8166              	.LVL900:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8167              		.loc 1 1350 0
 8168 47b8 28208DE5 		str	r2, [sp, #40]
 8169              	.LVL901:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8170              		.loc 1 1351 0
 8171 47bc FF3003E2 		and	r3, r3, #255
 8172              	.LVL902:
1367:../uvc.c      **** 		 {
 8173              		.loc 1 1367 0
 8174 47c0 4803000A 		beq	.L732
 8175 47c4 4A01009A 		bls	.L889
 8176 47c8 850054E3 		cmp	r4, #133
 8177 47cc 5D03000A 		beq	.L737
 8178 47d0 6E03003A 		bcc	.L738
 8179 47d4 860054E3 		cmp	r4, #134
 8180 47d8 4F02000A 		beq	.L739
 8181 47dc 870054E3 		cmp	r4, #135
 8182 47e0 EE02001A 		bne	.L731
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8183              		.loc 1 1801 0
 8184 47e4 020053E3 		cmp	r3, #2
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8185              		.loc 1 1802 0
 8186 47e8 77C7DBE5 		ldrb	ip, [fp, #1911]	@ zero_extendqisi2
 8187              	.LVL903:
1813:../uvc.c      **** 		 	 if(Len == 2){
 8188              		.loc 1 1813 0
 8189 47ec 0300A0E1 		mov	r0, r3
 8190              	.LVL904:
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8191              		.loc 1 1803 0
 8192 47f0 7827DBE5 		ldrb	r2, [fp, #1912]	@ zero_extendqisi2
1801:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8193              		.loc 1 1801 0
 8194 47f4 1402000A 		beq	.L871
 8195              	.L744:
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8196              		.loc 1 1809 0
 8197 47f8 0030A0E3 		mov	r3, #0
 8198              	.LVL905:
1813:../uvc.c      **** 		 	 if(Len == 2){
 8199              		.loc 1 1813 0
 8200 47fc E0189FE5 		ldr	r1, .L904+96
1806:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8201              		.loc 1 1806 0
 8202 4800 28C0C8E5 		strb	ip, [r8, #40]
1808:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8203              		.loc 1 1808 0
 8204 4804 2920C8E5 		strb	r2, [r8, #41]
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8205              		.loc 1 1809 0
 8206 4808 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 8207              		.loc 1 1819 0
 8208 480c 24308DE5 		str	r3, [sp, #36]
 8209 4810 0050A0E3 		mov	r5, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 8210              		.loc 1 1813 0
 8211 4814 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8212              	.LVL906:
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8213              		.loc 1 1818 0
 8214 4818 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 8215              	.LVL907:
1819:../uvc.c      **** 		 	 }
 8216              		.loc 1 1819 0
 8217 481c 2A30D8E5 		ldrb	r3, [r8, #42]	@ zero_extendqisi2
 8218              	.LVL908:
 8219 4820 24C09DE5 		ldr	ip, [sp, #36]
 8220 4824 730100EA 		b	.L741
 8221              	.LVL909:
 8222              	.L627:
 8223              	.LBE216:
 8224              	.LBE215:
3928:../uvc.c      **** 			break;
 8225              		.loc 1 3928 0
 8226 4828 0200A0E3 		mov	r0, #2
 8227 482c FEFFFFEB 		bl	ControlHandle
 8228              	.LVL910:
 8229 4830 44309DE5 		ldr	r3, [sp, #68]
 8230 4834 4CFEFFEA 		b	.L617
 8231              	.L757:
 8232              	.LBE273:
 8233              	.LBE286:
 8234              	.LBB287:
 8235              	.LBB160:
4217:../uvc.c      ****     {
 8236              		.loc 1 4217 0
 8237 4838 010B53E3 		cmp	r3, #1024
 8238 483c 7900000A 		beq	.L760
 8239 4840 050C53E3 		cmp	r3, #1280
 8240 4844 43FEFF1A 		bne	.L618
 8241              	.LVL911:
4237:../uvc.c      ****     		break;
 8242              		.loc 1 4237 0
 8243 4848 1400A0E3 		mov	r0, #20
 8244 484c FEFFFFEB 		bl	ControlHandle
 8245              	.LVL912:
 8246 4850 44309DE5 		ldr	r3, [sp, #68]
 8247 4854 44FEFFEA 		b	.L617
 8248              	.L881:
4217:../uvc.c      ****     {
 8249              		.loc 1 4217 0
 8250 4858 070C53E3 		cmp	r3, #1792
 8251 485c 6D00000A 		beq	.L764
 8252 4860 020B53E3 		cmp	r3, #2048
 8253 4864 3BFEFF1A 		bne	.L618
 8254              	.LVL913:
4249:../uvc.c      ****     		break;
 8255              		.loc 1 4249 0
 8256 4868 1700A0E3 		mov	r0, #23
 8257 486c FEFFFFEB 		bl	ControlHandle
 8258              	.LVL914:
 8259 4870 44309DE5 		ldr	r3, [sp, #68]
 8260 4874 3CFEFFEA 		b	.L617
 8261              	.L885:
4217:../uvc.c      ****     {
 8262              		.loc 1 4217 0
 8263 4878 160C53E3 		cmp	r3, #5632
 8264 487c 2E00000A 		beq	.L780
 8265 4880 170C53E3 		cmp	r3, #5888
 8266 4884 33FEFF1A 		bne	.L618
4317:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
 8267              		.loc 1 4317 0
 8268 4888 2A00A0E3 		mov	r0, #42
 8269 488c FEFFFFEB 		bl	ControlHandle
 8270              	.LVL915:
4318:../uvc.c      ****    		break;
 8271              		.loc 1 4318 0
 8272 4890 3C389FE5 		ldr	r3, .L904+80
 8273 4894 B020D4E1 		ldrh	r2, [r4]
 8274 4898 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8275 489c 0400A0E3 		mov	r0, #4
 8276 48a0 08189FE5 		ldr	r1, .L904+44
 8277 48a4 FEFFFFEB 		bl	CyU3PDebugPrint
 8278              	.LVL916:
 8279 48a8 44309DE5 		ldr	r3, [sp, #68]
 8280 48ac 2EFEFFEA 		b	.L617
 8281              	.L884:
4217:../uvc.c      ****     {
 8282              		.loc 1 4217 0
 8283 48b0 0F0C53E3 		cmp	r3, #3840
 8284 48b4 1C00000A 		beq	.L773
 8285 48b8 010A53E3 		cmp	r3, #4096
 8286 48bc 25FEFF1A 		bne	.L618
 8287              	.LVL917:
4286:../uvc.c      ****     		break;
 8288              		.loc 1 4286 0
 8289 48c0 1F00A0E3 		mov	r0, #31
 8290 48c4 FEFFFFEB 		bl	ControlHandle
 8291              	.LVL918:
 8292 48c8 44309DE5 		ldr	r3, [sp, #68]
 8293 48cc 26FEFFEA 		b	.L617
 8294              	.LVL919:
 8295              	.L882:
 8296 48d0 0030A0E1 		mov	r3, r0
 8297              	.LBE160:
 8298              	.LBE287:
4905:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8299              		.loc 1 4905 0
 8300 48d4 0320A0E1 		mov	r2, r3
 8301 48d8 0500A0E1 		mov	r0, r5
 8302              	.LVL920:
 8303 48dc D0179FE5 		ldr	r1, .L904+48
 8304 48e0 20308DE5 		str	r3, [sp, #32]
 8305 48e4 FEFFFFEB 		bl	CyU3PDebugPrint
 8306              	.LVL921:
4906:../uvc.c      **** 					}
 8307              		.loc 1 4906 0
 8308 48e8 20309DE5 		ldr	r3, [sp, #32]
 8309 48ec 0300A0E1 		mov	r0, r3
 8310 48f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 8311              	.LVL922:
 8312              	.L758:
 8313              	.LBB288:
 8314              	.LBB161:
4221:../uvc.c      ****     		break;
 8315              		.loc 1 4221 0
 8316 48f4 1000A0E3 		mov	r0, #16
 8317 48f8 FEFFFFEB 		bl	ControlHandle
 8318              	.LVL923:
 8319 48fc 44309DE5 		ldr	r3, [sp, #68]
 8320 4900 19FEFFEA 		b	.L617
 8321              	.L783:
4337:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
 8322              		.loc 1 4337 0
 8323 4904 2F00A0E3 		mov	r0, #47
 8324 4908 FEFFFFEB 		bl	ControlHandle
 8325              	.LVL924:
4338:../uvc.c      ****     		break;
 8326              		.loc 1 4338 0
 8327 490c C0379FE5 		ldr	r3, .L904+80
 8328 4910 B020D4E1 		ldrh	r2, [r4]
 8329 4914 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8330 4918 0400A0E3 		mov	r0, #4
 8331 491c 94179FE5 		ldr	r1, .L904+52
 8332 4920 FEFFFFEB 		bl	CyU3PDebugPrint
 8333              	.LVL925:
 8334 4924 44309DE5 		ldr	r3, [sp, #68]
 8335 4928 0FFEFFEA 		b	.L617
 8336              	.L773:
 8337              	.LVL926:
4282:../uvc.c      ****     		break;
 8338              		.loc 1 4282 0
 8339 492c 1E00A0E3 		mov	r0, #30
 8340 4930 FEFFFFEB 		bl	ControlHandle
 8341              	.LVL927:
 8342 4934 44309DE5 		ldr	r3, [sp, #68]
 8343 4938 0BFEFFEA 		b	.L617
 8344              	.L780:
4312:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
 8345              		.loc 1 4312 0
 8346 493c 2900A0E3 		mov	r0, #41
 8347 4940 FEFFFFEB 		bl	ControlHandle
 8348              	.LVL928:
4313:../uvc.c      ****     		break;
 8349              		.loc 1 4313 0
 8350 4944 88379FE5 		ldr	r3, .L904+80
 8351 4948 B020D4E1 		ldrh	r2, [r4]
 8352 494c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8353 4950 0400A0E3 		mov	r0, #4
 8354 4954 60179FE5 		ldr	r1, .L904+56
 8355 4958 FEFFFFEB 		bl	CyU3PDebugPrint
 8356              	.LVL929:
 8357 495c 44309DE5 		ldr	r3, [sp, #68]
 8358 4960 01FEFFEA 		b	.L617
 8359              	.L767:
 8360              	.LVL930:
4268:../uvc.c      ****     		break;
 8361              		.loc 1 4268 0
 8362 4964 1B00A0E3 		mov	r0, #27
 8363 4968 FEFFFFEB 		bl	ControlHandle
 8364              	.LVL931:
 8365 496c 44309DE5 		ldr	r3, [sp, #68]
 8366 4970 FDFDFFEA 		b	.L617
 8367              	.L776:
 8368              	.LVL932:
 8369              	.LBB144:
 8370              	.LBB145:
1359:../uvc.c      ****     /*
 8371              		.loc 1 1359 0
 8372 4974 58C79FE5 		ldr	ip, .L904+80
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8373              		.loc 1 1341 0
 8374 4978 8017DBE5 		ldrb	r1, [fp, #1920]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8375              		.loc 1 1359 0
 8376 497c 00C0DCE5 		ldrb	ip, [ip]	@ zero_extendqisi2
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8377              		.loc 1 1342 0
 8378 4980 8157DBE5 		ldrb	r5, [fp, #1921]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8379              		.loc 1 1343 0
 8380 4984 8F27DBE5 		ldrb	r2, [fp, #1935]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8381              		.loc 1 1344 0
 8382 4988 8237DBE5 		ldrb	r3, [fp, #1922]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8383              		.loc 1 1341 0
 8384 498c FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8385              		.loc 1 1343 0
 8386 4990 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8387              		.loc 1 1367 0
 8388 4994 83005CE3 		cmp	ip, #131
1359:../uvc.c      ****     /*
 8389              		.loc 1 1359 0
 8390 4998 28C08DE5 		str	ip, [sp, #40]
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8391              		.loc 1 1341 0
 8392 499c 30108DE5 		str	r1, [sp, #48]
 8393              	.LVL933:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8394              		.loc 1 1342 0
 8395 49a0 FF5005E2 		and	r5, r5, #255
 8396              	.LVL934:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8397              		.loc 1 1343 0
 8398 49a4 2C208DE5 		str	r2, [sp, #44]
 8399              	.LVL935:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8400              		.loc 1 1344 0
 8401 49a8 FF3003E2 		and	r3, r3, #255
 8402              	.LVL936:
1367:../uvc.c      **** 		 {
 8403              		.loc 1 1367 0
 8404 49ac 9C03000A 		beq	.L786
 8405 49b0 4B02009A 		bls	.L890
 8406 49b4 28C09DE5 		ldr	ip, [sp, #40]
 8407 49b8 85005CE3 		cmp	ip, #133
 8408 49bc 2E02000A 		beq	.L791
 8409 49c0 E003003A 		bcc	.L792
 8410 49c4 86005CE3 		cmp	ip, #134
 8411 49c8 CF03000A 		beq	.L793
 8412 49cc 87005CE3 		cmp	ip, #135
 8413 49d0 9F03001A 		bne	.L785
1788:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8414              		.loc 1 1788 0
 8415 49d4 020053E3 		cmp	r3, #2
1789:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8416              		.loc 1 1789 0
 8417 49d8 8BC7DBE5 		ldrb	ip, [fp, #1931]	@ zero_extendqisi2
1813:../uvc.c      **** 		 	 if(Len == 2){
 8418              		.loc 1 1813 0
 8419 49dc 0300A0E1 		mov	r0, r3
1790:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8420              		.loc 1 1790 0
 8421 49e0 8C27DBE5 		ldrb	r2, [fp, #1932]	@ zero_extendqisi2
1788:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8422              		.loc 1 1788 0
 8423 49e4 A903000A 		beq	.L872
 8424              	.L800:
1795:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8425              		.loc 1 1795 0
 8426 49e8 0030A0E3 		mov	r3, #0
 8427              	.LVL937:
1813:../uvc.c      **** 		 	 if(Len == 2){
 8428              		.loc 1 1813 0
 8429 49ec F0169FE5 		ldr	r1, .L904+96
1794:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8430              		.loc 1 1794 0
 8431 49f0 28C0C8E5 		strb	ip, [r8, #40]
1796:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8432              		.loc 1 1796 0
 8433 49f4 2A20C8E5 		strb	r2, [r8, #42]
1795:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8434              		.loc 1 1795 0
 8435 49f8 2930C8E5 		strb	r3, [r8, #41]
1797:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8436              		.loc 1 1797 0
 8437 49fc 2B30C8E5 		strb	r3, [r8, #43]
1819:../uvc.c      **** 		 	 }
 8438              		.loc 1 1819 0
 8439 4a00 24308DE5 		str	r3, [sp, #36]
 8440 4a04 0040A0E3 		mov	r4, #0
1813:../uvc.c      **** 		 	 if(Len == 2){
 8441              		.loc 1 1813 0
 8442 4a08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8443              	.LVL938:
1818:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8444              		.loc 1 1818 0
 8445 4a0c 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 8446              	.LVL939:
1819:../uvc.c      **** 		 	 }
 8447              		.loc 1 1819 0
 8448 4a10 2A50D8E5 		ldrb	r5, [r8, #42]	@ zero_extendqisi2
 8449              	.LVL940:
 8450 4a14 220200EA 		b	.L795
 8451              	.LVL941:
 8452              	.L764:
 8453              	.LBE145:
 8454              	.LBE144:
4245:../uvc.c      ****     		break;
 8455              		.loc 1 4245 0
 8456 4a18 1600A0E3 		mov	r0, #22
 8457 4a1c FEFFFFEB 		bl	ControlHandle
 8458              	.LVL942:
 8459 4a20 44309DE5 		ldr	r3, [sp, #68]
 8460 4a24 D0FDFFEA 		b	.L617
 8461              	.L760:
 8462              	.LVL943:
4233:../uvc.c      ****     		break;
 8463              		.loc 1 4233 0
 8464 4a28 1300A0E3 		mov	r0, #19
 8465 4a2c FEFFFFEB 		bl	ControlHandle
 8466              	.LVL944:
 8467 4a30 44309DE5 		ldr	r3, [sp, #68]
 8468 4a34 CCFDFFEA 		b	.L617
 8469              	.LVL945:
 8470              	.L887:
 8471              	.LBE161:
 8472              	.LBE288:
 8473              	.LBB289:
 8474              	.LBB274:
 8475              	.LBB226:
 8476              	.LBB192:
1367:../uvc.c      **** 		 {
 8477              		.loc 1 1367 0
 8478 4a38 81005CE3 		cmp	ip, #129
 8479 4a3c 3203000A 		beq	.L710
 8480 4a40 E601008A 		bhi	.L711
 8481 4a44 01005CE3 		cmp	ip, #1
 8482 4a48 6203001A 		bne	.L707
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8483              		.loc 1 1823 0
 8484 4a4c 2000A0E3 		mov	r0, #32
 8485 4a50 8C169FE5 		ldr	r1, .L904+96
 8486 4a54 42208DE2 		add	r2, sp, #66
 8487 4a58 20308DE5 		str	r3, [sp, #32]
 8488 4a5c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8489              	.LVL946:
1825:../uvc.c      **** 			   {
 8490              		.loc 1 1825 0
 8491 4a60 20309DE5 		ldr	r3, [sp, #32]
 8492 4a64 000050E3 		cmp	r0, #0
 8493 4a68 34008DE5 		str	r0, [sp, #52]
 8494 4a6c 0005001A 		bne	.L723
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8495              		.loc 1 1827 0
 8496 4a70 020053E3 		cmp	r3, #2
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8497              		.loc 1 1828 0
 8498 4a74 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8499              		.loc 1 1827 0
 8500 4a78 D404000A 		beq	.L891
 8501              	.LVL947:
1832:../uvc.c      **** 				 }
 8502              		.loc 1 1832 0
 8503 4a7c 2AC0D9E5 		ldrb	ip, [r9, #42]	@ zero_extendqisi2
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8504              		.loc 1 1835 0
 8505 4a80 38308DE5 		str	r3, [sp, #56]
1832:../uvc.c      **** 				 }
 8506              		.loc 1 1832 0
 8507 4a84 24C08DE5 		str	ip, [sp, #36]
 8508              	.LVL948:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8509              		.loc 1 1835 0
 8510 4a88 2CC09DE5 		ldr	ip, [sp, #44]
 8511 4a8c 08308DE5 		str	r3, [sp, #8]
 8512 4a90 04C08DE5 		str	ip, [sp, #4]
 8513 4a94 24C09DE5 		ldr	ip, [sp, #36]
 8514 4a98 00508DE5 		str	r5, [sp]
 8515 4a9c 10C08DE5 		str	ip, [sp, #16]
 8516 4aa0 0C408DE5 		str	r4, [sp, #12]
 8517 4aa4 0400A0E3 		mov	r0, #4
 8518              	.LVL949:
 8519 4aa8 40169FE5 		ldr	r1, .L904+108
 8520 4aac 0920A0E3 		mov	r2, #9
 8521 4ab0 30309DE5 		ldr	r3, [sp, #48]
 8522 4ab4 FEFFFFEB 		bl	CyU3PDebugPrint
 8523              	.LVL950:
2241:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 8524              		.loc 1 2241 0
 8525 4ab8 38C09DE5 		ldr	ip, [sp, #56]
 8526 4abc 04005CE3 		cmp	ip, #4
 8527 4ac0 9B04000A 		beq	.L892
 8528              	.LVL951:
 8529              	.L728:
2258:../uvc.c      **** 			 	 			 break;
 8530              		.loc 1 2258 0
 8531 4ac4 6627DBE5 		ldrb	r2, [fp, #1894]	@ zero_extendqisi2
2257:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8532              		.loc 1 2257 0
 8533 4ac8 38C09DE5 		ldr	ip, [sp, #56]
2258:../uvc.c      **** 			 	 			 break;
 8534              		.loc 1 2258 0
 8535 4acc 6537DBE5 		ldrb	r3, [fp, #1893]	@ zero_extendqisi2
2257:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8536              		.loc 1 2257 0
 8537 4ad0 04169FE5 		ldr	r1, .L904+88
 8538 4ad4 0C108DE8 		stmia	sp, {r2, r3, ip}
 8539 4ad8 24309DE5 		ldr	r3, [sp, #36]
 8540 4adc 0400A0E3 		mov	r0, #4
 8541 4ae0 0420A0E1 		mov	r2, r4
 8542 4ae4 FEFFFFEB 		bl	CyU3PDebugPrint
 8543              	.LVL952:
 8544 4ae8 24109DE5 		ldr	r1, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8545              		.loc 1 1355 0
 8546 4aec FF50A0E3 		mov	r5, #255
 8547 4af0 05C0A0E1 		mov	ip, r5
 8548              	.LVL953:
 8549              	.L717:
2274:../uvc.c      **** }
 8550              		.loc 1 2274 0
 8551 4af4 02108DE8 		stmia	sp, {r1, ip}
 8552 4af8 28209DE5 		ldr	r2, [sp, #40]
 8553 4afc 08508DE5 		str	r5, [sp, #8]
 8554 4b00 FD0000EA 		b	.L870
 8555              	.LVL954:
 8556              	.L886:
 8557              	.LBE192:
 8558              	.LBE226:
 8559              	.LBB227:
 8560              	.LBB181:
1367:../uvc.c      **** 		 {
 8561              		.loc 1 1367 0
 8562 4b04 81005EE3 		cmp	lr, #129
 8563 4b08 5104000A 		beq	.L677
 8564 4b0c 5301008A 		bhi	.L678
 8565 4b10 01005EE3 		cmp	lr, #1
 8566 4b14 1803001A 		bne	.L674
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8567              		.loc 1 1823 0
 8568 4b18 42208DE2 		add	r2, sp, #66
 8569 4b1c 2000A0E3 		mov	r0, #32
 8570 4b20 BC159FE5 		ldr	r1, .L904+96
 8571 4b24 20308DE5 		str	r3, [sp, #32]
 8572 4b28 1CC08DE5 		str	ip, [sp, #28]
 8573 4b2c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8574              	.LVL955:
1825:../uvc.c      **** 			   {
 8575              		.loc 1 1825 0
 8576 4b30 20309DE5 		ldr	r3, [sp, #32]
 8577 4b34 1CC09DE5 		ldr	ip, [sp, #28]
 8578 4b38 002050E2 		subs	r2, r0, #0
 8579 4b3c 6E04001A 		bne	.L688
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8580              		.loc 1 1827 0
 8581 4b40 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 				 }else{
 8582              		.loc 1 1829 0
 8583 4b44 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1832:../uvc.c      **** 				 }
 8584              		.loc 1 1832 0
 8585 4b48 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8586              	.LVL956:
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8587              		.loc 1 1828 0
 8588 4b4c 2850D9E5 		ldrb	r5, [r9, #40]	@ zero_extendqisi2
 8589              	.LVL957:
1829:../uvc.c      **** 				 }else{
 8590              		.loc 1 1829 0
 8591 4b50 28E08D05 		streq	lr, [sp, #40]
 8592              	.LVL958:
1832:../uvc.c      **** 				 }
 8593              		.loc 1 1832 0
 8594 4b54 28008D15 		strne	r0, [sp, #40]
 8595              	.LVL959:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8596              		.loc 1 1835 0
 8597 4b58 00C08DE5 		str	ip, [sp]
 8598 4b5c 28C09DE5 		ldr	ip, [sp, #40]
 8599 4b60 0400A0E3 		mov	r0, #4
 8600 4b64 08308DE5 		str	r3, [sp, #8]
 8601 4b68 0C508DE5 		str	r5, [sp, #12]
 8602 4b6c 2C309DE5 		ldr	r3, [sp, #44]
 8603 4b70 10C08DE5 		str	ip, [sp, #16]
 8604 4b74 0020A0E1 		mov	r2, r0
 8605              	.LVL960:
 8606 4b78 70159FE5 		ldr	r1, .L904+108
 8607 4b7c 04408DE5 		str	r4, [sp, #4]
 8608 4b80 FEFFFFEB 		bl	CyU3PDebugPrint
 8609              	.LVL961:
2134:../uvc.c      **** 							 {
 8610              		.loc 1 2134 0
 8611 4b84 000055E3 		cmp	r5, #0
2131:../uvc.c      **** 							 //Data0 = Data0 - 1;
 8612              		.loc 1 2131 0
 8613 4b88 7D55CBE5 		strb	r5, [fp, #1405]
 8614              	.LVL962:
2137:../uvc.c      **** 							 }
 8615              		.loc 1 2137 0
 8616 4b8c 0130A003 		moveq	r3, #1
 8617              	.LVL963:
2142:../uvc.c      **** 							 }
 8618              		.loc 1 2142 0
 8619 4b90 0030A013 		movne	r3, #0
2141:../uvc.c      **** 								 is60Hz = CyFalse;
 8620              		.loc 1 2141 0
 8621 4b94 0150A013 		movne	r5, #1
2144:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 8622              		.loc 1 2144 0
 8623 4b98 0400A0E3 		mov	r0, #4
 8624 4b9c 1C159FE5 		ldr	r1, .L904+60
 8625 4ba0 0520A0E1 		mov	r2, r5
2142:../uvc.c      **** 							 }
 8626              		.loc 1 2142 0
 8627 4ba4 6C3088E5 		str	r3, [r8, #108]
 8628              	.LVL964:
2144:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 8629              		.loc 1 2144 0
 8630 4ba8 6C3098E5 		ldr	r3, [r8, #108]
 8631 4bac FEFFFFEB 		bl	CyU3PDebugPrint
 8632              	.LVL965:
2145:../uvc.c      **** 							 {
 8633              		.loc 1 2145 0
 8634 4bb0 883098E5 		ldr	r3, [r8, #136]
 8635 4bb4 010053E3 		cmp	r3, #1
 8636 4bb8 A303000A 		beq	.L893
 8637              	.L693:
 8638 4bbc 28109DE5 		ldr	r1, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8639              		.loc 1 1355 0
 8640 4bc0 FF40A0E3 		mov	r4, #255
 8641              	.LVL966:
2173:../uvc.c      **** 							 break;
 8642              		.loc 1 2173 0
 8643 4bc4 0130A0E3 		mov	r3, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8644              		.loc 1 1355 0
 8645 4bc8 04C0A0E1 		mov	ip, r4
2173:../uvc.c      **** 							 break;
 8646              		.loc 1 2173 0
 8647 4bcc 8135CBE5 		strb	r3, [fp, #1409]
 8648              	.LVL967:
 8649              	.L684:
2274:../uvc.c      **** }
 8650              		.loc 1 2274 0
 8651 4bd0 02108DE8 		stmia	sp, {r1, ip}
 8652 4bd4 24209DE5 		ldr	r2, [sp, #36]
 8653 4bd8 08408DE5 		str	r4, [sp, #8]
 8654 4bdc 880000EA 		b	.L869
 8655              	.LVL968:
 8656              	.L888:
 8657              	.LBE181:
 8658              	.LBE227:
 8659              	.LBB228:
 8660              	.LBB205:
1367:../uvc.c      **** 		 {
 8661              		.loc 1 1367 0
 8662 4be0 810052E3 		cmp	r2, #129
 8663 4be4 F701000A 		beq	.L641
 8664 4be8 4301008A 		bhi	.L642
 8665 4bec 010052E3 		cmp	r2, #1
 8666 4bf0 0B02001A 		bne	.L638
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8667              		.loc 1 1823 0
 8668 4bf4 42208DE2 		add	r2, sp, #66
 8669 4bf8 2000A0E3 		mov	r0, #32
 8670 4bfc E0149FE5 		ldr	r1, .L904+96
 8671 4c00 1CC08DE5 		str	ip, [sp, #28]
 8672 4c04 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8673              	.LVL969:
1825:../uvc.c      **** 			   {
 8674              		.loc 1 1825 0
 8675 4c08 1CC09DE5 		ldr	ip, [sp, #28]
 8676 4c0c 002050E2 		subs	r2, r0, #0
 8677 4c10 3104001A 		bne	.L654
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8678              		.loc 1 1827 0
 8679 4c14 02005CE3 		cmp	ip, #2
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8680              		.loc 1 1828 0
 8681 4c18 28E0D905 		ldreqb	lr, [r9, #40]	@ zero_extendqisi2
1831:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8682              		.loc 1 1831 0
 8683 4c1c 2810D915 		ldrneb	r1, [r9, #40]	@ zero_extendqisi2
1829:../uvc.c      **** 				 }else{
 8684              		.loc 1 1829 0
 8685 4c20 2900D905 		ldreqb	r0, [r9, #41]	@ zero_extendqisi2
 8686              	.LVL970:
1832:../uvc.c      **** 				 }
 8687              		.loc 1 1832 0
 8688 4c24 2A20D915 		ldrneb	r2, [r9, #42]	@ zero_extendqisi2
 8689              	.LVL971:
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8690              		.loc 1 1828 0
 8691 4c28 30E08D05 		streq	lr, [sp, #48]
 8692              	.LVL972:
1831:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8693              		.loc 1 1831 0
 8694 4c2c 30108D15 		strne	r1, [sp, #48]
 8695              	.LVL973:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8696              		.loc 1 1835 0
 8697 4c30 30108DE8 		stmia	sp, {r4, r5, ip}
 8698 4c34 30C09DE5 		ldr	ip, [sp, #48]
1829:../uvc.c      **** 				 }else{
 8699              		.loc 1 1829 0
 8700 4c38 28008D05 		streq	r0, [sp, #40]
 8701              	.LVL974:
1832:../uvc.c      **** 				 }
 8702              		.loc 1 1832 0
 8703 4c3c 28208D15 		strne	r2, [sp, #40]
 8704              	.LVL975:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8705              		.loc 1 1835 0
 8706 4c40 0CC08DE5 		str	ip, [sp, #12]
 8707 4c44 28C09DE5 		ldr	ip, [sp, #40]
 8708 4c48 0020A0E3 		mov	r2, #0
 8709 4c4c 2C309DE5 		ldr	r3, [sp, #44]
 8710 4c50 10C08DE5 		str	ip, [sp, #16]
 8711 4c54 94149FE5 		ldr	r1, .L904+108
 8712 4c58 0400A0E3 		mov	r0, #4
 8713 4c5c FEFFFFEB 		bl	CyU3PDebugPrint
 8714              	.LVL976:
2189:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 8715              		.loc 1 2189 0
 8716 4c60 30C09DE5 		ldr	ip, [sp, #48]
2199:../uvc.c      **** 					 		 }
 8717              		.loc 1 2199 0
 8718 4c64 30E09DE5 		ldr	lr, [sp, #48]
2189:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 8719              		.loc 1 2189 0
 8720 4c68 A9C5CBE5 		strb	ip, [fp, #1449]
2199:../uvc.c      **** 					 		 }
 8721              		.loc 1 2199 0
 8722 4c6c 05C5DBE5 		ldrb	ip, [fp, #1285]	@ zero_extendqisi2
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8723              		.loc 1 2202 0
 8724 4c70 7C449FE5 		ldr	r4, .L904+112
 8725              	.LVL977:
2199:../uvc.c      **** 					 		 }
 8726              		.loc 1 2199 0
 8727 4c74 8CC38EE1 		orr	ip, lr, ip, asl #7
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8728              		.loc 1 2202 0
 8729 4c78 1C0094E5 		ldr	r0, [r4, #28]
2199:../uvc.c      **** 					 		 }
 8730              		.loc 1 2199 0
 8731 4c7c FFC00CE2 		and	ip, ip, #255
 8732              	.LVL978:
2202:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8733              		.loc 1 2202 0
 8734 4c80 0010E0E3 		mvn	r1, #0
 8735 4c84 1CC08DE5 		str	ip, [sp, #28]
 8736 4c88 FEFFFFEB 		bl	_txe_mutex_get
 8737              	.LVL979:
2203:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8738              		.loc 1 2203 0
 8739 4c8c 1CC09DE5 		ldr	ip, [sp, #28]
 8740 4c90 0010A0E3 		mov	r1, #0
 8741 4c94 0530A0E1 		mov	r3, r5
 8742 4c98 00C08DE5 		str	ip, [sp]
 8743 4c9c 2C209DE5 		ldr	r2, [sp, #44]
 8744 4ca0 0400A0E1 		mov	r0, r4
 8745 4ca4 04108DE5 		str	r1, [sp, #4]
 8746 4ca8 FEFFFFEB 		bl	cmdSet
 8747              	.LVL980:
2204:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8748              		.loc 1 2204 0
 8749 4cac 1C0094E5 		ldr	r0, [r4, #28]
 8750 4cb0 FEFFFFEB 		bl	_txe_mutex_put
 8751              	.LVL981:
2205:../uvc.c      **** 					 		 break;
 8752              		.loc 1 2205 0
 8753 4cb4 0130A0E3 		mov	r3, #1
 8754 4cb8 AD35CBE5 		strb	r3, [fp, #1453]
 8755 4cbc 1CC09DE5 		ldr	ip, [sp, #28]
 8756 4cc0 28E09DE5 		ldr	lr, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8757              		.loc 1 1355 0
 8758 4cc4 FF40A0E3 		mov	r4, #255
 8759 4cc8 0450A0E1 		mov	r5, r4
 8760              	.LVL982:
 8761              	.L648:
2274:../uvc.c      **** }
 8762              		.loc 1 2274 0
 8763 4ccc 0C30A0E1 		mov	r3, ip
 8764 4cd0 00E08DE5 		str	lr, [sp]
 8765 4cd4 04508DE5 		str	r5, [sp, #4]
 8766 4cd8 08408DE5 		str	r4, [sp, #8]
 8767 4cdc 24209DE5 		ldr	r2, [sp, #36]
 8768 4ce0 0400A0E3 		mov	r0, #4
 8769 4ce4 E4139FE5 		ldr	r1, .L904+76
 8770 4ce8 FEFFFFEB 		bl	CyU3PDebugPrint
 8771              	.LVL983:
 8772 4cec 44309DE5 		ldr	r3, [sp, #68]
 8773 4cf0 1DFDFFEA 		b	.L617
 8774              	.LVL984:
 8775              	.L889:
 8776              	.LBE205:
 8777              	.LBE228:
 8778              	.LBB229:
 8779              	.LBB217:
1367:../uvc.c      **** 		 {
 8780              		.loc 1 1367 0
 8781 4cf4 810054E3 		cmp	r4, #129
 8782 4cf8 B003000A 		beq	.L734
 8783 4cfc CD00008A 		bhi	.L735
 8784 4d00 010054E3 		cmp	r4, #1
 8785 4d04 A501001A 		bne	.L731
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8786              		.loc 1 1823 0
 8787 4d08 42208DE2 		add	r2, sp, #66
 8788 4d0c 2000A0E3 		mov	r0, #32
 8789 4d10 CC139FE5 		ldr	r1, .L904+96
 8790 4d14 20308DE5 		str	r3, [sp, #32]
 8791 4d18 1CC08DE5 		str	ip, [sp, #28]
 8792 4d1c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8793              	.LVL985:
1825:../uvc.c      **** 			   {
 8794              		.loc 1 1825 0
 8795 4d20 20309DE5 		ldr	r3, [sp, #32]
 8796 4d24 1CC09DE5 		ldr	ip, [sp, #28]
 8797 4d28 002050E2 		subs	r2, r0, #0
 8798 4d2c EE03001A 		bne	.L745
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8799              		.loc 1 1827 0
 8800 4d30 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 				 }else{
 8801              		.loc 1 1829 0
 8802 4d34 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1832:../uvc.c      **** 				 }
 8803              		.loc 1 1832 0
 8804 4d38 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8805              	.LVL986:
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8806              		.loc 1 1828 0
 8807 4d3c 2850D9E5 		ldrb	r5, [r9, #40]	@ zero_extendqisi2
 8808              	.LVL987:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8809              		.loc 1 1835 0
 8810 4d40 28209DE5 		ldr	r2, [sp, #40]
 8811              	.LVL988:
1829:../uvc.c      **** 				 }else{
 8812              		.loc 1 1829 0
 8813 4d44 24E08D05 		streq	lr, [sp, #36]
 8814              	.LVL989:
1832:../uvc.c      **** 				 }
 8815              		.loc 1 1832 0
 8816 4d48 24008D15 		strne	r0, [sp, #36]
 8817              	.LVL990:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8818              		.loc 1 1835 0
 8819 4d4c 2C109DE5 		ldr	r1, [sp, #44]
 8820 4d50 2C008DE9 		stmib	sp, {r2, r3, r5}
 8821 4d54 24309DE5 		ldr	r3, [sp, #36]
 8822 4d58 0B20A0E3 		mov	r2, #11
 8823 4d5c 00108DE5 		str	r1, [sp]
 8824 4d60 10308DE5 		str	r3, [sp, #16]
 8825 4d64 84139FE5 		ldr	r1, .L904+108
 8826 4d68 0C30A0E1 		mov	r3, ip
 8827 4d6c 0400A0E3 		mov	r0, #4
 8828 4d70 1CC08DE5 		str	ip, [sp, #28]
 8829 4d74 FEFFFFEB 		bl	CyU3PDebugPrint
 8830              	.LVL991:
2178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8831              		.loc 1 2178 0
 8832 4d78 74E39FE5 		ldr	lr, .L904+112
 8833 4d7c 0010E0E3 		mvn	r1, #0
 8834 4d80 1C009EE5 		ldr	r0, [lr, #28]
 8835 4d84 FEFFFFEB 		bl	_txe_mutex_get
 8836              	.LVL992:
2179:../uvc.c      **** 							 dataIdx++;
 8837              		.loc 1 2179 0
 8838 4d88 1CC09DE5 		ldr	ip, [sp, #28]
 8839 4d8c 0030A0E3 		mov	r3, #0
 8840 4d90 0C20A0E1 		mov	r2, ip
 8841 4d94 04308DE5 		str	r3, [sp, #4]
 8842 4d98 0B10A0E3 		mov	r1, #11
 8843 4d9c 28309DE5 		ldr	r3, [sp, #40]
 8844 4da0 00508DE5 		str	r5, [sp]
 8845 4da4 48039FE5 		ldr	r0, .L904+112
 8846 4da8 FEFFFFEB 		bl	cmdSet
 8847              	.LVL993:
2181:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8848              		.loc 1 2181 0
 8849 4dac 24C09DE5 		ldr	ip, [sp, #36]
 8850 4db0 01E0A0E3 		mov	lr, #1
 8851 4db4 00C08DE5 		str	ip, [sp]
 8852 4db8 2C209DE5 		ldr	r2, [sp, #44]
 8853 4dbc 28309DE5 		ldr	r3, [sp, #40]
 8854 4dc0 04E08DE5 		str	lr, [sp, #4]
 8855 4dc4 0B10A0E3 		mov	r1, #11
 8856 4dc8 24039FE5 		ldr	r0, .L904+112
 8857 4dcc FEFFFFEB 		bl	cmdSet
 8858              	.LVL994:
2182:../uvc.c      **** 
 8859              		.loc 1 2182 0
 8860 4dd0 1C139FE5 		ldr	r1, .L904+112
 8861 4dd4 1C0091E5 		ldr	r0, [r1, #28]
 8862 4dd8 FEFFFFEB 		bl	_txe_mutex_put
 8863              	.LVL995:
2185:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8864              		.loc 1 2185 0
 8865 4ddc 24C09DE5 		ldr	ip, [sp, #36]
2186:../uvc.c      **** 							 break;
 8866              		.loc 1 2186 0
 8867 4de0 0120A0E3 		mov	r2, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8868              		.loc 1 1355 0
 8869 4de4 FF30A0E3 		mov	r3, #255
2186:../uvc.c      **** 							 break;
 8870              		.loc 1 2186 0
 8871 4de8 7D27CBE5 		strb	r2, [fp, #1917]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8872              		.loc 1 1355 0
 8873 4dec 0320A0E1 		mov	r2, r3
2184:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 8874              		.loc 1 2184 0
 8875 4df0 8455CBE5 		strb	r5, [fp, #1412]
2185:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8876              		.loc 1 2185 0
 8877 4df4 86C5CBE5 		strb	ip, [fp, #1414]
 8878              	.LVL996:
 8879              	.L741:
2274:../uvc.c      **** }
 8880              		.loc 1 2274 0
 8881 4df8 0C008DE9 		stmib	sp, {r2, r3}
 8882 4dfc 0420A0E1 		mov	r2, r4
 8883              	.LVL997:
 8884 4e00 00C08DE5 		str	ip, [sp]
 8885              	.LVL998:
 8886              	.L869:
 8887 4e04 0530A0E1 		mov	r3, r5
 8888 4e08 0400A0E3 		mov	r0, #4
 8889 4e0c BC129FE5 		ldr	r1, .L904+76
 8890 4e10 FEFFFFEB 		bl	CyU3PDebugPrint
 8891              	.LVL999:
 8892 4e14 44309DE5 		ldr	r3, [sp, #68]
 8893 4e18 D3FCFFEA 		b	.L617
 8894              	.LVL1000:
 8895              	.L879:
 8896              	.LBE217:
 8897              	.LBE229:
 8898              	.LBB230:
 8899              	.LBB172:
1367:../uvc.c      **** 		 {
 8900              		.loc 1 1367 0
 8901 4e1c 810055E3 		cmp	r5, #129
 8902 4e20 F901000A 		beq	.L660
 8903 4e24 7A00008A 		bhi	.L661
 8904 4e28 010055E3 		cmp	r5, #1
 8905 4e2c 1502001A 		bne	.L657
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8906              		.loc 1 1823 0
 8907 4e30 42208DE2 		add	r2, sp, #66
 8908 4e34 2000A0E3 		mov	r0, #32
 8909 4e38 A4129FE5 		ldr	r1, .L904+96
 8910 4e3c 20308DE5 		str	r3, [sp, #32]
 8911 4e40 1CC08DE5 		str	ip, [sp, #28]
 8912 4e44 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8913              	.LVL1001:
1825:../uvc.c      **** 			   {
 8914              		.loc 1 1825 0
 8915 4e48 20309DE5 		ldr	r3, [sp, #32]
 8916 4e4c 1CC09DE5 		ldr	ip, [sp, #28]
 8917 4e50 002050E2 		subs	r2, r0, #0
 8918 4e54 B203001A 		bne	.L671
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8919              		.loc 1 1827 0
 8920 4e58 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 				 }else{
 8921              		.loc 1 1829 0
 8922 4e5c 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1832:../uvc.c      **** 				 }
 8923              		.loc 1 1832 0
 8924 4e60 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8925              	.LVL1002:
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8926              		.loc 1 1828 0
 8927 4e64 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
 8928              	.LVL1003:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8929              		.loc 1 1835 0
 8930 4e68 28209DE5 		ldr	r2, [sp, #40]
 8931              	.LVL1004:
1829:../uvc.c      **** 				 }else{
 8932              		.loc 1 1829 0
 8933 4e6c 24E08D05 		streq	lr, [sp, #36]
 8934              	.LVL1005:
1832:../uvc.c      **** 				 }
 8935              		.loc 1 1832 0
 8936 4e70 24008D15 		strne	r0, [sp, #36]
 8937              	.LVL1006:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8938              		.loc 1 1835 0
 8939 4e74 2C109DE5 		ldr	r1, [sp, #44]
 8940 4e78 1C008DE9 		stmib	sp, {r2, r3, r4}
 8941 4e7c 24309DE5 		ldr	r3, [sp, #36]
 8942 4e80 0120A0E3 		mov	r2, #1
 8943 4e84 00108DE5 		str	r1, [sp]
 8944 4e88 10308DE5 		str	r3, [sp, #16]
 8945 4e8c 5C129FE5 		ldr	r1, .L904+108
 8946 4e90 0C30A0E1 		mov	r3, ip
 8947 4e94 0400A0E3 		mov	r0, #4
 8948 4e98 FEFFFFEB 		bl	CyU3PDebugPrint
 8949              	.LVL1007:
2097:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 8950              		.loc 1 2097 0
 8951 4e9c 50C29FE5 		ldr	ip, .L904+112
 8952 4ea0 0010E0E3 		mvn	r1, #0
 8953 4ea4 1C009CE5 		ldr	r0, [ip, #28]
 8954 4ea8 FEFFFFEB 		bl	_txe_mutex_get
 8955              	.LVL1008:
2106:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8956              		.loc 1 2106 0
 8957 4eac 0010A0E3 		mov	r1, #0
 8958 4eb0 2C209DE5 		ldr	r2, [sp, #44]
 8959 4eb4 28309DE5 		ldr	r3, [sp, #40]
 8960 4eb8 04108DE5 		str	r1, [sp, #4]
 8961 4ebc 00408DE5 		str	r4, [sp]
 8962 4ec0 0110A0E3 		mov	r1, #1
 8963 4ec4 28029FE5 		ldr	r0, .L904+112
 8964 4ec8 FEFFFFEB 		bl	cmdSet
 8965              	.LVL1009:
2107:../uvc.c      **** 
 8966              		.loc 1 2107 0
 8967 4ecc 20E29FE5 		ldr	lr, .L904+112
 8968 4ed0 1C009EE5 		ldr	r0, [lr, #28]
 8969 4ed4 FEFFFFEB 		bl	_txe_mutex_put
 8970              	.LVL1010:
 8971 4ed8 24C09DE5 		ldr	ip, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8972              		.loc 1 1355 0
 8973 4edc FF30A0E3 		mov	r3, #255
2110:../uvc.c      **** 							 break;
 8974              		.loc 1 2110 0
 8975 4ee0 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8976              		.loc 1 1355 0
 8977 4ee4 0320A0E1 		mov	r2, r3
2109:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8978              		.loc 1 2109 0
 8979 4ee8 5545CBE5 		strb	r4, [fp, #1365]
2110:../uvc.c      **** 							 break;
 8980              		.loc 1 2110 0
 8981 4eec 5915CBE5 		strb	r1, [fp, #1369]
 8982              	.LVL1011:
 8983              	.L667:
2274:../uvc.c      **** }
 8984              		.loc 1 2274 0
 8985 4ef0 0C008DE9 		stmib	sp, {r2, r3}
 8986 4ef4 0520A0E1 		mov	r2, r5
 8987              	.LVL1012:
 8988 4ef8 00C08DE5 		str	ip, [sp]
 8989              	.LVL1013:
 8990              	.L870:
 8991              	.LBE172:
 8992              	.LBE230:
 8993              	.LBB231:
 8994              	.LBB193:
 8995 4efc 0430A0E1 		mov	r3, r4
 8996 4f00 0400A0E3 		mov	r0, #4
 8997 4f04 C4119FE5 		ldr	r1, .L904+76
 8998 4f08 FEFFFFEB 		bl	CyU3PDebugPrint
 8999              	.LVL1014:
 9000 4f0c 44309DE5 		ldr	r3, [sp, #68]
 9001 4f10 95FCFFEA 		b	.L617
 9002              	.L752:
 9003              	.LVL1015:
 9004              	.LBE193:
 9005              	.LBE231:
 9006              	.LBE274:
 9007              	.LBE289:
 9008              	.LBB290:
 9009              	.LBB162:
4274:../uvc.c      ****     		break;
 9010              		.loc 1 4274 0
 9011 4f14 1C00A0E3 		mov	r0, #28
 9012 4f18 FEFFFFEB 		bl	ControlHandle
 9013              	.LVL1016:
 9014 4f1c 44309DE5 		ldr	r3, [sp, #68]
 9015 4f20 91FCFFEA 		b	.L617
 9016              	.L775:
 9017              	.LVL1017:
4298:../uvc.c      ****     		break;
 9018              		.loc 1 4298 0
 9019 4f24 2600A0E3 		mov	r0, #38
 9020 4f28 FEFFFFEB 		bl	ControlHandle
 9021              	.LVL1018:
 9022 4f2c 44309DE5 		ldr	r3, [sp, #68]
 9023 4f30 8DFCFFEA 		b	.L617
 9024              	.L756:
 9025              	.LVL1019:
4229:../uvc.c      ****      		break;
 9026              		.loc 1 4229 0
 9027 4f34 1200A0E3 		mov	r0, #18
 9028 4f38 FEFFFFEB 		bl	ControlHandle
 9029              	.LVL1020:
 9030 4f3c 44309DE5 		ldr	r3, [sp, #68]
 9031 4f40 89FCFFEA 		b	.L617
 9032              	.L782:
4332:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9033              		.loc 1 4332 0
 9034 4f44 2E00A0E3 		mov	r0, #46
 9035 4f48 FEFFFFEB 		bl	ControlHandle
 9036              	.LVL1021:
4333:../uvc.c      ****     		break;
 9037              		.loc 1 4333 0
 9038 4f4c 80319FE5 		ldr	r3, .L904+80
 9039 4f50 B020D4E1 		ldrh	r2, [r4]
 9040 4f54 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9041 4f58 0400A0E3 		mov	r0, #4
 9042 4f5c 60119FE5 		ldr	r1, .L904+64
 9043 4f60 FEFFFFEB 		bl	CyU3PDebugPrint
 9044              	.LVL1022:
 9045 4f64 44309DE5 		ldr	r3, [sp, #68]
 9046 4f68 7FFCFFEA 		b	.L617
 9047              	.L766:
 9048              	.LVL1023:
4264:../uvc.c      ****     		break;
 9049              		.loc 1 4264 0
 9050 4f6c 1A00A0E3 		mov	r0, #26
 9051 4f70 FEFFFFEB 		bl	ControlHandle
 9052              	.LVL1024:
 9053 4f74 44309DE5 		ldr	r3, [sp, #68]
 9054 4f78 7BFCFFEA 		b	.L617
 9055              	.L762:
 9056              	.LVL1025:
4253:../uvc.c      ****      		break;
 9057              		.loc 1 4253 0
 9058 4f7c 1800A0E3 		mov	r0, #24
 9059 4f80 FEFFFFEB 		bl	ControlHandle
 9060              	.LVL1026:
 9061 4f84 44309DE5 		ldr	r3, [sp, #68]
 9062 4f88 77FCFFEA 		b	.L617
 9063              	.L754:
 9064              	.LVL1027:
4241:../uvc.c      ****      		break;
 9065              		.loc 1 4241 0
 9066 4f8c 1500A0E3 		mov	r0, #21
 9067 4f90 FEFFFFEB 		bl	ControlHandle
 9068              	.LVL1028:
 9069 4f94 44309DE5 		ldr	r3, [sp, #68]
 9070 4f98 73FCFFEA 		b	.L617
 9071              	.L778:
4322:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 9072              		.loc 1 4322 0
 9073 4f9c 2B00A0E3 		mov	r0, #43
 9074 4fa0 FEFFFFEB 		bl	ControlHandle
 9075              	.LVL1029:
4323:../uvc.c      ****     		break;
 9076              		.loc 1 4323 0
 9077 4fa4 28319FE5 		ldr	r3, .L904+80
 9078 4fa8 B020D4E1 		ldrh	r2, [r4]
 9079 4fac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9080 4fb0 0400A0E3 		mov	r0, #4
 9081 4fb4 0C119FE5 		ldr	r1, .L904+68
 9082 4fb8 FEFFFFEB 		bl	CyU3PDebugPrint
 9083              	.LVL1030:
 9084 4fbc 44309DE5 		ldr	r3, [sp, #68]
 9085 4fc0 69FCFFEA 		b	.L617
 9086              	.L771:
 9087              	.LVL1031:
4290:../uvc.c      ****     		break;
 9088              		.loc 1 4290 0
 9089 4fc4 2400A0E3 		mov	r0, #36
 9090 4fc8 FEFFFFEB 		bl	ControlHandle
 9091              	.LVL1032:
 9092 4fcc 44309DE5 		ldr	r3, [sp, #68]
 9093 4fd0 65FCFFEA 		b	.L617
 9094              	.L769:
4307:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9095              		.loc 1 4307 0
 9096 4fd4 2800A0E3 		mov	r0, #40
 9097 4fd8 FEFFFFEB 		bl	ControlHandle
 9098              	.LVL1033:
4308:../uvc.c      ****     		break;
 9099              		.loc 1 4308 0
 9100 4fdc F0309FE5 		ldr	r3, .L904+80
 9101 4fe0 B020D4E1 		ldrh	r2, [r4]
 9102 4fe4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9103 4fe8 0400A0E3 		mov	r0, #4
 9104 4fec D8109FE5 		ldr	r1, .L904+72
 9105 4ff0 FEFFFFEB 		bl	CyU3PDebugPrint
 9106              	.LVL1034:
 9107 4ff4 44309DE5 		ldr	r3, [sp, #68]
 9108 4ff8 5BFCFFEA 		b	.L617
 9109              	.LVL1035:
 9110              	.L883:
 9111 4ffc 0250A0E1 		mov	r5, r2
 9112              	.LBE162:
 9113              	.LBE290:
4878:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9114              		.loc 1 4878 0
 9115 5000 0C00A0E1 		mov	r0, ip
 9116              	.LVL1036:
 9117 5004 A8109FE5 		ldr	r1, .L904+48
 9118 5008 FEFFFFEB 		bl	CyU3PDebugPrint
 9119              	.LVL1037:
4879:../uvc.c      **** 					}
 9120              		.loc 1 4879 0
 9121 500c 0500A0E1 		mov	r0, r5
 9122 5010 FEFFFFEB 		bl	CyFxAppErrorHandler
 9123              	.LVL1038:
 9124              	.L661:
 9125              	.LBB291:
 9126              	.LBB275:
 9127              	.LBB232:
 9128              	.LBB173:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9129              		.loc 1 1692 0
 9130 5014 020053E3 		cmp	r3, #2
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9131              		.loc 1 1693 0
 9132 5018 4BC5DBE5 		ldrb	ip, [fp, #1355]	@ zero_extendqisi2
 9133              	.LVL1039:
1704:../uvc.c      **** 		 	 if(Len == 2){
 9134              		.loc 1 1704 0
 9135 501c 0300A0E1 		mov	r0, r3
 9136              	.LVL1040:
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9137              		.loc 1 1694 0
 9138 5020 4C25DBE5 		ldrb	r2, [fp, #1356]	@ zero_extendqisi2
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9139              		.loc 1 1692 0
 9140 5024 8CFCFF1A 		bne	.L670
 9141              	.LVL1041:
 9142              	.L857:
1740:../uvc.c      **** 				  if(Len == 2){
 9143              		.loc 1 1740 0
 9144 5028 B4109FE5 		ldr	r1, .L904+96
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9145              		.loc 1 1729 0
 9146 502c 28C0C8E5 		strb	ip, [r8, #40]
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9147              		.loc 1 1730 0
 9148 5030 2920C8E5 		strb	r2, [r8, #41]
 9149 5034 880000EA 		b	.L859
 9150              	.LVL1042:
 9151              	.L735:
 9152              	.LBE173:
 9153              	.LBE232:
 9154              	.LBB233:
 9155              	.LBB218:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9156              		.loc 1 1692 0
 9157 5038 020053E3 		cmp	r3, #2
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9158              		.loc 1 1693 0
 9159 503c 6FC7DBE5 		ldrb	ip, [fp, #1903]	@ zero_extendqisi2
 9160              	.LVL1043:
1704:../uvc.c      **** 		 	 if(Len == 2){
 9161              		.loc 1 1704 0
 9162 5040 0300A0E1 		mov	r0, r3
 9163              	.LVL1044:
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9164              		.loc 1 1694 0
 9165 5044 7027DBE5 		ldrb	r2, [fp, #1904]	@ zero_extendqisi2
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9166              		.loc 1 1692 0
 9167 5048 EAFDFF1A 		bne	.L744
 9168              	.LVL1045:
 9169              	.L871:
1802:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9170              		.loc 1 1802 0
 9171 504c 28C0C8E5 		strb	ip, [r8, #40]
1813:../uvc.c      **** 		 	 if(Len == 2){
 9172              		.loc 1 1813 0
 9173 5050 8C109FE5 		ldr	r1, .L904+96
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 9174              		.loc 1 1803 0
 9175 5054 2920C8E5 		strb	r2, [r8, #41]
1816:../uvc.c      **** 		 	 }else{
 9176              		.loc 1 1816 0
 9177 5058 00C0A0E3 		mov	ip, #0
 9178 505c 370000EA 		b	.L866
 9179              	.LVL1046:
 9180              	.L678:
 9181              	.LBE218:
 9182              	.LBE233:
 9183              	.LBB234:
 9184              	.LBB182:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9185              		.loc 1 1692 0
 9186 5060 020053E3 		cmp	r3, #2
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9187              		.loc 1 1693 0
 9188 5064 73C5DBE5 		ldrb	ip, [fp, #1395]	@ zero_extendqisi2
 9189              	.LVL1047:
1704:../uvc.c      **** 		 	 if(Len == 2){
 9190              		.loc 1 1704 0
 9191 5068 0300A0E1 		mov	r0, r3
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9192              		.loc 1 1694 0
 9193 506c 7425DBE5 		ldrb	r2, [fp, #1396]	@ zero_extendqisi2
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9194              		.loc 1 1692 0
 9195 5070 50FDFF1A 		bne	.L687
 9196              	.LVL1048:
 9197              	.L860:
1740:../uvc.c      **** 				  if(Len == 2){
 9198              		.loc 1 1740 0
 9199 5074 68109FE5 		ldr	r1, .L904+96
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9200              		.loc 1 1729 0
 9201 5078 28C0C8E5 		strb	ip, [r8, #40]
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9202              		.loc 1 1730 0
 9203 507c 2920C8E5 		strb	r2, [r8, #41]
 9204 5080 650000EA 		b	.L861
 9205              	.L905:
 9206              		.align	2
 9207              	.L904:
 9208 5084 00000000 		.word	.LANCHOR0
 9209 5088 00000000 		.word	.LANCHOR1
 9210 508c 00000000 		.word	glInterStaBuffer
 9211 5090 00000000 		.word	wIndex
 9212 5094 00000000 		.word	wValue
 9213 5098 AC0C0000 		.word	.LC70
 9214 509c 00000000 		.word	bmReqType
 9215 50a0 00000000 		.word	wLength
 9216 50a4 300C0000 		.word	.LC69
 9217 50a8 00000000 		.word	glChHandleInterStat
 9218 50ac 880D0000 		.word	.LC76
 9219 50b0 3C0D0000 		.word	.LC74
 9220 50b4 F00D0000 		.word	.LC79
 9221 50b8 D00D0000 		.word	.LC78
 9222 50bc 180D0000 		.word	.LC73
 9223 50c0 B8050000 		.word	.LC32
 9224 50c4 B00D0000 		.word	.LC77
 9225 50c8 600D0000 		.word	.LC75
 9226 50cc F80C0000 		.word	.LC72
 9227 50d0 2C060000 		.word	.LC35
 9228 50d4 00000000 		.word	bRequest
 9229 50d8 D80C0000 		.word	.LC71
 9230 50dc 64050000 		.word	.LC31
 9231 50e0 D8050000 		.word	.LC33
 9232 50e4 28000000 		.word	.LANCHOR0+40
 9233 50e8 38040000 		.word	.LC26
 9234 50ec FC050000 		.word	.LC34
 9235 50f0 68040000 		.word	.LC27
 9236 50f4 00000000 		.word	cmdQu
 9237 50f8 00000000 		.word	.LANCHOR1
 9238              	.LVL1049:
 9239              	.L642:
 9240              	.LBE182:
 9241              	.LBE234:
 9242              	.LBB235:
 9243              	.LBB206:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9244              		.loc 1 1692 0
 9245 50fc 02005CE3 		cmp	ip, #2
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9246              		.loc 1 1693 0
 9247 5100 9F25DB05 		ldreqb	r2, [fp, #1439]	@ zero_extendqisi2
1704:../uvc.c      **** 		 	 if(Len == 2){
 9248              		.loc 1 1704 0
 9249 5104 0200A003 		moveq	r0, #2
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9250              		.loc 1 1694 0
 9251 5108 A035DB05 		ldreqb	r3, [fp, #1440]	@ zero_extendqisi2
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9252              		.loc 1 1692 0
 9253 510c C001000A 		beq	.L852
1697:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9254              		.loc 1 1697 0
 9255 5110 9FE5DBE5 		ldrb	lr, [fp, #1439]	@ zero_extendqisi2
1699:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9256              		.loc 1 1699 0
 9257 5114 A025DBE5 		ldrb	r2, [fp, #1440]	@ zero_extendqisi2
 9258 5118 8AFDFFEA 		b	.L854
 9259              	.LVL1050:
 9260              	.L739:
 9261              	.LBE206:
 9262              	.LBE235:
 9263              	.LBB236:
 9264              	.LBB219:
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9265              		.loc 1 1775 0
 9266 511c 7527DBE5 		ldrb	r2, [fp, #1909]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9267              		.loc 1 1781 0
 9268 5120 44101FE5 		ldr	r1, .L904+96
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9269              		.loc 1 1776 0
 9270 5124 0030A0E3 		mov	r3, #0
 9271              	.LVL1051:
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9272              		.loc 1 1781 0
 9273 5128 0100A0E3 		mov	r0, #1
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9274              		.loc 1 1775 0
 9275 512c 2820C8E5 		strb	r2, [r8, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9276              		.loc 1 1776 0
 9277 5130 2930C8E5 		strb	r3, [r8, #41]
 9278              	.LVL1052:
 9279              	.L867:
1764:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9280              		.loc 1 1764 0
 9281 5134 03C0A0E1 		mov	ip, r3
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9282              		.loc 1 1759 0
 9283 5138 2A30C8E5 		strb	r3, [r8, #42]
1760:../uvc.c      **** 		 	 }
 9284              		.loc 1 1760 0
 9285 513c 2B30C8E5 		strb	r3, [r8, #43]
 9286              	.L866:
1764:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9287              		.loc 1 1764 0
 9288 5140 24C08DE5 		str	ip, [sp, #36]
 9289 5144 0050A0E3 		mov	r5, #0
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9290              		.loc 1 1762 0
 9291 5148 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9292              	.LVL1053:
1763:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
 9293              		.loc 1 1763 0
 9294 514c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9295              	.LVL1054:
1764:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9296              		.loc 1 1764 0
 9297 5150 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9298              	.LVL1055:
 9299 5154 24C09DE5 		ldr	ip, [sp, #36]
 9300 5158 26FFFFEA 		b	.L741
 9301              	.LVL1056:
 9302              	.L715:
 9303              	.LBE219:
 9304              	.LBE236:
 9305              	.LBB237:
 9306              	.LBB194:
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9307              		.loc 1 1775 0
 9308 515c 6CE01FE5 		ldr	lr, .L904+116
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9309              		.loc 1 1781 0
 9310 5160 84101FE5 		ldr	r1, .L904+96
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9311              		.loc 1 1775 0
 9312 5164 6127DEE5 		ldrb	r2, [lr, #1889]	@ zero_extendqisi2
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9313              		.loc 1 1776 0
 9314 5168 0030A0E3 		mov	r3, #0
 9315              	.LVL1057:
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9316              		.loc 1 1781 0
 9317 516c 0100A0E3 		mov	r0, #1
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9318              		.loc 1 1775 0
 9319 5170 2820C8E5 		strb	r2, [r8, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9320              		.loc 1 1776 0
 9321 5174 2930C8E5 		strb	r3, [r8, #41]
1777:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9322              		.loc 1 1777 0
 9323 5178 2A30C8E5 		strb	r3, [r8, #42]
1778:../uvc.c      **** 		 	 }
 9324              		.loc 1 1778 0
 9325 517c 2B30C8E5 		strb	r3, [r8, #43]
 9326              	.LVL1058:
 9327              	.L863:
1743:../uvc.c      **** 				  }else{
 9328              		.loc 1 1743 0
 9329 5180 00C0A0E3 		mov	ip, #0
 9330 5184 24C08DE5 		str	ip, [sp, #36]
 9331 5188 0040A0E3 		mov	r4, #0
1740:../uvc.c      **** 				  if(Len == 2){
 9332              		.loc 1 1740 0
 9333 518c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9334              	.LVL1059:
1742:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9335              		.loc 1 1742 0
 9336 5190 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9337              	.LVL1060:
1743:../uvc.c      **** 				  }else{
 9338              		.loc 1 1743 0
 9339 5194 2950D8E5 		ldrb	r5, [r8, #41]	@ zero_extendqisi2
 9340              	.LVL1061:
 9341 5198 24109DE5 		ldr	r1, [sp, #36]
 9342 519c 54FEFFEA 		b	.L717
 9343              	.LVL1062:
 9344              	.L646:
 9345              	.LBE194:
 9346              	.LBE237:
 9347              	.LBB238:
 9348              	.LBB207:
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9349              		.loc 1 1775 0
 9350 51a0 A525DBE5 		ldrb	r2, [fp, #1445]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9351              		.loc 1 1781 0
 9352 51a4 C8101FE5 		ldr	r1, .L904+96
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9353              		.loc 1 1776 0
 9354 51a8 0030A0E3 		mov	r3, #0
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9355              		.loc 1 1781 0
 9356 51ac 0100A0E3 		mov	r0, #1
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9357              		.loc 1 1775 0
 9358 51b0 2820C8E5 		strb	r2, [r8, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9359              		.loc 1 1776 0
 9360 51b4 2930C8E5 		strb	r3, [r8, #41]
1777:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9361              		.loc 1 1777 0
 9362 51b8 2A30C8E5 		strb	r3, [r8, #42]
1778:../uvc.c      **** 		 	 }
 9363              		.loc 1 1778 0
 9364 51bc 2B30C8E5 		strb	r3, [r8, #43]
 9365              	.LVL1063:
 9366              	.L856:
1743:../uvc.c      **** 				  }else{
 9367              		.loc 1 1743 0
 9368 51c0 00C0A0E3 		mov	ip, #0
 9369 51c4 28C08DE5 		str	ip, [sp, #40]
1740:../uvc.c      **** 				  if(Len == 2){
 9370              		.loc 1 1740 0
 9371 51c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9372              	.LVL1064:
1743:../uvc.c      **** 				  }else{
 9373              		.loc 1 1743 0
 9374 51cc 00C0A0E3 		mov	ip, #0
1742:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9375              		.loc 1 1742 0
 9376 51d0 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 9377              	.LVL1065:
1743:../uvc.c      **** 				  }else{
 9378              		.loc 1 1743 0
 9379 51d4 2940D8E5 		ldrb	r4, [r8, #41]	@ zero_extendqisi2
 9380              	.LVL1066:
 9381 51d8 28E09DE5 		ldr	lr, [sp, #40]
 9382 51dc BAFEFFEA 		b	.L648
 9383              	.LVL1067:
 9384              	.L711:
 9385              	.LBE207:
 9386              	.LBE238:
 9387              	.LBB239:
 9388              	.LBB195:
1692:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9389              		.loc 1 1692 0
 9390 51e0 020053E3 		cmp	r3, #2
 9391 51e4 1302000A 		beq	.L894
1697:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9392              		.loc 1 1697 0
 9393 51e8 F8E01FE5 		ldr	lr, .L904+116
1704:../uvc.c      **** 		 	 if(Len == 2){
 9394              		.loc 1 1704 0
 9395 51ec 0300A0E1 		mov	r0, r3
1697:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9396              		.loc 1 1697 0
 9397 51f0 5BC7DEE5 		ldrb	ip, [lr, #1883]	@ zero_extendqisi2
1699:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9398              		.loc 1 1699 0
 9399 51f4 5C27DEE5 		ldrb	r2, [lr, #1884]	@ zero_extendqisi2
 9400 51f8 29FDFFEA 		b	.L722
 9401              	.LVL1068:
 9402              	.L682:
 9403              	.LBE195:
 9404              	.LBE239:
 9405              	.LBB240:
 9406              	.LBB183:
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9407              		.loc 1 1775 0
 9408 51fc 7925DBE5 		ldrb	r2, [fp, #1401]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9409              		.loc 1 1781 0
 9410 5200 24111FE5 		ldr	r1, .L904+96
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9411              		.loc 1 1776 0
 9412 5204 0030A0E3 		mov	r3, #0
 9413              	.LVL1069:
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9414              		.loc 1 1781 0
 9415 5208 0100A0E3 		mov	r0, #1
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9416              		.loc 1 1775 0
 9417 520c 2820C8E5 		strb	r2, [r8, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9418              		.loc 1 1776 0
 9419 5210 2930C8E5 		strb	r3, [r8, #41]
1777:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9420              		.loc 1 1777 0
 9421 5214 2A30C8E5 		strb	r3, [r8, #42]
1778:../uvc.c      **** 		 	 }
 9422              		.loc 1 1778 0
 9423 5218 2B30C8E5 		strb	r3, [r8, #43]
 9424              	.LVL1070:
 9425              	.L861:
1743:../uvc.c      **** 				  }else{
 9426              		.loc 1 1743 0
 9427 521c 00C0A0E3 		mov	ip, #0
 9428 5220 28C08DE5 		str	ip, [sp, #40]
 9429 5224 0050A0E3 		mov	r5, #0
1740:../uvc.c      **** 				  if(Len == 2){
 9430              		.loc 1 1740 0
 9431 5228 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9432              	.LVL1071:
1742:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9433              		.loc 1 1742 0
 9434 522c 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9435              	.LVL1072:
1743:../uvc.c      **** 				  }else{
 9436              		.loc 1 1743 0
 9437 5230 2940D8E5 		ldrb	r4, [r8, #41]	@ zero_extendqisi2
 9438              	.LVL1073:
 9439 5234 28109DE5 		ldr	r1, [sp, #40]
 9440 5238 64FEFFEA 		b	.L684
 9441              	.LVL1074:
 9442              	.L665:
 9443              	.LBE183:
 9444              	.LBE240:
 9445              	.LBB241:
 9446              	.LBB174:
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9447              		.loc 1 1775 0
 9448 523c 5125DBE5 		ldrb	r2, [fp, #1361]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9449              		.loc 1 1781 0
 9450 5240 64111FE5 		ldr	r1, .L904+96
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9451              		.loc 1 1776 0
 9452 5244 0030A0E3 		mov	r3, #0
 9453              	.LVL1075:
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9454              		.loc 1 1781 0
 9455 5248 0100A0E3 		mov	r0, #1
1775:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9456              		.loc 1 1775 0
 9457 524c 2820C8E5 		strb	r2, [r8, #40]
1776:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9458              		.loc 1 1776 0
 9459 5250 2930C8E5 		strb	r3, [r8, #41]
1777:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9460              		.loc 1 1777 0
 9461 5254 2A30C8E5 		strb	r3, [r8, #42]
1778:../uvc.c      **** 		 	 }
 9462              		.loc 1 1778 0
 9463 5258 2B30C8E5 		strb	r3, [r8, #43]
 9464              	.LVL1076:
 9465              	.L859:
1743:../uvc.c      **** 				  }else{
 9466              		.loc 1 1743 0
 9467 525c 00C0A0E3 		mov	ip, #0
 9468 5260 24C08DE5 		str	ip, [sp, #36]
 9469 5264 0040A0E3 		mov	r4, #0
1740:../uvc.c      **** 				  if(Len == 2){
 9470              		.loc 1 1740 0
 9471 5268 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9472              	.LVL1077:
1742:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9473              		.loc 1 1742 0
 9474 526c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9475              	.LVL1078:
1743:../uvc.c      **** 				  }else{
 9476              		.loc 1 1743 0
 9477 5270 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9478              	.LVL1079:
 9479 5274 24C09DE5 		ldr	ip, [sp, #36]
 9480 5278 1CFFFFEA 		b	.L667
 9481              	.LVL1080:
 9482              	.L791:
 9483              	.LBE174:
 9484              	.LBE241:
 9485              	.LBE275:
 9486              	.LBE291:
 9487              	.LBB292:
 9488              	.LBB163:
 9489              	.LBB152:
 9490              	.LBB146:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9491              		.loc 1 1372 0
 9492 527c 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9493              		.loc 1 1373 0
 9494 5280 0200A0E3 		mov	r0, #2
 9495 5284 A8111FE5 		ldr	r1, .L904+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9496              		.loc 1 1371 0
 9497 5288 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9498              		.loc 1 1372 0
 9499 528c 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9500              		.loc 1 1374 0
 9501 5290 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9502              		.loc 1 1373 0
 9503 5294 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9504              	.LVL1081:
1374:../uvc.c      **** 			  break;
 9505              		.loc 1 1374 0
 9506 5298 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9507              	.LVL1082:
 9508 529c 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9509              		.loc 1 1355 0
 9510 52a0 FF50A0E3 		mov	r5, #255
 9511              	.LVL1083:
 9512              	.L795:
2274:../uvc.c      **** }
 9513              		.loc 1 2274 0
 9514 52a4 24109DE5 		ldr	r1, [sp, #36]
 9515 52a8 28209DE5 		ldr	r2, [sp, #40]
 9516 52ac 02108DE8 		stmia	sp, {r1, ip}
 9517 52b0 E8111FE5 		ldr	r1, .L904+76
 9518 52b4 0430A0E1 		mov	r3, r4
 9519 52b8 08508DE5 		str	r5, [sp, #8]
 9520 52bc 0400A0E3 		mov	r0, #4
 9521 52c0 FEFFFFEB 		bl	CyU3PDebugPrint
 9522              	.LVL1084:
 9523              	.LBE146:
 9524              	.LBE152:
4303:../uvc.c      ****     		break;
 9525              		.loc 1 4303 0
 9526 52c4 F8211FE5 		ldr	r2, .L904+80
 9527 52c8 0400A0E3 		mov	r0, #4
 9528 52cc 0030D2E5 		ldrb	r3, [r2]	@ zero_extendqisi2
 9529 52d0 00121FE5 		ldr	r1, .L904+84
 9530 52d4 B020D7E1 		ldrh	r2, [r7]
 9531 52d8 FEFFFFEB 		bl	CyU3PDebugPrint
 9532              	.LVL1085:
 9533 52dc 44309DE5 		ldr	r3, [sp, #68]
 9534 52e0 A1FBFFEA 		b	.L617
 9535              	.LVL1086:
 9536              	.L890:
 9537              	.LBB153:
 9538              	.LBB147:
1367:../uvc.c      **** 		 {
 9539              		.loc 1 1367 0
 9540 52e4 81005CE3 		cmp	ip, #129
 9541 52e8 6C01000A 		beq	.L788
 9542 52ec 6201008A 		bhi	.L789
 9543 52f0 01005CE3 		cmp	ip, #1
 9544 52f4 5601001A 		bne	.L785
1823:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9545              		.loc 1 1823 0
 9546 52f8 2000A0E3 		mov	r0, #32
 9547 52fc 20121FE5 		ldr	r1, .L904+96
 9548 5300 42208DE2 		add	r2, sp, #66
 9549 5304 20308DE5 		str	r3, [sp, #32]
 9550 5308 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9551              	.LVL1087:
1825:../uvc.c      **** 			   {
 9552              		.loc 1 1825 0
 9553 530c 20309DE5 		ldr	r3, [sp, #32]
 9554 5310 000050E3 		cmp	r0, #0
 9555 5314 34008DE5 		str	r0, [sp, #52]
 9556 5318 BC01001A 		bne	.L801
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9557              		.loc 1 1827 0
 9558 531c 020053E3 		cmp	r3, #2
1828:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 9559              		.loc 1 1828 0
 9560 5320 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
1827:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9561              		.loc 1 1827 0
 9562 5324 DD02000A 		beq	.L895
 9563              	.LVL1088:
1832:../uvc.c      **** 				 }
 9564              		.loc 1 1832 0
 9565 5328 2AC0D9E5 		ldrb	ip, [r9, #42]	@ zero_extendqisi2
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9566              		.loc 1 1835 0
 9567 532c 38308DE5 		str	r3, [sp, #56]
1832:../uvc.c      **** 				 }
 9568              		.loc 1 1832 0
 9569 5330 24C08DE5 		str	ip, [sp, #36]
 9570              	.LVL1089:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9571              		.loc 1 1835 0
 9572 5334 2CC09DE5 		ldr	ip, [sp, #44]
 9573 5338 08308DE5 		str	r3, [sp, #8]
 9574 533c 04C08DE5 		str	ip, [sp, #4]
 9575 5340 24C09DE5 		ldr	ip, [sp, #36]
 9576 5344 00508DE5 		str	r5, [sp]
 9577 5348 10C08DE5 		str	ip, [sp, #16]
 9578 534c 0C408DE5 		str	r4, [sp, #12]
 9579 5350 0400A0E3 		mov	r0, #4
 9580              	.LVL1090:
 9581 5354 6C121FE5 		ldr	r1, .L904+108
 9582 5358 2720A0E3 		mov	r2, #39
 9583 535c 30309DE5 		ldr	r3, [sp, #48]
 9584 5360 FEFFFFEB 		bl	CyU3PDebugPrint
 9585              	.LVL1091:
2050:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 9586              		.loc 1 2050 0
 9587 5364 38C09DE5 		ldr	ip, [sp, #56]
 9588 5368 04005CE3 		cmp	ip, #4
 9589 536c F302000A 		beq	.L896
 9590              	.LVL1092:
 9591              	.L806:
2067:../uvc.c      **** 				 	 			 break;
 9592              		.loc 1 2067 0
 9593 5370 8E27DBE5 		ldrb	r2, [fp, #1934]	@ zero_extendqisi2
2066:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9594              		.loc 1 2066 0
 9595 5374 38C09DE5 		ldr	ip, [sp, #56]
2067:../uvc.c      **** 				 	 			 break;
 9596              		.loc 1 2067 0
 9597 5378 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
2066:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9598              		.loc 1 2066 0
 9599 537c 0400A0E3 		mov	r0, #4
 9600 5380 0C108DE8 		stmia	sp, {r2, r3, ip}
 9601 5384 B0121FE5 		ldr	r1, .L904+88
 9602 5388 0420A0E1 		mov	r2, r4
 9603 538c 24309DE5 		ldr	r3, [sp, #36]
 9604 5390 FEFFFFEB 		bl	CyU3PDebugPrint
 9605              	.LVL1093:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9606              		.loc 1 1355 0
 9607 5394 FF50A0E3 		mov	r5, #255
 9608 5398 05C0A0E1 		mov	ip, r5
 9609 539c C0FFFFEA 		b	.L795
 9610              	.LVL1094:
 9611              	.L731:
 9612              	.LBE147:
 9613              	.LBE153:
 9614              	.LBE163:
 9615              	.LBE292:
 9616              	.LBB293:
 9617              	.LBB276:
 9618              	.LBB242:
 9619              	.LBB220:
2271:../uvc.c      **** 			  break;
 9620              		.loc 1 2271 0
 9621 53a0 0000A0E3 		mov	r0, #0
 9622 53a4 0020A0E1 		mov	r2, r0
 9623 53a8 0110A0E3 		mov	r1, #1
 9624 53ac FEFFFFEB 		bl	CyU3PUsbStall
 9625              	.LVL1095:
 9626              	.L865:
 9627 53b0 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9628              		.loc 1 1355 0
 9629 53b4 FF30A0E3 		mov	r3, #255
 9630 53b8 0320A0E1 		mov	r2, r3
2271:../uvc.c      **** 			  break;
 9631              		.loc 1 2271 0
 9632 53bc 24C08DE5 		str	ip, [sp, #36]
 9633 53c0 0C50A0E1 		mov	r5, ip
 9634 53c4 8BFEFFEA 		b	.L741
 9635              	.LVL1096:
 9636              	.L641:
 9637              	.LBE220:
 9638              	.LBE242:
 9639              	.LBB243:
 9640              	.LBB208:
1647:../uvc.c      **** 			 	 			 {
 9641              		.loc 1 1647 0
 9642 53c8 02005CE3 		cmp	ip, #2
 9643 53cc 1503000A 		beq	.L897
1655:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 9644              		.loc 1 1655 0
 9645 53d0 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9646              		.loc 1 1355 0
 9647 53d4 FF40A013 		movne	r4, #255
 9648              	.LVL1097:
 9649 53d8 0450A011 		movne	r5, r4
 9650              	.LVL1098:
1655:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 9651              		.loc 1 1655 0
 9652 53dc 7801000A 		beq	.L898
 9653              	.LVL1099:
 9654              	.L650:
1671:../uvc.c      **** 
 9655              		.loc 1 1671 0
 9656 53e0 0C00A0E1 		mov	r0, ip
 9657 53e4 08131FE5 		ldr	r1, .L904+96
 9658 53e8 1CC08DE5 		str	ip, [sp, #28]
 9659 53ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9660              	.LVL1100:
1674:../uvc.c      **** //#endif
 9661              		.loc 1 1674 0
 9662 53f0 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 9663 53f4 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 9664 53f8 1CC09DE5 		ldr	ip, [sp, #28]
 9665 53fc 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9666 5400 03108DE8 		stmia	sp, {r0, r1, ip}
 9667 5404 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9668 5408 0400A0E3 		mov	r0, #4
 9669 540c 2C131FE5 		ldr	r1, .L904+100
 9670 5410 FEFFFFEB 		bl	CyU3PDebugPrint
 9671              	.LVL1101:
 9672 5414 00C0A0E3 		mov	ip, #0
 9673 5418 28C08DE5 		str	ip, [sp, #40]
 9674 541c 0CE0A0E1 		mov	lr, ip
 9675 5420 29FEFFEA 		b	.L648
 9676              	.LVL1102:
 9677              	.L638:
2271:../uvc.c      **** 			  break;
 9678              		.loc 1 2271 0
 9679 5424 0000A0E3 		mov	r0, #0
 9680 5428 0020A0E1 		mov	r2, r0
 9681 542c 0110A0E3 		mov	r1, #1
 9682 5430 FEFFFFEB 		bl	CyU3PUsbStall
 9683              	.LVL1103:
 9684              	.L853:
 9685 5434 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9686              		.loc 1 1355 0
 9687 5438 FF40A0E3 		mov	r4, #255
 9688              	.LVL1104:
 9689 543c 0450A0E1 		mov	r5, r4
 9690              	.LVL1105:
2271:../uvc.c      **** 			  break;
 9691              		.loc 1 2271 0
 9692 5440 28C08DE5 		str	ip, [sp, #40]
 9693 5444 0CE0A0E1 		mov	lr, ip
 9694 5448 1FFEFFEA 		b	.L648
 9695              	.LVL1106:
 9696              	.L681:
 9697              	.LBE208:
 9698              	.LBE243:
 9699              	.LBB244:
 9700              	.LBB184:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9701              		.loc 1 1757 0
 9702 544c 77C5DBE5 		ldrb	ip, [fp, #1399]	@ zero_extendqisi2
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9703              		.loc 1 1758 0
 9704 5450 7825DBE5 		ldrb	r2, [fp, #1400]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9705              		.loc 1 1762 0
 9706 5454 0300A0E1 		mov	r0, r3
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9707              		.loc 1 1759 0
 9708 5458 0030A0E3 		mov	r3, #0
 9709              	.LVL1107:
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9710              		.loc 1 1762 0
 9711 545c 80131FE5 		ldr	r1, .L904+96
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9712              		.loc 1 1757 0
 9713 5460 28C0C8E5 		strb	ip, [r8, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9714              		.loc 1 1758 0
 9715 5464 2920C8E5 		strb	r2, [r8, #41]
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9716              		.loc 1 1759 0
 9717 5468 2A30C8E5 		strb	r3, [r8, #42]
1760:../uvc.c      **** 		 	 }
 9718              		.loc 1 1760 0
 9719 546c 2B30C8E5 		strb	r3, [r8, #43]
 9720 5470 69FFFFEA 		b	.L861
 9721              	.LVL1108:
 9722              	.L664:
 9723              	.LBE184:
 9724              	.LBE244:
 9725              	.LBB245:
 9726              	.LBB175:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9727              		.loc 1 1757 0
 9728 5474 4FC5DBE5 		ldrb	ip, [fp, #1359]	@ zero_extendqisi2
 9729              	.LVL1109:
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9730              		.loc 1 1758 0
 9731 5478 5025DBE5 		ldrb	r2, [fp, #1360]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9732              		.loc 1 1762 0
 9733 547c 0300A0E1 		mov	r0, r3
 9734              	.LVL1110:
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9735              		.loc 1 1759 0
 9736 5480 0030A0E3 		mov	r3, #0
 9737              	.LVL1111:
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9738              		.loc 1 1762 0
 9739 5484 A8131FE5 		ldr	r1, .L904+96
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9740              		.loc 1 1757 0
 9741 5488 28C0C8E5 		strb	ip, [r8, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9742              		.loc 1 1758 0
 9743 548c 2920C8E5 		strb	r2, [r8, #41]
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9744              		.loc 1 1759 0
 9745 5490 2A30C8E5 		strb	r3, [r8, #42]
1760:../uvc.c      **** 		 	 }
 9746              		.loc 1 1760 0
 9747 5494 2B30C8E5 		strb	r3, [r8, #43]
 9748 5498 6FFFFFEA 		b	.L859
 9749              	.LVL1112:
 9750              	.L663:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9751              		.loc 1 1372 0
 9752 549c 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9753              		.loc 1 1373 0
 9754 54a0 0200A0E3 		mov	r0, #2
 9755 54a4 C8131FE5 		ldr	r1, .L904+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9756              		.loc 1 1371 0
 9757 54a8 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9758              		.loc 1 1372 0
 9759 54ac 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9760              		.loc 1 1374 0
 9761 54b0 24208DE5 		str	r2, [sp, #36]
 9762 54b4 0040A0E3 		mov	r4, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9763              		.loc 1 1373 0
 9764 54b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9765              	.LVL1113:
1374:../uvc.c      **** 			  break;
 9766              		.loc 1 1374 0
 9767 54bc 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9768              	.LVL1114:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9769              		.loc 1 1355 0
 9770 54c0 FF30A0E3 		mov	r3, #255
 9771 54c4 24C09DE5 		ldr	ip, [sp, #36]
 9772 54c8 88FEFFEA 		b	.L667
 9773              	.LVL1115:
 9774              	.L675:
 9775              	.LBE175:
 9776              	.LBE245:
 9777              	.LBB246:
 9778              	.LBB185:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9779              		.loc 1 1729 0
 9780 54cc DCE31FE5 		ldr	lr, .L904+116
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9781              		.loc 1 1728 0
 9782 54d0 020053E3 		cmp	r3, #2
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9783              		.loc 1 1729 0
 9784 54d4 75C5DEE5 		ldrb	ip, [lr, #1397]	@ zero_extendqisi2
 9785              	.LVL1116:
1740:../uvc.c      **** 				  if(Len == 2){
 9786              		.loc 1 1740 0
 9787 54d8 0300A0E1 		mov	r0, r3
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9788              		.loc 1 1730 0
 9789 54dc 7625DEE5 		ldrb	r2, [lr, #1398]	@ zero_extendqisi2
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9790              		.loc 1 1728 0
 9791 54e0 34FCFF1A 		bne	.L687
 9792              	.LVL1117:
 9793 54e4 E2FEFFEA 		b	.L860
 9794              	.LVL1118:
 9795              	.L732:
 9796              	.LBE185:
 9797              	.LBE246:
 9798              	.LBB247:
 9799              	.LBB221:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9800              		.loc 1 1729 0
 9801 54e8 F8E31FE5 		ldr	lr, .L904+116
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9802              		.loc 1 1728 0
 9803 54ec 020053E3 		cmp	r3, #2
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9804              		.loc 1 1729 0
 9805 54f0 71C7DEE5 		ldrb	ip, [lr, #1905]	@ zero_extendqisi2
 9806              	.LVL1119:
1740:../uvc.c      **** 				  if(Len == 2){
 9807              		.loc 1 1740 0
 9808 54f4 0300A0E1 		mov	r0, r3
 9809              	.LVL1120:
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9810              		.loc 1 1730 0
 9811 54f8 7227DEE5 		ldrb	r2, [lr, #1906]	@ zero_extendqisi2
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9812              		.loc 1 1728 0
 9813 54fc BDFCFF1A 		bne	.L744
 9814              	.LVL1121:
 9815 5500 D1FEFFEA 		b	.L871
 9816              	.LVL1122:
 9817              	.L708:
 9818              	.LBE221:
 9819              	.LBE247:
 9820              	.LBB248:
 9821              	.LBB196:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9822              		.loc 1 1729 0
 9823 5504 14E41FE5 		ldr	lr, .L904+116
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9824              		.loc 1 1728 0
 9825 5508 020053E3 		cmp	r3, #2
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9826              		.loc 1 1729 0
 9827 550c 5DC7DEE5 		ldrb	ip, [lr, #1885]	@ zero_extendqisi2
1740:../uvc.c      **** 				  if(Len == 2){
 9828              		.loc 1 1740 0
 9829 5510 0300A0E1 		mov	r0, r3
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9830              		.loc 1 1730 0
 9831 5514 5E27DEE5 		ldrb	r2, [lr, #1886]	@ zero_extendqisi2
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9832              		.loc 1 1728 0
 9833 5518 61FCFF1A 		bne	.L722
 9834              	.LVL1123:
 9835              	.L862:
1740:../uvc.c      **** 				  if(Len == 2){
 9836              		.loc 1 1740 0
 9837 551c 40141FE5 		ldr	r1, .L904+96
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9838              		.loc 1 1729 0
 9839 5520 28C0C8E5 		strb	ip, [r8, #40]
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9840              		.loc 1 1730 0
 9841 5524 2920C8E5 		strb	r2, [r8, #41]
 9842 5528 14FFFFEA 		b	.L863
 9843              	.LVL1124:
 9844              	.L658:
 9845              	.LBE196:
 9846              	.LBE248:
 9847              	.LBB249:
 9848              	.LBB176:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9849              		.loc 1 1729 0
 9850 552c 3CE41FE5 		ldr	lr, .L904+116
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9851              		.loc 1 1728 0
 9852 5530 020053E3 		cmp	r3, #2
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9853              		.loc 1 1729 0
 9854 5534 4DC5DEE5 		ldrb	ip, [lr, #1357]	@ zero_extendqisi2
 9855              	.LVL1125:
1740:../uvc.c      **** 				  if(Len == 2){
 9856              		.loc 1 1740 0
 9857 5538 0300A0E1 		mov	r0, r3
 9858              	.LVL1126:
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9859              		.loc 1 1730 0
 9860 553c 4E25DEE5 		ldrb	r2, [lr, #1358]	@ zero_extendqisi2
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9861              		.loc 1 1728 0
 9862 5540 45FBFF1A 		bne	.L670
 9863              	.LVL1127:
 9864 5544 B7FEFFEA 		b	.L857
 9865              	.LVL1128:
 9866              	.L737:
 9867              	.LBE176:
 9868              	.LBE249:
 9869              	.LBB250:
 9870              	.LBB222:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9871              		.loc 1 1372 0
 9872 5548 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9873              		.loc 1 1373 0
 9874 554c 0200A0E3 		mov	r0, #2
 9875 5550 74141FE5 		ldr	r1, .L904+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9876              		.loc 1 1371 0
 9877 5554 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9878              		.loc 1 1372 0
 9879 5558 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9880              		.loc 1 1374 0
 9881 555c 24208DE5 		str	r2, [sp, #36]
 9882 5560 0050A0E3 		mov	r5, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9883              		.loc 1 1373 0
 9884 5564 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9885              	.LVL1129:
1374:../uvc.c      **** 			  break;
 9886              		.loc 1 1374 0
 9887 5568 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9888              	.LVL1130:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9889              		.loc 1 1355 0
 9890 556c FF30A0E3 		mov	r3, #255
 9891 5570 24C09DE5 		ldr	ip, [sp, #36]
 9892 5574 1FFEFFEA 		b	.L741
 9893              	.LVL1131:
 9894              	.L639:
 9895              	.LBE222:
 9896              	.LBE250:
 9897              	.LBB251:
 9898              	.LBB209:
1728:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9899              		.loc 1 1728 0
 9900 5578 02005CE3 		cmp	ip, #2
 9901 557c A000000A 		beq	.L899
1733:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9902              		.loc 1 1733 0
 9903 5580 90041FE5 		ldr	r0, .L904+116
 9904 5584 A1E5D0E5 		ldrb	lr, [r0, #1441]	@ zero_extendqisi2
1735:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9905              		.loc 1 1735 0
 9906 5588 A225D0E5 		ldrb	r2, [r0, #1442]	@ zero_extendqisi2
 9907 558c 6DFCFFEA 		b	.L854
 9908              	.LVL1132:
 9909              	.L738:
 9910              	.LBE209:
 9911              	.LBE251:
 9912              	.LBB252:
 9913              	.LBB223:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9914              		.loc 1 1757 0
 9915 5590 73C7DBE5 		ldrb	ip, [fp, #1907]	@ zero_extendqisi2
 9916              	.LVL1133:
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9917              		.loc 1 1758 0
 9918 5594 7427DBE5 		ldrb	r2, [fp, #1908]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9919              		.loc 1 1762 0
 9920 5598 0300A0E1 		mov	r0, r3
 9921              	.LVL1134:
 9922 559c C0141FE5 		ldr	r1, .L904+96
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9923              		.loc 1 1759 0
 9924 55a0 0030A0E3 		mov	r3, #0
 9925              	.LVL1135:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9926              		.loc 1 1757 0
 9927 55a4 28C0C8E5 		strb	ip, [r8, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9928              		.loc 1 1758 0
 9929 55a8 2920C8E5 		strb	r2, [r8, #41]
 9930 55ac E0FEFFEA 		b	.L867
 9931              	.LVL1136:
 9932              	.L645:
 9933              	.LBE223:
 9934              	.LBE252:
 9935              	.LBB253:
 9936              	.LBB210:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9937              		.loc 1 1757 0
 9938 55b0 C0041FE5 		ldr	r0, .L904+116
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9939              		.loc 1 1759 0
 9940 55b4 0030A0E3 		mov	r3, #0
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9941              		.loc 1 1757 0
 9942 55b8 A3E5D0E5 		ldrb	lr, [r0, #1443]	@ zero_extendqisi2
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9943              		.loc 1 1758 0
 9944 55bc A425D0E5 		ldrb	r2, [r0, #1444]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9945              		.loc 1 1762 0
 9946 55c0 E4141FE5 		ldr	r1, .L904+96
 9947 55c4 0C00A0E1 		mov	r0, ip
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9948              		.loc 1 1757 0
 9949 55c8 28E0C8E5 		strb	lr, [r8, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9950              		.loc 1 1758 0
 9951 55cc 2920C8E5 		strb	r2, [r8, #41]
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9952              		.loc 1 1759 0
 9953 55d0 2A30C8E5 		strb	r3, [r8, #42]
1760:../uvc.c      **** 		 	 }
 9954              		.loc 1 1760 0
 9955 55d4 2B30C8E5 		strb	r3, [r8, #43]
 9956 55d8 F8FEFFEA 		b	.L856
 9957              	.L644:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9958              		.loc 1 1372 0
 9959 55dc 0030A0E3 		mov	r3, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9960              		.loc 1 1373 0
 9961 55e0 0200A0E3 		mov	r0, #2
 9962 55e4 08151FE5 		ldr	r1, .L904+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9963              		.loc 1 1371 0
 9964 55e8 28C0C8E5 		strb	ip, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9965              		.loc 1 1372 0
 9966 55ec 2930C8E5 		strb	r3, [r8, #41]
1374:../uvc.c      **** 			  break;
 9967              		.loc 1 1374 0
 9968 55f0 28308DE5 		str	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9969              		.loc 1 1355 0
 9970 55f4 FF40A0E3 		mov	r4, #255
 9971              	.LVL1137:
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9972              		.loc 1 1373 0
 9973 55f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9974              	.LVL1138:
1374:../uvc.c      **** 			  break;
 9975              		.loc 1 1374 0
 9976 55fc 00C0A0E3 		mov	ip, #0
 9977 5600 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 9978              	.LVL1139:
 9979 5604 28E09DE5 		ldr	lr, [sp, #40]
 9980 5608 AFFDFFEA 		b	.L648
 9981              	.LVL1140:
 9982              	.L660:
 9983              	.LBE210:
 9984              	.LBE253:
 9985              	.LBB254:
 9986              	.LBB177:
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 9987              		.loc 1 1539 0
 9988 560c 0C00A0E1 		mov	r0, ip
 9989 5610 28109DE5 		ldr	r1, [sp, #40]
 9990 5614 20308DE5 		str	r3, [sp, #32]
 9991 5618 FEFFFFEB 		bl	SensorGetControl
 9992              	.LVL1141:
1671:../uvc.c      **** 
 9993              		.loc 1 1671 0
 9994 561c 20309DE5 		ldr	r3, [sp, #32]
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 9995              		.loc 1 1540 0
 9996 5620 30E51FE5 		ldr	lr, .L904+116
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 9997              		.loc 1 1552 0
 9998 5624 0020A0E3 		mov	r2, #0
1671:../uvc.c      **** 
 9999              		.loc 1 1671 0
 10000 5628 4C151FE5 		ldr	r1, .L904+96
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10001              		.loc 1 1552 0
 10002 562c 2920C8E5 		strb	r2, [r8, #41]
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10003              		.loc 1 1539 0
 10004 5630 0040A0E1 		mov	r4, r0
 10005              	.LVL1142:
1671:../uvc.c      **** 
 10006              		.loc 1 1671 0
 10007 5634 0300A0E1 		mov	r0, r3
 10008              	.LVL1143:
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10009              		.loc 1 1540 0
 10010 5638 5545CEE5 		strb	r4, [lr, #1365]
 10011              	.LVL1144:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 10012              		.loc 1 1551 0
 10013 563c 2840C8E5 		strb	r4, [r8, #40]
1671:../uvc.c      **** 
 10014              		.loc 1 1671 0
 10015 5640 20308DE5 		str	r3, [sp, #32]
 10016 5644 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10017              	.LVL1145:
1674:../uvc.c      **** //#endif
 10018              		.loc 1 1674 0
 10019 5648 29C0D8E5 		ldrb	ip, [r8, #41]	@ zero_extendqisi2
 10020 564c 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10021 5650 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10022 5654 20309DE5 		ldr	r3, [sp, #32]
 10023 5658 03008DE8 		stmia	sp, {r0, r1}
 10024 565c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10025 5660 08308DE5 		str	r3, [sp, #8]
 10026 5664 0400A0E3 		mov	r0, #4
 10027 5668 0C30A0E1 		mov	r3, ip
 10028 566c 8C151FE5 		ldr	r1, .L904+100
 10029 5670 FEFFFFEB 		bl	CyU3PDebugPrint
 10030              	.LVL1146:
 10031 5674 00C0A0E3 		mov	ip, #0
 10032 5678 24C08DE5 		str	ip, [sp, #36]
 10033 567c 0420A0E1 		mov	r2, r4
 10034 5680 FF30A0E3 		mov	r3, #255
 10035 5684 19FEFFEA 		b	.L667
 10036              	.LVL1147:
 10037              	.L657:
2271:../uvc.c      **** 			  break;
 10038              		.loc 1 2271 0
 10039 5688 0000A0E3 		mov	r0, #0
 10040 568c 0020A0E1 		mov	r2, r0
 10041 5690 0110A0E3 		mov	r1, #1
 10042 5694 FEFFFFEB 		bl	CyU3PUsbStall
 10043              	.LVL1148:
 10044              	.L858:
 10045 5698 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10046              		.loc 1 1355 0
 10047 569c FF30A0E3 		mov	r3, #255
 10048 56a0 0320A0E1 		mov	r2, r3
2271:../uvc.c      **** 			  break;
 10049              		.loc 1 2271 0
 10050 56a4 24C08DE5 		str	ip, [sp, #36]
 10051 56a8 0C40A0E1 		mov	r4, ip
 10052 56ac 0FFEFFEA 		b	.L667
 10053              	.LVL1149:
 10054              	.L713:
 10055              	.LBE177:
 10056              	.LBE254:
 10057              	.LBB255:
 10058              	.LBB197:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10059              		.loc 1 1372 0
 10060 56b0 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10061              		.loc 1 1373 0
 10062 56b4 D8151FE5 		ldr	r1, .L904+96
 10063 56b8 0200A0E3 		mov	r0, #2
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10064              		.loc 1 1371 0
 10065 56bc 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10066              		.loc 1 1372 0
 10067 56c0 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 10068              		.loc 1 1374 0
 10069 56c4 24208DE5 		str	r2, [sp, #36]
 10070 56c8 0040A0E3 		mov	r4, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10071              		.loc 1 1373 0
 10072 56cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10073              	.LVL1150:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10074              		.loc 1 1355 0
 10075 56d0 FF50A0E3 		mov	r5, #255
 10076              	.LVL1151:
1374:../uvc.c      **** 			  break;
 10077              		.loc 1 1374 0
 10078 56d4 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10079              	.LVL1152:
 10080 56d8 24109DE5 		ldr	r1, [sp, #36]
 10081 56dc 04FDFFEA 		b	.L717
 10082              	.LVL1153:
 10083              	.L714:
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10084              		.loc 1 1757 0
 10085 56e0 F0E51FE5 		ldr	lr, .L904+116
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10086              		.loc 1 1762 0
 10087 56e4 0300A0E1 		mov	r0, r3
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10088              		.loc 1 1757 0
 10089 56e8 5FC7DEE5 		ldrb	ip, [lr, #1887]	@ zero_extendqisi2
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10090              		.loc 1 1758 0
 10091 56ec 6027DEE5 		ldrb	r2, [lr, #1888]	@ zero_extendqisi2
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10092              		.loc 1 1759 0
 10093 56f0 0030A0E3 		mov	r3, #0
 10094              	.LVL1154:
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10095              		.loc 1 1762 0
 10096 56f4 18161FE5 		ldr	r1, .L904+96
1757:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10097              		.loc 1 1757 0
 10098 56f8 28C0C8E5 		strb	ip, [r8, #40]
1758:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10099              		.loc 1 1758 0
 10100 56fc 2920C8E5 		strb	r2, [r8, #41]
1759:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10101              		.loc 1 1759 0
 10102 5700 2A30C8E5 		strb	r3, [r8, #42]
1760:../uvc.c      **** 		 	 }
 10103              		.loc 1 1760 0
 10104 5704 2B30C8E5 		strb	r3, [r8, #43]
 10105 5708 9CFEFFEA 		b	.L863
 10106              	.LVL1155:
 10107              	.L710:
1647:../uvc.c      **** 			 	 			 {
 10108              		.loc 1 1647 0
 10109 570c 020053E3 		cmp	r3, #2
 10110 5710 5D02000A 		beq	.L900
1655:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10111              		.loc 1 1655 0
 10112 5714 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10113              		.loc 1 1355 0
 10114 5718 FF50A013 		movne	r5, #255
 10115              	.LVL1156:
 10116 571c 05C0A011 		movne	ip, r5
1655:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10117              		.loc 1 1655 0
 10118 5720 9200000A 		beq	.L901
 10119              	.LVL1157:
 10120              	.L719:
1671:../uvc.c      **** 
 10121              		.loc 1 1671 0
 10122 5724 0300A0E1 		mov	r0, r3
 10123 5728 4C161FE5 		ldr	r1, .L904+96
 10124 572c 1CC08DE5 		str	ip, [sp, #28]
 10125 5730 20308DE5 		str	r3, [sp, #32]
 10126 5734 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10127              	.LVL1158:
1674:../uvc.c      **** //#endif
 10128              		.loc 1 1674 0
 10129 5738 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10130 573c 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10131 5740 20309DE5 		ldr	r3, [sp, #32]
 10132 5744 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10133 5748 03008DE8 		stmia	sp, {r0, r1}
 10134 574c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10135 5750 08308DE5 		str	r3, [sp, #8]
 10136 5754 74161FE5 		ldr	r1, .L904+100
 10137 5758 0E30A0E1 		mov	r3, lr
 10138 575c 0400A0E3 		mov	r0, #4
 10139 5760 FEFFFFEB 		bl	CyU3PDebugPrint
 10140              	.LVL1159:
 10141 5764 0000A0E3 		mov	r0, #0
 10142 5768 24008DE5 		str	r0, [sp, #36]
 10143 576c 0040A0E1 		mov	r4, r0
 10144 5770 1CC09DE5 		ldr	ip, [sp, #28]
 10145 5774 0010A0E1 		mov	r1, r0
 10146 5778 DDFCFFEA 		b	.L717
 10147              	.LVL1160:
 10148              	.L674:
 10149              	.LBE197:
 10150              	.LBE255:
 10151              	.LBB256:
 10152              	.LBB186:
2271:../uvc.c      **** 			  break;
 10153              		.loc 1 2271 0
 10154 577c 0000A0E3 		mov	r0, #0
 10155 5780 0110A0E3 		mov	r1, #1
 10156 5784 0020A0E1 		mov	r2, r0
 10157 5788 FEFFFFEB 		bl	CyU3PUsbStall
 10158              	.LVL1161:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10159              		.loc 1 1355 0
 10160 578c FF40A0E3 		mov	r4, #255
 10161              	.LVL1162:
2271:../uvc.c      **** 			  break;
 10162              		.loc 1 2271 0
 10163 5790 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10164              		.loc 1 1355 0
 10165 5794 04C0A0E1 		mov	ip, r4
2271:../uvc.c      **** 			  break;
 10166              		.loc 1 2271 0
 10167 5798 28008DE5 		str	r0, [sp, #40]
 10168 579c 0050A0E1 		mov	r5, r0
 10169 57a0 0010A0E1 		mov	r1, r0
 10170 57a4 09FDFFEA 		b	.L684
 10171              	.LVL1163:
 10172              	.L680:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10173              		.loc 1 1372 0
 10174 57a8 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10175              		.loc 1 1373 0
 10176 57ac D0161FE5 		ldr	r1, .L904+96
 10177 57b0 0200A0E3 		mov	r0, #2
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10178              		.loc 1 1371 0
 10179 57b4 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10180              		.loc 1 1372 0
 10181 57b8 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 10182              		.loc 1 1374 0
 10183 57bc 28208DE5 		str	r2, [sp, #40]
 10184 57c0 0050A0E3 		mov	r5, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10185              		.loc 1 1373 0
 10186 57c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10187              	.LVL1164:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10188              		.loc 1 1355 0
 10189 57c8 FF40A0E3 		mov	r4, #255
 10190              	.LVL1165:
1374:../uvc.c      **** 			  break;
 10191              		.loc 1 1374 0
 10192 57cc 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10193              	.LVL1166:
 10194 57d0 28109DE5 		ldr	r1, [sp, #40]
 10195 57d4 FDFCFFEA 		b	.L684
 10196              	.LVL1167:
 10197              	.L707:
 10198              	.LBE186:
 10199              	.LBE256:
 10200              	.LBB257:
 10201              	.LBB198:
2271:../uvc.c      **** 			  break;
 10202              		.loc 1 2271 0
 10203 57d8 0000A0E3 		mov	r0, #0
 10204 57dc 0110A0E3 		mov	r1, #1
 10205 57e0 0020A0E1 		mov	r2, r0
 10206 57e4 FEFFFFEB 		bl	CyU3PUsbStall
 10207              	.LVL1168:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10208              		.loc 1 1355 0
 10209 57e8 FF50A0E3 		mov	r5, #255
 10210              	.LVL1169:
2271:../uvc.c      **** 			  break;
 10211              		.loc 1 2271 0
 10212 57ec 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10213              		.loc 1 1355 0
 10214 57f0 05C0A0E1 		mov	ip, r5
2271:../uvc.c      **** 			  break;
 10215              		.loc 1 2271 0
 10216 57f4 24008DE5 		str	r0, [sp, #36]
 10217 57f8 0040A0E1 		mov	r4, r0
 10218 57fc 0010A0E1 		mov	r1, r0
 10219 5800 BBFCFFEA 		b	.L717
 10220              	.LVL1170:
 10221              	.L899:
 10222              	.LBE198:
 10223              	.LBE257:
 10224              	.LBB258:
 10225              	.LBB211:
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10226              		.loc 1 1729 0
 10227 5804 14E71FE5 		ldr	lr, .L904+116
 10228 5808 A125DEE5 		ldrb	r2, [lr, #1441]	@ zero_extendqisi2
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10229              		.loc 1 1730 0
 10230 580c A235DEE5 		ldrb	r3, [lr, #1442]	@ zero_extendqisi2
 10231              	.L855:
1740:../uvc.c      **** 				  if(Len == 2){
 10232              		.loc 1 1740 0
 10233 5810 0C00A0E1 		mov	r0, ip
 10234              	.L852:
 10235 5814 38171FE5 		ldr	r1, .L904+96
1729:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10236              		.loc 1 1729 0
 10237 5818 2820C8E5 		strb	r2, [r8, #40]
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10238              		.loc 1 1730 0
 10239 581c 2930C8E5 		strb	r3, [r8, #41]
 10240 5820 66FEFFEA 		b	.L856
 10241              	.LVL1171:
 10242              	.L786:
 10243              	.LBE211:
 10244              	.LBE258:
 10245              	.LBE276:
 10246              	.LBE293:
 10247              	.LBB294:
 10248              	.LBB164:
 10249              	.LBB154:
 10250              	.LBB148:
1715:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10251              		.loc 1 1715 0
 10252 5824 020053E3 		cmp	r3, #2
1721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10253              		.loc 1 1721 0
 10254 5828 85C7DB15 		ldrneb	ip, [fp, #1925]	@ zero_extendqisi2
1740:../uvc.c      **** 				  if(Len == 2){
 10255              		.loc 1 1740 0
 10256 582c 0300A011 		movne	r0, r3
1723:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10257              		.loc 1 1723 0
 10258 5830 8627DB15 		ldrneb	r2, [fp, #1926]	@ zero_extendqisi2
1715:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10259              		.loc 1 1715 0
 10260 5834 6BFCFF1A 		bne	.L800
1716:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10261              		.loc 1 1716 0
 10262 5838 8527DBE5 		ldrb	r2, [fp, #1925]	@ zero_extendqisi2
1717:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10263              		.loc 1 1717 0
 10264 583c 8637DBE5 		ldrb	r3, [fp, #1926]	@ zero_extendqisi2
 10265              	.LVL1172:
1740:../uvc.c      **** 				  if(Len == 2){
 10266              		.loc 1 1740 0
 10267 5840 0200A0E3 		mov	r0, #2
 10268 5844 68171FE5 		ldr	r1, .L904+96
1716:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10269              		.loc 1 1716 0
 10270 5848 2820C8E5 		strb	r2, [r8, #40]
1717:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10271              		.loc 1 1717 0
 10272 584c 2930C8E5 		strb	r3, [r8, #41]
 10273 5850 350000EA 		b	.L868
 10274              	.LVL1173:
 10275              	.L785:
2271:../uvc.c      **** 			  break;
 10276              		.loc 1 2271 0
 10277 5854 0000A0E3 		mov	r0, #0
 10278 5858 0020A0E1 		mov	r2, r0
 10279 585c 0110A0E3 		mov	r1, #1
 10280 5860 FEFFFFEB 		bl	CyU3PUsbStall
 10281              	.LVL1174:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10282              		.loc 1 1355 0
 10283 5864 FF50A0E3 		mov	r5, #255
 10284              	.LVL1175:
2271:../uvc.c      **** 			  break;
 10285              		.loc 1 2271 0
 10286 5868 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10287              		.loc 1 1355 0
 10288 586c 05C0A0E1 		mov	ip, r5
2271:../uvc.c      **** 			  break;
 10289              		.loc 1 2271 0
 10290 5870 24008DE5 		str	r0, [sp, #36]
 10291 5874 0040A0E1 		mov	r4, r0
 10292 5878 89FEFFEA 		b	.L795
 10293              	.LVL1176:
 10294              	.L789:
1679:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10295              		.loc 1 1679 0
 10296 587c 020053E3 		cmp	r3, #2
1680:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10297              		.loc 1 1680 0
 10298 5880 83C7DBE5 		ldrb	ip, [fp, #1923]	@ zero_extendqisi2
1704:../uvc.c      **** 		 	 if(Len == 2){
 10299              		.loc 1 1704 0
 10300 5884 0300A0E1 		mov	r0, r3
1681:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10301              		.loc 1 1681 0
 10302 5888 8427DBE5 		ldrb	r2, [fp, #1924]	@ zero_extendqisi2
1679:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10303              		.loc 1 1679 0
 10304 588c 55FCFF1A 		bne	.L800
 10305              	.LVL1177:
 10306              	.L872:
1813:../uvc.c      **** 		 	 if(Len == 2){
 10307              		.loc 1 1813 0
 10308 5890 B4171FE5 		ldr	r1, .L904+96
1789:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 10309              		.loc 1 1789 0
 10310 5894 28C0C8E5 		strb	ip, [r8, #40]
1790:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 10311              		.loc 1 1790 0
 10312 5898 2920C8E5 		strb	r2, [r8, #41]
 10313 589c 220000EA 		b	.L868
 10314              	.LVL1178:
 10315              	.L788:
1497:../uvc.c      **** 			 	 			 {
 10316              		.loc 1 1497 0
 10317 58a0 020053E3 		cmp	r3, #2
 10318 58a4 EC01000A 		beq	.L902
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10319              		.loc 1 1505 0
 10320 58a8 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10321              		.loc 1 1355 0
 10322 58ac FF50A013 		movne	r5, #255
 10323              	.LVL1179:
 10324 58b0 05C0A011 		movne	ip, r5
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10325              		.loc 1 1505 0
 10326 58b4 C801000A 		beq	.L903
 10327              	.LVL1180:
 10328              	.L797:
1671:../uvc.c      **** 
 10329              		.loc 1 1671 0
 10330 58b8 0300A0E1 		mov	r0, r3
 10331 58bc E0171FE5 		ldr	r1, .L904+96
 10332 58c0 1CC08DE5 		str	ip, [sp, #28]
 10333 58c4 20308DE5 		str	r3, [sp, #32]
 10334 58c8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10335              	.LVL1181:
1674:../uvc.c      **** //#endif
 10336              		.loc 1 1674 0
 10337 58cc 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10338 58d0 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10339 58d4 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10340 58d8 20309DE5 		ldr	r3, [sp, #32]
 10341 58dc 03008DE8 		stmia	sp, {r0, r1}
 10342 58e0 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10343 58e4 08308DE5 		str	r3, [sp, #8]
 10344 58e8 0400A0E3 		mov	r0, #4
 10345 58ec 0E30A0E1 		mov	r3, lr
 10346 58f0 10181FE5 		ldr	r1, .L904+100
 10347 58f4 FEFFFFEB 		bl	CyU3PDebugPrint
 10348              	.LVL1182:
 10349 58f8 00E0A0E3 		mov	lr, #0
 10350 58fc 24E08DE5 		str	lr, [sp, #36]
 10351 5900 0E40A0E1 		mov	r4, lr
 10352 5904 1CC09DE5 		ldr	ip, [sp, #28]
 10353 5908 65FEFFEA 		b	.L795
 10354              	.LVL1183:
 10355              	.L793:
1769:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10356              		.loc 1 1769 0
 10357 590c 8927DBE5 		ldrb	r2, [fp, #1929]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10358              		.loc 1 1781 0
 10359 5910 34181FE5 		ldr	r1, .L904+96
1770:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10360              		.loc 1 1770 0
 10361 5914 0030A0E3 		mov	r3, #0
 10362              	.LVL1184:
1781:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10363              		.loc 1 1781 0
 10364 5918 0100A0E3 		mov	r0, #1
1769:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10365              		.loc 1 1769 0
 10366 591c 2820C8E5 		strb	r2, [r8, #40]
1770:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10367              		.loc 1 1770 0
 10368 5920 2930C8E5 		strb	r3, [r8, #41]
1771:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10369              		.loc 1 1771 0
 10370 5924 2A30C8E5 		strb	r3, [r8, #42]
1772:../uvc.c      **** 		 	 }
 10371              		.loc 1 1772 0
 10372 5928 2B30C8E5 		strb	r3, [r8, #43]
 10373              	.LVL1185:
 10374              	.L868:
1743:../uvc.c      **** 				  }else{
 10375              		.loc 1 1743 0
 10376 592c 00C0A0E3 		mov	ip, #0
 10377 5930 24C08DE5 		str	ip, [sp, #36]
 10378 5934 0040A0E3 		mov	r4, #0
1740:../uvc.c      **** 				  if(Len == 2){
 10379              		.loc 1 1740 0
 10380 5938 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10381              	.LVL1186:
1742:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10382              		.loc 1 1742 0
 10383 593c 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10384              	.LVL1187:
1743:../uvc.c      **** 				  }else{
 10385              		.loc 1 1743 0
 10386 5940 2950D8E5 		ldrb	r5, [r8, #41]	@ zero_extendqisi2
 10387              	.LVL1188:
 10388 5944 56FEFFEA 		b	.L795
 10389              	.LVL1189:
 10390              	.L792:
1751:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10391              		.loc 1 1751 0
 10392 5948 87C7DBE5 		ldrb	ip, [fp, #1927]	@ zero_extendqisi2
1752:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10393              		.loc 1 1752 0
 10394 594c 8827DBE5 		ldrb	r2, [fp, #1928]	@ zero_extendqisi2
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10395              		.loc 1 1762 0
 10396 5950 0300A0E1 		mov	r0, r3
1753:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10397              		.loc 1 1753 0
 10398 5954 0030A0E3 		mov	r3, #0
 10399              	.LVL1190:
1762:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10400              		.loc 1 1762 0
 10401 5958 7C181FE5 		ldr	r1, .L904+96
1751:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10402              		.loc 1 1751 0
 10403 595c 28C0C8E5 		strb	ip, [r8, #40]
1752:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10404              		.loc 1 1752 0
 10405 5960 2920C8E5 		strb	r2, [r8, #41]
1753:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10406              		.loc 1 1753 0
 10407 5964 2A30C8E5 		strb	r3, [r8, #42]
1754:../uvc.c      **** 		 	 }
 10408              		.loc 1 1754 0
 10409 5968 2B30C8E5 		strb	r3, [r8, #43]
 10410 596c EEFFFFEA 		b	.L868
 10411              	.LVL1191:
 10412              	.L901:
 10413              	.LBE148:
 10414              	.LBE154:
 10415              	.LBE164:
 10416              	.LBE294:
 10417              	.LBB295:
 10418              	.LBB277:
 10419              	.LBB259:
 10420              	.LBB199:
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10421              		.loc 1 1656 0
 10422 5970 0500A0E1 		mov	r0, r5
 10423 5974 2C109DE5 		ldr	r1, [sp, #44]
 10424 5978 20308DE5 		str	r3, [sp, #32]
 10425 597c FEFFFFEB 		bl	SensorGetControl
 10426              	.LVL1192:
1657:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10427              		.loc 1 1657 0
 10428 5980 90C81FE5 		ldr	ip, .L904+116
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10429              		.loc 1 1658 0
 10430 5984 2C109DE5 		ldr	r1, [sp, #44]
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10431              		.loc 1 1656 0
 10432 5988 0020A0E1 		mov	r2, r0
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10433              		.loc 1 1658 0
 10434 598c 30009DE5 		ldr	r0, [sp, #48]
1657:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10435              		.loc 1 1657 0
 10436 5990 6527CCE5 		strb	r2, [ip, #1893]
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10437              		.loc 1 1656 0
 10438 5994 2820C8E5 		strb	r2, [r8, #40]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10439              		.loc 1 1658 0
 10440 5998 FEFFFFEB 		bl	SensorGetControl
 10441              	.LVL1193:
1659:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10442              		.loc 1 1659 0
 10443 599c ACE81FE5 		ldr	lr, .L904+116
1660:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10444              		.loc 1 1660 0
 10445 59a0 0020A0E3 		mov	r2, #0
 10446 59a4 2920C8E5 		strb	r2, [r8, #41]
1661:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10447              		.loc 1 1661 0
 10448 59a8 2B20C8E5 		strb	r2, [r8, #43]
1662:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10449              		.loc 1 1662 0
 10450 59ac 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10451              	.LVL1194:
1659:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10452              		.loc 1 1659 0
 10453 59b0 6607CEE5 		strb	r0, [lr, #1894]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10454              		.loc 1 1658 0
 10455 59b4 0050A0E1 		mov	r5, r0
 10456              	.LVL1195:
 10457 59b8 2A00C8E5 		strb	r0, [r8, #42]
 10458 59bc 20309DE5 		ldr	r3, [sp, #32]
 10459 59c0 57FFFFEA 		b	.L719
 10460              	.LVL1196:
 10461              	.L898:
 10462              	.LBE199:
 10463              	.LBE259:
 10464              	.LBB260:
 10465              	.LBB212:
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10466              		.loc 1 1656 0
 10467 59c4 0510A0E1 		mov	r1, r5
 10468 59c8 0400A0E1 		mov	r0, r4
 10469 59cc 1CC08DE5 		str	ip, [sp, #28]
 10470 59d0 FEFFFFEB 		bl	SensorGetControl
 10471              	.LVL1197:
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10472              		.loc 1 1658 0
 10473 59d4 0510A0E1 		mov	r1, r5
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10474              		.loc 1 1656 0
 10475 59d8 0030A0E1 		mov	r3, r0
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10476              		.loc 1 1658 0
 10477 59dc 2C009DE5 		ldr	r0, [sp, #44]
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10478              		.loc 1 1656 0
 10479 59e0 2830C8E5 		strb	r3, [r8, #40]
1657:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10480              		.loc 1 1657 0
 10481 59e4 A935CBE5 		strb	r3, [fp, #1449]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10482              		.loc 1 1658 0
 10483 59e8 FEFFFFEB 		bl	SensorGetControl
 10484              	.LVL1198:
1660:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10485              		.loc 1 1660 0
 10486 59ec 0030A0E3 		mov	r3, #0
 10487 59f0 2930C8E5 		strb	r3, [r8, #41]
1661:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10488              		.loc 1 1661 0
 10489 59f4 2B30C8E5 		strb	r3, [r8, #43]
1662:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10490              		.loc 1 1662 0
 10491 59f8 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 10492              	.LVL1199:
1659:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10493              		.loc 1 1659 0
 10494 59fc AA05CBE5 		strb	r0, [fp, #1450]
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10495              		.loc 1 1658 0
 10496 5a00 0040A0E1 		mov	r4, r0
 10497              	.LVL1200:
 10498 5a04 2A00C8E5 		strb	r0, [r8, #42]
 10499 5a08 1CC09DE5 		ldr	ip, [sp, #28]
 10500 5a0c 73FEFFEA 		b	.L650
 10501              	.LVL1201:
 10502              	.L801:
 10503              	.LBE212:
 10504              	.LBE260:
 10505              	.LBE277:
 10506              	.LBE295:
 10507              	.LBB296:
 10508              	.LBB165:
 10509              	.LBB155:
 10510              	.LBB149:
2263:../uvc.c      **** 			   }
 10511              		.loc 1 2263 0
 10512 5a10 34209DE5 		ldr	r2, [sp, #52]
 10513 5a14 0400A0E3 		mov	r0, #4
 10514              	.LVL1202:
 10515 5a18 34191FE5 		ldr	r1, .L904+104
 10516 5a1c FEFFFFEB 		bl	CyU3PDebugPrint
 10517              	.LVL1203:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10518              		.loc 1 1355 0
 10519 5a20 FF50A0E3 		mov	r5, #255
 10520              	.LVL1204:
2263:../uvc.c      **** 			   }
 10521              		.loc 1 2263 0
 10522 5a24 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10523              		.loc 1 1355 0
 10524 5a28 05C0A0E1 		mov	ip, r5
2263:../uvc.c      **** 			   }
 10525              		.loc 1 2263 0
 10526 5a2c 24E08DE5 		str	lr, [sp, #36]
 10527 5a30 0E40A0E1 		mov	r4, lr
 10528 5a34 1AFEFFEA 		b	.L795
 10529              	.LVL1205:
 10530              	.L894:
 10531              	.LBE149:
 10532              	.LBE155:
 10533              	.LBE165:
 10534              	.LBE296:
 10535              	.LBB297:
 10536              	.LBB278:
 10537              	.LBB261:
 10538              	.LBB200:
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10539              		.loc 1 1693 0
 10540 5a38 48191FE5 		ldr	r1, .L904+116
1704:../uvc.c      **** 		 	 if(Len == 2){
 10541              		.loc 1 1704 0
 10542 5a3c 0300A0E1 		mov	r0, r3
1693:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10543              		.loc 1 1693 0
 10544 5a40 5BC7D1E5 		ldrb	ip, [r1, #1883]	@ zero_extendqisi2
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10545              		.loc 1 1694 0
 10546 5a44 5C27D1E5 		ldrb	r2, [r1, #1884]	@ zero_extendqisi2
 10547 5a48 B3FEFFEA 		b	.L862
 10548              	.LVL1206:
 10549              	.L893:
 10550              	.LBE200:
 10551              	.LBE261:
 10552              	.LBB262:
 10553              	.LBB187:
2147:../uvc.c      **** 			                         {
 10554              		.loc 1 2147 0
 10555 5a4c 7030D9E5 		ldrb	r3, [r9, #112]	@ zero_extendqisi2
 10556 5a50 013043E2 		sub	r3, r3, #1
 10557 5a54 030053E3 		cmp	r3, #3
 10558 5a58 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 10559 5a5c 56FCFFEA 		b	.L693
 10560              	.L695:
 10561 5a60 745B0000 		.word	.L694
 10562 5a64 285B0000 		.word	.L696
 10563 5a68 CC5A0000 		.word	.L697
 10564 5a6c 705A0000 		.word	.L698
 10565              	.L698:
2165:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10566              		.loc 1 2165 0
 10567 5a70 6C2098E5 		ldr	r2, [r8, #108]
 10568 5a74 5230DBE5 		ldrb	r3, [fp, #82]	@ zero_extendqisi2
 10569 5a78 000052E3 		cmp	r2, #0
 10570 5a7c B020A003 		moveq	r2, #176
 10571 5a80 3020A013 		movne	r2, #48
 10572 5a84 032082E1 		orr	r2, r2, r3
 10573 5a88 3010A0E3 		mov	r1, #48
 10574 5a8c 5230A0E3 		mov	r3, #82
 10575 5a90 0100A0E3 		mov	r0, #1
 10576 5a94 FEFFFFEB 		bl	SensorSetIrisControl
 10577              	.LVL1207:
2166:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 10578              		.loc 1 2166 0
 10579 5a98 7D0FA0E3 		mov	r0, #500
 10580 5a9c FEFFFFEB 		bl	_tx_thread_sleep
 10581              	.LVL1208:
2167:../uvc.c      **** 			                         	default:
 10582              		.loc 1 2167 0
 10583 5aa0 6C1098E5 		ldr	r1, [r8, #108]
 10584 5aa4 5220DBE5 		ldrb	r2, [fp, #82]	@ zero_extendqisi2
 10585 5aa8 000051E3 		cmp	r1, #0
 10586 5aac B010A003 		moveq	r1, #176
 10587 5ab0 3010A013 		movne	r1, #48
 10588 5ab4 022081E1 		orr	r2, r1, r2
 10589 5ab8 6C3098E5 		ldr	r3, [r8, #108]
 10590 5abc E4191FE5 		ldr	r1, .L904+92
 10591 5ac0 0400A0E3 		mov	r0, #4
 10592 5ac4 FEFFFFEB 		bl	CyU3PDebugPrint
 10593              	.LVL1209:
 10594 5ac8 3BFCFFEA 		b	.L693
 10595              	.L697:
2160:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10596              		.loc 1 2160 0
 10597 5acc 6C2098E5 		ldr	r2, [r8, #108]
 10598 5ad0 5230DBE5 		ldrb	r3, [fp, #82]	@ zero_extendqisi2
 10599 5ad4 000052E3 		cmp	r2, #0
 10600 5ad8 8020A003 		moveq	r2, #128
 10601 5adc 0020A013 		movne	r2, #0
 10602 5ae0 032082E1 		orr	r2, r2, r3
 10603 5ae4 3010A0E3 		mov	r1, #48
 10604 5ae8 5230A0E3 		mov	r3, #82
 10605 5aec 0100A0E3 		mov	r0, #1
 10606 5af0 FEFFFFEB 		bl	SensorSetIrisControl
 10607              	.LVL1210:
2161:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 10608              		.loc 1 2161 0
 10609 5af4 7D0FA0E3 		mov	r0, #500
 10610 5af8 FEFFFFEB 		bl	_tx_thread_sleep
 10611              	.LVL1211:
2162:../uvc.c      **** 			                         		break;
 10612              		.loc 1 2162 0
 10613 5afc 6C1098E5 		ldr	r1, [r8, #108]
 10614 5b00 5220DBE5 		ldrb	r2, [fp, #82]	@ zero_extendqisi2
 10615 5b04 000051E3 		cmp	r1, #0
 10616 5b08 8010A003 		moveq	r1, #128
 10617 5b0c 0010A013 		movne	r1, #0
 10618 5b10 022081E1 		orr	r2, r1, r2
 10619 5b14 6C3098E5 		ldr	r3, [r8, #108]
 10620 5b18 401A1FE5 		ldr	r1, .L904+92
 10621 5b1c 0400A0E3 		mov	r0, #4
 10622 5b20 FEFFFFEB 		bl	CyU3PDebugPrint
 10623              	.LVL1212:
 10624 5b24 24FCFFEA 		b	.L693
 10625              	.L696:
2155:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10626              		.loc 1 2155 0
 10627 5b28 6C2098E5 		ldr	r2, [r8, #108]
 10628 5b2c 3010A0E3 		mov	r1, #48
 10629 5b30 000052E3 		cmp	r2, #0
 10630 5b34 9220A003 		moveq	r2, #146
 10631 5b38 1220A013 		movne	r2, #18
 10632 5b3c 5230A0E3 		mov	r3, #82
 10633 5b40 0100A0E3 		mov	r0, #1
 10634 5b44 FEFFFFEB 		bl	SensorSetIrisControl
 10635              	.LVL1213:
2156:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 10636              		.loc 1 2156 0
 10637 5b48 7D0FA0E3 		mov	r0, #500
 10638 5b4c FEFFFFEB 		bl	_tx_thread_sleep
 10639              	.LVL1214:
2157:../uvc.c      **** 			                         		break;
 10640              		.loc 1 2157 0
 10641 5b50 6C2098E5 		ldr	r2, [r8, #108]
 10642 5b54 7C1A1FE5 		ldr	r1, .L904+92
 10643 5b58 000052E3 		cmp	r2, #0
 10644 5b5c 6C3098E5 		ldr	r3, [r8, #108]
 10645 5b60 9220A003 		moveq	r2, #146
 10646 5b64 1220A013 		movne	r2, #18
 10647 5b68 0400A0E3 		mov	r0, #4
 10648 5b6c FEFFFFEB 		bl	CyU3PDebugPrint
 10649              	.LVL1215:
 10650 5b70 11FCFFEA 		b	.L693
 10651              	.L694:
2150:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10652              		.loc 1 2150 0
 10653 5b74 6C2098E5 		ldr	r2, [r8, #108]
 10654 5b78 3010A0E3 		mov	r1, #48
 10655 5b7c 000052E3 		cmp	r2, #0
 10656 5b80 A220A003 		moveq	r2, #162
 10657 5b84 2220A013 		movne	r2, #34
 10658 5b88 5230A0E3 		mov	r3, #82
 10659 5b8c 0100A0E3 		mov	r0, #1
 10660 5b90 FEFFFFEB 		bl	SensorSetIrisControl
 10661              	.LVL1216:
2151:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 10662              		.loc 1 2151 0
 10663 5b94 7D0FA0E3 		mov	r0, #500
 10664 5b98 FEFFFFEB 		bl	_tx_thread_sleep
 10665              	.LVL1217:
2152:../uvc.c      **** 			                         		break;
 10666              		.loc 1 2152 0
 10667 5b9c 6C2098E5 		ldr	r2, [r8, #108]
 10668 5ba0 C81A1FE5 		ldr	r1, .L904+92
 10669 5ba4 000052E3 		cmp	r2, #0
 10670 5ba8 6C3098E5 		ldr	r3, [r8, #108]
 10671 5bac A220A003 		moveq	r2, #162
 10672 5bb0 2220A013 		movne	r2, #34
 10673 5bb4 0400A0E3 		mov	r0, #4
 10674 5bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 10675              	.LVL1218:
 10676 5bbc FEFBFFEA 		b	.L693
 10677              	.LVL1219:
 10678              	.L734:
 10679              	.LBE187:
 10680              	.LBE262:
 10681              	.LBB263:
 10682              	.LBB224:
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 10683              		.loc 1 1595 0
 10684 5bc0 0C00A0E1 		mov	r0, ip
 10685 5bc4 28109DE5 		ldr	r1, [sp, #40]
 10686 5bc8 20308DE5 		str	r3, [sp, #32]
 10687 5bcc FEFFFFEB 		bl	SensorGetControl
 10688              	.LVL1220:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10689              		.loc 1 1596 0
 10690 5bd0 28109DE5 		ldr	r1, [sp, #40]
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 10691              		.loc 1 1595 0
 10692 5bd4 0050A0E1 		mov	r5, r0
 10693              	.LVL1221:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10694              		.loc 1 1596 0
 10695 5bd8 2C009DE5 		ldr	r0, [sp, #44]
 10696              	.LVL1222:
 10697 5bdc FEFFFFEB 		bl	SensorGetControl
 10698              	.LVL1223:
1671:../uvc.c      **** 
 10699              		.loc 1 1671 0
 10700 5be0 20309DE5 		ldr	r3, [sp, #32]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 10701              		.loc 1 1603 0
 10702 5be4 0020A0E3 		mov	r2, #0
1671:../uvc.c      **** 
 10703              		.loc 1 1671 0
 10704 5be8 0C1B1FE5 		ldr	r1, .L904+96
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 10705              		.loc 1 1598 0
 10706 5bec 8455CBE5 		strb	r5, [fp, #1412]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 10707              		.loc 1 1603 0
 10708 5bf0 2920C8E5 		strb	r2, [r8, #41]
1604:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10709              		.loc 1 1604 0
 10710 5bf4 2B20C8E5 		strb	r2, [r8, #43]
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 10711              		.loc 1 1597 0
 10712 5bf8 2850C8E5 		strb	r5, [r8, #40]
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10713              		.loc 1 1596 0
 10714 5bfc 24008DE5 		str	r0, [sp, #36]
 10715              	.LVL1224:
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 10716              		.loc 1 1599 0
 10717 5c00 24C09DE5 		ldr	ip, [sp, #36]
1671:../uvc.c      **** 
 10718              		.loc 1 1671 0
 10719 5c04 0300A0E1 		mov	r0, r3
1600:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10720              		.loc 1 1600 0
 10721 5c08 86C5CBE5 		strb	ip, [fp, #1414]
 10722              	.LVL1225:
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 10723              		.loc 1 1599 0
 10724 5c0c 2AC0C8E5 		strb	ip, [r8, #42]
1671:../uvc.c      **** 
 10725              		.loc 1 1671 0
 10726 5c10 20308DE5 		str	r3, [sp, #32]
 10727 5c14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10728              	.LVL1226:
1674:../uvc.c      **** //#endif
 10729              		.loc 1 1674 0
 10730 5c18 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10731 5c1c 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10732 5c20 20309DE5 		ldr	r3, [sp, #32]
 10733 5c24 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10734 5c28 03008DE8 		stmia	sp, {r0, r1}
 10735 5c2c 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10736 5c30 08308DE5 		str	r3, [sp, #8]
 10737 5c34 0400A0E3 		mov	r0, #4
 10738 5c38 0E30A0E1 		mov	r3, lr
 10739 5c3c 5C1B1FE5 		ldr	r1, .L904+100
 10740 5c40 FEFFFFEB 		bl	CyU3PDebugPrint
 10741              	.LVL1227:
 10742 5c44 24309DE5 		ldr	r3, [sp, #36]
 10743 5c48 0520A0E1 		mov	r2, r5
 10744 5c4c 03C0A0E1 		mov	ip, r3
 10745 5c50 68FCFFEA 		b	.L741
 10746              	.LVL1228:
 10747              	.L677:
 10748              	.LBE224:
 10749              	.LBE263:
 10750              	.LBB264:
 10751              	.LBB188:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 10752              		.loc 1 1579 0
 10753 5c54 0410A0E1 		mov	r1, r4
 10754 5c58 0100A0E3 		mov	r0, #1
 10755 5c5c 20308DE5 		str	r3, [sp, #32]
 10756 5c60 FEFFFFEB 		bl	SensorGetControl
 10757              	.LVL1229:
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 10758              		.loc 1 1582 0
 10759 5c64 74EB1FE5 		ldr	lr, .L904+116
1671:../uvc.c      **** 
 10760              		.loc 1 1671 0
 10761 5c68 8C1B1FE5 		ldr	r1, .L904+96
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 10762              		.loc 1 1580 0
 10763 5c6c A0C3A0E1 		mov	ip, r0, lsr #7
 10764 5c70 FFC00CE2 		and	ip, ip, #255
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 10765              		.loc 1 1582 0
 10766 5c74 7DC5CEE5 		strb	ip, [lr, #1405]
1671:../uvc.c      **** 
 10767              		.loc 1 1671 0
 10768 5c78 20309DE5 		ldr	r3, [sp, #32]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10769              		.loc 1 1583 0
 10770 5c7c 7E45DEE5 		ldrb	r4, [lr, #1406]	@ zero_extendqisi2
 10771              	.LVL1230:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 10772              		.loc 1 1579 0
 10773 5c80 0050A0E1 		mov	r5, r0
 10774              	.LVL1231:
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10775              		.loc 1 1583 0
 10776 5c84 FF4004E2 		and	r4, r4, #255
1671:../uvc.c      **** 
 10777              		.loc 1 1671 0
 10778 5c88 0300A0E1 		mov	r0, r3
 10779              	.LVL1232:
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 10780              		.loc 1 1580 0
 10781 5c8c 28C0C8E5 		strb	ip, [r8, #40]
1671:../uvc.c      **** 
 10782              		.loc 1 1671 0
 10783 5c90 1CC08DE5 		str	ip, [sp, #28]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10784              		.loc 1 1583 0
 10785 5c94 2940C8E5 		strb	r4, [r8, #41]
 10786              	.LVL1233:
1671:../uvc.c      **** 
 10787              		.loc 1 1671 0
 10788 5c98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10789              	.LVL1234:
1674:../uvc.c      **** //#endif
 10790              		.loc 1 1674 0
 10791 5c9c 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10792 5ca0 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10793 5ca4 20309DE5 		ldr	r3, [sp, #32]
 10794 5ca8 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10795 5cac 03008DE8 		stmia	sp, {r0, r1}
 10796 5cb0 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10797 5cb4 08308DE5 		str	r3, [sp, #8]
 10798 5cb8 D81B1FE5 		ldr	r1, .L904+100
 10799 5cbc 0E30A0E1 		mov	r3, lr
 10800 5cc0 0400A0E3 		mov	r0, #4
 10801 5cc4 FEFFFFEB 		bl	CyU3PDebugPrint
 10802              	.LVL1235:
 10803 5cc8 0000A0E3 		mov	r0, #0
 10804 5ccc 28008DE5 		str	r0, [sp, #40]
 10805 5cd0 1CC09DE5 		ldr	ip, [sp, #28]
 10806 5cd4 0010A0E1 		mov	r1, r0
 10807 5cd8 BCFBFFEA 		b	.L684
 10808              	.LVL1236:
 10809              	.L654:
 10810              	.LBE188:
 10811              	.LBE264:
 10812              	.LBB265:
 10813              	.LBB213:
2263:../uvc.c      **** 			   }
 10814              		.loc 1 2263 0
 10815 5cdc F81B1FE5 		ldr	r1, .L904+104
 10816 5ce0 0400A0E3 		mov	r0, #4
 10817              	.LVL1237:
 10818 5ce4 FEFFFFEB 		bl	CyU3PDebugPrint
 10819              	.LVL1238:
 10820 5ce8 D1FDFFEA 		b	.L853
 10821              	.LVL1239:
 10822              	.L745:
 10823              	.LBE213:
 10824              	.LBE265:
 10825              	.LBB266:
 10826              	.LBB225:
 10827 5cec 081C1FE5 		ldr	r1, .L904+104
 10828 5cf0 0400A0E3 		mov	r0, #4
 10829              	.LVL1240:
 10830 5cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 10831              	.LVL1241:
 10832 5cf8 ACFDFFEA 		b	.L865
 10833              	.LVL1242:
 10834              	.L688:
 10835              	.LBE225:
 10836              	.LBE266:
 10837              	.LBB267:
 10838              	.LBB189:
 10839 5cfc 181C1FE5 		ldr	r1, .L904+104
 10840 5d00 0400A0E3 		mov	r0, #4
 10841              	.LVL1243:
 10842 5d04 FEFFFFEB 		bl	CyU3PDebugPrint
 10843              	.LVL1244:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10844              		.loc 1 1355 0
 10845 5d08 FF40A0E3 		mov	r4, #255
 10846              	.LVL1245:
2263:../uvc.c      **** 			   }
 10847              		.loc 1 2263 0
 10848 5d0c 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10849              		.loc 1 1355 0
 10850 5d10 04C0A0E1 		mov	ip, r4
2263:../uvc.c      **** 			   }
 10851              		.loc 1 2263 0
 10852 5d14 28E08DE5 		str	lr, [sp, #40]
 10853 5d18 0E50A0E1 		mov	r5, lr
 10854 5d1c 0E10A0E1 		mov	r1, lr
 10855 5d20 AAFBFFEA 		b	.L684
 10856              	.LVL1246:
 10857              	.L671:
 10858              	.LBE189:
 10859              	.LBE267:
 10860              	.LBB268:
 10861              	.LBB178:
 10862 5d24 401C1FE5 		ldr	r1, .L904+104
 10863 5d28 0400A0E3 		mov	r0, #4
 10864              	.LVL1247:
 10865 5d2c FEFFFFEB 		bl	CyU3PDebugPrint
 10866              	.LVL1248:
 10867 5d30 58FEFFEA 		b	.L858
 10868              	.LVL1249:
 10869              	.L892:
 10870              	.LBE178:
 10871              	.LBE268:
 10872              	.LBB269:
 10873              	.LBB201:
2242:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 10874              		.loc 1 2242 0
 10875 5d34 48CC1FE5 		ldr	ip, .L904+112
 10876 5d38 0010E0E3 		mvn	r1, #0
 10877 5d3c 1C009CE5 		ldr	r0, [ip, #28]
 10878 5d40 3CC08DE5 		str	ip, [sp, #60]
 10879 5d44 FEFFFFEB 		bl	_txe_mutex_get
 10880              	.LVL1250:
2243:../uvc.c      **** 								 {
 10881              		.loc 1 2243 0
 10882 5d48 58EC1FE5 		ldr	lr, .L904+116
 10883 5d4c 6537DEE5 		ldrb	r3, [lr, #1893]	@ zero_extendqisi2
 10884 5d50 030054E1 		cmp	r4, r3
1834:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 10885              		.loc 1 1834 0
 10886 5d54 34309D05 		ldreq	r3, [sp, #52]
2243:../uvc.c      **** 								 {
 10887              		.loc 1 2243 0
 10888 5d58 0900000A 		beq	.L729
2246:../uvc.c      **** 									 dataIdx++;
 10889              		.loc 1 2246 0
 10890 5d5c 34C09DE5 		ldr	ip, [sp, #52]
 10891 5d60 00408DE5 		str	r4, [sp]
 10892 5d64 04C08DE5 		str	ip, [sp, #4]
 10893 5d68 2C309DE5 		ldr	r3, [sp, #44]
 10894 5d6c 30209DE5 		ldr	r2, [sp, #48]
 10895 5d70 3C009DE5 		ldr	r0, [sp, #60]
 10896 5d74 0910A0E3 		mov	r1, #9
2245:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 10897              		.loc 1 2245 0
 10898 5d78 6547CEE5 		strb	r4, [lr, #1893]
2246:../uvc.c      **** 									 dataIdx++;
 10899              		.loc 1 2246 0
 10900 5d7c FEFFFFEB 		bl	cmdSet
 10901              	.LVL1251:
2247:../uvc.c      **** 								 }
 10902              		.loc 1 2247 0
 10903 5d80 28309DE5 		ldr	r3, [sp, #40]
 10904              	.LVL1252:
 10905              	.L729:
2249:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 10906              		.loc 1 2249 0
 10907 5d84 6627DBE5 		ldrb	r2, [fp, #1894]	@ zero_extendqisi2
 10908 5d88 24C09DE5 		ldr	ip, [sp, #36]
 10909 5d8c 02005CE1 		cmp	ip, r2
 10910 5d90 0800000A 		beq	.L730
2250:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 10911              		.loc 1 2250 0
 10912 5d94 A4EC1FE5 		ldr	lr, .L904+116
2251:../uvc.c      **** 								 }
 10913              		.loc 1 2251 0
 10914 5d98 04308DE5 		str	r3, [sp, #4]
 10915 5d9c 00C08DE5 		str	ip, [sp]
 10916 5da0 0520A0E1 		mov	r2, r5
 10917 5da4 2C309DE5 		ldr	r3, [sp, #44]
 10918              	.LVL1253:
 10919 5da8 BC0C1FE5 		ldr	r0, .L904+112
 10920 5dac 0910A0E3 		mov	r1, #9
2250:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 10921              		.loc 1 2250 0
 10922 5db0 66C7CEE5 		strb	ip, [lr, #1894]
2251:../uvc.c      **** 								 }
 10923              		.loc 1 2251 0
 10924 5db4 FEFFFFEB 		bl	cmdSet
 10925              	.LVL1254:
 10926              	.L730:
2254:../uvc.c      **** 
 10927              		.loc 1 2254 0
 10928 5db8 3CC09DE5 		ldr	ip, [sp, #60]
2253:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10929              		.loc 1 2253 0
 10930 5dbc 0130A0E3 		mov	r3, #1
2254:../uvc.c      **** 
 10931              		.loc 1 2254 0
 10932 5dc0 1C009CE5 		ldr	r0, [ip, #28]
2253:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10933              		.loc 1 2253 0
 10934 5dc4 6937CBE5 		strb	r3, [fp, #1897]
2254:../uvc.c      **** 
 10935              		.loc 1 2254 0
 10936 5dc8 FEFFFFEB 		bl	_txe_mutex_put
 10937              	.LVL1255:
 10938 5dcc 3CFBFFEA 		b	.L728
 10939              	.LVL1256:
 10940              	.L891:
1829:../uvc.c      **** 				 }else{
 10941              		.loc 1 1829 0
 10942 5dd0 29C0D9E5 		ldrb	ip, [r9, #41]	@ zero_extendqisi2
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10943              		.loc 1 1835 0
 10944 5dd4 0400A0E3 		mov	r0, #4
 10945              	.LVL1257:
1829:../uvc.c      **** 				 }else{
 10946              		.loc 1 1829 0
 10947 5dd8 24C08DE5 		str	ip, [sp, #36]
 10948              	.LVL1258:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10949              		.loc 1 1835 0
 10950 5ddc 2CC09DE5 		ldr	ip, [sp, #44]
 10951 5de0 08308DE5 		str	r3, [sp, #8]
 10952 5de4 04C08DE5 		str	ip, [sp, #4]
 10953 5de8 24C09DE5 		ldr	ip, [sp, #36]
 10954 5dec 30309DE5 		ldr	r3, [sp, #48]
 10955 5df0 00508DE5 		str	r5, [sp]
 10956 5df4 0C408DE5 		str	r4, [sp, #12]
 10957 5df8 10C08DE5 		str	ip, [sp, #16]
 10958 5dfc 141D1FE5 		ldr	r1, .L904+108
 10959 5e00 0920A0E3 		mov	r2, #9
 10960 5e04 FEFFFFEB 		bl	CyU3PDebugPrint
 10961              	.LVL1259:
2233:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 10962              		.loc 1 2233 0
 10963 5e08 18ED1FE5 		ldr	lr, .L904+116
 10964 5e0c 6537DEE5 		ldrb	r3, [lr, #1893]	@ zero_extendqisi2
 10965 5e10 030054E1 		cmp	r4, r3
 10966 5e14 1100000A 		beq	.L726
2234:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 10967              		.loc 1 2234 0
 10968 5e18 2C5D1FE5 		ldr	r5, .L904+112
 10969              	.LVL1260:
 10970 5e1c 0010E0E3 		mvn	r1, #0
 10971 5e20 1C0095E5 		ldr	r0, [r5, #28]
 10972 5e24 FEFFFFEB 		bl	_txe_mutex_get
 10973              	.LVL1261:
2235:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10974              		.loc 1 2235 0
 10975 5e28 34C09DE5 		ldr	ip, [sp, #52]
 10976 5e2c 30209DE5 		ldr	r2, [sp, #48]
 10977 5e30 04C08DE5 		str	ip, [sp, #4]
 10978 5e34 2C309DE5 		ldr	r3, [sp, #44]
 10979 5e38 0910A0E3 		mov	r1, #9
 10980 5e3c 00408DE5 		str	r4, [sp]
 10981 5e40 0500A0E1 		mov	r0, r5
 10982 5e44 FEFFFFEB 		bl	cmdSet
 10983              	.LVL1262:
2236:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 10984              		.loc 1 2236 0
 10985 5e48 1C0095E5 		ldr	r0, [r5, #28]
 10986 5e4c FEFFFFEB 		bl	_txe_mutex_put
 10987              	.LVL1263:
2237:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 10988              		.loc 1 2237 0
 10989 5e50 60ED1FE5 		ldr	lr, .L904+116
2238:../uvc.c      **** 								 }
 10990              		.loc 1 2238 0
 10991 5e54 34C09DE5 		ldr	ip, [sp, #52]
2237:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 10992              		.loc 1 2237 0
 10993 5e58 6547CEE5 		strb	r4, [lr, #1893]
2238:../uvc.c      **** 								 }
 10994              		.loc 1 2238 0
 10995 5e5c 66C7CEE5 		strb	ip, [lr, #1894]
 10996              	.L726:
2240:../uvc.c      **** 			 	 			 }else if(Len == 4){
 10997              		.loc 1 2240 0
 10998 5e60 0130A0E3 		mov	r3, #1
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10999              		.loc 1 1835 0
 11000 5e64 02C0A0E3 		mov	ip, #2
2240:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11001              		.loc 1 2240 0
 11002 5e68 6937CBE5 		strb	r3, [fp, #1897]
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11003              		.loc 1 1835 0
 11004 5e6c 38C08DE5 		str	ip, [sp, #56]
 11005 5e70 13FBFFEA 		b	.L728
 11006              	.LVL1264:
 11007              	.L723:
2263:../uvc.c      **** 			   }
 11008              		.loc 1 2263 0
 11009 5e74 901D1FE5 		ldr	r1, .L904+104
 11010 5e78 34209DE5 		ldr	r2, [sp, #52]
 11011 5e7c 0400A0E3 		mov	r0, #4
 11012              	.LVL1265:
 11013 5e80 FEFFFFEB 		bl	CyU3PDebugPrint
 11014              	.LVL1266:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11015              		.loc 1 1355 0
 11016 5e84 FF50A0E3 		mov	r5, #255
 11017              	.LVL1267:
2263:../uvc.c      **** 			   }
 11018              		.loc 1 2263 0
 11019 5e88 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11020              		.loc 1 1355 0
 11021 5e8c 05C0A0E1 		mov	ip, r5
2263:../uvc.c      **** 			   }
 11022              		.loc 1 2263 0
 11023 5e90 24E08DE5 		str	lr, [sp, #36]
 11024 5e94 0E40A0E1 		mov	r4, lr
 11025 5e98 0E10A0E1 		mov	r1, lr
 11026 5e9c 14FBFFEA 		b	.L717
 11027              	.LVL1268:
 11028              	.L895:
 11029              	.LBE201:
 11030              	.LBE269:
 11031              	.LBE278:
 11032              	.LBE297:
 11033              	.LBB298:
 11034              	.LBB166:
 11035              	.LBB156:
 11036              	.LBB150:
1829:../uvc.c      **** 				 }else{
 11037              		.loc 1 1829 0
 11038 5ea0 29C0D9E5 		ldrb	ip, [r9, #41]	@ zero_extendqisi2
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11039              		.loc 1 1835 0
 11040 5ea4 0400A0E3 		mov	r0, #4
 11041              	.LVL1269:
1829:../uvc.c      **** 				 }else{
 11042              		.loc 1 1829 0
 11043 5ea8 24C08DE5 		str	ip, [sp, #36]
 11044              	.LVL1270:
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11045              		.loc 1 1835 0
 11046 5eac 2CC09DE5 		ldr	ip, [sp, #44]
 11047 5eb0 08308DE5 		str	r3, [sp, #8]
 11048 5eb4 04C08DE5 		str	ip, [sp, #4]
 11049 5eb8 24C09DE5 		ldr	ip, [sp, #36]
 11050 5ebc 30309DE5 		ldr	r3, [sp, #48]
 11051 5ec0 00508DE5 		str	r5, [sp]
 11052 5ec4 0C408DE5 		str	r4, [sp, #12]
 11053 5ec8 10C08DE5 		str	ip, [sp, #16]
 11054 5ecc E41D1FE5 		ldr	r1, .L904+108
 11055 5ed0 2720A0E3 		mov	r2, #39
 11056 5ed4 FEFFFFEB 		bl	CyU3PDebugPrint
 11057              	.LVL1271:
2042:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11058              		.loc 1 2042 0
 11059 5ed8 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
 11060 5edc 030054E1 		cmp	r4, r3
 11061 5ee0 1100000A 		beq	.L804
2043:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11062              		.loc 1 2043 0
 11063 5ee4 F85D1FE5 		ldr	r5, .L904+112
 11064              	.LVL1272:
 11065 5ee8 0010E0E3 		mvn	r1, #0
 11066 5eec 1C0095E5 		ldr	r0, [r5, #28]
 11067 5ef0 FEFFFFEB 		bl	_txe_mutex_get
 11068              	.LVL1273:
2044:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11069              		.loc 1 2044 0
 11070 5ef4 34C09DE5 		ldr	ip, [sp, #52]
 11071 5ef8 30209DE5 		ldr	r2, [sp, #48]
 11072 5efc 04C08DE5 		str	ip, [sp, #4]
 11073 5f00 2C309DE5 		ldr	r3, [sp, #44]
 11074 5f04 2710A0E3 		mov	r1, #39
 11075 5f08 00408DE5 		str	r4, [sp]
 11076 5f0c 0500A0E1 		mov	r0, r5
 11077 5f10 FEFFFFEB 		bl	cmdSet
 11078              	.LVL1274:
2045:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11079              		.loc 1 2045 0
 11080 5f14 1C0095E5 		ldr	r0, [r5, #28]
 11081 5f18 FEFFFFEB 		bl	_txe_mutex_put
 11082              	.LVL1275:
2046:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11083              		.loc 1 2046 0
 11084 5f1c 2CEE1FE5 		ldr	lr, .L904+116
2047:../uvc.c      **** 									 }
 11085              		.loc 1 2047 0
 11086 5f20 34C09DE5 		ldr	ip, [sp, #52]
2046:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11087              		.loc 1 2046 0
 11088 5f24 8D47CEE5 		strb	r4, [lr, #1933]
2047:../uvc.c      **** 									 }
 11089              		.loc 1 2047 0
 11090 5f28 8EC7CEE5 		strb	ip, [lr, #1934]
 11091              	.L804:
2049:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11092              		.loc 1 2049 0
 11093 5f2c 0130A0E3 		mov	r3, #1
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11094              		.loc 1 1835 0
 11095 5f30 02C0A0E3 		mov	ip, #2
2049:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11096              		.loc 1 2049 0
 11097 5f34 9137CBE5 		strb	r3, [fp, #1937]
1835:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11098              		.loc 1 1835 0
 11099 5f38 38C08DE5 		str	ip, [sp, #56]
 11100 5f3c 0BFDFFEA 		b	.L806
 11101              	.LVL1276:
 11102              	.L896:
2051:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11103              		.loc 1 2051 0
 11104 5f40 54CE1FE5 		ldr	ip, .L904+112
 11105 5f44 0010E0E3 		mvn	r1, #0
 11106 5f48 1C009CE5 		ldr	r0, [ip, #28]
 11107 5f4c 3CC08DE5 		str	ip, [sp, #60]
 11108 5f50 FEFFFFEB 		bl	_txe_mutex_get
 11109              	.LVL1277:
2052:../uvc.c      **** 									 {
 11110              		.loc 1 2052 0
 11111 5f54 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
 11112 5f58 030054E1 		cmp	r4, r3
1834:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11113              		.loc 1 1834 0
 11114 5f5c 34309D05 		ldreq	r3, [sp, #52]
2052:../uvc.c      **** 									 {
 11115              		.loc 1 2052 0
 11116 5f60 0A00000A 		beq	.L807
2055:../uvc.c      **** 										 dataIdx++;
 11117              		.loc 1 2055 0
 11118 5f64 34C09DE5 		ldr	ip, [sp, #52]
2054:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11119              		.loc 1 2054 0
 11120 5f68 78EE1FE5 		ldr	lr, .L904+116
2055:../uvc.c      **** 										 dataIdx++;
 11121              		.loc 1 2055 0
 11122 5f6c 00408DE5 		str	r4, [sp]
 11123 5f70 04C08DE5 		str	ip, [sp, #4]
 11124 5f74 2C309DE5 		ldr	r3, [sp, #44]
 11125 5f78 30209DE5 		ldr	r2, [sp, #48]
 11126 5f7c 3C009DE5 		ldr	r0, [sp, #60]
 11127 5f80 2710A0E3 		mov	r1, #39
2054:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11128              		.loc 1 2054 0
 11129 5f84 8D47CEE5 		strb	r4, [lr, #1933]
2055:../uvc.c      **** 										 dataIdx++;
 11130              		.loc 1 2055 0
 11131 5f88 FEFFFFEB 		bl	cmdSet
 11132              	.LVL1278:
2056:../uvc.c      **** 									 }
 11133              		.loc 1 2056 0
 11134 5f8c 28309DE5 		ldr	r3, [sp, #40]
 11135              	.LVL1279:
 11136              	.L807:
2058:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11137              		.loc 1 2058 0
 11138 5f90 8E27DBE5 		ldrb	r2, [fp, #1934]	@ zero_extendqisi2
 11139 5f94 24C09DE5 		ldr	ip, [sp, #36]
 11140 5f98 02005CE1 		cmp	ip, r2
 11141 5f9c 0800000A 		beq	.L808
2059:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11142              		.loc 1 2059 0
 11143 5fa0 B0EE1FE5 		ldr	lr, .L904+116
2060:../uvc.c      **** 									 }
 11144              		.loc 1 2060 0
 11145 5fa4 04308DE5 		str	r3, [sp, #4]
 11146 5fa8 00C08DE5 		str	ip, [sp]
 11147 5fac 0520A0E1 		mov	r2, r5
 11148 5fb0 2C309DE5 		ldr	r3, [sp, #44]
 11149              	.LVL1280:
 11150 5fb4 C80E1FE5 		ldr	r0, .L904+112
 11151 5fb8 2710A0E3 		mov	r1, #39
2059:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11152              		.loc 1 2059 0
 11153 5fbc 8EC7CEE5 		strb	ip, [lr, #1934]
2060:../uvc.c      **** 									 }
 11154              		.loc 1 2060 0
 11155 5fc0 FEFFFFEB 		bl	cmdSet
 11156              	.LVL1281:
 11157              	.L808:
2063:../uvc.c      **** 
 11158              		.loc 1 2063 0
 11159 5fc4 3CC09DE5 		ldr	ip, [sp, #60]
2062:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11160              		.loc 1 2062 0
 11161 5fc8 0130A0E3 		mov	r3, #1
2063:../uvc.c      **** 
 11162              		.loc 1 2063 0
 11163 5fcc 1C009CE5 		ldr	r0, [ip, #28]
2062:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11164              		.loc 1 2062 0
 11165 5fd0 9137CBE5 		strb	r3, [fp, #1937]
2063:../uvc.c      **** 
 11166              		.loc 1 2063 0
 11167 5fd4 FEFFFFEB 		bl	_txe_mutex_put
 11168              	.LVL1282:
 11169 5fd8 E4FCFFEA 		b	.L806
 11170              	.LVL1283:
 11171              	.L903:
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11172              		.loc 1 1506 0
 11173 5fdc 0500A0E1 		mov	r0, r5
 11174 5fe0 2C109DE5 		ldr	r1, [sp, #44]
 11175 5fe4 20308DE5 		str	r3, [sp, #32]
 11176 5fe8 FEFFFFEB 		bl	SensorGetControl
 11177              	.LVL1284:
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11178              		.loc 1 1508 0
 11179 5fec 2C109DE5 		ldr	r1, [sp, #44]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11180              		.loc 1 1506 0
 11181 5ff0 0020A0E1 		mov	r2, r0
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11182              		.loc 1 1508 0
 11183 5ff4 30009DE5 		ldr	r0, [sp, #48]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11184              		.loc 1 1506 0
 11185 5ff8 2820C8E5 		strb	r2, [r8, #40]
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11186              		.loc 1 1507 0
 11187 5ffc 8D27CBE5 		strb	r2, [fp, #1933]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11188              		.loc 1 1508 0
 11189 6000 FEFFFFEB 		bl	SensorGetControl
 11190              	.LVL1285:
1510:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11191              		.loc 1 1510 0
 11192 6004 0020A0E3 		mov	r2, #0
 11193 6008 2920C8E5 		strb	r2, [r8, #41]
1511:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11194              		.loc 1 1511 0
 11195 600c 2B20C8E5 		strb	r2, [r8, #43]
1512:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11196              		.loc 1 1512 0
 11197 6010 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 11198              	.LVL1286:
1509:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11199              		.loc 1 1509 0
 11200 6014 8E07CBE5 		strb	r0, [fp, #1934]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11201              		.loc 1 1508 0
 11202 6018 0050A0E1 		mov	r5, r0
 11203              	.LVL1287:
 11204 601c 2A00C8E5 		strb	r0, [r8, #42]
 11205 6020 20309DE5 		ldr	r3, [sp, #32]
 11206 6024 23FEFFEA 		b	.L797
 11207              	.LVL1288:
 11208              	.L897:
 11209              	.LBE150:
 11210              	.LBE156:
 11211              	.LBE166:
 11212              	.LBE298:
 11213              	.LBB299:
 11214              	.LBB279:
 11215              	.LBB270:
 11216              	.LBB214:
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11217              		.loc 1 1649 0
 11218 6028 0510A0E1 		mov	r1, r5
 11219 602c 2C009DE5 		ldr	r0, [sp, #44]
 11220 6030 1CC08DE5 		str	ip, [sp, #28]
 11221 6034 FEFFFFEB 		bl	SensorGetControl
 11222              	.LVL1289:
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11223              		.loc 1 1650 0
 11224 6038 48EF1FE5 		ldr	lr, .L904+116
1651:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11225              		.loc 1 1651 0
 11226 603c 0040A0E3 		mov	r4, #0
 11227              	.LVL1290:
 11228 6040 2940C8E5 		strb	r4, [r8, #41]
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11229              		.loc 1 1650 0
 11230 6044 A905CEE5 		strb	r0, [lr, #1449]
1652:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11231              		.loc 1 1652 0
 11232 6048 AA45CEE5 		strb	r4, [lr, #1450]
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11233              		.loc 1 1649 0
 11234 604c 0050A0E1 		mov	r5, r0
 11235              	.LVL1291:
 11236 6050 2800C8E5 		strb	r0, [r8, #40]
 11237 6054 1CC09DE5 		ldr	ip, [sp, #28]
 11238 6058 E0FCFFEA 		b	.L650
 11239              	.LVL1292:
 11240              	.L902:
 11241              	.LBE214:
 11242              	.LBE270:
 11243              	.LBE279:
 11244              	.LBE299:
 11245              	.LBB300:
 11246              	.LBB167:
 11247              	.LBB157:
 11248              	.LBB151:
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11249              		.loc 1 1499 0
 11250 605c 30009DE5 		ldr	r0, [sp, #48]
 11251 6060 2C109DE5 		ldr	r1, [sp, #44]
 11252 6064 20308DE5 		str	r3, [sp, #32]
 11253 6068 FEFFFFEB 		bl	SensorGetControl
 11254              	.LVL1293:
1501:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11255              		.loc 1 1501 0
 11256 606c 0050A0E3 		mov	r5, #0
 11257              	.LVL1294:
 11258 6070 2950C8E5 		strb	r5, [r8, #41]
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11259              		.loc 1 1500 0
 11260 6074 8D07CBE5 		strb	r0, [fp, #1933]
1502:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11261              		.loc 1 1502 0
 11262 6078 8E57CBE5 		strb	r5, [fp, #1934]
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11263              		.loc 1 1499 0
 11264 607c 00C0A0E1 		mov	ip, r0
 11265              	.LVL1295:
 11266 6080 2800C8E5 		strb	r0, [r8, #40]
 11267 6084 20309DE5 		ldr	r3, [sp, #32]
 11268 6088 0AFEFFEA 		b	.L797
 11269              	.LVL1296:
 11270              	.L900:
 11271              	.LBE151:
 11272              	.LBE157:
 11273              	.LBE167:
 11274              	.LBE300:
 11275              	.LBB301:
 11276              	.LBB280:
 11277              	.LBB271:
 11278              	.LBB202:
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11279              		.loc 1 1649 0
 11280 608c 30009DE5 		ldr	r0, [sp, #48]
 11281 6090 2C109DE5 		ldr	r1, [sp, #44]
 11282 6094 20308DE5 		str	r3, [sp, #32]
 11283 6098 FEFFFFEB 		bl	SensorGetControl
 11284              	.LVL1297:
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11285              		.loc 1 1650 0
 11286 609c ACEF1FE5 		ldr	lr, .L904+116
1651:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11287              		.loc 1 1651 0
 11288 60a0 0050A0E3 		mov	r5, #0
 11289              	.LVL1298:
 11290 60a4 2950C8E5 		strb	r5, [r8, #41]
1650:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11291              		.loc 1 1650 0
 11292 60a8 6507CEE5 		strb	r0, [lr, #1893]
1652:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11293              		.loc 1 1652 0
 11294 60ac 6657CEE5 		strb	r5, [lr, #1894]
1649:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11295              		.loc 1 1649 0
 11296 60b0 00C0A0E1 		mov	ip, r0
 11297              	.LVL1299:
 11298 60b4 2800C8E5 		strb	r0, [r8, #40]
 11299 60b8 20309DE5 		ldr	r3, [sp, #32]
 11300 60bc 98FDFFEA 		b	.L719
 11301              	.LBE202:
 11302              	.LBE271:
 11303              	.LBE280:
 11304              	.LBE301:
 11305              		.cfi_endproc
 11306              	.LFE25:
 11308              		.align	2
 11309              		.global	CyFxGpifCB
 11311              	CyFxGpifCB:
 11312              	.LFB13:
3037:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 11313              		.loc 1 3037 0
 11314              		.cfi_startproc
 11315              		@ args = 0, pretend = 0, frame = 0
 11316              		@ frame_needed = 0, uses_anonymous_args = 0
3038:../uvc.c      ****     {
 11317              		.loc 1 3038 0
 11318 60c0 010050E3 		cmp	r0, #1
3037:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 11319              		.loc 1 3037 0
 11320 60c4 10402DE9 		stmfd	sp!, {r4, lr}
 11321              	.LCFI29:
 11322              		.cfi_def_cfa_offset 8
 11323              		.cfi_offset 4, -8
 11324              		.cfi_offset 14, -4
3038:../uvc.c      ****     {
 11325              		.loc 1 3038 0
 11326 60c8 1080BD18 		ldmnefd	sp!, {r4, pc}
 11327              	.LBB306:
 11328              	.LBB307:
2935:../uvc.c      ****     {
 11329              		.loc 1 2935 0
 11330 60cc C4309FE5 		ldr	r3, .L923
 11331 60d0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 11332 60d4 030053E3 		cmp	r3, #3
 11333 60d8 1000000A 		beq	.L922
2961:../uvc.c      ****     {
 11334              		.loc 1 2961 0
 11335 60dc 020053E3 		cmp	r3, #2
 11336 60e0 1080BD18 		ldmnefd	sp!, {r4, pc}
2963:../uvc.c      ****         {
 11337              		.loc 1 2963 0
 11338 60e4 083041E2 		sub	r3, r1, #8
 11339 60e8 0A0053E3 		cmp	r3, #10
 11340 60ec 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 11341 60f0 200000EA 		b	.L915
 11342              	.L917:
 11343 60f4 70610000 		.word	.L910
 11344 60f8 78610000 		.word	.L915
 11345 60fc 78610000 		.word	.L915
 11346 6100 40610000 		.word	.L906
 11347 6104 78610000 		.word	.L915
 11348 6108 78610000 		.word	.L915
 11349 610c 78610000 		.word	.L915
 11350 6110 44610000 		.word	.L921
 11351 6114 78610000 		.word	.L915
 11352 6118 78610000 		.word	.L915
 11353 611c 40610000 		.word	.L906
 11354              	.L922:
2937:../uvc.c      ****         {
 11355              		.loc 1 2937 0
 11356 6120 0B1041E2 		sub	r1, r1, #11
 11357 6124 030051E3 		cmp	r1, #3
 11358 6128 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 11359 612c 150000EA 		b	.L909
 11360              	.L911:
 11361 6130 70610000 		.word	.L910
 11362 6134 44610000 		.word	.L921
 11363 6138 40610000 		.word	.L906
 11364 613c 40610000 		.word	.L906
 11365              	.L906:
 11366 6140 1080BDE8 		ldmfd	sp!, {r4, pc}
 11367              	.L921:
2963:../uvc.c      ****         {
 11368              		.loc 1 2963 0
 11369 6144 0110A0E3 		mov	r1, #1
 11370              	.L912:
3020:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 11371              		.loc 1 3020 0
 11372 6148 4C009FE5 		ldr	r0, .L923+4
 11373 614c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3021:../uvc.c      ****         {
 11374              		.loc 1 3021 0
 11375 6150 004050E2 		subs	r4, r0, #0
 11376 6154 1080BD08 		ldmeqfd	sp!, {r4, pc}
3023:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 11377              		.loc 1 3023 0
 11378 6158 0400A0E3 		mov	r0, #4
 11379 615c 3C109FE5 		ldr	r1, .L923+8
 11380 6160 0420A0E1 		mov	r2, r4
 11381 6164 FEFFFFEB 		bl	CyU3PDebugPrint
3024:../uvc.c      ****         }
 11382              		.loc 1 3024 0
 11383 6168 0400A0E1 		mov	r0, r4
 11384 616c FEFFFFEB 		bl	CyFxAppErrorHandler
 11385              	.L910:
2937:../uvc.c      ****         {
 11386              		.loc 1 2937 0
 11387 6170 0010A0E3 		mov	r1, #0
 11388 6174 F3FFFFEA 		b	.L912
 11389              	.L915:
3009:../uvc.c      ****                 /* Unexpected current state. Return error. */
 11390              		.loc 1 3009 0
 11391 6178 0120A0E1 		mov	r2, r1
 11392 617c 0100A0E3 		mov	r0, #1
 11393 6180 1C109FE5 		ldr	r1, .L923+12
 11394 6184 FEFFFFEB 		bl	CyU3PDebugPrint
 11395              	.L909:
 11396              	.LBE307:
 11397              	.LBE306:
 11398              	.LBB308:
 11399              	.LBB309:
3044:../uvc.c      ****     }
 11400              		.loc 1 3044 0
 11401 6188 0400A0E3 		mov	r0, #4
 11402 618c 14109FE5 		ldr	r1, .L923+16
 11403              	.LBE309:
 11404              	.LBE308:
3047:../uvc.c      **** 
 11405              		.loc 1 3047 0
 11406 6190 1040BDE8 		ldmfd	sp!, {r4, lr}
 11407              	.LBB311:
 11408              	.LBB310:
3044:../uvc.c      ****     }
 11409              		.loc 1 3044 0
 11410 6194 FEFFFFEA 		b	CyU3PDebugPrint
 11411              	.L924:
 11412              		.align	2
 11413              	.L923:
 11414 6198 00000000 		.word	.LANCHOR0
 11415 619c 00000000 		.word	glChHandleUVCStream
 11416 61a0 3C0E0000 		.word	.LC81
 11417 61a4 240E0000 		.word	.LC80
 11418 61a8 6C0E0000 		.word	.LC82
 11419              	.LBE310:
 11420              	.LBE311:
 11421              		.cfi_endproc
 11422              	.LFE13:
 11424              		.align	2
 11425              		.global	CyFxApplicationDefine
 11427              	CyFxApplicationDefine:
 11428              	.LFB27:
5277:../uvc.c      **** }
5278:../uvc.c      **** 
5279:../uvc.c      **** 
5280:../uvc.c      **** /*
5281:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5282:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5283:../uvc.c      ****  */
5284:../uvc.c      **** void
5285:../uvc.c      **** CyFxApplicationDefine (
5286:../uvc.c      ****         void)
5287:../uvc.c      **** {
 11429              		.loc 1 5287 0
 11430              		.cfi_startproc
 11431              		@ args = 0, pretend = 0, frame = 32
 11432              		@ frame_needed = 0, uses_anonymous_args = 0
 11433              	.LVL1300:
 11434 61ac F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 11435              	.LCFI30:
 11436              		.cfi_def_cfa_offset 32
 11437              		.cfi_offset 4, -32
 11438              		.cfi_offset 5, -28
 11439              		.cfi_offset 6, -24
 11440              		.cfi_offset 7, -20
 11441              		.cfi_offset 8, -16
 11442              		.cfi_offset 9, -12
 11443              		.cfi_offset 10, -8
 11444              		.cfi_offset 14, -4
5288:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5289:../uvc.c      ****     uint32_t retThrdCreate;
5290:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5291:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5292:../uvc.c      **** 
5293:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5294:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11445              		.loc 1 5294 0
 11446 61b0 010AA0E3 		mov	r0, #4096
5287:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 11447              		.loc 1 5287 0
 11448 61b4 40D04DE2 		sub	sp, sp, #64
 11449              	.LCFI31:
 11450              		.cfi_def_cfa_offset 96
 11451              		.loc 1 5294 0
 11452 61b8 FEFFFFEB 		bl	CyU3PMemAlloc
 11453              	.LVL1301:
 11454 61bc 0070A0E1 		mov	r7, r0
 11455              	.LVL1302:
5295:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11456              		.loc 1 5295 0
 11457 61c0 010AA0E3 		mov	r0, #4096
 11458              	.LVL1303:
 11459 61c4 FEFFFFEB 		bl	CyU3PMemAlloc
 11460              	.LVL1304:
 11461 61c8 0060A0E1 		mov	r6, r0
 11462              	.LVL1305:
5296:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11463              		.loc 1 5296 0
 11464 61cc 010AA0E3 		mov	r0, #4096
 11465              	.LVL1306:
 11466 61d0 FEFFFFEB 		bl	CyU3PMemAlloc
 11467              	.LVL1307:
5297:../uvc.c      **** 
5298:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 11468              		.loc 1 5298 0
 11469 61d4 000056E3 		cmp	r6, #0
 11470 61d8 00005713 		cmpne	r7, #0
 11471 61dc 00A0A013 		movne	r10, #0
 11472 61e0 01A0A003 		moveq	r10, #1
5296:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11473              		.loc 1 5296 0
 11474 61e4 0090A0E1 		mov	r9, r0
 11475              	.LVL1308:
 11476              		.loc 1 5298 0
 11477 61e8 0000001A 		bne	.L936
 11478              	.LVL1309:
 11479              	.L926:
 11480              	.L928:
 11481 61ec FEFFFFEA 		b	.L928
 11482              	.LVL1310:
 11483              	.L936:
 11484              		.loc 1 5298 0 is_stmt 0 discriminator 1
 11485 61f0 000050E3 		cmp	r0, #0
 11486 61f4 FCFFFF0A 		beq	.L926
 11487              	.LVL1311:
5299:../uvc.c      ****         goto fatalErrorHandler;
5300:../uvc.c      **** 
5301:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5302:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5303:../uvc.c      ****     char *staName = "I2CstaQue";
5304:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 11488              		.loc 1 5304 0 is_stmt 1
 11489 61f8 F4309FE5 		ldr	r3, .L937
 11490 61fc 20008DE2 		add	r0, sp, #32
 11491              	.LVL1312:
 11492 6200 00308DE5 		str	r3, [sp]
 11493 6204 4010A0E3 		mov	r1, #64
 11494 6208 E8209FE5 		ldr	r2, .L937+4
 11495 620c 0A30A0E1 		mov	r3, r10
 11496 6210 FEFFFFEB 		bl	cmdbufCreate
 11497              	.LVL1313:
 11498 6214 20E08DE2 		add	lr, sp, #32
 11499 6218 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 11500 621c D8C09FE5 		ldr	ip, .L937+8
5305:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5306:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5307:../uvc.c      **** 
5308:../uvc.c      **** 	/****** initialize command descriptor ***********/
5309:../uvc.c      **** 	cmdquInit(cmdQuptr);
5310:../uvc.c      **** 	cmdquInit(statQuptr);
5311:../uvc.c      **** 
5312:../uvc.c      ****     /* Create the UVC application thread. */
5313:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 11501              		.loc 1 5313 0
 11502 6220 0840A0E3 		mov	r4, #8
5304:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 11503              		.loc 1 5304 0
 11504 6224 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 11505 6228 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 11506              		.loc 1 5313 0
 11507 622c 0150A0E3 		mov	r5, #1
5304:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 11508              		.loc 1 5304 0
 11509 6230 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5309:../uvc.c      **** 	cmdquInit(statQuptr);
 11510              		.loc 1 5309 0
 11511 6234 10004CE2 		sub	r0, ip, #16
 11512 6238 FEFFFFEB 		bl	cmdquInit
 11513              	.LVL1314:
5310:../uvc.c      **** 
 11514              		.loc 1 5310 0
 11515 623c BC009FE5 		ldr	r0, .L937+12
 11516 6240 FEFFFFEB 		bl	cmdquInit
 11517              	.LVL1315:
 11518              		.loc 1 5313 0
 11519 6244 A880A0E3 		mov	r8, #168
 11520 6248 012AA0E3 		mov	r2, #4096
 11521 624c 0A30A0E1 		mov	r3, r10
 11522 6250 14008DE9 		stmib	sp, {r2, r4}
 11523 6254 A8009FE5 		ldr	r0, .L937+16
 11524 6258 00708DE5 		str	r7, [sp]
 11525 625c 10A08DE5 		str	r10, [sp, #16]
 11526 6260 0C408DE5 		str	r4, [sp, #12]
 11527 6264 14508DE5 		str	r5, [sp, #20]
 11528 6268 18808DE5 		str	r8, [sp, #24]
 11529 626c 94109FE5 		ldr	r1, .L937+20
 11530 6270 94209FE5 		ldr	r2, .L937+24
 11531 6274 FEFFFFEB 		bl	_txe_thread_create
 11532              	.LVL1316:
5314:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5315:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5316:../uvc.c      ****             0,                                          /* No input parameter to thread */
5317:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5318:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5319:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5320:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5321:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5322:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5323:../uvc.c      ****             );
5324:../uvc.c      ****     if (retThrdCreate != 0)
 11533              		.loc 1 5324 0
 11534 6278 003050E2 		subs	r3, r0, #0
 11535 627c DAFFFF1A 		bne	.L926
5325:../uvc.c      ****     {
5326:../uvc.c      ****         goto fatalErrorHandler;
5327:../uvc.c      ****     }
5328:../uvc.c      **** 
5329:../uvc.c      ****     /* Create the control request handling thread. */
5330:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 11536              		.loc 1 5330 0
 11537 6280 027BA0E3 		mov	r7, #2048
 11538              	.LVL1317:
 11539 6284 10308DE5 		str	r3, [sp, #16]
 11540 6288 00608DE5 		str	r6, [sp]
 11541 628c 08408DE5 		str	r4, [sp, #8]
 11542 6290 0C408DE5 		str	r4, [sp, #12]
 11543 6294 14508DE5 		str	r5, [sp, #20]
 11544 6298 18808DE5 		str	r8, [sp, #24]
 11545 629c 04708DE5 		str	r7, [sp, #4]
 11546 62a0 68009FE5 		ldr	r0, .L937+28
 11547              	.LVL1318:
 11548 62a4 68109FE5 		ldr	r1, .L937+32
 11549 62a8 68209FE5 		ldr	r2, .L937+36
 11550 62ac FEFFFFEB 		bl	_txe_thread_create
 11551              	.LVL1319:
5331:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5332:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5333:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5334:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5335:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5336:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5337:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5338:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5339:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5340:../uvc.c      ****             );
5341:../uvc.c      ****     if (retThrdCreate != 0)
 11552              		.loc 1 5341 0
 11553 62b0 003050E2 		subs	r3, r0, #0
 11554 62b4 CCFFFF1A 		bne	.L926
5342:../uvc.c      ****     {
5343:../uvc.c      ****         goto fatalErrorHandler;
5344:../uvc.c      ****     }
5345:../uvc.c      **** #if 1
5346:../uvc.c      ****     /* Create the I2C control command handling thread. */
5347:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 11555              		.loc 1 5347 0
 11556 62b8 00908DE5 		str	r9, [sp]
 11557 62bc 04708DE5 		str	r7, [sp, #4]
 11558 62c0 08408DE5 		str	r4, [sp, #8]
 11559 62c4 0C408DE5 		str	r4, [sp, #12]
 11560 62c8 10308DE5 		str	r3, [sp, #16]
 11561 62cc 14508DE5 		str	r5, [sp, #20]
 11562 62d0 18808DE5 		str	r8, [sp, #24]
 11563 62d4 40009FE5 		ldr	r0, .L937+40
 11564              	.LVL1320:
 11565 62d8 40109FE5 		ldr	r1, .L937+44
 11566 62dc 40209FE5 		ldr	r2, .L937+48
 11567 62e0 FEFFFFEB 		bl	_txe_thread_create
 11568              	.LVL1321:
5348:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5349:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5350:../uvc.c      ****             0,                                          /* No input parameter to thread */
5351:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5352:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5353:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5354:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5355:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5356:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5357:../uvc.c      ****             );
5358:../uvc.c      ****     if (retThrdCreate != 0)
 11569              		.loc 1 5358 0
 11570 62e4 000050E3 		cmp	r0, #0
 11571 62e8 BFFFFF1A 		bne	.L926
5359:../uvc.c      ****     {
5360:../uvc.c      ****         goto fatalErrorHandler;
5361:../uvc.c      ****     }
5362:../uvc.c      **** #endif
5363:../uvc.c      **** 
5364:../uvc.c      ****     return;
5365:../uvc.c      **** 
5366:../uvc.c      **** fatalErrorHandler:
5367:../uvc.c      ****     /* Add custom recovery or debug actions here */
5368:../uvc.c      ****     /* Loop indefinitely */
5369:../uvc.c      ****     while (1);
5370:../uvc.c      **** }
 11572              		.loc 1 5370 0
 11573 62ec 40D08DE2 		add	sp, sp, #64
 11574              		@ sp needed
 11575 62f0 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 11576              	.LVL1322:
 11577              	.L938:
 11578              		.align	2
 11579              	.L937:
 11580 62f4 00000000 		.word	cmdQuMux
 11581 62f8 840E0000 		.word	.LC83
 11582 62fc 00000000 		.word	cmdQu
 11583 6300 00000000 		.word	statQu
 11584 6304 A4000000 		.word	.LANCHOR0+164
 11585 6308 900E0000 		.word	.LC84
 11586 630c 00000000 		.word	UVCAppThread_Entry
 11587 6310 4C010000 		.word	.LANCHOR0+332
 11588 6314 A40E0000 		.word	.LC85
 11589 6318 00000000 		.word	UVCAppEP0Thread_Entry
 11590 631c F4010000 		.word	.LANCHOR0+500
 11591 6320 BC0E0000 		.word	.LC86
 11592 6324 00000000 		.word	I2cAppThread_Entry
 11593              		.cfi_endproc
 11594              	.LFE27:
 11596              		.section	.text.startup,"ax",%progbits
 11597              		.align	2
 11598              		.global	main
 11600              	main:
 11601              	.LFB28:
5371:../uvc.c      **** 
5372:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5373:../uvc.c      ****  * the ThreadX RTOS here.
5374:../uvc.c      ****  */
5375:../uvc.c      **** int
5376:../uvc.c      **** main (
5377:../uvc.c      ****         void)
5378:../uvc.c      **** {
 11602              		.loc 1 5378 0
 11603              		.cfi_startproc
 11604              		@ args = 0, pretend = 0, frame = 56
 11605              		@ frame_needed = 0, uses_anonymous_args = 0
 11606 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 11607              	.LCFI32:
 11608              		.cfi_def_cfa_offset 12
 11609              		.cfi_offset 4, -12
 11610              		.cfi_offset 5, -8
 11611              		.cfi_offset 14, -4
 11612 0004 3CD04DE2 		sub	sp, sp, #60
 11613              	.LCFI33:
 11614              		.cfi_def_cfa_offset 72
5379:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5380:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5381:../uvc.c      **** 
5382:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5383:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5384:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11615              		.loc 1 5384 0
 11616 0008 0230A0E3 		mov	r3, #2
5385:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5386:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5387:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 11617              		.loc 1 5387 0
 11618 000c 0010A0E3 		mov	r1, #0
5388:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 11619              		.loc 1 5388 0
 11620 0010 0320A0E3 		mov	r2, #3
5383:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11621              		.loc 1 5383 0
 11622 0014 0150A0E3 		mov	r5, #1
5389:../uvc.c      **** 
5390:../uvc.c      ****     /* Initialize the device */
5391:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 11623              		.loc 1 5391 0
 11624 0018 0D00A0E1 		mov	r0, sp
5383:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11625              		.loc 1 5383 0
 11626 001c 00508DE5 		str	r5, [sp]
5384:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 11627              		.loc 1 5384 0
 11628 0020 0430CDE5 		strb	r3, [sp, #4]
5385:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 11629              		.loc 1 5385 0
 11630 0024 0530CDE5 		strb	r3, [sp, #5]
5386:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 11631              		.loc 1 5386 0
 11632 0028 0630CDE5 		strb	r3, [sp, #6]
5387:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 11633              		.loc 1 5387 0
 11634 002c 08108DE5 		str	r1, [sp, #8]
5388:../uvc.c      **** 
 11635              		.loc 1 5388 0
 11636 0030 0C20CDE5 		strb	r2, [sp, #12]
 11637              		.loc 1 5391 0
 11638 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 11639              	.LVL1323:
5392:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 11640              		.loc 1 5392 0
 11641 0038 004050E2 		subs	r4, r0, #0
 11642 003c 0000000A 		beq	.L944
 11643              	.L940:
 11644              	.L941:
 11645 0040 FEFFFFEA 		b	.L941
 11646              	.L944:
5393:../uvc.c      ****     {
5394:../uvc.c      ****         goto handle_fatal_error;
5395:../uvc.c      ****     }
5396:../uvc.c      **** 
5397:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5398:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 11647              		.loc 1 5398 0
 11648 0044 0410A0E1 		mov	r1, r4
 11649 0048 0420A0E1 		mov	r2, r4
 11650 004c 0500A0E1 		mov	r0, r5
 11651              	.LVL1324:
 11652 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 11653              	.LVL1325:
5399:../uvc.c      **** 
5400:../uvc.c      ****     /* Configure the IO matrix for the device. */
5401:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5402:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5403:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5404:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5405:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5406:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5407:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5408:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5409:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5410:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5411:../uvc.c      **** 
5412:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 11654              		.loc 1 5412 0
 11655 0054 10008DE2 		add	r0, sp, #16
5402:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 11656              		.loc 1 5402 0
 11657 0058 2640CDE5 		strb	r4, [sp, #38]
5403:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 11658              		.loc 1 5403 0
 11659 005c 28408DE5 		str	r4, [sp, #40]
5404:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 11660              		.loc 1 5404 0
 11661 0060 2C408DE5 		str	r4, [sp, #44]
5405:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 11662              		.loc 1 5405 0
 11663 0064 30408DE5 		str	r4, [sp, #48]
5406:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 11664              		.loc 1 5406 0
 11665 0068 34408DE5 		str	r4, [sp, #52]
5409:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 11666              		.loc 1 5409 0
 11667 006c 1C408DE5 		str	r4, [sp, #28]
5410:../uvc.c      **** 
 11668              		.loc 1 5410 0
 11669 0070 20408DE5 		str	r4, [sp, #32]
5401:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 11670              		.loc 1 5401 0
 11671 0074 10508DE5 		str	r5, [sp, #16]
5407:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 11672              		.loc 1 5407 0
 11673 0078 14508DE5 		str	r5, [sp, #20]
5408:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 11674              		.loc 1 5408 0
 11675 007c 18508DE5 		str	r5, [sp, #24]
 11676              		.loc 1 5412 0
 11677 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 11678              	.LVL1326:
5413:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 11679              		.loc 1 5413 0
 11680 0084 004050E2 		subs	r4, r0, #0
 11681 0088 ECFFFF1A 		bne	.L940
5414:../uvc.c      ****     {
5415:../uvc.c      ****         goto handle_fatal_error;
5416:../uvc.c      ****     }
5417:../uvc.c      **** 
5418:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5419:../uvc.c      ****     CyU3PKernelEntry ();
 11682              		.loc 1 5419 0
 11683 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 11684              	.LVL1327:
5420:../uvc.c      **** 
5421:../uvc.c      ****     /* Dummy return to make the compiler happy */
5422:../uvc.c      ****     return 0;
5423:../uvc.c      **** 
5424:../uvc.c      **** handle_fatal_error:
5425:../uvc.c      ****     /* Cannot recover from this error. */
5426:../uvc.c      ****     while (1);
5427:../uvc.c      **** }
 11685              		.loc 1 5427 0
 11686 0090 0400A0E1 		mov	r0, r4
 11687 0094 3CD08DE2 		add	sp, sp, #60
 11688              		@ sp needed
 11689 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 11690              		.cfi_endproc
 11691              	.LFE28:
 11693              		.comm	I2CCmdTimer,44,4
 11694              		.comm	posTick,4,4
 11695              		.global	glUVCHeader
 11696              		.global	glProbeStilCtrl20
 11697              		.global	glProbeCtrl20
 11698              		.global	glProbeStilCtrl
 11699              		.global	glProbeCtrlFull
 11700              		.global	glProbeCtrl
 11701              		.global	streamingStarted
 11702              		.global	clearFeatureRqtReceived
 11703              		.global	usbSpeed
 11704              		.global	isUsbConnected
 11705              		.global	pbcpbak
 11706              		.global	pbcbak
 11707              		.global	pbbak
 11708              		.global	fbbak
 11709              		.global	pbc
 11710              		.global	pb
 11711              		.global	fb
 11712              		.comm	wLength,2,2
 11713              		.comm	wIndex,2,2
 11714              		.comm	wValue,2,2
 11715              		.comm	bRequest,1,1
 11716              		.comm	bmReqType,1,1
 11717              		.comm	imgHdMux,56,4
 11718              		.comm	timMux,56,4
 11719              		.comm	staQuMux,56,4
 11720              		.comm	cmdQuMux,56,4
 11721              		.comm	statQu,32,4
 11722              		.comm	cmdQu,32,4
 11723              		.global	testSnap
 11724              		.global	snapButFlag
 11725              		.comm	glInterStaBuffer,4,4
 11726              		.comm	glChHandleInterStat,172,4
 11727              		.comm	glChHandleStillStream,232,4
 11728              		.comm	glChHandleUVCStream,232,4
 11729              		.global	CyFxGpifConfig_usb2
 11730              		.global	CyFxGpifRegValue_usb2
 11731              		.global	CyFxGpifWavedataPosition_usb2
 11732              		.global	CyFxGpifWavedata_usb2
 11733              		.global	CyFxGpifTransition_usb2
 11734              		.global	CyFxGpifConfig
 11735              		.global	CyFxGpifRegValue
 11736              		.global	CyFxGpifWavedataPosition
 11737              		.global	CyFxGpifWavedata
 11738              		.global	CyFxGpifTransition
 11739              		.section	.rodata
 11740              		.align	2
 11741              		.set	.LANCHOR2,. + 0
 11744              	ShutSp:
 11745 0000 3582     		.short	-32203
 11746 0002 1B41     		.short	16667
 11747 0004 8D20     		.short	8333
 11748 0006 A00F     		.short	4000
 11749 0008 D007     		.short	2000
 11750 000a E803     		.short	1000
 11751 000c F401     		.short	500
 11752 000e C800     		.short	200
 11753 0010 6400     		.short	100
 11754 0012 0A00     		.short	10
 11755 0014 0000     		.short	0
 11756 0016 00000000 		.space	10
 11756      00000000 
 11756      0000
 11759              	pEXTSenCtrl:
 11760 0020 B0050000 		.word	EXTShutter
 11761 0024 10090000 		.word	EXTSensUp
 11762 0028 FC080000 		.word	EXTMirror
 11763 002c E8080000 		.word	EXT3DnoiseReduceMode
 11764 0030 D4080000 		.word	EXT3DNoiseLev
 11765 0034 C0080000 		.word	EXTDayNightMode
 11766 0038 AC080000 		.word	EXTDayNightdely
 11767 003c 98080000 		.word	EXTDayNightlev
 11768 0040 84080000 		.word	EXTNightDaylev
 11769 0044 0C050000 		.word	EXTAexModGainlev
 11770 0048 70080000 		.word	EXTExpReflev
 11771 004c C4050000 		.word	EXTShutlev
 11772 0050 5C080000 		.word	EXTCamMode
 11773 0054 00000000 		.word	0
 11774 0058 48080000 		.word	EXTSensorPare
 11775 005c 34080000 		.word	EXTI2Ccmd
 11776 0060 00000000 		.word	0
 11777 0064 00000000 		.word	0
 11778 0068 00000000 		.word	0
 11779 006c 00000000 		.word	0
 11780 0070 34050000 		.word	EXTBLCWinPos
 11781 0074 20080000 		.word	EXTBLCWeight
 11782 0078 F8040000 		.word	EXTBLCGrid
 11783 007c 80070000 		.word	EXTExHyster
 11784 0080 20050000 		.word	EXTExCtrlSped
 11785 0084 0C080000 		.word	EXTEnhanceMode
 11786 0088 F8070000 		.word	EXTEnhanceGain
 11787 008c E4070000 		.word	EXTEnhanceSTED
 11788 0090 D0070000 		.word	EXT2DNRGain
 11789 0094 BC070000 		.word	EXT2DNRSTED
 11790 0098 A8070000 		.word	EXTGammaCor
 11791 009c 94070000 		.word	EXTAGCMaxLimit
 11792 00a0 00000000 		.word	0
 11793 00a4 00000000 		.space	124
 11793      00000000 
 11793      00000000 
 11793      00000000 
 11793      00000000 
 11796              	pPUCSenCtrl:
 11797 0120 9C050000 		.word	PUCBLC
 11798 0124 48050000 		.word	PUCBright
 11799 0128 4C090000 		.word	PUCContrast
 11800 012c 00000000 		.word	0
 11801 0130 70050000 		.word	PUCPLFreq
 11802 0134 5C050000 		.word	PUCHueC
 11803 0138 38090000 		.word	PUCSaturation
 11804 013c 88050000 		.word	PUCSharp
 11805 0140 00000000 		.word	0
 11806 0144 58070000 		.word	PUCWBMd
 11807 0148 00000000 		.word	0
 11808 014c 6C070000 		.word	PUCWBLC
 11809 0150 00000000 		.word	0
 11810 0154 00000000 		.word	0
 11811 0158 24090000 		.word	PUCDZoom
 11812 015c 00000000 		.word	0
 11815              	curFlag:
 11816 0160 00000000 		.space	64
 11816      00000000 
 11816      00000000 
 11816      00000000 
 11816      00000000 
 11819              	CyFxGpifConfig:
 11820 01a0 0F00     		.short	15
 11821 01a2 0000     		.space	2
 11822 01a4 00000000 		.word	CyFxGpifWavedata
 11823 01a8 00000000 		.word	CyFxGpifWavedataPosition
 11824 01ac 0500     		.short	5
 11825 01ae 0000     		.space	2
 11826 01b0 00000000 		.word	CyFxGpifTransition
 11827 01b4 4C00     		.short	76
 11828 01b6 0000     		.space	2
 11829 01b8 00000000 		.word	CyFxGpifRegValue
 11832              	CyFxGpifConfig_usb2:
 11833 01bc 9300     		.short	147
 11834 01be 0000     		.space	2
 11835 01c0 00000000 		.word	CyFxGpifWavedata_usb2
 11836 01c4 00000000 		.word	CyFxGpifWavedataPosition_usb2
 11837 01c8 0800     		.short	8
 11838 01ca 0000     		.space	2
 11839 01cc 00000000 		.word	CyFxGpifTransition_usb2
 11840 01d0 4C00     		.short	76
 11841 01d2 0000     		.space	2
 11842 01d4 00000000 		.word	CyFxGpifRegValue_usb2
 11843              		.data
 11844              		.align	2
 11845              		.set	.LANCHOR1,. + 0
 11848              	glProbeCtrlFull:
 11849 0000 00       		.byte	0
 11850 0001 00       		.byte	0
 11851 0002 01       		.byte	1
 11852 0003 01       		.byte	1
 11853 0004 15       		.byte	21
 11854 0005 16       		.byte	22
 11855 0006 05       		.byte	5
 11856 0007 00       		.byte	0
 11857 0008 00       		.byte	0
 11858 0009 00       		.byte	0
 11859 000a 00       		.byte	0
 11860 000b 00       		.byte	0
 11861 000c 00       		.byte	0
 11862 000d 00       		.byte	0
 11863 000e 00       		.byte	0
 11864 000f 00       		.byte	0
 11865 0010 00       		.byte	0
 11866 0011 00       		.byte	0
 11867 0012 00       		.byte	0
 11868 0013 C6       		.byte	-58
 11869 0014 99       		.byte	-103
 11870 0015 00       		.byte	0
 11871 0016 00       		.byte	0
 11872 0017 40       		.byte	64
 11873 0018 00       		.byte	0
 11874 0019 00       		.byte	0
 11875 001a 0000     		.space	2
 11878              	glProbeCtrl20:
 11879 001c 00       		.byte	0
 11880 001d 00       		.byte	0
 11881 001e 01       		.byte	1
 11882 001f 01       		.byte	1
 11883 0020 80       		.byte	-128
 11884 0021 1A       		.byte	26
 11885 0022 06       		.byte	6
 11886 0023 00       		.byte	0
 11887 0024 00       		.byte	0
 11888 0025 00       		.byte	0
 11889 0026 00       		.byte	0
 11890 0027 00       		.byte	0
 11891 0028 00       		.byte	0
 11892 0029 00       		.byte	0
 11893 002a 00       		.byte	0
 11894 002b 00       		.byte	0
 11895 002c 00       		.byte	0
 11896 002d 00       		.byte	0
 11897 002e 00       		.byte	0
 11898 002f D2       		.byte	-46
 11899 0030 0F       		.byte	15
 11900 0031 00       		.byte	0
 11901 0032 00       		.byte	0
 11902 0033 40       		.byte	64
 11903 0034 00       		.byte	0
 11904 0035 00       		.byte	0
 11905 0036 0000     		.space	2
 11908              	glProbeCtrl:
 11909 0038 00       		.byte	0
 11910 0039 00       		.byte	0
 11911 003a 01       		.byte	1
 11912 003b 01       		.byte	1
 11913 003c 15       		.byte	21
 11914 003d 16       		.byte	22
 11915 003e 05       		.byte	5
 11916 003f 00       		.byte	0
 11917 0040 00       		.byte	0
 11918 0041 00       		.byte	0
 11919 0042 00       		.byte	0
 11920 0043 00       		.byte	0
 11921 0044 00       		.byte	0
 11922 0045 00       		.byte	0
 11923 0046 00       		.byte	0
 11924 0047 00       		.byte	0
 11925 0048 00       		.byte	0
 11926 0049 00       		.byte	0
 11927 004a 00       		.byte	0
 11928 004b 48       		.byte	72
 11929 004c 3F       		.byte	63
 11930 004d 00       		.byte	0
 11931 004e 00       		.byte	0
 11932 004f 40       		.byte	64
 11933 0050 00       		.byte	0
 11934 0051 00       		.byte	0
 11937              	ROIMode:
 11938 0052 01       		.byte	1
 11939 0053 00       		.space	1
 11942              	glProbeStilCtrl:
 11943 0054 01       		.byte	1
 11944 0055 02       		.byte	2
 11945 0056 00       		.byte	0
 11946 0057 00       		.byte	0
 11947 0058 C6       		.byte	-58
 11948 0059 99       		.byte	-103
 11949 005a 00       		.byte	0
 11950 005b 00       		.byte	0
 11951 005c 40       		.byte	64
 11952 005d 00       		.byte	0
 11953 005e 00       		.byte	0
 11954 005f 00       		.space	1
 11957              	glProbeStilCtrl20:
 11958 0060 01       		.byte	1
 11959 0061 01       		.byte	1
 11960 0062 00       		.byte	0
 11961 0063 00       		.byte	0
 11962 0064 D2       		.byte	-46
 11963 0065 0F       		.byte	15
 11964 0066 00       		.byte	0
 11965 0067 00       		.byte	0
 11966 0068 40       		.byte	64
 11967 0069 00       		.byte	0
 11968 006a 00       		.byte	0
 11969 006b 00       		.space	1
 11972              	ExUCtrlParArry:
 11973 006c 00       		.byte	0
 11974 006d 00       		.byte	0
 11975 006e 04       		.byte	4
 11976 006f 01       		.byte	1
 11977 0070 00       		.byte	0
 11978 0071 38       		.byte	56
 11979 0072 01       		.byte	1
 11980 0073 01       		.byte	1
 11981 0074 00       		.byte	0
 11982 0075 03       		.byte	3
 11983 0076 00       		.byte	0
 11984 0077 4E       		.byte	78
 11985 0078 00       		.byte	0
 11986 0079 4E       		.byte	78
 11987 007a 00       		.byte	0
 11988 007b 30       		.byte	48
 11989 007c 01       		.byte	1
 11990 007d 00       		.byte	0
 11991 007e 00       		.byte	0
 11992 007f 00000000 		.space	5
 11992      00
 11993 0084 00       		.byte	0
 11994 0085 00       		.byte	0
 11995 0086 01       		.byte	1
 11996 0087 00       		.byte	0
 11997 0088 00       		.byte	0
 11998 0089 00       		.byte	0
 11999 008a 00       		.byte	0
 12000 008b 01       		.byte	1
 12001 008c 00       		.byte	0
 12002 008d 03       		.byte	3
 12003 008e 00       		.byte	0
 12004 008f 00       		.byte	0
 12005 0090 00       		.byte	0
 12006 0091 00       		.byte	0
 12007 0092 00       		.byte	0
 12008 0093 30       		.byte	48
 12009 0094 01       		.byte	1
 12010 0095 00       		.byte	0
 12011 0096 00       		.byte	0
 12012 0097 00000000 		.space	5
 12012      00
 12013 009c 00       		.byte	0
 12014 009d 00       		.byte	0
 12015 009e 02       		.byte	2
 12016 009f 00       		.byte	0
 12017 00a0 00       		.byte	0
 12018 00a1 FF       		.byte	-1
 12019 00a2 00       		.byte	0
 12020 00a3 01       		.byte	1
 12021 00a4 00       		.byte	0
 12022 00a5 03       		.byte	3
 12023 00a6 00       		.byte	0
 12024 00a7 01       		.byte	1
 12025 00a8 00       		.byte	0
 12026 00a9 00       		.byte	0
 12027 00aa 00       		.byte	0
 12028 00ab 30       		.byte	48
 12029 00ac 01       		.byte	1
 12030 00ad 01       		.byte	1
 12031 00ae 00       		.byte	0
 12032 00af 00000000 		.space	5
 12032      00
 12033 00b4 00       		.byte	0
 12034 00b5 00       		.byte	0
 12035 00b6 02       		.byte	2
 12036 00b7 00       		.byte	0
 12037 00b8 00       		.byte	0
 12038 00b9 00       		.byte	0
 12039 00ba 00       		.byte	0
 12040 00bb 00       		.byte	0
 12041 00bc 00       		.byte	0
 12042 00bd 03       		.byte	3
 12043 00be 00       		.byte	0
 12044 00bf 00       		.byte	0
 12045 00c0 00       		.byte	0
 12046 00c1 00       		.byte	0
 12047 00c2 00       		.byte	0
 12048 00c3 30       		.byte	48
 12049 00c4 01       		.byte	1
 12050 00c5 01       		.byte	1
 12051 00c6 00       		.byte	0
 12052 00c7 00000000 		.space	5
 12052      00
 12053 00cc 13       		.byte	19
 12054 00cd 14       		.byte	20
 12055 00ce 02       		.byte	2
 12056 00cf 00       		.byte	0
 12057 00d0 00       		.byte	0
 12058 00d1 FF       		.byte	-1
 12059 00d2 FF       		.byte	-1
 12060 00d3 01       		.byte	1
 12061 00d4 00       		.byte	0
 12062 00d5 03       		.byte	3
 12063 00d6 00       		.byte	0
 12064 00d7 66       		.byte	102
 12065 00d8 66       		.byte	102
 12066 00d9 66       		.byte	102
 12067 00da 66       		.byte	102
 12068 00db 30       		.byte	48
 12069 00dc 01       		.byte	1
 12070 00dd 00       		.byte	0
 12071 00de 00       		.byte	0
 12072 00df 00000000 		.space	5
 12072      00
 12073 00e4 11       		.byte	17
 12074 00e5 00       		.byte	0
 12075 00e6 02       		.byte	2
 12076 00e7 01       		.byte	1
 12077 00e8 00       		.byte	0
 12078 00e9 03       		.byte	3
 12079 00ea 00       		.byte	0
 12080 00eb 01       		.byte	1
 12081 00ec 00       		.byte	0
 12082 00ed 03       		.byte	3
 12083 00ee 00       		.byte	0
 12084 00ef 80       		.byte	-128
 12085 00f0 00       		.byte	0
 12086 00f1 80       		.byte	-128
 12087 00f2 00       		.byte	0
 12088 00f3 30       		.byte	48
 12089 00f4 01       		.byte	1
 12090 00f5 01       		.byte	1
 12091 00f6 00       		.byte	0
 12092 00f7 00000000 		.space	5
 12092      00
 12093 00fc 10       		.byte	16
 12094 00fd 00       		.byte	0
 12095 00fe 01       		.byte	1
 12096 00ff 01       		.byte	1
 12097 0100 00       		.byte	0
 12098 0101 02       		.byte	2
 12099 0102 00       		.byte	0
 12100 0103 01       		.byte	1
 12101 0104 00       		.byte	0
 12102 0105 03       		.byte	3
 12103 0106 00       		.byte	0
 12104 0107 00       		.byte	0
 12105 0108 00       		.byte	0
 12106 0109 00       		.byte	0
 12107 010a 00       		.byte	0
 12108 010b 30       		.byte	48
 12109 010c 01       		.byte	1
 12110 010d 01       		.byte	1
 12111 010e 00       		.byte	0
 12112 010f 00000000 		.space	5
 12112      00
 12113 0114 00       		.byte	0
 12114 0115 00       		.byte	0
 12115 0116 04       		.byte	4
 12116 0117 01       		.byte	1
 12117 0118 00       		.byte	0
 12118 0119 38       		.byte	56
 12119 011a 01       		.byte	1
 12120 011b 01       		.byte	1
 12121 011c 00       		.byte	0
 12122 011d 03       		.byte	3
 12123 011e 00       		.byte	0
 12124 011f 4E       		.byte	78
 12125 0120 00       		.byte	0
 12126 0121 4E       		.byte	78
 12127 0122 00       		.byte	0
 12128 0123 30       		.byte	48
 12129 0124 01       		.byte	1
 12130 0125 00       		.byte	0
 12131 0126 00       		.byte	0
 12132 0127 00000000 		.space	5
 12132      00
 12133 012c 00       		.byte	0
 12134 012d 00       		.byte	0
 12135 012e 01       		.byte	1
 12136 012f 00       		.byte	0
 12137 0130 00       		.byte	0
 12138 0131 00       		.byte	0
 12139 0132 00       		.byte	0
 12140 0133 01       		.byte	1
 12141 0134 00       		.byte	0
 12142 0135 03       		.byte	3
 12143 0136 00       		.byte	0
 12144 0137 00       		.byte	0
 12145 0138 00       		.byte	0
 12146 0139 00       		.byte	0
 12147 013a 00       		.byte	0
 12148 013b 30       		.byte	48
 12149 013c 01       		.byte	1
 12150 013d 00       		.byte	0
 12151 013e 00       		.byte	0
 12152 013f 00000000 		.space	5
 12152      00
 12153 0144 00       		.byte	0
 12154 0145 00       		.byte	0
 12155 0146 02       		.byte	2
 12156 0147 00       		.byte	0
 12157 0148 00       		.byte	0
 12158 0149 05       		.byte	5
 12159 014a 00       		.byte	0
 12160 014b 01       		.byte	1
 12161 014c 00       		.byte	0
 12162 014d 03       		.byte	3
 12163 014e 00       		.byte	0
 12164 014f 00       		.byte	0
 12165 0150 00       		.byte	0
 12166 0151 00       		.byte	0
 12167 0152 00       		.byte	0
 12168 0153 30       		.byte	48
 12169 0154 01       		.byte	1
 12170 0155 00       		.byte	0
 12171 0156 00       		.byte	0
 12172 0157 00000000 		.space	5
 12172      00
 12173 015c 00       		.byte	0
 12174 015d 00       		.byte	0
 12175 015e 03       		.byte	3
 12176 015f 00       		.byte	0
 12177 0160 00       		.byte	0
 12178 0161 0A       		.byte	10
 12179 0162 00       		.byte	0
 12180 0163 01       		.byte	1
 12181 0164 00       		.byte	0
 12182 0165 03       		.byte	3
 12183 0166 00       		.byte	0
 12184 0167 00       		.byte	0
 12185 0168 00       		.byte	0
 12186 0169 00       		.byte	0
 12187 016a 00       		.byte	0
 12188 016b 30       		.byte	48
 12189 016c 01       		.byte	1
 12190 016d 00       		.byte	0
 12191 016e 00       		.byte	0
 12192 016f 00000000 		.space	5
 12192      00
 12193 0174 00       		.byte	0
 12194 0175 00       		.byte	0
 12195 0176 02       		.byte	2
 12196 0177 00       		.byte	0
 12197 0178 00       		.byte	0
 12198 0179 40       		.byte	64
 12199 017a 00       		.byte	0
 12200 017b 01       		.byte	1
 12201 017c 00       		.byte	0
 12202 017d 03       		.byte	3
 12203 017e 00       		.byte	0
 12204 017f 0F       		.byte	15
 12205 0180 11       		.byte	17
 12206 0181 00       		.byte	0
 12207 0182 00       		.byte	0
 12208 0183 30       		.byte	48
 12209 0184 01       		.byte	1
 12210 0185 00       		.byte	0
 12211 0186 00       		.byte	0
 12212 0187 00000000 		.space	5
 12212      00
 12213 018c 00       		.byte	0
 12214 018d 00       		.byte	0
 12215 018e 02       		.byte	2
 12216 018f 00       		.byte	0
 12217 0190 00       		.byte	0
 12218 0191 64       		.byte	100
 12219 0192 00       		.byte	0
 12220 0193 01       		.byte	1
 12221 0194 00       		.byte	0
 12222 0195 03       		.byte	3
 12223 0196 00       		.byte	0
 12224 0197 00       		.byte	0
 12225 0198 00       		.byte	0
 12226 0199 00       		.byte	0
 12227 019a 00       		.byte	0
 12228 019b 30       		.byte	48
 12229 019c 01       		.byte	1
 12230 019d 00       		.byte	0
 12231 019e 00       		.byte	0
 12232 019f 00000000 		.space	5
 12232      00
 12233 01a4 00       		.byte	0
 12234 01a5 00       		.byte	0
 12235 01a6 02       		.byte	2
 12236 01a7 00       		.byte	0
 12237 01a8 00       		.byte	0
 12238 01a9 64       		.byte	100
 12239 01aa 00       		.byte	0
 12240 01ab 01       		.byte	1
 12241 01ac 00       		.byte	0
 12242 01ad 03       		.byte	3
 12243 01ae 00       		.byte	0
 12244 01af 00       		.byte	0
 12245 01b0 00       		.byte	0
 12246 01b1 00       		.byte	0
 12247 01b2 00       		.byte	0
 12248 01b3 30       		.byte	48
 12249 01b4 01       		.byte	1
 12250 01b5 00       		.byte	0
 12251 01b6 00       		.byte	0
 12252 01b7 00000000 		.space	5
 12252      00
 12253 01bc 00       		.byte	0
 12254 01bd 00       		.byte	0
 12255 01be 02       		.byte	2
 12256 01bf 00       		.byte	0
 12257 01c0 00       		.byte	0
 12258 01c1 64       		.byte	100
 12259 01c2 00       		.byte	0
 12260 01c3 01       		.byte	1
 12261 01c4 00       		.byte	0
 12262 01c5 03       		.byte	3
 12263 01c6 00       		.byte	0
 12264 01c7 00       		.byte	0
 12265 01c8 00       		.byte	0
 12266 01c9 00       		.byte	0
 12267 01ca 00       		.byte	0
 12268 01cb 30       		.byte	48
 12269 01cc 01       		.byte	1
 12270 01cd 00       		.byte	0
 12271 01ce 00       		.byte	0
 12272 01cf 00000000 		.space	5
 12272      00
 12273 01d4 00       		.byte	0
 12274 01d5 00       		.byte	0
 12275 01d6 02       		.byte	2
 12276 01d7 00       		.byte	0
 12277 01d8 00       		.byte	0
 12278 01d9 64       		.byte	100
 12279 01da 00       		.byte	0
 12280 01db 01       		.byte	1
 12281 01dc 00       		.byte	0
 12282 01dd 03       		.byte	3
 12283 01de 00       		.byte	0
 12284 01df 00       		.byte	0
 12285 01e0 00       		.byte	0
 12286 01e1 00       		.byte	0
 12287 01e2 00       		.byte	0
 12288 01e3 30       		.byte	48
 12289 01e4 01       		.byte	1
 12290 01e5 00       		.byte	0
 12291 01e6 00       		.byte	0
 12292 01e7 00000000 		.space	5
 12292      00
 12295              	CtrlParArry:
 12296 01ec 10       		.byte	16
 12297 01ed 10       		.byte	16
 12298 01ee 02       		.byte	2
 12299 01ef 00       		.byte	0
 12300 01f0 00       		.byte	0
 12301 01f1 03       		.byte	3
 12302 01f2 00       		.byte	0
 12303 01f3 01       		.byte	1
 12304 01f4 00       		.byte	0
 12305 01f5 03       		.byte	3
 12306 01f6 00       		.byte	0
 12307 01f7 03       		.byte	3
 12308 01f8 00       		.byte	0
 12309 01f9 03       		.byte	3
 12310 01fa 00       		.byte	0
 12311 01fb 30       		.byte	48
 12312 01fc 01       		.byte	1
 12313 01fd 00       		.byte	0
 12314 01fe 00       		.byte	0
 12315 01ff 00000000 		.space	5
 12315      00
 12316 0204 15       		.byte	21
 12317 0205 15       		.byte	21
 12318 0206 02       		.byte	2
 12319 0207 00       		.byte	0
 12320 0208 00       		.byte	0
 12321 0209 FF       		.byte	-1
 12322 020a 00       		.byte	0
 12323 020b 01       		.byte	1
 12324 020c 00       		.byte	0
 12325 020d 03       		.byte	3
 12326 020e 00       		.byte	0
 12327 020f 76       		.byte	118
 12328 0210 00       		.byte	0
 12329 0211 76       		.byte	118
 12330 0212 C7       		.byte	-57
 12331 0213 30       		.byte	48
 12332 0214 01       		.byte	1
 12333 0215 01       		.byte	1
 12334 0216 00       		.byte	0
 12335 0217 00000000 		.space	5
 12335      00
 12336 021c 04       		.byte	4
 12337 021d 04       		.byte	4
 12338 021e 02       		.byte	2
 12339 021f 00       		.byte	0
 12340 0220 00       		.byte	0
 12341 0221 FF       		.byte	-1
 12342 0222 00       		.byte	0
 12343 0223 01       		.byte	1
 12344 0224 00       		.byte	0
 12345 0225 03       		.byte	3
 12346 0226 00       		.byte	0
 12347 0227 70       		.byte	112
 12348 0228 00       		.byte	0
 12349 0229 70       		.byte	112
 12350 022a 00       		.byte	0
 12351 022b 30       		.byte	48
 12352 022c 01       		.byte	1
 12353 022d 01       		.byte	1
 12354 022e 00       		.byte	0
 12355 022f 00000000 		.space	5
 12355      00
 12356 0234 00       		.byte	0
 12357 0235 00       		.byte	0
 12358 0236 02       		.byte	2
 12359 0237 00       		.byte	0
 12360 0238 00       		.byte	0
 12361 0239 64       		.byte	100
 12362 023a 00       		.byte	0
 12363 023b 01       		.byte	1
 12364 023c 00       		.byte	0
 12365 023d 03       		.byte	3
 12366 023e 00       		.byte	0
 12367 023f 00       		.byte	0
 12368 0240 00       		.byte	0
 12369 0241 00       		.byte	0
 12370 0242 00       		.byte	0
 12371 0243 30       		.byte	48
 12372 0244 01       		.byte	1
 12373 0245 00       		.byte	0
 12374 0246 00       		.byte	0
 12375 0247 00000000 		.space	5
 12375      00
 12376 024c 07       		.byte	7
 12377 024d 07       		.byte	7
 12378 024e 02       		.byte	2
 12379 024f 00       		.byte	0
 12380 0250 00       		.byte	0
 12381 0251 01       		.byte	1
 12382 0252 00       		.byte	0
 12383 0253 01       		.byte	1
 12384 0254 00       		.byte	0
 12385 0255 03       		.byte	3
 12386 0256 00       		.byte	0
 12387 0257 01       		.byte	1
 12388 0258 00       		.byte	0
 12389 0259 01       		.byte	1
 12390 025a 00       		.byte	0
 12391 025b 30       		.byte	48
 12392 025c 01       		.byte	1
 12393 025d 00       		.byte	0
 12394 025e 00       		.byte	0
 12395 025f 00000000 		.space	5
 12395      00
 12396 0264 DF       		.byte	-33
 12397 0265 E1       		.byte	-31
 12398 0266 02       		.byte	2
 12399 0267 00       		.byte	0
 12400 0268 00       		.byte	0
 12401 0269 FF       		.byte	-1
 12402 026a 00       		.byte	0
 12403 026b 01       		.byte	1
 12404 026c 00       		.byte	0
 12405 026d 03       		.byte	3
 12406 026e 00       		.byte	0
 12407 026f 80       		.byte	-128
 12408 0270 00       		.byte	0
 12409 0271 00       		.byte	0
 12410 0272 00       		.byte	0
 12411 0273 C6       		.byte	-58
 12412 0274 01       		.byte	1
 12413 0275 01       		.byte	1
 12414 0276 00       		.byte	0
 12415 0277 00000000 		.space	5
 12415      00
 12416 027c 85       		.byte	-123
 12417 027d 86       		.byte	-122
 12418 027e 02       		.byte	2
 12419 027f 00       		.byte	0
 12420 0280 00       		.byte	0
 12421 0281 64       		.byte	100
 12422 0282 00       		.byte	0
 12423 0283 01       		.byte	1
 12424 0284 00       		.byte	0
 12425 0285 03       		.byte	3
 12426 0286 00       		.byte	0
 12427 0287 32       		.byte	50
 12428 0288 00       		.byte	0
 12429 0289 32       		.byte	50
 12430 028a 00       		.byte	0
 12431 028b F2       		.byte	-14
 12432 028c 01       		.byte	1
 12433 028d 01       		.byte	1
 12434 028e 00       		.byte	0
 12435 028f 00000000 		.space	5
 12435      00
 12436 0294 06       		.byte	6
 12437 0295 07       		.byte	7
 12438 0296 02       		.byte	2
 12439 0297 00       		.byte	0
 12440 0298 00       		.byte	0
 12441 0299 FF       		.byte	-1
 12442 029a 00       		.byte	0
 12443 029b 01       		.byte	1
 12444 029c 00       		.byte	0
 12445 029d 03       		.byte	3
 12446 029e 00       		.byte	0
 12447 029f 20       		.byte	32
 12448 02a0 00       		.byte	0
 12449 02a1 20       		.byte	32
 12450 02a2 00       		.byte	0
 12451 02a3 30       		.byte	48
 12452 02a4 01       		.byte	1
 12453 02a5 01       		.byte	1
 12454 02a6 00       		.byte	0
 12455 02a7 00000000 		.space	5
 12455      00
 12456 02ac 00       		.byte	0
 12457 02ad 00       		.byte	0
 12458 02ae 02       		.byte	2
 12459 02af 00       		.byte	0
 12460 02b0 00       		.byte	0
 12461 02b1 64       		.byte	100
 12462 02b2 00       		.byte	0
 12463 02b3 01       		.byte	1
 12464 02b4 00       		.byte	0
 12465 02b5 03       		.byte	3
 12466 02b6 00       		.byte	0
 12467 02b7 00       		.byte	0
 12468 02b8 00       		.byte	0
 12469 02b9 00       		.byte	0
 12470 02ba 00       		.byte	0
 12471 02bb 30       		.byte	48
 12472 02bc 01       		.byte	1
 12473 02bd 00       		.byte	0
 12474 02be 00       		.byte	0
 12475 02bf 00000000 		.space	5
 12475      00
 12476 02c4 08       		.byte	8
 12477 02c5 08       		.byte	8
 12478 02c6 02       		.byte	2
 12479 02c7 00       		.byte	0
 12480 02c8 00       		.byte	0
 12481 02c9 05       		.byte	5
 12482 02ca 00       		.byte	0
 12483 02cb 01       		.byte	1
 12484 02cc 00       		.byte	0
 12485 02cd 03       		.byte	3
 12486 02ce 00       		.byte	0
 12487 02cf 00       		.byte	0
 12488 02d0 00       		.byte	0
 12489 02d1 00       		.byte	0
 12490 02d2 00       		.byte	0
 12491 02d3 30       		.byte	48
 12492 02d4 01       		.byte	1
 12493 02d5 00       		.byte	0
 12494 02d6 00       		.byte	0
 12495 02d7 00000000 		.space	5
 12495      00
 12496 02dc 00       		.byte	0
 12497 02dd 00       		.byte	0
 12498 02de 02       		.byte	2
 12499 02df 00       		.byte	0
 12500 02e0 00       		.byte	0
 12501 02e1 40       		.byte	64
 12502 02e2 00       		.byte	0
 12503 02e3 01       		.byte	1
 12504 02e4 00       		.byte	0
 12505 02e5 03       		.byte	3
 12506 02e6 00       		.byte	0
 12507 02e7 00       		.byte	0
 12508 02e8 00       		.byte	0
 12509 02e9 00       		.byte	0
 12510 02ea 00       		.byte	0
 12511 02eb 30       		.byte	48
 12512 02ec 01       		.byte	1
 12513 02ed 00       		.byte	0
 12514 02ee 00       		.byte	0
 12515 02ef 00000000 		.space	5
 12515      00
 12516 02f4 09       		.byte	9
 12517 02f5 0A       		.byte	10
 12518 02f6 04       		.byte	4
 12519 02f7 00       		.byte	0
 12520 02f8 00       		.byte	0
 12521 02f9 40       		.byte	64
 12522 02fa 00       		.byte	0
 12523 02fb 01       		.byte	1
 12524 02fc 00       		.byte	0
 12525 02fd 03       		.byte	3
 12526 02fe 00       		.byte	0
 12527 02ff 20       		.byte	32
 12528 0300 38       		.byte	56
 12529 0301 20       		.byte	32
 12530 0302 38       		.byte	56
 12531 0303 30       		.byte	48
 12532 0304 01       		.byte	1
 12533 0305 00       		.byte	0
 12534 0306 00       		.byte	0
 12535 0307 00000000 		.space	5
 12535      00
 12536 030c 00       		.byte	0
 12537 030d 00       		.byte	0
 12538 030e 02       		.byte	2
 12539 030f 00       		.byte	0
 12540 0310 00       		.byte	0
 12541 0311 64       		.byte	100
 12542 0312 00       		.byte	0
 12543 0313 01       		.byte	1
 12544 0314 00       		.byte	0
 12545 0315 03       		.byte	3
 12546 0316 00       		.byte	0
 12547 0317 00       		.byte	0
 12548 0318 00       		.byte	0
 12549 0319 00       		.byte	0
 12550 031a 00       		.byte	0
 12551 031b 30       		.byte	48
 12552 031c 01       		.byte	1
 12553 031d 00       		.byte	0
 12554 031e 00       		.byte	0
 12555 031f 00000000 		.space	5
 12555      00
 12556 0324 00       		.byte	0
 12557 0325 00       		.byte	0
 12558 0326 02       		.byte	2
 12559 0327 00       		.byte	0
 12560 0328 00       		.byte	0
 12561 0329 64       		.byte	100
 12562 032a 00       		.byte	0
 12563 032b 01       		.byte	1
 12564 032c 00       		.byte	0
 12565 032d 03       		.byte	3
 12566 032e 00       		.byte	0
 12567 032f 00       		.byte	0
 12568 0330 00       		.byte	0
 12569 0331 00       		.byte	0
 12570 0332 00       		.byte	0
 12571 0333 30       		.byte	48
 12572 0334 01       		.byte	1
 12573 0335 00       		.byte	0
 12574 0336 00       		.byte	0
 12575 0337 00000000 		.space	5
 12575      00
 12576 033c 2A       		.byte	42
 12577 033d 2A       		.byte	42
 12578 033e 02       		.byte	2
 12579 033f 00       		.byte	0
 12580 0340 00       		.byte	0
 12581 0341 1B       		.byte	27
 12582 0342 00       		.byte	0
 12583 0343 01       		.byte	1
 12584 0344 00       		.byte	0
 12585 0345 03       		.byte	3
 12586 0346 00       		.byte	0
 12587 0347 00       		.byte	0
 12588 0348 00       		.byte	0
 12589 0349 00       		.byte	0
 12590 034a 00       		.byte	0
 12591 034b 30       		.byte	48
 12592 034c 01       		.byte	1
 12593 034d 00       		.byte	0
 12594 034e 00       		.byte	0
 12595 034f 00000000 		.space	5
 12595      00
 12596 0354 00       		.byte	0
 12597 0355 00       		.byte	0
 12598 0356 02       		.byte	2
 12599 0357 00       		.byte	0
 12600 0358 00       		.byte	0
 12601 0359 64       		.byte	100
 12602 035a 00       		.byte	0
 12603 035b 01       		.byte	1
 12604 035c 00       		.byte	0
 12605 035d 03       		.byte	3
 12606 035e 00       		.byte	0
 12607 035f 00       		.byte	0
 12608 0360 00       		.byte	0
 12609 0361 00       		.byte	0
 12610 0362 00       		.byte	0
 12611 0363 30       		.byte	48
 12612 0364 01       		.byte	1
 12613 0365 00       		.byte	0
 12614 0366 00       		.byte	0
 12615 0367 00000000 		.space	5
 12615      00
 12616 036c 00       		.byte	0
 12617 036d 00       		.byte	0
 12618 036e 02       		.byte	2
 12619 036f 00       		.byte	0
 12620 0370 00       		.byte	0
 12621 0371 12       		.byte	18
 12622 0372 00       		.byte	0
 12623 0373 01       		.byte	1
 12624 0374 00       		.byte	0
 12625 0375 03       		.byte	3
 12626 0376 00       		.byte	0
 12627 0377 00       		.byte	0
 12628 0378 00       		.byte	0
 12629 0379 00       		.byte	0
 12630 037a 00       		.byte	0
 12631 037b 30       		.byte	48
 12632 037c 01       		.byte	1
 12633 037d 00       		.byte	0
 12634 037e 00       		.byte	0
 12635 037f 00000000 		.space	5
 12635      00
 12636 0384 01       		.byte	1
 12637 0385 01       		.byte	1
 12638 0386 02       		.byte	2
 12639 0387 00       		.byte	0
 12640 0388 00       		.byte	0
 12641 0389 09       		.byte	9
 12642 038a 00       		.byte	0
 12643 038b 01       		.byte	1
 12644 038c 00       		.byte	0
 12645 038d 03       		.byte	3
 12646 038e 00       		.byte	0
 12647 038f 00       		.byte	0
 12648 0390 00       		.byte	0
 12649 0391 01       		.byte	1
 12650 0392 00       		.byte	0
 12651 0393 30       		.byte	48
 12652 0394 01       		.byte	1
 12653 0395 00       		.byte	0
 12654 0396 00       		.byte	0
 12655 0397 00000000 		.space	5
 12655      00
 12656 039c 05       		.byte	5
 12657 039d 05       		.byte	5
 12658 039e 02       		.byte	2
 12659 039f 00       		.byte	0
 12660 03a0 00       		.byte	0
 12661 03a1 03       		.byte	3
 12662 03a2 00       		.byte	0
 12663 03a3 01       		.byte	1
 12664 03a4 00       		.byte	0
 12665 03a5 03       		.byte	3
 12666 03a6 00       		.byte	0
 12667 03a7 00       		.byte	0
 12668 03a8 00       		.byte	0
 12669 03a9 00       		.byte	0
 12670 03aa 00       		.byte	0
 12671 03ab 30       		.byte	48
 12672 03ac 01       		.byte	1
 12673 03ad 00       		.byte	0
 12674 03ae 00       		.byte	0
 12675 03af 00000000 		.space	5
 12675      00
 12676 03b4 18       		.byte	24
 12677 03b5 18       		.byte	24
 12678 03b6 02       		.byte	2
 12679 03b7 00       		.byte	0
 12680 03b8 00       		.byte	0
 12681 03b9 01       		.byte	1
 12682 03ba 00       		.byte	0
 12683 03bb 01       		.byte	1
 12684 03bc 00       		.byte	0
 12685 03bd 03       		.byte	3
 12686 03be 00       		.byte	0
 12687 03bf 00       		.byte	0
 12688 03c0 00       		.byte	0
 12689 03c1 00       		.byte	0
 12690 03c2 00       		.byte	0
 12691 03c3 30       		.byte	48
 12692 03c4 01       		.byte	1
 12693 03c5 00       		.byte	0
 12694 03c6 00       		.byte	0
 12695 03c7 00000000 		.space	5
 12695      00
 12696 03cc 19       		.byte	25
 12697 03cd 19       		.byte	25
 12698 03ce 01       		.byte	1
 12699 03cf 00       		.byte	0
 12700 03d0 00       		.byte	0
 12701 03d1 40       		.byte	64
 12702 03d2 00       		.byte	0
 12703 03d3 01       		.byte	1
 12704 03d4 00       		.byte	0
 12705 03d5 03       		.byte	3
 12706 03d6 00       		.byte	0
 12707 03d7 20       		.byte	32
 12708 03d8 00       		.byte	0
 12709 03d9 20       		.byte	32
 12710 03da 00       		.byte	0
 12711 03db 30       		.byte	48
 12712 03dc 01       		.byte	1
 12713 03dd 00       		.byte	0
 12714 03de 00       		.byte	0
 12715 03df 00000000 		.space	5
 12715      00
 12716 03e4 20       		.byte	32
 12717 03e5 20       		.byte	32
 12718 03e6 02       		.byte	2
 12719 03e7 00       		.byte	0
 12720 03e8 00       		.byte	0
 12721 03e9 02       		.byte	2
 12722 03ea 00       		.byte	0
 12723 03eb 01       		.byte	1
 12724 03ec 00       		.byte	0
 12725 03ed 03       		.byte	3
 12726 03ee 00       		.byte	0
 12727 03ef 00       		.byte	0
 12728 03f0 00       		.byte	0
 12729 03f1 00       		.byte	0
 12730 03f2 00       		.byte	0
 12731 03f3 30       		.byte	48
 12732 03f4 01       		.byte	1
 12733 03f5 00       		.byte	0
 12734 03f6 00       		.byte	0
 12735 03f7 00000000 		.space	5
 12735      00
 12736 03fc 22       		.byte	34
 12737 03fd 22       		.byte	34
 12738 03fe 02       		.byte	2
 12739 03ff 00       		.byte	0
 12740 0400 00       		.byte	0
 12741 0401 3F       		.byte	63
 12742 0402 00       		.byte	0
 12743 0403 01       		.byte	1
 12744 0404 00       		.byte	0
 12745 0405 03       		.byte	3
 12746 0406 00       		.byte	0
 12747 0407 00       		.byte	0
 12748 0408 00       		.byte	0
 12749 0409 00       		.byte	0
 12750 040a 00       		.byte	0
 12751 040b 30       		.byte	48
 12752 040c 01       		.byte	1
 12753 040d 00       		.byte	0
 12754 040e 00       		.byte	0
 12755 040f 00000000 		.space	5
 12755      00
 12756 0414 23       		.byte	35
 12757 0415 23       		.byte	35
 12758 0416 02       		.byte	2
 12759 0417 00       		.byte	0
 12760 0418 00       		.byte	0
 12761 0419 64       		.byte	100
 12762 041a 00       		.byte	0
 12763 041b 01       		.byte	1
 12764 041c 00       		.byte	0
 12765 041d 03       		.byte	3
 12766 041e 00       		.byte	0
 12767 041f 10       		.byte	16
 12768 0420 00       		.byte	0
 12769 0421 10       		.byte	16
 12770 0422 00       		.byte	0
 12771 0423 30       		.byte	48
 12772 0424 01       		.byte	1
 12773 0425 00       		.byte	0
 12774 0426 00       		.byte	0
 12775 0427 00000000 		.space	5
 12775      00
 12776 042c 24       		.byte	36
 12777 042d 24       		.byte	36
 12778 042e 02       		.byte	2
 12779 042f 00       		.byte	0
 12780 0430 00       		.byte	0
 12781 0431 64       		.byte	100
 12782 0432 00       		.byte	0
 12783 0433 01       		.byte	1
 12784 0434 00       		.byte	0
 12785 0435 03       		.byte	3
 12786 0436 00       		.byte	0
 12787 0437 10       		.byte	16
 12788 0438 00       		.byte	0
 12789 0439 10       		.byte	16
 12790 043a 00       		.byte	0
 12791 043b 30       		.byte	48
 12792 043c 01       		.byte	1
 12793 043d 00       		.byte	0
 12794 043e 00       		.byte	0
 12795 043f 00000000 		.space	5
 12795      00
 12796 0444 00       		.byte	0
 12797 0445 03       		.byte	3
 12798 0446 04       		.byte	4
 12799 0447 00       		.byte	0
 12800 0448 00       		.byte	0
 12801 0449 7F       		.byte	127
 12802 044a 00       		.byte	0
 12803 044b 01       		.byte	1
 12804 044c 00       		.byte	0
 12805 044d 03       		.byte	3
 12806 044e 00       		.byte	0
 12807 044f 00       		.byte	0
 12808 0450 20       		.byte	32
 12809 0451 00       		.byte	0
 12810 0452 20       		.byte	32
 12811 0453 30       		.byte	48
 12812 0454 01       		.byte	1
 12813 0455 00       		.byte	0
 12814 0456 00       		.byte	0
 12815 0457 00000000 		.space	5
 12815      00
 12816 045c 04       		.byte	4
 12817 045d 04       		.byte	4
 12818 045e 02       		.byte	2
 12819 045f 00       		.byte	0
 12820 0460 00       		.byte	0
 12821 0461 FF       		.byte	-1
 12822 0462 00       		.byte	0
 12823 0463 01       		.byte	1
 12824 0464 00       		.byte	0
 12825 0465 03       		.byte	3
 12826 0466 00       		.byte	0
 12827 0467 60       		.byte	96
 12828 0468 00       		.byte	0
 12829 0469 60       		.byte	96
 12830 046a 00       		.byte	0
 12831 046b 30       		.byte	48
 12832 046c 01       		.byte	1
 12833 046d 00       		.byte	0
 12834 046e 00       		.byte	0
 12835 046f 00000000 		.space	5
 12835      00
 12836 0474 00       		.byte	0
 12837 0475 00       		.byte	0
 12838 0476 02       		.byte	2
 12839 0477 00       		.byte	0
 12840 0478 00       		.byte	0
 12841 0479 19       		.byte	25
 12842 047a 00       		.byte	0
 12843 047b 01       		.byte	1
 12844 047c 00       		.byte	0
 12845 047d 03       		.byte	3
 12846 047e 00       		.byte	0
 12847 047f 00       		.byte	0
 12848 0480 00       		.byte	0
 12849 0481 00       		.byte	0
 12850 0482 00       		.byte	0
 12851 0483 30       		.byte	48
 12852 0484 01       		.byte	1
 12853 0485 00       		.byte	0
 12854 0486 00       		.byte	0
 12855 0487 00000000 		.space	5
 12855      00
 12856 048c 10       		.byte	16
 12857 048d 10       		.byte	16
 12858 048e 02       		.byte	2
 12859 048f 00       		.byte	0
 12860 0490 00       		.byte	0
 12861 0491 06       		.byte	6
 12862 0492 00       		.byte	0
 12863 0493 01       		.byte	1
 12864 0494 00       		.byte	0
 12865 0495 03       		.byte	3
 12866 0496 00       		.byte	0
 12867 0497 03       		.byte	3
 12868 0498 00       		.byte	0
 12869 0499 03       		.byte	3
 12870 049a 00       		.byte	0
 12871 049b 30       		.byte	48
 12872 049c 01       		.byte	1
 12873 049d 00       		.byte	0
 12874 049e 00       		.byte	0
 12875 049f 00000000 		.space	5
 12875      00
 12876 04a4 00       		.byte	0
 12877 04a5 00       		.byte	0
 12878 04a6 02       		.byte	2
 12879 04a7 00       		.byte	0
 12880 04a8 00       		.byte	0
 12881 04a9 03       		.byte	3
 12882 04aa 00       		.byte	0
 12883 04ab 01       		.byte	1
 12884 04ac 00       		.byte	0
 12885 04ad 03       		.byte	3
 12886 04ae 00       		.byte	0
 12887 04af 00       		.byte	0
 12888 04b0 00       		.byte	0
 12889 04b1 00       		.byte	0
 12890 04b2 00       		.byte	0
 12891 04b3 30       		.byte	48
 12892 04b4 01       		.byte	1
 12893 04b5 00       		.byte	0
 12894 04b6 00       		.byte	0
 12895 04b7 00000000 		.space	5
 12895      00
 12896 04bc 50       		.byte	80
 12897 04bd 50       		.byte	80
 12898 04be 01       		.byte	1
 12899 04bf 00       		.byte	0
 12900 04c0 00       		.byte	0
 12901 04c1 03       		.byte	3
 12902 04c2 00       		.byte	0
 12903 04c3 01       		.byte	1
 12904 04c4 00       		.byte	0
 12905 04c5 03       		.byte	3
 12906 04c6 00       		.byte	0
 12907 04c7 00       		.byte	0
 12908 04c8 00       		.byte	0
 12909 04c9 00       		.byte	0
 12910 04ca 00       		.byte	0
 12911 04cb 30       		.byte	48
 12912 04cc 01       		.byte	1
 12913 04cd 00       		.byte	0
 12914 04ce 00       		.byte	0
 12915 04cf 00000000 		.space	5
 12915      00
 12916 04d4 00       		.byte	0
 12917 04d5 00       		.byte	0
 12918 04d6 0B       		.byte	11
 12919 04d7 00       		.byte	0
 12920 04d8 00       		.byte	0
 12921 04d9 FF       		.byte	-1
 12922 04da FF       		.byte	-1
 12923 04db 01       		.byte	1
 12924 04dc 00       		.byte	0
 12925 04dd 03       		.byte	3
 12926 04de 00       		.byte	0
 12927 04df 00       		.byte	0
 12928 04e0 00       		.byte	0
 12929 04e1 00       		.byte	0
 12930 04e2 00       		.byte	0
 12931 04e3 00       		.byte	0
 12932 04e4 01       		.byte	1
 12933 04e5 00       		.byte	0
 12934 04e6 00       		.byte	0
 12935 04e7 00000000 		.space	5
 12935      00
 12938              	glUVCHeader:
 12939 04ec 0C       		.byte	12
 12940 04ed 8C       		.byte	-116
 12941 04ee 00       		.byte	0
 12942 04ef 00       		.byte	0
 12943 04f0 00       		.byte	0
 12944 04f1 00       		.byte	0
 12945 04f2 00       		.byte	0
 12946 04f3 00       		.byte	0
 12947 04f4 00       		.byte	0
 12948 04f5 00       		.byte	0
 12949 04f6 00       		.byte	0
 12950 04f7 00       		.byte	0
 12953              	EXTBLCGrid:
 12954 04f8 10       		.byte	16
 12955 04f9 10       		.byte	16
 12956 04fa 02       		.byte	2
 12957 04fb 01       		.byte	1
 12958 04fc 00       		.byte	0
 12959 04fd 02       		.byte	2
 12960 04fe 00       		.byte	0
 12961 04ff 01       		.byte	1
 12962 0500 00       		.byte	0
 12963 0501 03       		.byte	3
 12964 0502 00       		.byte	0
 12965 0503 00       		.byte	0
 12966 0504 00       		.byte	0
 12967 0505 00       		.byte	0
 12968 0506 00       		.byte	0
 12969 0507 30       		.byte	48
 12970 0508 01       		.byte	1
 12971 0509 00       		.byte	0
 12972 050a 0000     		.space	2
 12975              	EXTAexModGainlev:
 12976 050c 00       		.byte	0
 12977 050d 03       		.byte	3
 12978 050e 04       		.byte	4
 12979 050f 00       		.byte	0
 12980 0510 00       		.byte	0
 12981 0511 7F       		.byte	127
 12982 0512 00       		.byte	0
 12983 0513 01       		.byte	1
 12984 0514 00       		.byte	0
 12985 0515 03       		.byte	3
 12986 0516 00       		.byte	0
 12987 0517 00       		.byte	0
 12988 0518 3F       		.byte	63
 12989 0519 00       		.byte	0
 12990 051a 3F       		.byte	63
 12991 051b 30       		.byte	48
 12992 051c 01       		.byte	1
 12993 051d 00       		.byte	0
 12994 051e 0000     		.space	2
 12997              	EXTExCtrlSped:
 12998 0520 02       		.byte	2
 12999 0521 02       		.byte	2
 13000 0522 02       		.byte	2
 13001 0523 00       		.byte	0
 13002 0524 00       		.byte	0
 13003 0525 FF       		.byte	-1
 13004 0526 00       		.byte	0
 13005 0527 01       		.byte	1
 13006 0528 00       		.byte	0
 13007 0529 03       		.byte	3
 13008 052a 00       		.byte	0
 13009 052b 80       		.byte	-128
 13010 052c 00       		.byte	0
 13011 052d 80       		.byte	-128
 13012 052e 00       		.byte	0
 13013 052f 30       		.byte	48
 13014 0530 01       		.byte	1
 13015 0531 00       		.byte	0
 13016 0532 0000     		.space	2
 13019              	EXTBLCWinPos:
 13020 0534 14       		.byte	20
 13021 0535 13       		.byte	19
 13022 0536 02       		.byte	2
 13023 0537 00       		.byte	0
 13024 0538 00       		.byte	0
 13025 0539 FF       		.byte	-1
 13026 053a FF       		.byte	-1
 13027 053b 01       		.byte	1
 13028 053c 00       		.byte	0
 13029 053d 03       		.byte	3
 13030 053e 00       		.byte	0
 13031 053f 66       		.byte	102
 13032 0540 66       		.byte	102
 13033 0541 66       		.byte	102
 13034 0542 66       		.byte	102
 13035 0543 30       		.byte	48
 13036 0544 01       		.byte	1
 13037 0545 00       		.byte	0
 13038 0546 0000     		.space	2
 13041              	PUCBright:
 13042 0548 15       		.byte	21
 13043 0549 15       		.byte	21
 13044 054a 02       		.byte	2
 13045 054b 00       		.byte	0
 13046 054c 00       		.byte	0
 13047 054d FF       		.byte	-1
 13048 054e 00       		.byte	0
 13049 054f 01       		.byte	1
 13050 0550 00       		.byte	0
 13051 0551 03       		.byte	3
 13052 0552 00       		.byte	0
 13053 0553 76       		.byte	118
 13054 0554 00       		.byte	0
 13055 0555 76       		.byte	118
 13056 0556 77       		.byte	119
 13057 0557 30       		.byte	48
 13058 0558 01       		.byte	1
 13059 0559 00       		.byte	0
 13060 055a 0000     		.space	2
 13063              	PUCHueC:
 13064 055c DF       		.byte	-33
 13065 055d E1       		.byte	-31
 13066 055e 02       		.byte	2
 13067 055f 00       		.byte	0
 13068 0560 00       		.byte	0
 13069 0561 FF       		.byte	-1
 13070 0562 00       		.byte	0
 13071 0563 01       		.byte	1
 13072 0564 00       		.byte	0
 13073 0565 03       		.byte	3
 13074 0566 00       		.byte	0
 13075 0567 80       		.byte	-128
 13076 0568 00       		.byte	0
 13077 0569 00       		.byte	0
 13078 056a 00       		.byte	0
 13079 056b 30       		.byte	48
 13080 056c 01       		.byte	1
 13081 056d 00       		.byte	0
 13082 056e 0000     		.space	2
 13085              	PUCPLFreq:
 13086 0570 07       		.byte	7
 13087 0571 07       		.byte	7
 13088 0572 02       		.byte	2
 13089 0573 00       		.byte	0
 13090 0574 00       		.byte	0
 13091 0575 01       		.byte	1
 13092 0576 00       		.byte	0
 13093 0577 01       		.byte	1
 13094 0578 00       		.byte	0
 13095 0579 03       		.byte	3
 13096 057a 00       		.byte	0
 13097 057b 01       		.byte	1
 13098 057c 00       		.byte	0
 13099 057d 01       		.byte	1
 13100 057e 00       		.byte	0
 13101 057f 30       		.byte	48
 13102 0580 01       		.byte	1
 13103 0581 00       		.byte	0
 13104 0582 0000     		.space	2
 13107              	WBMenuCmpArry:
 13108 0584 20       		.byte	32
 13109 0585 0F       		.byte	15
 13110 0586 38       		.byte	56
 13111 0587 F0       		.byte	-16
 13114              	PUCSharp:
 13115 0588 06       		.byte	6
 13116 0589 07       		.byte	7
 13117 058a 02       		.byte	2
 13118 058b 00       		.byte	0
 13119 058c 00       		.byte	0
 13120 058d FF       		.byte	-1
 13121 058e 00       		.byte	0
 13122 058f 01       		.byte	1
 13123 0590 00       		.byte	0
 13124 0591 03       		.byte	3
 13125 0592 00       		.byte	0
 13126 0593 00       		.byte	0
 13127 0594 00       		.byte	0
 13128 0595 00       		.byte	0
 13129 0596 00       		.byte	0
 13130 0597 30       		.byte	48
 13131 0598 01       		.byte	1
 13132 0599 00       		.byte	0
 13133 059a 0000     		.space	2
 13136              	PUCBLC:
 13137 059c 10       		.byte	16
 13138 059d 11       		.byte	17
 13139 059e 02       		.byte	2
 13140 059f 00       		.byte	0
 13141 05a0 00       		.byte	0
 13142 05a1 03       		.byte	3
 13143 05a2 00       		.byte	0
 13144 05a3 01       		.byte	1
 13145 05a4 00       		.byte	0
 13146 05a5 03       		.byte	3
 13147 05a6 00       		.byte	0
 13148 05a7 03       		.byte	3
 13149 05a8 00       		.byte	0
 13150 05a9 03       		.byte	3
 13151 05aa 00       		.byte	0
 13152 05ab 30       		.byte	48
 13153 05ac 01       		.byte	1
 13154 05ad 00       		.byte	0
 13155 05ae 0000     		.space	2
 13158              	EXTShutter:
 13159 05b0 00       		.byte	0
 13160 05b1 02       		.byte	2
 13161 05b2 02       		.byte	2
 13162 05b3 00       		.byte	0
 13163 05b4 00       		.byte	0
 13164 05b5 08       		.byte	8
 13165 05b6 00       		.byte	0
 13166 05b7 01       		.byte	1
 13167 05b8 00       		.byte	0
 13168 05b9 03       		.byte	3
 13169 05ba 00       		.byte	0
 13170 05bb 00       		.byte	0
 13171 05bc 00       		.byte	0
 13172 05bd 00       		.byte	0
 13173 05be 00       		.byte	0
 13174 05bf 30       		.byte	48
 13175 05c0 01       		.byte	1
 13176 05c1 00       		.byte	0
 13177 05c2 0000     		.space	2
 13180              	EXTShutlev:
 13181 05c4 12       		.byte	18
 13182 05c5 12       		.byte	18
 13183 05c6 02       		.byte	2
 13184 05c7 00       		.byte	0
 13185 05c8 00       		.byte	0
 13186 05c9 FF       		.byte	-1
 13187 05ca 7F       		.byte	127
 13188 05cb 01       		.byte	1
 13189 05cc 00       		.byte	0
 13190 05cd 03       		.byte	3
 13191 05ce 00       		.byte	0
 13192 05cf 3F       		.byte	63
 13193 05d0 00       		.byte	0
 13194 05d1 3F       		.byte	63
 13195 05d2 00       		.byte	0
 13196 05d3 30       		.byte	48
 13197 05d4 01       		.byte	1
 13198 05d5 00       		.byte	0
 13199 05d6 0000     		.space	2
 13202              	CTCtrlParArry:
 13203 05d8 00       		.byte	0
 13204 05d9 00       		.byte	0
 13205 05da 01       		.byte	1
 13206 05db 00       		.byte	0
 13207 05dc 00       		.byte	0
 13208 05dd 03       		.byte	3
 13209 05de 00       		.byte	0
 13210 05df 01       		.byte	1
 13211 05e0 00       		.byte	0
 13212 05e1 03       		.byte	3
 13213 05e2 00       		.byte	0
 13214 05e3 03       		.byte	3
 13215 05e4 00       		.byte	0
 13216 05e5 03       		.byte	3
 13217 05e6 00       		.byte	0
 13218 05e7 30       		.byte	48
 13219 05e8 01       		.byte	1
 13220 05e9 00       		.byte	0
 13221 05ea 00       		.byte	0
 13222 05eb 00000000 		.space	5
 13222      00
 13223 05f0 00       		.byte	0
 13224 05f1 00       		.byte	0
 13225 05f2 01       		.byte	1
 13226 05f3 01       		.byte	1
 13227 05f4 00       		.byte	0
 13228 05f5 0F       		.byte	15
 13229 05f6 00       		.byte	0
 13230 05f7 0F       		.byte	15
 13231 05f8 00       		.byte	0
 13232 05f9 03       		.byte	3
 13233 05fa 00       		.byte	0
 13234 05fb 02       		.byte	2
 13235 05fc 00       		.byte	0
 13236 05fd 02       		.byte	2
 13237 05fe 00       		.byte	0
 13238 05ff 30       		.byte	48
 13239 0600 01       		.byte	1
 13240 0601 01       		.byte	1
 13241 0602 00       		.byte	0
 13242 0603 00000000 		.space	5
 13242      00
 13243 0608 02       		.byte	2
 13244 0609 00       		.byte	0
 13245 060a 01       		.byte	1
 13246 060b 00       		.byte	0
 13247 060c 00       		.byte	0
 13248 060d 01       		.byte	1
 13249 060e 00       		.byte	0
 13250 060f 01       		.byte	1
 13251 0610 00       		.byte	0
 13252 0611 03       		.byte	3
 13253 0612 00       		.byte	0
 13254 0613 00       		.byte	0
 13255 0614 00       		.byte	0
 13256 0615 00       		.byte	0
 13257 0616 00       		.byte	0
 13258 0617 30       		.byte	48
 13259 0618 01       		.byte	1
 13260 0619 01       		.byte	1
 13261 061a 00       		.byte	0
 13262 061b 00000000 		.space	5
 13262      00
 13263 0620 00       		.byte	0
 13264 0621 00       		.byte	0
 13265 0622 04       		.byte	4
 13266 0623 01       		.byte	1
 13267 0624 00       		.byte	0
 13268 0625 38       		.byte	56
 13269 0626 01       		.byte	1
 13270 0627 01       		.byte	1
 13271 0628 00       		.byte	0
 13272 0629 03       		.byte	3
 13273 062a 00       		.byte	0
 13274 062b 4E       		.byte	78
 13275 062c 00       		.byte	0
 13276 062d 4E       		.byte	78
 13277 062e 00       		.byte	0
 13278 062f 30       		.byte	48
 13279 0630 01       		.byte	1
 13280 0631 00       		.byte	0
 13281 0632 00       		.byte	0
 13282 0633 00000000 		.space	5
 13282      00
 13283 0638 04       		.byte	4
 13284 0639 00       		.byte	0
 13285 063a 01       		.byte	1
 13286 063b 00       		.byte	0
 13287 063c 00       		.byte	0
 13288 063d 00       		.byte	0
 13289 063e 00       		.byte	0
 13290 063f 01       		.byte	1
 13291 0640 00       		.byte	0
 13292 0641 03       		.byte	3
 13293 0642 00       		.byte	0
 13294 0643 00       		.byte	0
 13295 0644 00       		.byte	0
 13296 0645 00       		.byte	0
 13297 0646 00       		.byte	0
 13298 0647 30       		.byte	48
 13299 0648 01       		.byte	1
 13300 0649 00       		.byte	0
 13301 064a 00       		.byte	0
 13302 064b 00000000 		.space	5
 13302      00
 13303 0650 05       		.byte	5
 13304 0651 00       		.byte	0
 13305 0652 02       		.byte	2
 13306 0653 00       		.byte	0
 13307 0654 00       		.byte	0
 13308 0655 FF       		.byte	-1
 13309 0656 00       		.byte	0
 13310 0657 01       		.byte	1
 13311 0658 00       		.byte	0
 13312 0659 03       		.byte	3
 13313 065a 00       		.byte	0
 13314 065b 01       		.byte	1
 13315 065c 00       		.byte	0
 13316 065d 00       		.byte	0
 13317 065e 00       		.byte	0
 13318 065f 30       		.byte	48
 13319 0660 01       		.byte	1
 13320 0661 01       		.byte	1
 13321 0662 00       		.byte	0
 13322 0663 00000000 		.space	5
 13322      00
 13323 0668 06       		.byte	6
 13324 0669 00       		.byte	0
 13325 066a 02       		.byte	2
 13326 066b 00       		.byte	0
 13327 066c 00       		.byte	0
 13328 066d 00       		.byte	0
 13329 066e 00       		.byte	0
 13330 066f 00       		.byte	0
 13331 0670 00       		.byte	0
 13332 0671 03       		.byte	3
 13333 0672 00       		.byte	0
 13334 0673 00       		.byte	0
 13335 0674 00       		.byte	0
 13336 0675 00       		.byte	0
 13337 0676 00       		.byte	0
 13338 0677 30       		.byte	48
 13339 0678 01       		.byte	1
 13340 0679 01       		.byte	1
 13341 067a 00       		.byte	0
 13342 067b 00000000 		.space	5
 13342      00
 13343 0680 23       		.byte	35
 13344 0681 00       		.byte	0
 13345 0682 02       		.byte	2
 13346 0683 00       		.byte	0
 13347 0684 00       		.byte	0
 13348 0685 30       		.byte	48
 13349 0686 00       		.byte	0
 13350 0687 01       		.byte	1
 13351 0688 00       		.byte	0
 13352 0689 03       		.byte	3
 13353 068a 0A       		.byte	10
 13354 068b 00       		.byte	0
 13355 068c 00       		.byte	0
 13356 068d 0A       		.byte	10
 13357 068e 00       		.byte	0
 13358 068f 30       		.byte	48
 13359 0690 01       		.byte	1
 13360 0691 01       		.byte	1
 13361 0692 00       		.byte	0
 13362 0693 00000000 		.space	5
 13362      00
 13363 0698 08       		.byte	8
 13364 0699 00       		.byte	0
 13365 069a 01       		.byte	1
 13366 069b 00       		.byte	0
 13367 069c 00       		.byte	0
 13368 069d 7F       		.byte	127
 13369 069e 00       		.byte	0
 13370 069f 01       		.byte	1
 13371 06a0 00       		.byte	0
 13372 06a1 03       		.byte	3
 13373 06a2 00       		.byte	0
 13374 06a3 00       		.byte	0
 13375 06a4 00       		.byte	0
 13376 06a5 00       		.byte	0
 13377 06a6 00       		.byte	0
 13378 06a7 30       		.byte	48
 13379 06a8 01       		.byte	1
 13380 06a9 00       		.byte	0
 13381 06aa 00       		.byte	0
 13382 06ab 00000000 		.space	5
 13382      00
 13383 06b0 09       		.byte	9
 13384 06b1 00       		.byte	0
 13385 06b2 02       		.byte	2
 13386 06b3 00       		.byte	0
 13387 06b4 00       		.byte	0
 13388 06b5 05       		.byte	5
 13389 06b6 00       		.byte	0
 13390 06b7 01       		.byte	1
 13391 06b8 00       		.byte	0
 13392 06b9 03       		.byte	3
 13393 06ba 00       		.byte	0
 13394 06bb 00       		.byte	0
 13395 06bc 00       		.byte	0
 13396 06bd 00       		.byte	0
 13397 06be 00       		.byte	0
 13398 06bf 30       		.byte	48
 13399 06c0 01       		.byte	1
 13400 06c1 00       		.byte	0
 13401 06c2 00       		.byte	0
 13402 06c3 00000000 		.space	5
 13402      00
 13403 06c8 10       		.byte	16
 13404 06c9 00       		.byte	0
 13405 06ca 03       		.byte	3
 13406 06cb 00       		.byte	0
 13407 06cc 00       		.byte	0
 13408 06cd 00       		.byte	0
 13409 06ce 00       		.byte	0
 13410 06cf 00       		.byte	0
 13411 06d0 00       		.byte	0
 13412 06d1 03       		.byte	3
 13413 06d2 00       		.byte	0
 13414 06d3 00       		.byte	0
 13415 06d4 00       		.byte	0
 13416 06d5 00       		.byte	0
 13417 06d6 00       		.byte	0
 13418 06d7 30       		.byte	48
 13419 06d8 01       		.byte	1
 13420 06d9 00       		.byte	0
 13421 06da 00       		.byte	0
 13422 06db 00000000 		.space	5
 13422      00
 13423 06e0 00       		.byte	0
 13424 06e1 00       		.byte	0
 13425 06e2 02       		.byte	2
 13426 06e3 00       		.byte	0
 13427 06e4 00       		.byte	0
 13428 06e5 40       		.byte	64
 13429 06e6 00       		.byte	0
 13430 06e7 01       		.byte	1
 13431 06e8 00       		.byte	0
 13432 06e9 03       		.byte	3
 13433 06ea 00       		.byte	0
 13434 06eb 0F       		.byte	15
 13435 06ec 11       		.byte	17
 13436 06ed 00       		.byte	0
 13437 06ee 00       		.byte	0
 13438 06ef 30       		.byte	48
 13439 06f0 01       		.byte	1
 13440 06f1 00       		.byte	0
 13441 06f2 00       		.byte	0
 13442 06f3 00000000 		.space	5
 13442      00
 13443 06f8 00       		.byte	0
 13444 06f9 00       		.byte	0
 13445 06fa 02       		.byte	2
 13446 06fb 00       		.byte	0
 13447 06fc 00       		.byte	0
 13448 06fd 64       		.byte	100
 13449 06fe 00       		.byte	0
 13450 06ff 01       		.byte	1
 13451 0700 00       		.byte	0
 13452 0701 03       		.byte	3
 13453 0702 00       		.byte	0
 13454 0703 00       		.byte	0
 13455 0704 00       		.byte	0
 13456 0705 00       		.byte	0
 13457 0706 00       		.byte	0
 13458 0707 30       		.byte	48
 13459 0708 01       		.byte	1
 13460 0709 00       		.byte	0
 13461 070a 00       		.byte	0
 13462 070b 00000000 		.space	5
 13462      00
 13463 0710 00       		.byte	0
 13464 0711 00       		.byte	0
 13465 0712 02       		.byte	2
 13466 0713 00       		.byte	0
 13467 0714 00       		.byte	0
 13468 0715 64       		.byte	100
 13469 0716 00       		.byte	0
 13470 0717 01       		.byte	1
 13471 0718 00       		.byte	0
 13472 0719 03       		.byte	3
 13473 071a 00       		.byte	0
 13474 071b 00       		.byte	0
 13475 071c 00       		.byte	0
 13476 071d 00       		.byte	0
 13477 071e 00       		.byte	0
 13478 071f 30       		.byte	48
 13479 0720 01       		.byte	1
 13480 0721 00       		.byte	0
 13481 0722 00       		.byte	0
 13482 0723 00000000 		.space	5
 13482      00
 13483 0728 00       		.byte	0
 13484 0729 00       		.byte	0
 13485 072a 02       		.byte	2
 13486 072b 00       		.byte	0
 13487 072c 00       		.byte	0
 13488 072d 64       		.byte	100
 13489 072e 00       		.byte	0
 13490 072f 01       		.byte	1
 13491 0730 00       		.byte	0
 13492 0731 03       		.byte	3
 13493 0732 00       		.byte	0
 13494 0733 00       		.byte	0
 13495 0734 00       		.byte	0
 13496 0735 00       		.byte	0
 13497 0736 00       		.byte	0
 13498 0737 30       		.byte	48
 13499 0738 01       		.byte	1
 13500 0739 00       		.byte	0
 13501 073a 00       		.byte	0
 13502 073b 00000000 		.space	5
 13502      00
 13503 0740 00       		.byte	0
 13504 0741 00       		.byte	0
 13505 0742 02       		.byte	2
 13506 0743 00       		.byte	0
 13507 0744 00       		.byte	0
 13508 0745 64       		.byte	100
 13509 0746 00       		.byte	0
 13510 0747 01       		.byte	1
 13511 0748 00       		.byte	0
 13512 0749 03       		.byte	3
 13513 074a 00       		.byte	0
 13514 074b 00       		.byte	0
 13515 074c 00       		.byte	0
 13516 074d 00       		.byte	0
 13517 074e 00       		.byte	0
 13518 074f 30       		.byte	48
 13519 0750 01       		.byte	1
 13520 0751 00       		.byte	0
 13521 0752 00       		.byte	0
 13522 0753 00000000 		.space	5
 13522      00
 13525              	PUCWBMd:
 13526 0758 08       		.byte	8
 13527 0759 08       		.byte	8
 13528 075a 02       		.byte	2
 13529 075b 00       		.byte	0
 13530 075c 00       		.byte	0
 13531 075d 05       		.byte	5
 13532 075e 00       		.byte	0
 13533 075f 01       		.byte	1
 13534 0760 00       		.byte	0
 13535 0761 03       		.byte	3
 13536 0762 00       		.byte	0
 13537 0763 00       		.byte	0
 13538 0764 00       		.byte	0
 13539 0765 00       		.byte	0
 13540 0766 00       		.byte	0
 13541 0767 30       		.byte	48
 13542 0768 01       		.byte	1
 13543 0769 00       		.byte	0
 13544 076a 0000     		.space	2
 13547              	PUCWBLC:
 13548 076c 09       		.byte	9
 13549 076d 0A       		.byte	10
 13550 076e 04       		.byte	4
 13551 076f 00       		.byte	0
 13552 0770 00       		.byte	0
 13553 0771 40       		.byte	64
 13554 0772 00       		.byte	0
 13555 0773 01       		.byte	1
 13556 0774 00       		.byte	0
 13557 0775 03       		.byte	3
 13558 0776 00       		.byte	0
 13559 0777 20       		.byte	32
 13560 0778 00       		.byte	0
 13561 0779 38       		.byte	56
 13562 077a 00       		.byte	0
 13563 077b 30       		.byte	48
 13564 077c 01       		.byte	1
 13565 077d 00       		.byte	0
 13566 077e 0000     		.space	2
 13569              	EXTExHyster:
 13570 0780 0B       		.byte	11
 13571 0781 0B       		.byte	11
 13572 0782 02       		.byte	2
 13573 0783 00       		.byte	0
 13574 0784 00       		.byte	0
 13575 0785 FF       		.byte	-1
 13576 0786 00       		.byte	0
 13577 0787 01       		.byte	1
 13578 0788 00       		.byte	0
 13579 0789 03       		.byte	3
 13580 078a 00       		.byte	0
 13581 078b 80       		.byte	-128
 13582 078c 00       		.byte	0
 13583 078d 80       		.byte	-128
 13584 078e 00       		.byte	0
 13585 078f 30       		.byte	48
 13586 0790 01       		.byte	1
 13587 0791 00       		.byte	0
 13590              	snapButFlag:
 13591 0792 01       		.byte	1
 13592 0793 00       		.space	1
 13595              	EXTAGCMaxLimit:
 13596 0794 0C       		.byte	12
 13597 0795 0C       		.byte	12
 13598 0796 02       		.byte	2
 13599 0797 00       		.byte	0
 13600 0798 00       		.byte	0
 13601 0799 10       		.byte	16
 13602 079a 00       		.byte	0
 13603 079b 01       		.byte	1
 13604 079c 00       		.byte	0
 13605 079d 03       		.byte	3
 13606 079e 00       		.byte	0
 13607 079f 00       		.byte	0
 13608 07a0 00       		.byte	0
 13609 07a1 00       		.byte	0
 13610 07a2 00       		.byte	0
 13611 07a3 30       		.byte	48
 13612 07a4 01       		.byte	1
 13613 07a5 00       		.byte	0
 13614 07a6 0000     		.space	2
 13617              	EXTGammaCor:
 13618 07a8 17       		.byte	23
 13619 07a9 17       		.byte	23
 13620 07aa 02       		.byte	2
 13621 07ab 00       		.byte	0
 13622 07ac 00       		.byte	0
 13623 07ad 10       		.byte	16
 13624 07ae 00       		.byte	0
 13625 07af 01       		.byte	1
 13626 07b0 00       		.byte	0
 13627 07b1 03       		.byte	3
 13628 07b2 00       		.byte	0
 13629 07b3 00       		.byte	0
 13630 07b4 00       		.byte	0
 13631 07b5 00       		.byte	0
 13632 07b6 00       		.byte	0
 13633 07b7 30       		.byte	48
 13634 07b8 01       		.byte	1
 13635 07b9 00       		.byte	0
 13636 07ba 0000     		.space	2
 13639              	EXT2DNRSTED:
 13640 07bc 1A       		.byte	26
 13641 07bd 1B       		.byte	27
 13642 07be 04       		.byte	4
 13643 07bf 00       		.byte	0
 13644 07c0 00       		.byte	0
 13645 07c1 FF       		.byte	-1
 13646 07c2 00       		.byte	0
 13647 07c3 01       		.byte	1
 13648 07c4 00       		.byte	0
 13649 07c5 03       		.byte	3
 13650 07c6 00       		.byte	0
 13651 07c7 80       		.byte	-128
 13652 07c8 00       		.byte	0
 13653 07c9 80       		.byte	-128
 13654 07ca 00       		.byte	0
 13655 07cb 30       		.byte	48
 13656 07cc 01       		.byte	1
 13657 07cd 00       		.byte	0
 13658 07ce 0000     		.space	2
 13661              	EXT2DNRGain:
 13662 07d0 18       		.byte	24
 13663 07d1 19       		.byte	25
 13664 07d2 02       		.byte	2
 13665 07d3 00       		.byte	0
 13666 07d4 00       		.byte	0
 13667 07d5 FF       		.byte	-1
 13668 07d6 00       		.byte	0
 13669 07d7 01       		.byte	1
 13670 07d8 00       		.byte	0
 13671 07d9 03       		.byte	3
 13672 07da 00       		.byte	0
 13673 07db 80       		.byte	-128
 13674 07dc 00       		.byte	0
 13675 07dd 80       		.byte	-128
 13676 07de 00       		.byte	0
 13677 07df 30       		.byte	48
 13678 07e0 01       		.byte	1
 13679 07e1 00       		.byte	0
 13680 07e2 0000     		.space	2
 13683              	EXTEnhanceSTED:
 13684 07e4 08       		.byte	8
 13685 07e5 09       		.byte	9
 13686 07e6 04       		.byte	4
 13687 07e7 00       		.byte	0
 13688 07e8 00       		.byte	0
 13689 07e9 FF       		.byte	-1
 13690 07ea 00       		.byte	0
 13691 07eb 01       		.byte	1
 13692 07ec 00       		.byte	0
 13693 07ed 03       		.byte	3
 13694 07ee 00       		.byte	0
 13695 07ef 80       		.byte	-128
 13696 07f0 00       		.byte	0
 13697 07f1 80       		.byte	-128
 13698 07f2 00       		.byte	0
 13699 07f3 30       		.byte	48
 13700 07f4 01       		.byte	1
 13701 07f5 00       		.byte	0
 13702 07f6 0000     		.space	2
 13705              	EXTEnhanceGain:
 13706 07f8 07       		.byte	7
 13707 07f9 07       		.byte	7
 13708 07fa 02       		.byte	2
 13709 07fb 00       		.byte	0
 13710 07fc 00       		.byte	0
 13711 07fd FF       		.byte	-1
 13712 07fe 00       		.byte	0
 13713 07ff 01       		.byte	1
 13714 0800 00       		.byte	0
 13715 0801 03       		.byte	3
 13716 0802 00       		.byte	0
 13717 0803 80       		.byte	-128
 13718 0804 00       		.byte	0
 13719 0805 80       		.byte	-128
 13720 0806 00       		.byte	0
 13721 0807 30       		.byte	48
 13722 0808 01       		.byte	1
 13723 0809 00       		.byte	0
 13724 080a 0000     		.space	2
 13727              	EXTEnhanceMode:
 13728 080c 06       		.byte	6
 13729 080d 06       		.byte	6
 13730 080e 02       		.byte	2
 13731 080f 00       		.byte	0
 13732 0810 00       		.byte	0
 13733 0811 FF       		.byte	-1
 13734 0812 00       		.byte	0
 13735 0813 01       		.byte	1
 13736 0814 00       		.byte	0
 13737 0815 03       		.byte	3
 13738 0816 00       		.byte	0
 13739 0817 80       		.byte	-128
 13740 0818 00       		.byte	0
 13741 0819 80       		.byte	-128
 13742 081a 00       		.byte	0
 13743 081b 30       		.byte	48
 13744 081c 01       		.byte	1
 13745 081d 00       		.byte	0
 13746 081e 0000     		.space	2
 13749              	EXTBLCWeight:
 13750 0820 11       		.byte	17
 13751 0821 11       		.byte	17
 13752 0822 02       		.byte	2
 13753 0823 00       		.byte	0
 13754 0824 00       		.byte	0
 13755 0825 FF       		.byte	-1
 13756 0826 00       		.byte	0
 13757 0827 01       		.byte	1
 13758 0828 00       		.byte	0
 13759 0829 03       		.byte	3
 13760 082a 00       		.byte	0
 13761 082b 80       		.byte	-128
 13762 082c 00       		.byte	0
 13763 082d 80       		.byte	-128
 13764 082e 00       		.byte	0
 13765 082f 30       		.byte	48
 13766 0830 01       		.byte	1
 13767 0831 00       		.byte	0
 13768 0832 0000     		.space	2
 13771              	EXTI2Ccmd:
 13772 0834 00       		.byte	0
 13773 0835 00       		.byte	0
 13774 0836 0B       		.byte	11
 13775 0837 00       		.byte	0
 13776 0838 00       		.byte	0
 13777 0839 FF       		.byte	-1
 13778 083a FF       		.byte	-1
 13779 083b 01       		.byte	1
 13780 083c 00       		.byte	0
 13781 083d 03       		.byte	3
 13782 083e 00       		.byte	0
 13783 083f 00       		.byte	0
 13784 0840 00       		.byte	0
 13785 0841 00       		.byte	0
 13786 0842 00       		.byte	0
 13787 0843 00       		.byte	0
 13788 0844 01       		.byte	1
 13789 0845 00       		.byte	0
 13790 0846 0000     		.space	2
 13793              	EXTSensorPare:
 13794 0848 50       		.byte	80
 13795 0849 50       		.byte	80
 13796 084a 02       		.byte	2
 13797 084b 00       		.byte	0
 13798 084c 00       		.byte	0
 13799 084d 03       		.byte	3
 13800 084e 00       		.byte	0
 13801 084f 01       		.byte	1
 13802 0850 00       		.byte	0
 13803 0851 03       		.byte	3
 13804 0852 00       		.byte	0
 13805 0853 00       		.byte	0
 13806 0854 00       		.byte	0
 13807 0855 00       		.byte	0
 13808 0856 00       		.byte	0
 13809 0857 30       		.byte	48
 13810 0858 01       		.byte	1
 13811 0859 00       		.byte	0
 13812 085a 0000     		.space	2
 13815              	EXTCamMode:
 13816 085c 10       		.byte	16
 13817 085d 10       		.byte	16
 13818 085e 02       		.byte	2
 13819 085f 00       		.byte	0
 13820 0860 00       		.byte	0
 13821 0861 06       		.byte	6
 13822 0862 00       		.byte	0
 13823 0863 01       		.byte	1
 13824 0864 00       		.byte	0
 13825 0865 03       		.byte	3
 13826 0866 00       		.byte	0
 13827 0867 03       		.byte	3
 13828 0868 00       		.byte	0
 13829 0869 03       		.byte	3
 13830 086a 00       		.byte	0
 13831 086b 30       		.byte	48
 13832 086c 01       		.byte	1
 13833 086d 00       		.byte	0
 13834 086e 0000     		.space	2
 13837              	EXTExpReflev:
 13838 0870 04       		.byte	4
 13839 0871 04       		.byte	4
 13840 0872 02       		.byte	2
 13841 0873 00       		.byte	0
 13842 0874 00       		.byte	0
 13843 0875 FF       		.byte	-1
 13844 0876 00       		.byte	0
 13845 0877 01       		.byte	1
 13846 0878 00       		.byte	0
 13847 0879 03       		.byte	3
 13848 087a 00       		.byte	0
 13849 087b 3C       		.byte	60
 13850 087c 00       		.byte	0
 13851 087d 3C       		.byte	60
 13852 087e 00       		.byte	0
 13853 087f 30       		.byte	48
 13854 0880 01       		.byte	1
 13855 0881 00       		.byte	0
 13856 0882 0000     		.space	2
 13859              	EXTNightDaylev:
 13860 0884 24       		.byte	36
 13861 0885 24       		.byte	36
 13862 0886 02       		.byte	2
 13863 0887 00       		.byte	0
 13864 0888 00       		.byte	0
 13865 0889 64       		.byte	100
 13866 088a 00       		.byte	0
 13867 088b 01       		.byte	1
 13868 088c 00       		.byte	0
 13869 088d 03       		.byte	3
 13870 088e 00       		.byte	0
 13871 088f 10       		.byte	16
 13872 0890 00       		.byte	0
 13873 0891 10       		.byte	16
 13874 0892 00       		.byte	0
 13875 0893 30       		.byte	48
 13876 0894 01       		.byte	1
 13877 0895 00       		.byte	0
 13878 0896 0000     		.space	2
 13881              	EXTDayNightlev:
 13882 0898 23       		.byte	35
 13883 0899 23       		.byte	35
 13884 089a 02       		.byte	2
 13885 089b 00       		.byte	0
 13886 089c 00       		.byte	0
 13887 089d 64       		.byte	100
 13888 089e 00       		.byte	0
 13889 089f 01       		.byte	1
 13890 08a0 00       		.byte	0
 13891 08a1 03       		.byte	3
 13892 08a2 00       		.byte	0
 13893 08a3 10       		.byte	16
 13894 08a4 00       		.byte	0
 13895 08a5 10       		.byte	16
 13896 08a6 00       		.byte	0
 13897 08a7 30       		.byte	48
 13898 08a8 01       		.byte	1
 13899 08a9 00       		.byte	0
 13900 08aa 0000     		.space	2
 13903              	EXTDayNightdely:
 13904 08ac 22       		.byte	34
 13905 08ad 22       		.byte	34
 13906 08ae 02       		.byte	2
 13907 08af 00       		.byte	0
 13908 08b0 00       		.byte	0
 13909 08b1 3F       		.byte	63
 13910 08b2 00       		.byte	0
 13911 08b3 01       		.byte	1
 13912 08b4 00       		.byte	0
 13913 08b5 03       		.byte	3
 13914 08b6 00       		.byte	0
 13915 08b7 00       		.byte	0
 13916 08b8 00       		.byte	0
 13917 08b9 00       		.byte	0
 13918 08ba 00       		.byte	0
 13919 08bb 30       		.byte	48
 13920 08bc 01       		.byte	1
 13921 08bd 00       		.byte	0
 13922 08be 0000     		.space	2
 13925              	EXTDayNightMode:
 13926 08c0 20       		.byte	32
 13927 08c1 20       		.byte	32
 13928 08c2 02       		.byte	2
 13929 08c3 00       		.byte	0
 13930 08c4 00       		.byte	0
 13931 08c5 02       		.byte	2
 13932 08c6 00       		.byte	0
 13933 08c7 01       		.byte	1
 13934 08c8 00       		.byte	0
 13935 08c9 03       		.byte	3
 13936 08ca 00       		.byte	0
 13937 08cb 00       		.byte	0
 13938 08cc 00       		.byte	0
 13939 08cd 00       		.byte	0
 13940 08ce 00       		.byte	0
 13941 08cf 30       		.byte	48
 13942 08d0 01       		.byte	1
 13943 08d1 00       		.byte	0
 13944 08d2 0000     		.space	2
 13947              	EXT3DNoiseLev:
 13948 08d4 19       		.byte	25
 13949 08d5 19       		.byte	25
 13950 08d6 02       		.byte	2
 13951 08d7 00       		.byte	0
 13952 08d8 00       		.byte	0
 13953 08d9 40       		.byte	64
 13954 08da 00       		.byte	0
 13955 08db 01       		.byte	1
 13956 08dc 00       		.byte	0
 13957 08dd 03       		.byte	3
 13958 08de 00       		.byte	0
 13959 08df 20       		.byte	32
 13960 08e0 00       		.byte	0
 13961 08e1 20       		.byte	32
 13962 08e2 00       		.byte	0
 13963 08e3 30       		.byte	48
 13964 08e4 01       		.byte	1
 13965 08e5 00       		.byte	0
 13966 08e6 0000     		.space	2
 13969              	EXT3DnoiseReduceMode:
 13970 08e8 18       		.byte	24
 13971 08e9 18       		.byte	24
 13972 08ea 02       		.byte	2
 13973 08eb 00       		.byte	0
 13974 08ec 00       		.byte	0
 13975 08ed 01       		.byte	1
 13976 08ee 00       		.byte	0
 13977 08ef 01       		.byte	1
 13978 08f0 00       		.byte	0
 13979 08f1 03       		.byte	3
 13980 08f2 00       		.byte	0
 13981 08f3 00       		.byte	0
 13982 08f4 00       		.byte	0
 13983 08f5 00       		.byte	0
 13984 08f6 00       		.byte	0
 13985 08f7 30       		.byte	48
 13986 08f8 01       		.byte	1
 13987 08f9 00       		.byte	0
 13988 08fa 0000     		.space	2
 13991              	EXTMirror:
 13992 08fc 05       		.byte	5
 13993 08fd 05       		.byte	5
 13994 08fe 02       		.byte	2
 13995 08ff 00       		.byte	0
 13996 0900 00       		.byte	0
 13997 0901 03       		.byte	3
 13998 0902 00       		.byte	0
 13999 0903 01       		.byte	1
 14000 0904 00       		.byte	0
 14001 0905 03       		.byte	3
 14002 0906 00       		.byte	0
 14003 0907 00       		.byte	0
 14004 0908 00       		.byte	0
 14005 0909 00       		.byte	0
 14006 090a 00       		.byte	0
 14007 090b 30       		.byte	48
 14008 090c 01       		.byte	1
 14009 090d 00       		.byte	0
 14010 090e 0000     		.space	2
 14013              	EXTSensUp:
 14014 0910 01       		.byte	1
 14015 0911 01       		.byte	1
 14016 0912 02       		.byte	2
 14017 0913 00       		.byte	0
 14018 0914 00       		.byte	0
 14019 0915 09       		.byte	9
 14020 0916 00       		.byte	0
 14021 0917 01       		.byte	1
 14022 0918 00       		.byte	0
 14023 0919 03       		.byte	3
 14024 091a 00       		.byte	0
 14025 091b 00       		.byte	0
 14026 091c 00       		.byte	0
 14027 091d 01       		.byte	1
 14028 091e 00       		.byte	0
 14029 091f 30       		.byte	48
 14030 0920 01       		.byte	1
 14031 0921 00       		.byte	0
 14032 0922 0000     		.space	2
 14035              	PUCDZoom:
 14036 0924 2A       		.byte	42
 14037 0925 2A       		.byte	42
 14038 0926 02       		.byte	2
 14039 0927 00       		.byte	0
 14040 0928 00       		.byte	0
 14041 0929 1B       		.byte	27
 14042 092a 00       		.byte	0
 14043 092b 01       		.byte	1
 14044 092c 00       		.byte	0
 14045 092d 03       		.byte	3
 14046 092e 00       		.byte	0
 14047 092f 00       		.byte	0
 14048 0930 00       		.byte	0
 14049 0931 00       		.byte	0
 14050 0932 00       		.byte	0
 14051 0933 30       		.byte	48
 14052 0934 01       		.byte	1
 14053 0935 00       		.byte	0
 14054 0936 0000     		.space	2
 14057              	PUCSaturation:
 14058 0938 85       		.byte	-123
 14059 0939 86       		.byte	-122
 14060 093a 02       		.byte	2
 14061 093b 00       		.byte	0
 14062 093c 00       		.byte	0
 14063 093d 64       		.byte	100
 14064 093e 00       		.byte	0
 14065 093f 01       		.byte	1
 14066 0940 00       		.byte	0
 14067 0941 03       		.byte	3
 14068 0942 00       		.byte	0
 14069 0943 32       		.byte	50
 14070 0944 00       		.byte	0
 14071 0945 32       		.byte	50
 14072 0946 00       		.byte	0
 14073 0947 30       		.byte	48
 14074 0948 01       		.byte	1
 14075 0949 00       		.byte	0
 14076 094a 0000     		.space	2
 14079              	PUCContrast:
 14080 094c 0D       		.byte	13
 14081 094d 0D       		.byte	13
 14082 094e 02       		.byte	2
 14083 094f 00       		.byte	0
 14084 0950 00       		.byte	0
 14085 0951 FF       		.byte	-1
 14086 0952 00       		.byte	0
 14087 0953 01       		.byte	1
 14088 0954 00       		.byte	0
 14089 0955 03       		.byte	3
 14090 0956 00       		.byte	0
 14091 0957 70       		.byte	112
 14092 0958 00       		.byte	0
 14093 0959 70       		.byte	112
 14094 095a 00       		.byte	0
 14095 095b 30       		.byte	48
 14096 095c 01       		.byte	1
 14097 095d 00       		.byte	0
 14098 095e 0000     		.space	2
 14101              	CyFxGpifRegValue_usb2:
 14102 0960 08830080 		.word	-2147450104
 14103 0964 67000000 		.word	103
 14104 0968 01000000 		.word	1
 14105 096c 46000000 		.word	70
 14106 0970 00000000 		.word	0
 14107 0974 00000000 		.word	0
 14108 0978 02000000 		.word	2
 14109 097c 82000000 		.word	130
 14110 0980 82070000 		.word	1922
 14111 0984 40040000 		.word	1088
 14112 0988 FCFF0000 		.word	65532
 14113 098c 28000000 		.word	40
 14114 0990 00000000 		.word	0
 14115 0994 00000000 		.word	0
 14116 0998 00000000 		.word	0
 14117 099c 00000000 		.word	0
 14118 09a0 01000000 		.word	1
 14119 09a4 00000000 		.word	0
 14120 09a8 00000000 		.word	0
 14121 09ac 00000000 		.word	0
 14122 09b0 00000000 		.word	0
 14123 09b4 00000000 		.word	0
 14124 09b8 00000000 		.word	0
 14125 09bc 00000000 		.word	0
 14126 09c0 00000000 		.word	0
 14127 09c4 00000000 		.word	0
 14128 09c8 00000000 		.word	0
 14129 09cc 00000000 		.word	0
 14130 09d0 00000000 		.word	0
 14131 09d4 06000000 		.word	6
 14132 09d8 00000000 		.word	0
 14133 09dc FFFF0000 		.word	65535
 14134 09e0 09010000 		.word	265
 14135 09e4 00000000 		.word	0
 14136 09e8 F71F0000 		.word	8183
 14137 09ec 00000000 		.word	0
 14138 09f0 FFFF0000 		.word	65535
 14139 09f4 09010000 		.word	265
 14140 09f8 00000000 		.word	0
 14141 09fc F71F0000 		.word	8183
 14142 0a00 00000000 		.word	0
 14143 0a04 00000000 		.word	0
 14144 0a08 00000000 		.word	0
 14145 0a0c 00000000 		.word	0
 14146 0a10 00000000 		.word	0
 14147 0a14 00000000 		.word	0
 14148 0a18 00000000 		.word	0
 14149 0a1c 00000000 		.word	0
 14150 0a20 00000000 		.word	0
 14151 0a24 00000000 		.word	0
 14152 0a28 00000000 		.word	0
 14153 0a2c 00000000 		.word	0
 14154 0a30 00000000 		.word	0
 14155 0a34 00000000 		.word	0
 14156 0a38 00000000 		.word	0
 14157 0a3c 00000000 		.word	0
 14158 0a40 00000000 		.word	0
 14159 0a44 00000000 		.word	0
 14160 0a48 00000000 		.word	0
 14161 0a4c 00000000 		.word	0
 14162 0a50 00000000 		.word	0
 14163 0a54 00000000 		.word	0
 14164 0a58 00000000 		.word	0
 14165 0a5c 00040180 		.word	-2147417088
 14166 0a60 01040180 		.word	-2147417087
 14167 0a64 02040180 		.word	-2147417086
 14168 0a68 03040180 		.word	-2147417085
 14169 0a6c 00000000 		.word	0
 14170 0a70 00000000 		.word	0
 14171 0a74 00000000 		.word	0
 14172 0a78 00000000 		.word	0
 14173 0a7c 00000000 		.word	0
 14174 0a80 00000000 		.word	0
 14175 0a84 00000000 		.word	0
 14176 0a88 00000000 		.word	0
 14177 0a8c C1FFFFFF 		.word	-63
 14180              	CyFxGpifWavedataPosition_usb2:
 14181 0a90 00       		.byte	0
 14182 0a91 01       		.byte	1
 14183 0a92 02       		.byte	2
 14184 0a93 03       		.byte	3
 14185 0a94 04       		.byte	4
 14186 0a95 05       		.byte	5
 14187 0a96 06       		.byte	6
 14188 0a97 07       		.byte	7
 14189 0a98 08       		.byte	8
 14190 0a99 09       		.byte	9
 14191 0a9a 0A       		.byte	10
 14192 0a9b 08       		.byte	8
 14193 0a9c 0B       		.byte	11
 14194 0a9d 0C       		.byte	12
 14195 0a9e 0D       		.byte	13
 14196 0a9f 08       		.byte	8
 14197 0aa0 0E       		.byte	14
 14198 0aa1 0F       		.byte	15
 14199 0aa2 08       		.byte	8
 14200 0aa3 08       		.byte	8
 14201 0aa4 08       		.byte	8
 14202 0aa5 08       		.byte	8
 14203 0aa6 08       		.byte	8
 14204 0aa7 08       		.byte	8
 14205 0aa8 08       		.byte	8
 14206 0aa9 08       		.byte	8
 14207 0aaa 08       		.byte	8
 14208 0aab 08       		.byte	8
 14209 0aac 08       		.byte	8
 14210 0aad 08       		.byte	8
 14211 0aae 08       		.byte	8
 14212 0aaf 08       		.byte	8
 14213 0ab0 08       		.byte	8
 14214 0ab1 08       		.byte	8
 14215 0ab2 08       		.byte	8
 14216 0ab3 08       		.byte	8
 14217 0ab4 08       		.byte	8
 14218 0ab5 08       		.byte	8
 14219 0ab6 08       		.byte	8
 14220 0ab7 08       		.byte	8
 14221 0ab8 08       		.byte	8
 14222 0ab9 08       		.byte	8
 14223 0aba 08       		.byte	8
 14224 0abb 08       		.byte	8
 14225 0abc 08       		.byte	8
 14226 0abd 08       		.byte	8
 14227 0abe 08       		.byte	8
 14228 0abf 08       		.byte	8
 14229 0ac0 08       		.byte	8
 14230 0ac1 08       		.byte	8
 14231 0ac2 08       		.byte	8
 14232 0ac3 08       		.byte	8
 14233 0ac4 08       		.byte	8
 14234 0ac5 08       		.byte	8
 14235 0ac6 08       		.byte	8
 14236 0ac7 08       		.byte	8
 14237 0ac8 08       		.byte	8
 14238 0ac9 08       		.byte	8
 14239 0aca 08       		.byte	8
 14240 0acb 08       		.byte	8
 14241 0acc 08       		.byte	8
 14242 0acd 08       		.byte	8
 14243 0ace 08       		.byte	8
 14244 0acf 08       		.byte	8
 14245 0ad0 08       		.byte	8
 14246 0ad1 08       		.byte	8
 14247 0ad2 08       		.byte	8
 14248 0ad3 08       		.byte	8
 14249 0ad4 08       		.byte	8
 14250 0ad5 08       		.byte	8
 14251 0ad6 08       		.byte	8
 14252 0ad7 08       		.byte	8
 14253 0ad8 08       		.byte	8
 14254 0ad9 08       		.byte	8
 14255 0ada 08       		.byte	8
 14256 0adb 08       		.byte	8
 14257 0adc 08       		.byte	8
 14258 0add 08       		.byte	8
 14259 0ade 08       		.byte	8
 14260 0adf 08       		.byte	8
 14261 0ae0 08       		.byte	8
 14262 0ae1 08       		.byte	8
 14263 0ae2 08       		.byte	8
 14264 0ae3 08       		.byte	8
 14265 0ae4 08       		.byte	8
 14266 0ae5 08       		.byte	8
 14267 0ae6 08       		.byte	8
 14268 0ae7 08       		.byte	8
 14269 0ae8 08       		.byte	8
 14270 0ae9 08       		.byte	8
 14271 0aea 08       		.byte	8
 14272 0aeb 08       		.byte	8
 14273 0aec 08       		.byte	8
 14274 0aed 08       		.byte	8
 14275 0aee 08       		.byte	8
 14276 0aef 08       		.byte	8
 14277 0af0 08       		.byte	8
 14278 0af1 08       		.byte	8
 14279 0af2 08       		.byte	8
 14280 0af3 08       		.byte	8
 14281 0af4 08       		.byte	8
 14282 0af5 08       		.byte	8
 14283 0af6 08       		.byte	8
 14284 0af7 08       		.byte	8
 14285 0af8 08       		.byte	8
 14286 0af9 08       		.byte	8
 14287 0afa 08       		.byte	8
 14288 0afb 08       		.byte	8
 14289 0afc 08       		.byte	8
 14290 0afd 08       		.byte	8
 14291 0afe 08       		.byte	8
 14292 0aff 08       		.byte	8
 14293 0b00 08       		.byte	8
 14294 0b01 08       		.byte	8
 14295 0b02 08       		.byte	8
 14296 0b03 08       		.byte	8
 14297 0b04 08       		.byte	8
 14298 0b05 08       		.byte	8
 14299 0b06 08       		.byte	8
 14300 0b07 08       		.byte	8
 14301 0b08 08       		.byte	8
 14302 0b09 08       		.byte	8
 14303 0b0a 08       		.byte	8
 14304 0b0b 08       		.byte	8
 14305 0b0c 08       		.byte	8
 14306 0b0d 08       		.byte	8
 14307 0b0e 08       		.byte	8
 14308 0b0f 08       		.byte	8
 14309 0b10 00       		.byte	0
 14310 0b11 01       		.byte	1
 14311 0b12 02       		.byte	2
 14312 0b13 10       		.byte	16
 14313 0b14 04       		.byte	4
 14314 0b15 05       		.byte	5
 14315 0b16 06       		.byte	6
 14316 0b17 07       		.byte	7
 14317 0b18 08       		.byte	8
 14318 0b19 09       		.byte	9
 14319 0b1a 0A       		.byte	10
 14320 0b1b 08       		.byte	8
 14321 0b1c 11       		.byte	17
 14322 0b1d 0C       		.byte	12
 14323 0b1e 0D       		.byte	13
 14324 0b1f 08       		.byte	8
 14325 0b20 0E       		.byte	14
 14326 0b21 0F       		.byte	15
 14327 0b22 08       		.byte	8
 14328 0b23 00       		.space	1
 14331              	CyFxGpifWavedata_usb2:
 14332 0b24 0181731E 		.word	510886145
 14333 0b28 00000000 		.word	0
 14334 0b2c 00000080 		.word	-2147483648
 14335 0b30 00000000 		.word	0
 14336 0b34 00000000 		.word	0
 14337 0b38 00000000 		.word	0
 14338 0b3c 0201703E 		.word	1047527682
 14339 0b40 00010000 		.word	256
 14340 0b44 A00000C0 		.word	-1073741664
 14341 0b48 00000000 		.word	0
 14342 0b4c 00000000 		.word	0
 14343 0b50 00000000 		.word	0
 14344 0b54 0394731E 		.word	510891011
 14345 0b58 04000020 		.word	536870916
 14346 0b5c 60004080 		.word	-2143289248
 14347 0b60 00000000 		.word	0
 14348 0b64 00000000 		.word	0
 14349 0b68 00000000 		.word	0
 14350 0b6c 0620702E 		.word	779100166
 14351 0b70 0C000000 		.word	12
 14352 0b74 00000080 		.word	-2147483648
 14353 0b78 0620702E 		.word	779100166
 14354 0b7c 0C000000 		.word	12
 14355 0b80 00000080 		.word	-2147483648
 14356 0b84 0394731E 		.word	510891011
 14357 0b88 04000020 		.word	536870916
 14358 0b8c 60004080 		.word	-2143289248
 14359 0b90 0620702E 		.word	779100166
 14360 0b94 0C000000 		.word	12
 14361 0b98 00000080 		.word	-2147483648
 14362 0b9c 0C93731E 		.word	510890764
 14363 0ba0 04000024 		.word	603979780
 14364 0ba4 90004080 		.word	-2143289200
 14365 0ba8 0D20702E 		.word	779100173
 14366 0bac 0C000000 		.word	12
 14367 0bb0 00000080 		.word	-2147483648
 14368 0bb4 0780724E 		.word	1316126727
 14369 0bb8 0A000000 		.word	10
 14370 0bbc 00000080 		.word	-2147483648
 14371 0bc0 08000000 		.word	8
 14372 0bc4 00000000 		.word	0
 14373 0bc8 00010080 		.word	-2147483392
 14374 0bcc 0920702E 		.word	779100169
 14375 0bd0 0C010000 		.word	268
 14376 0bd4 00000080 		.word	-2147483648
 14377 0bd8 0A01701E 		.word	510656778
 14378 0bdc 0E000100 		.word	65550
 14379 0be0 00000080 		.word	-2147483648
 14380 0be4 00000000 		.word	0
 14381 0be8 00000000 		.word	0
 14382 0bec 00000000 		.word	0
 14383 0bf0 00000000 		.word	0
 14384 0bf4 00000000 		.word	0
 14385 0bf8 00000000 		.word	0
 14386 0bfc 0394731E 		.word	510891011
 14387 0c00 04000020 		.word	536870916
 14388 0c04 60004080 		.word	-2143289248
 14389 0c08 08000000 		.word	8
 14390 0c0c 00000000 		.word	0
 14391 0c10 00010080 		.word	-2147483392
 14392 0c14 0B000000 		.word	11
 14393 0c18 00000000 		.word	0
 14394 0c1c 00010080 		.word	-2147483392
 14395 0c20 0C93731E 		.word	510890764
 14396 0c24 04000024 		.word	603979780
 14397 0c28 90004080 		.word	-2143289200
 14398 0c2c 0D20702E 		.word	779100173
 14399 0c30 0C000000 		.word	12
 14400 0c34 00000080 		.word	-2147483648
 14401 0c38 0D20702E 		.word	779100173
 14402 0c3c 0C000000 		.word	12
 14403 0c40 00000080 		.word	-2147483648
 14404 0c44 0E60724E 		.word	1316118542
 14405 0c48 0A000000 		.word	10
 14406 0c4c 00000080 		.word	-2147483648
 14407 0c50 0F000000 		.word	15
 14408 0c54 00000000 		.word	0
 14409 0c58 00010080 		.word	-2147483392
 14410 0c5c 1020702E 		.word	779100176
 14411 0c60 0C010000 		.word	268
 14412 0c64 00000080 		.word	-2147483648
 14413 0c68 1101701E 		.word	510656785
 14414 0c6c 0E000100 		.word	65550
 14415 0c70 00000080 		.word	-2147483648
 14416 0c74 0C93731E 		.word	510890764
 14417 0c78 04000024 		.word	603979780
 14418 0c7c 90004080 		.word	-2143289200
 14419 0c80 0F000000 		.word	15
 14420 0c84 00000000 		.word	0
 14421 0c88 00010080 		.word	-2147483392
 14422 0c8c 12000000 		.word	18
 14423 0c90 00000000 		.word	0
 14424 0c94 00010080 		.word	-2147483392
 14425 0c98 0394731E 		.word	510891011
 14426 0c9c 04000020 		.word	536870916
 14427 0ca0 60004080 		.word	-2143289248
 14428 0ca4 0480732E 		.word	779321348
 14429 0ca8 02010000 		.word	258
 14430 0cac 0000C0C0 		.word	-1061158912
 14431 0cb0 0580732E 		.word	779321349
 14432 0cb4 02010000 		.word	258
 14433 0cb8 0000C0C0 		.word	-1061158912
 14434 0cbc 0580732E 		.word	779321349
 14435 0cc0 02010000 		.word	258
 14436 0cc4 0000C0C0 		.word	-1061158912
 14437 0cc8 0480732E 		.word	779321348
 14438 0ccc 02010000 		.word	258
 14439 0cd0 0000C0C0 		.word	-1061158912
 14442              	CyFxGpifTransition_usb2:
 14443 0cd4 0000     		.short	0
 14444 0cd6 5555     		.short	21845
 14445 0cd8 AAAA     		.short	-21846
 14446 0cda 8888     		.short	-30584
 14447 0cdc 1111     		.short	4369
 14448 0cde 4444     		.short	17476
 14449 0ce0 3333     		.short	13107
 14450 0ce2 CCCC     		.short	-13108
 14453              	CyFxGpifRegValue:
 14454 0ce4 08830080 		.word	-2147450104
 14455 0ce8 67000000 		.word	103
 14456 0cec 00000000 		.word	0
 14457 0cf0 46000000 		.word	70
 14458 0cf4 00000000 		.word	0
 14459 0cf8 00000000 		.word	0
 14460 0cfc 02000000 		.word	2
 14461 0d00 82000000 		.word	130
 14462 0d04 82070000 		.word	1922
 14463 0d08 40040000 		.word	1088
 14464 0d0c FCFF0000 		.word	65532
 14465 0d10 28000000 		.word	40
 14466 0d14 00000000 		.word	0
 14467 0d18 00000000 		.word	0
 14468 0d1c 00000000 		.word	0
 14469 0d20 00000000 		.word	0
 14470 0d24 01000000 		.word	1
 14471 0d28 00000000 		.word	0
 14472 0d2c 00000000 		.word	0
 14473 0d30 00000000 		.word	0
 14474 0d34 00000000 		.word	0
 14475 0d38 00000000 		.word	0
 14476 0d3c 00000000 		.word	0
 14477 0d40 00000000 		.word	0
 14478 0d44 00000000 		.word	0
 14479 0d48 00000000 		.word	0
 14480 0d4c 00000000 		.word	0
 14481 0d50 00000000 		.word	0
 14482 0d54 00000000 		.word	0
 14483 0d58 06000000 		.word	6
 14484 0d5c 00000000 		.word	0
 14485 0d60 FFFF0000 		.word	65535
 14486 0d64 09010000 		.word	265
 14487 0d68 00000000 		.word	0
 14488 0d6c F71F0000 		.word	8183
 14489 0d70 00000000 		.word	0
 14490 0d74 FFFF0000 		.word	65535
 14491 0d78 09010000 		.word	265
 14492 0d7c 00000000 		.word	0
 14493 0d80 F71F0000 		.word	8183
 14494 0d84 00000000 		.word	0
 14495 0d88 00000000 		.word	0
 14496 0d8c 00000000 		.word	0
 14497 0d90 00000000 		.word	0
 14498 0d94 00000000 		.word	0
 14499 0d98 00000000 		.word	0
 14500 0d9c 00000000 		.word	0
 14501 0da0 00000000 		.word	0
 14502 0da4 00000000 		.word	0
 14503 0da8 00000000 		.word	0
 14504 0dac 00000000 		.word	0
 14505 0db0 00000000 		.word	0
 14506 0db4 00000000 		.word	0
 14507 0db8 00000000 		.word	0
 14508 0dbc 00000000 		.word	0
 14509 0dc0 00000000 		.word	0
 14510 0dc4 00000000 		.word	0
 14511 0dc8 00000000 		.word	0
 14512 0dcc 00000000 		.word	0
 14513 0dd0 00000000 		.word	0
 14514 0dd4 00000000 		.word	0
 14515 0dd8 00000000 		.word	0
 14516 0ddc 00000000 		.word	0
 14517 0de0 00040180 		.word	-2147417088
 14518 0de4 01040180 		.word	-2147417087
 14519 0de8 02040180 		.word	-2147417086
 14520 0dec 03040180 		.word	-2147417085
 14521 0df0 00000000 		.word	0
 14522 0df4 00000000 		.word	0
 14523 0df8 00000000 		.word	0
 14524 0dfc 00000000 		.word	0
 14525 0e00 00000000 		.word	0
 14526 0e04 00000000 		.word	0
 14527 0e08 00000000 		.word	0
 14528 0e0c 00000000 		.word	0
 14529 0e10 C1FFFFFF 		.word	-63
 14532              	CyFxGpifWavedataPosition:
 14533 0e14 00       		.byte	0
 14534 0e15 01       		.byte	1
 14535 0e16 02       		.byte	2
 14536 0e17 03       		.byte	3
 14537 0e18 04       		.byte	4
 14538 0e19 05       		.byte	5
 14539 0e1a 06       		.byte	6
 14540 0e1b 07       		.byte	7
 14541 0e1c 08       		.byte	8
 14542 0e1d 09       		.byte	9
 14543 0e1e 0A       		.byte	10
 14544 0e1f 0B       		.byte	11
 14545 0e20 0B       		.byte	11
 14546 0e21 0B       		.byte	11
 14547 0e22 0B       		.byte	11
 14548 0e23 00       		.space	1
 14551              	CyFxGpifWavedata:
 14552 0e24 0181731E 		.word	510886145
 14553 0e28 00000000 		.word	0
 14554 0e2c 00000080 		.word	-2147483648
 14555 0e30 00000000 		.word	0
 14556 0e34 00000000 		.word	0
 14557 0e38 00000000 		.word	0
 14558 0e3c 0201702E 		.word	779092226
 14559 0e40 00010000 		.word	256
 14560 0e44 A0000080 		.word	-2147483488
 14561 0e48 00000000 		.word	0
 14562 0e4c 00000000 		.word	0
 14563 0e50 00000000 		.word	0
 14564 0e54 0380722E 		.word	779255811
 14565 0e58 02010020 		.word	536871170
 14566 0e5c 60000080 		.word	-2147483552
 14567 0e60 00000000 		.word	0
 14568 0e64 00000000 		.word	0
 14569 0e68 00000000 		.word	0
 14570 0e6c 0460722E 		.word	779247620
 14571 0e70 02010024 		.word	603980034
 14572 0e74 90000080 		.word	-2147483504
 14573 0e78 0594731E 		.word	510891013
 14574 0e7c 06000000 		.word	6
 14575 0e80 00000080 		.word	-2147483648
 14576 0e84 0380722E 		.word	779255811
 14577 0e88 02010020 		.word	536871170
 14578 0e8c 60000080 		.word	-2147483552
 14579 0e90 0693731E 		.word	510890758
 14580 0e94 06000000 		.word	6
 14581 0e98 00000080 		.word	-2147483648
 14582 0e9c 0720703E 		.word	1047535623
 14583 0ea0 08010000 		.word	264
 14584 0ea4 00000080 		.word	-2147483648
 14585 0ea8 0820703E 		.word	1047535624
 14586 0eac 08010000 		.word	264
 14587 0eb0 00000080 		.word	-2147483648
 14588 0eb4 0920703E 		.word	1047535625
 14589 0eb8 08010000 		.word	264
 14590 0ebc 00000080 		.word	-2147483648
 14591 0ec0 0A20703E 		.word	1047535626
 14592 0ec4 08010000 		.word	264
 14593 0ec8 00000080 		.word	-2147483648
 14594 0ecc 0380722E 		.word	779255811
 14595 0ed0 02010020 		.word	536871170
 14596 0ed4 60000080 		.word	-2147483552
 14597 0ed8 0B000000 		.word	11
 14598 0edc 00000000 		.word	0
 14599 0ee0 00010080 		.word	-2147483392
 14600 0ee4 0460722E 		.word	779247620
 14601 0ee8 02010024 		.word	603980034
 14602 0eec 90000080 		.word	-2147483504
 14603 0ef0 0D000000 		.word	13
 14604 0ef4 00000000 		.word	0
 14605 0ef8 00010080 		.word	-2147483392
 14606 0efc 0460722E 		.word	779247620
 14607 0f00 02010024 		.word	603980034
 14608 0f04 90000080 		.word	-2147483504
 14609 0f08 0C000000 		.word	12
 14610 0f0c 00000000 		.word	0
 14611 0f10 00010080 		.word	-2147483392
 14612 0f14 0380722E 		.word	779255811
 14613 0f18 02010020 		.word	536871170
 14614 0f1c 60000080 		.word	-2147483552
 14615 0f20 0E000000 		.word	14
 14616 0f24 00000000 		.word	0
 14617 0f28 00010080 		.word	-2147483392
 14618 0f2c 00000000 		.word	0
 14619 0f30 00000000 		.word	0
 14620 0f34 00000000 		.word	0
 14621 0f38 00000000 		.word	0
 14622 0f3c 00000000 		.word	0
 14623 0f40 00000000 		.word	0
 14626              	CyFxGpifTransition:
 14627 0f44 0000     		.short	0
 14628 0f46 5555     		.short	21845
 14629 0f48 8888     		.short	-30584
 14630 0f4a AAAA     		.short	-21846
 14631 0f4c 3333     		.short	13107
 14632 0f4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 14633              		.align	2
 14634              	.LC0:
 14635 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 14635      706F732D 
 14635      74696D65 
 14635      72202564 
 14635      2025640D 
 14636 0016 0000     		.space	2
 14637              	.LC1:
 14638 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 14638      6F207374 
 14638      7265616D 
 14638      20474554 
 14638      20726571 
 14639 003d 000000   		.space	3
 14640              	.LC2:
 14641 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 14641      74686520 
 14641      76696465 
 14641      6F206D6F 
 14641      64652066 
 14642 0061 000000   		.space	3
 14643              	.LC3:
 14644 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 14644      74686520 
 14644      76696465 
 14644      6F206D6F 
 14644      64652066 
 14645 0089 000000   		.space	3
 14646              	.LC4:
 14647 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 14647      43595F46 
 14647      585F5556 
 14647      435F5354 
 14647      5245414D 
 14648 00b2 0000     		.space	2
 14649              	.LC5:
 14650 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 14650      55564320 
 14650      7374696C 
 14650      6C205072 
 14650      6F622873 
 14651 00df 00       		.space	1
 14652              	.LC6:
 14653 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 14653      74686520 
 14653      7374696C 
 14653      6C206D6F 
 14653      64652066 
 14654 0101 000000   		.space	3
 14655              	.LC7:
 14656 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 14656      7374696C 
 14656      6C20636F 
 14656      6D6D6974 
 14656      20636F6E 
 14657              	.LC8:
 14658 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 14658      43595F46 
 14658      585F5556 
 14658      435F5354 
 14658      494C5F45 
 14659              	.LC9:
 14660 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 14660      55564320 
 14660      7374696C 
 14660      6C207472 
 14660      69676765 
 14661 0179 000000   		.space	3
 14662              	.LC10:
 14663 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 14663      7374696C 
 14663      6C207472 
 14663      69676765 
 14663      7220636F 
 14664 01a3 00       		.space	1
 14665              	.LC11:
 14666 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 14666      7065722D 
 14666      74696D65 
 14666      72202564 
 14666      0D0A00
 14667 01b7 00       		.space	1
 14668              	.LC12:
 14669 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 14669      636F6D6D 
 14669      616E6420 
 14669      71756575 
 14669      65206973 
 14670 01db 00       		.space	1
 14671              	.LC13:
 14672 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 14672      7220696E 
 14672      206D756C 
 14672      74696368 
 14672      616E6E65 
 14673 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 14673      2025782C 
 14673      20646D61 
 14673      446F6E65 
 14673      20256420 
 14674              	.LC14:
 14675 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 14675      5420656E 
 14675      636F756E 
 14675      74657265 
 14675      642E2E2E 
 14676              	.LC15:
 14677 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 14677      454E4420 
 14677      656E636F 
 14677      756E7465 
 14677      7265642E 
 14678 026a 0000     		.space	2
 14679              	.LC16:
 14680 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 14680      64697363 
 14680      6F6E6E65 
 14680      63746564 
 14680      2E2E2E30 
 14681 028b 00       		.space	1
 14682              	.LC17:
 14683 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 14683      43595F46 
 14683      585F5556 
 14683      435F5649 
 14683      44454F5F 
 14684 02bf 0A00     		.ascii	"\012\000"
 14685 02c1 000000   		.space	3
 14686              	.LC18:
 14687 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 14687      43595F46 
 14687      585F5556 
 14687      435F5649 
 14687      44454F5F 
 14688 02f7 00       		.ascii	"\000"
 14689              	.LC19:
 14690 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 14690      726E6174 
 14690      65207365 
 14690      7474696E 
 14690      6720302E 
 14691              	.LC20:
 14692 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 14692      72206665 
 14692      61747572 
 14692      65207265 
 14692      71756573 
 14693 0333 00       		.space	1
 14694              	.LC21:
 14695 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 14695      49324320 
 14695      636F6D6D 
 14695      616E6420 
 14695      69732030 
 14696 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14696      78257820 
 14696      30782578 
 14696      20307825 
 14696      78203078 
 14697              	.LC22:
 14698 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 14698      49324320 
 14698      636F6D6D 
 14698      616E6420 
 14698      73657474 
 14699 03a6 0000     		.space	2
 14700              	.LC23:
 14701 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 14701      73687574 
 14701      74657220 
 14701      73657420 
 14701      76616C75 
 14702 03d2 0000     		.space	2
 14703              	.LC24:
 14704 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 14704      26414743 
 14704      2073656E 
 14704      7420746F 
 14704      20686F73 
 14705 03fa 0000     		.space	2
 14706              	.LC25:
 14707 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 14707      49324320 
 14707      63757272 
 14707      656E7420 
 14707      64617461 
 14708 042f 64202564 		.ascii	"d %d\015\012\000"
 14708      0D0A00
 14709 0436 0000     		.space	2
 14710              	.LC26:
 14711 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 14711      63757272 
 14711      656E7420 
 14711      76616C75 
 14711      65203078 
 14712 0465 000000   		.space	3
 14713              	.LC27:
 14714 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 14714      73657420 
 14714      636F6E74 
 14714      726F6C20 
 14714      6374726C 
 14715 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x Data0: 0x%x Data1: 0x%x\015\012"
 14715      443A2030 
 14715      78257820 
 14715      4C656E3A 
 14715      20307825 
 14716 04ca 00       		.ascii	"\000"
 14717 04cb 00       		.space	1
 14718              	.LC28:
 14719 04cc 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 14719      26414743 
 14719      20676F74 
 14719      74656E20 
 14719      66726F6D 
 14720 04fd 0A00     		.ascii	"\012\000"
 14721 04ff 00       		.space	1
 14722              	.LC29:
 14723 0500 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14723      73687574 
 14723      74657226 
 14723      6578706F 
 14723      73757265 
 14724 052b 00       		.space	1
 14725              	.LC30:
 14726 052c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 14726      74657220 
 14726      6C657665 
 14726      6C20676F 
 14726      7474656E 
 14727 055f 25640D0A 		.ascii	"%d\015\012\000"
 14727      00
 14728              	.LC31:
 14729 0564 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 14729      64617461 
 14729      20676574 
 14729      73206672 
 14729      6F6D2068 
 14730 0597 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 14730      78206375 
 14730      7248693A 
 14730      20307825 
 14730      78204C65 
 14731 05b5 000000   		.space	3
 14732              	.LC32:
 14733 05b8 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 14733      75656E63 
 14733      79207365 
 14733      7474696E 
 14733      67206973 
 14734 05d6 0000     		.space	2
 14735              	.LC33:
 14736 05d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 14736      20746865 
 14736      20766964 
 14736      656F206D 
 14736      6F646520 
 14737 05fa 0000     		.space	2
 14738              	.LC34:
 14739 05fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 14739      67657420 
 14739      64617461 
 14739      2066726F 
 14739      6D20686F 
 14740 0629 000000   		.space	3
 14741              	.LC35:
 14742 062c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 14742      52657175 
 14742      65737420 
 14742      30782578 
 14742      20706172 
 14743 065f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 14743      6E642074 
 14743      6F20686F 
 14743      73742030 
 14743      78257820 
 14744 067a 0000     		.space	2
 14745              	.LC36:
 14746 067c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 14746      204F7020 
 14746      72656365 
 14746      69766573 
 14746      20284354 
 14747 06a3 00       		.space	1
 14748              	.LC37:
 14749 06a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 14749      756C7420 
 14749      73656C65 
 14749      63746F72 
 14749      20284354 
 14750 06c6 0000     		.space	2
 14751              	.LC38:
 14752 06c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 14752      756C7420 
 14752      72657175 
 14752      65737420 
 14752      28435429 
 14753 06e9 000000   		.space	3
 14754              	.LC39:
 14755 06ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 14755      52657175 
 14755      65737420 
 14755      30782578 
 14755      20706172 
 14756 071f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 14756      20307825 
 14756      78202F20 
 14756      73656E64 
 14756      20746F20 
 14757 074c 00       		.ascii	"\000"
 14758 074d 000000   		.space	3
 14759              	.LC40:
 14760 0750 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 14760      73657420 
 14760      64656620 
 14760      64617461 
 14760      20307825 
 14761 076f 00       		.space	1
 14762              	.LC41:
 14763 0770 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 14763      73657420 
 14763      64656620 
 14763      64617461 
 14763      20307825 
 14764 07a3 2E0D0A00 		.ascii	".\015\012\000"
 14765 07a7 00       		.space	1
 14766              	.LC42:
 14767 07a8 4572726F 		.ascii	"Error handler...\015\012\000"
 14767      72206861 
 14767      6E646C65 
 14767      722E2E2E 
 14767      0D0A00
 14768 07bb 00       		.space	1
 14769              	.LC43:
 14770 07bc 55415254 		.ascii	"UART initialization failed!\012\000"
 14770      20696E69 
 14770      7469616C 
 14770      697A6174 
 14770      696F6E20 
 14771 07d9 000000   		.space	3
 14772              	.LC44:
 14773 07dc 49324320 		.ascii	"I2C initialization failed!\012\000"
 14773      696E6974 
 14773      69616C69 
 14773      7A617469 
 14773      6F6E2066 
 14774              	.LC45:
 14775 07f8 49324320 		.ascii	"I2C configuration failed!\012\000"
 14775      636F6E66 
 14775      69677572 
 14775      6174696F 
 14775      6E206661 
 14776 0813 00       		.space	1
 14777              	.LC46:
 14778 0814 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 14778      43726561 
 14778      74652045 
 14778      76656E74 
 14778      20666169 
 14779 083e 0000     		.space	2
 14780              	.LC47:
 14781 0840 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 14781      20496E69 
 14781      74206661 
 14781      696C6564 
 14781      2C204572 
 14782 0863 00       		.space	1
 14783              	.LC48:
 14784 0864 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 14784      204F7665 
 14784      72726964 
 14784      65206661 
 14784      696C6564 
 14785 088b 00       		.space	1
 14786              	.LC49:
 14787 088c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 14787      28323029 
 14787      204F7665 
 14787      72726964 
 14787      65206661 
 14788 08b7 00       		.space	1
 14789              	.LC50:
 14790 08b8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 14790      28323429 
 14790      204F7665 
 14790      72726964 
 14790      65206661 
 14791 08e3 00       		.space	1
 14792              	.LC51:
 14793 08e4 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 14793      20536574 
 14793      20287265 
 14793      73657420 
 14793      32322920 
 14794 0916 00       		.ascii	"\000"
 14795 0917 00       		.space	1
 14796              	.LC52:
 14797 0918 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 14797      20536574 
 14797      2028706F 
 14797      77657220 
 14797      32302920 
 14798 094a 00       		.ascii	"\000"
 14799 094b 00       		.space	1
 14800              	.LC53:
 14801 094c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 14801      20536574 
 14801      2028736E 
 14801      61702073 
 14801      686F7420 
 14802 097f 25640A00 		.ascii	"%d\012\000"
 14803 0983 00       		.space	1
 14804              	.LC54:
 14805 0984 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 14805      46756E63 
 14805      74696F6E 
 14805      20466169 
 14805      6C656420 
 14806 09b3 00       		.space	1
 14807              	.LC55:
 14808 09b4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 14808      46756E63 
 14808      74696F6E 
 14808      20466169 
 14808      6C656420 
 14809 09e3 00       		.space	1
 14810              	.LC56:
 14811 09e4 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 14811      53657420 
 14811      456E6470 
 14811      6F696E74 
 14811      20636F6E 
 14812 0a14 00       		.ascii	"\000"
 14813 0a15 000000   		.space	3
 14814              	.LC57:
 14815 0a18 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 14815      496E7465 
 14815      72727570 
 14815      74205374 
 14815      61747573 
 14816 0a4b 20436F64 		.ascii	" Code = %d\012\000"
 14816      65203D20 
 14816      25640A00 
 14817 0a57 00       		.space	1
 14818              	.LC58:
 14819 0a58 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 14819      65642074 
 14819      6F20616C 
 14819      6C6F6361 
 14819      7465206D 
 14820 0a8b 65720D0A 		.ascii	"er\015\012\000"
 14820      00
 14821              	.LC59:
 14822 0a90 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 14822      4368616E 
 14822      6E656C20 
 14822      43726561 
 14822      74696F6E 
 14823 0abe 0000     		.space	2
 14824              	.LC60:
 14825 0ac0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 14825      436F6E6E 
 14825      65637420 
 14825      6661696C 
 14825      65642C20 
 14826 0ae5 000000   		.space	3
 14827              	.LC61:
 14828 0ae8 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 14828      74686520 
 14828      76696465 
 14828      6F206D6F 
 14828      64652066 
 14829 0b0a 0000     		.space	2
 14830              	.LC62:
 14831 0b0c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 14831      4368616E 
 14831      6E656C20 
 14831      52657365 
 14831      74204661 
 14832 0b37 00       		.space	1
 14833              	.LC63:
 14834 0b38 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 14834      4368616E 
 14834      6E656C20 
 14834      53657420 
 14834      5472616E 
 14835 0b69 00       		.ascii	"\000"
 14836 0b6a 0000     		.space	2
 14837              	.LC64:
 14838 0b6c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 14838      4368616E 
 14838      6E656C20 
 14838      53657420 
 14838      5472616E 
 14839 0b9d 0A00     		.ascii	"\012\000"
 14840 0b9f 00       		.space	1
 14841              	.LC65:
 14842 0ba0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 14842      75706572 
 14842      20677069 
 14842      6600
 14843 0bae 0000     		.space	2
 14844              	.LC66:
 14845 0bb0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 14845      69676820 
 14845      67706966 
 14845      00
 14846 0bbd 000000   		.space	3
 14847              	.LC67:
 14848 0bc0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 14848      696E6720 
 14848      47504946 
 14848      20436F6E 
 14848      66696775 
 14849 0bf3 0A00     		.ascii	"\012\000"
 14850 0bf5 000000   		.space	3
 14851              	.LC68:
 14852 0bf8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 14852      74696E67 
 14852      20475049 
 14852      46207374 
 14852      61746520 
 14853 0c2b 0D0A00   		.ascii	"\015\012\000"
 14854 0c2e 0000     		.space	2
 14855              	.LC69:
 14856 0c30 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 14856      73706565 
 14856      64203D20 
 14856      25642065 
 14856      76656E66 
 14857 0c60 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 14857      71756573 
 14857      74203D20 
 14857      30782578 
 14857      20775661 
 14858 0c90 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 14858      203D2030 
 14858      78257820 
 14858      6973666C 
 14858      61672030 
 14859 0caa 0000     		.space	2
 14860              	.LC70:
 14861 0cac 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 14861      64656661 
 14861      756C7420 
 14861      73657475 
 14861      70207265 
 14862              	.LC71:
 14863 0cd8 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 14863      68797374 
 14863      65722063 
 14863      6F6D6D61 
 14863      6E642030 
 14864 0cf7 00       		.space	1
 14865              	.LC72:
 14866 0cf8 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 14866      6374726C 
 14866      73706420 
 14866      636F6D6D 
 14866      616E6420 
 14867              	.LC73:
 14868 0d18 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 14868      65646765 
 14868      4D6F6465 
 14868      20636F6D 
 14868      6D616E64 
 14869 0d39 000000   		.space	3
 14870              	.LC74:
 14871 0d3c 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 14871      65646765 
 14871      6761696E 
 14871      20636F6D 
 14871      6D616E64 
 14872 0d5d 000000   		.space	3
 14873              	.LC75:
 14874 0d60 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 14874      65646765 
 14874      20737461 
 14874      72742F65 
 14874      6E642063 
 14875 0d87 00       		.space	1
 14876              	.LC76:
 14877 0d88 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 14877      32444E52 
 14877      20737461 
 14877      72742F65 
 14877      6E642063 
 14878 0daf 00       		.space	1
 14879              	.LC77:
 14880 0db0 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 14880      67616D6D 
 14880      6120636F 
 14880      6D6D616E 
 14880      64203078 
 14881 0dce 0000     		.space	2
 14882              	.LC78:
 14883 0dd0 54686520 		.ascii	"The AGC Max command 0x%x 0x%x\015\012\000"
 14883      41474320 
 14883      4D617820 
 14883      636F6D6D 
 14883      616E6420 
 14884              	.LC79:
 14885 0df0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 14885      65642074 
 14885      6F207365 
 14885      6E642069 
 14885      6E746572 
 14886 0e21 0A00     		.ascii	"\012\000"
 14887 0e23 00       		.space	1
 14888              	.LC80:
 14889 0e24 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 14889      6F6D6D69 
 14889      74656F66 
 14889      20737461 
 14889      7465203D 
 14890              	.LC81:
 14891 0e3c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 14891      6E656C20 
 14891      53657420 
 14891      57726170 
 14891      55702066 
 14892 0e69 000000   		.space	3
 14893              	.LC82:
 14894 0e6c 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 14894      69742045 
 14894      4F462066 
 14894      61696C65 
 14894      64210D0A 
 14895 0e81 000000   		.space	3
 14896              	.LC83:
 14897 0e84 49324363 		.ascii	"I2CcmdQue\000"
 14897      6D645175 
 14897      6500
 14898 0e8e 0000     		.space	2
 14899              	.LC84:
 14900 0e90 33303A55 		.ascii	"30:UVC App Thread\000"
 14900      56432041 
 14900      70702054 
 14900      68726561 
 14900      6400
 14901 0ea2 0000     		.space	2
 14902              	.LC85:
 14903 0ea4 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 14903      56432041 
 14903      70702045 
 14903      50302054 
 14903      68726561 
 14904 0eba 0000     		.space	2
 14905              	.LC86:
 14906 0ebc 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 14906      32432041 
 14906      70702043 
 14906      54524C20 
 14906      54687265 
 14907 0ed3 00       		.bss
 14908              		.align	2
 14909              		.set	.LANCHOR0,. + 0
 14912              	glFxUVCEvent:
 14913 0000 00000000 		.space	40
 14913      00000000 
 14913      00000000 
 14913      00000000 
 14913      00000000 
 14916              	glEp0Buffer:
 14917 0028 00000000 		.space	32
 14917      00000000 
 14917      00000000 
 14917      00000000 
 14917      00000000 
 14920              	usbSpeed:
 14921 0048 00       		.space	1
 14922 0049 000000   		.space	3
 14925              	glCommitCtrl:
 14926 004c 00000000 		.space	32
 14926      00000000 
 14926      00000000 
 14926      00000000 
 14926      00000000 
 14929              	is60Hz:
 14930 006c 00000000 		.space	4
 14933              	setRes:
 14934 0070 00       		.space	1
 14937              	setstilRes:
 14938 0071 00       		.space	1
 14941              	stiflag:
 14942 0072 00       		.space	1
 14943 0073 00       		.space	1
 14946              	fb:
 14947 0074 0000     		.space	2
 14950              	pb:
 14951 0076 0000     		.space	2
 14954              	pbc:
 14955 0078 0000     		.space	2
 14956 007a 0000     		.space	2
 14959              	hitFV:
 14960 007c 00000000 		.space	4
 14963              	prodCount:
 14964 0080 0000     		.space	2
 14967              	consCount:
 14968 0082 0000     		.space	2
 14971              	streamingStarted:
 14972 0084 00000000 		.space	4
 14975              	gpif_initialized:
 14976 0088 00000000 		.space	4
 14979              	isUsbConnected:
 14980 008c 00000000 		.space	4
 14983              	clearFeatureRqtReceived:
 14984 0090 00000000 		.space	4
 14987              	I2CCMDArry:
 14988 0094 00000000 		.space	12
 14988      00000000 
 14988      00000000 
 14991              	IMcount.8243:
 14992 00a0 00       		.space	1
 14993 00a1 000000   		.space	3
 14996              	uvcAppThread:
 14997 00a4 00000000 		.space	168
 14997      00000000 
 14997      00000000 
 14997      00000000 
 14997      00000000 
 15000              	uvcAppEP0Thread:
 15001 014c 00000000 		.space	168
 15001      00000000 
 15001      00000000 
 15001      00000000 
 15001      00000000 
 15004              	i2cAppThread:
 15005 01f4 00000000 		.space	168
 15005      00000000 
 15005      00000000 
 15005      00000000 
 15005      00000000 
 15008              	pbcpbak:
 15009 029c 0000     		.space	2
 15012              	pbcbak:
 15013 029e 0000     		.space	2
 15016              	pbbak:
 15017 02a0 0000     		.space	2
 15020              	fbbak:
 15021 02a2 0000     		.space	2
 15024              	testSnap:
 15025 02a4 00       		.space	1
 15026 02a5 000000   		.text
 15027              	.Letext0:
 15028              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15029              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15030              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15031              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15032              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15033              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15034              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15035              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15036              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15037              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15038              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15039              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15040              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15041              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15042              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15043              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15044              		.file 18 "../sensor.h"
 15045              		.file 19 "../cmdqu.h"
 15046              		.file 20 "../uvc.h"
 15047              		.file 21 "../cyfxgpif2config.h"
 15048              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15049              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2549   .text:000014e0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2577   .text:00001544 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2662   .text:00001604 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2680   .text:00001644 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2800   .text:00001748 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2813   .text:00001774 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2871   .text:000017f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:2886   .text:00001824 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:3557   .text:00001e74 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:3564   .text:00001e84 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:4075   .text:00002344 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:4098   .text:00002394 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:4724   .text:000029bc CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:4871   .text:00002ae4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:4884   .text:00002b0c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5300   .text:00002f3c $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5311   .text:00002f5c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5581   .text:000031f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5593   .text:00003214 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5596   .text:00003214 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5897   .text:000034d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5904   .text:000034e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5907   .text:000034e0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5951   .text:00003524 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5956   .text:0000352c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5959   .text:0000352c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5987   .text:00003548 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5991   .text:0000354c $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:5994   .text:0000354c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:6779   .text:00003bc8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:6785   .text:00003bd8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:7260   .text:00003fc0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11311  .text:000060c0 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:7319   .text:00004098 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:7322   .text:00004098 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:7391   .text:00004110 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:7399   .text:00004120 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:9208   .text:00005084 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:9245   .text:000050fc $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:10561  .text:00005a60 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:10567  .text:00005a70 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11343  .text:000060f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11356  .text:00006120 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11361  .text:00006130 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11366  .text:00006140 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11414  .text:00006198 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11424  .text:000061ac $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11427  .text:000061ac CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11580  .text:000062f4 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11597  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11600  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:12938  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11957  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11878  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11942  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11848  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11908  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14971  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14983  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14920  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14979  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15008  .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15012  .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15016  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15020  .bss:000002a2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14954  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14950  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14946  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15024  .bss:000002a4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13590  .data:00000792 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11832  .rodata:000001bc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14101  .data:00000960 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14180  .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14331  .data:00000b24 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14442  .data:00000cd4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11819  .rodata:000001a0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14453  .data:00000ce4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14532  .data:00000e14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14551  .data:00000e24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14626  .data:00000f44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11740  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11744  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11759  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13158  .data:000005b0 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14013  .data:00000910 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13991  .data:000008fc EXTMirror
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13969  .data:000008e8 EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13947  .data:000008d4 EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13925  .data:000008c0 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13903  .data:000008ac EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13881  .data:00000898 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13859  .data:00000884 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:12975  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13837  .data:00000870 EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13180  .data:000005c4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13815  .data:0000085c EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13793  .data:00000848 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13771  .data:00000834 EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13019  .data:00000534 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13749  .data:00000820 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:12953  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13569  .data:00000780 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:12997  .data:00000520 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13727  .data:0000080c EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13705  .data:000007f8 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13683  .data:000007e4 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13661  .data:000007d0 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13639  .data:000007bc EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13617  .data:000007a8 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13595  .data:00000794 EXTAGCMaxLimit
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11796  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13136  .data:0000059c PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13041  .data:00000548 PUCBright
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14079  .data:0000094c PUCContrast
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13085  .data:00000570 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13063  .data:0000055c PUCHueC
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14057  .data:00000938 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13114  .data:00000588 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13525  .data:00000758 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13547  .data:0000076c PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14035  .data:00000924 PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11815  .rodata:00000160 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11844  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11937  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:11972  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:12295  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13107  .data:00000584 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:13202  .data:000005d8 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14633  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14908  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14912  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14916  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14925  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14929  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14933  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14937  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14941  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14959  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14963  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14967  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14975  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14987  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14991  .bss:000000a0 IMcount.8243
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:14996  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15000  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccFrOp06.s:15004  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
SensorGetControl
memcpy
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
