   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB27:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      **** CyBool_t        streamingRecove = CyFalse;              /* start streaming again */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static CyBool_t stream_start = CyFalse;
 214:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 215:../uvc.c      ****                                                            the current video frame. */
 216:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 217:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 218:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 219:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 220:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 221:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 222:../uvc.c      **** 
 223:../uvc.c      **** /************ control parameters array ***********
 224:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 225:../uvc.c      ****  *    e.g.
 226:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 227:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 228:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 229:../uvc.c      ****  **************************************************/
 230:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 231:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 232:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 233:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 234:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 236:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 237:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 238:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 239:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 240:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 241:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 244:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 245:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 249:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 254:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 256:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 258:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 259:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 260:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 261:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 262:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 264:../uvc.c      **** 		/**********************************
 265:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 266:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 267:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 268:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 269:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 270:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 271:../uvc.c      **** 		 *
 272:../uvc.c      **** 		 *********************************/
 273:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 274:../uvc.c      **** };
 275:../uvc.c      **** #if 1 // the new control structure
 276:../uvc.c      **** /* the processing unit control request */
 277:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 278:../uvc.c      **** 
 279:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 280:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 281:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 282:../uvc.c      **** 		 2,					//UVCLn: the command length
 283:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 284:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 285:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 286:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 287:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 288:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 289:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 290:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 291:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 292:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 293:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 294:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 295:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 296:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 297:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 298:../uvc.c      **** 		}; //
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 301:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 302:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 303:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 304:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 305:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 306:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 307:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 308:../uvc.c      **** 		 2,					//UVCLn: the command length
 309:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 310:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 311:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 312:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 313:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 314:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 315:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 316:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 317:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 318:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 319:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 320:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 321:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 322:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 323:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 324:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 325:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 326:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 327:../uvc.c      **** 
 328:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 329:../uvc.c      **** 	&PUCBLC,
 330:../uvc.c      **** 	0, //&PUCBright,
 331:../uvc.c      **** 	0, //&PUCContrast,
 332:../uvc.c      **** 	0, //&PUCGain (AGC?)
 333:../uvc.c      **** 	0, //&PUCPLFreq,
 334:../uvc.c      **** 	0, //&PUCHueC,
 335:../uvc.c      **** 	0, //&PUCSaturation,
 336:../uvc.c      **** 	&PUCSharp,
 337:../uvc.c      **** 	0, //&PUCGamGain,
 338:../uvc.c      **** 	0, //&PUCWBMd,
 339:../uvc.c      **** 	0, //UVCCtlID10,
 340:../uvc.c      **** 	0, //&PUCWBLC,
 341:../uvc.c      **** 	0, //UVCCtlID12,
 342:../uvc.c      **** 	0, //UVCCtlID13,
 343:../uvc.c      **** 	0, //&PUCDZoom,
 344:../uvc.c      **** 	0 //UVCCtlID15
 345:../uvc.c      **** };
 346:../uvc.c      **** 
 347:../uvc.c      **** /* the Camera terminal control request */
 348:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 349:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 350:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 351:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 352:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 353:../uvc.c      **** 
 354:../uvc.c      **** /* the Extentsion control request */
 355:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 356:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 357:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 358:../uvc.c      **** 		 2,					//UVCLn: the command length
 359:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 360:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 361:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 362:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 363:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 364:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 365:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 366:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 367:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 368:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 369:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 370:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 371:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 372:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 373:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 374:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 375:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 376:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 377:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 378:../uvc.c      **** 		 2,					//UVCLn: the command length
 379:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 380:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 381:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 382:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 383:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 384:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 385:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 386:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 387:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 388:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 389:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 390:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 391:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 392:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 393:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 394:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 395:../uvc.c      **** */
 396:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 397:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 398:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 399:../uvc.c      **** 		 2,					//UVCLn: the command length
 400:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 401:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 402:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 403:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 404:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 405:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 406:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 407:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 408:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 409:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 410:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 411:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 412:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 413:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 414:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 415:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 416:../uvc.c      **** */
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 418:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 421:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 422:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 423:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 424:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 425:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 426:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 427:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 428:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 429:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 430:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 431:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 432:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 433:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 434:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 435:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 436:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 437:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 438:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 439:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 440:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 441:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 442:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 443:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 444:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 445:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 447:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 448:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 449:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 450:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 451:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 452:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 453:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 454:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 456:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 457:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 458:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 459:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 460:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 461:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 462:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 464:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 465:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 466:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 467:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 468:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 469:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 470:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 471:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 472:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 473:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 474:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 475:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 476:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 477:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 478:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 479:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 480:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 481:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 482:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 483:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 484:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 485:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 486:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 487:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 488:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 489:../uvc.c      **** 		}; //
 490:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 491:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 492:../uvc.c      **** 
 493:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 494:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 495:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 496:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 497:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 498:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 499:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 500:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 501:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 502:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 503:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 504:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 505:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 506:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 507:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 508:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 509:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 510:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 511:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 512:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 513:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 514:../uvc.c      **** 
 515:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 516:../uvc.c      **** 		&EXTShutter,
 517:../uvc.c      **** 		0, //&EXTSensUp,
 518:../uvc.c      **** 		0, //&EXTMirror,
 519:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 520:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 521:../uvc.c      **** 		0, //&EXTDayNightMode,
 522:../uvc.c      **** 		0, //&EXTDayNightdely,
 523:../uvc.c      **** 		0, //&EXTDayNightlev,
 524:../uvc.c      **** 		0, //&EXTNightDaylev,
 525:../uvc.c      **** 		&EXTAexModGainlev,
 526:../uvc.c      **** 		0, //&EXTExpReflev,
 527:../uvc.c      **** 		&EXTShutlev,
 528:../uvc.c      **** 		0, //&EXTCamMode,
 529:../uvc.c      **** 		0, //&EXTSnapshot,
 530:../uvc.c      **** 		0, //&EXTSensorPare,
 531:../uvc.c      **** 		0, //&EXTI2Ccmd,
 532:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 533:../uvc.c      **** 		0, //&Ext1CtlID1,
 534:../uvc.c      **** 		0, //&Ext1CtlID2,
 535:../uvc.c      **** 		0, //&Ext1CtlID3,
 536:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 537:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 538:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 539:../uvc.c      **** 		0
 540:../uvc.c      **** };
 541:../uvc.c      **** 
 542:../uvc.c      **** #endif //end of the new control structure
 543:../uvc.c      **** 
 544:../uvc.c      **** #ifndef CAM720
 545:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 546:../uvc.c      **** #else
 547:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 548:../uvc.c      **** #endif
 549:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 550:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 551:../uvc.c      **** 
 552:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 553:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 554:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 555:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 556:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 557:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 558:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 559:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 560:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 561:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 564:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 565:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 569:../uvc.c      **** };
 570:../uvc.c      **** 
 571:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 572:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 573:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 574:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 575:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 576:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 577:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 578:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 579:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 580:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 581:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 582:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 590:../uvc.c      **** };
 591:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 592:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 593:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 594:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 595:../uvc.c      **** 
 596:../uvc.c      **** static uint8_t debugData[64][2] = {{0,0}};
 597:../uvc.c      **** static uint8_t dbgIdx = 2;
 598:../uvc.c      **** static uint8_t value[32][2] = {{0,0}};
 599:../uvc.c      **** static uint8_t valIdx = 1;
 600:../uvc.c      **** 
 601:../uvc.c      **** /*
 602:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 603:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 604:../uvc.c      ****  */
 605:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 606:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 607:../uvc.c      **** };
 608:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 609:../uvc.c      **** 		0 //bit0:0-read; 1-write. bit1:number of addr. bit2:device addr. bit3:board addr. bit4:DSP addr. 
 610:../uvc.c      **** 			//bit8:number of data. bit9:data0. bit10:data1. ......
 611:../uvc.c      **** };
 612:../uvc.c      **** 
 613:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 614:../uvc.c      **** 
 615:../uvc.c      **** void I2CCmdHandler(){
 616:../uvc.c      **** 	uint8_t buf[2];
 617:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 621:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 622:../uvc.c      **** 	uint8_t i;
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 624:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 625:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 627:../uvc.c      **** 	{
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 630:../uvc.c      **** 			{
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 632:../uvc.c      **** 			}
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 634:../uvc.c      **** 
 635:../uvc.c      **** 	}
 636:../uvc.c      **** 	else if(I2CCMDArry[2]!=0x70){//for get debug data
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 643:../uvc.c      **** 			}
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 647:../uvc.c      **** 			}
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 649:../uvc.c      **** 				CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 651:../uvc.c      **** 
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 653:../uvc.c      **** 				{
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 655:../uvc.c      **** 				}
 656:../uvc.c      **** 
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else {
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 661:../uvc.c      **** 			}
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 663:../uvc.c      **** 			{
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 		I2CCMDArry[11] = 0xff;
 671:../uvc.c      **** 		//CmdType = 0xf;//end the routine
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 676:../uvc.c      **** 			dbgIdx = 2;
 677:../uvc.c      **** 			valIdx = 1;
 678:../uvc.c      **** 			value[0][1] = valIdx;
 679:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 680:../uvc.c      **** 		}
 681:../uvc.c      **** 		CmdType = 0xf;//end the routine
 682:../uvc.c      **** 	}
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 684:../uvc.c      **** 	{
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 686:../uvc.c      **** #if 0 //for debugging
 687:../uvc.c      **** 		/* test still image operation */
 688:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 689:../uvc.c      **** 			snapButFlag = 0; //press
 690:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 691:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 692:../uvc.c      **** 			snapButFlag = 0xf; //release
 693:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 694:../uvc.c      **** 		}
 695:../uvc.c      **** 
 696:../uvc.c      **** 		/* end of the test */
 697:../uvc.c      **** #endif
 698:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 703:../uvc.c      **** 				}
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 705:../uvc.c      **** 		}else{//not support currently
 706:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 707:../uvc.c      **** 		}
 708:../uvc.c      **** 	}else if(CmdType == 1){
 709:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 711:../uvc.c      **** 				for(i = 0; i<4; i++)
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 713:../uvc.c      **** 			}
 714:../uvc.c      **** 			else{
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 719:../uvc.c      **** 				}
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 721:../uvc.c      **** 				//if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 722:../uvc.c      **** 			}
 723:../uvc.c      **** 		}else{//not support currently
 724:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 725:../uvc.c      **** 		}
 726:../uvc.c      **** 
 727:../uvc.c      **** 	}
 728:../uvc.c      **** }
 729:../uvc.c      **** 
 730:../uvc.c      **** /************************************
 731:../uvc.c      ****  * set Iris mode
 732:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 733:../uvc.c      ****  */
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 735:../uvc.c      **** 	uint8_t dataIdx = 0;
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** }
 741:../uvc.c      **** 
 742:../uvc.c      **** 
 743:../uvc.c      **** 
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 745:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 746:../uvc.c      **** 	uint16_t NumLn;
 747:../uvc.c      **** 	uint16_t fRate, shutTm;
 748:../uvc.c      **** 	uint8_t LnVal;
 749:../uvc.c      **** 	switch (Data){
 750:../uvc.c      **** 	case 1:
 751:../uvc.c      **** 	case 2:
 752:../uvc.c      **** 	case 3:
 753:../uvc.c      **** 	case 4:
 754:../uvc.c      **** 	case 5:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 756:../uvc.c      **** 		fRate = 30;
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 758:../uvc.c      **** 		if(NumLn > 1944)
 759:../uvc.c      **** 			NumLn =1944;
 760:../uvc.c      **** 		else if(NumLn < 8)
 761:../uvc.c      **** 			NumLn = 8;
 762:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 763:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 764:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 765:../uvc.c      **** 		break;
 766:../uvc.c      **** 	case 6:
 767:../uvc.c      **** 	case 7:
 768:../uvc.c      **** 	case 8:
 769:../uvc.c      **** 	case 9:
 770:../uvc.c      **** 	case 10:
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 772:../uvc.c      **** 		fRate = 30;
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 774:../uvc.c      **** 		if(NumLn > 1944)
 775:../uvc.c      **** 			NumLn =1944;
 776:../uvc.c      **** 		else if(NumLn < 8)
 777:../uvc.c      **** 			NumLn = 8;
 778:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 781:../uvc.c      **** 		break;
 782:../uvc.c      **** 	case 0: //auto
 783:../uvc.c      **** 	default:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 785:../uvc.c      **** 		LnVal = 1;
 786:../uvc.c      **** 		break;
 787:../uvc.c      **** 	}
 788:../uvc.c      **** 	return LnVal;
 789:../uvc.c      **** }
 790:../uvc.c      **** 
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 792:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 793:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 794:../uvc.c      ****     uint16_t readCount;
 795:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 796:../uvc.c      ****     uint8_t devAdd;
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 803:../uvc.c      ****     }else{
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 808:../uvc.c      ****     }
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 810:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 811:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 812:../uvc.c      **** #endif
 813:../uvc.c      ****     reqData = bRequest;
 814:../uvc.c      ****     /*
 815:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 816:../uvc.c      ****      */
 817:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 818:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 819:../uvc.c      ****     	goto EndofSet;
 820:../uvc.c      ****     }
 821:../uvc.c      ****     switch (bRequest)
 822:../uvc.c      **** 		 {
 823:../uvc.c      **** 
 824:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 828:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 829:../uvc.c      **** 			  break;
 830:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 831:../uvc.c      **** 
 832:../uvc.c      **** 			 switch(CtrlID)
 833:../uvc.c      **** 			 {
 834:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 835:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 839:../uvc.c      **** 			 	 		 }else{
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 844:../uvc.c      **** 			 	 		 }
 845:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 846:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 847:../uvc.c      **** 						 break;
 848:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 849:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 850:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 854:../uvc.c      **** 			 	 		 }else{
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 860:../uvc.c      **** 			 	 		 }
 861:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 862:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 863:../uvc.c      **** 			 	 		 break;
 864:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 865:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 866:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 867:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 868:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 872:../uvc.c      **** 			 	 		 }else{
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 876:../uvc.c      **** 			 	 			else
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 881:../uvc.c      **** 			 	 		 }
 882:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 883:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 884:../uvc.c      **** 			 	 		 break;
 885:../uvc.c      **** 			 	 }
 886:../uvc.c      **** 			 	 case ExtShutCtlID0:
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 890:../uvc.c      **** 
 891:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 892:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 893:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 897:../uvc.c      **** 		 	 		 }else{
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 903:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 905:../uvc.c      **** 
 906:../uvc.c      **** 		 	 		 }
 907:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 910:../uvc.c      **** 			 		 break;
 911:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 915:../uvc.c      **** 
 916:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 917:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 922:../uvc.c      **** 		 	 		 }else{
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 927:../uvc.c      **** 		 	 		 }
 928:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 929:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 930:../uvc.c      **** 			 		 break;
 931:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 933:../uvc.c      **** 
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 935:../uvc.c      **** 						if(sendData >= 3){
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 937:../uvc.c      **** 							sendData = 0; //set back to default
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 939:../uvc.c      **** 						}
 940:../uvc.c      **** 						sendData += 4;
 941:../uvc.c      **** 					 }
 942:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 943:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 944:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 945:../uvc.c      **** 					 break;
 946:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 949:../uvc.c      **** 			 		 }
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 954:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 955:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 956:../uvc.c      **** #endif
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 958:../uvc.c      **** 			 		 {
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 960:../uvc.c      **** 			 		 }
 961:../uvc.c      **** 			 		 break;
 962:../uvc.c      **** 				 case ExtAexModCtlID9:
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 966:../uvc.c      **** 
 967:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 968:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 972:../uvc.c      **** 		 	 		 }else{
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 976:../uvc.c      **** 
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 980:../uvc.c      **** 		 	 		 }
 981:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 982:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 983:../uvc.c      **** 
 984:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 986:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 991:../uvc.c      **** 					 break;
 992:../uvc.c      **** 
 993:../uvc.c      **** 			 	 case BrgtCtlID1:
 994:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 995:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 996:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 997:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 998:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 999:../uvc.c      **** 					 }else{
1000:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1001:../uvc.c      **** 					 }
1002:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
1003:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 */
1006:../uvc.c      **** 
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1009:../uvc.c      **** 		 	 		 }else{
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
1015:../uvc.c      **** 					  if(Data0&0x80){
1016:../uvc.c      **** 						  Data0 = ~Data0;
1017:../uvc.c      **** 					  }else{
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
1019:../uvc.c      **** 					  }
1020:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1021:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1022:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1023:../uvc.c      **** 			 		 break;
1024:../uvc.c      **** 				 case HueCtlID5:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1027:../uvc.c      **** 		 	 		 }else{
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1031:../uvc.c      **** 		 	 		 }
1032:../uvc.c      **** 
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1035:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1036:../uvc.c      **** 					 break;
1037:../uvc.c      **** 				 case WBTLevCtlID11:
1038:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1039:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1040:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1041:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1045:../uvc.c      **** 		 	 		 }else{
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1053:../uvc.c      **** 		 	 		 }
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1056:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1057:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1058:../uvc.c      **** 					 break;
1059:../uvc.c      **** 				 case BLCCtlID0:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1063:../uvc.c      **** 		 	 		 }else{
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1069:../uvc.c      **** 		 	 		 }
1070:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1071:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1072:../uvc.c      **** 					 break;
1073:../uvc.c      **** 				 case ShapCtlID7:
1074:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1075:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1076:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1080:../uvc.c      **** 		 	 		 }else{
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1085:../uvc.c      **** 		 	 		 }
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case ExtExRefCtlID10:
1090:../uvc.c      **** 				 case ConsCtlID2:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1093:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1097:../uvc.c      **** 		 	 		 }else{
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1102:../uvc.c      **** 		 	 		 }
1103:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1104:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1105:../uvc.c      **** 					 break;
1106:../uvc.c      **** 				 case WBTMdCtlID9:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1108:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1111:../uvc.c      **** 		 	 		 }else{
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1116:../uvc.c      **** 
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1118:../uvc.c      **** 		 	 		 }
1119:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1120:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1121:../uvc.c      **** 					 break;
1122:../uvc.c      **** 				 case MFreqCtlID4:
1123:../uvc.c      **** 
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1125:../uvc.c      **** 
1126:../uvc.c      **** 		 	 			 if(is60Hz)
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1128:../uvc.c      **** 		 	 			 else
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1130:../uvc.c      **** 
1131:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1133:../uvc.c      **** 		 	 		 }else{
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1140:../uvc.c      **** 		 	 		 }
1141:../uvc.c      **** 
1142:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1143:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1144:../uvc.c      **** 					 break;
1145:../uvc.c      **** 				 case SaturCtlID6:
1146:../uvc.c      **** 				 default:
1147:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1148:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1152:../uvc.c      **** 		 	 		 }else{
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1157:../uvc.c      **** 		 	 		 }
1158:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1159:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1160:../uvc.c      **** 
1161:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1162:../uvc.c      **** 					 break;
1163:../uvc.c      **** 			 }
1164:../uvc.c      **** 
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 
1167:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1168:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1169:../uvc.c      **** #endif
1170:../uvc.c      **** 			  break;
1171:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1175:../uvc.c      **** 		 	 }
1176:../uvc.c      **** 
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1179:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1180:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1181:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1182:../uvc.c      **** 			 }else
1183:../uvc.c      **** 			 {
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1186:../uvc.c      **** 			 }
1187:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1188:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1189:../uvc.c      **** 			  break;
1190:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1194:../uvc.c      **** 		 	 }
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1197:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1198:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1199:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1200:../uvc.c      **** 			 }else
1201:../uvc.c      **** 			 {
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1204:../uvc.c      **** 			 }
1205:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1206:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1207:../uvc.c      **** 			  break;
1208:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1212:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1213:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1214:../uvc.c      **** 		 	 }
1215:../uvc.c      **** 		 	 else{
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1220:../uvc.c      **** 		 	 }
1221:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1222:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1223:../uvc.c      **** 			  break;
1224:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1227:../uvc.c      **** 		 	 }
1228:../uvc.c      **** 		 	 else{
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1230:../uvc.c      **** 		 	 }
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1232:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1233:../uvc.c      **** 			  Len = 1;
1234:../uvc.c      **** 			  break;
1235:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1239:../uvc.c      **** 		 	 }
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1245:../uvc.c      **** 			 }else{
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1248:../uvc.c      **** 			 }
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1250:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1251:../uvc.c      **** 			  break;
1252:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1254:../uvc.c      **** 				  glEp0Buffer, &readCount);
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1256:../uvc.c      **** 			   {
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1259:../uvc.c      **** 				  getData = glEp0Buffer[0];
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1261:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1262:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1263:../uvc.c      **** #endif
1264:../uvc.c      **** 				  switch(CtrlID)
1265:../uvc.c      **** 					 {
1266:../uvc.c      **** 						 case ExtShutCtlID0:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1271:../uvc.c      **** #if 1	// register setting directly
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1273:../uvc.c      **** 						     {
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1275:../uvc.c      **** 						    	 dataIdx = 0;
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1278:../uvc.c      **** 								 dataIdx++;
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1281:../uvc.c      **** 						     }
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1284:../uvc.c      **** 						     break;
1285:../uvc.c      **** #else	// old fashion
1286:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1287:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1288:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1289:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1290:../uvc.c      **** 									 }else{
1291:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1292:../uvc.c      **** 									 }
1293:../uvc.c      **** 								 }
1294:../uvc.c      **** 							 }else{
1295:../uvc.c      **** 								 Data1 = Data0 - 1;
1296:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1297:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1298:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1299:../uvc.c      **** 									 }else{
1300:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1301:../uvc.c      **** 									 }
1302:../uvc.c      **** 								 }
1303:../uvc.c      **** 								 if(Data1 < 8){
1304:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1305:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1306:../uvc.c      **** 								 }else{
1307:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1308:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1309:../uvc.c      **** 								 }
1310:../uvc.c      **** 							 }
1311:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1312:../uvc.c      **** 							 dataIdx = 0;
1313:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1314:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1315:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1316:../uvc.c      **** 							 if(AxMode){
1317:../uvc.c      **** 								 dataIdx++;
1318:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1319:../uvc.c      **** 								 dataIdx++;
1320:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1321:../uvc.c      **** 							 }
1322:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1323:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1324:../uvc.c      **** 							 break;
1325:../uvc.c      **** #endif
1326:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1330:../uvc.c      **** 						     dataIdx = 0;
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1333:../uvc.c      **** 							 {
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1337:../uvc.c      **** 								 /*
1338:../uvc.c      **** 								 dataIdx++;
1339:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1340:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1341:../uvc.c      **** 									 dataIdx++;
1342:../uvc.c      **** 								 }else{
1343:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1344:../uvc.c      **** 									 dataIdx++;
1345:../uvc.c      **** 								 }
1346:../uvc.c      **** 								 */
1347:../uvc.c      **** 							 }
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1352:../uvc.c      **** 								 }
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 
1360:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1364:../uvc.c      **** 						     dataIdx = 0;
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1366:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1367:../uvc.c      **** 							 {
1368:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1369:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1370:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1371:../uvc.c      **** 								 dataIdx++;
1372:../uvc.c      **** 							 }
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1377:../uvc.c      **** 									 dataIdx++;
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1379:../uvc.c      **** 								 }
1380:../uvc.c      **** 							 }
1381:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1385:../uvc.c      **** 							 break;
1386:../uvc.c      **** 						 case ExtCamMCtlID12:
1387:../uvc.c      **** 							 dataIdx = 0;
1388:../uvc.c      **** 							 if(Data0 <= 3){
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1390:../uvc.c      **** 								 Data1 = Data0;
1391:../uvc.c      **** 							 }else{
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1393:../uvc.c      **** 								 Data1 = Data0-4;
1394:../uvc.c      **** 							 }
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1401:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1402:../uvc.c      **** 							 break;
1403:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1404:../uvc.c      **** 							 dataIdx = 0;
1405:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1406:../uvc.c      **** 								 Data0 = 1;
1407:../uvc.c      **** 							 }else{ //save current sensor parameters.
1408:../uvc.c      **** 								 Data0 = 0;
1409:../uvc.c      **** 							 }
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1414:../uvc.c      **** 							 break;
1415:../uvc.c      **** 						 case ExtI2CCtlID15:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1418:../uvc.c      **** 					 		 }
1419:../uvc.c      **** 					 		I2CCmdHandler();
1420:../uvc.c      **** 							 break;
1421:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1425:../uvc.c      **** 
1426:../uvc.c      **** 							 dataIdx = 0;
1427:../uvc.c      **** #if 0 //seperate version
1428:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1429:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1431:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1432:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1433:../uvc.c      **** 							 }else{ //disable BLD window
1434:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1435:../uvc.c      **** 							 }
1436:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1437:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1438:../uvc.c      **** 							 dataIdx++;
1439:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1440:../uvc.c      **** 							 dataIdx++;
1441:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1442:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1444:../uvc.c      **** 							 dataIdx++;
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1446:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1447:../uvc.c      **** #else //combination version
1448:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1450:../uvc.c      **** 						     /* end test */
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1452:../uvc.c      **** 							 dataIdx++;
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1455:../uvc.c      **** 							 getData1 = Data1;
1456:../uvc.c      **** #endif
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1460:../uvc.c      **** 							 break;
1461:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1465:../uvc.c      **** 
1466:../uvc.c      **** 							 dataIdx = 0;
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1472:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1473:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1474:../uvc.c      **** 							 break;
1475:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1476:../uvc.c      **** 							 dataIdx = 0;
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1478:../uvc.c      **** 							 if(Data0 == 1){
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1480:../uvc.c      **** 							 }else{
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1482:../uvc.c      **** 							 }
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1486:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1488:../uvc.c      **** 							 break;
1489:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1490:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1491:../uvc.c      **** 							 dataIdx = 0;
1492:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1493:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1494:../uvc.c      **** 							  if(Data0&0x80){
1495:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1496:../uvc.c      **** 							  }else{
1497:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1498:../uvc.c      **** 							  }
1499:../uvc.c      **** 							 Data1 |= ~0x03;
1500:../uvc.c      **** 							 Data1 &= 0xC7;
1501:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1502:../uvc.c      **** 						  	 dataIdx++;
1503:../uvc.c      **** 
1504:../uvc.c      **** 							 Data0 = (Data0 << 2);
1505:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1506:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1507:../uvc.c      **** 
1508:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1509:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1510:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1511:../uvc.c      **** #endif
1512:../uvc.c      **** 							 dataIdx = 0;
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1514:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1515:../uvc.c      **** 							  if(Data0&0x80){
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1517:../uvc.c      **** 							  }else{
1518:../uvc.c      **** 								  Data0 = ~Data0;
1519:../uvc.c      **** 							  }
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1522:../uvc.c      **** 
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1525:../uvc.c      **** 
1526:../uvc.c      **** 
1527:../uvc.c      **** 							 break;
1528:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1529:../uvc.c      **** 							 dataIdx = 0;
1530:../uvc.c      **** 
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1533:../uvc.c      **** 							 dataIdx++;
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1535:../uvc.c      **** 							 dataIdx++;
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1537:../uvc.c      **** 							 dataIdx++;
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1539:../uvc.c      **** 							 dataIdx++;
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1541:../uvc.c      **** 							 dataIdx++;
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1544:../uvc.c      **** 
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1547:../uvc.c      **** 							 break;
1548:../uvc.c      **** 						 case SaturCtlID6:
1549:../uvc.c      **** 							 dataIdx = 0;
1550:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1553:../uvc.c      **** 							 dataIdx++;
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1558:../uvc.c      **** 							 break;
1559:../uvc.c      **** 
1560:../uvc.c      **** 						 case WBTLevCtlID11:
1561:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1562:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1563:../uvc.c      **** 							 dataIdx = 0;
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1567:../uvc.c      **** 							 dataIdx++;
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1570:../uvc.c      **** 
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1574:../uvc.c      **** 							 break;
1575:../uvc.c      **** 						 case MFreqCtlID4:
1576:../uvc.c      **** 							 dataIdx = 0;
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
1579:../uvc.c      **** 							 is60Hz = Data0;
1580:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1581:../uvc.c      **** 							 {
1582:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1583:../uvc.c      **** 								 is60Hz = CyFalse;
1584:../uvc.c      **** 							 }
1585:../uvc.c      **** 							 else if(Data0 >2)
1586:../uvc.c      **** 							 {
1587:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1588:../uvc.c      **** 								 is60Hz = CyTrue;
1589:../uvc.c      **** 							 }
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1592:../uvc.c      **** 							 {
1593:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1594:../uvc.c      **** 			                       switch (setRes)
1595:../uvc.c      **** 			                         {
1596:../uvc.c      **** 			                         	case 1: //1944
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1600:../uvc.c      **** 			                         		break;
1601:../uvc.c      **** 			                         	case 2: //1080
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1605:../uvc.c      **** 			                         		break;
1606:../uvc.c      **** 			                         	case 3: //720
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1610:../uvc.c      **** 			                         		break;
1611:../uvc.c      **** 			                         	case 4: //VGA
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1615:../uvc.c      **** 			                         	default:
1616:../uvc.c      **** 			                         		break;
1617:../uvc.c      **** 			                         }
1618:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1619:../uvc.c      **** 							 }
1620:../uvc.c      **** 
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1622:../uvc.c      **** 							 break;
1623:../uvc.c      **** 					 	 case BLCCtlID0:
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1627:../uvc.c      **** 						     dataIdx = 0;
1628:../uvc.c      **** 
1629:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1630:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1635:../uvc.c      **** 							 {
1636:../uvc.c      **** 								 if(Data0 < 3){
1637:../uvc.c      **** 					 				 Data0 += 4;
1638:../uvc.c      **** 					 			 }else{
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1640:../uvc.c      **** 									Data0 = 4; //set to default.
1641:../uvc.c      **** 					 			 }
1642:../uvc.c      **** 					 		 }
1643:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1644:../uvc.c      **** 							 dataIdx = 0;
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1648:../uvc.c      **** 
1649:../uvc.c      **** 					 		 break;
1650:../uvc.c      **** 					 	 case ShapCtlID7:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1654:../uvc.c      **** 						     dataIdx = 0;
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1657:../uvc.c      **** 							 if(Data0 != 0){
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1659:../uvc.c      **** #ifdef COLOR
1660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1661:../uvc.c      **** #else
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1663:../uvc.c      **** 								 dataIdx++;
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1665:../uvc.c      **** #endif
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1667:../uvc.c      **** 							 }else{
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1671:../uvc.c      **** 
1672:../uvc.c      **** 							 }
1673:../uvc.c      **** 							 break;
1674:../uvc.c      **** 						 case ExtExRefCtlID10:
1675:../uvc.c      **** 						 case ConsCtlID2:
1676:../uvc.c      **** 							 dataIdx = 0;
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1680:../uvc.c      **** 
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1683:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1684:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1685:../uvc.c      **** 
1686:../uvc.c      **** 							 break;
1687:../uvc.c      **** 						 default:
1688:../uvc.c      **** 							 dataIdx = 0;
1689:../uvc.c      **** 
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1693:../uvc.c      **** 
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1696:../uvc.c      **** 							 break;
1697:../uvc.c      **** 					 }
1698:../uvc.c      **** 			   }else{
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1700:../uvc.c      **** 			   }
1701:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1702:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1703:../uvc.c      **** #endif
1704:../uvc.c      **** 
1705:../uvc.c      **** 			  break;
1706:../uvc.c      **** 		  default:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1708:../uvc.c      **** 			  break;
1709:../uvc.c      **** 		 }
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1711:../uvc.c      **** }
1712:../uvc.c      **** /************** CT control requests handler *************************/
1713:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1714:../uvc.c      **** 
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1716:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1717:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1718:../uvc.c      ****     uint16_t readCount;
1719:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1720:../uvc.c      ****     uint16_t diff, value, diffRd;
1721:../uvc.c      ****     uint8_t i, shutter, index;
1722:../uvc.c      ****     diff = 0xffff;
1723:../uvc.c      ****     shutter = 1;
1724:../uvc.c      ****     index = 1;
1725:../uvc.c      **** 
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1728:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1730:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1731:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1732:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1733:../uvc.c      **** #endif
1734:../uvc.c      ****     reqData = bRequest;
1735:../uvc.c      **** 
1736:../uvc.c      ****     switch (bRequest)
1737:../uvc.c      **** 		 {
1738:../uvc.c      **** 
1739:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1743:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 			  break;
1745:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1746:../uvc.c      **** 
1747:../uvc.c      **** 			 switch(CtrlID)
1748:../uvc.c      **** 			 {
1749:../uvc.c      **** 				 default:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1754:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1755:../uvc.c      **** 					 break;
1756:../uvc.c      **** 			 }
1757:../uvc.c      **** 
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1759:../uvc.c      **** 
1760:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1761:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1762:../uvc.c      **** #endif
1763:../uvc.c      **** 			  break;
1764:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1768:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1769:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1772:../uvc.c      **** 			  break;
1773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1777:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1778:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1779:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1780:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1781:../uvc.c      **** 			  break;
1782:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1786:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1787:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1788:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1789:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1790:../uvc.c      **** 			  break;
1791:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1794:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1795:../uvc.c      **** 			  Len = 1;
1796:../uvc.c      **** 			  break;
1797:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1804:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1805:../uvc.c      **** 			  break;
1806:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1808:../uvc.c      **** 			  glEp0Buffer, &readCount);
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1811:../uvc.c      **** 			  value = Data1;
1812:../uvc.c      **** 
1813:../uvc.c      **** 			  switch(CtrlID)
1814:../uvc.c      **** 			  {
1815:../uvc.c      **** 		  	      case AutoExMCtlID1:
1816:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1817:../uvc.c      **** 
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1820:../uvc.c      **** 				    getData = glEp0Buffer[0];
1821:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1822:../uvc.c      **** 		  		    switch (getData){
1823:../uvc.c      **** 						case 1:
1824:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1825:../uvc.c      **** 							break;
1826:../uvc.c      **** 						case 2:
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1828:../uvc.c      **** 							dataIdx = 0;
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1832:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1833:../uvc.c      **** 
1834:../uvc.c      **** 							break;
1835:../uvc.c      **** 						case 4:
1836:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1837:../uvc.c      **** 							break;
1838:../uvc.c      **** 						case 8:
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1840:../uvc.c      **** 			  		    	dataIdx = 0;
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1844:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1845:../uvc.c      **** 							break;
1846:../uvc.c      **** 		  		    }
1847:../uvc.c      **** #if 0
1848:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1849:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1850:../uvc.c      **** 						  dataIdx = 0;
1851:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1852:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1853:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1854:../uvc.c      **** 		  		    }
1855:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1856:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1857:../uvc.c      **** 		  		    }
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 				    break;
1860:../uvc.c      **** 
1861:../uvc.c      **** 			  	  case ExTmACtlID3:
1862:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1863:../uvc.c      **** 
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1867:../uvc.c      **** 					  {
1868:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1869:../uvc.c      **** 						  {
1870:../uvc.c      **** 							if(value > ShutValueArry[i]){
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1872:../uvc.c      **** 							}else{
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1874:../uvc.c      **** 							}
1875:../uvc.c      **** 							  if(diff > diffRd){
1876:../uvc.c      **** 								  diff = diffRd;
1877:../uvc.c      **** 								  index = i;
1878:../uvc.c      **** 							  }
1879:../uvc.c      **** 						  }
1880:../uvc.c      **** 						  shutter = shutter+index;
1881:../uvc.c      **** 
1882:../uvc.c      **** 						  dataIdx = 0;
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1886:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1887:../uvc.c      **** 
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1892:../uvc.c      **** 					  }else{
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1894:../uvc.c      **** 					  }
1895:../uvc.c      **** 					  getData = glEp0Buffer[0];
1896:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1897:../uvc.c      **** 					  break;
1898:../uvc.c      **** 			  	  case IriACtlID7:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1900:../uvc.c      **** 					  {
1901:../uvc.c      **** 							 dataIdx = 0;
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1905:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1906:../uvc.c      **** 
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1910:../uvc.c      **** 					  }else{
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1912:../uvc.c      **** 					  }
1913:../uvc.c      **** 					  getData = glEp0Buffer[0];
1914:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1915:../uvc.c      **** 
1916:../uvc.c      **** 					  break;
1917:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1918:../uvc.c      **** 					  getData = glEp0Buffer[0];
1919:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1920:../uvc.c      **** #if 1
1921:../uvc.c      **** 					  dataIdx = 0;
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 					  if(getData == 1)
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1925:../uvc.c      **** 					  else if(getData == 0xff)
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1927:../uvc.c      **** 					  else
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1929:../uvc.c      **** 					  //dataIdx++;
1930:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1932:../uvc.c      **** #endif
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1934:../uvc.c      **** 					  break;
1935:../uvc.c      **** 
1936:../uvc.c      **** 			  	  default:
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1939:../uvc.c      **** 			  		 break;
1940:../uvc.c      **** 			  }
1941:../uvc.c      **** 			  break;
1942:../uvc.c      **** 		  default:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1945:../uvc.c      **** 			  break;
1946:../uvc.c      **** 		 }
1947:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1948:../uvc.c      **** 
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1950:../uvc.c      **** }
1951:../uvc.c      **** 
1952:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1953:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1954:../uvc.c      **** {
1955:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1956:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1957:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1958:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1959:../uvc.c      **** 
1960:../uvc.c      ****     CtrlID = BrgtCtlID1;
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1964:../uvc.c      ****     Data1 = Data0;
1965:../uvc.c      **** 
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      ****     if(Data1&0x80){
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1969:../uvc.c      ****     }else{
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1971:../uvc.c      ****     }
1972:../uvc.c      ****     Data0 = (Data0 << 2);
1973:../uvc.c      **** 
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1975:../uvc.c      **** 
1976:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1981:../uvc.c      **** 
1982:../uvc.c      ****     CtrlID = ConsCtlID2;
1983:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1984:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1990:../uvc.c      **** 
1991:../uvc.c      ****     CtrlID = HueCtlID5;
1992:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2003:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2004:../uvc.c      **** 
2005:../uvc.c      ****     CtrlID = SaturCtlID6;
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2012:../uvc.c      **** 
2013:../uvc.c      ****     CtrlID = ShapCtlID7;
2014:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2015:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2020:../uvc.c      **** 
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2022:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2023:../uvc.c      **** 	return;
2024:../uvc.c      **** }
2025:../uvc.c      **** 
2026:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2027:../uvc.c      **** void
2028:../uvc.c      **** CyFxUVCAddHeader (
2029:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2030:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2031:../uvc.c      ****         )
2032:../uvc.c      **** {
2033:../uvc.c      ****     /* Copy header to buffer */
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2037:../uvc.c      **** 
2038:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2042:../uvc.c      ****     }
2043:../uvc.c      **** }
2044:../uvc.c      **** 
2045:../uvc.c      **** 
2046:../uvc.c      **** /* Application Error Handler */
2047:../uvc.c      **** void
2048:../uvc.c      **** CyFxAppErrorHandler (
2049:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2050:../uvc.c      ****         )
2051:../uvc.c      **** {
2052:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2053:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2054:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2055:../uvc.c      **** 
2056:../uvc.c      ****        This function can be modified to take additional error handling actions such
2057:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2058:../uvc.c      ****      */
2059:../uvc.c      ****     for (;;)
2060:../uvc.c      ****     {
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
2063:../uvc.c      ****     }
2064:../uvc.c      **** }
2065:../uvc.c      **** 
2066:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2067:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2068:../uvc.c      ****  */
2069:../uvc.c      **** static void
2070:../uvc.c      **** CyFxUVCApplnAbortHandler (
2071:../uvc.c      ****         void)
2072:../uvc.c      **** {
2073:../uvc.c      **** 	uint32_t flag;
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2075:../uvc.c      **** 	{
2076:../uvc.c      ****         /* Clear the Video Stream Request Event */
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2078:../uvc.c      **** 
2079:../uvc.c      ****         /* Set Video Stream Abort Event */
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2081:../uvc.c      **** 	}
2082:../uvc.c      **** }
2083:../uvc.c      **** 
2084:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2085:../uvc.c      **** static void
2086:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2087:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2088:../uvc.c      ****         uint16_t             evdata  /* Event data */
2089:../uvc.c      ****         )
2090:../uvc.c      **** {
2091:../uvc.c      ****     switch (evtype)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
2097:../uvc.c      ****             gpif_initialized = 0;
2098:../uvc.c      ****             streamingStarted = CyFalse;
2099:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2100:../uvc.c      ****             break;
2101:../uvc.c      **** 
2102:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
2106:../uvc.c      ****             gpif_initialized = 0;
2107:../uvc.c      ****             streamingStarted = CyFalse;
2108:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2109:../uvc.c      ****             break;
2110:../uvc.c      **** 
2111:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
2115:../uvc.c      ****             gpif_initialized = 0;
2116:../uvc.c      ****             isUsbConnected = CyFalse;
2117:../uvc.c      ****             streamingStarted = CyFalse;
2118:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2119:../uvc.c      ****             break;
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef BACKFLOW_DETECT
2122:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2123:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2124:../uvc.c      ****             break;
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      ****         default:
2128:../uvc.c      ****             break;
2129:../uvc.c      ****     }
2130:../uvc.c      **** }
2131:../uvc.c      **** 
2132:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2133:../uvc.c      **** static CyBool_t
2134:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2135:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2136:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2137:../uvc.c      ****         )
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2140:../uvc.c      ****     uint32_t status;
2141:../uvc.c      ****     //CyU3PDebugPrint (4, "The USB setup Requests and UVC events 0x%x, 0x%x\r\n", setupdat0, setupd
2142:../uvc.c      ****     /* Obtain Request Type and Request */
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
2149:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
2150:../uvc.c      ****     if(dbgIdx < 63){
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
2154:../uvc.c      **** 		dbgIdx++;
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Check for UVC Class Requests */
2159:../uvc.c      ****     switch (bmReqType)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2162:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2163:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2164:../uvc.c      ****             switch (wIndex & 0xFF)
2165:../uvc.c      ****             {
2166:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2167:../uvc.c      ****                     {
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2170:../uvc.c      ****                                 CYU3P_EVENT_OR);
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2172:../uvc.c      ****                         {
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2175:../uvc.c      ****                         }
2176:../uvc.c      ****                     }
2177:../uvc.c      ****                     break;
2178:../uvc.c      **** 
2179:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2180:../uvc.c      ****                     {
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2183:../uvc.c      ****                                 CYU3P_EVENT_OR);
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2185:../uvc.c      ****                         {
2186:../uvc.c      ****                             /* Error handling */
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2189:../uvc.c      ****                         }
2190:../uvc.c      ****                     }
2191:../uvc.c      ****                     break;
2192:../uvc.c      **** 
2193:../uvc.c      ****                 default:
2194:../uvc.c      ****                     break;
2195:../uvc.c      ****             }
2196:../uvc.c      ****             break;
2197:../uvc.c      **** 
2198:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2200:../uvc.c      ****             {
2201:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2202:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2204:../uvc.c      ****                 {
2205:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2208:../uvc.c      ****                     gpif_initialized = 0;
2209:../uvc.c      ****                     streamingStarted = CyFalse;
2210:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2212:../uvc.c      ****                     CyU3PBusyWait (100);
2213:../uvc.c      **** 
2214:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2218:../uvc.c      ****                     CyU3PBusyWait (100);
2219:../uvc.c      **** 
2220:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
2223:../uvc.c      ****                     /* Complete Control request handshake */
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
2225:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2228:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2229:../uvc.c      **** 
2230:../uvc.c      ****                 }
2231:../uvc.c      ****             }
2232:../uvc.c      ****             break;
2233:../uvc.c      **** 
2234:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2236:../uvc.c      ****             {
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2238:../uvc.c      ****                 {
2239:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2240:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2241:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2242:../uvc.c      ****                 	 * has started. */
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
2244:../uvc.c      ****                     {
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2246:../uvc.c      **** 
2247:../uvc.c      ****                         /* Disable the GPIF state machine. */
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2249:../uvc.c      ****                         gpif_initialized = 0;
2250:../uvc.c      ****                         streamingStarted = CyFalse;
2251:../uvc.c      **** 
2252:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2254:../uvc.c      ****                         CyU3PBusyWait (100);
2255:../uvc.c      **** 
2256:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2260:../uvc.c      ****                         CyU3PBusyWait (100);
2261:../uvc.c      **** 
2262:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2264:../uvc.c      **** 
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
2266:../uvc.c      ****                         /* Complete Control request handshake */
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
2268:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
2271:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2272:../uvc.c      ****                     }
2273:../uvc.c      ****                     else
2274:../uvc.c      ****                     {
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
2277:../uvc.c      ****                     }
2278:../uvc.c      ****                 }
2279:../uvc.c      ****             }
2280:../uvc.c      ****             break;
2281:../uvc.c      **** 
2282:../uvc.c      ****         default:
2283:../uvc.c      ****             break;
2284:../uvc.c      ****     }
2285:../uvc.c      **** 
2286:../uvc.c      ****     /* Return status of request handling to the USB driver */
2287:../uvc.c      ****     return uvcHandleReq;
2288:../uvc.c      **** }
2289:../uvc.c      **** 
2290:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2291:../uvc.c      **** 
2292:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2293:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2294:../uvc.c      ****  */
2295:../uvc.c      **** void
2296:../uvc.c      **** CyFxUvcApplnDmaCallback (
2297:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2298:../uvc.c      ****         CyU3PDmaCbType_t      type,
2299:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2300:../uvc.c      ****         )
2301:../uvc.c      **** {
2302:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2303:../uvc.c      **** #if 1
2304:../uvc.c      ****     CyU3PReturnStatus_t status;
2305:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2306:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2307:../uvc.c      **** 
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2309:../uvc.c      ****     {
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2311:../uvc.c      ****             {
2312:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2313:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2314:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2315:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2316:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2317:../uvc.c      ****                 	stiflag = 0x03;
2318:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2319:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2320:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2321:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2322:../uvc.c      ****                 }
2323:../uvc.c      **** #endif
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2325:../uvc.c      ****                 fb++;
2326:../uvc.c      ****             }
2327:../uvc.c      ****             else
2328:../uvc.c      ****             {
2329:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2331:../uvc.c      ****                 pb++;
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
2333:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2334:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2335:../uvc.c      ****                 //lineCount = 0; //res test
2336:../uvc.c      **** #if 1   //remove the still flag clearing here
2337:../uvc.c      ****                 if(stiflag == 0x0F){
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2341:../uvc.c      ****                 	stiflag = 0xAA;
2342:../uvc.c      ****                 }
2343:../uvc.c      **** #endif
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2345:../uvc.c      ****             }
2346:../uvc.c      **** 
2347:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2348:../uvc.c      ****             prodCount++;
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2350:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2351:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2353:../uvc.c      ****             {
2354:../uvc.c      ****                 prodCount--;
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2356:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2357:../uvc.c      ****             }
2358:../uvc.c      ****     }
2359:../uvc.c      **** #endif
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         consCount++;
2363:../uvc.c      ****         streamingStarted = CyTrue;
2364:../uvc.c      ****     }
2365:../uvc.c      **** }
2366:../uvc.c      **** 
2367:../uvc.c      **** /*
2368:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2369:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2370:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2371:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2372:../uvc.c      ****  * to commit the buffer.
2373:../uvc.c      ****  */
2374:../uvc.c      **** static uint8_t
2375:../uvc.c      **** CyFxUvcAppCommitEOF (
2376:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2377:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2378:../uvc.c      ****         )
2379:../uvc.c      **** {
2380:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2381:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2384:../uvc.c      **** 
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2386:../uvc.c      ****     {
2387:../uvc.c      ****         switch (stateId)
2388:../uvc.c      ****         {
2389:../uvc.c      **** 
2390:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2391:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2392:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2393:../uvc.c      ****                 break;
2394:../uvc.c      **** 
2395:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2396:../uvc.c      ****                 socket = 0;
2397:../uvc.c      ****                 break;
2398:../uvc.c      **** 
2399:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2400:../uvc.c      ****                 socket = 1;
2401:../uvc.c      ****                 break;
2402:../uvc.c      **** 
2403:../uvc.c      ****             default:
2404:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2405:../uvc.c      ****                 /* Unexpected current state. Return error. */
2406:../uvc.c      ****             	//lineCount++;
2407:../uvc.c      ****             	return 1;
2408:../uvc.c      ****         }
2409:../uvc.c      ****     }
2410:../uvc.c      **** 
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2412:../uvc.c      ****     {
2413:../uvc.c      ****         switch (stateId)
2414:../uvc.c      ****         {
2415:../uvc.c      **** #ifndef CAM720
2416:../uvc.c      **** #ifdef GPIFIIM
2417:../uvc.c      ****             case 13:
2418:../uvc.c      ****             case 24:
2419:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2420:../uvc.c      ****                 break;
2421:../uvc.c      **** 
2422:../uvc.c      ****             case 8:
2423:../uvc.c      ****                 socket = 0;
2424:../uvc.c      ****                 break;
2425:../uvc.c      **** 
2426:../uvc.c      ****             case 20:
2427:../uvc.c      ****                 socket = 1;
2428:../uvc.c      ****                 break;
2429:../uvc.c      **** #else
2430:../uvc.c      ****             case 11:
2431:../uvc.c      ****             case 18:
2432:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2433:../uvc.c      ****                 break;
2434:../uvc.c      **** 
2435:../uvc.c      ****             case 8:
2436:../uvc.c      ****                 socket = 0;
2437:../uvc.c      ****                 break;
2438:../uvc.c      **** 
2439:../uvc.c      ****             case 15:
2440:../uvc.c      ****                 socket = 1;
2441:../uvc.c      ****                 break;
2442:../uvc.c      **** #endif
2443:../uvc.c      **** #else
2444:../uvc.c      ****             case 11:
2445:../uvc.c      ****             case 18:
2446:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2447:../uvc.c      ****                 break;
2448:../uvc.c      **** 
2449:../uvc.c      ****             case 8:
2450:../uvc.c      ****                 socket = 0;
2451:../uvc.c      ****                 break;
2452:../uvc.c      **** 
2453:../uvc.c      ****             case 15:
2454:../uvc.c      ****                 socket = 1;
2455:../uvc.c      ****                 break;
2456:../uvc.c      **** 
2457:../uvc.c      **** #endif
2458:../uvc.c      ****              default:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2460:../uvc.c      ****                 /* Unexpected current state. Return error. */
2461:../uvc.c      ****                return 1;
2462:../uvc.c      ****         }
2463:../uvc.c      ****     }
2464:../uvc.c      **** 
2465:../uvc.c      ****     if (socket != 0xFF)
2466:../uvc.c      ****     {
2467:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2468:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2469:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2472:../uvc.c      ****         {
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2474:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2475:../uvc.c      ****         }
2476:../uvc.c      ****     }
2477:../uvc.c      **** 
2478:../uvc.c      ****     return 0;
2479:../uvc.c      **** }
2480:../uvc.c      **** 
2481:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2482:../uvc.c      **** void
2483:../uvc.c      **** CyFxGpifCB (
2484:../uvc.c      ****         CyU3PGpifEventType event,
2485:../uvc.c      ****         uint8_t currentState
2486:../uvc.c      ****         )
2487:../uvc.c      **** {
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2489:../uvc.c      ****     {
2490:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2491:../uvc.c      ****     	           in the UVC implementation. */
2492:../uvc.c      ****     	//hitFV = CyTrue;
2493:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2495:../uvc.c      ****     }
2496:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2497:../uvc.c      **** }
2498:../uvc.c      **** 
2499:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2500:../uvc.c      **** static void
2501:../uvc.c      **** CyFxUVCApplnDebugInit (
2502:../uvc.c      ****         void)
2503:../uvc.c      **** {
2504:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2505:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2506:../uvc.c      **** 
2507:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2510:../uvc.c      ****     {
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****     }
2514:../uvc.c      **** 
2515:../uvc.c      ****     /* Set UART Configuration */
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2523:../uvc.c      **** 
2524:../uvc.c      ****     /* Set the UART configuration */
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2527:../uvc.c      ****     {
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2529:../uvc.c      ****     }
2530:../uvc.c      **** 
2531:../uvc.c      ****     /* Set the UART transfer */
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2534:../uvc.c      ****     {
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2536:../uvc.c      ****     }
2537:../uvc.c      **** 
2538:../uvc.c      ****     /* Initialize the Debug logger module. */
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      ****     /* Disable log message headers. */
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2547:../uvc.c      **** }
2548:../uvc.c      **** 
2549:../uvc.c      **** /* I2C initialization. */
2550:../uvc.c      **** static void
2551:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2552:../uvc.c      **** {
2553:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2554:../uvc.c      ****     CyU3PReturnStatus_t status;
2555:../uvc.c      **** 
2556:../uvc.c      ****     status = CyU3PI2cInit ();
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2558:../uvc.c      ****     {
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
2561:../uvc.c      ****     }
2562:../uvc.c      **** 
2563:../uvc.c      ****     /*  Set I2C Configuration */
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2568:../uvc.c      **** 
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2571:../uvc.c      ****     {
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
2574:../uvc.c      ****     }
2575:../uvc.c      **** }
2576:../uvc.c      **** 
2577:../uvc.c      **** #ifdef BACKFLOW_DETECT
2578:../uvc.c      **** static void CyFxUvcAppPibCallback (
2579:../uvc.c      ****         CyU3PPibIntrType cbType,
2580:../uvc.c      ****         uint16_t cbArg)
2581:../uvc.c      **** {
2582:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2583:../uvc.c      ****     {
2584:../uvc.c      ****         if (!back_flow_detected)
2585:../uvc.c      ****         {
2586:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2587:../uvc.c      ****             back_flow_detected = 1;
2588:../uvc.c      ****         }
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** #endif
2592:../uvc.c      **** 
2593:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2594:../uvc.c      **** static void
2595:../uvc.c      **** CyFxUvcAppDebugCallback (
2596:../uvc.c      ****         CyU3PDmaChannel   *handle,
2597:../uvc.c      ****         CyU3PDmaCbType_t   type,
2598:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2599:../uvc.c      **** {
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2604:../uvc.c      ****     }
2605:../uvc.c      **** }
2606:../uvc.c      **** #endif
2607:../uvc.c      **** 
2608:../uvc.c      **** #if 0
2609:../uvc.c      **** static void CyFxAppIntEpCb(
2610:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2611:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2612:../uvc.c      **** 		uint8_t  ebNum)
2613:../uvc.c      **** 		{
2614:../uvc.c      **** 			//CyBool_t value;
2615:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2616:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2617:../uvc.c      **** 
2618:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2619:../uvc.c      **** 		}
2620:../uvc.c      **** #endif
2621:../uvc.c      **** 
2622:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2623:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2624:../uvc.c      ****    configures the DMA module for the UVC Application */
2625:../uvc.c      **** static void
2626:../uvc.c      **** CyFxUVCApplnInit (void)
2627:../uvc.c      **** {
2628:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2629:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2630:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2631:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2632:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2633:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2634:../uvc.c      **** 
2635:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2636:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2637:../uvc.c      **** 
2638:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2639:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2640:../uvc.c      **** #endif
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Create UVC event group */
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2644:../uvc.c      ****     if (apiRetStatus != 0)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2651:../uvc.c      ****     CyFxUvcAppPTZInit ();
2652:../uvc.c      **** #endif
2653:../uvc.c      **** 
2654:../uvc.c      ****     isUsbConnected = CyFalse;
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2656:../uvc.c      **** 
2657:../uvc.c      ****     /* Init the GPIO module */
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize Gpio interface */
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2666:../uvc.c      ****     if (apiRetStatus != 0)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2669:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2670:../uvc.c      ****     }
2671:../uvc.c      **** 
2672:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2673:../uvc.c      ****      * must use GpioOverride to configure it */
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2675:../uvc.c      ****     if (apiRetStatus != 0)
2676:../uvc.c      ****     {
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2679:../uvc.c      ****     }
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2681:../uvc.c      ****     if (apiRetStatus != 0)
2682:../uvc.c      ****     {
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2684:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2685:../uvc.c      ****     }
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2687:../uvc.c      ****     if (apiRetStatus != 0)
2688:../uvc.c      ****     {
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2691:../uvc.c      ****     }
2692:../uvc.c      **** 
2693:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2701:../uvc.c      ****     {
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2703:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2704:../uvc.c      ****     }
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2707:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2715:../uvc.c      ****     {
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2717:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2718:../uvc.c      ****     }
2719:../uvc.c      **** 
2720:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2721:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2729:../uvc.c      ****     {
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2732:../uvc.c      ****     }
2733:../uvc.c      **** 
2734:../uvc.c      ****     /* Initialize the P-port. */
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2739:../uvc.c      **** 
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2742:../uvc.c      ****     {
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2744:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2745:../uvc.c      ****     }
2746:../uvc.c      **** 
2747:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2749:../uvc.c      **** 
2750:../uvc.c      **** #ifdef BACKFLOW_DETECT
2751:../uvc.c      ****     back_flow_detected = 0;
2752:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2753:../uvc.c      **** #endif
2754:../uvc.c      **** 
2755:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2756:../uvc.c      ****     SensorReset ();
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
2758:../uvc.c      ****     //SensorInit ();
2759:../uvc.c      **** 
2760:../uvc.c      ****     /* USB initialization. */
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2763:../uvc.c      ****     {
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2765:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2766:../uvc.c      ****     }
2767:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2769:../uvc.c      **** 
2770:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2772:../uvc.c      **** 
2773:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2774:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2775:../uvc.c      **** 
2776:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2779:../uvc.c      **** 
2780:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* Configuration descriptors. */
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2788:../uvc.c      **** 
2789:../uvc.c      ****     /* String Descriptors */
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2793:../uvc.c      **** 
2794:../uvc.c      ****     /* Configure the status interrupt endpoint.
2795:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2796:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2797:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2798:../uvc.c      ****      */
2799:../uvc.c      ****     endPointConfig.enable   = 1;
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2803:../uvc.c      ****     endPointConfig.streams  = 0;
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2807:../uvc.c      ****     {
2808:../uvc.c      ****         /* Error Handling */
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2811:../uvc.c      ****     }
2812:../uvc.c      **** 
2813:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2826:../uvc.c      ****             &dmaInterConfig);
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2828:../uvc.c      ****     {
2829:../uvc.c      ****         /* Error handling */
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2832:../uvc.c      ****     }
2833:../uvc.c      **** 
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
2836:../uvc.c      ****     {
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2838:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2857:../uvc.c      ****             &dmaMultiConfig);
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2859:../uvc.c      ****     {
2860:../uvc.c      ****         /* Error handling */
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2863:../uvc.c      ****     }
2864:../uvc.c      **** 
2865:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2866:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2867:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2868:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2869:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2870:../uvc.c      ****      */
2871:../uvc.c      **** 
2872:../uvc.c      ****     endPointConfig.enable   = 1;
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2876:../uvc.c      ****     endPointConfig.streams  = 0;
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
2878:../uvc.c      **** 
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2887:../uvc.c      **** 
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2890:../uvc.c      ****     {
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2892:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2893:../uvc.c      ****     }
2894:../uvc.c      **** 
2895:../uvc.c      ****     channelConfig.size           = 1024;
2896:../uvc.c      ****     channelConfig.count          = 1;
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2906:../uvc.c      **** 
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2909:../uvc.c      ****     {
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2911:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2912:../uvc.c      ****     }
2913:../uvc.c      **** 
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2916:../uvc.c      ****     {
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2918:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2919:../uvc.c      ****     }
2920:../uvc.c      **** 
2921:../uvc.c      ****     channelConfig.size           = 1024;
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2930:../uvc.c      ****     channelConfig.notification   = 0;
2931:../uvc.c      ****     channelConfig.cb             = 0;
2932:../uvc.c      **** 
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2935:../uvc.c      ****     {
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2938:../uvc.c      ****     }
2939:../uvc.c      **** 
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
2942:../uvc.c      ****     {
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2944:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2945:../uvc.c      ****     }
2946:../uvc.c      **** #endif
2947:../uvc.c      **** 
2948:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2951:../uvc.c      ****     {
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2953:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2954:../uvc.c      ****     }
2955:../uvc.c      **** 
2956:../uvc.c      ****     CyU3PBusyWait(100);
2957:../uvc.c      **** 
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2959:../uvc.c      **** 
2960:../uvc.c      ****     endPointConfig.enable   = 1;
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2963:../uvc.c      ****     {
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
2966:../uvc.c      ****     }
2967:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2968:../uvc.c      ****     {
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
2971:../uvc.c      ****     }
2972:../uvc.c      ****     endPointConfig.streams  = 0;
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2975:../uvc.c      ****     {
2976:../uvc.c      ****         /* Error Handling */
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2979:../uvc.c      ****     }
2980:../uvc.c      **** #if 0    //for still image method 3 using
2981:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2982:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2983:../uvc.c      ****     {
2984:../uvc.c      ****         /* Error Handling */
2985:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2986:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2987:../uvc.c      ****     }
2988:../uvc.c      **** #endif
2989:../uvc.c      **** 
2990:../uvc.c      **** }
2991:../uvc.c      **** 
2992:../uvc.c      **** /*
2993:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2994:../uvc.c      ****  * streaming session is started.
2995:../uvc.c      ****  */
2996:../uvc.c      **** static void
2997:../uvc.c      **** CyFxUvcAppGpifInit (
2998:../uvc.c      ****         void)
2999:../uvc.c      **** {
3000:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3001:../uvc.c      **** 
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3003:../uvc.c      ****     {
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3006:../uvc.c      ****     }
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3008:../uvc.c      ****     {
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3011:../uvc.c      ****     }
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3013:../uvc.c      ****     {
3014:../uvc.c      ****         /* Error Handling */
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3017:../uvc.c      ****     }
3018:../uvc.c      **** 
3019:../uvc.c      ****     /* Start the state machine from the designated start state. */
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3021:../uvc.c      ****     {
3022:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3023:../uvc.c      ****     }
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3025:../uvc.c      ****     {
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3027:../uvc.c      ****     }
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3029:../uvc.c      ****     {
3030:../uvc.c      ****         /* Error Handling */
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3032:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3033:../uvc.c      ****     }
3034:../uvc.c      **** }
3035:../uvc.c      **** 
3036:../uvc.c      **** /*
3037:../uvc.c      ****  * Entry function for the UVC Application Thread
3038:../uvc.c      ****  */
3039:../uvc.c      **** 
3040:../uvc.c      **** uint32_t posTick;
3041:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3042:../uvc.c      **** 
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
3046:../uvc.c      **** }
3047:../uvc.c      **** 
3048:../uvc.c      **** 
3049:../uvc.c      **** void
3050:../uvc.c      **** UVCAppThread_Entry (
3051:../uvc.c      ****         uint32_t input)
3052:../uvc.c      **** {
3053:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3054:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3055:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3056:../uvc.c      ****     uint8_t i = 0;
3057:../uvc.c      ****     uint32_t flag;
3058:../uvc.c      ****     uint32_t prinflag = 0;
3059:../uvc.c      **** static uint8_t IMcount = 0;
3060:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3061:../uvc.c      ****     uint32_t frameCnt = 0;
3062:../uvc.c      **** #endif
3063:../uvc.c      ****     /* Initialize the Uart Debug Module */
3064:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3065:../uvc.c      **** 
3066:../uvc.c      ****     /* Initialize the I2C interface */
3067:../uvc.c      **** 	while (i++ < 6){
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
3069:../uvc.c      **** 	}
3070:../uvc.c      **** 
3071:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3072:../uvc.c      **** 
3073:../uvc.c      ****     /* Initialize the UVC Application */
3074:../uvc.c      ****     CyFxUVCApplnInit ();
3075:../uvc.c      ****     /*
3076:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3077:../uvc.c      **** 
3078:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3079:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3080:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3081:../uvc.c      **** 
3082:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3083:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3084:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3085:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3086:../uvc.c      **** 
3087:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3088:../uvc.c      ****        of handling the abort request.
3089:../uvc.c      ****      */
3090:../uvc.c      **** 
3091:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3092:../uvc.c      ****     //CyU3PThreadSleep(1000);
3093:../uvc.c      **** 
3094:../uvc.c      ****     for (;;)
3095:../uvc.c      ****     {
3096:../uvc.c      ****         /* Waiting for the Video Stream Event */
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3098:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3099:../uvc.c      ****         {
3100:../uvc.c      ****         	debugData[0][1] = debugData[0][1]&0xFF;
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
3102:../uvc.c      ****         	//CyU3PDebugPrint (4, "stream ready %x\n", apiRetStatus);
3103:../uvc.c      **** #if 0 //test for new firmware no video bring up
3104:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3105:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3106:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3107:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3108:../uvc.c      ****             {
3109:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3110:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3111:../uvc.c      ****                 {
3112:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3113:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3114:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3115:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3116:../uvc.c      **** #endif
3117:../uvc.c      **** #endif
3118:../uvc.c      ****                     }
3119:../uvc.c      ****                 else
3120:../uvc.c      ****                 {
3121:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3122:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3123:../uvc.c      **** #ifdef USB_LOWRES_IMG
3124:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3125:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3126:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3127:../uvc.c      **** #endif
3128:../uvc.c      **** #endif
3129:../uvc.c      ****                 }
3130:../uvc.c      **** 
3131:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3132:../uvc.c      ****                 prodCount++;
3133:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3134:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3135:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3136:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3137:../uvc.c      ****                 {
3138:../uvc.c      ****                     prodCount--;
3139:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3140:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3141:../uvc.c      ****                 }
3142:../uvc.c      ****             }
3143:../uvc.c      **** #endif
3144:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3145:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3147:../uvc.c      ****             {
3148:../uvc.c      ****             	if(0&&(prinflag == 0)){
3149:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3150:../uvc.c      ****             		prinflag = 1;
3151:../uvc.c      ****             	}
3152:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3153:../uvc.c      ****             	debugData[0][0]++;
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
3155:../uvc.c      ****             	fb=0;
3156:../uvc.c      ****             	pb=0;
3157:../uvc.c      ****             	pbc=0;
3158:../uvc.c      ****                 prodCount = 0;
3159:../uvc.c      ****                 consCount = 0;
3160:../uvc.c      ****                 hitFV     = CyFalse;
3161:../uvc.c      **** 
3162:../uvc.c      **** #ifdef BACKFLOW_DETECT
3163:../uvc.c      ****                 back_flow_detected = 0;
3164:../uvc.c      **** #endif
3165:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3166:../uvc.c      ****                 frameCnt++;
3167:../uvc.c      **** #endif
3168:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3169:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3170:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3171:../uvc.c      ****                 //}
3172:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3174:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3175:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3177:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3178:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3179:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3180:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3181:../uvc.c      ****                 		stiflag = 0xFF;
3182:../uvc.c      ****                 		IMcount = 0;
3183:../uvc.c      ****                 	}
3184:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3185:../uvc.c      **** 
3186:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3188:../uvc.c      ****                 		stiflag = 0x0F;
3189:../uvc.c      ****                 		IMcount = 0;
3190:../uvc.c      ****                 		}
3191:../uvc.c      ****                  		/*if(IMcount > 0x4){
3192:../uvc.c      ****                 			stiflag = 0x0F;
3193:../uvc.c      ****                 			IMcount = 0;
3194:../uvc.c      ****                 		}*/
3195:../uvc.c      **** 
3196:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3197:../uvc.c      ****                     //CyU3PThreadSleep(400);
3198:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3199:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3200:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3201:../uvc.c      **** 
3202:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3203:../uvc.c      ****                 	{
3204:../uvc.c      ****                     switch (setRes)
3205:../uvc.c      ****                      {
3206:../uvc.c      ****                  	case 1: //1944
3207:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3208:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3209:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3210:../uvc.c      ****                  		break;
3211:../uvc.c      ****                  	case 2: //1080
3212:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3213:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3214:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3215:../uvc.c      ****                  		break;
3216:../uvc.c      ****                  	case 3: //720
3217:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3218:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3219:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3220:../uvc.c      ****                  		break;
3221:../uvc.c      ****                  	case 4: //VGA
3222:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3223:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3224:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3225:../uvc.c      ****                  		break;
3226:../uvc.c      ****                  	default:
3227:../uvc.c      ****                  		break;
3228:../uvc.c      ****                      }
3229:../uvc.c      ****                     IMcount = 0;
3230:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3231:../uvc.c      ****                 	stiflag = 0x0;
3232:../uvc.c      ****                 	}
3233:../uvc.c      ****                 }
3234:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3235:../uvc.c      ****                 /* Reset the DMA channel. */
3236:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3237:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3238:../uvc.c      ****                 {
3239:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3240:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3241:../uvc.c      ****                 }
3242:../uvc.c      **** 
3243:../uvc.c      ****                 /* Start Channel Immediately */
3244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3245:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3246:../uvc.c      ****                 {
3247:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3248:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3249:../uvc.c      ****                 }
3250:../uvc.c      **** 
3251:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3252:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3253:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3254:../uvc.c      ****                 }
3255:../uvc.c      ****         }
3256:../uvc.c      ****         else
3257:../uvc.c      ****         {
3258:../uvc.c      ****             /* If we have a stream abort request pending. */
3259:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3260:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3261:../uvc.c      ****             {
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
3264:../uvc.c      ****             	hitFV     = CyFalse;
3265:../uvc.c      ****                 prodCount = 0;
3266:../uvc.c      ****                 consCount = 0;
3267:../uvc.c      ****                 if(0&&(prinflag == 0)){
3268:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3269:../uvc.c      ****                 	prinflag = 1;
3270:../uvc.c      ****                 }
3271:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3272:../uvc.c      ****                 fb=0;
3273:../uvc.c      ****                 pb=0;
3274:../uvc.c      ****                 pbc=0;
3275:../uvc.c      **** 
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3277:../uvc.c      ****                 {
3278:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3279:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3280:../uvc.c      ****                     {
3281:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3282:../uvc.c      ****                     }
3283:../uvc.c      **** 
3284:../uvc.c      ****                     /* Flush the Endpoint memory */
3285:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3286:../uvc.c      ****                 }else{
3287:../uvc.c      ****                     apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT
3288:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]&0x7F;
3289:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]|0x10;
3290:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3291:../uvc.c      ****                     {
3292:../uvc.c      ****                         CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus)
3293:../uvc.c      ****                     }
3294:../uvc.c      ****                     CyU3PDebugPrint (4, "clear feature stream set %x\n", apiRetStatus);
3295:../uvc.c      ****                 }
3296:../uvc.c      **** 
3297:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3298:../uvc.c      ****             }
3299:../uvc.c      ****             else
3300:../uvc.c      ****             {
3301:../uvc.c      **** #if 0
3302:../uvc.c      ****                 if(stream_start == CyTrue){
3303:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
3304:../uvc.c      ****                     		&flag, CYU3P_NO_WAIT != CY_U3P_SUCCESS)){
3305:../uvc.c      ****     					if(1||clearFeatureRqtReceived){
3306:../uvc.c      ****     						CyU3PThreadSleep(3000);
3307:../uvc.c      ****     						//if(stream_start == CyTrue){
3308:../uvc.c      ****     							streamingRecove = CyTrue;
3309:../uvc.c      ****     							debugData[1][1]++;
3310:../uvc.c      ****     						//}
3311:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
3312:../uvc.c      ****     						stream_start == CyFalse;
3313:../uvc.c      ****     					}
3314:../uvc.c      ****                     }
3315:../uvc.c      **** 
3316:../uvc.c      ****                 }
3317:../uvc.c      **** #endif
3318:../uvc.c      **** 
3319:../uvc.c      ****             	/* We are essentially idle at this point. Wait for the reception of a start streaming 
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
3323:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
3324:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
3325:../uvc.c      ****                     		CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
3326:../uvc.c      ****             	}
3327:../uvc.c      ****             	else
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
3329:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3330:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3331:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3332:../uvc.c      ****             	CyU3PDebugPrint (4, "post wait stream set %x\n", apiRetStatus);
3333:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3334:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3335:../uvc.c      ****                 {
3336:../uvc.c      ****                     /* Error handling */
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3338:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3339:../uvc.c      ****                 }
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
3342:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3344:../uvc.c      ****                 {
3345:../uvc.c      **** #if 0
3346:../uvc.c      ****                 	//for start up of the AF Lens
3347:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3348:../uvc.c      ****                     CyU3PThreadSleep(500);
3349:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3350:../uvc.c      ****                     CyU3PThreadSleep(500);
3351:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3352:../uvc.c      ****                    	CyU3PThreadSleep(300);
3353:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3354:../uvc.c      ****                     CyU3PThreadSleep(500);
3355:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3356:../uvc.c      ****                     CyU3PThreadSleep(500);
3357:../uvc.c      **** #endif
3358:../uvc.c      **** #if 0
3359:../uvc.c      ****                     if(streamingRecove){
3360:../uvc.c      ****                     switch (setRes)
3361:../uvc.c      ****                     {
3362:../uvc.c      ****                      	case 1: //1944
3363:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
3364:../uvc.c      ****                      		CyU3PThreadSleep(100);
3365:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
3366:../uvc.c      ****                      		break;
3367:../uvc.c      ****                      	case 2: //1080
3368:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
3369:../uvc.c      ****                      		CyU3PThreadSleep(100);
3370:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
3371:../uvc.c      ****                      		break;
3372:../uvc.c      ****                      	case 3: //720
3373:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
3374:../uvc.c      ****                      		CyU3PThreadSleep(100);
3375:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
3376:../uvc.c      ****                      		break;
3377:../uvc.c      ****                      	case 4: //VGA
3378:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
3379:../uvc.c      ****                      		CyU3PThreadSleep(100);
3380:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
3381:../uvc.c      ****                      		break;
3382:../uvc.c      ****                      	default:
3383:../uvc.c      ****                      		break;
3384:../uvc.c      **** 
3385:../uvc.c      ****                     }
3386:../uvc.c      ****                     streamingRecove = CyFalse;
3387:../uvc.c      ****                     }
3388:../uvc.c      **** #endif
3389:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3390:../uvc.c      **** 
3391:../uvc.c      ****                     gpif_initialized = CyTrue;
3392:../uvc.c      ****                     //stream_start = CyTrue;
3393:../uvc.c      ****                     CyU3PThreadSleep(200);
3394:../uvc.c      ****                     
3395:../uvc.c      ****                 }
3396:../uvc.c      ****                 else
3397:../uvc.c      ****                 {
3398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3401:../uvc.c      ****                 }
3402:../uvc.c      ****             }
3403:../uvc.c      ****         }
3404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3405:../uvc.c      **** 
3406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3407:../uvc.c      ****         CyU3PThreadRelinquish ();
3408:../uvc.c      ****     }
3409:../uvc.c      **** }
3410:../uvc.c      **** 
3411:../uvc.c      **** /*
3412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3413:../uvc.c      ****  */
3414:../uvc.c      **** 
3415:../uvc.c      **** static void
3416:../uvc.c      **** UVCHandleProcessingUnitRqts (
3417:../uvc.c      ****         void)
3418:../uvc.c      **** {
3419:../uvc.c      ****     uint8_t CtrlAdd;
3420:../uvc.c      **** #ifdef DbgInfo
3421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3422:../uvc.c      **** #endif
3423:../uvc.c      ****     switch (wValue)
3424:../uvc.c      ****     {
3425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3428:../uvc.c      ****     		break;
3429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3432:../uvc.c      ****     		break;
3433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3436:../uvc.c      **** 			break;
3437:../uvc.c      **** 
3438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3439:../uvc.c      **** 
3440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3443:../uvc.c      ****       		break;
3444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3446:../uvc.c      ****      		ControlHandle(HueCtlID5);
3447:../uvc.c      ****      		break;
3448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3451:../uvc.c      ****           		break;
3452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3455:../uvc.c      ****           		break;
3456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3461:../uvc.c      ****     		break;
3462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3465:../uvc.c      ****     		break;
3466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3469:../uvc.c      ****     		break;
3470:../uvc.c      **** 
3471:../uvc.c      ****         default:
3472:../uvc.c      ****             /*
3473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3474:../uvc.c      ****              * other controls.
3475:../uvc.c      ****              */
3476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3478:../uvc.c      ****             break;
3479:../uvc.c      ****     }
3480:../uvc.c      **** }
3481:../uvc.c      **** 
3482:../uvc.c      **** /*
3483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3484:../uvc.c      ****  */
3485:../uvc.c      **** static void
3486:../uvc.c      **** UVCHandleCameraTerminalRqts (
3487:../uvc.c      ****         void)
3488:../uvc.c      **** {
3489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3491:../uvc.c      ****     uint16_t readCount;
3492:../uvc.c      ****     uint16_t zoomVal;
3493:../uvc.c      ****     int32_t  panVal, tiltVal;
3494:../uvc.c      ****     CyBool_t sendData = CyFalse;
3495:../uvc.c      **** #endif
3496:../uvc.c      ****     uint8_t CtrlAdd;
3497:../uvc.c      **** 
3498:../uvc.c      ****     switch (wValue)
3499:../uvc.c      ****     {
3500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3503:../uvc.c      ****     		break;
3504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3507:../uvc.c      ****     		break;
3508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3511:../uvc.c      **** 			break;
3512:../uvc.c      **** 
3513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3516:../uvc.c      **** 			break;
3517:../uvc.c      **** 
3518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3521:../uvc.c      ****       		break;
3522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3525:../uvc.c      ****      		break;
3526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3529:../uvc.c      ****           		break;
3530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3531:../uvc.c      ****           		break;
3532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3535:../uvc.c      ****      		break;
3536:../uvc.c      **** 
3537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3540:../uvc.c      ****     		break;
3541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3544:../uvc.c      ****     		break;
3545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3548:../uvc.c      ****     		break;
3549:../uvc.c      **** 
3550:../uvc.c      ****         default:
3551:../uvc.c      ****             /*
3552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3553:../uvc.c      ****              * other controls.
3554:../uvc.c      ****              */
3555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3557:../uvc.c      ****             break;
3558:../uvc.c      ****     }
3559:../uvc.c      **** 
3560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3561:../uvc.c      ****     switch (wValue)
3562:../uvc.c      ****     {
3563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3564:../uvc.c      ****             switch (bRequest)
3565:../uvc.c      ****             {
3566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3569:../uvc.c      ****                     break;
3570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3572:../uvc.c      ****                     sendData = CyTrue;
3573:../uvc.c      ****                     break;
3574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3576:../uvc.c      ****                     sendData = CyTrue;
3577:../uvc.c      ****                     break;
3578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3580:../uvc.c      ****                     sendData = CyTrue;
3581:../uvc.c      ****                     break;
3582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3584:../uvc.c      ****                     sendData = CyTrue;
3585:../uvc.c      ****                     break;
3586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3588:../uvc.c      ****                     sendData = CyTrue;
3589:../uvc.c      ****                     break;
3590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3592:../uvc.c      ****                             glEp0Buffer, &readCount);
3593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3594:../uvc.c      ****                     {
3595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3597:../uvc.c      ****                     }
3598:../uvc.c      ****                     break;
3599:../uvc.c      ****                 default:
3600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3601:../uvc.c      ****                     break;
3602:../uvc.c      ****             }
3603:../uvc.c      **** 
3604:../uvc.c      ****             if (sendData)
3605:../uvc.c      ****             {
3606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3610:../uvc.c      ****             }
3611:../uvc.c      ****             break;
3612:../uvc.c      **** 
3613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3614:../uvc.c      ****             switch (bRequest)
3615:../uvc.c      ****             {
3616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3619:../uvc.c      ****                     break;
3620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3623:../uvc.c      ****                     sendData = CyTrue;
3624:../uvc.c      ****                     break;
3625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3628:../uvc.c      ****                     sendData = CyTrue;
3629:../uvc.c      ****                     break;
3630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3633:../uvc.c      ****                     sendData = CyTrue;
3634:../uvc.c      ****                     break;
3635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3638:../uvc.c      ****                     sendData = CyTrue;
3639:../uvc.c      ****                     break;
3640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3643:../uvc.c      ****                     sendData = CyTrue;
3644:../uvc.c      ****                     break;
3645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3647:../uvc.c      ****                             glEp0Buffer, &readCount);
3648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3649:../uvc.c      ****                     {
3650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3654:../uvc.c      **** 
3655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3657:../uvc.c      ****                     }
3658:../uvc.c      ****                     break;
3659:../uvc.c      ****                 default:
3660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3661:../uvc.c      ****                     break;
3662:../uvc.c      ****             }
3663:../uvc.c      **** 
3664:../uvc.c      ****             if (sendData)
3665:../uvc.c      ****             {
3666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3676:../uvc.c      ****             }
3677:../uvc.c      ****             break;
3678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3679:../uvc.c      ****         default:
3680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3681:../uvc.c      ****             break;
3682:../uvc.c      ****     }
3683:../uvc.c      **** #endif
3684:../uvc.c      **** }
3685:../uvc.c      **** 
3686:../uvc.c      **** /*
3687:../uvc.c      ****  * Handler for UVC Interface control requests.
3688:../uvc.c      ****  */
3689:../uvc.c      **** static void
3690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3691:../uvc.c      ****         void)
3692:../uvc.c      **** {
3693:../uvc.c      **** 	if(valIdx < 32){
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
3695:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
3696:../uvc.c      **** 		valIdx++;
3697:../uvc.c      **** 		value[0][1] = valIdx;
3698:../uvc.c      **** 	}
3699:../uvc.c      ****     switch (wValue)
3700:../uvc.c      ****     {
3701:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3702:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3703:../uvc.c      ****     		break;
3704:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3705:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3706:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3707:../uvc.c      ****     		break;
3708:../uvc.c      ****     	default:
3709:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3710:../uvc.c      ****      		break;
3711:../uvc.c      ****     }
3712:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3713:../uvc.c      **** 
3714:../uvc.c      **** }
3715:../uvc.c      **** 
3716:../uvc.c      **** /*
3717:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3718:../uvc.c      ****  */
3719:../uvc.c      **** static void
3720:../uvc.c      **** UVCHandleExtensionUnitRqts (
3721:../uvc.c      ****         void)
3722:../uvc.c      **** {
3723:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3724:../uvc.c      **** 
3725:../uvc.c      **** #ifdef DbgInfo
3726:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3727:../uvc.c      **** #endif
3728:../uvc.c      ****     switch (wValue)
3729:../uvc.c      ****     {
3730:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3731:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3732:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3733:../uvc.c      ****     		break;
3734:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3735:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3736:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3737:../uvc.c      ****     		break;
3738:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3739:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3740:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3741:../uvc.c      ****      		break;
3742:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3743:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3744:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3745:../uvc.c      ****     		break;
3746:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3747:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3748:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3749:../uvc.c      ****     		break;
3750:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3751:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3752:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3753:../uvc.c      ****      		break;
3754:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3755:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3756:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3757:../uvc.c      ****     		break;
3758:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3759:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3760:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3761:../uvc.c      ****     		break;
3762:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3763:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3764:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3765:../uvc.c      ****      		break;
3766:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3767:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3768:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3769:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3770:../uvc.c      ****     		}else/* no support for 1080p camera */
3771:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3772:../uvc.c      ****     		break;
3773:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3774:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3775:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3776:../uvc.c      ****     		break;
3777:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3778:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3779:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3780:../uvc.c      ****     		break;
3781:../uvc.c      **** 
3782:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3783:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3784:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3785:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3786:../uvc.c      ****     		break;
3787:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3788:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3789:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3790:../uvc.c      ****     		//break;
3791:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3792:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3793:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3794:../uvc.c      ****     		break;
3795:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3796:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3797:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3798:../uvc.c      ****     		break;
3799:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3800:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3801:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3802:../uvc.c      ****     		break;
3803:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3804:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3805:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3806:../uvc.c      ****     		break;
3807:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3808:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3809:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3810:../uvc.c      ****     		break;
3811:../uvc.c      ****    	default:
3812:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3813:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3814:../uvc.c      ****     		break;
3815:../uvc.c      ****     }
3816:../uvc.c      **** 
3817:../uvc.c      **** }
3818:../uvc.c      **** 
3819:../uvc.c      **** /*
3820:../uvc.c      ****  * Handler for the video streaming control requests.
3821:../uvc.c      ****  */
3822:../uvc.c      **** static void
3823:../uvc.c      **** UVCHandleVideoStreamingRqts (
3824:../uvc.c      ****         void)
3825:../uvc.c      **** {
3826:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3827:../uvc.c      ****     uint16_t readCount;
3828:../uvc.c      **** 
3829:../uvc.c      ****     switch (wValue)
3830:../uvc.c      ****     {
3831:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3832:../uvc.c      ****             switch (bRequest)
3833:../uvc.c      ****             {
3834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3835:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3836:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3837:../uvc.c      ****                     break;
3838:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3839:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3840:../uvc.c      ****                     glEp0Buffer[1] = 0;
3841:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3842:../uvc.c      ****                     break;
3843:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3844:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3845:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3846:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3847:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3848:../uvc.c      ****                     {
3849:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3850:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3851:../uvc.c      **** 
3852:../uvc.c      ****                     }
3853:../uvc.c      ****                     else
3854:../uvc.c      ****                     {
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3856:../uvc.c      ****                     }
3857:../uvc.c      ****                     break;
3858:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3859:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3860:../uvc.c      ****                             glCommitCtrl, &readCount);
3861:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3862:../uvc.c      ****                     {
3863:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3864:../uvc.c      ****                         {
3865:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3866:../uvc.c      ****                                active data structure. */
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3873:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3874:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3875:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3876:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3877:../uvc.c      **** #if 0
3878:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3879:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3880:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3881:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3882:../uvc.c      **** #endif
3883:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3884:../uvc.c      ****                        }
3885:../uvc.c      ****                     }
3886:../uvc.c      ****                     break;
3887:../uvc.c      ****                 default:
3888:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3889:../uvc.c      ****                     break;
3890:../uvc.c      ****             }
3891:../uvc.c      ****             break;
3892:../uvc.c      **** 
3893:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3894:../uvc.c      ****             switch (bRequest)
3895:../uvc.c      ****             {
3896:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3899:../uvc.c      ****                     break;
3900:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3901:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3902:../uvc.c      ****                     glEp0Buffer[1] = 0;
3903:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3904:../uvc.c      ****                     break;
3905:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3906:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3907:../uvc.c      ****                     {
3908:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3909:../uvc.c      ****                     }
3910:../uvc.c      ****                     else
3911:../uvc.c      ****                     {
3912:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3913:../uvc.c      ****                     }
3914:../uvc.c      ****                     break;
3915:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3916:../uvc.c      ****                     /* for error cover implementation */
3917:../uvc.c      ****                     CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
3918:../uvc.c      **** 
3919:../uvc.c      ****                     /* Disable the GPIF state machine. */
3920:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
3921:../uvc.c      ****                     gpif_initialized = 0;
3922:../uvc.c      ****                     streamingStarted = CyFalse;
3923:../uvc.c      **** 
3924:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
3925:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3926:../uvc.c      ****                     CyU3PBusyWait (100);
3927:../uvc.c      **** 
3928:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
3929:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3930:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3931:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3932:../uvc.c      ****                     CyU3PBusyWait (100);
3933:../uvc.c      **** 
3934:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
3935:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3936:../uvc.c      **** 
3937:../uvc.c      ****                     //uvcHandleReq = CyTrue;
3938:../uvc.c      ****                     /* Complete Control request handshake */
3939:../uvc.c      ****                     CyU3PUsbAckSetup ();
3940:../uvc.c      ****                     /* Indicate stop streaming to main thread */
3941:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
3942:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x10; //set bit0
3943:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
3944:../uvc.c      ****                     /* end of the error cover implementation */
3945:../uvc.c      **** 
3946:../uvc.c      ****                 	/* The host has selected the parameters for the video stream. Check the desired
3947:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3948:../uvc.c      ****                        */
3949:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3950:../uvc.c      ****                             glCommitCtrl, &readCount);
3951:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3952:../uvc.c      ****                     {
3953:../uvc.c      ****                         switch (glCommitCtrl[3])
3954:../uvc.c      ****                          {
3955:../uvc.c      ****                          	case 1: //1944
3956:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3957:../uvc.c      ****                          		CyU3PThreadSleep(500);
3958:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3959:../uvc.c      ****                          		break;
3960:../uvc.c      ****                          	case 2: //1080
3961:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3962:../uvc.c      ****                          		CyU3PThreadSleep(500);
3963:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3964:../uvc.c      ****                          		break;
3965:../uvc.c      ****                          	case 3: //720
3966:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3967:../uvc.c      ****                          		CyU3PThreadSleep(500);
3968:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3969:../uvc.c      ****                          		break;
3970:../uvc.c      ****                          	case 4: //VGA
3971:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3972:../uvc.c      ****                          		CyU3PThreadSleep(500);
3973:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3974:../uvc.c      ****                          		break;
3975:../uvc.c      ****                          	default:
3976:../uvc.c      ****                          		break;
3977:../uvc.c      ****                          }
3978:../uvc.c      ****                         setRes = glCommitCtrl[3];
3979:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3980:../uvc.c      **** 
3981:../uvc.c      **** #if 0
3982:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3983:../uvc.c      ****                         {
3984:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3985:../uvc.c      ****                         }
3986:../uvc.c      ****                         else
3987:../uvc.c      ****                         {
3988:../uvc.c      ****                             SensorScaling_VGA ();
3989:../uvc.c      ****                         }
3990:../uvc.c      **** #endif
3991:../uvc.c      ****                         /* We can start streaming video now. */
3992:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3993:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3994:../uvc.c      ****                         {
3995:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3996:../uvc.c      ****                         }
3997:../uvc.c      ****                     }
3998:../uvc.c      ****                     break;
3999:../uvc.c      **** 
4000:../uvc.c      ****                 default:
4001:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4002:../uvc.c      ****                     break;
4003:../uvc.c      ****             }
4004:../uvc.c      ****             break;
4005:../uvc.c      **** 
4006:../uvc.c      **** /* still image streaming handler */
4007:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4008:../uvc.c      ****                 switch (bRequest)
4009:../uvc.c      ****                 {
4010:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4011:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4012:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4013:../uvc.c      ****                         break;
4014:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4015:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4016:../uvc.c      ****                         glEp0Buffer[1] = 0;
4017:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4018:../uvc.c      ****                         break;
4019:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4020:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4021:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4022:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4023:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4024:../uvc.c      ****                         {
4025:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4026:../uvc.c      ****                         }
4027:../uvc.c      ****                         else
4028:../uvc.c      ****                         {
4029:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4030:../uvc.c      ****                         }
4031:../uvc.c      ****                         break;
4032:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4033:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4034:../uvc.c      ****                                 glCommitCtrl, &readCount);
4035:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4036:../uvc.c      ****                         {
4037:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4038:../uvc.c      ****                             {
4039:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4040:../uvc.c      ****                                    active data structure. */
4041:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4042:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4043:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
4044:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
4045:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
4046:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
4047:../uvc.c      ****                             }
4048:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4049:../uvc.c      ****                         }
4050:../uvc.c      ****                         break;
4051:../uvc.c      ****                     default:
4052:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4053:../uvc.c      ****                         break;
4054:../uvc.c      ****                 }
4055:../uvc.c      ****                 break;
4056:../uvc.c      **** 
4057:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4058:../uvc.c      ****                 switch (bRequest)
4059:../uvc.c      ****                 {
4060:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4061:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4062:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4063:../uvc.c      ****                         break;
4064:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4065:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4066:../uvc.c      ****                         glEp0Buffer[1] = 0;
4067:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4068:../uvc.c      ****                         break;
4069:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4070:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4071:../uvc.c      ****                         {
4072:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4073:../uvc.c      ****                         }
4074:../uvc.c      ****                         else
4075:../uvc.c      ****                         {
4076:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4077:../uvc.c      ****                         }
4078:../uvc.c      ****                         break;
4079:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4080:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4081:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4082:../uvc.c      ****                            */
4083:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4084:../uvc.c      ****                                 glCommitCtrl, &readCount);
4085:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4086:../uvc.c      ****                         {
4087:../uvc.c      ****     #if 0
4088:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4089:../uvc.c      ****                             {
4090:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4091:../uvc.c      ****                             }
4092:../uvc.c      ****                             else
4093:../uvc.c      ****                             {
4094:../uvc.c      ****                                 SensorScaling_VGA ();
4095:../uvc.c      ****                             }
4096:../uvc.c      ****                             /* We can start streaming video now. */
4097:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4098:../uvc.c      **** 
4099:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4100:../uvc.c      ****                             {
4101:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4102:../uvc.c      ****                             }
4103:../uvc.c      **** 	#endif
4104:../uvc.c      ****                            switch (glCommitCtrl[1])
4105:../uvc.c      ****                              {
4106:../uvc.c      ****                              	case 4: //1944
4107:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4108:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4109:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4110:../uvc.c      ****                              		break;
4111:../uvc.c      ****                              	case 3: //1080
4112:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4113:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4114:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4115:../uvc.c      ****                              		break;
4116:../uvc.c      ****                              	case 2: //720
4117:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4118:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4119:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4120:../uvc.c      ****                              		break;
4121:../uvc.c      ****                             	case 1: //VGA
4122:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4123:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4124:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4125:../uvc.c      ****                              		break;
4126:../uvc.c      ****                               	default:
4127:../uvc.c      ****                              		break;
4128:../uvc.c      ****                              }
4129:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4130:../uvc.c      **** 
4131:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4132:../uvc.c      **** 
4133:../uvc.c      ****                         }
4134:../uvc.c      ****                         break;
4135:../uvc.c      **** 
4136:../uvc.c      ****                     default:
4137:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4138:../uvc.c      ****                         break;
4139:../uvc.c      ****                 }
4140:../uvc.c      ****                 break;
4141:../uvc.c      **** 
4142:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4143:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4144:../uvc.c      ****             	switch (bRequest)
4145:../uvc.c      ****                 {
4146:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4147:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4148:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4149:../uvc.c      ****                         break;
4150:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4151:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4152:../uvc.c      ****                         glEp0Buffer[1] = 0;
4153:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4154:../uvc.c      ****                         break;
4155:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4156:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4157:../uvc.c      ****                         {
4158:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4159:../uvc.c      ****                         }
4160:../uvc.c      ****                         else
4161:../uvc.c      ****                         {
4162:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4163:../uvc.c      ****                         }
4164:../uvc.c      ****                         break;
4165:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4166:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4167:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4168:../uvc.c      ****                            */
4169:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4170:../uvc.c      ****                                 glCommitCtrl, &readCount);
4171:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4172:../uvc.c      ****                         {
4173:../uvc.c      ****     #if 1
4174:../uvc.c      ****                             /* We can start still streaming video now. */
4175:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4176:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4177:../uvc.c      ****                             {
4178:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4179:../uvc.c      ****                             }
4180:../uvc.c      ****     #endif
4181:../uvc.c      ****                             else{
4182:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4183:../uvc.c      ****                             //stillcont = 0;
4184:../uvc.c      ****                             }
4185:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4186:../uvc.c      ****                         }else{
4187:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4188:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4189:../uvc.c      ****                         }
4190:../uvc.c      ****                         break;
4191:../uvc.c      **** 
4192:../uvc.c      ****                     default:
4193:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4194:../uvc.c      ****                         break;
4195:../uvc.c      ****                 }
4196:../uvc.c      ****                 break;
4197:../uvc.c      **** 
4198:../uvc.c      ****         default:
4199:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4200:../uvc.c      ****             break;
4201:../uvc.c      ****     }
4202:../uvc.c      **** }
4203:../uvc.c      **** 
4204:../uvc.c      **** /*
4205:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4206:../uvc.c      ****  */
4207:../uvc.c      **** void
4208:../uvc.c      **** UVCAppEP0Thread_Entry (
4209:../uvc.c      ****         uint32_t input)
4210:../uvc.c      **** {
4211:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4212:../uvc.c      ****     uint32_t eventFlag;
4213:../uvc.c      **** 	CyBool_t value;
4214:../uvc.c      **** 	CyBool_t *valueptr = &value;
4215:../uvc.c      **** 
4216:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4217:../uvc.c      **** 
4218:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4219:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4220:../uvc.c      **** 
4221:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4222:../uvc.c      **** #endif
4223:../uvc.c      **** 
4224:../uvc.c      ****     /* for interrupt status test */
4225:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4226:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4227:../uvc.c      **** 
4228:../uvc.c      ****     for (;;)
4229:../uvc.c      ****     {
4230:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4232:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4233:../uvc.c      ****         {
4234:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4235:../uvc.c      ****             if (!isUsbConnected)
4236:../uvc.c      ****             {
4237:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4238:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4239:../uvc.c      ****                 {
4240:../uvc.c      ****                     isUsbConnected = CyTrue;
4241:../uvc.c      ****                 }
4242:../uvc.c      ****             }
4243:../uvc.c      **** #ifdef DbgInfo
4244:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4245:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4246:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4247:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4248:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4249:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4250:../uvc.c      **** #endif
4251:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4252:../uvc.c      ****             {
4253:../uvc.c      ****             	switch ((wIndex >> 8))
4254:../uvc.c      ****                 {
4255:../uvc.c      **** 
4256:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4257:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4258:../uvc.c      ****                         break;
4259:../uvc.c      **** 
4260:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4261:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4262:../uvc.c      ****                         break;
4263:../uvc.c      **** 
4264:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4265:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4266:../uvc.c      ****                         break;
4267:../uvc.c      **** 
4268:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4269:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4270:../uvc.c      ****                         break;
4271:../uvc.c      **** 
4272:../uvc.c      ****                     default:
4273:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4274:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4275:../uvc.c      ****                         break;
4276:../uvc.c      ****                 }
4277:../uvc.c      ****             }
4278:../uvc.c      **** 
4279:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4280:../uvc.c      ****             {
4281:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4282:../uvc.c      **** 
4283:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4284:../uvc.c      ****                 {
4285:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4286:../uvc.c      ****                 }
4287:../uvc.c      ****                 else
4288:../uvc.c      ****                 {
4289:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4290:../uvc.c      ****                 }
4291:../uvc.c      ****             }
4292:../uvc.c      **** 
4293:../uvc.c      ****             /* handle interrupt status event */
4294:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4295:../uvc.c      ****             {
4296:../uvc.c      **** 
4297:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4298:../uvc.c      ****             	/** preparing interrupt status data **/
4299:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4300:../uvc.c      **** 
4301:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4302:../uvc.c      **** 
4303:../uvc.c      **** #if 0 //for real button
4304:../uvc.c      **** 				if(value&&(!snapButFlag)){
4305:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4306:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4307:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4308:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4309:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4310:../uvc.c      **** 
4311:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4312:../uvc.c      **** 					interStabuf.size   = 1024;
4313:../uvc.c      **** 					interStabuf.status = 0;
4314:../uvc.c      **** 
4315:../uvc.c      **** 					interStabuf.count = 4;
4316:../uvc.c      **** 
4317:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4318:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4319:../uvc.c      **** 
4320:../uvc.c      **** 					/** send a interrupt status data **/
4321:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4322:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4323:../uvc.c      **** 					{
4324:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4325:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4326:../uvc.c      **** 					}
4327:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4328:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4329:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4330:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4331:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4332:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4333:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4334:../uvc.c      **** 
4335:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4336:../uvc.c      **** 					interStabuf.size   = 1024;
4337:../uvc.c      **** 					interStabuf.status = 0;
4338:../uvc.c      **** 
4339:../uvc.c      **** 					interStabuf.count = 4;
4340:../uvc.c      **** 
4341:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4342:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4343:../uvc.c      **** 
4344:../uvc.c      **** 					/** send a interrupt status data **/
4345:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4346:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4347:../uvc.c      **** 					{
4348:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4349:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4350:../uvc.c      **** 					}
4351:../uvc.c      **** 
4352:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4353:../uvc.c      **** 					stiflag = 0xFF;
4354:../uvc.c      **** 				}
4355:../uvc.c      **** #else			//for botton simulation
4356:../uvc.c      **** 				if(snapButFlag == 0x0f){
4357:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4361:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4362:../uvc.c      **** 
4363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4364:../uvc.c      **** 					interStabuf.size   = 1024;
4365:../uvc.c      **** 					interStabuf.status = 0;
4366:../uvc.c      **** 
4367:../uvc.c      **** 					interStabuf.count = 4;
4368:../uvc.c      **** 
4369:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4371:../uvc.c      **** 
4372:../uvc.c      **** 					/** send a interrupt status data **/
4373:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4374:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4375:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4376:../uvc.c      **** 					{
4377:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4378:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4379:../uvc.c      **** 					}
4380:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4381:../uvc.c      **** 
4382:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4383:../uvc.c      **** 				}else if(!snapButFlag){
4384:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4385:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4387:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4389:../uvc.c      **** 
4390:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4391:../uvc.c      **** 					interStabuf.size   = 1024;
4392:../uvc.c      **** 					interStabuf.status = 0;
4393:../uvc.c      **** 
4394:../uvc.c      **** 					interStabuf.count = 4;
4395:../uvc.c      **** 
4396:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4397:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4398:../uvc.c      **** 
4399:../uvc.c      **** 					/** send a interrupt status data **/
4400:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4401:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4402:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4403:../uvc.c      **** 					{
4404:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4405:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4406:../uvc.c      **** 					}
4407:../uvc.c      **** 
4408:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4409:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4410:../uvc.c      **** 				}
4411:../uvc.c      **** #endif
4412:../uvc.c      **** 
4413:../uvc.c      ****             }
4414:../uvc.c      **** 
4415:../uvc.c      **** 
4416:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4417:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4418:../uvc.c      ****             {
4419:../uvc.c      ****                 /* Get the command buffer */
4420:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4421:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4422:../uvc.c      ****                 {
4423:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4424:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4425:../uvc.c      ****                 }
4426:../uvc.c      **** 
4427:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4428:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4429:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4430:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4431:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4432:../uvc.c      ****                  * register value high byte and register value low byte.
4433:../uvc.c      ****                  */
4434:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4435:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4436:../uvc.c      ****                 {
4437:../uvc.c      ****                     if (dmaInfo.count == 3)
4438:../uvc.c      ****                     {
4439:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4440:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4441:../uvc.c      ****                         dmaInfo.count = 3;
4442:../uvc.c      ****                     }
4443:../uvc.c      ****                     else if (dmaInfo.count == 4)
4444:../uvc.c      ****                     {
4445:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4446:../uvc.c      ****                         {
4447:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4448:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4449:../uvc.c      ****                         }
4450:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4451:../uvc.c      ****                     }
4452:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4453:../uvc.c      ****                 }
4454:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4455:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4456:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4457:../uvc.c      ****                  */
4458:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4459:../uvc.c      ****                 {
4460:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4461:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4462:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4463:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4464:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4465:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4466:../uvc.c      ****                         	break;
4467:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4468:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4469:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4470:../uvc.c      ****                         	break;*/
4471:../uvc.c      ****                     dmaInfo.count -= 2;
4472:../uvc.c      ****                 }
4473:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4474:../uvc.c      ****                 else
4475:../uvc.c      ****                 {
4476:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4477:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4478:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4479:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4480:../uvc.c      ****                 }
4481:../uvc.c      **** 
4482:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4483:../uvc.c      ****                 dmaInfo.size   = 1024;
4484:../uvc.c      ****                 dmaInfo.status = 0;
4485:../uvc.c      **** 
4486:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4487:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4488:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4489:../uvc.c      ****                 {
4490:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4491:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4492:../uvc.c      ****                 }
4493:../uvc.c      **** 
4494:../uvc.c      ****                 /* Wait until the response has gone out. */
4495:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4496:../uvc.c      **** 
4497:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4498:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4499:../uvc.c      ****                 {
4500:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4501:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4502:../uvc.c      ****                 }
4503:../uvc.c      ****             }
4504:../uvc.c      **** #endif
4505:../uvc.c      ****         }
4506:../uvc.c      ****         /* Allow other ready threads to run. */
4507:../uvc.c      ****         CyU3PThreadRelinquish ();
4508:../uvc.c      ****     }
4509:../uvc.c      **** }
4510:../uvc.c      **** 
4511:../uvc.c      **** /*
4512:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4513:../uvc.c      ****  * added 10/2013
4514:../uvc.c      ****  */
4515:../uvc.c      **** /*
4516:../uvc.c      **** static uint8_t timeDelay[64] = {
4517:../uvc.c      **** 
4518:../uvc.c      **** };
4519:../uvc.c      **** */
4520:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4520 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4521:../uvc.c      **** 
4522:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4523:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4524:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4525:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4526:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4527:../uvc.c      **** 	uint32_t flag = 0;
4528:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4529:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4530:../uvc.c      **** 	uint8_t i;
4531:../uvc.c      **** 	uint16_t delaytime;
4532:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4533:../uvc.c      **** 
4534:../uvc.c      **** #if 0 //for test the command queue
4535:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4536:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4537:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4538:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4539:../uvc.c      **** 		lcCmdDes += 1;
4540:../uvc.c      **** 	}
4541:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4542:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4543:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4544:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4545:../uvc.c      **** 		lcCmdDes += 1;
4546:../uvc.c      **** 	}
4547:../uvc.c      **** 
4548:../uvc.c      **** #endif
4549:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4550:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4550 0
  36 0004 30229FE5 		ldr	r2, .L25
4527:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4527 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4520:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4520 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4550 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 18029FE5 		ldr	r0, .L25+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4527:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4527 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4550 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4551:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4551 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 FC119FE5 		ldr	r1, .L25+8
  71 0044 FC519FE5 		ldr	r5, .L25+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4552:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4552 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4553:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4553 0
  79 005c DC019FE5 		ldr	r0, .L25+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4554:../uvc.c      **** 
4555:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4555 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4556:../uvc.c      ****         /* Allow other ready threads to run. */
4557:../uvc.c      **** 
4558:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4558 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4555:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4555 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4559:../uvc.c      **** 	}
4560:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4560 0
  92 0078 C8019FE5 		ldr	r0, .L25+12
  93 007c C8119FE5 		ldr	r1, .L25+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 B8619FE5 		ldr	r6, .L25+20
  99 0094 B8B19FE5 		ldr	fp, .L25+24
4561:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4562:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4563:../uvc.c      **** 	//CyU3PThreadSleep(100);
4564:../uvc.c      **** 	//SetCurCmd();
4565:../uvc.c      **** 	/*********** the loop of the thread ***********/
4566:../uvc.c      **** 	for(;;){
4567:../uvc.c      **** 
4568:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4568 0
 101 0098 0070E0E3 		mvn	r7, #0
4569:../uvc.c      **** /*  // for test GPIO output
4570:../uvc.c      **** 		if(trigger)
4571:../uvc.c      **** 		{
4572:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4573:../uvc.c      **** 			{
4574:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4575:../uvc.c      **** 			}
4576:../uvc.c      **** 
4577:../uvc.c      **** 		}else{
4578:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4579:../uvc.c      **** 			{
4580:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4581:../uvc.c      **** 			}
4582:../uvc.c      **** 
4583:../uvc.c      **** 		}
4584:../uvc.c      **** */
4585:../uvc.c      **** 		if(0&&streamingRecove){//start stream again after the USB-pipe reset
4586:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
4587:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
4588:../uvc.c      **** 
4589:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
4590:../uvc.c      ****             {
4591:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
4592:../uvc.c      ****             }
4593:../uvc.c      **** 		}
4594:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4595:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4596:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4597:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4598:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4599:../uvc.c      **** 				i = 0;
4600:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4600 0
 103 009c 0090A0E3 		mov	r9, #0
4601:../uvc.c      **** 					i++;
4602:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4603:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4604:../uvc.c      **** 				}
4605:../uvc.c      **** #if 0
4606:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4607:../uvc.c      **** 				i = lcStaDes->curNum;
4608:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4609:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4610:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4611:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4612:../uvc.c      **** 
4613:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4614:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4615:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4616:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4617:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4618:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4619:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4620:../uvc.c      **** #endif
4621:../uvc.c      **** 				//}
4622:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4623:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4624:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4625:../uvc.c      **** 				/* setting delay */
4626:../uvc.c      **** 				delaytime = 300;
4627:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4628:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4629:../uvc.c      **** 			} //end of the if condition statment
4630:../uvc.c      **** #endif
4631:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4632:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4633:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4634:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4635:../uvc.c      **** 
4636:../uvc.c      **** 				/*
4637:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4638:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4639:../uvc.c      **** 				*/
4640:../uvc.c      **** 
4641:../uvc.c      **** 				/* find a available command */
4642:../uvc.c      **** 				i = 0;
4643:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4644:../uvc.c      **** 					i++;
4645:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4646:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4647:../uvc.c      **** 				}
4648:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4649:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4650:../uvc.c      **** 					i = lcCmdDes->curNum;
4651:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4652:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4653:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4654:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4655:../uvc.c      **** #if 1
4656:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4657:../uvc.c      **** 						case 0x20:
4658:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4659:../uvc.c      **** 							delaytime = 500;
4660:../uvc.c      **** 							break;
4661:../uvc.c      **** 						case 0x21:
4662:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4663:../uvc.c      **** 							delaytime = 500;
4664:../uvc.c      **** 							break;
4665:../uvc.c      **** 						case 0x22:
4666:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4667:../uvc.c      **** 							delaytime = 300;
4668:../uvc.c      **** 							break;
4669:../uvc.c      **** 						case 0x23:
4670:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4671:../uvc.c      **** 							delaytime = 300;
4672:../uvc.c      **** 							break;
4673:../uvc.c      **** 						default:
4674:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4675:../uvc.c      **** 							break;
4676:../uvc.c      **** 					}
4677:../uvc.c      **** #endif
4678:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4679:../uvc.c      **** 					/** timer's ticket modify **/
4680:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4681:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4682:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4683:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4684:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4685:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4686:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4687:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4688:../uvc.c      **** #endif
4689:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4690:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4691:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4692:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4693:../uvc.c      **** 						}else{
4694:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4695:../uvc.c      **** 						}
4696:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4697:../uvc.c      **** 					}else{
4698:../uvc.c      **** 						lcCmdDes->curNum ++;
4699:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4699 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L20:
4568:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4568 0
 108 00a4 14308DE2 		add	r3, sp, #20
 109 00a8 2010A0E3 		mov	r1, #32
 110 00ac 0320A0E3 		mov	r2, #3
 111 00b0 A0019FE5 		ldr	r0, .L25+28
 112 00b4 00708DE5 		str	r7, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4594:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4594 0
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 1C0096E5 		ldr	r0, [r6, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4600:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 119              		.loc 1 4600 0
 120 00c8 101096E5 		ldr	r1, [r6, #16]
 121 00cc 3C3091E5 		ldr	r3, [r1, #60]
 122 00d0 000053E3 		cmp	r3, #0
 123 00d4 0300001A 		bne	.L4
 124              	.LVL4:
 125              	.L5:
4601:../uvc.c      **** 					i++;
 126              		.loc 1 4601 0
 127 00d8 012083E2 		add	r2, r3, #1
 128 00dc FF3002E2 		and	r3, r2, #255
 129              	.LVL5:
4600:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4600 0
 131 00e0 3F0053E3 		cmp	r3, #63
 132 00e4 FBFFFF9A 		bls	.L5
 133              	.LVL6:
 134              	.L4:
4631:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 135              		.loc 1 4631 0
 136 00e8 1C0096E5 		ldr	r0, [r6, #28]
 137 00ec FEFFFFEB 		bl	_txe_mutex_put
 138              	.LVL7:
4633:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 139              		.loc 1 4633 0
 140 00f0 1C0095E5 		ldr	r0, [r5, #28]
 141 00f4 0010E0E3 		mvn	r1, #0
 142 00f8 FEFFFFEB 		bl	_txe_mutex_get
4634:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 143              		.loc 1 4634 0
 144 00fc 104095E5 		ldr	r4, [r5, #16]
 145              	.LVL8:
4643:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 146              		.loc 1 4643 0
 147 0100 3C2094E5 		ldr	r2, [r4, #60]
 148 0104 000052E3 		cmp	r2, #0
 149 0108 0800001A 		bne	.L6
 150 010c 0030A0E3 		mov	r3, #0
 151              	.LVL9:
 152              	.L7:
4645:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 153              		.loc 1 4645 0
 154 0110 344094E5 		ldr	r4, [r4, #52]
 155              	.LVL10:
4644:../uvc.c      **** 					i++;
 156              		.loc 1 4644 0
 157 0114 01A083E2 		add	sl, r3, #1
4643:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 158              		.loc 1 4643 0
 159 0118 3C2094E5 		ldr	r2, [r4, #60]
4644:../uvc.c      **** 					i++;
 160              		.loc 1 4644 0
 161 011c FF300AE2 		and	r3, sl, #255
 162              	.LVL11:
4643:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 163              		.loc 1 4643 0
 164 0120 3F0053E3 		cmp	r3, #63
 165 0124 00005293 		cmpls	r2, #0
 166 0128 F8FFFF0A 		beq	.L7
 167 012c 104085E5 		str	r4, [r5, #16]
 168              	.LVL12:
 169              	.L6:
4649:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 170              		.loc 1 4649 0
 171 0130 000052E3 		cmp	r2, #0
 172 0134 2D00000A 		beq	.L8
 173              	.LVL13:
4651:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 174              		.loc 1 4651 0
 175 0138 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
4656:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 176              		.loc 1 4656 0
 177 013c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4651:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 178              		.loc 1 4651 0
 179 0140 813081E0 		add	r3, r1, r1, asl #1
 180 0144 83E084E0 		add	lr, r4, r3, asl #1
4656:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 181              		.loc 1 4656 0
 182 0148 20C040E2 		sub	ip, r0, #32
4652:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 183              		.loc 1 4652 0
 184 014c 0510DEE5 		ldrb	r1, [lr, #5]	@ zero_extendqisi2
4651:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 185              		.loc 1 4651 0
 186 0150 0400DEE5 		ldrb	r0, [lr, #4]	@ zero_extendqisi2
 187              	.LVL14:
4653:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 188              		.loc 1 4653 0
 189 0154 0620DEE5 		ldrb	r2, [lr, #6]	@ zero_extendqisi2
 190              	.LVL15:
4654:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 191              		.loc 1 4654 0
 192 0158 B8A0DEE1 		ldrh	sl, [lr, #8]
 193              	.LVL16:
4656:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 194              		.loc 1 4656 0
 195 015c 03005CE3 		cmp	ip, #3
 196 0160 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 197 0164 1A0000EA 		b	.L9
 198              	.L14:
 199 0168 E0010000 		.word	.L10
 200 016c C4010000 		.word	.L11
 201 0170 78010000 		.word	.L13
 202 0174 78010000 		.word	.L13
 203              	.LVL17:
 204              	.L13:
4670:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 205              		.loc 1 4670 0
 206 0178 8230A0E3 		mov	r3, #130
 207 017c FEFFFFEB 		bl	SensorSetIrisControl
 208              	.LVL18:
4672:../uvc.c      **** 							break;
 209              		.loc 1 4672 0
 210 0180 4B1FA0E3 		mov	r1, #300
 211              	.LVL19:
 212              	.L15:
4681:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 213              		.loc 1 4681 0
 214 0184 0020A0E3 		mov	r2, #0
 215 0188 B0009FE5 		ldr	r0, .L25+4
 216 018c FEFFFFEB 		bl	_txe_timer_change
4682:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 217              		.loc 1 4682 0
 218 0190 A8009FE5 		ldr	r0, .L25+4
 219 0194 FEFFFFEB 		bl	_txe_timer_activate
 220              	.LVL20:
4689:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 221              		.loc 1 4689 0
 222 0198 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 223 019c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 224 01a0 0A0052E1 		cmp	r2, sl
4698:../uvc.c      **** 						lcCmdDes->curNum ++;
 225              		.loc 1 4698 0
 226 01a4 01A08A12 		addne	sl, sl, #1
 227 01a8 01A0C415 		strneb	sl, [r4, #1]
 228              		.loc 1 4699 0
 229 01ac 3C808415 		strne	r8, [r4, #60]
4689:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 230              		.loc 1 4689 0
 231 01b0 1400000A 		beq	.L24
 232              	.LVL21:
 233              	.L19:
4700:../uvc.c      **** 					}
4701:../uvc.c      **** 				}else{
4702:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4703:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4704:../uvc.c      **** 				}
4705:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 234              		.loc 1 4705 0
 235 01b4 1C0095E5 		ldr	r0, [r5, #28]
 236 01b8 FEFFFFEB 		bl	_txe_mutex_put
 237              	.LVL22:
4706:../uvc.c      **** 			}
4707:../uvc.c      **** /*
4708:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4709:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4710:../uvc.c      **** */
4711:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4712:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4713:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4714:../uvc.c      **** #endif
4715:../uvc.c      **** 
4716:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4717:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4718:../uvc.c      **** #if 0
4719:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4720:../uvc.c      **** 
4721:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4722:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4723:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4724:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4725:../uvc.c      **** 			    i = 0;
4726:../uvc.c      **** 				 switch(cmdCopyIdx)
4727:../uvc.c      **** 				 {
4728:../uvc.c      **** 					 case BrgtCtlID1:
4729:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4730:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4731:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4732:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4733:../uvc.c      **** 							 i++;
4734:../uvc.c      **** 						 }
4735:../uvc.c      **** 						 else{
4736:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4737:../uvc.c      **** 						 }
4738:../uvc.c      **** 
4739:../uvc.c      **** 						 CyU3PBusyWait(500);
4740:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4741:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4742:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4743:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4744:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4745:../uvc.c      **** 						 }
4746:../uvc.c      **** 						 else{
4747:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4748:../uvc.c      **** 						 }
4749:../uvc.c      **** 						 break;
4750:../uvc.c      **** 					 case HueCtlID5:
4751:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4752:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4753:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4754:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4755:../uvc.c      **** 						 }
4756:../uvc.c      **** 						 else{
4757:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4758:../uvc.c      **** 						 }
4759:../uvc.c      **** 						 break;
4760:../uvc.c      **** 					 case SaturCtlID6:
4761:../uvc.c      **** 					 case WBTLevCtlID10:
4762:../uvc.c      **** 					 default:
4763:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4765:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4767:../uvc.c      **** 						 }
4768:../uvc.c      **** 						 else{
4769:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4770:../uvc.c      **** 						 }
4771:../uvc.c      **** 						 break;
4772:../uvc.c      **** 				 }
4773:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4774:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4775:../uvc.c      **** 			}
4776:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4777:../uvc.c      **** #endif
4778:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4779:../uvc.c      **** 		/* Allow other ready threads to run. */
4780:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4781:../uvc.c      **** 			CyU3PThreadRelinquish ();
 238              		.loc 1 4781 0
 239 01bc FEFFFFEB 		bl	_txe_thread_relinquish
4782:../uvc.c      **** 		}
 240              		.loc 1 4782 0
 241 01c0 B7FFFFEA 		b	.L20
 242              	.LVL23:
 243              	.L11:
4662:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 244              		.loc 1 4662 0
 245 01c4 5230A0E3 		mov	r3, #82
 246 01c8 FEFFFFEB 		bl	SensorSetIrisControl
 247              	.LVL24:
4664:../uvc.c      **** 							break;
 248              		.loc 1 4664 0
 249 01cc 7D1FA0E3 		mov	r1, #500
 250 01d0 EBFFFFEA 		b	.L15
 251              	.LVL25:
 252              	.L9:
4674:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 253              		.loc 1 4674 0
 254 01d4 FEFFFFEB 		bl	SensorSetControl
 255              	.LVL26:
 256 01d8 0A10A0E1 		mov	r1, sl
4675:../uvc.c      **** 							break;
 257              		.loc 1 4675 0
 258 01dc E8FFFFEA 		b	.L15
 259              	.LVL27:
 260              	.L10:
4658:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 261              		.loc 1 4658 0
 262 01e0 8230A0E3 		mov	r3, #130
 263 01e4 FEFFFFEB 		bl	SensorSetIrisControl
 264              	.LVL28:
4660:../uvc.c      **** 							break;
 265              		.loc 1 4660 0
 266 01e8 7D1FA0E3 		mov	r1, #500
 267 01ec E4FFFFEA 		b	.L15
 268              	.LVL29:
 269              	.L8:
4702:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 270              		.loc 1 4702 0
 271 01f0 FA1FA0E3 		mov	r1, #1000
 272 01f4 44009FE5 		ldr	r0, .L25+4
 273 01f8 FEFFFFEB 		bl	_txe_timer_change
4703:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 274              		.loc 1 4703 0
 275 01fc 3C009FE5 		ldr	r0, .L25+4
 276 0200 FEFFFFEB 		bl	_txe_timer_activate
 277 0204 EAFFFFEA 		b	.L19
 278              	.LVL30:
 279              	.L24:
4691:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 280              		.loc 1 4691 0
 281 0208 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4690:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 282              		.loc 1 4690 0
 283 020c 3C9084E5 		str	r9, [r4, #60]
4691:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 284              		.loc 1 4691 0
 285 0210 23005CE3 		cmp	ip, #35
4692:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 286              		.loc 1 4692 0
 287 0214 24C04C82 		subhi	ip, ip, #36
 288 0218 8CC08C80 		addhi	ip, ip, ip, asl #1
4694:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 289              		.loc 1 4694 0
 290 021c 8CC08C90 		addls	ip, ip, ip, asl #1
4692:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 291              		.loc 1 4692 0
 292 0220 8CC18B80 		addhi	ip, fp, ip, asl #3
4694:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 293              		.loc 1 4694 0
 294 0224 8CC18B90 		addls	ip, fp, ip, asl #3
4692:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 295              		.loc 1 4692 0
 296 0228 1090CC85 		strhib	r9, [ip, #16]
4694:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 297              		.loc 1 4694 0
 298 022c 9091CC95 		strlsb	r9, [ip, #400]
4696:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 299              		.loc 1 4696 0
 300 0230 344094E5 		ldr	r4, [r4, #52]
 301              	.LVL31:
 302 0234 104085E5 		str	r4, [r5, #16]
 303 0238 DDFFFFEA 		b	.L19
 304              	.L26:
 305              		.align	2
 306              	.L25:
 307 023c 00000000 		.word	I2CCmdCb
 308 0240 00000000 		.word	I2CCmdTimer
 309 0244 00000000 		.word	.LC0
 310 0248 00000000 		.word	cmdQu
 311 024c 14000000 		.word	.LC1
 312 0250 00000000 		.word	statQu
 313 0254 00000000 		.word	.LANCHOR1
 314 0258 00000000 		.word	.LANCHOR0
 315              		.cfi_endproc
 316              	.LFE27:
 318              		.align	2
 320              	CyFxUvcAppDebugCallback:
 321              	.LFB16:
2599:../uvc.c      **** {
 322              		.loc 1 2599 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 0
 325              		@ frame_needed = 0, uses_anonymous_args = 0
 326              		@ link register save eliminated.
 327              	.LVL32:
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 328              		.loc 1 2600 0
 329 025c 080051E3 		cmp	r1, #8
 330 0260 1EFF2F11 		bxne	lr
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
 331              		.loc 1 2603 0
 332 0264 08009FE5 		ldr	r0, .L29
 333              	.LVL33:
 334 0268 1010A0E3 		mov	r1, #16
 335              	.LVL34:
 336 026c 0020A0E3 		mov	r2, #0
 337              	.LVL35:
2605:../uvc.c      **** }
 338              		.loc 1 2605 0
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
 339              		.loc 1 2603 0
 340 0270 FEFFFFEA 		b	_txe_event_flags_set
 341              	.L30:
 342              		.align	2
 343              	.L29:
 344 0274 00000000 		.word	.LANCHOR0
 345              		.cfi_endproc
 346              	.LFE16:
 348              		.align	2
 349              		.global	I2CCmdCb
 351              	I2CCmdCb:
 352              	.LFB19:
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 353              		.loc 1 3043 0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              	.LVL36:
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 358              		.loc 1 3044 0
 359 0278 28209FE5 		ldr	r2, .L32
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 360              		.loc 1 3043 0
 361 027c 0030A0E1 		mov	r3, r0
 362 0280 10402DE9 		stmfd	sp!, {r4, lr}
 363              	.LCFI2:
 364              		.cfi_def_cfa_offset 8
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 365              		.loc 1 3044 0
 366 0284 20109FE5 		ldr	r1, .L32+4
 367 0288 002092E5 		ldr	r2, [r2, #0]
 368 028c 0400A0E3 		mov	r0, #4
 369              	.LVL37:
 370              		.cfi_offset 14, -4
 371              		.cfi_offset 4, -8
 372 0290 FEFFFFEB 		bl	CyU3PDebugPrint
 373              	.LVL38:
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 374              		.loc 1 3045 0
 375 0294 14009FE5 		ldr	r0, .L32+8
 376 0298 2010A0E3 		mov	r1, #32
 377 029c 0020A0E3 		mov	r2, #0
3046:../uvc.c      **** }
 378              		.loc 1 3046 0
 379 02a0 1040BDE8 		ldmfd	sp!, {r4, lr}
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 380              		.loc 1 3045 0
 381 02a4 FEFFFFEA 		b	_txe_event_flags_set
 382              	.L33:
 383              		.align	2
 384              	.L32:
 385 02a8 00000000 		.word	posTick
 386 02ac 38000000 		.word	.LC2
 387 02b0 00000000 		.word	.LANCHOR0
 388              		.cfi_endproc
 389              	.LFE19:
 391              		.align	2
 393              	CyFxUVCApplnUSBEventCB:
 394              	.LFB9:
2090:../uvc.c      **** {
 395              		.loc 1 2090 0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 8
 398              		@ frame_needed = 0, uses_anonymous_args = 0
 399              	.LVL39:
2091:../uvc.c      ****     switch (evtype)
 400              		.loc 1 2091 0
 401 02b4 020050E3 		cmp	r0, #2
2090:../uvc.c      **** {
 402              		.loc 1 2090 0
 403 02b8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 404              	.LCFI3:
 405              		.cfi_def_cfa_offset 16
 406 02bc 0130A0E1 		mov	r3, r1
 407 02c0 10D04DE2 		sub	sp, sp, #16
 408              	.LCFI4:
 409              		.cfi_def_cfa_offset 32
2090:../uvc.c      **** {
 410              		.loc 1 2090 0
 411 02c4 0040A0E1 		mov	r4, r0
 412              		.cfi_offset 14, -4
 413              		.cfi_offset 6, -8
 414              		.cfi_offset 5, -12
 415              		.cfi_offset 4, -16
2091:../uvc.c      ****     switch (evtype)
 416              		.loc 1 2091 0
 417 02c8 3C00000A 		beq	.L37
 418 02cc 040050E3 		cmp	r0, #4
 419 02d0 2200000A 		beq	.L38
 420 02d4 010050E3 		cmp	r0, #1
 421 02d8 0100000A 		beq	.L40
 422              	.LVL40:
 423              	.L34:
2130:../uvc.c      **** }
 424              		.loc 1 2130 0
 425 02dc 10D08DE2 		add	sp, sp, #16
 426 02e0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 427              	.LVL41:
 428              	.L40:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 429              		.loc 1 2114 0
 430 02e4 4C519FE5 		ldr	r5, .L41
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 431              		.loc 1 2112 0
 432 02e8 0020A0E1 		mov	r2, r0
 433 02ec 48119FE5 		ldr	r1, .L41+4
 434              	.LVL42:
 435 02f0 0400A0E3 		mov	r0, #4
 436              	.LVL43:
 437 02f4 FEFFFFEB 		bl	CyU3PDebugPrint
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 438              		.loc 1 2113 0
 439 02f8 0400A0E1 		mov	r0, r4
 440 02fc FEFFFFEB 		bl	CyU3PGpifDisable
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 441              		.loc 1 2114 0
 442 0300 2A20D5E5 		ldrb	r2, [r5, #42]	@ zero_extendqisi2
2115:../uvc.c      ****             gpif_initialized = 0;
 443              		.loc 1 2115 0
 444 0304 00C0A0E3 		mov	ip, #0
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 445              		.loc 1 2114 0
 446 0308 04E082E3 		orr	lr, r2, #4
 447              	.LBB16:
 448              	.LBB17:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 449              		.loc 1 2074 0
 450 030c 0410A0E1 		mov	r1, r4
 451 0310 0500A0E1 		mov	r0, r5
 452 0314 0220A0E3 		mov	r2, #2
 453 0318 0C308DE2 		add	r3, sp, #12
 454              	.LBE17:
 455              	.LBE16:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 456              		.loc 1 2114 0
 457 031c 2AE0C5E5 		strb	lr, [r5, #42]
2115:../uvc.c      ****             gpif_initialized = 0;
 458              		.loc 1 2115 0
 459 0320 A8C085E5 		str	ip, [r5, #168]
2116:../uvc.c      ****             isUsbConnected = CyFalse;
 460              		.loc 1 2116 0
 461 0324 B0C085E5 		str	ip, [r5, #176]
2117:../uvc.c      ****             streamingStarted = CyFalse;
 462              		.loc 1 2117 0
 463 0328 ACC085E5 		str	ip, [r5, #172]
 464              	.LBB19:
 465              	.LBB18:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 466              		.loc 1 2074 0
 467 032c 00C08DE5 		str	ip, [sp, #0]
 468 0330 FEFFFFEB 		bl	_txe_event_flags_get
 469 0334 004050E2 		subs	r4, r0, #0
 470 0338 E7FFFF1A 		bne	.L34
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 471              		.loc 1 2077 0
 472 033c 0110E0E3 		mvn	r1, #1
 473 0340 0220A0E3 		mov	r2, #2
 474 0344 0500A0E1 		mov	r0, r5
 475              	.L39:
 476 0348 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 477              		.loc 1 2080 0
 478 034c 0500A0E1 		mov	r0, r5
 479 0350 0210A0E3 		mov	r1, #2
 480 0354 0420A0E1 		mov	r2, r4
 481 0358 FEFFFFEB 		bl	_txe_event_flags_set
 482 035c DEFFFFEA 		b	.L34
 483              	.LVL44:
 484              	.L38:
 485              	.LBE18:
 486              	.LBE19:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 487              		.loc 1 2096 0
 488 0360 D0509FE5 		ldr	r5, .L41
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 489              		.loc 1 2094 0
 490 0364 D4109FE5 		ldr	r1, .L41+8
 491              	.LVL45:
 492 0368 0020A0E1 		mov	r2, r0
 493 036c FEFFFFEB 		bl	CyU3PDebugPrint
 494              	.LVL46:
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 495              		.loc 1 2095 0
 496 0370 0100A0E3 		mov	r0, #1
 497 0374 FEFFFFEB 		bl	CyU3PGpifDisable
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 498              		.loc 1 2096 0
 499 0378 2A00D5E5 		ldrb	r0, [r5, #42]	@ zero_extendqisi2
2097:../uvc.c      ****             gpif_initialized = 0;
 500              		.loc 1 2097 0
 501 037c 00C0A0E3 		mov	ip, #0
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 502              		.loc 1 2096 0
 503 0380 01E080E3 		orr	lr, r0, #1
 504              	.LBB20:
 505              	.LBB21:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 506              		.loc 1 2074 0
 507 0384 0110A0E3 		mov	r1, #1
 508 0388 0220A0E3 		mov	r2, #2
 509 038c 0500A0E1 		mov	r0, r5
 510 0390 0C308DE2 		add	r3, sp, #12
 511              	.LBE21:
 512              	.LBE20:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 513              		.loc 1 2096 0
 514 0394 2AE0C5E5 		strb	lr, [r5, #42]
2097:../uvc.c      ****             gpif_initialized = 0;
 515              		.loc 1 2097 0
 516 0398 A8C085E5 		str	ip, [r5, #168]
2098:../uvc.c      ****             streamingStarted = CyFalse;
 517              		.loc 1 2098 0
 518 039c ACC085E5 		str	ip, [r5, #172]
 519              	.LBB23:
 520              	.LBB22:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 521              		.loc 1 2074 0
 522 03a0 00C08DE5 		str	ip, [sp, #0]
 523 03a4 FEFFFFEB 		bl	_txe_event_flags_get
 524 03a8 004050E2 		subs	r4, r0, #0
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 525              		.loc 1 2077 0
 526 03ac 0500A001 		moveq	r0, r5
 527 03b0 0110E003 		mvneq	r1, #1
 528 03b4 0220A003 		moveq	r2, #2
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 529              		.loc 1 2074 0
 530 03b8 C7FFFF1A 		bne	.L34
 531 03bc E1FFFFEA 		b	.L39
 532              	.LVL47:
 533              	.L37:
 534              	.LBE22:
 535              	.LBE23:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 536              		.loc 1 2105 0
 537 03c0 70509FE5 		ldr	r5, .L41
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 538              		.loc 1 2103 0
 539 03c4 0020A0E1 		mov	r2, r0
 540 03c8 74109FE5 		ldr	r1, .L41+12
 541              	.LVL48:
 542 03cc 0400A0E3 		mov	r0, #4
 543              	.LVL49:
 544 03d0 FEFFFFEB 		bl	CyU3PDebugPrint
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 545              		.loc 1 2104 0
 546 03d4 0100A0E3 		mov	r0, #1
 547 03d8 FEFFFFEB 		bl	CyU3PGpifDisable
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 548              		.loc 1 2105 0
 549 03dc 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2106:../uvc.c      ****             gpif_initialized = 0;
 550              		.loc 1 2106 0
 551 03e0 0060A0E3 		mov	r6, #0
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 552              		.loc 1 2105 0
 553 03e4 02C081E3 		orr	ip, r1, #2
 554              	.LBB24:
 555              	.LBB26:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 556              		.loc 1 2074 0
 557 03e8 0500A0E1 		mov	r0, r5
 558 03ec 0110A0E3 		mov	r1, #1
 559 03f0 0420A0E1 		mov	r2, r4
 560 03f4 0C308DE2 		add	r3, sp, #12
 561              	.LBE26:
 562              	.LBE24:
2106:../uvc.c      ****             gpif_initialized = 0;
 563              		.loc 1 2106 0
 564 03f8 A86085E5 		str	r6, [r5, #168]
2107:../uvc.c      ****             streamingStarted = CyFalse;
 565              		.loc 1 2107 0
 566 03fc AC6085E5 		str	r6, [r5, #172]
 567              	.LBB28:
 568              	.LBB25:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 569              		.loc 1 2074 0
 570 0400 00608DE5 		str	r6, [sp, #0]
 571              	.LBE25:
 572              	.LBE28:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 573              		.loc 1 2105 0
 574 0404 2AC0C5E5 		strb	ip, [r5, #42]
 575              	.LBB29:
 576              	.LBB27:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 577              		.loc 1 2074 0
 578 0408 FEFFFFEB 		bl	_txe_event_flags_get
 579 040c 006050E2 		subs	r6, r0, #0
 580 0410 B1FFFF1A 		bne	.L34
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 581              		.loc 1 2077 0
 582 0414 0420A0E1 		mov	r2, r4
 583 0418 0500A0E1 		mov	r0, r5
 584 041c 0110E0E3 		mvn	r1, #1
 585 0420 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 586              		.loc 1 2080 0
 587 0424 0500A0E1 		mov	r0, r5
 588 0428 0410A0E1 		mov	r1, r4
 589 042c 0620A0E1 		mov	r2, r6
 590 0430 FEFFFFEB 		bl	_txe_event_flags_set
 591 0434 A8FFFFEA 		b	.L34
 592              	.L42:
 593              		.align	2
 594              	.L41:
 595 0438 00000000 		.word	.LANCHOR0
 596 043c 94000000 		.word	.LC5
 597 0440 50000000 		.word	.LC3
 598 0444 70000000 		.word	.LC4
 599              	.LBE27:
 600              	.LBE29:
 601              		.cfi_endproc
 602              	.LFE9:
 604              		.align	2
 605              		.global	CyFxUvcApplnDmaCallback
 607              	CyFxUvcApplnDmaCallback:
 608              	.LFB11:
2301:../uvc.c      **** {
 609              		.loc 1 2301 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 0
 612              		@ frame_needed = 0, uses_anonymous_args = 0
 613              	.LVL50:
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 614              		.loc 1 2308 0
 615 0448 080051E3 		cmp	r1, #8
2301:../uvc.c      **** {
 616              		.loc 1 2301 0
 617 044c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 618              	.LCFI5:
 619              		.cfi_def_cfa_offset 20
 620 0450 0250A0E1 		mov	r5, r2
 621              		.cfi_offset 14, -4
 622              		.cfi_offset 7, -8
 623              		.cfi_offset 6, -12
 624              		.cfi_offset 5, -16
 625              		.cfi_offset 4, -20
 626 0454 0CD04DE2 		sub	sp, sp, #12
 627              	.LCFI6:
 628              		.cfi_def_cfa_offset 32
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 629              		.loc 1 2308 0
 630 0458 0B00000A 		beq	.L49
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 631              		.loc 1 2360 0
 632 045c 100051E3 		cmp	r1, #16
 633 0460 0700001A 		bne	.L43
2362:../uvc.c      ****         consCount++;
 634              		.loc 1 2362 0
 635 0464 7C319FE5 		ldr	r3, .L52
2363:../uvc.c      ****         streamingStarted = CyTrue;
 636              		.loc 1 2363 0
 637 0468 0120A0E3 		mov	r2, #1
 638              	.LVL51:
2362:../uvc.c      ****         consCount++;
 639              		.loc 1 2362 0
 640 046c B20CD3E1 		ldrh	r0, [r3, #194]
 641              	.LVL52:
2363:../uvc.c      ****         streamingStarted = CyTrue;
 642              		.loc 1 2363 0
 643 0470 AC2083E5 		str	r2, [r3, #172]
2362:../uvc.c      ****         consCount++;
 644              		.loc 1 2362 0
 645 0474 02C080E0 		add	ip, r0, r2
 646 0478 0C18A0E1 		mov	r1, ip, asl #16
 647              	.LVL53:
 648 047c 2128A0E1 		mov	r2, r1, lsr #16
 649 0480 B22CC3E1 		strh	r2, [r3, #194]	@ movhi
 650              	.L43:
2365:../uvc.c      **** }
 651              		.loc 1 2365 0
 652 0484 0CD08DE2 		add	sp, sp, #12
 653 0488 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 654              	.LVL54:
 655              	.L49:
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 656              		.loc 1 2310 0
 657 048c B420D2E1 		ldrh	r2, [r2, #4]
 658 0490 54319FE5 		ldr	r3, .L52+4
 659 0494 030052E1 		cmp	r2, r3
 660 0498 3500000A 		beq	.L50
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 661              		.loc 1 2330 0
 662 049c 006095E5 		ldr	r6, [r5, #0]
 663              	.LBB34:
 664              	.LBB36:
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 665              		.loc 1 2035 0
 666 04a0 48719FE5 		ldr	r7, .L52+8
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 667              		.loc 1 2034 0
 668 04a4 0010E0E3 		mvn	r1, #0
 669              	.LVL55:
 670              	.LBE36:
 671              	.LBE34:
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 672              		.loc 1 2330 0
 673 04a8 0C4046E2 		sub	r4, r6, #12
 674              	.LVL56:
 675              	.LBB38:
 676              	.LBB35:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 677              		.loc 1 2034 0
 678 04ac 40019FE5 		ldr	r0, .L52+12
 679              	.LVL57:
 680 04b0 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 681              		.loc 1 2035 0
 682 04b4 0400A0E1 		mov	r0, r4
 683 04b8 121D87E2 		add	r1, r7, #1152
 684 04bc 0C20A0E3 		mov	r2, #12
 685 04c0 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 686              		.loc 1 2036 0
 687 04c4 28019FE5 		ldr	r0, .L52+12
 688 04c8 FEFFFFEB 		bl	_txe_mutex_put
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 689              		.loc 1 2041 0
 690 04cc 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 691              	.LBE35:
 692              	.LBE38:
2331:../uvc.c      ****                 pb++;
 693              		.loc 1 2331 0
 694 04d0 10419FE5 		ldr	r4, .L52
 695              	.LVL58:
 696              	.LBB39:
 697              	.LBB37:
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 698              		.loc 1 2041 0
 699 04d4 02108CE3 		orr	r1, ip, #2
 700 04d8 0B1046E5 		strb	r1, [r6, #-11]
 701              	.LBE37:
 702              	.LBE39:
2331:../uvc.c      ****                 pb++;
 703              		.loc 1 2331 0
 704 04dc B60BD4E1 		ldrh	r0, [r4, #182]
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 705              		.loc 1 2337 0
 706 04e0 BA20D4E5 		ldrb	r2, [r4, #186]	@ zero_extendqisi2
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 707              		.loc 1 2332 0
 708 04e4 B410D5E1 		ldrh	r1, [r5, #4]
2331:../uvc.c      ****                 pb++;
 709              		.loc 1 2331 0
 710 04e8 013080E2 		add	r3, r0, #1
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 711              		.loc 1 2337 0
 712 04ec 0F0052E3 		cmp	r2, #15
2331:../uvc.c      ****                 pb++;
 713              		.loc 1 2331 0
 714 04f0 B63BC4E1 		strh	r3, [r4, #182]	@ movhi
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 715              		.loc 1 2332 0
 716 04f4 B81BC4E1 		strh	r1, [r4, #184]	@ movhi
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 717              		.loc 1 2337 0
 718 04f8 2E00000A 		beq	.L51
 719              	.L47:
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 720              		.loc 1 2344 0
 721 04fc 01E0A0E3 		mov	lr, #1
 722 0500 BCE084E5 		str	lr, [r4, #188]
 723              	.LVL59:
 724              	.L46:
2348:../uvc.c      ****             prodCount++;
 725              		.loc 1 2348 0
 726 0504 B0ECD4E1 		ldrh	lr, [r4, #192]
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 727              		.loc 1 2349 0
 728 0508 0C1081E2 		add	r1, r1, #12
2348:../uvc.c      ****             prodCount++;
 729              		.loc 1 2348 0
 730 050c 01308EE2 		add	r3, lr, #1
 731 0510 0308A0E1 		mov	r0, r3, asl #16
 732 0514 20C8A0E1 		mov	ip, r0, lsr #16
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 733              		.loc 1 2349 0
 734 0518 0128A0E1 		mov	r2, r1, asl #16
 735 051c 2218A0E1 		mov	r1, r2, lsr #16
 736 0520 D0009FE5 		ldr	r0, .L52+16
 737 0524 0020A0E3 		mov	r2, #0
2348:../uvc.c      ****             prodCount++;
 738              		.loc 1 2348 0
 739 0528 B0CCC4E1 		strh	ip, [r4, #192]	@ movhi
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 740              		.loc 1 2349 0
 741 052c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 742              	.LVL60:
2348:../uvc.c      ****             prodCount++;
 743              		.loc 1 2348 0
 744 0530 B0109FE5 		ldr	r1, .L52
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 745              		.loc 1 2352 0
 746 0534 002050E2 		subs	r2, r0, #0
 747 0538 D1FFFF0A 		beq	.L43
2354:../uvc.c      ****                 prodCount--;
 748              		.loc 1 2354 0
 749 053c B00CD1E1 		ldrh	r0, [r1, #192]
 750              	.LVL61:
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 751              		.loc 1 2355 0
 752 0540 B430D5E1 		ldrh	r3, [r5, #4]
2354:../uvc.c      ****                 prodCount--;
 753              		.loc 1 2354 0
 754 0544 01E040E2 		sub	lr, r0, #1
 755 0548 0EC8A0E1 		mov	ip, lr, asl #16
 756 054c 2C08A0E1 		mov	r0, ip, lsr #16
 757 0550 B00CC1E1 		strh	r0, [r1, #192]	@ movhi
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 758              		.loc 1 2355 0
 759 0554 B0ECD1E1 		ldrh	lr, [r1, #192]
 760 0558 B2CCD1E1 		ldrh	ip, [r1, #194]
 761 055c 0400A0E3 		mov	r0, #4
 762 0560 94109FE5 		ldr	r1, .L52+20
 763 0564 00E08DE5 		str	lr, [sp, #0]
 764 0568 04C08DE5 		str	ip, [sp, #4]
 765 056c FEFFFFEB 		bl	CyU3PDebugPrint
 766              	.LVL62:
 767 0570 C3FFFFEA 		b	.L43
 768              	.LVL63:
 769              	.L50:
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 770              		.loc 1 2324 0
 771 0574 006095E5 		ldr	r6, [r5, #0]
 772              	.LBB40:
 773              	.LBB41:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 774              		.loc 1 2034 0
 775 0578 0010E0E3 		mvn	r1, #0
 776              	.LVL64:
 777              	.LBE41:
 778              	.LBE40:
2325:../uvc.c      ****                 fb++;
 779              		.loc 1 2325 0
 780 057c 64409FE5 		ldr	r4, .L52
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 781              		.loc 1 2324 0
 782 0580 0C6046E2 		sub	r6, r6, #12
 783              	.LVL65:
 784              	.LBB43:
 785              	.LBB42:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 786              		.loc 1 2034 0
 787 0584 68009FE5 		ldr	r0, .L52+12
 788              	.LVL66:
 789 0588 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 790              		.loc 1 2035 0
 791 058c 6C109FE5 		ldr	r1, .L52+24
 792 0590 0600A0E1 		mov	r0, r6
 793 0594 0C20A0E3 		mov	r2, #12
 794 0598 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 795              		.loc 1 2036 0
 796 059c 50009FE5 		ldr	r0, .L52+12
 797 05a0 FEFFFFEB 		bl	_txe_mutex_put
 798              	.LBE42:
 799              	.LBE43:
2325:../uvc.c      ****                 fb++;
 800              		.loc 1 2325 0
 801 05a4 B4CBD4E1 		ldrh	ip, [r4, #180]
 802 05a8 B410D5E1 		ldrh	r1, [r5, #4]
 803 05ac 01008CE2 		add	r0, ip, #1
 804 05b0 B40BC4E1 		strh	r0, [r4, #180]	@ movhi
 805 05b4 D2FFFFEA 		b	.L46
 806              	.LVL67:
 807              	.L51:
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 808              		.loc 1 2338 0
 809 05b8 0010E0E3 		mvn	r1, #0
 810 05bc 30009FE5 		ldr	r0, .L52+12
 811 05c0 FEFFFFEB 		bl	_txe_mutex_get
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 812              		.loc 1 2339 0
 813 05c4 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 814              		.loc 1 2340 0
 815 05c8 24009FE5 		ldr	r0, .L52+12
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 816              		.loc 1 2339 0
 817 05cc DF2001E2 		and	r2, r1, #223
 818 05d0 8124C7E5 		strb	r2, [r7, #1153]
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 819              		.loc 1 2340 0
 820 05d4 FEFFFFEB 		bl	_txe_mutex_put
2341:../uvc.c      ****                 	stiflag = 0xAA;
 821              		.loc 1 2341 0
 822 05d8 5530E0E3 		mvn	r3, #85
 823 05dc BA30C4E5 		strb	r3, [r4, #186]
 824 05e0 B410D5E1 		ldrh	r1, [r5, #4]
 825 05e4 C4FFFFEA 		b	.L47
 826              	.L53:
 827              		.align	2
 828              	.L52:
 829 05e8 00000000 		.word	.LANCHOR0
 830 05ec F03F0000 		.word	16368
 831 05f0 00000000 		.word	.LANCHOR1
 832 05f4 00000000 		.word	imgHdMux
 833 05f8 00000000 		.word	glChHandleUVCStream
 834 05fc B4000000 		.word	.LC6
 835 0600 80040000 		.word	.LANCHOR1+1152
 836              		.cfi_endproc
 837              	.LFE11:
 839              		.align	2
 841              	CyFxUVCApplnUSBSetupCB:
 842              	.LFB10:
2138:../uvc.c      **** {
 843              		.loc 1 2138 0
 844              		.cfi_startproc
 845              		@ args = 0, pretend = 0, frame = 8
 846              		@ frame_needed = 0, uses_anonymous_args = 0
 847              	.LVL68:
 848 0604 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 849              	.LCFI7:
 850              		.cfi_def_cfa_offset 32
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 851              		.loc 1 2144 0
 852 0608 6C839FE5 		ldr	r8, .L83
 853              		.cfi_offset 14, -4
 854              		.cfi_offset 10, -8
 855              		.cfi_offset 9, -12
 856              		.cfi_offset 8, -16
 857              		.cfi_offset 7, -20
 858              		.cfi_offset 6, -24
 859              		.cfi_offset 5, -28
 860              		.cfi_offset 4, -32
 861 060c FF3C00E2 		and	r3, r0, #65280
 862 0610 2364A0E1 		mov	r6, r3, lsr #8
 863 0614 0060C8E5 		strb	r6, [r8, #0]
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 864              		.loc 1 2148 0
 865 0618 0630A0E1 		mov	r3, r6
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 866              		.loc 1 2143 0
 867 061c 5C439FE5 		ldr	r4, .L83+4
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 868              		.loc 1 2147 0
 869 0620 5C639FE5 		ldr	r6, .L83+8
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 870              		.loc 1 2145 0
 871 0624 5C939FE5 		ldr	r9, .L83+12
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 872              		.loc 1 2146 0
 873 0628 5CA39FE5 		ldr	sl, .L83+16
2138:../uvc.c      **** {
 874              		.loc 1 2138 0
 875 062c 18D04DE2 		sub	sp, sp, #24
 876              	.LCFI8:
 877              		.cfi_def_cfa_offset 56
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 878              		.loc 1 2147 0
 879 0630 21C8A0E1 		mov	ip, r1, lsr #16
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 880              		.loc 1 2143 0
 881 0634 FF7000E2 		and	r7, r0, #255
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 882              		.loc 1 2146 0
 883 0638 0128A0E1 		mov	r2, r1, asl #16
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 884              		.loc 1 2147 0
 885 063c B0C0C6E1 		strh	ip, [r6, #0]	@ movhi
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 886              		.loc 1 2143 0
 887 0640 0070C4E5 		strb	r7, [r4, #0]
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 888              		.loc 1 2146 0
 889 0644 22E8A0E1 		mov	lr, r2, lsr #16
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 890              		.loc 1 2145 0
 891 0648 2058A0E1 		mov	r5, r0, lsr #16
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 892              		.loc 1 2148 0
 893 064c 0720A0E1 		mov	r2, r7
 894 0650 08C08DE5 		str	ip, [sp, #8]
 895 0654 0400A0E3 		mov	r0, #4
 896              	.LVL69:
 897 0658 00C0A0E3 		mov	ip, #0
 898 065c 2C139FE5 		ldr	r1, .L83+20
 899              	.LVL70:
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 900              		.loc 1 2145 0
 901 0660 B050C9E1 		strh	r5, [r9, #0]	@ movhi
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 902              		.loc 1 2146 0
 903 0664 B0E0CAE1 		strh	lr, [sl, #0]	@ movhi
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 904              		.loc 1 2148 0
 905 0668 20408DE8 		stmia	sp, {r5, lr}	@ phole stm
 906 066c 0CC08DE5 		str	ip, [sp, #12]
 907 0670 FEFFFFEB 		bl	CyU3PDebugPrint
2150:../uvc.c      ****     if(dbgIdx < 63){
 908              		.loc 1 2150 0
 909 0674 18239FE5 		ldr	r2, .L83+24
 910 0678 8C34D2E5 		ldrb	r3, [r2, #1164]	@ zero_extendqisi2
 911 067c 3E0053E3 		cmp	r3, #62
 912 0680 0D00008A 		bhi	.L55
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
 913              		.loc 1 2151 0
 914 0684 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 915 0688 800054E3 		cmp	r4, #128
 916 068c A1005413 		cmpne	r4, #161
 917 0690 5800001A 		bne	.L77
 918              	.L56:
2159:../uvc.c      ****     switch (bmReqType)
 919              		.loc 1 2159 0
 920 0694 020054E3 		cmp	r4, #2
 921 0698 0D00000A 		beq	.L59
 922              	.L79:
 923 069c 1900009A 		bls	.L78
 924 06a0 210054E3 		cmp	r4, #33
 925 06a4 5C00000A 		beq	.L60
 926 06a8 A10054E3 		cmp	r4, #161
 927 06ac 5A00000A 		beq	.L60
 928              	.L74:
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 929              		.loc 1 2139 0
 930 06b0 0000A0E3 		mov	r0, #0
 931              	.LVL71:
 932              	.L57:
2288:../uvc.c      **** }
 933              		.loc 1 2288 0
 934 06b4 18D08DE2 		add	sp, sp, #24
 935 06b8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 936              	.LVL72:
 937              	.L55:
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 938              		.loc 1 2156 0
 939 06bc 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 940 06c0 D0029FE5 		ldr	r0, .L83+28
 941 06c4 0020E0E3 		mvn	r2, #0
2159:../uvc.c      ****     switch (bmReqType)
 942              		.loc 1 2159 0
 943 06c8 020054E3 		cmp	r4, #2
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 944              		.loc 1 2156 0
 945 06cc A720C0E5 		strb	r2, [r0, #167]
2159:../uvc.c      ****     switch (bmReqType)
 946              		.loc 1 2159 0
 947 06d0 F1FFFF1A 		bne	.L79
 948              	.L59:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 949              		.loc 1 2235 0
 950 06d4 0070D8E5 		ldrb	r7, [r8, #0]	@ zero_extendqisi2
 951 06d8 010057E3 		cmp	r7, #1
 952 06dc F3FFFF1A 		bne	.L74
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 953              		.loc 1 2237 0
 954 06e0 B080DAE1 		ldrh	r8, [sl, #0]
 955 06e4 830058E3 		cmp	r8, #131
 956 06e8 F0FFFF1A 		bne	.L74
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
 957              		.loc 1 2243 0
 958 06ec A4529FE5 		ldr	r5, .L83+28
 959 06f0 AC6095E5 		ldr	r6, [r5, #172]
 960 06f4 010056E3 		cmp	r6, #1
 961 06f8 6D00000A 		beq	.L80
 962              	.LVL73:
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
 963              		.loc 1 2276 0
 964 06fc FEFFFFEB 		bl	CyU3PUsbAckSetup
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
 965              		.loc 1 2275 0
 966 0700 0700A0E1 		mov	r0, r7
 967 0704 EAFFFFEA 		b	.L57
 968              	.LVL74:
 969              	.L78:
2159:../uvc.c      ****     switch (bmReqType)
 970              		.loc 1 2159 0
 971 0708 010054E3 		cmp	r4, #1
 972 070c E7FFFF1A 		bne	.L74
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 973              		.loc 1 2199 0
 974 0710 0010D8E5 		ldrb	r1, [r8, #0]	@ zero_extendqisi2
 975 0714 0B0051E3 		cmp	r1, #11
 976 0718 E4FFFF1A 		bne	.L74
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 977              		.loc 1 2203 0
 978 071c B030DAE1 		ldrh	r3, [sl, #0]
 979 0720 010053E3 		cmp	r3, #1
 980 0724 E1FFFF1A 		bne	.L74
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 981              		.loc 1 2203 0 is_stmt 0 discriminator 1
 982 0728 B050D9E1 		ldrh	r5, [r9, #0]
 983 072c 000055E3 		cmp	r5, #0
 984 0730 DEFFFF1A 		bne	.L74
2208:../uvc.c      ****                     gpif_initialized = 0;
 985              		.loc 1 2208 0 is_stmt 1
 986 0734 5C629FE5 		ldr	r6, .L83+28
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 987              		.loc 1 2206 0
 988 0738 5C129FE5 		ldr	r1, .L83+32
 989 073c 0400A0E3 		mov	r0, #4
 990 0740 FEFFFFEB 		bl	CyU3PDebugPrint
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 991              		.loc 1 2207 0
 992 0744 0400A0E1 		mov	r0, r4
 993 0748 FEFFFFEB 		bl	CyU3PGpifDisable
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 994              		.loc 1 2211 0
 995 074c 0410A0E1 		mov	r1, r4
2208:../uvc.c      ****                     gpif_initialized = 0;
 996              		.loc 1 2208 0
 997 0750 A85086E5 		str	r5, [r6, #168]
2209:../uvc.c      ****                     streamingStarted = CyFalse;
 998              		.loc 1 2209 0
 999 0754 AC5086E5 		str	r5, [r6, #172]
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1000              		.loc 1 2211 0
 1001 0758 8300A0E3 		mov	r0, #131
 1002 075c FEFFFFEB 		bl	CyU3PUsbSetEpNak
2212:../uvc.c      ****                     CyU3PBusyWait (100);
 1003              		.loc 1 2212 0
 1004 0760 6400A0E3 		mov	r0, #100
 1005 0764 FEFFFFEB 		bl	CyU3PBusyWait
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1006              		.loc 1 2215 0
 1007 0768 30029FE5 		ldr	r0, .L83+36
 1008 076c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1009              		.loc 1 2216 0
 1010 0770 8300A0E3 		mov	r0, #131
 1011 0774 FEFFFFEB 		bl	CyU3PUsbFlushEp
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1012              		.loc 1 2217 0
 1013 0778 0510A0E1 		mov	r1, r5
 1014 077c 8300A0E3 		mov	r0, #131
 1015 0780 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2218:../uvc.c      ****                     CyU3PBusyWait (100);
 1016              		.loc 1 2218 0
 1017 0784 6400A0E3 		mov	r0, #100
 1018 0788 FEFFFFEB 		bl	CyU3PBusyWait
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1019              		.loc 1 2221 0
 1020 078c 0510A0E1 		mov	r1, r5
 1021 0790 0420A0E1 		mov	r2, r4
 1022 0794 8300A0E3 		mov	r0, #131
 1023 0798 FEFFFFEB 		bl	CyU3PUsbStall
 1024              	.LVL75:
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
 1025              		.loc 1 2224 0
 1026 079c FEFFFFEB 		bl	CyU3PUsbAckSetup
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 1027              		.loc 1 2226 0
 1028 07a0 2A20D6E5 		ldrb	r2, [r6, #42]	@ zero_extendqisi2
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1029              		.loc 1 2227 0
 1030 07a4 C44086E5 		str	r4, [r6, #196]
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 1031              		.loc 1 2226 0
 1032 07a8 08C082E3 		orr	ip, r2, #8
 1033 07ac 2AC0C6E5 		strb	ip, [r6, #42]
 1034              	.LBB48:
 1035              	.LBB49:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1036              		.loc 1 2074 0
 1037 07b0 0600A0E1 		mov	r0, r6
 1038 07b4 0410A0E1 		mov	r1, r4
 1039 07b8 0220A0E3 		mov	r2, #2
 1040 07bc 14308DE2 		add	r3, sp, #20
 1041 07c0 00508DE5 		str	r5, [sp, #0]
 1042 07c4 FEFFFFEB 		bl	_txe_event_flags_get
 1043 07c8 005050E2 		subs	r5, r0, #0
 1044 07cc 2D00001A 		bne	.L72
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1045              		.loc 1 2077 0
 1046 07d0 0110E0E3 		mvn	r1, #1
 1047 07d4 0220A0E3 		mov	r2, #2
 1048 07d8 0600A0E1 		mov	r0, r6
 1049 07dc FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1050              		.loc 1 2080 0
 1051 07e0 0600A0E1 		mov	r0, r6
 1052 07e4 0210A0E3 		mov	r1, #2
 1053 07e8 0520A0E1 		mov	r2, r5
 1054 07ec FEFFFFEB 		bl	_txe_event_flags_set
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1055              		.loc 1 2222 0
 1056 07f0 0400A0E1 		mov	r0, r4
 1057 07f4 AEFFFFEA 		b	.L57
 1058              	.LVL76:
 1059              	.L77:
 1060              	.LBE49:
 1061              	.LBE48:
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1062              		.loc 1 2152 0
 1063 07f8 98119FE5 		ldr	r1, .L83+28
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1064              		.loc 1 2153 0
 1065 07fc 00C0D8E5 		ldrb	ip, [r8, #0]	@ zero_extendqisi2
2154:../uvc.c      **** 		dbgIdx++;
 1066              		.loc 1 2154 0
 1067 0800 010083E2 		add	r0, r3, #1
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1068              		.loc 1 2152 0
 1069 0804 833081E0 		add	r3, r1, r3, asl #1
 1070 0808 2840C3E5 		strb	r4, [r3, #40]
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1071              		.loc 1 2153 0
 1072 080c 29C0C3E5 		strb	ip, [r3, #41]
2154:../uvc.c      **** 		dbgIdx++;
 1073              		.loc 1 2154 0
 1074 0810 8C04C2E5 		strb	r0, [r2, #1164]
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
 1075              		.loc 1 2155 0
 1076 0814 A700C1E5 		strb	r0, [r1, #167]
 1077 0818 9DFFFFEA 		b	.L56
 1078              	.L60:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1079              		.loc 1 2164 0
 1080 081c 0040DAE5 		ldrb	r4, [sl, #0]	@ zero_extendqisi2
 1081 0820 000054E3 		cmp	r4, #0
 1082 0824 0F00001A 		bne	.L81
 1083              	.LVL77:
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1084              		.loc 1 2169 0
 1085 0828 0420A0E1 		mov	r2, r4
 1086 082c 64019FE5 		ldr	r0, .L83+28
 1087 0830 0410A0E3 		mov	r1, #4
 1088 0834 FEFFFFEB 		bl	_txe_event_flags_set
 1089              	.LVL78:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1090              		.loc 1 2171 0
 1091 0838 002050E2 		subs	r2, r0, #0
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1092              		.loc 1 2168 0
 1093 083c 0100A003 		moveq	r0, #1
 1094              	.LVL79:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1095              		.loc 1 2171 0
 1096 0840 9BFFFF0A 		beq	.L57
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1097              		.loc 1 2173 0
 1098 0844 58119FE5 		ldr	r1, .L83+40
 1099 0848 0400A0E3 		mov	r0, #4
 1100 084c FEFFFFEB 		bl	CyU3PDebugPrint
 1101              	.LVL80:
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1102              		.loc 1 2174 0
 1103 0850 0400A0E1 		mov	r0, r4
 1104 0854 0110A0E3 		mov	r1, #1
 1105 0858 0420A0E1 		mov	r2, r4
 1106 085c FEFFFFEB 		bl	CyU3PUsbStall
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1107              		.loc 1 2168 0
 1108 0860 0100A0E3 		mov	r0, #1
 1109 0864 92FFFFEA 		b	.L57
 1110              	.LVL81:
 1111              	.L81:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1112              		.loc 1 2164 0
 1113 0868 010054E3 		cmp	r4, #1
 1114 086c 8FFFFF1A 		bne	.L74
 1115              	.LVL82:
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1116              		.loc 1 2182 0
 1117 0870 0020A0E3 		mov	r2, #0
 1118 0874 1C019FE5 		ldr	r0, .L83+28
 1119 0878 0810A0E3 		mov	r1, #8
 1120 087c FEFFFFEB 		bl	_txe_event_flags_set
 1121              	.LVL83:
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1122              		.loc 1 2184 0
 1123 0880 002050E2 		subs	r2, r0, #0
 1124 0884 0100001A 		bne	.L82
 1125              	.LVL84:
 1126              	.L72:
 1127              	.LBB51:
 1128              	.LBB50:
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1129              		.loc 1 2222 0
 1130 0888 0400A0E1 		mov	r0, r4
 1131 088c 88FFFFEA 		b	.L57
 1132              	.LVL85:
 1133              	.L82:
 1134              	.LBE50:
 1135              	.LBE51:
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1136              		.loc 1 2187 0
 1137 0890 10119FE5 		ldr	r1, .L83+44
 1138 0894 0400A0E3 		mov	r0, #4
 1139              	.LVL86:
 1140 0898 FEFFFFEB 		bl	CyU3PDebugPrint
 1141              	.LVL87:
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1142              		.loc 1 2188 0
 1143 089c 0000A0E3 		mov	r0, #0
 1144 08a0 0410A0E1 		mov	r1, r4
 1145 08a4 0020A0E1 		mov	r2, r0
 1146 08a8 FEFFFFEB 		bl	CyU3PUsbStall
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1147              		.loc 1 2181 0
 1148 08ac 0400A0E1 		mov	r0, r4
 1149 08b0 7FFFFFEA 		b	.L57
 1150              	.LVL88:
 1151              	.L80:
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1152              		.loc 1 2245 0
 1153 08b4 F0109FE5 		ldr	r1, .L83+48
 1154 08b8 0400A0E3 		mov	r0, #4
 1155 08bc FEFFFFEB 		bl	CyU3PDebugPrint
2249:../uvc.c      ****                         gpif_initialized = 0;
 1156              		.loc 1 2249 0
 1157 08c0 0070A0E3 		mov	r7, #0
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1158              		.loc 1 2248 0
 1159 08c4 0600A0E1 		mov	r0, r6
 1160 08c8 FEFFFFEB 		bl	CyU3PGpifDisable
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1161              		.loc 1 2253 0
 1162 08cc 0610A0E1 		mov	r1, r6
2249:../uvc.c      ****                         gpif_initialized = 0;
 1163              		.loc 1 2249 0
 1164 08d0 A87085E5 		str	r7, [r5, #168]
2250:../uvc.c      ****                         streamingStarted = CyFalse;
 1165              		.loc 1 2250 0
 1166 08d4 AC7085E5 		str	r7, [r5, #172]
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1167              		.loc 1 2253 0
 1168 08d8 0800A0E1 		mov	r0, r8
 1169 08dc FEFFFFEB 		bl	CyU3PUsbSetEpNak
2254:../uvc.c      ****                         CyU3PBusyWait (100);
 1170              		.loc 1 2254 0
 1171 08e0 6400A0E3 		mov	r0, #100
 1172 08e4 FEFFFFEB 		bl	CyU3PBusyWait
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1173              		.loc 1 2257 0
 1174 08e8 B0009FE5 		ldr	r0, .L83+36
 1175 08ec FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1176              		.loc 1 2258 0
 1177 08f0 0800A0E1 		mov	r0, r8
 1178 08f4 FEFFFFEB 		bl	CyU3PUsbFlushEp
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1179              		.loc 1 2259 0
 1180 08f8 0710A0E1 		mov	r1, r7
 1181 08fc 0800A0E1 		mov	r0, r8
 1182 0900 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2260:../uvc.c      ****                         CyU3PBusyWait (100);
 1183              		.loc 1 2260 0
 1184 0904 6400A0E3 		mov	r0, #100
 1185 0908 FEFFFFEB 		bl	CyU3PBusyWait
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1186              		.loc 1 2263 0
 1187 090c 0710A0E1 		mov	r1, r7
 1188 0910 0620A0E1 		mov	r2, r6
 1189 0914 0800A0E1 		mov	r0, r8
 1190 0918 FEFFFFEB 		bl	CyU3PUsbStall
 1191              	.LVL89:
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1192              		.loc 1 2267 0
 1193 091c FEFFFFEB 		bl	CyU3PUsbAckSetup
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1194              		.loc 1 2270 0
 1195 0920 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1196              		.loc 1 2269 0
 1197 0924 C46085E5 		str	r6, [r5, #196]
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1198              		.loc 1 2270 0
 1199 0928 10C081E3 		orr	ip, r1, #16
 1200 092c 2AC0C5E5 		strb	ip, [r5, #42]
 1201              	.LBB52:
 1202              	.LBB53:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1203              		.loc 1 2074 0
 1204 0930 0500A0E1 		mov	r0, r5
 1205 0934 0610A0E1 		mov	r1, r6
 1206 0938 0420A0E1 		mov	r2, r4
 1207 093c 14308DE2 		add	r3, sp, #20
 1208 0940 00708DE5 		str	r7, [sp, #0]
 1209 0944 FEFFFFEB 		bl	_txe_event_flags_get
 1210 0948 007050E2 		subs	r7, r0, #0
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1211              		.loc 1 2265 0
 1212 094c 0600A011 		movne	r0, r6
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1213              		.loc 1 2074 0
 1214 0950 57FFFF1A 		bne	.L57
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1215              		.loc 1 2077 0
 1216 0954 0110E0E3 		mvn	r1, #1
 1217 0958 0420A0E1 		mov	r2, r4
 1218 095c 0500A0E1 		mov	r0, r5
 1219 0960 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1220              		.loc 1 2080 0
 1221 0964 0500A0E1 		mov	r0, r5
 1222 0968 0410A0E1 		mov	r1, r4
 1223 096c 0720A0E1 		mov	r2, r7
 1224 0970 FEFFFFEB 		bl	_txe_event_flags_set
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1225              		.loc 1 2265 0
 1226 0974 0600A0E1 		mov	r0, r6
 1227 0978 4DFFFFEA 		b	.L57
 1228              	.L84:
 1229              		.align	2
 1230              	.L83:
 1231 097c 00000000 		.word	bRequest
 1232 0980 00000000 		.word	bmReqType
 1233 0984 00000000 		.word	wLength
 1234 0988 00000000 		.word	wValue
 1235 098c 00000000 		.word	wIndex
 1236 0990 00010000 		.word	.LC7
 1237 0994 00000000 		.word	.LANCHOR1
 1238 0998 00000000 		.word	.LANCHOR0
 1239 099c C8010000 		.word	.LC10
 1240 09a0 00000000 		.word	glChHandleUVCStream
 1241 09a4 5C010000 		.word	.LC8
 1242 09a8 94010000 		.word	.LC9
 1243 09ac E0010000 		.word	.LC11
 1244              	.LBE53:
 1245              	.LBE52:
 1246              		.cfi_endproc
 1247              	.LFE10:
 1249              		.align	2
 1250              		.global	CyFxGpifCB
 1252              	CyFxGpifCB:
 1253              	.LFB13:
2487:../uvc.c      **** {
 1254              		.loc 1 2487 0
 1255              		.cfi_startproc
 1256              		@ args = 0, pretend = 0, frame = 0
 1257              		@ frame_needed = 0, uses_anonymous_args = 0
 1258              	.LVL90:
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1259              		.loc 1 2488 0
 1260 09b0 010050E3 		cmp	r0, #1
2487:../uvc.c      **** {
 1261              		.loc 1 2487 0
 1262 09b4 10402DE9 		stmfd	sp!, {r4, lr}
 1263              	.LCFI9:
 1264              		.cfi_def_cfa_offset 8
2487:../uvc.c      **** {
 1265              		.loc 1 2487 0
 1266 09b8 0120A0E1 		mov	r2, r1
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1267              		.loc 1 2488 0
 1268 09bc 1080BD18 		ldmnefd	sp!, {r4, pc}
 1269              		.cfi_offset 14, -4
 1270              		.cfi_offset 4, -8
 1271              	.LVL91:
 1272              	.LBB58:
 1273              	.LBB59:
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1274              		.loc 1 2385 0
 1275 09c0 CC309FE5 		ldr	r3, .L100
 1276 09c4 C830D3E5 		ldrb	r3, [r3, #200]	@ zero_extendqisi2
 1277 09c8 030053E3 		cmp	r3, #3
 1278 09cc 2100000A 		beq	.L99
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1279              		.loc 1 2411 0
 1280 09d0 020053E3 		cmp	r3, #2
 1281 09d4 1080BD18 		ldmnefd	sp!, {r4, pc}
2413:../uvc.c      ****         switch (stateId)
 1282              		.loc 1 2413 0
 1283 09d8 080041E2 		sub	r0, r1, #8
 1284              	.LVL92:
 1285 09dc 0A0050E3 		cmp	r0, #10
 1286 09e0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1287 09e4 230000EA 		b	.L92
 1288              	.L94:
 1289 09e8 180A0000 		.word	.L89
 1290 09ec 780A0000 		.word	.L92
 1291 09f0 780A0000 		.word	.L92
 1292 09f4 140A0000 		.word	.L85
 1293 09f8 780A0000 		.word	.L92
 1294 09fc 780A0000 		.word	.L92
 1295 0a00 780A0000 		.word	.L92
 1296 0a04 500A0000 		.word	.L98
 1297 0a08 780A0000 		.word	.L92
 1298 0a0c 780A0000 		.word	.L92
 1299 0a10 140A0000 		.word	.L85
 1300              	.LVL93:
 1301              	.L85:
 1302 0a14 1080BDE8 		ldmfd	sp!, {r4, pc}
 1303              	.LVL94:
 1304              	.L89:
2396:../uvc.c      ****                 socket = 0;
 1305              		.loc 1 2396 0
 1306 0a18 0010A0E3 		mov	r1, #0
 1307              	.LVL95:
 1308              	.L90:
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1309              		.loc 1 2470 0
 1310 0a1c 74009FE5 		ldr	r0, .L100+4
 1311 0a20 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1312              	.LVL96:
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1313              		.loc 1 2471 0
 1314 0a24 002050E2 		subs	r2, r0, #0
 1315 0a28 F9FFFF0A 		beq	.L85
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1316              		.loc 1 2473 0
 1317 0a2c 0400A0E3 		mov	r0, #4
 1318              	.LVL97:
 1319 0a30 64109FE5 		ldr	r1, .L100+8
 1320 0a34 FEFFFFEB 		bl	CyU3PDebugPrint
 1321              	.LVL98:
 1322              	.L95:
 1323              	.LBB60:
 1324              	.LBB61:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1325              		.loc 1 2061 0
 1326 0a38 60109FE5 		ldr	r1, .L100+12
 1327 0a3c 0400A0E3 		mov	r0, #4
 1328 0a40 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 1329              		.loc 1 2062 0
 1330 0a44 FA0FA0E3 		mov	r0, #1000
 1331 0a48 FEFFFFEB 		bl	_tx_thread_sleep
 1332 0a4c F9FFFFEA 		b	.L95
 1333              	.LVL99:
 1334              	.L98:
 1335              	.LBE61:
 1336              	.LBE60:
2440:../uvc.c      ****                 socket = 1;
 1337              		.loc 1 2440 0
 1338 0a50 0110A0E3 		mov	r1, #1
 1339              	.LVL100:
 1340 0a54 F0FFFFEA 		b	.L90
 1341              	.LVL101:
 1342              	.L99:
2387:../uvc.c      ****         switch (stateId)
 1343              		.loc 1 2387 0
 1344 0a58 0B2041E2 		sub	r2, r1, #11
 1345 0a5c 030052E3 		cmp	r2, #3
 1346 0a60 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1347 0a64 060000EA 		b	.L88
 1348              	.L91:
 1349 0a68 180A0000 		.word	.L89
 1350 0a6c 500A0000 		.word	.L98
 1351 0a70 140A0000 		.word	.L85
 1352 0a74 140A0000 		.word	.L85
 1353              	.LVL102:
 1354              	.L92:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1355              		.loc 1 2459 0
 1356 0a78 24109FE5 		ldr	r1, .L100+16
 1357              	.LVL103:
 1358 0a7c 0100A0E3 		mov	r0, #1
 1359 0a80 FEFFFFEB 		bl	CyU3PDebugPrint
 1360              	.LVL104:
 1361              	.L88:
 1362              	.LBE59:
 1363              	.LBE58:
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1364              		.loc 1 2494 0
 1365 0a84 1C109FE5 		ldr	r1, .L100+20
 1366 0a88 0400A0E3 		mov	r0, #4
2497:../uvc.c      **** }
 1367              		.loc 1 2497 0
 1368 0a8c 1040BDE8 		ldmfd	sp!, {r4, lr}
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1369              		.loc 1 2494 0
 1370 0a90 FEFFFFEA 		b	CyU3PDebugPrint
 1371              	.L101:
 1372              		.align	2
 1373              	.L100:
 1374 0a94 00000000 		.word	.LANCHOR0
 1375 0a98 00000000 		.word	glChHandleUVCStream
 1376 0a9c 1C020000 		.word	.LC13
 1377 0aa0 4C020000 		.word	.LC14
 1378 0aa4 04020000 		.word	.LC12
 1379 0aa8 60020000 		.word	.LC15
 1380              		.cfi_endproc
 1381              	.LFE13:
 1383              		.align	2
 1384              		.global	I2CCmdHandler
 1386              	I2CCmdHandler:
 1387              	.LFB0:
 615:../uvc.c      **** void I2CCmdHandler(){
 1388              		.loc 1 615 0
 1389              		.cfi_startproc
 1390              		@ args = 0, pretend = 0, frame = 16
 1391              		@ frame_needed = 0, uses_anonymous_args = 0
 1392 0aac F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1393              	.LCFI10:
 1394              		.cfi_def_cfa_offset 36
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1395              		.loc 1 618 0
 1396 0ab0 44439FE5 		ldr	r4, .L127
 1397              		.cfi_offset 14, -4
 1398              		.cfi_offset 11, -8
 1399              		.cfi_offset 10, -12
 1400              		.cfi_offset 9, -16
 1401              		.cfi_offset 8, -20
 1402              		.cfi_offset 7, -24
 1403              		.cfi_offset 6, -28
 1404              		.cfi_offset 5, -32
 1405              		.cfi_offset 4, -36
 615:../uvc.c      **** void I2CCmdHandler(){
 1406              		.loc 1 615 0
 1407 0ab4 3CD04DE2 		sub	sp, sp, #60
 1408              	.LCFI11:
 1409              		.cfi_def_cfa_offset 96
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1410              		.loc 1 623 0
 1411 0ab8 D310D4E5 		ldrb	r1, [r4, #211]	@ zero_extendqisi2
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1412              		.loc 1 618 0
 1413 0abc CC50D4E5 		ldrb	r5, [r4, #204]	@ zero_extendqisi2
 1414              	.LVL105:
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1415              		.loc 1 619 0
 1416 0ac0 CD70D4E5 		ldrb	r7, [r4, #205]	@ zero_extendqisi2
 1417              	.LVL106:
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1418              		.loc 1 620 0
 1419 0ac4 D460D4E5 		ldrb	r6, [r4, #212]	@ zero_extendqisi2
 1420              	.LVL107:
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1421              		.loc 1 623 0
 1422 0ac8 CEE0D4E5 		ldrb	lr, [r4, #206]	@ zero_extendqisi2
 1423 0acc CF80D4E5 		ldrb	r8, [r4, #207]	@ zero_extendqisi2
 1424 0ad0 D0A0D4E5 		ldrb	sl, [r4, #208]	@ zero_extendqisi2
 1425 0ad4 D190D4E5 		ldrb	r9, [r4, #209]	@ zero_extendqisi2
 1426 0ad8 D2B0D4E5 		ldrb	fp, [r4, #210]	@ zero_extendqisi2
 1427 0adc 14108DE5 		str	r1, [sp, #20]
 1428 0ae0 D530D4E5 		ldrb	r3, [r4, #213]	@ zero_extendqisi2
 1429 0ae4 0400A0E3 		mov	r0, #4
 1430 0ae8 1C308DE5 		str	r3, [sp, #28]
 1431 0aec D6C0D4E5 		ldrb	ip, [r4, #214]	@ zero_extendqisi2
 1432 0af0 0730A0E1 		mov	r3, r7
 1433 0af4 04139FE5 		ldr	r1, .L127+4
 1434 0af8 0520A0E1 		mov	r2, r5
 1435 0afc 00E08DE5 		str	lr, [sp, #0]
 1436 0b00 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1437 0b04 0C908DE5 		str	r9, [sp, #12]
 1438 0b08 10B08DE5 		str	fp, [sp, #16]
 1439 0b0c 18608DE5 		str	r6, [sp, #24]
 1440 0b10 20C08DE5 		str	ip, [sp, #32]
 1441 0b14 FEFFFFEB 		bl	CyU3PDebugPrint
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1442              		.loc 1 626 0
 1443 0b18 CE30D4E5 		ldrb	r3, [r4, #206]	@ zero_extendqisi2
 1444 0b1c 700053E3 		cmp	r3, #112
 1445 0b20 1100000A 		beq	.L120
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 1446              		.loc 1 637 0
 1447 0b24 000055E3 		cmp	r5, #0
 1448 0b28 0300000A 		beq	.L121
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 1449              		.loc 1 672 0
 1450 0b2c 010055E3 		cmp	r5, #1
 1451 0b30 2E00000A 		beq	.L122
 1452              	.LVL108:
 1453              	.L102:
 728:../uvc.c      **** }
 1454              		.loc 1 728 0
 1455 0b34 3CD08DE2 		add	sp, sp, #60
 1456 0b38 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1457              	.LVL109:
 1458              	.L121:
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1459              		.loc 1 639 0
 1460 0b3c CF20D4E5 		ldrb	r2, [r4, #207]	@ zero_extendqisi2
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1461              		.loc 1 638 0
 1462 0b40 0F00A0E3 		mov	r0, #15
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1463              		.loc 1 639 0
 1464 0b44 000052E3 		cmp	r2, #0
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1465              		.loc 1 638 0
 1466 0b48 D700C4E5 		strb	r0, [r4, #215]
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1467              		.loc 1 639 0
 1468 0b4c 1F00001A 		bne	.L107
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 1469              		.loc 1 640 0
 1470 0b50 000053E3 		cmp	r3, #0
 1471 0b54 3200001A 		bne	.L108
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1472              		.loc 1 641 0
 1473 0b58 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1474              		.loc 1 642 0
 1475 0b5c 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1476              		.loc 1 641 0
 1477 0b60 D620C4E5 		strb	r2, [r4, #214]
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1478              		.loc 1 642 0
 1479 0b64 D5C0C4E5 		strb	ip, [r4, #213]
 1480 0b68 150000EA 		b	.L114
 1481              	.L120:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1482              		.loc 1 626 0 discriminator 1
 1483 0b6c CF00D4E5 		ldrb	r0, [r4, #207]	@ zero_extendqisi2
 1484 0b70 520050E3 		cmp	r0, #82
 1485 0b74 3400000A 		beq	.L123
 1486              	.L104:
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1487              		.loc 1 683 0
 1488 0b78 000055E3 		cmp	r5, #0
 1489 0b7c 5400001A 		bne	.L113
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1490              		.loc 1 699 0
 1491 0b80 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1492 0b84 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1493              		.loc 1 685 0
 1494 0b88 0FC0A0E3 		mov	ip, #15
 1495 0b8c D7C0C4E5 		strb	ip, [r4, #215]
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1496              		.loc 1 699 0
 1497 0b90 D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1498 0b94 D130D4E5 		ldrb	r3, [r4, #209]	@ zero_extendqisi2
 1499 0b98 34E08DE2 		add	lr, sp, #52
 1500 0b9c 010080E3 		orr	r0, r0, #1
 1501 0ba0 011081E3 		orr	r1, r1, #1
 1502 0ba4 00E08DE5 		str	lr, [sp, #0]
 1503 0ba8 FEFFFFEB 		bl	SensorRead2B
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1504              		.loc 1 700 0
 1505 0bac 34C0DDE5 		ldrb	ip, [sp, #52]	@ zero_extendqisi2
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 1506              		.loc 1 701 0
 1507 0bb0 020056E3 		cmp	r6, #2
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1508              		.loc 1 700 0
 1509 0bb4 D5C0C4E5 		strb	ip, [r4, #213]
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1510              		.loc 1 702 0
 1511 0bb8 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1512 0bbc 38C29F05 		ldreq	ip, .L127
 1513 0bc0 D600CC05 		streqb	r0, [ip, #214]
 1514              	.LVL110:
 1515              	.L114:
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1516              		.loc 1 704 0
 1517 0bc4 0020E0E3 		mvn	r2, #0
 1518 0bc8 D720C4E5 		strb	r2, [r4, #215]
 1519 0bcc D8FFFFEA 		b	.L102
 1520              	.LVL111:
 1521              	.L107:
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 1522              		.loc 1 662 0
 1523 0bd0 010052E3 		cmp	r2, #1
 1524 0bd4 FAFFFF1A 		bne	.L114
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1525              		.loc 1 664 0
 1526 0bd8 83C084E0 		add	ip, r4, r3, asl #1
 1527 0bdc DC00DCE5 		ldrb	r0, [ip, #220]	@ zero_extendqisi2
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1528              		.loc 1 665 0
 1529 0be0 DD10DCE5 		ldrb	r1, [ip, #221]	@ zero_extendqisi2
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1530              		.loc 1 664 0
 1531 0be4 D500C4E5 		strb	r0, [r4, #213]
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1532              		.loc 1 665 0
 1533 0be8 D610C4E5 		strb	r1, [r4, #214]
 1534 0bec F4FFFFEA 		b	.L114
 1535              	.L122:
 676:../uvc.c      **** 			dbgIdx = 2;
 1536              		.loc 1 676 0
 1537 0bf0 0C229FE5 		ldr	r2, .L127+8
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1538              		.loc 1 673 0
 1539 0bf4 0010A0E3 		mov	r1, #0
 676:../uvc.c      **** 			dbgIdx = 2;
 1540              		.loc 1 676 0
 1541 0bf8 0230A0E3 		mov	r3, #2
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1542              		.loc 1 673 0
 1543 0bfc 2810C4E5 		strb	r1, [r4, #40]
 1544 0c00 2910C4E5 		strb	r1, [r4, #41]
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 1545              		.loc 1 674 0
 1546 0c04 2A10C4E5 		strb	r1, [r4, #42]
 1547 0c08 2B10C4E5 		strb	r1, [r4, #43]
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 1548              		.loc 1 675 0
 1549 0c0c 4610C4E5 		strb	r1, [r4, #70]
 1550 0c10 4710C4E5 		strb	r1, [r4, #71]
 676:../uvc.c      **** 			dbgIdx = 2;
 1551              		.loc 1 676 0
 1552 0c14 8C34C2E5 		strb	r3, [r2, #1164]
 677:../uvc.c      **** 			valIdx = 1;
 1553              		.loc 1 677 0
 1554 0c18 8E54C2E5 		strb	r5, [r2, #1166]
 678:../uvc.c      **** 			value[0][1] = valIdx;
 1555              		.loc 1 678 0
 1556 0c1c DD50C4E5 		strb	r5, [r4, #221]
 1557 0c20 C3FFFFEA 		b	.L102
 1558              	.L108:
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 1559              		.loc 1 644 0
 1560 0c24 010053E3 		cmp	r3, #1
 1561 0c28 1A00000A 		beq	.L124
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 1562              		.loc 1 648 0
 1563 0c2c 110053E3 		cmp	r3, #17
 1564 0c30 1E00000A 		beq	.L125
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1565              		.loc 1 659 0
 1566 0c34 833084E0 		add	r3, r4, r3, asl #1
 1567 0c38 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1568              		.loc 1 660 0
 1569 0c3c 29C0D3E5 		ldrb	ip, [r3, #41]	@ zero_extendqisi2
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1570              		.loc 1 659 0
 1571 0c40 D520C4E5 		strb	r2, [r4, #213]
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1572              		.loc 1 660 0
 1573 0c44 D6C0C4E5 		strb	ip, [r4, #214]
 1574 0c48 DDFFFFEA 		b	.L114
 1575              	.L123:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1576              		.loc 1 626 0 discriminator 1
 1577 0c4c D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1578 0c50 300052E3 		cmp	r2, #48
 1579 0c54 C7FFFF1A 		bne	.L104
 1580 0c58 D1C0D4E5 		ldrb	ip, [r4, #209]	@ zero_extendqisi2
 1581 0c5c 01005CE3 		cmp	ip, #1
 1582 0c60 C4FFFF1A 		bne	.L104
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1583              		.loc 1 628 0
 1584 0c64 D520D4E5 		ldrb	r2, [r4, #213]	@ zero_extendqisi2
 1585 0c68 94E19FE5 		ldr	lr, .L127+8
 1586 0c6c 031002E2 		and	r1, r2, #3
 1587 0c70 8D14CEE5 		strb	r1, [lr, #1165]
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1588              		.loc 1 629 0
 1589 0c74 D83094E5 		ldr	r3, [r4, #216]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1590              		.loc 1 633 0
 1591 0c78 88119FE5 		ldr	r1, .L127+12
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1592              		.loc 1 629 0
 1593 0c7c 000053E3 		cmp	r3, #0
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1594              		.loc 1 631 0
 1595 0c80 80208203 		orreq	r2, r2, #128
 1596 0c84 D520C405 		streqb	r2, [r4, #213]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1597              		.loc 1 633 0
 1598 0c88 8D34DEE5 		ldrb	r3, [lr, #1165]	@ zero_extendqisi2
 1599 0c8c 0400A0E3 		mov	r0, #4
 1600 0c90 FEFFFFEB 		bl	CyU3PDebugPrint
 1601 0c94 B7FFFFEA 		b	.L104
 1602              	.L124:
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1603              		.loc 1 646 0
 1604 0c98 64019FE5 		ldr	r0, .L127+8
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1605              		.loc 1 645 0
 1606 0c9c 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1607              		.loc 1 646 0
 1608 0ca0 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1609              		.loc 1 645 0
 1610 0ca4 D510C4E5 		strb	r1, [r4, #213]
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1611              		.loc 1 646 0
 1612 0ca8 D630C4E5 		strb	r3, [r4, #214]
 1613 0cac C4FFFFEA 		b	.L114
 1614              	.L125:
 1615              	.LVL112:
 1616              	.LBB62:
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 1617              		.loc 1 650 0
 1618 0cb0 0400A0E1 		mov	r0, r4
 1619 0cb4 0110A0E3 		mov	r1, #1
 1620 0cb8 FEFFFFEB 		bl	_txe_event_flags_set
 1621              	.LVL113:
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 1622              		.loc 1 652 0
 1623 0cbc 002050E2 		subs	r2, r0, #0
 1624 0cc0 BFFFFF0A 		beq	.L114
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 1625              		.loc 1 654 0
 1626 0cc4 40119FE5 		ldr	r1, .L127+16
 1627 0cc8 0400A0E3 		mov	r0, #4
 1628              	.LVL114:
 1629 0ccc FEFFFFEB 		bl	CyU3PDebugPrint
 1630              	.LVL115:
 1631 0cd0 BBFFFFEA 		b	.L114
 1632              	.L113:
 1633              	.LBE62:
 708:../uvc.c      **** 	}else if(CmdType == 1){
 1634              		.loc 1 708 0
 1635 0cd4 010055E3 		cmp	r5, #1
 1636 0cd8 95FFFF1A 		bne	.L102
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 1637              		.loc 1 710 0
 1638 0cdc 020057E3 		cmp	r7, #2
 1639 0ce0 2400000A 		beq	.L126
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1640              		.loc 1 715 0
 1641 0ce4 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1642 0ce8 0C319FE5 		ldr	r3, .L127
 1643 0cec FE1001E2 		and	r1, r1, #254
 1644 0cf0 820051E3 		cmp	r1, #130
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1645              		.loc 1 718 0
 1646 0cf4 D050D315 		ldrneb	r5, [r3, #208]	@ zero_extendqisi2
 1647              	.LVL116:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1648              		.loc 1 715 0
 1649 0cf8 0200001A 		bne	.L119
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1650              		.loc 1 715 0 is_stmt 0 discriminator 1
 1651 0cfc D050D3E5 		ldrb	r5, [r3, #208]	@ zero_extendqisi2
 1652 0d00 300055E3 		cmp	r5, #48
 1653 0d04 0700000A 		beq	.L117
 1654              	.L119:
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1655              		.loc 1 718 0 is_stmt 1
 1656 0d08 D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1657              	.L118:
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1658              		.loc 1 720 0
 1659 0d0c CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1660 0d10 D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1661 0d14 0520A0E1 		mov	r2, r5
 1662 0d18 FE0000E2 		and	r0, r0, #254
 1663 0d1c 00E08DE5 		str	lr, [sp, #0]
 1664 0d20 FEFFFFEB 		bl	SensorWrite2B
 1665 0d24 82FFFFEA 		b	.L102
 1666              	.L117:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1667              		.loc 1 715 0 discriminator 1
 1668 0d28 D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1669 0d2c 100053E3 		cmp	r3, #16
 1670 0d30 F5FFFF1A 		bne	.L118
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1671              		.loc 1 716 0
 1672 0d34 D4409FE5 		ldr	r4, .L127+20
 1673 0d38 0010E0E3 		mvn	r1, #0
 1674 0d3c 1C0094E5 		ldr	r0, [r4, #28]
 1675 0d40 2C308DE5 		str	r3, [sp, #44]
 1676 0d44 FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1677              		.loc 1 717 0
 1678 0d48 2C309DE5 		ldr	r3, [sp, #44]
 1679 0d4c 00C0A0E3 		mov	ip, #0
 1680 0d50 0320A0E1 		mov	r2, r3
 1681 0d54 0400A0E1 		mov	r0, r4
 1682 0d58 1710A0E3 		mov	r1, #23
 1683 0d5c 0530A0E1 		mov	r3, r5
 1684 0d60 00C08DE5 		str	ip, [sp, #0]
 1685 0d64 04C08DE5 		str	ip, [sp, #4]
 1686 0d68 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1687              		.loc 1 718 0
 1688 0d6c 1C0094E5 		ldr	r0, [r4, #28]
 1689 0d70 FEFFFFEB 		bl	_txe_mutex_put
 1690 0d74 6EFFFFEA 		b	.L102
 1691              	.LVL117:
 1692              	.L126:
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1693              		.loc 1 712 0
 1694 0d78 CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1695 0d7c D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1696 0d80 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1697 0d84 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1698 0d88 FE0002E2 		and	r0, r2, #254
 1699 0d8c 0020A0E3 		mov	r2, #0
 1700 0d90 00E08DE5 		str	lr, [sp, #0]
 1701 0d94 FEFFFFEB 		bl	SensorWrite2B2
 1702 0d98 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1703 0d9c D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1704 0da0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1705 0da4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1706 0da8 0020A0E3 		mov	r2, #0
 1707 0dac FE0000E2 		and	r0, r0, #254
 1708 0db0 00C08DE5 		str	ip, [sp, #0]
 1709 0db4 FEFFFFEB 		bl	SensorWrite2B2
 1710              	.LVL118:
 1711 0db8 CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1712 0dbc D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1713 0dc0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1714 0dc4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1715 0dc8 FE0002E2 		and	r0, r2, #254
 1716 0dcc 0020A0E3 		mov	r2, #0
 1717 0dd0 00C08DE5 		str	ip, [sp, #0]
 1718 0dd4 FEFFFFEB 		bl	SensorWrite2B2
 1719 0dd8 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1720 0ddc D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1721 0de0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1722 0de4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1723 0de8 0020A0E3 		mov	r2, #0
 1724 0dec FE0000E2 		and	r0, r0, #254
 1725 0df0 00C08DE5 		str	ip, [sp, #0]
 1726 0df4 FEFFFFEB 		bl	SensorWrite2B2
 1727 0df8 4DFFFFEA 		b	.L102
 1728              	.L128:
 1729              		.align	2
 1730              	.L127:
 1731 0dfc 00000000 		.word	.LANCHOR0
 1732 0e00 78020000 		.word	.LC16
 1733 0e04 00000000 		.word	.LANCHOR1
 1734 0e08 C4020000 		.word	.LC17
 1735 0e0c EC020000 		.word	.LC18
 1736 0e10 00000000 		.word	cmdQu
 1737              		.cfi_endproc
 1738              	.LFE0:
 1740              		.align	2
 1741              		.global	setIrisauto
 1743              	setIrisauto:
 1744              	.LFB1:
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1745              		.loc 1 734 0
 1746              		.cfi_startproc
 1747              		@ args = 0, pretend = 0, frame = 0
 1748              		@ frame_needed = 0, uses_anonymous_args = 0
 1749              	.LVL119:
 1750 0e14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1751              	.LCFI12:
 1752              		.cfi_def_cfa_offset 16
 1753 0e18 0160A0E1 		mov	r6, r1
 1754              		.cfi_offset 14, -4
 1755              		.cfi_offset 6, -8
 1756              		.cfi_offset 5, -12
 1757              		.cfi_offset 4, -16
 1758 0e1c 08D04DE2 		sub	sp, sp, #8
 1759              	.LCFI13:
 1760              		.cfi_def_cfa_offset 24
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1761              		.loc 1 734 0
 1762 0e20 0040A0E1 		mov	r4, r0
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1763              		.loc 1 737 0
 1764 0e24 0050A0E3 		mov	r5, #0
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1765              		.loc 1 736 0
 1766 0e28 0010E0E3 		mvn	r1, #0
 1767              	.LVL120:
 1768 0e2c 1C0090E5 		ldr	r0, [r0, #28]
 1769              	.LVL121:
 1770 0e30 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1771              		.loc 1 737 0
 1772 0e34 060065E0 		rsb	r0, r5, r6
 1773 0e38 00C070E2 		rsbs	ip, r0, #0
 1774 0e3c 00C0ACE0 		adc	ip, ip, r0
 1775 0e40 2010A0E3 		mov	r1, #32
 1776 0e44 2720A0E3 		mov	r2, #39
 1777 0e48 3030A0E3 		mov	r3, #48
 1778 0e4c 0400A0E1 		mov	r0, r4
 1779 0e50 00C08DE5 		str	ip, [sp, #0]
 1780 0e54 04508DE5 		str	r5, [sp, #4]
 1781 0e58 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1782              		.loc 1 738 0
 1783 0e5c 050056E1 		cmp	r6, r5
 1784 0e60 0260A003 		moveq	r6, #2
 1785 0e64 0160A013 		movne	r6, #1
 1786 0e68 0400A0E1 		mov	r0, r4
 1787 0e6c 2110A0E3 		mov	r1, #33
 1788 0e70 2520A0E3 		mov	r2, #37
 1789 0e74 3030A0E3 		mov	r3, #48
 1790 0e78 00608DE5 		str	r6, [sp, #0]
 1791 0e7c 04508DE5 		str	r5, [sp, #4]
 1792 0e80 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1793              		.loc 1 739 0
 1794 0e84 1C0094E5 		ldr	r0, [r4, #28]
 740:../uvc.c      **** }
 1795              		.loc 1 740 0
 1796 0e88 08D08DE2 		add	sp, sp, #8
 1797 0e8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1798              		.loc 1 739 0
 1799 0e90 FEFFFFEA 		b	_txe_mutex_put
 1800              		.cfi_endproc
 1801              	.LFE1:
 1803              		.align	2
 1804              		.global	getShutCtrl
 1806              	getShutCtrl:
 1807              	.LFB2:
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1808              		.loc 1 744 0
 1809              		.cfi_startproc
 1810              		@ args = 0, pretend = 0, frame = 0
 1811              		@ frame_needed = 0, uses_anonymous_args = 0
 1812              	.LVL122:
 749:../uvc.c      **** 	switch (Data){
 1813              		.loc 1 749 0
 1814 0e94 013040E2 		sub	r3, r0, #1
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1815              		.loc 1 744 0
 1816 0e98 10402DE9 		stmfd	sp!, {r4, lr}
 1817              	.LCFI14:
 1818              		.cfi_def_cfa_offset 8
 1819 0e9c 08D04DE2 		sub	sp, sp, #8
 1820              	.LCFI15:
 1821              		.cfi_def_cfa_offset 16
 749:../uvc.c      **** 	switch (Data){
 1822              		.loc 1 749 0
 1823 0ea0 090053E3 		cmp	r3, #9
 1824 0ea4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1825 0ea8 380000EA 		b	.L133
 1826              		.cfi_offset 14, -4
 1827              		.cfi_offset 4, -8
 1828              	.L136:
 1829 0eac 440F0000 		.word	.L134
 1830 0eb0 440F0000 		.word	.L134
 1831 0eb4 440F0000 		.word	.L134
 1832 0eb8 440F0000 		.word	.L134
 1833 0ebc 440F0000 		.word	.L134
 1834 0ec0 D40E0000 		.word	.L135
 1835 0ec4 D40E0000 		.word	.L135
 1836 0ec8 D40E0000 		.word	.L135
 1837 0ecc D40E0000 		.word	.L135
 1838 0ed0 D40E0000 		.word	.L135
 1839              	.L135:
 1840              	.LVL123:
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1841              		.loc 1 773 0
 1842 0ed4 ECC09FE5 		ldr	ip, .L145
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1843              		.loc 1 771 0
 1844 0ed8 8330A0E1 		mov	r3, r3, asl #1
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1845              		.loc 1 773 0
 1846 0edc B3309CE1 		ldrh	r3, [ip, r3]
 1847 0ee0 E4E09FE5 		ldr	lr, .L145+4
 1848 0ee4 032263E0 		rsb	r2, r3, r3, asl #4
 1849 0ee8 8240A0E1 		mov	r4, r2, asl #1
 1850 0eec 94CECEE0 		smull	ip, lr, r4, lr
 1851 0ef0 C4CFA0E1 		mov	ip, r4, asr #31
 1852 0ef4 4E246CE0 		rsb	r2, ip, lr, asr #8
 774:../uvc.c      **** 		if(NumLn > 1944)
 1853              		.loc 1 774 0
 1854 0ef8 D0E09FE5 		ldr	lr, .L145+8
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1855              		.loc 1 773 0
 1856 0efc 0228A0E1 		mov	r2, r2, asl #16
 1857 0f00 22C8A0E1 		mov	ip, r2, lsr #16
 1858              	.LVL124:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1859              		.loc 1 774 0
 1860 0f04 0E005CE1 		cmp	ip, lr
 1861 0f08 2600008A 		bhi	.L142
 776:../uvc.c      **** 		else if(NumLn < 8)
 1862              		.loc 1 776 0
 1863 0f0c 07005CE3 		cmp	ip, #7
 1864 0f10 2700008A 		bhi	.L144
 1865              	.LVL125:
 1866              	.L143:
 1867 0f14 01C0A0E3 		mov	ip, #1
 1868 0f18 08E0A0E3 		mov	lr, #8
 1869 0f1c 0C40A0E1 		mov	r4, ip
 1870              	.L139:
 1871              	.LVL126:
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1872              		.loc 1 779 0
 1873 0f20 0120A0E3 		mov	r2, #1
 1874 0f24 0020C1E5 		strb	r2, [r1, #0]
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1875              		.loc 1 780 0
 1876 0f28 0020A0E1 		mov	r2, r0
 1877 0f2c A0109FE5 		ldr	r1, .L145+12
 1878              	.LVL127:
 1879 0f30 0400A0E3 		mov	r0, #4
 1880              	.LVL128:
 1881 0f34 00E08DE5 		str	lr, [sp, #0]
 1882 0f38 04C08DE5 		str	ip, [sp, #4]
 1883 0f3c FEFFFFEB 		bl	CyU3PDebugPrint
 781:../uvc.c      **** 		break;
 1884              		.loc 1 781 0
 1885 0f40 150000EA 		b	.L138
 1886              	.LVL129:
 1887              	.L134:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1888              		.loc 1 755 0
 1889 0f44 7CE09FE5 		ldr	lr, .L145
 1890 0f48 8330A0E1 		mov	r3, r3, asl #1
 1891 0f4c B3309EE1 		ldrh	r3, [lr, r3]
 1892              	.LVL130:
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1893              		.loc 1 757 0
 1894 0f50 80C09FE5 		ldr	ip, .L145+16
 758:../uvc.c      **** 		if(NumLn > 1944)
 1895              		.loc 1 758 0
 1896 0f54 74E09FE5 		ldr	lr, .L145+8
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1897              		.loc 1 757 0
 1898 0f58 932C8CE0 		umull	r2, ip, r3, ip
 1899 0f5c AC24A0E1 		mov	r2, ip, lsr #9
 1900 0f60 024262E0 		rsb	r4, r2, r2, asl #4
 1901 0f64 8448A0E1 		mov	r4, r4, asl #17
 1902 0f68 2428A0E1 		mov	r2, r4, lsr #16
 1903              	.LVL131:
 758:../uvc.c      **** 		if(NumLn > 1944)
 1904              		.loc 1 758 0
 1905 0f6c 0E0052E1 		cmp	r2, lr
 1906 0f70 0C00008A 		bhi	.L142
 760:../uvc.c      **** 		else if(NumLn < 8)
 1907              		.loc 1 760 0
 1908 0f74 070052E3 		cmp	r2, #7
 1909 0f78 E5FFFF9A 		bls	.L143
 1910 0f7c A449A0E1 		mov	r4, r4, lsr #19
 1911 0f80 FF4004E2 		and	r4, r4, #255
 1912 0f84 02E0A0E1 		mov	lr, r2
 1913 0f88 04C0A0E1 		mov	ip, r4
 1914 0f8c E3FFFFEA 		b	.L139
 1915              	.LVL132:
 1916              	.L133:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1917              		.loc 1 784 0
 1918 0f90 0000A0E3 		mov	r0, #0
 1919              	.LVL133:
 785:../uvc.c      **** 		LnVal = 1;
 1920              		.loc 1 785 0
 1921 0f94 0140A0E3 		mov	r4, #1
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1922              		.loc 1 784 0
 1923 0f98 0000C1E5 		strb	r0, [r1, #0]
 1924              	.LVL134:
 1925              	.L138:
 789:../uvc.c      **** }
 1926              		.loc 1 789 0
 1927 0f9c 0400A0E1 		mov	r0, r4
 1928 0fa0 08D08DE2 		add	sp, sp, #8
 1929 0fa4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1930              	.LVL135:
 1931              	.L142:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1932              		.loc 1 774 0
 1933 0fa8 F3C0A0E3 		mov	ip, #243
 1934 0fac 0C40A0E1 		mov	r4, ip
 1935 0fb0 DAFFFFEA 		b	.L139
 1936              	.LVL136:
 1937              	.L144:
 776:../uvc.c      **** 		else if(NumLn < 8)
 1938              		.loc 1 776 0
 1939 0fb4 A2E9A0E1 		mov	lr, r2, lsr #19
 1940 0fb8 FF400EE2 		and	r4, lr, #255
 1941 0fbc 0CE0A0E1 		mov	lr, ip
 1942 0fc0 04C0A0E1 		mov	ip, r4
 1943              	.LVL137:
 1944 0fc4 D5FFFFEA 		b	.L139
 1945              	.L146:
 1946              		.align	2
 1947              	.L145:
 1948 0fc8 00000000 		.word	.LANCHOR2
 1949 0fcc 817F807F 		.word	2139127681
 1950 0fd0 98070000 		.word	1944
 1951 0fd4 14030000 		.word	.LC19
 1952 0fd8 01FF00FF 		.word	-16711935
 1953              		.cfi_endproc
 1954              	.LFE2:
 1956              		.align	2
 1957              		.global	ControlHandle
 1959              	ControlHandle:
 1960              	.LFB3:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1961              		.loc 1 791 0
 1962              		.cfi_startproc
 1963              		@ args = 0, pretend = 0, frame = 24
 1964              		@ frame_needed = 0, uses_anonymous_args = 0
 1965              	.LVL138:
 1966 0fdc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1967              	.LCFI16:
 1968              		.cfi_def_cfa_offset 36
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1969              		.loc 1 798 0
 1970 0fe0 230050E3 		cmp	r0, #35
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1971              		.loc 1 797 0
 1972 0fe4 207040E2 		sub	r7, r0, #32
 1973              		.cfi_offset 14, -4
 1974              		.cfi_offset 11, -8
 1975              		.cfi_offset 10, -12
 1976              		.cfi_offset 9, -16
 1977              		.cfi_offset 8, -20
 1978              		.cfi_offset 7, -24
 1979              		.cfi_offset 6, -28
 1980              		.cfi_offset 5, -32
 1981              		.cfi_offset 4, -36
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1982              		.loc 1 791 0
 1983 0fe8 2CD04DE2 		sub	sp, sp, #44
 1984              	.LCFI17:
 1985              		.cfi_def_cfa_offset 80
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1986              		.loc 1 791 0
 1987 0fec 0040A0E1 		mov	r4, r0
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1988              		.loc 1 797 0
 1989 0ff0 FF7007E2 		and	r7, r7, #255
 1990              	.LVL139:
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1991              		.loc 1 798 0
 1992 0ff4 2300009A 		bls	.L148
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1993              		.loc 1 799 0
 1994 0ff8 586F9FE5 		ldr	r6, .L329+72
 1995 0ffc 872087E0 		add	r2, r7, r7, asl #1
 1996 1000 8221A0E1 		mov	r2, r2, asl #3
 1997 1004 023086E0 		add	r3, r6, r2
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1998              		.loc 1 800 0
 1999 1008 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 2000              		.loc 1 801 0
 2001 100c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 2002              		.loc 1 802 0
 2003 1010 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 813:../uvc.c      ****     reqData = bRequest;
 2004              		.loc 1 813 0
 2005 1014 F43E9FE5 		ldr	r3, .L329
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2006              		.loc 1 799 0
 2007 1018 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 2008              	.LVL140:
 813:../uvc.c      ****     reqData = bRequest;
 2009              		.loc 1 813 0
 2010 101c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 2011              	.LVL141:
 821:../uvc.c      ****     switch (bRequest)
 2012              		.loc 1 821 0
 2013 1020 830055E3 		cmp	r5, #131
 2014 1024 2200000A 		beq	.L154
 2015              	.LVL142:
 2016              	.L319:
 2017 1028 2B00009A 		bls	.L317
 2018 102c 850055E3 		cmp	r5, #133
 2019 1030 8800000A 		beq	.L156
 2020 1034 7600003A 		bcc	.L155
 2021 1038 860055E3 		cmp	r5, #134
 2022 103c C500000A 		beq	.L157
 2023 1040 870055E3 		cmp	r5, #135
 2024 1044 B900000A 		beq	.L318
 2025              	.L150:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 2026              		.loc 1 1707 0
 2027 1048 0000A0E3 		mov	r0, #0
 2028              	.LVL143:
 2029 104c 0110A0E3 		mov	r1, #1
 2030 1050 0020A0E1 		mov	r2, r0
 2031 1054 FEFFFFEB 		bl	CyU3PUsbStall
1708:../uvc.c      **** 			  break;
 2032              		.loc 1 1708 0
 2033 1058 FFA0A0E3 		mov	sl, #255
 2034 105c 0A70A0E1 		mov	r7, sl
 2035              	.LVL144:
 2036 1060 0A40A0E1 		mov	r4, sl
 2037 1064 0A80A0E1 		mov	r8, sl
 2038              	.LVL145:
 2039              	.L160:
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 2040              		.loc 1 1710 0
 2041 1068 A41E9FE5 		ldr	r1, .L329+4
 2042 106c 0520A0E1 		mov	r2, r5
 2043 1070 0830A0E1 		mov	r3, r8
 2044 1074 0400A0E3 		mov	r0, #4
 2045 1078 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 2046 107c FEFFFFEB 		bl	CyU3PDebugPrint
1711:../uvc.c      **** }
 2047              		.loc 1 1711 0
 2048 1080 2CD08DE2 		add	sp, sp, #44
 2049 1084 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 2050              	.LVL146:
 2051              	.L148:
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2052              		.loc 1 804 0
 2053 1088 C86E9FE5 		ldr	r6, .L329+72
 813:../uvc.c      ****     reqData = bRequest;
 2054              		.loc 1 813 0
 2055 108c 7C3E9FE5 		ldr	r3, .L329
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2056              		.loc 1 804 0
 2057 1090 808080E0 		add	r8, r0, r0, asl #1
 2058 1094 885186E0 		add	r5, r6, r8, asl #3
 2059 1098 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 2060              	.LVL147:
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2061              		.loc 1 805 0
 2062 109c 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 2063              	.LVL148:
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2064              		.loc 1 806 0
 2065 10a0 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 2066              	.LVL149:
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2067              		.loc 1 807 0
 2068 10a4 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 2069              	.LVL150:
 813:../uvc.c      ****     reqData = bRequest;
 2070              		.loc 1 813 0
 2071 10a8 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 2072              	.LVL151:
 821:../uvc.c      ****     switch (bRequest)
 2073              		.loc 1 821 0
 2074 10ac 830055E3 		cmp	r5, #131
 2075 10b0 DCFFFF1A 		bne	.L319
 2076              	.LVL152:
 2077              	.L154:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2078              		.loc 1 1191 0
 2079 10b4 230054E3 		cmp	r4, #35
 2080 10b8 C400009A 		bls	.L227
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2081              		.loc 1 1192 0
 2082 10bc 872087E0 		add	r2, r7, r7, asl #1
 2083 10c0 826186E0 		add	r6, r6, r2, asl #3
 2084 10c4 909E9FE5 		ldr	r9, .L329+76
 2085 10c8 0530D6E5 		ldrb	r3, [r6, #5]	@ zero_extendqisi2
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2086              		.loc 1 1193 0
 2087 10cc 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 2088              	.LVL153:
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2089              		.loc 1 1192 0
 2090 10d0 1C31C9E5 		strb	r3, [r9, #284]
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2091              		.loc 1 1193 0
 2092 10d4 1D01C9E5 		strb	r0, [r9, #285]
 2093 10d8 0B0000EA 		b	.L235
 2094              	.LVL154:
 2095              	.L317:
 821:../uvc.c      ****     switch (bRequest)
 2096              		.loc 1 821 0
 2097 10dc 810055E3 		cmp	r5, #129
 2098 10e0 6800000A 		beq	.L152
 2099 10e4 1000009A 		bls	.L320
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2100              		.loc 1 1172 0
 2101 10e8 230054E3 		cmp	r4, #35
 2102 10ec AB00009A 		bls	.L224
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2103              		.loc 1 1173 0
 2104 10f0 879087E0 		add	r9, r7, r7, asl #1
 2105 10f4 896186E0 		add	r6, r6, r9, asl #3
 2106 10f8 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 2107              	.LVL155:
 2108 10fc 589E9FE5 		ldr	r9, .L329+76
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2109              		.loc 1 1174 0
 2110 1100 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2111              		.loc 1 1173 0
 2112 1104 1C71C9E5 		strb	r7, [r9, #284]
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2113              		.loc 1 1174 0
 2114 1108 1DE1C9E5 		strb	lr, [r9, #285]
 2115              	.LVL156:
 2116              	.L235:
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2117              		.loc 1 1249 0
 2118 110c 0800A0E1 		mov	r0, r8
1251:../uvc.c      **** 			  break;
 2119              		.loc 1 1251 0
 2120 1110 FFA0A0E3 		mov	sl, #255
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2121              		.loc 1 1249 0
 2122 1114 FC1D9FE5 		ldr	r1, .L329+8
 2123 1118 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2124              	.LVL157:
1251:../uvc.c      **** 			  break;
 2125              		.loc 1 1251 0
 2126 111c 0A40A0E1 		mov	r4, sl
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2127              		.loc 1 1249 0
 2128 1120 1C71D9E5 		ldrb	r7, [r9, #284]	@ zero_extendqisi2
1251:../uvc.c      **** 			  break;
 2129              		.loc 1 1251 0
 2130 1124 0A80A0E1 		mov	r8, sl
 2131 1128 CEFFFFEA 		b	.L160
 2132              	.LVL158:
 2133              	.L320:
 821:../uvc.c      ****     switch (bRequest)
 2134              		.loc 1 821 0
 2135 112c 010055E3 		cmp	r5, #1
 2136 1130 C4FFFF1A 		bne	.L150
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 2137              		.loc 1 1253 0
 2138 1134 201E9FE5 		ldr	r1, .L329+76
 2139 1138 26208DE2 		add	r2, sp, #38
 2140 113c 2000A0E3 		mov	r0, #32
 2141              	.LVL159:
 2142 1140 471F81E2 		add	r1, r1, #284
 2143 1144 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2144              	.LVL160:
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 2145              		.loc 1 1255 0
 2146 1148 002050E2 		subs	r2, r0, #0
 2147 114c 4A04001A 		bne	.L237
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2148              		.loc 1 1257 0
 2149 1150 04CE9FE5 		ldr	ip, .L329+76
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2150              		.loc 1 1258 0
 2151 1154 00EE9FE5 		ldr	lr, .L329+76
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2152              		.loc 1 1257 0
 2153 1158 1C31DCE5 		ldrb	r3, [ip, #284]	@ zero_extendqisi2
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2154              		.loc 1 1260 0
 2155 115c 1E01DEE5 		ldrb	r0, [lr, #286]	@ zero_extendqisi2
 2156              	.LVL161:
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2157              		.loc 1 1257 0
 2158 1160 18308DE5 		str	r3, [sp, #24]
 2159              	.LVL162:
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2160              		.loc 1 1258 0
 2161 1164 1DC1DEE5 		ldrb	ip, [lr, #285]	@ zero_extendqisi2
 2162              	.LVL163:
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2163              		.loc 1 1260 0
 2164 1168 1C008DE5 		str	r0, [sp, #28]
 2165              	.LVL164:
1264:../uvc.c      **** 				  switch(CtrlID)
 2166              		.loc 1 1264 0
 2167 116c 260054E3 		cmp	r4, #38
 2168 1170 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2169 1174 790300EA 		b	.L238
 2170              	.L256:
 2171 1178 A41E0000 		.word	.L239
 2172 117c 381E0000 		.word	.L240
 2173 1180 D81D0000 		.word	.L241
 2174 1184 601F0000 		.word	.L238
 2175 1188 741D0000 		.word	.L242
 2176 118c 341C0000 		.word	.L243
 2177 1190 BC1B0000 		.word	.L244
 2178 1194 FC210000 		.word	.L245
 2179 1198 601F0000 		.word	.L238
 2180 119c 601F0000 		.word	.L238
 2181 11a0 601F0000 		.word	.L238
 2182 11a4 78210000 		.word	.L246
 2183 11a8 601F0000 		.word	.L238
 2184 11ac 601F0000 		.word	.L238
 2185 11b0 601F0000 		.word	.L238
 2186 11b4 601F0000 		.word	.L238
 2187 11b8 9C200000 		.word	.L247
 2188 11bc 601F0000 		.word	.L238
 2189 11c0 601F0000 		.word	.L238
 2190 11c4 601F0000 		.word	.L238
 2191 11c8 601F0000 		.word	.L238
 2192 11cc 601F0000 		.word	.L238
 2193 11d0 601F0000 		.word	.L238
 2194 11d4 601F0000 		.word	.L238
 2195 11d8 601F0000 		.word	.L238
 2196 11dc C81F0000 		.word	.L248
 2197 11e0 D81D0000 		.word	.L241
 2198 11e4 98190000 		.word	.L249
 2199 11e8 10190000 		.word	.L250
 2200 11ec 601F0000 		.word	.L238
 2201 11f0 B4180000 		.word	.L251
 2202 11f4 30180000 		.word	.L252
 2203 11f8 601F0000 		.word	.L238
 2204 11fc 601F0000 		.word	.L238
 2205 1200 601F0000 		.word	.L238
 2206 1204 601F0000 		.word	.L238
 2207 1208 A01A0000 		.word	.L253
 2208 120c 2C1A0000 		.word	.L254
 2209 1210 3C1B0000 		.word	.L255
 2210              	.LVL165:
 2211              	.L155:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2212              		.loc 1 1209 0
 2213 1214 230054E3 		cmp	r4, #35
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2214              		.loc 1 1216 0
 2215 1218 84408490 		addls	r4, r4, r4, asl #1
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2216              		.loc 1 1210 0
 2217 121c 87708780 		addhi	r7, r7, r7, asl #1
 2218              	.LVL166:
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2219              		.loc 1 1216 0
 2220 1220 84618690 		addls	r6, r6, r4, asl #3
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2221              		.loc 1 1210 0
 2222 1224 87618680 		addhi	r6, r6, r7, asl #3
 2223 1228 2C9D9F85 		ldrhi	r9, .L329+76
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2224              		.loc 1 1216 0
 2225 122c 289D9F95 		ldrls	r9, .L329+76
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2226              		.loc 1 1210 0
 2227 1230 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2228              		.loc 1 1211 0
 2229 1234 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2230              		.loc 1 1216 0
 2231 1238 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2232              		.loc 1 1217 0
 2233 123c 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2234              		.loc 1 1218 0
 2235 1240 0040A0E3 		mov	r4, #0
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2236              		.loc 1 1216 0
 2237 1244 1C11C9E5 		strb	r1, [r9, #284]
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2238              		.loc 1 1217 0
 2239 1248 1D21C9E5 		strb	r2, [r9, #285]
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2240              		.loc 1 1218 0
 2241 124c 1E41C9E5 		strb	r4, [r9, #286]
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2242              		.loc 1 1219 0
 2243 1250 1F41C9E5 		strb	r4, [r9, #287]
 2244 1254 ACFFFFEA 		b	.L235
 2245              	.LVL167:
 2246              	.L156:
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2247              		.loc 1 825 0
 2248 1258 FC4C9FE5 		ldr	r4, .L329+76
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2249              		.loc 1 826 0
 2250 125c 00A0A0E3 		mov	sl, #0
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2251              		.loc 1 825 0
 2252 1260 1C81C4E5 		strb	r8, [r4, #284]
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2253              		.loc 1 826 0
 2254 1264 1DA1C4E5 		strb	sl, [r4, #285]
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2255              		.loc 1 827 0
 2256 1268 471F84E2 		add	r1, r4, #284
 829:../uvc.c      **** 			  break;
 2257              		.loc 1 829 0
 2258 126c FFA0A0E3 		mov	sl, #255
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2259              		.loc 1 827 0
 2260 1270 0200A0E3 		mov	r0, #2
 2261              	.LVL168:
 2262 1274 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2263              	.LVL169:
 829:../uvc.c      **** 			  break;
 2264              		.loc 1 829 0
 2265 1278 0A80A0E1 		mov	r8, sl
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2266              		.loc 1 827 0
 2267 127c 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2268              	.LVL170:
 829:../uvc.c      **** 			  break;
 2269              		.loc 1 829 0
 2270 1280 0A40A0E1 		mov	r4, sl
 2271 1284 77FFFFEA 		b	.L160
 2272              	.LVL171:
 2273              	.L152:
 832:../uvc.c      **** 			 switch(CtrlID)
 2274              		.loc 1 832 0
 2275 1288 260054E3 		cmp	r4, #38
 2276 128c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2277 1290 DB0000EA 		b	.L161
 2278              	.L178:
 2279 1294 60170000 		.word	.L162
 2280 1298 A0160000 		.word	.L163
 2281 129c F4160000 		.word	.L164
 2282 12a0 04160000 		.word	.L161
 2283 12a4 A0150000 		.word	.L165
 2284 12a8 10180000 		.word	.L166
 2285 12ac 04160000 		.word	.L161
 2286 12b0 C8160000 		.word	.L167
 2287 12b4 04160000 		.word	.L161
 2288 12b8 8C170000 		.word	.L168
 2289 12bc 04160000 		.word	.L161
 2290 12c0 D4150000 		.word	.L169
 2291 12c4 04160000 		.word	.L161
 2292 12c8 04160000 		.word	.L161
 2293 12cc 04160000 		.word	.L161
 2294 12d0 04160000 		.word	.L161
 2295 12d4 B4170000 		.word	.L170
 2296 12d8 04160000 		.word	.L161
 2297 12dc 04160000 		.word	.L161
 2298 12e0 04160000 		.word	.L161
 2299 12e4 04160000 		.word	.L161
 2300 12e8 04160000 		.word	.L161
 2301 12ec 04160000 		.word	.L161
 2302 12f0 04160000 		.word	.L161
 2303 12f4 04160000 		.word	.L161
 2304 12f8 34160000 		.word	.L171
 2305 12fc F4160000 		.word	.L164
 2306 1300 1C170000 		.word	.L172
 2307 1304 78150000 		.word	.L173
 2308 1308 04160000 		.word	.L161
 2309 130c 04160000 		.word	.L161
 2310 1310 4C140000 		.word	.L174
 2311 1314 04160000 		.word	.L161
 2312 1318 04160000 		.word	.L161
 2313 131c 04160000 		.word	.L161
 2314 1320 04160000 		.word	.L161
 2315 1324 E8140000 		.word	.L175
 2316 1328 4C150000 		.word	.L176
 2317 132c 28150000 		.word	.L177
 2318              	.L318:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2319              		.loc 1 1236 0
 2320 1330 230054E3 		cmp	r4, #35
 2321 1334 3100009A 		bls	.L234
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2322              		.loc 1 1237 0
 2323 1338 87A087E0 		add	sl, r7, r7, asl #1
 2324 133c 8A6186E0 		add	r6, r6, sl, asl #3
 2325 1340 149C9FE5 		ldr	r9, .L329+76
 2326 1344 0BC0D6E5 		ldrb	ip, [r6, #11]	@ zero_extendqisi2
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2327              		.loc 1 1238 0
 2328 1348 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2329              		.loc 1 1237 0
 2330 134c 1CC1C9E5 		strb	ip, [r9, #284]
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2331              		.loc 1 1238 0
 2332 1350 1D11C9E5 		strb	r1, [r9, #285]
 2333 1354 6CFFFFEA 		b	.L235
 2334              	.L157:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2335              		.loc 1 1225 0
 2336 1358 230054E3 		cmp	r4, #35
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2337              		.loc 1 1226 0
 2338 135c 87708780 		addhi	r7, r7, r7, asl #1
 2339              	.LVL172:
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2340              		.loc 1 1229 0
 2341 1360 84408490 		addls	r4, r4, r4, asl #1
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2342              		.loc 1 1226 0
 2343 1364 87618680 		addhi	r6, r6, r7, asl #3
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2344              		.loc 1 1229 0
 2345 1368 84618690 		addls	r6, r6, r4, asl #3
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2346              		.loc 1 1226 0
 2347 136c E88B9F85 		ldrhi	r8, .L329+76
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2348              		.loc 1 1229 0
 2349 1370 E48B9F95 		ldrls	r8, .L329+76
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2350              		.loc 1 1226 0
 2351 1374 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2352              		.loc 1 1229 0
 2353 1378 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2354              		.loc 1 1234 0
 2355 137c FFA0A0E3 		mov	sl, #255
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2356              		.loc 1 1229 0
 2357 1380 1C31C8E5 		strb	r3, [r8, #284]
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2358              		.loc 1 1231 0
 2359 1384 0100A0E3 		mov	r0, #1
 2360              	.LVL173:
 2361 1388 881B9FE5 		ldr	r1, .L329+8
 2362 138c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2363              	.LVL174:
1234:../uvc.c      **** 			  break;
 2364              		.loc 1 1234 0
 2365 1390 0A40A0E1 		mov	r4, sl
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2366              		.loc 1 1231 0
 2367 1394 1C71D8E5 		ldrb	r7, [r8, #284]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2368              		.loc 1 1234 0
 2369 1398 0A80A0E1 		mov	r8, sl
 2370 139c 31FFFFEA 		b	.L160
 2371              	.LVL175:
 2372              	.L224:
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2373              		.loc 1 1177 0
 2374 13a0 0B0054E3 		cmp	r4, #11
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2375              		.loc 1 1184 0
 2376 13a4 84408410 		addne	r4, r4, r4, asl #1
 2377 13a8 84618610 		addne	r6, r6, r4, asl #3
 2378 13ac A89B9F15 		ldrne	r9, .L329+76
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2379              		.loc 1 1178 0
 2380 13b0 A49B9F05 		ldreq	r9, .L329+76
 2381 13b4 603B9F05 		ldreq	r3, .L329+12
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2382              		.loc 1 1184 0
 2383 13b8 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2384              		.loc 1 1185 0
 2385 13bc 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2386              		.loc 1 1178 0
 2387 13c0 1C318905 		streq	r3, [r9, #284]
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2388              		.loc 1 1184 0
 2389 13c4 1C21C915 		strneb	r2, [r9, #284]
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2390              		.loc 1 1185 0
 2391 13c8 1D31C915 		strneb	r3, [r9, #285]
 2392 13cc 4EFFFFEA 		b	.L235
 2393              	.L227:
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2394              		.loc 1 1195 0
 2395 13d0 0B0054E3 		cmp	r4, #11
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2396              		.loc 1 1202 0
 2397 13d4 84408410 		addne	r4, r4, r4, asl #1
 2398 13d8 84618610 		addne	r6, r6, r4, asl #3
 2399 13dc 789B9F15 		ldrne	r9, .L329+76
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2400              		.loc 1 1196 0
 2401 13e0 749B9F05 		ldreq	r9, .L329+76
 2402 13e4 343B9F05 		ldreq	r3, .L329+16
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2403              		.loc 1 1202 0
 2404 13e8 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2405              		.loc 1 1203 0
 2406 13ec 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2407              		.loc 1 1196 0
 2408 13f0 1C318905 		streq	r3, [r9, #284]
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2409              		.loc 1 1202 0
 2410 13f4 1C21C915 		strneb	r2, [r9, #284]
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2411              		.loc 1 1203 0
 2412 13f8 1D31C915 		strneb	r3, [r9, #285]
 2413 13fc 42FFFFEA 		b	.L235
 2414              	.L234:
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2415              		.loc 1 1240 0
 2416 1400 0B0054E3 		cmp	r4, #11
 2417 1404 0700000A 		beq	.L321
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2418              		.loc 1 1246 0
 2419 1408 849084E0 		add	r9, r4, r4, asl #1
 2420 140c 896186E0 		add	r6, r6, r9, asl #3
 2421 1410 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2422 1414 409B9FE5 		ldr	r9, .L329+76
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2423              		.loc 1 1247 0
 2424 1418 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2425              		.loc 1 1246 0
 2426 141c 1C21C9E5 		strb	r2, [r9, #284]
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2427              		.loc 1 1247 0
 2428 1420 1D31C9E5 		strb	r3, [r9, #285]
 2429 1424 38FFFFEA 		b	.L235
 2430              	.L321:
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2431              		.loc 1 1241 0
 2432 1428 2C9B9FE5 		ldr	r9, .L329+76
 2433 142c 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 2434              	.LVL176:
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2435              		.loc 1 1243 0
 2436 1430 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2437              	.LVL177:
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2438              		.loc 1 1242 0
 2439 1434 00E0A0E3 		mov	lr, #0
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2440              		.loc 1 1241 0
 2441 1438 1C01C9E5 		strb	r0, [r9, #284]
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2442              		.loc 1 1242 0
 2443 143c 1DE1C9E5 		strb	lr, [r9, #285]
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2444              		.loc 1 1243 0
 2445 1440 1E71C9E5 		strb	r7, [r9, #286]
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2446              		.loc 1 1244 0
 2447 1444 1FE1C9E5 		strb	lr, [r9, #287]
 2448 1448 2FFFFFEA 		b	.L235
 2449              	.LVL178:
 2450              	.L174:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2451              		.loc 1 947 0 discriminator 1
 2452 144c 000058E3 		cmp	r8, #0
 2453 1450 EC04000A 		beq	.L313
 945:../uvc.c      **** 					 break;
 2454              		.loc 1 945 0
 2455 1454 28E1A0E1 		mov	lr, r8, lsr #2
 2456 1458 00005EE3 		cmp	lr, #0
 2457 145c 03005813 		cmpne	r8, #3
 2458 1460 0020A083 		movhi	r2, #0
 2459 1464 0120A093 		movls	r2, #1
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2460              		.loc 1 791 0
 2461 1468 0E31A0E1 		mov	r3, lr, asl #2
 945:../uvc.c      **** 					 break;
 2462              		.loc 1 945 0
 2463 146c F004009A 		bls	.L293
 2464 1470 A01A9FE5 		ldr	r1, .L329+8
 2465 1474 500041E2 		sub	r0, r1, #80
 2466              	.LVL179:
 2467              	.L197:
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2468              		.loc 1 948 0 discriminator 2
 2469 1478 044090E4 		ldr	r4, [r0], #4
 2470 147c 01A082E2 		add	sl, r2, #1
 2471 1480 FF200AE2 		and	r2, sl, #255
 2472 1484 0E0052E1 		cmp	r2, lr
 2473 1488 044081E4 		str	r4, [r1], #4
 2474 148c F9FFFF3A 		bcc	.L197
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2475              		.loc 1 948 0 is_stmt 0
 2476 1490 030058E1 		cmp	r8, r3
 2477 1494 C00A9F15 		ldrne	r0, .L329+76
 2478 1498 DA04000A 		beq	.L313
 2479              	.L306:
 2480 149c 03C080E0 		add	ip, r0, r3
 2481 14a0 CCE0DCE5 		ldrb	lr, [ip, #204]	@ zero_extendqisi2
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2482              		.loc 1 947 0 is_stmt 1
 2483 14a4 013083E2 		add	r3, r3, #1
 2484 14a8 FF3003E2 		and	r3, r3, #255
 2485              	.LVL180:
 2486 14ac 030058E1 		cmp	r8, r3
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2487              		.loc 1 948 0
 2488 14b0 1CE1CCE5 		strb	lr, [ip, #284]
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2489              		.loc 1 947 0
 2490 14b4 F8FFFF8A 		bhi	.L306
 2491              	.LVL181:
 2492              	.L180:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2493              		.loc 1 957 0
 2494 14b8 D710D0E5 		ldrb	r1, [r0, #215]	@ zero_extendqisi2
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2495              		.loc 1 950 0
 2496 14bc 983A9FE5 		ldr	r3, .L329+76
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2497              		.loc 1 957 0
 2498 14c0 FF0051E3 		cmp	r1, #255
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2499              		.loc 1 950 0
 2500 14c4 2571D0E5 		ldrb	r7, [r0, #293]	@ zero_extendqisi2
 2501              	.LVL182:
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2502              		.loc 1 951 0
 2503 14c8 26A1D0E5 		ldrb	sl, [r0, #294]	@ zero_extendqisi2
 2504              	.LVL183:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2505              		.loc 1 957 0
 2506 14cc 0F00000A 		beq	.L183
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2507              		.loc 1 959 0
 2508 14d0 D520D3E5 		ldrb	r2, [r3, #213]	@ zero_extendqisi2
 2509 14d4 481A9FE5 		ldr	r1, .L329+20
 2510 14d8 D630D3E5 		ldrb	r3, [r3, #214]	@ zero_extendqisi2
 2511 14dc 0400A0E3 		mov	r0, #4
 2512 14e0 FEFFFFEB 		bl	CyU3PDebugPrint
 2513 14e4 090000EA 		b	.L183
 2514              	.LVL184:
 2515              	.L175:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2516              		.loc 1 836 0
 2517 14e8 6C4A9FE5 		ldr	r4, .L329+76
 2518 14ec 6001D4E5 		ldrb	r0, [r4, #352]	@ zero_extendqisi2
 2519              	.LVL185:
 2520 14f0 000050E3 		cmp	r0, #0
 2521 14f4 0004000A 		beq	.L181
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2522              		.loc 1 837 0
 2523 14f8 9DC4D6E5 		ldrb	ip, [r6, #1181]	@ zero_extendqisi2
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2524              		.loc 1 838 0
 2525 14fc 9E14D6E5 		ldrb	r1, [r6, #1182]	@ zero_extendqisi2
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2526              		.loc 1 837 0
 2527 1500 FF700CE2 		and	r7, ip, #255
 2528              	.LVL186:
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2529              		.loc 1 838 0
 2530 1504 FFA001E2 		and	sl, r1, #255
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2531              		.loc 1 837 0
 2532 1508 1C71C4E5 		strb	r7, [r4, #284]
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2533              		.loc 1 838 0
 2534 150c 1DA1C4E5 		strb	sl, [r4, #285]
 2535              	.LVL187:
 2536              	.L183:
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2537              		.loc 1 1165 0
 2538 1510 0800A0E1 		mov	r0, r8
 2539 1514 FC199FE5 		ldr	r1, .L329+8
 2540 1518 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1170:../uvc.c      **** 			  break;
 2541              		.loc 1 1170 0
 2542 151c FF40A0E3 		mov	r4, #255
 2543 1520 0480A0E1 		mov	r8, r4
 2544 1524 CFFEFFEA 		b	.L160
 2545              	.LVL188:
 2546              	.L177:
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2547              		.loc 1 869 0
 2548 1528 2C4A9FE5 		ldr	r4, .L329+76
 2549 152c 62B1D4E5 		ldrb	fp, [r4, #354]	@ zero_extendqisi2
 2550 1530 00005BE3 		cmp	fp, #0
 2551 1534 FF03000A 		beq	.L186
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2552              		.loc 1 870 0
 2553 1538 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2554              	.LVL189:
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2555              		.loc 1 871 0
 2556 153c 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2557              		.loc 1 870 0
 2558 1540 1C71C4E5 		strb	r7, [r4, #284]
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2559              		.loc 1 871 0
 2560 1544 1DA1C4E5 		strb	sl, [r4, #285]
 2561 1548 F0FFFFEA 		b	.L183
 2562              	.LVL190:
 2563              	.L176:
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2564              		.loc 1 851 0
 2565 154c 084A9FE5 		ldr	r4, .L329+76
 2566 1550 61E1D4E5 		ldrb	lr, [r4, #353]	@ zero_extendqisi2
 2567 1554 00005EE3 		cmp	lr, #0
 2568 1558 2704000A 		beq	.L184
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2569              		.loc 1 852 0
 2570 155c B1A4D6E5 		ldrb	sl, [r6, #1201]	@ zero_extendqisi2
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2571              		.loc 1 853 0
 2572 1560 B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2573              		.loc 1 852 0
 2574 1564 FF700AE2 		and	r7, sl, #255
 2575              	.LVL191:
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2576              		.loc 1 853 0
 2577 1568 FFA002E2 		and	sl, r2, #255
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2578              		.loc 1 852 0
 2579 156c 1C71C4E5 		strb	r7, [r4, #284]
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2580              		.loc 1 853 0
 2581 1570 1DA1C4E5 		strb	sl, [r4, #285]
 2582 1574 E5FFFFEA 		b	.L183
 2583              	.LVL192:
 2584              	.L173:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2585              		.loc 1 934 0
 2586 1578 DC499FE5 		ldr	r4, .L329+76
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2587              		.loc 1 932 0
 2588 157c 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2589              	.LVL193:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2590              		.loc 1 934 0
 2591 1580 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 2592 1584 010052E3 		cmp	r2, #1
 2593 1588 9004000A 		beq	.L322
 2594              	.LVL194:
 2595              	.L314:
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2596              		.loc 1 1034 0
 2597 158c 0030A0E3 		mov	r3, #0
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2598              		.loc 1 1033 0
 2599 1590 1C71C4E5 		strb	r7, [r4, #284]
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2600              		.loc 1 1034 0
 2601 1594 1D31C4E5 		strb	r3, [r4, #285]
 2602              	.LVL195:
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2603              		.loc 1 809 0
 2604 1598 FFA0A0E3 		mov	sl, #255
1036:../uvc.c      **** 					 break;
 2605              		.loc 1 1036 0
 2606 159c DBFFFFEA 		b	.L183
 2607              	.LVL196:
 2608              	.L165:
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2609              		.loc 1 1124 0
 2610 15a0 B4499FE5 		ldr	r4, .L329+76
 2611 15a4 40E1D4E5 		ldrb	lr, [r4, #320]	@ zero_extendqisi2
 2612 15a8 00005EE3 		cmp	lr, #0
 2613 15ac 4304000A 		beq	.L218
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2614              		.loc 1 1126 0
 2615 15b0 D8C094E5 		ldr	ip, [r4, #216]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2616              		.loc 1 1132 0
 2617 15b4 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2618              		.loc 1 1126 0
 2619 15b8 00005CE3 		cmp	ip, #0
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2620              		.loc 1 1127 0
 2621 15bc 02C0A013 		movne	ip, #2
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
 2622              		.loc 1 1129 0
 2623 15c0 01C0A003 		moveq	ip, #1
 2624 15c4 1CC1C4E5 		strb	ip, [r4, #284]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2625              		.loc 1 1132 0
 2626 15c8 1DA1C4E5 		strb	sl, [r4, #285]
 2627 15cc 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2628              	.LVL197:
 2629 15d0 CEFFFFEA 		b	.L183
 2630              	.LVL198:
 2631              	.L169:
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2632              		.loc 1 1042 0
 2633 15d4 80499FE5 		ldr	r4, .L329+76
 2634 15d8 4721D4E5 		ldrb	r2, [r4, #327]	@ zero_extendqisi2
 2635 15dc 000052E3 		cmp	r2, #0
 2636 15e0 B603000A 		beq	.L208
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2637              		.loc 1 1043 0
 2638 15e4 F474D6E5 		ldrb	r7, [r6, #1268]	@ zero_extendqisi2
 2639              	.LVL199:
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2640              		.loc 1 1044 0
 2641 15e8 F6A4D6E5 		ldrb	sl, [r6, #1270]	@ zero_extendqisi2
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2642              		.loc 1 1043 0
 2643 15ec 1C71C4E5 		strb	r7, [r4, #284]
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2644              		.loc 1 1044 0
 2645 15f0 1EA1C4E5 		strb	sl, [r4, #286]
 2646              	.LVL200:
 2647              	.L209:
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2648              		.loc 1 1054 0
 2649 15f4 00E0A0E3 		mov	lr, #0
 2650 15f8 1DE1C4E5 		strb	lr, [r4, #285]
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2651              		.loc 1 1055 0
 2652 15fc 1FE1C4E5 		strb	lr, [r4, #287]
 2653              	.LVL201:
1058:../uvc.c      **** 					 break;
 2654              		.loc 1 1058 0
 2655 1600 C2FFFFEA 		b	.L183
 2656              	.LVL202:
 2657              	.L161:
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2658              		.loc 1 1149 0
 2659 1604 50B99FE5 		ldr	fp, .L329+76
 2660 1608 04308BE0 		add	r3, fp, r4
 2661 160c 3C21D3E5 		ldrb	r2, [r3, #316]	@ zero_extendqisi2
 2662 1610 000052E3 		cmp	r2, #0
 2663 1614 0F04000A 		beq	.L222
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2664              		.loc 1 1150 0
 2665 1618 844084E0 		add	r4, r4, r4, asl #1
 2666 161c 846186E0 		add	r6, r6, r4, asl #3
 2667 1620 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2668              	.LVL203:
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2669              		.loc 1 1151 0
 2670 1624 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2671              		.loc 1 1150 0
 2672 1628 1C71CBE5 		strb	r7, [fp, #284]
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2673              		.loc 1 1151 0
 2674 162c 1DA1CBE5 		strb	sl, [fp, #285]
 2675 1630 B6FFFFEA 		b	.L183
 2676              	.LVL204:
 2677              	.L171:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2678              		.loc 1 969 0
 2679 1634 20499FE5 		ldr	r4, .L329+76
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2680              		.loc 1 963 0
 2681 1638 E004D6E5 		ldrb	r0, [r6, #1248]	@ zero_extendqisi2
 2682              	.LVL205:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2683              		.loc 1 969 0
 2684 163c 55A1D4E5 		ldrb	sl, [r4, #341]	@ zero_extendqisi2
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2685              		.loc 1 964 0
 2686 1640 E174D6E5 		ldrb	r7, [r6, #1249]	@ zero_extendqisi2
 2687              	.LVL206:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2688              		.loc 1 965 0
 2689 1644 EF24D6E5 		ldrb	r2, [r6, #1263]	@ zero_extendqisi2
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2690              		.loc 1 969 0
 2691 1648 00005AE3 		cmp	sl, #0
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2692              		.loc 1 963 0
 2693 164c 04699FE5 		ldr	r6, .L329+72
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2694              		.loc 1 964 0
 2695 1650 FFA007E2 		and	sl, r7, #255
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2696              		.loc 1 963 0
 2697 1654 FF0000E2 		and	r0, r0, #255
 2698              	.LVL207:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2699              		.loc 1 965 0
 2700 1658 FF7002E2 		and	r7, r2, #255
 2701              	.LVL208:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2702              		.loc 1 969 0
 2703 165c CF03000A 		beq	.L200
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2704              		.loc 1 970 0
 2705 1660 EDC4D6E5 		ldrb	ip, [r6, #1261]	@ zero_extendqisi2
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2706              		.loc 1 971 0
 2707 1664 EEE4D6E5 		ldrb	lr, [r6, #1262]	@ zero_extendqisi2
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2708              		.loc 1 970 0
 2709 1668 1CC1C4E5 		strb	ip, [r4, #284]
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2710              		.loc 1 971 0
 2711 166c 1EE1C4E5 		strb	lr, [r4, #286]
 2712              	.LVL209:
 2713              	.L201:
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2714              		.loc 1 988 0
 2715 1670 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2716              	.LVL210:
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2717              		.loc 1 989 0
 2718 1674 1EA1D4E5 		ldrb	sl, [r4, #286]	@ zero_extendqisi2
 2719              	.LVL211:
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2720              		.loc 1 985 0
 2721 1678 00E0A0E3 		mov	lr, #0
 2722 167c 1DE1C4E5 		strb	lr, [r4, #285]
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2723              		.loc 1 987 0
 2724 1680 1FE1C4E5 		strb	lr, [r4, #287]
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2725              		.loc 1 990 0
 2726 1684 9C189FE5 		ldr	r1, .L329+24
 2727 1688 0720A0E1 		mov	r2, r7
 2728 168c 0E30A0E1 		mov	r3, lr
 2729 1690 0400A0E3 		mov	r0, #4
 2730 1694 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2731 1698 FEFFFFEB 		bl	CyU3PDebugPrint
 991:../uvc.c      **** 					 break;
 2732              		.loc 1 991 0
 2733 169c 9BFFFFEA 		b	.L183
 2734              	.LVL212:
 2735              	.L163:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2736              		.loc 1 1007 0
 2737 16a0 B4489FE5 		ldr	r4, .L329+76
 2738 16a4 3D11D4E5 		ldrb	r1, [r4, #317]	@ zero_extendqisi2
 2739 16a8 000051E3 		cmp	r1, #0
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2740              		.loc 1 1008 0
 2741 16ac A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2742              	.LVL213:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2743              		.loc 1 1007 0
 2744 16b0 1B04000A 		beq	.L323
 2745              	.LVL214:
 2746              	.L203:
1015:../uvc.c      **** 					  if(Data0&0x80){
 2747              		.loc 1 1015 0
 2748 16b4 800010E3 		tst	r0, #128
1016:../uvc.c      **** 						  Data0 = ~Data0;
 2749              		.loc 1 1016 0
 2750 16b8 0000E011 		mvnne	r0, r0
 2751              	.LVL215:
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2752              		.loc 1 1018 0
 2753 16bc 80004002 		subeq	r0, r0, #128
 2754 16c0 FF7000E2 		and	r7, r0, #255
 2755              	.LVL216:
 2756 16c4 B0FFFFEA 		b	.L314
 2757              	.LVL217:
 2758              	.L167:
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2759              		.loc 1 1077 0
 2760 16c8 8C489FE5 		ldr	r4, .L329+76
 2761 16cc 4321D4E5 		ldrb	r2, [r4, #323]	@ zero_extendqisi2
 2762 16d0 000052E3 		cmp	r2, #0
 2763 16d4 A503000A 		beq	.L212
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2764              		.loc 1 1078 0
 2765 16d8 19E5D6E5 		ldrb	lr, [r6, #1305]	@ zero_extendqisi2
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2766              		.loc 1 1079 0
 2767 16dc 1A15D6E5 		ldrb	r1, [r6, #1306]	@ zero_extendqisi2
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2768              		.loc 1 1078 0
 2769 16e0 FF700EE2 		and	r7, lr, #255
 2770              	.LVL218:
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2771              		.loc 1 1079 0
 2772 16e4 FFA001E2 		and	sl, r1, #255
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2773              		.loc 1 1078 0
 2774 16e8 1C71C4E5 		strb	r7, [r4, #284]
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2775              		.loc 1 1079 0
 2776 16ec 1DA1C4E5 		strb	sl, [r4, #285]
 2777 16f0 86FFFFEA 		b	.L183
 2778              	.LVL219:
 2779              	.L164:
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2780              		.loc 1 1094 0
 2781 16f4 60B89FE5 		ldr	fp, .L329+76
 2782 16f8 04408BE0 		add	r4, fp, r4
 2783 16fc 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2784              	.LVL220:
 2785 1700 000057E3 		cmp	r7, #0
 2786 1704 C803000A 		beq	.L214
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2787              		.loc 1 1095 0
 2788 1708 BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2789              		.loc 1 1096 0
 2790 170c BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2791              		.loc 1 1095 0
 2792 1710 1C71CBE5 		strb	r7, [fp, #284]
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2793              		.loc 1 1096 0
 2794 1714 1DA1CBE5 		strb	sl, [fp, #285]
 2795 1718 7CFFFFEA 		b	.L183
 2796              	.LVL221:
 2797              	.L172:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2798              		.loc 1 919 0
 2799 171c 38489FE5 		ldr	r4, .L329+76
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2800              		.loc 1 912 0
 2801 1720 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2802              		.loc 1 919 0
 2803 1724 5721D4E5 		ldrb	r2, [r4, #343]	@ zero_extendqisi2
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2804              		.loc 1 913 0
 2805 1728 CDE4D6E5 		ldrb	lr, [r6, #1229]	@ zero_extendqisi2
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2806              		.loc 1 914 0
 2807 172c DB14D6E5 		ldrb	r1, [r6, #1243]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2808              		.loc 1 919 0
 2809 1730 000052E3 		cmp	r2, #0
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2810              		.loc 1 912 0
 2811 1734 1C689FE5 		ldr	r6, .L329+72
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2812              		.loc 1 913 0
 2813 1738 FF000EE2 		and	r0, lr, #255
 2814              	.LVL222:
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2815              		.loc 1 914 0
 2816 173c FF1001E2 		and	r1, r1, #255
 2817              	.LVL223:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2818              		.loc 1 919 0
 2819 1740 A303000A 		beq	.L192
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2820              		.loc 1 920 0
 2821 1744 D9A4D6E5 		ldrb	sl, [r6, #1241]	@ zero_extendqisi2
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2822              		.loc 1 921 0
 2823 1748 DA34D6E5 		ldrb	r3, [r6, #1242]	@ zero_extendqisi2
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2824              		.loc 1 920 0
 2825 174c FF700AE2 		and	r7, sl, #255
 2826              	.LVL224:
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2827              		.loc 1 921 0
 2828 1750 FFA003E2 		and	sl, r3, #255
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2829              		.loc 1 920 0
 2830 1754 1C71C4E5 		strb	r7, [r4, #284]
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2831              		.loc 1 921 0
 2832 1758 1DA1C4E5 		strb	sl, [r4, #285]
 2833 175c 6BFFFFEA 		b	.L183
 2834              	.LVL225:
 2835              	.L162:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2836              		.loc 1 1060 0
 2837 1760 F4479FE5 		ldr	r4, .L329+76
 2838 1764 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2839              	.LVL226:
 2840 1768 000057E3 		cmp	r7, #0
 2841 176c E003000A 		beq	.L210
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2842              		.loc 1 1061 0
 2843 1770 05A5D6E5 		ldrb	sl, [r6, #1285]	@ zero_extendqisi2
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2844              		.loc 1 1062 0
 2845 1774 06C5D6E5 		ldrb	ip, [r6, #1286]	@ zero_extendqisi2
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2846              		.loc 1 1061 0
 2847 1778 FF700AE2 		and	r7, sl, #255
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2848              		.loc 1 1062 0
 2849 177c FFA00CE2 		and	sl, ip, #255
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2850              		.loc 1 1061 0
 2851 1780 1C71C4E5 		strb	r7, [r4, #284]
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2852              		.loc 1 1062 0
 2853 1784 1DA1C4E5 		strb	sl, [r4, #285]
 2854 1788 60FFFFEA 		b	.L183
 2855              	.LVL227:
 2856              	.L168:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2857              		.loc 1 1107 0
 2858 178c C8479FE5 		ldr	r4, .L329+76
 2859 1790 4531D4E5 		ldrb	r3, [r4, #325]	@ zero_extendqisi2
 2860 1794 000053E3 		cmp	r3, #0
 2861 1798 BD03000A 		beq	.L216
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2862              		.loc 1 1109 0
 2863 179c 6522D6E5 		ldrb	r2, [r6, #613]	@ zero_extendqisi2
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2864              		.loc 1 1110 0
 2865 17a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2866              		.loc 1 1109 0
 2867 17a4 037002E2 		and	r7, r2, #3
 2868              	.LVL228:
 2869 17a8 1C71C4E5 		strb	r7, [r4, #284]
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2870              		.loc 1 1110 0
 2871 17ac 1DA1C4E5 		strb	sl, [r4, #285]
 2872 17b0 56FFFFEA 		b	.L183
 2873              	.LVL229:
 2874              	.L170:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2875              		.loc 1 894 0
 2876 17b4 A0479FE5 		ldr	r4, .L329+76
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2877              		.loc 1 887 0
 2878 17b8 B8E4D6E5 		ldrb	lr, [r6, #1208]	@ zero_extendqisi2
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2879              		.loc 1 894 0
 2880 17bc 4C21D4E5 		ldrb	r2, [r4, #332]	@ zero_extendqisi2
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2881              		.loc 1 888 0
 2882 17c0 B934D6E5 		ldrb	r3, [r6, #1209]	@ zero_extendqisi2
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2883              		.loc 1 889 0
 2884 17c4 C774D6E5 		ldrb	r7, [r6, #1223]	@ zero_extendqisi2
 2885              	.LVL230:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2886              		.loc 1 894 0
 2887 17c8 000052E3 		cmp	r2, #0
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2888              		.loc 1 887 0
 2889 17cc 84679FE5 		ldr	r6, .L329+72
 2890 17d0 FF000EE2 		and	r0, lr, #255
 2891              	.LVL231:
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2892              		.loc 1 889 0
 2893 17d4 FF1007E2 		and	r1, r7, #255
 2894              	.LVL232:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2895              		.loc 1 894 0
 2896 17d8 D803000A 		beq	.L190
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2897              		.loc 1 895 0
 2898 17dc C5A4D6E5 		ldrb	sl, [r6, #1221]	@ zero_extendqisi2
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2899              		.loc 1 896 0
 2900 17e0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2901              		.loc 1 895 0
 2902 17e4 FF700AE2 		and	r7, sl, #255
 2903 17e8 1C71C4E5 		strb	r7, [r4, #284]
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2904              		.loc 1 896 0
 2905 17ec 1D31C4E5 		strb	r3, [r4, #285]
 2906              	.LVL233:
 2907              	.L191:
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2908              		.loc 1 909 0
 2909 17f0 34179FE5 		ldr	r1, .L329+28
 2910 17f4 0720A0E1 		mov	r2, r7
 2911 17f8 0730A0E1 		mov	r3, r7
 2912 17fc 0400A0E3 		mov	r0, #4
 2913 1800 00C08DE5 		str	ip, [sp, #0]
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 2914              		.loc 1 908 0
 2915 1804 0CA0A0E1 		mov	sl, ip
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2916              		.loc 1 909 0
 2917 1808 FEFFFFEB 		bl	CyU3PDebugPrint
 2918              	.LVL234:
 910:../uvc.c      **** 			 		 break;
 2919              		.loc 1 910 0
 2920 180c 3FFFFFEA 		b	.L183
 2921              	.LVL235:
 2922              	.L166:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2923              		.loc 1 1025 0
 2924 1810 44479FE5 		ldr	r4, .L329+76
 2925 1814 41C1D4E5 		ldrb	ip, [r4, #321]	@ zero_extendqisi2
 2926 1818 00005CE3 		cmp	ip, #0
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2927              		.loc 1 1026 0
 2928 181c 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2929              	.LVL236:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2930              		.loc 1 1025 0
 2931 1820 B002000A 		beq	.L324
 2932              	.L207:
 2933              	.LVL237:
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2934              		.loc 1 1033 0
 2935 1824 800040E2 		sub	r0, r0, #128
 2936              	.LVL238:
 2937 1828 FF7000E2 		and	r7, r0, #255
 2938              	.LVL239:
 2939 182c 56FFFFEA 		b	.L314
 2940              	.LVL240:
 2941              	.L252:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2942              		.loc 1 1416 0 discriminator 1
 2943 1830 000058E3 		cmp	r8, #0
 2944 1834 1800000A 		beq	.L258
1414:../uvc.c      **** 							 break;
 2945              		.loc 1 1414 0
 2946 1838 28E1A0E1 		mov	lr, r8, lsr #2
 2947 183c 00005EE3 		cmp	lr, #0
 2948 1840 03005813 		cmpne	r8, #3
 2949 1844 0020A083 		movhi	r2, #0
 2950 1848 0120A093 		movls	r2, #1
 2951              	.LVL241:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2952              		.loc 1 791 0
 2953 184c 0E31A0E1 		mov	r3, lr, asl #2
1414:../uvc.c      **** 							 break;
 2954              		.loc 1 1414 0
 2955 1850 FA03009A 		bls	.L295
 2956 1854 D4169FE5 		ldr	r1, .L329+32
 2957 1858 500081E2 		add	r0, r1, #80
 2958              	.LVL242:
 2959              	.L268:
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2960              		.loc 1 1417 0 discriminator 2
 2961 185c 047090E4 		ldr	r7, [r0], #4
 2962 1860 012082E2 		add	r2, r2, #1
 2963 1864 FF2002E2 		and	r2, r2, #255
 2964 1868 02005EE1 		cmp	lr, r2
 2965 186c 047081E4 		str	r7, [r1], #4
 2966 1870 F9FFFF8A 		bhi	.L268
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2967              		.loc 1 1417 0 is_stmt 0
 2968 1874 030058E1 		cmp	r8, r3
 2969 1878 0700000A 		beq	.L258
 2970              	.L307:
 2971 187c D8069FE5 		ldr	r0, .L329+76
 2972 1880 03E080E0 		add	lr, r0, r3
 2973 1884 1C11DEE5 		ldrb	r1, [lr, #284]	@ zero_extendqisi2
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2974              		.loc 1 1416 0 is_stmt 1
 2975 1888 013083E2 		add	r3, r3, #1
 2976 188c FF3003E2 		and	r3, r3, #255
 2977              	.LVL243:
 2978 1890 030058E1 		cmp	r8, r3
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2979              		.loc 1 1417 0
 2980 1894 CC10CEE5 		strb	r1, [lr, #204]
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2981              		.loc 1 1416 0
 2982 1898 F7FFFF8A 		bhi	.L307
 2983              	.LVL244:
 2984              	.L258:
1420:../uvc.c      **** 							 break;
 2985              		.loc 1 1420 0
 2986 189c FFA0A0E3 		mov	sl, #255
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2987              		.loc 1 1419 0
 2988 18a0 FEFFFFEB 		bl	I2CCmdHandler
 2989              	.LVL245:
1420:../uvc.c      **** 							 break;
 2990              		.loc 1 1420 0
 2991 18a4 0A70A0E1 		mov	r7, sl
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2992              		.loc 1 1419 0
 2993 18a8 18809DE5 		ldr	r8, [sp, #24]
 2994 18ac 1C409DE5 		ldr	r4, [sp, #28]
1420:../uvc.c      **** 							 break;
 2995              		.loc 1 1420 0
 2996 18b0 ECFDFFEA 		b	.L160
 2997              	.LVL246:
 2998              	.L251:
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2999              		.loc 1 1410 0
 3000 18b4 94769FE5 		ldr	r7, .L329+64
 3001              	.LVL247:
 3002 18b8 0010E0E3 		mvn	r1, #0
 3003 18bc 1C0097E5 		ldr	r0, [r7, #28]
 3004 18c0 FEFFFFEB 		bl	_txe_mutex_get
 3005              	.LVL248:
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3006              		.loc 1 1411 0
 3007 18c4 0A20A0E1 		mov	r2, sl
 3008 18c8 18A09DE5 		ldr	sl, [sp, #24]
 3009 18cc 00C0A0E3 		mov	ip, #0
 3010 18d0 01407AE2 		rsbs	r4, sl, #1
 3011 18d4 0040A033 		movcc	r4, #0
 3012 18d8 1E10A0E3 		mov	r1, #30
 3013 18dc 0930A0E1 		mov	r3, r9
 3014 18e0 0700A0E1 		mov	r0, r7
 3015 18e4 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3016 18e8 FEFFFFEB 		bl	cmdSet
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3017              		.loc 1 1412 0
 3018 18ec 1C0097E5 		ldr	r0, [r7, #28]
 3019 18f0 FEFFFFEB 		bl	_txe_mutex_put
1414:../uvc.c      **** 							 break;
 3020              		.loc 1 1414 0
 3021 18f4 FFA0A0E3 		mov	sl, #255
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3022              		.loc 1 1413 0
 3023 18f8 0100A0E3 		mov	r0, #1
 3024 18fc 6004C6E5 		strb	r0, [r6, #1120]
 3025 1900 18809DE5 		ldr	r8, [sp, #24]
 3026 1904 1C409DE5 		ldr	r4, [sp, #28]
1414:../uvc.c      **** 							 break;
 3027              		.loc 1 1414 0
 3028 1908 0A70A0E1 		mov	r7, sl
 3029 190c D5FDFFEA 		b	.L160
 3030              	.LVL249:
 3031              	.L250:
1388:../uvc.c      **** 							 if(Data0 <= 3){
 3032              		.loc 1 1388 0
 3033 1910 030053E3 		cmp	r3, #3
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3034              		.loc 1 1389 0
 3035 1914 40069F95 		ldrls	r0, .L329+76
 3036 1918 03E0A0E1 		mov	lr, r3
 3037              	.LVL250:
 3038 191c 0030A093 		movls	r3, #0
 3039 1920 7C31C095 		strlsb	r3, [r0, #380]
 3040              	.LVL251:
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3041              		.loc 1 1392 0
 3042 1924 30C69F85 		ldrhi	ip, .L329+76
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3043              		.loc 1 1389 0
 3044 1928 0E30A091 		movls	r3, lr
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3045              		.loc 1 1398 0
 3046 192c 1C469FE5 		ldr	r4, .L329+64
 3047 1930 18E09D95 		ldrls	lr, [sp, #24]
1393:../uvc.c      **** 								 Data1 = Data0-4;
 3048              		.loc 1 1393 0
 3049 1934 04304382 		subhi	r3, r3, #4
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3050              		.loc 1 1392 0
 3051 1938 0120A083 		movhi	r2, #1
 3052              	.LVL252:
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 3053              		.loc 1 1396 0
 3054 193c 8D31C6E5 		strb	r3, [r6, #397]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3055              		.loc 1 1397 0
 3056 1940 0130A0E3 		mov	r3, #1
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3057              		.loc 1 1392 0
 3058 1944 7C21CC85 		strhib	r2, [ip, #380]
 3059              	.LVL253:
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3060              		.loc 1 1398 0
 3061 1948 0010E0E3 		mvn	r1, #0
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3062              		.loc 1 1395 0
 3063 194c 2DE4C6E5 		strb	lr, [r6, #1069]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3064              		.loc 1 1397 0
 3065 1950 3034C6E5 		strb	r3, [r6, #1072]
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3066              		.loc 1 1398 0
 3067 1954 1C0094E5 		ldr	r0, [r4, #28]
 3068 1958 FEFFFFEB 		bl	_txe_mutex_get
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3069              		.loc 1 1399 0
 3070 195c 18809DE5 		ldr	r8, [sp, #24]
 3071 1960 0A20A0E1 		mov	r2, sl
 3072 1964 1C10A0E3 		mov	r1, #28
 3073 1968 0930A0E1 		mov	r3, r9
 3074 196c 0400A0E1 		mov	r0, r4
 3075 1970 00A0A0E3 		mov	sl, #0
 3076 1974 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3077 1978 FEFFFFEB 		bl	cmdSet
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3078              		.loc 1 1400 0
 3079 197c 1C0094E5 		ldr	r0, [r4, #28]
 3080              	.LVL254:
 3081              	.L316:
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3082              		.loc 1 1666 0
 3083 1980 FFA0A0E3 		mov	sl, #255
 3084 1984 FEFFFFEB 		bl	_txe_mutex_put
 3085 1988 0A70A0E1 		mov	r7, sl
 3086 198c 18809DE5 		ldr	r8, [sp, #24]
 3087 1990 1C409DE5 		ldr	r4, [sp, #28]
 3088 1994 B3FDFFEA 		b	.L160
 3089              	.LVL255:
 3090              	.L249:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3091              		.loc 1 1365 0
 3092 1998 B0459FE5 		ldr	r4, .L329+64
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3093              		.loc 1 1361 0
 3094 199c CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3095              		.loc 1 1362 0
 3096 19a0 CD74D6E5 		ldrb	r7, [r6, #1229]	@ zero_extendqisi2
 3097              	.LVL256:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3098              		.loc 1 1363 0
 3099 19a4 DBE4D6E5 		ldrb	lr, [r6, #1243]	@ zero_extendqisi2
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3100              		.loc 1 1365 0
 3101 19a8 0010E0E3 		mvn	r1, #0
 3102 19ac 1C0094E5 		ldr	r0, [r4, #28]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3103              		.loc 1 1361 0
 3104 19b0 FFA003E2 		and	sl, r3, #255
 3105              	.LVL257:
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3106              		.loc 1 1362 0
 3107 19b4 FF8007E2 		and	r8, r7, #255
 3108              	.LVL258:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3109              		.loc 1 1363 0
 3110 19b8 FF700EE2 		and	r7, lr, #255
 3111              	.LVL259:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3112              		.loc 1 1365 0
 3113 19bc FEFFFFEB 		bl	_txe_mutex_get
 3114              	.LVL260:
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3115              		.loc 1 1373 0
 3116 19c0 D904D6E5 		ldrb	r0, [r6, #1241]	@ zero_extendqisi2
 3117 19c4 18109DE5 		ldr	r1, [sp, #24]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3118              		.loc 1 1361 0
 3119 19c8 88359FE5 		ldr	r3, .L329+72
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3120              		.loc 1 1373 0
 3121 19cc 000051E1 		cmp	r1, r0
 3122 19d0 0600000A 		beq	.L263
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3123              		.loc 1 1374 0
 3124 19d4 D914C3E5 		strb	r1, [r3, #1241]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3125              		.loc 1 1375 0
 3126 19d8 ED24D3E5 		ldrb	r2, [r3, #1261]	@ zero_extendqisi2
 3127 19dc 010052E3 		cmp	r2, #1
 3128 19e0 6803000A 		beq	.L264
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3129              		.loc 1 1375 0 is_stmt 0 discriminator 1
 3130 19e4 ED14D3E5 		ldrb	r1, [r3, #1261]	@ zero_extendqisi2
 3131 19e8 030051E3 		cmp	r1, #3
 3132 19ec 6503000A 		beq	.L264
 3133              	.LVL261:
 3134              	.L263:
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3135              		.loc 1 1382 0 is_stmt 1
 3136 19f0 1C0094E5 		ldr	r0, [r4, #28]
 3137 19f4 FEFFFFEB 		bl	_txe_mutex_put
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3138              		.loc 1 1384 0
 3139 19f8 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3140              		.loc 1 1383 0
 3141 19fc 18809DE5 		ldr	r8, [sp, #24]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3142              		.loc 1 1384 0
 3143 1a00 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3144              		.loc 1 1383 0
 3145 1a04 1C409DE5 		ldr	r4, [sp, #28]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3146              		.loc 1 1384 0
 3147 1a08 D974D6E5 		ldrb	r7, [r6, #1241]	@ zero_extendqisi2
 3148              	.LVL262:
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3149              		.loc 1 1383 0
 3150 1a0c 0400A0E3 		mov	r0, #4
 3151 1a10 1C159FE5 		ldr	r1, .L329+36
1385:../uvc.c      **** 							 break;
 3152              		.loc 1 1385 0
 3153 1a14 FFA0A0E3 		mov	sl, #255
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3154              		.loc 1 1383 0
 3155 1a18 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3156 1a1c 08408DE5 		str	r4, [sp, #8]
1385:../uvc.c      **** 							 break;
 3157              		.loc 1 1385 0
 3158 1a20 0A70A0E1 		mov	r7, sl
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3159              		.loc 1 1383 0
 3160 1a24 FEFFFFEB 		bl	CyU3PDebugPrint
1385:../uvc.c      **** 							 break;
 3161              		.loc 1 1385 0
 3162 1a28 8EFDFFEA 		b	.L160
 3163              	.LVL263:
 3164              	.L254:
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3165              		.loc 1 1462 0
 3166 1a2c A4C4D6E5 		ldrb	ip, [r6, #1188]	@ zero_extendqisi2
 3167              	.LVL264:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3168              		.loc 1 1467 0
 3169 1a30 18A59FE5 		ldr	sl, .L329+64
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3170              		.loc 1 1463 0
 3171 1a34 A534D6E5 		ldrb	r3, [r6, #1189]	@ zero_extendqisi2
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3172              		.loc 1 1464 0
 3173 1a38 B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3174              		.loc 1 1462 0
 3175 1a3c FF800CE2 		and	r8, ip, #255
 3176              	.LVL265:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3177              		.loc 1 1467 0
 3178 1a40 0010E0E3 		mvn	r1, #0
 3179 1a44 1C009AE5 		ldr	r0, [sl, #28]
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3180              		.loc 1 1464 0
 3181 1a48 FF400EE2 		and	r4, lr, #255
 3182              	.LVL266:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3183              		.loc 1 1467 0
 3184 1a4c FEFFFFEB 		bl	_txe_mutex_get
 3185              	.LVL267:
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3186              		.loc 1 1468 0
 3187 1a50 0820A0E1 		mov	r2, r8
 3188 1a54 18809DE5 		ldr	r8, [sp, #24]
 3189              	.LVL268:
 3190 1a58 0430A0E1 		mov	r3, r4
 3191 1a5c 2510A0E3 		mov	r1, #37
 3192 1a60 0A00A0E1 		mov	r0, sl
 3193 1a64 0070A0E3 		mov	r7, #0
 3194              	.LVL269:
 3195 1a68 00808DE5 		str	r8, [sp, #0]
 3196 1a6c 04708DE5 		str	r7, [sp, #4]
 3197 1a70 FEFFFFEB 		bl	cmdSet
 3198              	.LVL270:
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3199              		.loc 1 1469 0
 3200 1a74 1C009AE5 		ldr	r0, [sl, #28]
 3201 1a78 FEFFFFEB 		bl	_txe_mutex_put
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3202              		.loc 1 1470 0
 3203 1a7c 18409DE5 		ldr	r4, [sp, #24]
 3204              	.LVL271:
1474:../uvc.c      **** 							 break;
 3205              		.loc 1 1474 0
 3206 1a80 FFA0A0E3 		mov	sl, #255
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3207              		.loc 1 1471 0
 3208 1a84 0100A0E3 		mov	r0, #1
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3209              		.loc 1 1470 0
 3210 1a88 B144C6E5 		strb	r4, [r6, #1201]
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3211              		.loc 1 1471 0
 3212 1a8c 0480A0E1 		mov	r8, r4
 3213 1a90 B504C6E5 		strb	r0, [r6, #1205]
 3214 1a94 1C409DE5 		ldr	r4, [sp, #28]
1474:../uvc.c      **** 							 break;
 3215              		.loc 1 1474 0
 3216 1a98 0A70A0E1 		mov	r7, sl
 3217 1a9c 71FDFFEA 		b	.L160
 3218              	.LVL272:
 3219              	.L253:
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3220              		.loc 1 1422 0
 3221 1aa0 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3222              		.loc 1 1449 0
 3223 1aa4 A4449FE5 		ldr	r4, .L329+64
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3224              		.loc 1 1423 0
 3225 1aa8 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 3226              	.LVL273:
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3227              		.loc 1 1424 0
 3228 1aac 9F14D6E5 		ldrb	r1, [r6, #1183]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3229              		.loc 1 1449 0
 3230 1ab0 1C0094E5 		ldr	r0, [r4, #28]
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3231              		.loc 1 1424 0
 3232 1ab4 FF7001E2 		and	r7, r1, #255
 3233              	.LVL274:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3234              		.loc 1 1449 0
 3235 1ab8 0010E0E3 		mvn	r1, #0
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3236              		.loc 1 1422 0
 3237 1abc FF9003E2 		and	r9, r3, #255
 3238              	.LVL275:
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3239              		.loc 1 1423 0
 3240 1ac0 FF8002E2 		and	r8, r2, #255
 3241              	.LVL276:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3242              		.loc 1 1449 0
 3243 1ac4 14C08DE5 		str	ip, [sp, #20]
 3244 1ac8 FEFFFFEB 		bl	_txe_mutex_get
 3245              	.LVL277:
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3246              		.loc 1 1451 0
 3247 1acc 18C09DE5 		ldr	ip, [sp, #24]
 3248 1ad0 00E0A0E3 		mov	lr, #0
 3249 1ad4 0920A0E1 		mov	r2, r9
 3250 1ad8 0730A0E1 		mov	r3, r7
 3251 1adc 2410A0E3 		mov	r1, #36
 3252 1ae0 0400A0E1 		mov	r0, r4
 3253 1ae4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3254 1ae8 FEFFFFEB 		bl	cmdSet
 3255              	.LVL278:
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 3256              		.loc 1 1453 0
 3257 1aec 14A09DE5 		ldr	sl, [sp, #20]
 3258 1af0 0820A0E1 		mov	r2, r8
 3259 1af4 0730A0E1 		mov	r3, r7
 3260 1af8 0190A0E3 		mov	r9, #1
 3261              	.LVL279:
 3262 1afc 2410A0E3 		mov	r1, #36
 3263 1b00 0400A0E1 		mov	r0, r4
 3264 1b04 00A08DE5 		str	sl, [sp, #0]
 3265 1b08 04908DE5 		str	r9, [sp, #4]
 3266 1b0c FEFFFFEB 		bl	cmdSet
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3267              		.loc 1 1454 0
 3268 1b10 1C0094E5 		ldr	r0, [r4, #28]
 3269 1b14 FEFFFFEB 		bl	_txe_mutex_put
 3270              	.LVL280:
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3271              		.loc 1 1457 0
 3272 1b18 18809DE5 		ldr	r8, [sp, #24]
 3273              	.LVL281:
1460:../uvc.c      **** 							 break;
 3274              		.loc 1 1460 0
 3275 1b1c FFA0A0E3 		mov	sl, #255
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3276              		.loc 1 1457 0
 3277 1b20 9D84C6E5 		strb	r8, [r6, #1181]
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3278              		.loc 1 1458 0
 3279 1b24 14C09DE5 		ldr	ip, [sp, #20]
1460:../uvc.c      **** 							 break;
 3280              		.loc 1 1460 0
 3281 1b28 0A70A0E1 		mov	r7, sl
 3282              	.LVL282:
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3283              		.loc 1 1458 0
 3284 1b2c 9EC4C6E5 		strb	ip, [r6, #1182]
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3285              		.loc 1 1459 0
 3286 1b30 0C40A0E1 		mov	r4, ip
 3287 1b34 A194C6E5 		strb	r9, [r6, #1185]
1460:../uvc.c      **** 							 break;
 3288              		.loc 1 1460 0
 3289 1b38 4AFDFFEA 		b	.L160
 3290              	.LVL283:
 3291              	.L255:
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3292              		.loc 1 1477 0
 3293 1b3c 8780A0E1 		mov	r8, r7, asl #1
 3294 1b40 10B49FE5 		ldr	fp, .L329+72
 3295 1b44 07C088E0 		add	ip, r8, r7
 3296              	.LVL284:
 3297 1b48 8CE186E0 		add	lr, r6, ip, asl #3
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3298              		.loc 1 1483 0
 3299 1b4c FC439FE5 		ldr	r4, .L329+64
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3300              		.loc 1 1477 0
 3301 1b50 0D30CEE5 		strb	r3, [lr, #13]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3302              		.loc 1 1479 0
 3303 1b54 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1478:../uvc.c      **** 							 if(Data0 == 1){
 3304              		.loc 1 1478 0
 3305 1b58 010053E3 		cmp	r3, #1
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3306              		.loc 1 1483 0
 3307 1b5c 0010E0E3 		mvn	r1, #0
 3308 1b60 1C0094E5 		ldr	r0, [r4, #28]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3309              		.loc 1 1479 0
 3310 1b64 80B08B03 		orreq	fp, fp, #128
 3311              	.LVL285:
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 3312              		.loc 1 1481 0
 3313 1b68 7FB00B12 		andne	fp, fp, #127
 3314              	.LVL286:
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3315              		.loc 1 1483 0
 3316 1b6c FEFFFFEB 		bl	_txe_mutex_get
 3317              	.LVL287:
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3318              		.loc 1 1484 0
 3319 1b70 0A20A0E1 		mov	r2, sl
 3320 1b74 2610A0E3 		mov	r1, #38
 3321 1b78 0930A0E1 		mov	r3, r9
 3322 1b7c 0400A0E1 		mov	r0, r4
 3323 1b80 00A0A0E3 		mov	sl, #0
 3324 1b84 04A08DE5 		str	sl, [sp, #4]
 3325 1b88 00B08DE5 		str	fp, [sp, #0]
 3326 1b8c FEFFFFEB 		bl	cmdSet
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3327              		.loc 1 1485 0
 3328 1b90 1C0094E5 		ldr	r0, [r4, #28]
 3329 1b94 FEFFFFEB 		bl	_txe_mutex_put
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3330              		.loc 1 1487 0
 3331 1b98 071088E0 		add	r1, r8, r7
 3332 1b9c 816186E0 		add	r6, r6, r1, asl #3
1488:../uvc.c      **** 							 break;
 3333              		.loc 1 1488 0
 3334 1ba0 FFA0A0E3 		mov	sl, #255
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3335              		.loc 1 1487 0
 3336 1ba4 0120A0E3 		mov	r2, #1
 3337 1ba8 1020C6E5 		strb	r2, [r6, #16]
 3338 1bac 18809DE5 		ldr	r8, [sp, #24]
 3339 1bb0 1C409DE5 		ldr	r4, [sp, #28]
1488:../uvc.c      **** 							 break;
 3340              		.loc 1 1488 0
 3341 1bb4 0A70A0E1 		mov	r7, sl
 3342              	.LVL288:
 3343 1bb8 2AFDFFEA 		b	.L160
 3344              	.LVL289:
 3345              	.L244:
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3346              		.loc 1 1551 0
 3347 1bbc 8C439FE5 		ldr	r4, .L329+64
 3348 1bc0 0010E0E3 		mvn	r1, #0
 3349 1bc4 1C0094E5 		ldr	r0, [r4, #28]
 3350 1bc8 FEFFFFEB 		bl	_txe_mutex_get
 3351              	.LVL290:
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3352              		.loc 1 1552 0
 3353 1bcc 18C09DE5 		ldr	ip, [sp, #24]
 3354 1bd0 00E0A0E3 		mov	lr, #0
 3355 1bd4 0A20A0E1 		mov	r2, sl
 3356 1bd8 0610A0E3 		mov	r1, #6
 3357 1bdc 0930A0E1 		mov	r3, r9
 3358 1be0 0400A0E1 		mov	r0, r4
 3359 1be4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3360 1be8 FEFFFFEB 		bl	cmdSet
 3361              	.LVL291:
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3362              		.loc 1 1554 0
 3363 1bec 18A09DE5 		ldr	sl, [sp, #24]
 3364 1bf0 0170A0E3 		mov	r7, #1
 3365              	.LVL292:
 3366 1bf4 0610A0E3 		mov	r1, #6
 3367 1bf8 0B20A0E1 		mov	r2, fp
 3368 1bfc 0930A0E1 		mov	r3, r9
 3369 1c00 0400A0E1 		mov	r0, r4
 3370 1c04 00A08DE5 		str	sl, [sp, #0]
 3371 1c08 04708DE5 		str	r7, [sp, #4]
 3372 1c0c FEFFFFEB 		bl	cmdSet
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3373              		.loc 1 1555 0
 3374 1c10 1C0094E5 		ldr	r0, [r4, #28]
 3375 1c14 FEFFFFEB 		bl	_txe_mutex_put
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3376              		.loc 1 1556 0
 3377 1c18 18809DE5 		ldr	r8, [sp, #24]
1558:../uvc.c      **** 							 break;
 3378              		.loc 1 1558 0
 3379 1c1c FFA0A0E3 		mov	sl, #255
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3380              		.loc 1 1557 0
 3381 1c20 2072C6E5 		strb	r7, [r6, #544]
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3382              		.loc 1 1556 0
 3383 1c24 1D82C6E5 		strb	r8, [r6, #541]
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3384              		.loc 1 1557 0
 3385 1c28 1C409DE5 		ldr	r4, [sp, #28]
1558:../uvc.c      **** 							 break;
 3386              		.loc 1 1558 0
 3387 1c2c 0A70A0E1 		mov	r7, sl
 3388 1c30 0CFDFFEA 		b	.L160
 3389              	.LVL293:
 3390              	.L243:
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3391              		.loc 1 1531 0
 3392 1c34 14839FE5 		ldr	r8, .L329+64
 3393 1c38 0010E0E3 		mvn	r1, #0
 3394 1c3c 1C0098E5 		ldr	r0, [r8, #28]
 3395 1c40 FEFFFFEB 		bl	_txe_mutex_get
 3396              	.LVL294:
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3397              		.loc 1 1532 0
 3398 1c44 18209DE5 		ldr	r2, [sp, #24]
 3399 1c48 00C0A0E3 		mov	ip, #0
 3400 1c4c 803042E2 		sub	r3, r2, #128
 3401 1c50 FF4003E2 		and	r4, r3, #255
 3402 1c54 0A20A0E1 		mov	r2, sl
 3403 1c58 0510A0E3 		mov	r1, #5
 3404 1c5c 0930A0E1 		mov	r3, r9
 3405 1c60 0800A0E1 		mov	r0, r8
 3406 1c64 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3407 1c68 FEFFFFEB 		bl	cmdSet
 3408              	.LVL295:
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3409              		.loc 1 1534 0
 3410 1c6c 18A09DE5 		ldr	sl, [sp, #24]
 3411 1c70 0510A0E3 		mov	r1, #5
 3412 1c74 76704AE2 		sub	r7, sl, #118
 3413              	.LVL296:
 3414 1c78 FFE007E2 		and	lr, r7, #255
 3415 1c7c DC20A0E3 		mov	r2, #220
 3416 1c80 0170A0E3 		mov	r7, #1
 3417 1c84 0930A0E1 		mov	r3, r9
 3418 1c88 0800A0E1 		mov	r0, r8
 3419 1c8c 00E08DE5 		str	lr, [sp, #0]
 3420 1c90 04708DE5 		str	r7, [sp, #4]
 3421 1c94 FEFFFFEB 		bl	cmdSet
 3422              	.LVL297:
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3423              		.loc 1 1536 0
 3424 1c98 18009DE5 		ldr	r0, [sp, #24]
 3425 1c9c 02C0A0E3 		mov	ip, #2
 3426 1ca0 7E1080E2 		add	r1, r0, #126
 3427 1ca4 FF4001E2 		and	r4, r1, #255
 3428 1ca8 DE20A0E3 		mov	r2, #222
 3429 1cac 0510A0E3 		mov	r1, #5
 3430 1cb0 0930A0E1 		mov	r3, r9
 3431 1cb4 0800A0E1 		mov	r0, r8
 3432 1cb8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3433 1cbc FEFFFFEB 		bl	cmdSet
 3434              	.LVL298:
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3435              		.loc 1 1538 0
 3436 1cc0 18209DE5 		ldr	r2, [sp, #24]
 3437 1cc4 0510A0E3 		mov	r1, #5
 3438 1cc8 723082E2 		add	r3, r2, #114
 3439 1ccc FFA003E2 		and	sl, r3, #255
 3440 1cd0 E020A0E3 		mov	r2, #224
 3441 1cd4 0930A0E1 		mov	r3, r9
 3442 1cd8 0800A0E1 		mov	r0, r8
 3443 1cdc 0340A0E3 		mov	r4, #3
 3444 1ce0 00A08DE5 		str	sl, [sp, #0]
 3445 1ce4 04408DE5 		str	r4, [sp, #4]
 3446 1ce8 FEFFFFEB 		bl	cmdSet
 3447              	.LVL299:
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3448              		.loc 1 1540 0
 3449 1cec 18009DE5 		ldr	r0, [sp, #24]
 3450 1cf0 DD20A0E3 		mov	r2, #221
 3451 1cf4 6F1040E2 		sub	r1, r0, #111
 3452 1cf8 FFC001E2 		and	ip, r1, #255
 3453 1cfc 0930A0E1 		mov	r3, r9
 3454 1d00 0510A0E3 		mov	r1, #5
 3455 1d04 0800A0E1 		mov	r0, r8
 3456 1d08 04A0A0E3 		mov	sl, #4
 3457 1d0c 00C08DE5 		str	ip, [sp, #0]
 3458 1d10 04A08DE5 		str	sl, [sp, #4]
 3459 1d14 FEFFFFEB 		bl	cmdSet
 3460              	.LVL300:
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3461              		.loc 1 1542 0
 3462 1d18 3C229FE5 		ldr	r2, .L329+76
 3463 1d1c 05E0A0E3 		mov	lr, #5
 3464 1d20 1C41D2E5 		ldrb	r4, [r2, #284]	@ zero_extendqisi2
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3465              		.loc 1 1545 0
 3466 1d24 30A29FE5 		ldr	sl, .L329+76
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3467              		.loc 1 1542 0
 3468 1d28 7F3084E2 		add	r3, r4, #127
 3469 1d2c FFC003E2 		and	ip, r3, #255
 3470 1d30 0E10A0E1 		mov	r1, lr
 3471 1d34 0B20A0E1 		mov	r2, fp
 3472 1d38 0930A0E1 		mov	r3, r9
 3473 1d3c 0800A0E1 		mov	r0, r8
 3474 1d40 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3475 1d44 FEFFFFEB 		bl	cmdSet
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3476              		.loc 1 1543 0
 3477 1d48 1C0098E5 		ldr	r0, [r8, #28]
 3478 1d4c FEFFFFEB 		bl	_txe_mutex_put
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3479              		.loc 1 1545 0
 3480 1d50 1C01DAE5 		ldrb	r0, [sl, #284]	@ zero_extendqisi2
1547:../uvc.c      **** 							 break;
 3481              		.loc 1 1547 0
 3482 1d54 FFA0A0E3 		mov	sl, #255
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3483              		.loc 1 1545 0
 3484 1d58 801040E2 		sub	r1, r0, #128
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3485              		.loc 1 1546 0
 3486 1d5c 0872C6E5 		strb	r7, [r6, #520]
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3487              		.loc 1 1545 0
 3488 1d60 0512C6E5 		strb	r1, [r6, #517]
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3489              		.loc 1 1546 0
 3490 1d64 18809DE5 		ldr	r8, [sp, #24]
 3491 1d68 1C409DE5 		ldr	r4, [sp, #28]
1547:../uvc.c      **** 							 break;
 3492              		.loc 1 1547 0
 3493 1d6c 0A70A0E1 		mov	r7, sl
 3494 1d70 BCFCFFEA 		b	.L160
 3495              	.LVL301:
 3496              	.L242:
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
 3497              		.loc 1 1578 0
 3498 1d74 012043E2 		sub	r2, r3, #1
 3499              	.LVL302:
 3500 1d78 FF2002E2 		and	r2, r2, #255
 3501              	.LVL303:
1579:../uvc.c      **** 							 is60Hz = Data0;
 3502              		.loc 1 1579 0
 3503 1d7c D8119FE5 		ldr	r1, .L329+76
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3504              		.loc 1 1590 0
 3505 1d80 D4E19FE5 		ldr	lr, .L329+76
1585:../uvc.c      **** 							 else if(Data0 >2)
 3506              		.loc 1 1585 0
 3507 1d84 020052E3 		cmp	r2, #2
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3508              		.loc 1 1577 0
 3509 1d88 ED31C6E5 		strb	r3, [r6, #493]
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3510              		.loc 1 1588 0
 3511 1d8c 0130A083 		movhi	r3, #1
1579:../uvc.c      **** 							 is60Hz = Data0;
 3512              		.loc 1 1579 0
 3513 1d90 D82081E5 		str	r2, [r1, #216]
 3514              	.LVL304:
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3515              		.loc 1 1590 0
 3516 1d94 0400A0E3 		mov	r0, #4
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3517              		.loc 1 1588 0
 3518 1d98 D8308185 		strhi	r3, [r1, #216]
 3519              	.LVL305:
 3520 1d9c 0320A081 		movhi	r2, r3
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3521              		.loc 1 1590 0
 3522 1da0 90119FE5 		ldr	r1, .L329+40
 3523 1da4 D8309EE5 		ldr	r3, [lr, #216]
 3524 1da8 FEFFFFEB 		bl	CyU3PDebugPrint
 3525              	.LVL306:
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3526              		.loc 1 1591 0
 3527 1dac A8019FE5 		ldr	r0, .L329+76
 3528 1db0 A83090E5 		ldr	r3, [r0, #168]
 3529 1db4 010053E3 		cmp	r3, #1
 3530 1db8 5101000A 		beq	.L325
 3531              	.LVL307:
 3532              	.L276:
1622:../uvc.c      **** 							 break;
 3533              		.loc 1 1622 0
 3534 1dbc FFA0A0E3 		mov	sl, #255
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3535              		.loc 1 1621 0
 3536 1dc0 0130A0E3 		mov	r3, #1
 3537 1dc4 F031C6E5 		strb	r3, [r6, #496]
 3538 1dc8 18809DE5 		ldr	r8, [sp, #24]
 3539 1dcc 1C409DE5 		ldr	r4, [sp, #28]
1622:../uvc.c      **** 							 break;
 3540              		.loc 1 1622 0
 3541 1dd0 0A70A0E1 		mov	r7, sl
 3542 1dd4 A3FCFFEA 		b	.L160
 3543              	.LVL308:
 3544              	.L241:
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3545              		.loc 1 1677 0
 3546 1dd8 70819FE5 		ldr	r8, .L329+64
 3547 1ddc 0010E0E3 		mvn	r1, #0
 3548 1de0 1C0098E5 		ldr	r0, [r8, #28]
 3549 1de4 FEFFFFEB 		bl	_txe_mutex_get
 3550              	.LVL309:
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3551              		.loc 1 1678 0
 3552 1de8 18C09DE5 		ldr	ip, [sp, #24]
 3553 1dec 0410A0E1 		mov	r1, r4
 3554 1df0 0A20A0E1 		mov	r2, sl
 3555 1df4 0930A0E1 		mov	r3, r9
 3556 1df8 0800A0E1 		mov	r0, r8
 3557 1dfc 00A0A0E3 		mov	sl, #0
 3558 1e00 00C08DE5 		str	ip, [sp, #0]
 3559 1e04 04A08DE5 		str	sl, [sp, #4]
 3560 1e08 FEFFFFEB 		bl	cmdSet
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3561              		.loc 1 1679 0
 3562 1e0c 1C0098E5 		ldr	r0, [r8, #28]
 3563 1e10 FEFFFFEB 		bl	_txe_mutex_put
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3564              		.loc 1 1681 0
 3565 1e14 18709DE5 		ldr	r7, [sp, #24]
 3566              	.LVL310:
1686:../uvc.c      **** 							 break;
 3567              		.loc 1 1686 0
 3568 1e18 FFA0A0E3 		mov	sl, #255
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3569              		.loc 1 1682 0
 3570 1e1c 0130A0E3 		mov	r3, #1
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3571              		.loc 1 1681 0
 3572 1e20 BD71C6E5 		strb	r7, [r6, #445]
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3573              		.loc 1 1682 0
 3574 1e24 0780A0E1 		mov	r8, r7
 3575 1e28 C031C6E5 		strb	r3, [r6, #448]
 3576 1e2c 1C409DE5 		ldr	r4, [sp, #28]
1686:../uvc.c      **** 							 break;
 3577              		.loc 1 1686 0
 3578 1e30 0A70A0E1 		mov	r7, sl
 3579 1e34 8BFCFFEA 		b	.L160
 3580              	.LVL311:
 3581              	.L240:
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3582              		.loc 1 1513 0
 3583 1e38 10819FE5 		ldr	r8, .L329+64
 3584 1e3c 0010E0E3 		mvn	r1, #0
 3585 1e40 1C0098E5 		ldr	r0, [r8, #28]
 3586 1e44 FEFFFFEB 		bl	_txe_mutex_get
 3587              	.LVL312:
1515:../uvc.c      **** 							  if(Data0&0x80){
 3588              		.loc 1 1515 0
 3589 1e48 18209DE5 		ldr	r2, [sp, #24]
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3590              		.loc 1 1520 0
 3591 1e4c 0930A0E1 		mov	r3, r9
1515:../uvc.c      **** 							  if(Data0&0x80){
 3592              		.loc 1 1515 0
 3593 1e50 800012E3 		tst	r2, #128
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3594              		.loc 1 1516 0
 3595 1e54 80704212 		subne	r7, r2, #128
 3596              	.LVL313:
1518:../uvc.c      **** 								  Data0 = ~Data0;
 3597              		.loc 1 1518 0
 3598 1e58 0270E001 		mvneq	r7, r2
 3599 1e5c FF7007E2 		and	r7, r7, #255
 3600              	.LVL314:
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3601              		.loc 1 1520 0
 3602 1e60 0110A0E3 		mov	r1, #1
 3603 1e64 0B20A0E1 		mov	r2, fp
 3604 1e68 0040A0E3 		mov	r4, #0
 3605 1e6c DC009FE5 		ldr	r0, .L329+64
 3606 1e70 00708DE5 		str	r7, [sp, #0]
 3607 1e74 04408DE5 		str	r4, [sp, #4]
 3608 1e78 FEFFFFEB 		bl	cmdSet
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3609              		.loc 1 1521 0
 3610 1e7c 1C0098E5 		ldr	r0, [r8, #28]
 3611 1e80 FEFFFFEB 		bl	_txe_mutex_put
1527:../uvc.c      **** 							 break;
 3612              		.loc 1 1527 0
 3613 1e84 FFA0A0E3 		mov	sl, #255
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3614              		.loc 1 1524 0
 3615 1e88 0130A0E3 		mov	r3, #1
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3616              		.loc 1 1523 0
 3617 1e8c A571C6E5 		strb	r7, [r6, #421]
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3618              		.loc 1 1524 0
 3619 1e90 A831C6E5 		strb	r3, [r6, #424]
 3620 1e94 18809DE5 		ldr	r8, [sp, #24]
 3621 1e98 1C409DE5 		ldr	r4, [sp, #28]
1527:../uvc.c      **** 							 break;
 3622              		.loc 1 1527 0
 3623 1e9c 0A70A0E1 		mov	r7, sl
 3624              	.LVL315:
 3625 1ea0 70FCFFEA 		b	.L160
 3626              	.LVL316:
 3627              	.L239:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3628              		.loc 1 1634 0
 3629 1ea4 B0409FE5 		ldr	r4, .L329+76
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3630              		.loc 1 1624 0
 3631 1ea8 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3632              	.LVL317:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3633              		.loc 1 1634 0
 3634 1eac 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 3635              	.LVL318:
 3636 1eb0 0310A0E1 		mov	r1, r3
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3637              		.loc 1 1625 0
 3638 1eb4 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3639              		.loc 1 1626 0
 3640 1eb8 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3641              		.loc 1 1634 0
 3642 1ebc 010052E3 		cmp	r2, #1
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3643              		.loc 1 1632 0
 3644 1ec0 01E0A0E3 		mov	lr, #1
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3645              		.loc 1 1631 0
 3646 1ec4 0515C6E5 		strb	r1, [r6, #1285]
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3647              		.loc 1 1624 0
 3648 1ec8 FF7007E2 		and	r7, r7, #255
 3649              	.LVL319:
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3650              		.loc 1 1632 0
 3651 1ecc 09E5C6E5 		strb	lr, [r6, #1289]
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3652              		.loc 1 1626 0
 3653 1ed0 FF8008E2 		and	r8, r8, #255
 3654              	.LVL320:
 3655 1ed4 0160A011 		movne	r6, r1
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3656              		.loc 1 1634 0
 3657 1ed8 6E01000A 		beq	.L326
 3658              	.LVL321:
 3659              	.L290:
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3660              		.loc 1 1645 0
 3661 1edc 6CA09FE5 		ldr	sl, .L329+64
 3662 1ee0 0010E0E3 		mvn	r1, #0
 3663 1ee4 1C009AE5 		ldr	r0, [sl, #28]
 3664 1ee8 FEFFFFEB 		bl	_txe_mutex_get
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3665              		.loc 1 1646 0
 3666 1eec 00C0A0E3 		mov	ip, #0
 3667 1ef0 0C10A0E1 		mov	r1, ip
 3668 1ef4 0720A0E1 		mov	r2, r7
 3669 1ef8 0830A0E1 		mov	r3, r8
 3670 1efc 0A00A0E1 		mov	r0, sl
 3671 1f00 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3672 1f04 FEFFFFEB 		bl	cmdSet
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3673              		.loc 1 1647 0
 3674 1f08 1C009AE5 		ldr	r0, [sl, #28]
 3675 1f0c 9BFEFFEA 		b	.L316
 3676              	.L330:
 3677              		.align	2
 3678              	.L329:
 3679 1f10 00000000 		.word	bRequest
 3680 1f14 38050000 		.word	.LC31
 3681 1f18 1C010000 		.word	.LANCHOR0+284
 3682 1f1c 01000100 		.word	65537
 3683 1f20 FF00FF00 		.word	16711935
 3684 1f24 C8030000 		.word	.LC23
 3685 1f28 04040000 		.word	.LC24
 3686 1f2c 68030000 		.word	.LC21
 3687 1f30 CC000000 		.word	.LANCHOR0+204
 3688 1f34 8C040000 		.word	.LC27
 3689 1f38 C4040000 		.word	.LC28
 3690 1f3c 58040000 		.word	.LC26
 3691 1f40 2C040000 		.word	.LC25
 3692 1f44 08050000 		.word	.LC30
 3693 1f48 E4040000 		.word	.LC29
 3694 1f4c 40030000 		.word	.LC20
 3695 1f50 00000000 		.word	cmdQu
 3696 1f54 90030000 		.word	.LC22
 3697 1f58 00000000 		.word	.LANCHOR1
 3698 1f5c 00000000 		.word	.LANCHOR0
 3699              	.LVL322:
 3700              	.L238:
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3701              		.loc 1 1690 0
 3702 1f60 18701FE5 		ldr	r7, .L329+64
 3703              	.LVL323:
 3704 1f64 0010E0E3 		mvn	r1, #0
 3705 1f68 1C0097E5 		ldr	r0, [r7, #28]
 3706 1f6c FEFFFFEB 		bl	_txe_mutex_get
 3707              	.LVL324:
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3708              		.loc 1 1691 0
 3709 1f70 0A20A0E1 		mov	r2, sl
 3710 1f74 18A09DE5 		ldr	sl, [sp, #24]
 3711 1f78 0410A0E1 		mov	r1, r4
 3712 1f7c 0930A0E1 		mov	r3, r9
 3713 1f80 0700A0E1 		mov	r0, r7
 3714 1f84 0080A0E3 		mov	r8, #0
 3715 1f88 00A08DE5 		str	sl, [sp, #0]
 3716 1f8c 04808DE5 		str	r8, [sp, #4]
 3717 1f90 FEFFFFEB 		bl	cmdSet
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3718              		.loc 1 1692 0
 3719 1f94 1C0097E5 		ldr	r0, [r7, #28]
 3720 1f98 FEFFFFEB 		bl	_txe_mutex_put
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3721              		.loc 1 1694 0
 3722 1f9c 18109DE5 		ldr	r1, [sp, #24]
 3723 1fa0 840084E0 		add	r0, r4, r4, asl #1
 3724 1fa4 806186E0 		add	r6, r6, r0, asl #3
1696:../uvc.c      **** 							 break;
 3725              		.loc 1 1696 0
 3726 1fa8 FFA0A0E3 		mov	sl, #255
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3727              		.loc 1 1695 0
 3728 1fac 0120A0E3 		mov	r2, #1
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3729              		.loc 1 1694 0
 3730 1fb0 8D11C6E5 		strb	r1, [r6, #397]
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3731              		.loc 1 1695 0
 3732 1fb4 9021C6E5 		strb	r2, [r6, #400]
 3733 1fb8 0180A0E1 		mov	r8, r1
 3734 1fbc 1C409DE5 		ldr	r4, [sp, #28]
1696:../uvc.c      **** 							 break;
 3735              		.loc 1 1696 0
 3736 1fc0 0A70A0E1 		mov	r7, sl
 3737 1fc4 27FCFFEA 		b	.L160
 3738              	.LVL325:
 3739              	.L248:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3740              		.loc 1 1331 0
 3741 1fc8 80401FE5 		ldr	r4, .L329+64
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3742              		.loc 1 1327 0
 3743 1fcc E0A4D6E5 		ldrb	sl, [r6, #1248]	@ zero_extendqisi2
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3744              		.loc 1 1328 0
 3745 1fd0 E1E4D6E5 		ldrb	lr, [r6, #1249]	@ zero_extendqisi2
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3746              		.loc 1 1329 0
 3747 1fd4 EFC4D6E5 		ldrb	ip, [r6, #1263]	@ zero_extendqisi2
 3748              	.LVL326:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3749              		.loc 1 1331 0
 3750 1fd8 0010E0E3 		mvn	r1, #0
 3751 1fdc 1C0094E5 		ldr	r0, [r4, #28]
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3752              		.loc 1 1329 0
 3753 1fe0 FF800CE2 		and	r8, ip, #255
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3754              		.loc 1 1328 0
 3755 1fe4 FF900EE2 		and	r9, lr, #255
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3756              		.loc 1 1331 0
 3757 1fe8 FEFFFFEB 		bl	_txe_mutex_get
 3758              	.LVL327:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3759              		.loc 1 1332 0
 3760 1fec 18C09DE5 		ldr	ip, [sp, #24]
 3761 1ff0 ED14D6E5 		ldrb	r1, [r6, #1261]	@ zero_extendqisi2
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3762              		.loc 1 1327 0
 3763 1ff4 FFA00AE2 		and	sl, sl, #255
 3764              	.LVL328:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3765              		.loc 1 1332 0
 3766 1ff8 01005CE1 		cmp	ip, r1
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3767              		.loc 1 1327 0
 3768 1ffc AC301FE5 		ldr	r3, .L329+72
 3769 2000 0C70A001 		moveq	r7, ip
 3770              	.LVL329:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3771              		.loc 1 1332 0
 3772 2004 0A00000A 		beq	.L261
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3773              		.loc 1 1334 0
 3774 2008 EDC4C3E5 		strb	ip, [r3, #1261]
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3775              		.loc 1 1335 0
 3776 200c C534D3E5 		ldrb	r3, [r3, #1221]	@ zero_extendqisi2
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3777              		.loc 1 1336 0
 3778 2010 0400A0E1 		mov	r0, r4
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3779              		.loc 1 1335 0
 3780 2014 03728CE1 		orr	r7, ip, r3, asl #4
 3781 2018 FF7007E2 		and	r7, r7, #255
 3782              	.LVL330:
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3783              		.loc 1 1336 0
 3784 201c 00C0A0E3 		mov	ip, #0
 3785 2020 1910A0E3 		mov	r1, #25
 3786 2024 0A20A0E1 		mov	r2, sl
 3787 2028 0830A0E1 		mov	r3, r8
 3788 202c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3789 2030 FEFFFFEB 		bl	cmdSet
 3790              	.LVL331:
 3791              	.L261:
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3792              		.loc 1 1348 0
 3793 2034 EE04D6E5 		ldrb	r0, [r6, #1262]	@ zero_extendqisi2
 3794 2038 1CE09DE5 		ldr	lr, [sp, #28]
 3795 203c 0E0050E1 		cmp	r0, lr
 3796 2040 0500000A 		beq	.L262
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3797              		.loc 1 1350 0
 3798 2044 18A09DE5 		ldr	sl, [sp, #24]
 3799              	.LVL332:
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3800              		.loc 1 1349 0
 3801 2048 F8201FE5 		ldr	r2, .L329+72
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3802              		.loc 1 1350 0
 3803 204c 02104AE2 		sub	r1, sl, #2
 3804 2050 010051E3 		cmp	r1, #1
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3805              		.loc 1 1349 0
 3806 2054 EEE4C2E5 		strb	lr, [r2, #1262]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3807              		.loc 1 1350 0
 3808 2058 E101009A 		bls	.L327
 3809              	.LVL333:
 3810              	.L262:
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3811              		.loc 1 1355 0
 3812 205c 1C0094E5 		ldr	r0, [r4, #28]
 3813 2060 FEFFFFEB 		bl	_txe_mutex_put
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3814              		.loc 1 1357 0
 3815 2064 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3816              		.loc 1 1356 0
 3817 2068 1C409DE5 		ldr	r4, [sp, #28]
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3818              		.loc 1 1357 0
 3819 206c EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
 3820 2070 C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3821              		.loc 1 1356 0
 3822 2074 0400A0E3 		mov	r0, #4
 3823 2078 44111FE5 		ldr	r1, .L329+44
1358:../uvc.c      **** 							 break;
 3824              		.loc 1 1358 0
 3825 207c FFA0A0E3 		mov	sl, #255
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3826              		.loc 1 1356 0
 3827 2080 04708DE5 		str	r7, [sp, #4]
 3828 2084 00C08DE5 		str	ip, [sp, #0]
 3829 2088 08408DE5 		str	r4, [sp, #8]
1358:../uvc.c      **** 							 break;
 3830              		.loc 1 1358 0
 3831 208c 0A70A0E1 		mov	r7, sl
 3832              	.LVL334:
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3833              		.loc 1 1356 0
 3834 2090 FEFFFFEB 		bl	CyU3PDebugPrint
 3835              	.LVL335:
 3836 2094 18809DE5 		ldr	r8, [sp, #24]
1358:../uvc.c      **** 							 break;
 3837              		.loc 1 1358 0
 3838 2098 F2FBFFEA 		b	.L160
 3839              	.LVL336:
 3840              	.L247:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3841              		.loc 1 1267 0
 3842 209c B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 3843 20a0 0310A0E1 		mov	r1, r3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3844              		.loc 1 1268 0
 3845 20a4 B984D6E5 		ldrb	r8, [r6, #1209]	@ zero_extendqisi2
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3846              		.loc 1 1269 0
 3847 20a8 C744D6E5 		ldrb	r4, [r6, #1223]	@ zero_extendqisi2
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3848              		.loc 1 1270 0
 3849 20ac C534C6E5 		strb	r3, [r6, #1221]
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3850              		.loc 1 1272 0
 3851 20b0 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3852              		.loc 1 1267 0
 3853 20b4 FF700AE2 		and	r7, sl, #255
 3854              	.LVL337:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3855              		.loc 1 1272 0
 3856 20b8 030013E3 		tst	r3, #3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3857              		.loc 1 1268 0
 3858 20bc FF8008E2 		and	r8, r8, #255
 3859              	.LVL338:
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3860              		.loc 1 1269 0
 3861 20c0 FF4004E2 		and	r4, r4, #255
 3862              	.LVL339:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3863              		.loc 1 1272 0
 3864 20c4 0130A001 		moveq	r3, r1
 3865 20c8 1D00000A 		beq	.L260
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3866              		.loc 1 1274 0
 3867 20cc 7C911FE5 		ldr	r9, .L329+72
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3868              		.loc 1 1276 0
 3869 20d0 88A11FE5 		ldr	sl, .L329+64
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3870              		.loc 1 1274 0
 3871 20d4 ED04D9E5 		ldrb	r0, [r9, #1261]	@ zero_extendqisi2
 3872 20d8 0120A0E1 		mov	r2, r1
 3873              	.LVL340:
 3874 20dc 023280E1 		orr	r3, r0, r2, asl #4
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3875              		.loc 1 1276 0
 3876 20e0 0010E0E3 		mvn	r1, #0
 3877 20e4 1C009AE5 		ldr	r0, [sl, #28]
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3878              		.loc 1 1274 0
 3879 20e8 FF9003E2 		and	r9, r3, #255
 3880              	.LVL341:
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3881              		.loc 1 1276 0
 3882 20ec 14C08DE5 		str	ip, [sp, #20]
 3883 20f0 FEFFFFEB 		bl	_txe_mutex_get
 3884              	.LVL342:
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3885              		.loc 1 1277 0
 3886 20f4 00E0A0E3 		mov	lr, #0
 3887 20f8 1010A0E3 		mov	r1, #16
 3888 20fc 0820A0E1 		mov	r2, r8
 3889 2100 0430A0E1 		mov	r3, r4
 3890 2104 0A00A0E1 		mov	r0, sl
 3891 2108 00E08DE5 		str	lr, [sp, #0]
 3892 210c 04E08DE5 		str	lr, [sp, #4]
 3893 2110 FEFFFFEB 		bl	cmdSet
 3894              	.LVL343:
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3895              		.loc 1 1279 0
 3896 2114 0720A0E1 		mov	r2, r7
 3897 2118 0430A0E1 		mov	r3, r4
 3898 211c 1010A0E3 		mov	r1, #16
 3899 2120 0A00A0E1 		mov	r0, sl
 3900 2124 0170A0E3 		mov	r7, #1
 3901              	.LVL344:
 3902 2128 00908DE5 		str	r9, [sp, #0]
 3903 212c 04708DE5 		str	r7, [sp, #4]
 3904 2130 FEFFFFEB 		bl	cmdSet
 3905              	.LVL345:
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3906              		.loc 1 1280 0
 3907 2134 1C009AE5 		ldr	r0, [sl, #28]
 3908 2138 FEFFFFEB 		bl	_txe_mutex_put
 3909 213c 14C09DE5 		ldr	ip, [sp, #20]
 3910 2140 0930A0E1 		mov	r3, r9
 3911              	.LVL346:
 3912              	.L260:
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3913              		.loc 1 1283 0
 3914 2144 ED84D6E5 		ldrb	r8, [r6, #1261]	@ zero_extendqisi2
 3915              	.LVL347:
 3916 2148 C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3917              	.LVL348:
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3918              		.loc 1 1282 0
 3919 214c 0400A0E3 		mov	r0, #4
 3920 2150 18121FE5 		ldr	r1, .L329+48
 3921 2154 0C20A0E1 		mov	r2, ip
1284:../uvc.c      **** 						     break;
 3922              		.loc 1 1284 0
 3923 2158 FFA0A0E3 		mov	sl, #255
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3924              		.loc 1 1282 0
 3925 215c 00808DE5 		str	r8, [sp, #0]
 3926 2160 04408DE5 		str	r4, [sp, #4]
1284:../uvc.c      **** 						     break;
 3927              		.loc 1 1284 0
 3928 2164 0A70A0E1 		mov	r7, sl
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3929              		.loc 1 1282 0
 3930 2168 FEFFFFEB 		bl	CyU3PDebugPrint
 3931 216c 18809DE5 		ldr	r8, [sp, #24]
 3932 2170 1C409DE5 		ldr	r4, [sp, #28]
1284:../uvc.c      **** 						     break;
 3933              		.loc 1 1284 0
 3934 2174 BBFBFFEA 		b	.L160
 3935              	.LVL349:
 3936              	.L246:
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3937              		.loc 1 1565 0
 3938 2178 30721FE5 		ldr	r7, .L329+64
 3939              	.LVL350:
 3940 217c 0010E0E3 		mvn	r1, #0
 3941 2180 1C0097E5 		ldr	r0, [r7, #28]
 3942 2184 FEFFFFEB 		bl	_txe_mutex_get
 3943              	.LVL351:
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3944              		.loc 1 1566 0
 3945 2188 18C09DE5 		ldr	ip, [sp, #24]
 3946 218c 0A20A0E1 		mov	r2, sl
 3947 2190 0B10A0E3 		mov	r1, #11
 3948 2194 0930A0E1 		mov	r3, r9
 3949 2198 0700A0E1 		mov	r0, r7
 3950 219c 00A0A0E3 		mov	sl, #0
 3951 21a0 00C08DE5 		str	ip, [sp, #0]
 3952 21a4 04A08DE5 		str	sl, [sp, #4]
 3953 21a8 FEFFFFEB 		bl	cmdSet
 3954              	.LVL352:
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3955              		.loc 1 1568 0
 3956 21ac 1C409DE5 		ldr	r4, [sp, #28]
 3957 21b0 0180A0E3 		mov	r8, #1
 3958 21b4 0B10A0E3 		mov	r1, #11
 3959 21b8 0B20A0E1 		mov	r2, fp
 3960 21bc 0930A0E1 		mov	r3, r9
 3961 21c0 0700A0E1 		mov	r0, r7
 3962 21c4 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3963 21c8 FEFFFFEB 		bl	cmdSet
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3964              		.loc 1 1569 0
 3965 21cc 1C0097E5 		ldr	r0, [r7, #28]
 3966 21d0 FEFFFFEB 		bl	_txe_mutex_put
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3967              		.loc 1 1571 0
 3968 21d4 18009DE5 		ldr	r0, [sp, #24]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3969              		.loc 1 1572 0
 3970 21d8 1C109DE5 		ldr	r1, [sp, #28]
1574:../uvc.c      **** 							 break;
 3971              		.loc 1 1574 0
 3972 21dc FFA0A0E3 		mov	sl, #255
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3973              		.loc 1 1573 0
 3974 21e0 9882C6E5 		strb	r8, [r6, #664]
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3975              		.loc 1 1571 0
 3976 21e4 F404C6E5 		strb	r0, [r6, #1268]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3977              		.loc 1 1572 0
 3978 21e8 F614C6E5 		strb	r1, [r6, #1270]
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3979              		.loc 1 1573 0
 3980 21ec 0080A0E1 		mov	r8, r0
 3981 21f0 0140A0E1 		mov	r4, r1
1574:../uvc.c      **** 							 break;
 3982              		.loc 1 1574 0
 3983 21f4 0A70A0E1 		mov	r7, sl
 3984 21f8 9AFBFFEA 		b	.L160
 3985              	.LVL353:
 3986              	.L245:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3987              		.loc 1 1651 0
 3988 21fc 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3989              		.loc 1 1652 0
 3990 2200 0D25D6E5 		ldrb	r2, [r6, #1293]	@ zero_extendqisi2
 3991              	.LVL354:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3992              		.loc 1 1653 0
 3993 2204 1B15D6E5 		ldrb	r1, [r6, #1307]	@ zero_extendqisi2
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3994              		.loc 1 1656 0
 3995 2208 0140A0E3 		mov	r4, #1
1657:../uvc.c      **** 							 if(Data0 != 0){
 3996              		.loc 1 1657 0
 3997 220c 000053E3 		cmp	r3, #0
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3998              		.loc 1 1655 0
 3999 2210 1935C6E5 		strb	r3, [r6, #1305]
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 4000              		.loc 1 1651 0
 4001 2214 FF8000E2 		and	r8, r0, #255
 4002              	.LVL355:
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4003              		.loc 1 1652 0
 4004 2218 FFA002E2 		and	sl, r2, #255
 4005              	.LVL356:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4006              		.loc 1 1653 0
 4007 221c FF7001E2 		and	r7, r1, #255
 4008              	.LVL357:
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4009              		.loc 1 1656 0
 4010 2220 1D45C6E5 		strb	r4, [r6, #1309]
1657:../uvc.c      **** 							 if(Data0 != 0){
 4011              		.loc 1 1657 0
 4012 2224 1C00000A 		beq	.L292
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4013              		.loc 1 1658 0
 4014 2228 E0621FE5 		ldr	r6, .L329+64
 4015 222c 0010E0E3 		mvn	r1, #0
 4016 2230 1C0096E5 		ldr	r0, [r6, #28]
 4017 2234 FEFFFFEB 		bl	_txe_mutex_get
 4018              	.LVL358:
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 4019              		.loc 1 1662 0
 4020 2238 0820A0E1 		mov	r2, r8
 4021 223c 00C0A0E3 		mov	ip, #0
 4022 2240 0710A0E3 		mov	r1, #7
 4023 2244 0730A0E1 		mov	r3, r7
 4024 2248 0600A0E1 		mov	r0, r6
 4025 224c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 4026 2250 FEFFFFEB 		bl	cmdSet
 4027              	.LVL359:
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 4028              		.loc 1 1664 0
 4029 2254 18809DE5 		ldr	r8, [sp, #24]
 4030              	.LVL360:
 4031 2258 0710A0E3 		mov	r1, #7
 4032 225c 0A20A0E1 		mov	r2, sl
 4033 2260 0730A0E1 		mov	r3, r7
 4034 2264 0600A0E1 		mov	r0, r6
 4035 2268 00808DE5 		str	r8, [sp, #0]
 4036 226c 04408DE5 		str	r4, [sp, #4]
 4037 2270 FEFFFFEB 		bl	cmdSet
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4038              		.loc 1 1666 0
 4039 2274 1C0096E5 		ldr	r0, [r6, #28]
 4040 2278 C0FDFFEA 		b	.L316
 4041              	.LVL361:
 4042              	.L237:
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 4043              		.loc 1 1699 0
 4044 227c FFA0A0E3 		mov	sl, #255
 4045 2280 0400A0E3 		mov	r0, #4
 4046              	.LVL362:
 4047 2284 48131FE5 		ldr	r1, .L329+52
 4048 2288 FEFFFFEB 		bl	CyU3PDebugPrint
 4049              	.LVL363:
 4050 228c 0A70A0E1 		mov	r7, sl
 4051              	.LVL364:
 4052 2290 0A40A0E1 		mov	r4, sl
 4053 2294 0A80A0E1 		mov	r8, sl
 4054 2298 72FBFFEA 		b	.L160
 4055              	.LVL365:
 4056              	.L292:
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4057              		.loc 1 1668 0
 4058 229c 54431FE5 		ldr	r4, .L329+64
 4059 22a0 0010E0E3 		mvn	r1, #0
 4060 22a4 1C0094E5 		ldr	r0, [r4, #28]
 4061 22a8 FEFFFFEB 		bl	_txe_mutex_get
 4062              	.LVL366:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4063              		.loc 1 1669 0
 4064 22ac 18E09DE5 		ldr	lr, [sp, #24]
 4065 22b0 0820A0E1 		mov	r2, r8
 4066 22b4 0730A0E1 		mov	r3, r7
 4067 22b8 0710A0E3 		mov	r1, #7
 4068 22bc 0400A0E1 		mov	r0, r4
 4069 22c0 00E08DE5 		str	lr, [sp, #0]
 4070 22c4 04E08DE5 		str	lr, [sp, #4]
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4071              		.loc 1 1670 0
 4072 22c8 FFA0A0E3 		mov	sl, #255
 4073              	.LVL367:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4074              		.loc 1 1669 0
 4075 22cc FEFFFFEB 		bl	cmdSet
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4076              		.loc 1 1670 0
 4077 22d0 1C0094E5 		ldr	r0, [r4, #28]
 4078 22d4 FEFFFFEB 		bl	_txe_mutex_put
 4079 22d8 0A70A0E1 		mov	r7, sl
 4080              	.LVL368:
 4081 22dc 1C409DE5 		ldr	r4, [sp, #28]
 4082 22e0 18809DE5 		ldr	r8, [sp, #24]
 4083              	.LVL369:
 4084 22e4 5FFBFFEA 		b	.L160
 4085              	.LVL370:
 4086              	.L324:
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4087              		.loc 1 1028 0
 4088 22e8 0A00A0E1 		mov	r0, sl
 4089 22ec 0910A0E1 		mov	r1, r9
 4090 22f0 FEFFFFEB 		bl	SensorGetControl
 4091              	.LVL371:
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4092              		.loc 1 1030 0
 4093 22f4 01A0A0E3 		mov	sl, #1
 4094 22f8 41A1C4E5 		strb	sl, [r4, #321]
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4095              		.loc 1 1029 0
 4096 22fc 0502C6E5 		strb	r0, [r6, #517]
 4097 2300 47FDFFEA 		b	.L207
 4098              	.LVL372:
 4099              	.L325:
1594:../uvc.c      **** 			                       switch (setRes)
 4100              		.loc 1 1594 0
 4101 2304 7D81D0E5 		ldrb	r8, [r0, #381]	@ zero_extendqisi2
 4102 2308 010048E2 		sub	r0, r8, #1
 4103 230c 030050E3 		cmp	r0, #3
 4104 2310 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 4105 2314 A8FEFFEA 		b	.L276
 4106              	.L281:
 4107 2318 44240000 		.word	.L277
 4108 231c F0230000 		.word	.L278
 4109 2320 8C230000 		.word	.L279
 4110 2324 28230000 		.word	.L280
 4111              	.L280:
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4112              		.loc 1 1612 0
 4113 2328 D4031FE5 		ldr	r0, .L329+76
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4114              		.loc 1 1614 0
 4115 232c D8A31FE5 		ldr	sl, .L329+76
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4116              		.loc 1 1612 0
 4117 2330 D8C090E5 		ldr	ip, [r0, #216]
 4118 2334 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4119 2338 00005CE3 		cmp	ip, #0
 4120 233c F4C0A003 		moveq	ip, #244
 4121 2340 74C0A013 		movne	ip, #116
 4122 2344 02208CE1 		orr	r2, ip, r2
 4123 2348 3010A0E3 		mov	r1, #48
 4124 234c 5230A0E3 		mov	r3, #82
 4125 2350 0100A0E3 		mov	r0, #1
 4126 2354 FEFFFFEB 		bl	SensorSetIrisControl
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4127              		.loc 1 1613 0
 4128 2358 7D0FA0E3 		mov	r0, #500
 4129 235c FEFFFFEB 		bl	_tx_thread_sleep
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4130              		.loc 1 1614 0
 4131 2360 D8409AE5 		ldr	r4, [sl, #216]
 4132 2364 8D74D6E5 		ldrb	r7, [r6, #1165]	@ zero_extendqisi2
 4133              	.LVL373:
 4134 2368 000054E3 		cmp	r4, #0
 4135 236c F440A003 		moveq	r4, #244
 4136 2370 7440A013 		movne	r4, #116
 4137 2374 D8309AE5 		ldr	r3, [sl, #216]
 4138 2378 38141FE5 		ldr	r1, .L329+56
 4139 237c 072084E1 		orr	r2, r4, r7
 4140 2380 0400A0E3 		mov	r0, #4
 4141 2384 FEFFFFEB 		bl	CyU3PDebugPrint
 4142 2388 8BFEFFEA 		b	.L276
 4143              	.LVL374:
 4144              	.L279:
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 4145              		.loc 1 1607 0
 4146 238c 38841FE5 		ldr	r8, .L329+76
 4147 2390 5230A0E3 		mov	r3, #82
 4148 2394 D8E098E5 		ldr	lr, [r8, #216]
 4149 2398 8D14D6E5 		ldrb	r1, [r6, #1165]	@ zero_extendqisi2
 4150 239c 00005EE3 		cmp	lr, #0
 4151 23a0 C4E0A003 		moveq	lr, #196
 4152 23a4 44E0A013 		movne	lr, #68
 4153 23a8 01208EE1 		orr	r2, lr, r1
 4154 23ac 0100A0E3 		mov	r0, #1
 4155 23b0 3010A0E3 		mov	r1, #48
 4156 23b4 FEFFFFEB 		bl	SensorSetIrisControl
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4157              		.loc 1 1608 0
 4158 23b8 7D0FA0E3 		mov	r0, #500
 4159 23bc FEFFFFEB 		bl	_tx_thread_sleep
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4160              		.loc 1 1609 0
 4161 23c0 6C341FE5 		ldr	r3, .L329+76
 4162 23c4 84141FE5 		ldr	r1, .L329+56
 4163 23c8 D80093E5 		ldr	r0, [r3, #216]
 4164 23cc 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4165 23d0 000050E3 		cmp	r0, #0
 4166 23d4 C400A003 		moveq	r0, #196
 4167 23d8 4400A013 		movne	r0, #68
 4168 23dc 022080E1 		orr	r2, r0, r2
 4169 23e0 D83093E5 		ldr	r3, [r3, #216]
 4170 23e4 0400A0E3 		mov	r0, #4
 4171 23e8 FEFFFFEB 		bl	CyU3PDebugPrint
1610:../uvc.c      **** 			                         		break;
 4172              		.loc 1 1610 0
 4173 23ec 72FEFFEA 		b	.L276
 4174              	.L278:
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4175              		.loc 1 1602 0
 4176 23f0 9CC41FE5 		ldr	ip, .L329+76
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4177              		.loc 1 1604 0
 4178 23f4 A0A41FE5 		ldr	sl, .L329+76
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4179              		.loc 1 1602 0
 4180 23f8 D8209CE5 		ldr	r2, [ip, #216]
 4181 23fc 3010A0E3 		mov	r1, #48
 4182 2400 000052E3 		cmp	r2, #0
 4183 2404 D420A003 		moveq	r2, #212
 4184 2408 5420A013 		movne	r2, #84
 4185 240c 5230A0E3 		mov	r3, #82
 4186 2410 0100A0E3 		mov	r0, #1
 4187 2414 FEFFFFEB 		bl	SensorSetIrisControl
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4188              		.loc 1 1603 0
 4189 2418 7D0FA0E3 		mov	r0, #500
 4190 241c FEFFFFEB 		bl	_tx_thread_sleep
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4191              		.loc 1 1604 0
 4192 2420 D8209AE5 		ldr	r2, [sl, #216]
 4193 2424 E4141FE5 		ldr	r1, .L329+56
 4194 2428 000052E3 		cmp	r2, #0
 4195 242c D8309AE5 		ldr	r3, [sl, #216]
 4196 2430 D420A003 		moveq	r2, #212
 4197 2434 5420A013 		movne	r2, #84
 4198 2438 0400A0E3 		mov	r0, #4
 4199 243c FEFFFFEB 		bl	CyU3PDebugPrint
1605:../uvc.c      **** 			                         		break;
 4200              		.loc 1 1605 0
 4201 2440 5DFEFFEA 		b	.L276
 4202              	.L277:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4203              		.loc 1 1597 0
 4204 2444 F0441FE5 		ldr	r4, .L329+76
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4205              		.loc 1 1599 0
 4206 2448 F4741FE5 		ldr	r7, .L329+76
 4207              	.LVL375:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4208              		.loc 1 1597 0
 4209 244c D82094E5 		ldr	r2, [r4, #216]
 4210 2450 3010A0E3 		mov	r1, #48
 4211 2454 000052E3 		cmp	r2, #0
 4212 2458 E420A003 		moveq	r2, #228
 4213 245c 6420A013 		movne	r2, #100
 4214 2460 5230A0E3 		mov	r3, #82
 4215 2464 0100A0E3 		mov	r0, #1
 4216 2468 FEFFFFEB 		bl	SensorSetIrisControl
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4217              		.loc 1 1598 0
 4218 246c 7D0FA0E3 		mov	r0, #500
 4219 2470 FEFFFFEB 		bl	_tx_thread_sleep
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4220              		.loc 1 1599 0
 4221 2474 D82097E5 		ldr	r2, [r7, #216]
 4222 2478 38151FE5 		ldr	r1, .L329+56
 4223 247c 000052E3 		cmp	r2, #0
 4224 2480 D83097E5 		ldr	r3, [r7, #216]
 4225 2484 E420A003 		moveq	r2, #228
 4226 2488 6420A013 		movne	r2, #100
 4227 248c 0400A0E3 		mov	r0, #4
 4228 2490 FEFFFFEB 		bl	CyU3PDebugPrint
1600:../uvc.c      **** 			                         		break;
 4229              		.loc 1 1600 0
 4230 2494 48FEFFEA 		b	.L276
 4231              	.LVL376:
 4232              	.L326:
1636:../uvc.c      **** 								 if(Data0 < 3){
 4233              		.loc 1 1636 0
 4234 2498 020051E3 		cmp	r1, #2
1637:../uvc.c      **** 					 				 Data0 += 4;
 4235              		.loc 1 1637 0
 4236 249c 04608192 		addls	r6, r1, #4
 4237 24a0 FF600692 		andls	r6, r6, #255
1636:../uvc.c      **** 								 if(Data0 < 3){
 4238              		.loc 1 1636 0
 4239 24a4 8CFEFF9A 		bls	.L290
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4240              		.loc 1 1639 0
 4241 24a8 0400A0E3 		mov	r0, #4
 4242 24ac 60151FE5 		ldr	r1, .L329+68
 4243 24b0 18309DE5 		ldr	r3, [sp, #24]
 4244 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4245              	.LVL377:
1640:../uvc.c      **** 									Data0 = 4; //set to default.
 4246              		.loc 1 1640 0
 4247 24b8 0460A0E3 		mov	r6, #4
 4248 24bc 86FEFFEA 		b	.L290
 4249              	.LVL378:
 4250              	.L208:
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4251              		.loc 1 1046 0
 4252 24c0 0A00A0E1 		mov	r0, sl
 4253              	.LVL379:
 4254 24c4 0910A0E1 		mov	r1, r9
 4255 24c8 FEFFFFEB 		bl	SensorGetControl
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4256              		.loc 1 1047 0
 4257 24cc 0910A0E1 		mov	r1, r9
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4258              		.loc 1 1046 0
 4259 24d0 0070A0E1 		mov	r7, r0
 4260              	.LVL380:
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4261              		.loc 1 1047 0
 4262 24d4 0B00A0E1 		mov	r0, fp
 4263              	.LVL381:
 4264 24d8 FEFFFFEB 		bl	SensorGetControl
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4265              		.loc 1 1052 0
 4266 24dc 0110A0E3 		mov	r1, #1
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4267              		.loc 1 1048 0
 4268 24e0 1C71C4E5 		strb	r7, [r4, #284]
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4269              		.loc 1 1049 0
 4270 24e4 F474C6E5 		strb	r7, [r6, #1268]
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4271              		.loc 1 1052 0
 4272 24e8 4711C4E5 		strb	r1, [r4, #327]
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4273              		.loc 1 1047 0
 4274 24ec 00A0A0E1 		mov	sl, r0
 4275              	.LVL382:
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4276              		.loc 1 1050 0
 4277 24f0 1E01C4E5 		strb	r0, [r4, #286]
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4278              		.loc 1 1051 0
 4279 24f4 F604C6E5 		strb	r0, [r6, #1270]
 4280 24f8 3DFCFFEA 		b	.L209
 4281              	.LVL383:
 4282              	.L181:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4283              		.loc 1 840 0
 4284 24fc 0910A0E1 		mov	r1, r9
 4285 2500 0B00A0E1 		mov	r0, fp
 4286 2504 FEFFFFEB 		bl	SensorGetControl
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4287              		.loc 1 842 0
 4288 2508 0910A0E1 		mov	r1, r9
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4289              		.loc 1 843 0
 4290 250c 0170A0E3 		mov	r7, #1
 4291              	.LVL384:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4292              		.loc 1 840 0
 4293 2510 0030A0E1 		mov	r3, r0
 4294 2514 1C31C4E5 		strb	r3, [r4, #284]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4295              		.loc 1 842 0
 4296 2518 0A00A0E1 		mov	r0, sl
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4297              		.loc 1 841 0
 4298 251c 9D34C6E5 		strb	r3, [r6, #1181]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4299              		.loc 1 842 0
 4300 2520 FEFFFFEB 		bl	SensorGetControl
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4301              		.loc 1 843 0
 4302 2524 6071C4E5 		strb	r7, [r4, #352]
 4303 2528 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4304              	.LVL385:
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4305              		.loc 1 842 0
 4306 252c 00A0A0E1 		mov	sl, r0
 4307              	.LVL386:
 4308 2530 1D01C4E5 		strb	r0, [r4, #285]
 847:../uvc.c      **** 						 break;
 4309              		.loc 1 847 0
 4310 2534 F5FBFFEA 		b	.L183
 4311              	.LVL387:
 4312              	.L186:
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4313              		.loc 1 873 0
 4314 2538 0A00A0E1 		mov	r0, sl
 4315              	.LVL388:
 4316 253c 0910A0E1 		mov	r1, r9
 4317 2540 FEFFFFEB 		bl	SensorGetControl
 4318              	.LVL389:
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4319              		.loc 1 879 0
 4320 2544 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4321              		.loc 1 880 0
 4322 2548 01C0A0E3 		mov	ip, #1
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4323              		.loc 1 879 0
 4324 254c 1DA1C4E5 		strb	sl, [r4, #285]
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4325              		.loc 1 880 0
 4326 2550 62C1C4E5 		strb	ip, [r4, #354]
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 4327              		.loc 1 874 0
 4328 2554 800010E3 		tst	r0, #128
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4329              		.loc 1 875 0
 4330 2558 0170A013 		movne	r7, #1
 4331              	.LVL390:
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4332              		.loc 1 877 0
 4333 255c 0B70A001 		moveq	r7, fp
 4334              	.LVL391:
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4335              		.loc 1 875 0
 4336 2560 1C71C415 		strneb	r7, [r4, #284]
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4337              		.loc 1 877 0
 4338 2564 1CB1C405 		streqb	fp, [r4, #284]
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 4339              		.loc 1 878 0
 4340 2568 9D70C6E5 		strb	r7, [r6, #157]
 884:../uvc.c      **** 			 	 		 break;
 4341              		.loc 1 884 0
 4342 256c E7FBFFEA 		b	.L183
 4343              	.LVL392:
 4344              	.L212:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4345              		.loc 1 1081 0
 4346 2570 0B00A0E1 		mov	r0, fp
 4347              	.LVL393:
 4348 2574 0910A0E1 		mov	r1, r9
 4349 2578 FEFFFFEB 		bl	SensorGetControl
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4350              		.loc 1 1084 0
 4351 257c 01C0A0E3 		mov	ip, #1
 4352 2580 43C1C4E5 		strb	ip, [r4, #323]
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4353              		.loc 1 1082 0
 4354 2584 1905C6E5 		strb	r0, [r6, #1305]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4355              		.loc 1 1083 0
 4356 2588 1AA5D6E5 		ldrb	sl, [r6, #1306]	@ zero_extendqisi2
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4357              		.loc 1 1081 0
 4358 258c 0070A0E1 		mov	r7, r0
 4359              	.LVL394:
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4360              		.loc 1 1083 0
 4361 2590 FFA00AE2 		and	sl, sl, #255
 4362              	.LVL395:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4363              		.loc 1 1081 0
 4364 2594 1C01C4E5 		strb	r0, [r4, #284]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4365              		.loc 1 1083 0
 4366 2598 1DA1C4E5 		strb	sl, [r4, #285]
1088:../uvc.c      **** 					 break;
 4367              		.loc 1 1088 0
 4368 259c DBFBFFEA 		b	.L183
 4369              	.LVL396:
 4370              	.L200:
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4371              		.loc 1 973 0
 4372 25a0 0710A0E1 		mov	r1, r7
 4373 25a4 FEFFFFEB 		bl	SensorGetControl
 4374              	.LVL397:
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4375              		.loc 1 977 0
 4376 25a8 0710A0E1 		mov	r1, r7
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4377              		.loc 1 974 0
 4378 25ac 032000E2 		and	r2, r0, #3
 4379 25b0 1C21C4E5 		strb	r2, [r4, #284]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4380              		.loc 1 977 0
 4381 25b4 0A00A0E1 		mov	r0, sl
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4382              		.loc 1 975 0
 4383 25b8 ED24C6E5 		strb	r2, [r6, #1261]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4384              		.loc 1 977 0
 4385 25bc FEFFFFEB 		bl	SensorGetControl
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4386              		.loc 1 979 0
 4387 25c0 0130A0E3 		mov	r3, #1
 4388 25c4 5531C4E5 		strb	r3, [r4, #341]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4389              		.loc 1 977 0
 4390 25c8 1E01C4E5 		strb	r0, [r4, #286]
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4391              		.loc 1 978 0
 4392 25cc EE04C6E5 		strb	r0, [r6, #1262]
 4393 25d0 26FCFFEA 		b	.L201
 4394              	.LVL398:
 4395              	.L192:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4396              		.loc 1 923 0
 4397 25d4 FEFFFFEB 		bl	SensorGetControl
 4398              	.LVL399:
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4399              		.loc 1 926 0
 4400 25d8 01C0A0E3 		mov	ip, #1
 4401 25dc 57C1C4E5 		strb	ip, [r4, #343]
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4402              		.loc 1 924 0
 4403 25e0 D904C6E5 		strb	r0, [r6, #1241]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4404              		.loc 1 925 0
 4405 25e4 DA14D6E5 		ldrb	r1, [r6, #1242]	@ zero_extendqisi2
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4406              		.loc 1 923 0
 4407 25e8 0070A0E1 		mov	r7, r0
 4408              	.LVL400:
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4409              		.loc 1 925 0
 4410 25ec FFA001E2 		and	sl, r1, #255
 4411              	.LVL401:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4412              		.loc 1 923 0
 4413 25f0 1C01C4E5 		strb	r0, [r4, #284]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4414              		.loc 1 925 0
 4415 25f4 1DA1C4E5 		strb	sl, [r4, #285]
 930:../uvc.c      **** 			 		 break;
 4416              		.loc 1 930 0
 4417 25f8 C4FBFFEA 		b	.L183
 4418              	.LVL402:
 4419              	.L184:
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4420              		.loc 1 855 0
 4421 25fc 0A00A0E1 		mov	r0, sl
 4422              	.LVL403:
 4423 2600 0910A0E1 		mov	r1, r9
 4424 2604 FEFFFFEB 		bl	SensorGetControl
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4425              		.loc 1 857 0
 4426 2608 B104C6E5 		strb	r0, [r6, #1201]
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4427              		.loc 1 858 0
 4428 260c B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4429              		.loc 1 855 0
 4430 2610 0070A0E1 		mov	r7, r0
 4431              	.LVL404:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4432              		.loc 1 858 0
 4433 2614 FFA001E2 		and	sl, r1, #255
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4434              		.loc 1 856 0
 4435 2618 1C01C4E5 		strb	r0, [r4, #284]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4436              		.loc 1 859 0
 4437 261c 0100A0E3 		mov	r0, #1
 4438              	.LVL405:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4439              		.loc 1 858 0
 4440 2620 1DA1C4E5 		strb	sl, [r4, #285]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4441              		.loc 1 859 0
 4442 2624 6101C4E5 		strb	r0, [r4, #353]
 4443              	.LVL406:
 863:../uvc.c      **** 			 	 		 break;
 4444              		.loc 1 863 0
 4445 2628 B8FBFFEA 		b	.L183
 4446              	.LVL407:
 4447              	.L214:
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4448              		.loc 1 1098 0
 4449 262c 0A00A0E1 		mov	r0, sl
 4450              	.LVL408:
 4451 2630 0910A0E1 		mov	r1, r9
 4452 2634 FEFFFFEB 		bl	SensorGetControl
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4453              		.loc 1 1100 0
 4454 2638 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
 4455 263c 1DA1CBE5 		strb	sl, [fp, #285]
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4456              		.loc 1 1098 0
 4457 2640 0070A0E1 		mov	r7, r0
 4458 2644 1C01CBE5 		strb	r0, [fp, #284]
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4459              		.loc 1 1099 0
 4460 2648 BD01C6E5 		strb	r0, [r6, #445]
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4461              		.loc 1 1101 0
 4462 264c 0100A0E3 		mov	r0, #1
 4463 2650 3C01C4E5 		strb	r0, [r4, #316]
 4464              	.LVL409:
1105:../uvc.c      **** 					 break;
 4465              		.loc 1 1105 0
 4466 2654 ADFBFFEA 		b	.L183
 4467              	.LVL410:
 4468              	.L222:
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4469              		.loc 1 1153 0
 4470 2658 0A00A0E1 		mov	r0, sl
 4471              	.LVL411:
 4472 265c 0910A0E1 		mov	r1, r9
 4473 2660 14308DE5 		str	r3, [sp, #20]
 4474 2664 FEFFFFEB 		bl	SensorGetControl
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4475              		.loc 1 1154 0
 4476 2668 84A084E0 		add	sl, r4, r4, asl #1
 4477 266c 8A6186E0 		add	r6, r6, sl, asl #3
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4478              		.loc 1 1155 0
 4479 2670 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4480              		.loc 1 1156 0
 4481 2674 0110A0E3 		mov	r1, #1
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4482              		.loc 1 1155 0
 4483 2678 1DA1CBE5 		strb	sl, [fp, #285]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4484              		.loc 1 1153 0
 4485 267c 1C01CBE5 		strb	r0, [fp, #284]
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4486              		.loc 1 1154 0
 4487 2680 8D01C6E5 		strb	r0, [r6, #397]
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4488              		.loc 1 1156 0
 4489 2684 14C09DE5 		ldr	ip, [sp, #20]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4490              		.loc 1 1153 0
 4491 2688 0070A0E1 		mov	r7, r0
 4492              	.LVL412:
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4493              		.loc 1 1156 0
 4494 268c 3C11CCE5 		strb	r1, [ip, #316]
 4495              	.LVL413:
1162:../uvc.c      **** 					 break;
 4496              		.loc 1 1162 0
 4497 2690 9EFBFFEA 		b	.L183
 4498              	.LVL414:
 4499              	.L216:
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4500              		.loc 1 1112 0
 4501 2694 0A00A0E1 		mov	r0, sl
 4502              	.LVL415:
 4503 2698 0910A0E1 		mov	r1, r9
 4504 269c FEFFFFEB 		bl	SensorGetControl
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4505              		.loc 1 1115 0
 4506 26a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4507              		.loc 1 1117 0
 4508 26a4 0110A0E3 		mov	r1, #1
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4509              		.loc 1 1115 0
 4510 26a8 1DA1C4E5 		strb	sl, [r4, #285]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4511              		.loc 1 1117 0
 4512 26ac 4511C4E5 		strb	r1, [r4, #325]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4513              		.loc 1 1114 0
 4514 26b0 037000E2 		and	r7, r0, #3
 4515              	.LVL416:
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4516              		.loc 1 1113 0
 4517 26b4 6502C6E5 		strb	r0, [r6, #613]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4518              		.loc 1 1114 0
 4519 26b8 1C71C4E5 		strb	r7, [r4, #284]
1121:../uvc.c      **** 					 break;
 4520              		.loc 1 1121 0
 4521 26bc 93FBFFEA 		b	.L183
 4522              	.LVL417:
 4523              	.L218:
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
 4524              		.loc 1 1134 0
 4525 26c0 0100A0E3 		mov	r0, #1
 4526              	.LVL418:
 4527 26c4 0910A0E1 		mov	r1, r9
 4528 26c8 FEFFFFEB 		bl	SensorGetControl
 4529              	.LVL419:
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4530              		.loc 1 1139 0
 4531 26cc 0130A0E3 		mov	r3, #1
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4532              		.loc 1 1138 0
 4533 26d0 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4534              		.loc 1 1139 0
 4535 26d4 4031C4E5 		strb	r3, [r4, #320]
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4536              		.loc 1 1138 0
 4537 26d8 1DA1C4E5 		strb	sl, [r4, #285]
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4538              		.loc 1 1135 0
 4539 26dc A003A0E1 		mov	r0, r0, lsr #7
 4540              	.LVL420:
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4541              		.loc 1 1136 0
 4542 26e0 037080E0 		add	r7, r0, r3
 4543              	.LVL421:
 4544 26e4 FF7007E2 		and	r7, r7, #255
 4545              	.LVL422:
 4546 26e8 1C71C4E5 		strb	r7, [r4, #284]
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4547              		.loc 1 1137 0
 4548 26ec ED71C6E5 		strb	r7, [r6, #493]
1144:../uvc.c      **** 					 break;
 4549              		.loc 1 1144 0
 4550 26f0 86FBFFEA 		b	.L183
 4551              	.LVL423:
 4552              	.L210:
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4553              		.loc 1 1064 0
 4554 26f4 0A00A0E1 		mov	r0, sl
 4555              	.LVL424:
 4556 26f8 0910A0E1 		mov	r1, r9
 4557 26fc FEFFFFEB 		bl	SensorGetControl
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4558              		.loc 1 1068 0
 4559 2700 0130A0E3 		mov	r3, #1
 4560 2704 3C31C4E5 		strb	r3, [r4, #316]
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4561              		.loc 1 1065 0
 4562 2708 037000E0 		and	r7, r0, r3
 4563              	.LVL425:
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4564              		.loc 1 1066 0
 4565 270c 0575C6E5 		strb	r7, [r6, #1285]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4566              		.loc 1 1067 0
 4567 2710 0605D6E5 		ldrb	r0, [r6, #1286]	@ zero_extendqisi2
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4568              		.loc 1 1065 0
 4569 2714 1C71C4E5 		strb	r7, [r4, #284]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4570              		.loc 1 1067 0
 4571 2718 FFA000E2 		and	sl, r0, #255
 4572              	.LVL426:
 4573 271c 1DA1C4E5 		strb	sl, [r4, #285]
1072:../uvc.c      **** 					 break;
 4574              		.loc 1 1072 0
 4575 2720 7AFBFFEA 		b	.L183
 4576              	.LVL427:
 4577              	.L323:
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4578              		.loc 1 1010 0
 4579 2724 0A00A0E1 		mov	r0, sl
 4580 2728 0910A0E1 		mov	r1, r9
 4581 272c FEFFFFEB 		bl	SensorGetControl
 4582              	.LVL428:
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4583              		.loc 1 1012 0
 4584 2730 0170A0E3 		mov	r7, #1
 4585              	.LVL429:
 4586 2734 3D71C4E5 		strb	r7, [r4, #317]
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4587              		.loc 1 1011 0
 4588 2738 A501C6E5 		strb	r0, [r6, #421]
 4589 273c DCFBFFEA 		b	.L203
 4590              	.LVL430:
 4591              	.L190:
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4592              		.loc 1 898 0
 4593 2740 FEFFFFEB 		bl	SensorGetControl
 4594              	.LVL431:
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4595              		.loc 1 904 0
 4596 2744 00181FE5 		ldr	r1, .L329+60
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4597              		.loc 1 899 0
 4598 2748 C504C6E5 		strb	r0, [r6, #1221]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4599              		.loc 1 902 0
 4600 274c C664D6E5 		ldrb	r6, [r6, #1222]	@ zero_extendqisi2
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4601              		.loc 1 898 0
 4602 2750 0070A0E1 		mov	r7, r0
 4603              	.LVL432:
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4604              		.loc 1 900 0
 4605 2754 700000E2 		and	r0, r0, #112
 4606              	.LVL433:
 4607 2758 20C2A0E1 		mov	ip, r0, lsr #4
 4608              	.LVL434:
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4609              		.loc 1 901 0
 4610 275c 1CC1C4E5 		strb	ip, [r4, #284]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4611              		.loc 1 902 0
 4612 2760 1D61C4E5 		strb	r6, [r4, #285]
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4613              		.loc 1 904 0
 4614 2764 0C20A0E1 		mov	r2, ip
 4615 2768 0C30A0E1 		mov	r3, ip
 4616 276c 0400A0E3 		mov	r0, #4
 4617 2770 00708DE5 		str	r7, [sp, #0]
 4618 2774 14C08DE5 		str	ip, [sp, #20]
 4619 2778 FEFFFFEB 		bl	CyU3PDebugPrint
 4620              	.LVL435:
 4621 277c 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4622              	.LVL436:
 4623 2780 14C09DE5 		ldr	ip, [sp, #20]
 4624 2784 19FCFFEA 		b	.L191
 4625              	.LVL437:
 4626              	.L264:
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4627              		.loc 1 1376 0
 4628 2788 0A20A0E1 		mov	r2, sl
 4629 278c 0730A0E1 		mov	r3, r7
 4630 2790 80E0A0E3 		mov	lr, #128
 4631 2794 00C0A0E3 		mov	ip, #0
 4632 2798 1B10A0E3 		mov	r1, #27
 4633 279c 54081FE5 		ldr	r0, .L329+64
 4634 27a0 00E08DE5 		str	lr, [sp, #0]
 4635 27a4 04C08DE5 		str	ip, [sp, #4]
 4636 27a8 FEFFFFEB 		bl	cmdSet
 4637              	.LVL438:
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4638              		.loc 1 1378 0
 4639 27ac 0820A0E1 		mov	r2, r8
 4640 27b0 18809DE5 		ldr	r8, [sp, #24]
 4641              	.LVL439:
 4642 27b4 01A0A0E3 		mov	sl, #1
 4643              	.LVL440:
 4644 27b8 1B10A0E3 		mov	r1, #27
 4645 27bc 0730A0E1 		mov	r3, r7
 4646 27c0 78081FE5 		ldr	r0, .L329+64
 4647 27c4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4648 27c8 FEFFFFEB 		bl	cmdSet
 4649              	.LVL441:
 4650 27cc 87FCFFEA 		b	.L263
 4651              	.LVL442:
 4652              	.L322:
 935:../uvc.c      **** 						if(sendData >= 3){
 4653              		.loc 1 935 0
 4654 27d0 020057E3 		cmp	r7, #2
 4655 27d4 0D00008A 		bhi	.L328
 4656              	.LVL443:
 4657              	.L195:
 940:../uvc.c      **** 						sendData += 4;
 4658              		.loc 1 940 0
 4659 27d8 047087E2 		add	r7, r7, #4
 4660              	.LVL444:
 4661 27dc FF7007E2 		and	r7, r7, #255
 4662              	.LVL445:
 4663 27e0 69FBFFEA 		b	.L314
 4664              	.LVL446:
 4665              	.L327:
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4666              		.loc 1 1351 0
 4667 27e4 0830A0E1 		mov	r3, r8
 4668 27e8 1910A0E3 		mov	r1, #25
 4669 27ec 0080A0E3 		mov	r8, #0
 4670              	.LVL447:
 4671 27f0 0920A0E1 		mov	r2, r9
 4672 27f4 AC081FE5 		ldr	r0, .L329+64
 4673 27f8 00E08DE5 		str	lr, [sp, #0]
 4674 27fc 04808DE5 		str	r8, [sp, #4]
 4675 2800 FEFFFFEB 		bl	cmdSet
 4676              	.LVL448:
 4677 2804 14FEFFEA 		b	.L262
 4678              	.LVL449:
 4679              	.L313:
 4680 2808 B4081FE5 		ldr	r0, .L329+76
 4681 280c 29FBFFEA 		b	.L180
 4682              	.LVL450:
 4683              	.L328:
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4684              		.loc 1 936 0
 4685 2810 0730A0E1 		mov	r3, r7
 4686 2814 0400A0E3 		mov	r0, #4
 4687              	.LVL451:
 4688 2818 CC181FE5 		ldr	r1, .L329+68
 4689 281c FEFFFFEB 		bl	CyU3PDebugPrint
 4690              	.LVL452:
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4691              		.loc 1 938 0
 4692 2820 D0081FE5 		ldr	r0, .L329+72
 4693 2824 0020A0E3 		mov	r2, #0
 937:../uvc.c      **** 							sendData = 0; //set back to default
 4694              		.loc 1 937 0
 4695 2828 0270A0E1 		mov	r7, r2
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4696              		.loc 1 938 0
 4697 282c 2D24C0E5 		strb	r2, [r0, #1069]
 4698 2830 E8FFFFEA 		b	.L195
 4699              	.LVL453:
 4700              	.L293:
 4701 2834 E0081FE5 		ldr	r0, .L329+76
 4702              	.LVL454:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4703              		.loc 1 791 0
 4704 2838 0030A0E3 		mov	r3, #0
 4705 283c 16FBFFEA 		b	.L306
 4706              	.LVL455:
 4707              	.L295:
 4708 2840 0030A0E3 		mov	r3, #0
 4709 2844 0CFCFFEA 		b	.L307
 4710              		.cfi_endproc
 4711              	.LFE3:
 4713              		.align	2
 4714              		.global	CTControlHandle
 4716              	CTControlHandle:
 4717              	.LFB4:
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4718              		.loc 1 1715 0
 4719              		.cfi_startproc
 4720              		@ args = 0, pretend = 0, frame = 64
 4721              		@ frame_needed = 0, uses_anonymous_args = 0
 4722              	.LVL456:
 4723 2848 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4724              	.LCFI18:
 4725              		.cfi_def_cfa_offset 36
1734:../uvc.c      ****     reqData = bRequest;
 4726              		.loc 1 1734 0
 4727 284c 64A99FE5 		ldr	sl, .L416
 4728              		.cfi_offset 14, -4
 4729              		.cfi_offset 11, -8
 4730              		.cfi_offset 10, -12
 4731              		.cfi_offset 9, -16
 4732              		.cfi_offset 8, -20
 4733              		.cfi_offset 7, -24
 4734              		.cfi_offset 6, -28
 4735              		.cfi_offset 5, -32
 4736              		.cfi_offset 4, -36
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4737              		.loc 1 1726 0
 4738 2850 64899FE5 		ldr	r8, .L416+4
1734:../uvc.c      ****     reqData = bRequest;
 4739              		.loc 1 1734 0
 4740 2854 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4741              		.loc 1 1726 0
 4742 2858 8090A0E1 		mov	r9, r0, asl #1
 4743 285c 002089E0 		add	r2, r9, r0
 4744 2860 822188E0 		add	r2, r8, r2, asl #3
1736:../uvc.c      ****     switch (bRequest)
 4745              		.loc 1 1736 0
 4746 2864 830055E3 		cmp	r5, #131
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4747              		.loc 1 1715 0
 4748 2868 5CD04DE2 		sub	sp, sp, #92
 4749              	.LCFI19:
 4750              		.cfi_def_cfa_offset 128
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4751              		.loc 1 1715 0
 4752 286c 0060A0E1 		mov	r6, r0
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4753              		.loc 1 1726 0
 4754 2870 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4755              	.LVL457:
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4756              		.loc 1 1727 0
 4757 2874 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4758              	.LVL458:
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4759              		.loc 1 1729 0
 4760 2878 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4761              	.LVL459:
1736:../uvc.c      ****     switch (bRequest)
 4762              		.loc 1 1736 0
 4763 287c 7600000A 		beq	.L336
 4764 2880 2100009A 		bls	.L411
 4765 2884 850055E3 		cmp	r5, #133
 4766 2888 5900000A 		beq	.L338
 4767 288c 4E00003A 		bcc	.L337
 4768 2890 860055E3 		cmp	r5, #134
 4769 2894 8000000A 		beq	.L339
 4770 2898 870055E3 		cmp	r5, #135
 4771 289c 7600000A 		beq	.L412
 4772              	.L332:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4773              		.loc 1 1943 0
 4774 28a0 0000A0E3 		mov	r0, #0
 4775              	.LVL460:
 4776 28a4 0110A0E3 		mov	r1, #1
 4777 28a8 0020A0E1 		mov	r2, r0
 4778 28ac FEFFFFEB 		bl	CyU3PUsbStall
 4779              	.LVL461:
 4780 28b0 08499FE5 		ldr	r4, .L416+8
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4781              		.loc 1 1944 0
 4782 28b4 0620A0E1 		mov	r2, r6
 4783 28b8 0400A0E3 		mov	r0, #4
 4784 28bc 00199FE5 		ldr	r1, .L416+12
 4785 28c0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4786 28c4 FEFFFFEB 		bl	CyU3PDebugPrint
1945:../uvc.c      **** 			  break;
 4787              		.loc 1 1945 0
 4788 28c8 FFC0A0E3 		mov	ip, #255
 4789 28cc 0C60A0E1 		mov	r6, ip
 4790 28d0 0C80A0E1 		mov	r8, ip
 4791              	.LVL462:
 4792              	.L342:
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4793              		.loc 1 1949 0
 4794 28d4 1EE1D4E5 		ldrb	lr, [r4, #286]	@ zero_extendqisi2
 4795 28d8 08C08DE5 		str	ip, [sp, #8]
 4796 28dc E4189FE5 		ldr	r1, .L416+16
 4797 28e0 FFC0A0E3 		mov	ip, #255
 4798 28e4 0520A0E1 		mov	r2, r5
 4799 28e8 0830A0E1 		mov	r3, r8
 4800 28ec 0400A0E3 		mov	r0, #4
 4801 28f0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4802 28f4 0CC08DE5 		str	ip, [sp, #12]
 4803 28f8 10E08DE5 		str	lr, [sp, #16]
 4804 28fc 14708DE5 		str	r7, [sp, #20]
 4805 2900 FEFFFFEB 		bl	CyU3PDebugPrint
1950:../uvc.c      **** }
 4806              		.loc 1 1950 0
 4807 2904 5CD08DE2 		add	sp, sp, #92
 4808 2908 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4809              	.LVL463:
 4810              	.L411:
1736:../uvc.c      ****     switch (bRequest)
 4811              		.loc 1 1736 0
 4812 290c 810055E3 		cmp	r5, #129
 4813 2910 4200000A 		beq	.L334
 4814 2914 1100009A 		bls	.L413
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4815              		.loc 1 1765 0
 4816 2918 A0489FE5 		ldr	r4, .L416+8
 4817 291c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4818              		.loc 1 1766 0
 4819 2920 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4820              		.loc 1 1767 0
 4821 2924 0A0050E3 		cmp	r0, #10
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4822              		.loc 1 1765 0
 4823 2928 1C11C4E5 		strb	r1, [r4, #284]
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4824              		.loc 1 1766 0
 4825 292c 1D61C4E5 		strb	r6, [r4, #285]
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4826              		.loc 1 1767 0
 4827 2930 2C00000A 		beq	.L410
 4828              	.LVL464:
 4829              	.L349:
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4830              		.loc 1 1801 0
 4831 2934 00E0A0E3 		mov	lr, #0
 4832 2938 1EE1C4E5 		strb	lr, [r4, #286]
 4833              	.L350:
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4834              		.loc 1 1802 0
 4835 293c 0030A0E3 		mov	r3, #0
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4836              		.loc 1 1803 0
 4837 2940 0700A0E1 		mov	r0, r7
 4838              	.LVL465:
 4839 2944 80189FE5 		ldr	r1, .L416+20
1805:../uvc.c      **** 			  break;
 4840              		.loc 1 1805 0
 4841 2948 FF60A0E3 		mov	r6, #255
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4842              		.loc 1 1802 0
 4843 294c 1F31C4E5 		strb	r3, [r4, #287]
1805:../uvc.c      **** 			  break;
 4844              		.loc 1 1805 0
 4845 2950 0680A0E1 		mov	r8, r6
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4846              		.loc 1 1803 0
 4847 2954 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4848              	.LVL466:
 4849 2958 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1805:../uvc.c      **** 			  break;
 4850              		.loc 1 1805 0
 4851 295c DCFFFFEA 		b	.L342
 4852              	.LVL467:
 4853              	.L413:
1736:../uvc.c      ****     switch (bRequest)
 4854              		.loc 1 1736 0
 4855 2960 010055E3 		cmp	r5, #1
 4856 2964 CDFFFF1A 		bne	.L332
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4857              		.loc 1 1807 0
 4858 2968 50489FE5 		ldr	r4, .L416+8
 4859 296c 56208DE2 		add	r2, sp, #86
 4860 2970 2000A0E3 		mov	r0, #32
 4861              	.LVL468:
 4862 2974 471F84E2 		add	r1, r4, #284
 4863 2978 2C308DE5 		str	r3, [sp, #44]
 4864 297c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4865              	.LVL469:
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4866              		.loc 1 1809 0
 4867 2980 1C01D4E5 		ldrb	r0, [r4, #284]	@ zero_extendqisi2
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4868              		.loc 1 1810 0
 4869 2984 1DC1D4E5 		ldrb	ip, [r4, #285]	@ zero_extendqisi2
1813:../uvc.c      **** 			  switch(CtrlID)
 4870              		.loc 1 1813 0
 4871 2988 012046E2 		sub	r2, r6, #1
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4872              		.loc 1 1809 0
 4873 298c 30008DE5 		str	r0, [sp, #48]
 4874              	.LVL470:
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4875              		.loc 1 1810 0
 4876 2990 34C08DE5 		str	ip, [sp, #52]
 4877              	.LVL471:
1813:../uvc.c      **** 			  switch(CtrlID)
 4878              		.loc 1 1813 0
 4879 2994 2C309DE5 		ldr	r3, [sp, #44]
 4880 2998 090052E3 		cmp	r2, #9
 4881 299c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4882 29a0 550100EA 		b	.L351
 4883              	.L356:
 4884 29a4 B82E0000 		.word	.L352
 4885 29a8 FC2E0000 		.word	.L351
 4886 29ac C82B0000 		.word	.L353
 4887 29b0 FC2E0000 		.word	.L351
 4888 29b4 FC2E0000 		.word	.L351
 4889 29b8 FC2E0000 		.word	.L351
 4890 29bc 442B0000 		.word	.L354
 4891 29c0 FC2E0000 		.word	.L351
 4892 29c4 FC2E0000 		.word	.L351
 4893 29c8 C82A0000 		.word	.L355
 4894              	.LVL472:
 4895              	.L337:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4896              		.loc 1 1783 0
 4897 29cc EC479FE5 		ldr	r4, .L416+8
 4898 29d0 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4899              		.loc 1 1784 0
 4900 29d4 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4901              		.loc 1 1785 0
 4902 29d8 0A0050E3 		cmp	r0, #10
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4903              		.loc 1 1783 0
 4904 29dc 1C81C4E5 		strb	r8, [r4, #284]
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4905              		.loc 1 1784 0
 4906 29e0 1D21C4E5 		strb	r2, [r4, #285]
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4907              		.loc 1 1785 0
 4908 29e4 D2FFFF1A 		bne	.L349
 4909              	.LVL473:
 4910              	.L410:
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4911              		.loc 1 1800 0 discriminator 1
 4912 29e8 0110A0E3 		mov	r1, #1
 4913 29ec 1E11C4E5 		strb	r1, [r4, #286]
 4914 29f0 D1FFFFEA 		b	.L350
 4915              	.LVL474:
 4916              	.L338:
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4917              		.loc 1 1740 0
 4918 29f4 C4479FE5 		ldr	r4, .L416+8
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4919              		.loc 1 1741 0
 4920 29f8 0030A0E3 		mov	r3, #0
 4921              	.LVL475:
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4922              		.loc 1 1742 0
 4923 29fc 0200A0E3 		mov	r0, #2
 4924              	.LVL476:
 4925 2a00 471F84E2 		add	r1, r4, #284
1744:../uvc.c      **** 			  break;
 4926              		.loc 1 1744 0
 4927 2a04 FF60A0E3 		mov	r6, #255
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4928              		.loc 1 1740 0
 4929 2a08 1C71C4E5 		strb	r7, [r4, #284]
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4930              		.loc 1 1741 0
 4931 2a0c 1D31C4E5 		strb	r3, [r4, #285]
1744:../uvc.c      **** 			  break;
 4932              		.loc 1 1744 0
 4933 2a10 0680A0E1 		mov	r8, r6
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4934              		.loc 1 1742 0
 4935 2a14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4936              	.LVL477:
 4937 2a18 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1744:../uvc.c      **** 			  break;
 4938              		.loc 1 1744 0
 4939 2a1c ACFFFFEA 		b	.L342
 4940              	.LVL478:
 4941              	.L334:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4942              		.loc 1 1750 0
 4943 2a20 98479FE5 		ldr	r4, .L416+8
 4944 2a24 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4945              		.loc 1 1751 0
 4946 2a28 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4947              		.loc 1 1752 0
 4948 2a2c 0080A0E3 		mov	r8, #0
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4949              		.loc 1 1758 0
 4950 2a30 0700A0E1 		mov	r0, r7
 4951              	.LVL479:
 4952 2a34 471F84E2 		add	r1, r4, #284
1763:../uvc.c      **** 			  break;
 4953              		.loc 1 1763 0
 4954 2a38 FF60A0E3 		mov	r6, #255
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4955              		.loc 1 1751 0
 4956 2a3c 1DC1C4E5 		strb	ip, [r4, #285]
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4957              		.loc 1 1752 0
 4958 2a40 1E81C4E5 		strb	r8, [r4, #286]
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4959              		.loc 1 1753 0
 4960 2a44 1F81C4E5 		strb	r8, [r4, #287]
 4961              	.LVL480:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4962              		.loc 1 1750 0
 4963 2a48 1CA1C4E5 		strb	sl, [r4, #284]
1763:../uvc.c      **** 			  break;
 4964              		.loc 1 1763 0
 4965 2a4c 0680A0E1 		mov	r8, r6
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4966              		.loc 1 1758 0
 4967 2a50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4968              	.LVL481:
 4969 2a54 0AC0A0E1 		mov	ip, sl
1763:../uvc.c      **** 			  break;
 4970              		.loc 1 1763 0
 4971 2a58 9DFFFFEA 		b	.L342
 4972              	.LVL482:
 4973              	.L336:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4974              		.loc 1 1774 0
 4975 2a5c 5C479FE5 		ldr	r4, .L416+8
 4976 2a60 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4977              	.LVL483:
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4978              		.loc 1 1775 0
 4979 2a64 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4980              		.loc 1 1776 0
 4981 2a68 0A0050E3 		cmp	r0, #10
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4982              		.loc 1 1774 0
 4983 2a6c 1C31C4E5 		strb	r3, [r4, #284]
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4984              		.loc 1 1775 0
 4985 2a70 1DE1C4E5 		strb	lr, [r4, #285]
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4986              		.loc 1 1776 0
 4987 2a74 AEFFFF1A 		bne	.L349
 4988 2a78 DAFFFFEA 		b	.L410
 4989              	.LVL484:
 4990              	.L412:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4991              		.loc 1 1798 0
 4992 2a7c 3C479FE5 		ldr	r4, .L416+8
 4993 2a80 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4994              		.loc 1 1799 0
 4995 2a84 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4996              		.loc 1 1800 0
 4997 2a88 0A0050E3 		cmp	r0, #10
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4998              		.loc 1 1798 0
 4999 2a8c 1C61C4E5 		strb	r6, [r4, #284]
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5000              		.loc 1 1799 0
 5001 2a90 1DC1C4E5 		strb	ip, [r4, #285]
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5002              		.loc 1 1800 0
 5003 2a94 A6FFFF1A 		bne	.L349
 5004 2a98 D2FFFFEA 		b	.L410
 5005              	.L339:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 5006              		.loc 1 1792 0
 5007 2a9c 1C479FE5 		ldr	r4, .L416+8
 5008 2aa0 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 5009              	.LVL485:
 5010 2aa4 0410A0E1 		mov	r1, r4
 5011 2aa8 1C01E1E5 		strb	r0, [r1, #284]!
1796:../uvc.c      **** 			  break;
 5012              		.loc 1 1796 0
 5013 2aac FF60A0E3 		mov	r6, #255
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5014              		.loc 1 1793 0
 5015 2ab0 0100A0E3 		mov	r0, #1
 5016 2ab4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5017              	.LVL486:
1796:../uvc.c      **** 			  break;
 5018              		.loc 1 1796 0
 5019 2ab8 0680A0E1 		mov	r8, r6
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5020              		.loc 1 1793 0
 5021 2abc 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1796:../uvc.c      **** 			  break;
 5022              		.loc 1 1796 0
 5023 2ac0 0170A0E3 		mov	r7, #1
 5024 2ac4 82FFFFEA 		b	.L342
 5025              	.LVL487:
 5026              	.L355:
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5027              		.loc 1 1922 0
 5028 2ac8 00679FE5 		ldr	r6, .L416+24
 5029 2acc 0010E0E3 		mvn	r1, #0
 5030 2ad0 1C0096E5 		ldr	r0, [r6, #28]
 5031 2ad4 2C308DE5 		str	r3, [sp, #44]
 5032 2ad8 FEFFFFEB 		bl	_txe_mutex_get
1923:../uvc.c      **** 					  if(getData == 1)
 5033              		.loc 1 1923 0
 5034 2adc 30E09DE5 		ldr	lr, [sp, #48]
 5035 2ae0 2C309DE5 		ldr	r3, [sp, #44]
 5036 2ae4 01005EE3 		cmp	lr, #1
 5037 2ae8 AA01000A 		beq	.L414
1925:../uvc.c      **** 					  else if(getData == 0xff)
 5038              		.loc 1 1925 0
 5039 2aec FF005EE3 		cmp	lr, #255
 5040 2af0 9F01000A 		beq	.L415
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 5041              		.loc 1 1928 0
 5042 2af4 0080A0E3 		mov	r8, #0
 5043 2af8 0600A0E1 		mov	r0, r6
 5044 2afc 2310A0E3 		mov	r1, #35
 5045 2b00 0B20A0E1 		mov	r2, fp
 5046 2b04 00808DE5 		str	r8, [sp, #0]
 5047 2b08 04808DE5 		str	r8, [sp, #4]
 5048 2b0c FEFFFFEB 		bl	cmdSet
 5049              	.L408:
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5050              		.loc 1 1931 0
 5051 2b10 1C0096E5 		ldr	r0, [r6, #28]
 5052 2b14 FEFFFFEB 		bl	_txe_mutex_put
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 5053              		.loc 1 1933 0
 5054 2b18 30809DE5 		ldr	r8, [sp, #48]
 5055 2b1c 34609DE5 		ldr	r6, [sp, #52]
 5056 2b20 1EC1D4E5 		ldrb	ip, [r4, #286]	@ zero_extendqisi2
 5057 2b24 0400A0E3 		mov	r0, #4
 5058 2b28 A4169FE5 		ldr	r1, .L416+28
 5059 2b2c 0820A0E1 		mov	r2, r8
 5060 2b30 0630A0E1 		mov	r3, r6
 5061 2b34 00C08DE5 		str	ip, [sp, #0]
 5062 2b38 FEFFFFEB 		bl	CyU3PDebugPrint
1934:../uvc.c      **** 					  break;
 5063              		.loc 1 1934 0
 5064 2b3c FFC0A0E3 		mov	ip, #255
 5065 2b40 63FFFFEA 		b	.L342
 5066              	.LVL488:
 5067              	.L354:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 5068              		.loc 1 1899 0
 5069 2b44 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 5070 2b48 010058E3 		cmp	r8, #1
 5071 2b4c 08005813 		cmpne	r8, #8
 5072 2b50 0000A013 		movne	r0, #0
 5073 2b54 0100A003 		moveq	r0, #1
 5074 2b58 8101001A 		bne	.L405
 5075              	.LVL489:
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5076              		.loc 1 1902 0
 5077 2b5c 6C869FE5 		ldr	r8, .L416+24
 5078 2b60 0010E0E3 		mvn	r1, #0
 5079 2b64 1C0098E5 		ldr	r0, [r8, #28]
 5080 2b68 2C308DE5 		str	r3, [sp, #44]
 5081 2b6c FEFFFFEB 		bl	_txe_mutex_get
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5082              		.loc 1 1903 0
 5083 2b70 30A09DE5 		ldr	sl, [sp, #48]
 5084 2b74 2210A0E3 		mov	r1, #34
 5085 2b78 0B20A0E1 		mov	r2, fp
 5086 2b7c 2C309DE5 		ldr	r3, [sp, #44]
 5087 2b80 00C0A0E3 		mov	ip, #0
 5088 2b84 0800A0E1 		mov	r0, r8
 5089 2b88 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 5090 2b8c FEFFFFEB 		bl	cmdSet
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5091              		.loc 1 1904 0
 5092 2b90 1C0098E5 		ldr	r0, [r8, #28]
 5093 2b94 FEFFFFEB 		bl	_txe_mutex_put
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5094              		.loc 1 1907 0
 5095 2b98 1C069FE5 		ldr	r0, .L416+4
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5096              		.loc 1 1908 0
 5097 2b9c 34209DE5 		ldr	r2, [sp, #52]
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5098              		.loc 1 1907 0
 5099 2ba0 061089E0 		add	r1, r9, r6
 5100 2ba4 813180E0 		add	r3, r0, r1, asl #3
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5101              		.loc 1 1909 0
 5102 2ba8 0160A0E3 		mov	r6, #1
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5103              		.loc 1 1907 0
 5104 2bac 2DA5C3E5 		strb	sl, [r3, #1325]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5105              		.loc 1 1908 0
 5106 2bb0 2E25C3E5 		strb	r2, [r3, #1326]
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5107              		.loc 1 1909 0
 5108 2bb4 3065C3E5 		strb	r6, [r3, #1328]
 5109              	.LVL490:
 5110              	.L406:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5111              		.loc 1 1911 0
 5112 2bb8 1C81D4E5 		ldrb	r8, [r4, #284]	@ zero_extendqisi2
 5113 2bbc 1D61D4E5 		ldrb	r6, [r4, #285]	@ zero_extendqisi2
1916:../uvc.c      **** 					  break;
 5114              		.loc 1 1916 0
 5115 2bc0 FFC0A0E3 		mov	ip, #255
 5116 2bc4 42FFFFEA 		b	.L342
 5117              	.LVL491:
 5118              	.L353:
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5119              		.loc 1 1865 0
 5120 2bc8 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 5121 2bcc 010050E3 		cmp	r0, #1
 5122 2bd0 04005013 		cmpne	r0, #4
 5123 2bd4 5D01001A 		bne	.L363
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
 5124              		.loc 1 1864 0
 5125 2bd8 30109DE5 		ldr	r1, [sp, #48]
 5126 2bdc 34E09DE5 		ldr	lr, [sp, #52]
 5127 2be0 0E2481E1 		orr	r2, r1, lr, asl #8
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5128              		.loc 1 1866 0
 5129 2be4 F90052E3 		cmp	r2, #249
 5130 2be8 5801008A 		bhi	.L363
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5131              		.loc 1 1871 0
 5132 2bec C8A042E2 		sub	sl, r2, #200
 5133 2bf0 0AC8A0E1 		mov	ip, sl, asl #16
 5134 2bf4 3CC08DE5 		str	ip, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5135              		.loc 1 1873 0
 5136 2bf8 27A062E2 		rsb	sl, r2, #39
 5137 2bfc 38A08DE5 		str	sl, [sp, #56]
 5138 2c00 3CA09DE5 		ldr	sl, [sp, #60]
 5139 2c04 C81062E2 		rsb	r1, r2, #200
 5140 2c08 C80052E3 		cmp	r2, #200
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5141              		.loc 1 1871 0
 5142 2c0c 640042E2 		sub	r0, r2, #100
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5143              		.loc 1 1873 0
 5144 2c10 0118A0E1 		mov	r1, r1, asl #16
 5145 2c14 64E062E2 		rsb	lr, r2, #100
 5146 2c18 2A18A081 		movhi	r1, sl, lsr #16
 5147 2c1c 2118A091 		movls	r1, r1, lsr #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5148              		.loc 1 1871 0
 5149 2c20 00C8A0E1 		mov	ip, r0, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5150              		.loc 1 1873 0
 5151 2c24 640052E3 		cmp	r2, #100
 5152 2c28 0E08A0E1 		mov	r0, lr, asl #16
 5153 2c2c 2C08A081 		movhi	r0, ip, lsr #16
 5154 2c30 38C09DE5 		ldr	ip, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5155              		.loc 1 1871 0
 5156 2c34 14A042E2 		sub	sl, r2, #20
 5157 2c38 38A08DE5 		str	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5158              		.loc 1 1873 0
 5159 2c3c 2008A091 		movls	r0, r0, lsr #16
 5160 2c40 14A062E2 		rsb	sl, r2, #20
 5161 2c44 3CA08DE5 		str	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5162              		.loc 1 1871 0
 5163 2c48 27E042E2 		sub	lr, r2, #39
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5164              		.loc 1 1873 0
 5165 2c4c 000051E1 		cmp	r1, r0
 5166 2c50 01A0A031 		movcc	sl, r1
 5167 2c54 00A0A021 		movcs	sl, r0
 5168 2c58 0CC8A0E1 		mov	ip, ip, asl #16
 5169 2c5c 270052E3 		cmp	r2, #39
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5170              		.loc 1 1871 0
 5171 2c60 0EE8A0E1 		mov	lr, lr, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5172              		.loc 1 1873 0
 5173 2c64 2CE8A091 		movls	lr, ip, lsr #16
 5174 2c68 68C59FE5 		ldr	ip, .L416+32
 5175 2c6c 20A08DE5 		str	sl, [sp, #32]
 5176 2c70 01A06CE0 		rsb	sl, ip, r1
 5177 2c74 2EE8A081 		movhi	lr, lr, lsr #16
 5178 2c78 00C07AE2 		rsbs	ip, sl, #0
 5179 2c7c 0AC0ACE0 		adc	ip, ip, sl
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5180              		.loc 1 1871 0
 5181 2c80 38A09DE5 		ldr	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5182              		.loc 1 1873 0
 5183 2c84 44C08DE5 		str	ip, [sp, #68]
 5184              	.LVL492:
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5185              		.loc 1 1871 0
 5186 2c88 0AC8A0E1 		mov	ip, sl, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5187              		.loc 1 1873 0
 5188 2c8c 3CA09DE5 		ldr	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5189              		.loc 1 1871 0
 5190 2c90 4CC08DE5 		str	ip, [sp, #76]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5191              		.loc 1 1873 0
 5192 2c94 0AC8A0E1 		mov	ip, sl, asl #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5193              		.loc 1 1871 0
 5194 2c98 0AA042E2 		sub	sl, r2, #10
 5195 2c9c 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5196              		.loc 1 1873 0
 5197 2ca0 20A09DE5 		ldr	sl, [sp, #32]
 5198 2ca4 3CC08DE5 		str	ip, [sp, #60]
 5199 2ca8 0A005EE1 		cmp	lr, sl
 5200 2cac 0EA0A031 		movcc	sl, lr
 5201 2cb0 0AC062E2 		rsb	ip, r2, #10
 5202 2cb4 40C08DE5 		str	ip, [sp, #64]
 5203 2cb8 38A08DE5 		str	sl, [sp, #56]
 5204 2cbc 3CC09DE5 		ldr	ip, [sp, #60]
 5205 2cc0 4CA09DE5 		ldr	sl, [sp, #76]
 5206 2cc4 140052E3 		cmp	r2, #20
 5207 2cc8 2CA8A091 		movls	sl, ip, lsr #16
 5208 2ccc 2AA8A081 		movhi	sl, sl, lsr #16
 5209 2cd0 44C09DE5 		ldr	ip, [sp, #68]
 5210 2cd4 010050E1 		cmp	r0, r1
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5211              		.loc 1 1871 0
 5212 2cd8 48109DE5 		ldr	r1, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5213              		.loc 1 1873 0
 5214 2cdc 01C0A033 		movcc	ip, #1
 5215 2ce0 3CA08DE5 		str	sl, [sp, #60]
 5216 2ce4 24C08DE5 		str	ip, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5217              		.loc 1 1871 0
 5218 2ce8 01A8A0E1 		mov	sl, r1, asl #16
 5219 2cec 05C042E2 		sub	ip, r2, #5
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5220              		.loc 1 1873 0
 5221 2cf0 051062E2 		rsb	r1, r2, #5
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5222              		.loc 1 1871 0
 5223 2cf4 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5224              		.loc 1 1873 0
 5225 2cf8 40009DE5 		ldr	r0, [sp, #64]
 5226 2cfc 38A09DE5 		ldr	sl, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5227              		.loc 1 1871 0
 5228 2d00 40C08DE5 		str	ip, [sp, #64]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5229              		.loc 1 1873 0
 5230 2d04 3CC09DE5 		ldr	ip, [sp, #60]
 5231 2d08 4C108DE5 		str	r1, [sp, #76]
 5232 2d0c 48109DE5 		ldr	r1, [sp, #72]
 5233 2d10 0008A0E1 		mov	r0, r0, asl #16
 5234 2d14 0A005CE1 		cmp	ip, sl
 5235 2d18 0AC0A021 		movcs	ip, sl
 5236 2d1c 0A0052E3 		cmp	r2, #10
 5237 2d20 20A09DE5 		ldr	sl, [sp, #32]
 5238 2d24 2108A081 		movhi	r0, r1, lsr #16
 5239 2d28 2008A091 		movls	r0, r0, lsr #16
 5240 2d2c 48008DE5 		str	r0, [sp, #72]
 5241 2d30 24009DE5 		ldr	r0, [sp, #36]
 5242 2d34 0A005EE1 		cmp	lr, sl
 5243 2d38 0200A033 		movcc	r0, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5244              		.loc 1 1871 0
 5245 2d3c 02E042E2 		sub	lr, r2, #2
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5246              		.loc 1 1873 0
 5247 2d40 44C08DE5 		str	ip, [sp, #68]
 5248 2d44 24008DE5 		str	r0, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5249              		.loc 1 1871 0
 5250 2d48 40C09DE5 		ldr	ip, [sp, #64]
 5251 2d4c 1CE08DE5 		str	lr, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5252              		.loc 1 1873 0
 5253 2d50 44009DE5 		ldr	r0, [sp, #68]
 5254 2d54 48E09DE5 		ldr	lr, [sp, #72]
 5255 2d58 4C109DE5 		ldr	r1, [sp, #76]
 5256 2d5c 02A062E2 		rsb	sl, r2, #2
 5257 2d60 00005EE1 		cmp	lr, r0
 5258 2d64 00E0A021 		movcs	lr, r0
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5259              		.loc 1 1871 0
 5260 2d68 0CC8A0E1 		mov	ip, ip, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5261              		.loc 1 1873 0
 5262 2d6c 050052E3 		cmp	r2, #5
 5263 2d70 40A08DE5 		str	sl, [sp, #64]
 5264 2d74 0118A0E1 		mov	r1, r1, asl #16
 5265 2d78 3CA09DE5 		ldr	sl, [sp, #60]
 5266 2d7c 2C18A081 		movhi	r1, ip, lsr #16
 5267 2d80 38C09DE5 		ldr	ip, [sp, #56]
 5268 2d84 4CE08DE5 		str	lr, [sp, #76]
 5269 2d88 24009DE5 		ldr	r0, [sp, #36]
 5270 2d8c 40E09DE5 		ldr	lr, [sp, #64]
 5271 2d90 2118A091 		movls	r1, r1, lsr #16
 5272 2d94 0C005AE1 		cmp	sl, ip
 5273 2d98 20108DE5 		str	r1, [sp, #32]
 5274 2d9c 0300A033 		movcc	r0, #3
 5275 2da0 38008DE5 		str	r0, [sp, #56]
 5276 2da4 4CA09DE5 		ldr	sl, [sp, #76]
 5277 2da8 0E08A0E1 		mov	r0, lr, asl #16
 5278 2dac 20E09DE5 		ldr	lr, [sp, #32]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5279              		.loc 1 1871 0
 5280 2db0 1C109DE5 		ldr	r1, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5281              		.loc 1 1873 0
 5282 2db4 0A005EE1 		cmp	lr, sl
 5283 2db8 0AE0A021 		movcs	lr, sl
 5284 2dbc 44C09DE5 		ldr	ip, [sp, #68]
 5285 2dc0 48A09DE5 		ldr	sl, [sp, #72]
 5286 2dc4 020052E3 		cmp	r2, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5287              		.loc 1 1871 0
 5288 2dc8 0118A0E1 		mov	r1, r1, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5289              		.loc 1 1873 0
 5290 2dcc 2018A091 		movls	r1, r0, lsr #16
 5291 2dd0 38009DE5 		ldr	r0, [sp, #56]
 5292 2dd4 2118A081 		movhi	r1, r1, lsr #16
 5293 2dd8 0C005AE1 		cmp	sl, ip
 5294 2ddc 0400A033 		movcc	r0, #4
 5295 2de0 40008DE5 		str	r0, [sp, #64]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5296              		.loc 1 1871 0
 5297 2de4 010042E2 		sub	r0, r2, #1
 5298 2de8 38008DE5 		str	r0, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5299              		.loc 1 1873 0
 5300 2dec 4CA09DE5 		ldr	sl, [sp, #76]
 5301 2df0 20009DE5 		ldr	r0, [sp, #32]
 5302 2df4 01C062E2 		rsb	ip, r2, #1
 5303 2df8 3CC08DE5 		str	ip, [sp, #60]
 5304 2dfc 0A0050E1 		cmp	r0, sl
1880:../uvc.c      **** 						  shutter = shutter+index;
 5305              		.loc 1 1880 0
 5306 2e00 38A09DE5 		ldr	sl, [sp, #56]
 5307 2e04 3C009DE5 		ldr	r0, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5308              		.loc 1 1873 0
 5309 2e08 40C09DE5 		ldr	ip, [sp, #64]
 5310 2e0c 05C0A033 		movcc	ip, #5
1880:../uvc.c      **** 						  shutter = shutter+index;
 5311              		.loc 1 1880 0
 5312 2e10 010052E3 		cmp	r2, #1
 5313 2e14 0028A091 		movls	r2, r0, asl #16
 5314 2e18 0A28A081 		movhi	r2, sl, asl #16
 5315 2e1c 0E0051E1 		cmp	r1, lr
 5316 2e20 01A0A031 		movcc	sl, r1
 5317 2e24 0EA0A021 		movcs	sl, lr
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5318              		.loc 1 1873 0
 5319 2e28 0E0051E1 		cmp	r1, lr
 5320 2e2c 0C10A021 		movcs	r1, ip
 5321 2e30 0610A033 		movcc	r1, #6
1880:../uvc.c      **** 						  shutter = shutter+index;
 5322              		.loc 1 1880 0
 5323 2e34 22085AE1 		cmp	sl, r2, lsr #16
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5324              		.loc 1 1883 0
 5325 2e38 90A39FE5 		ldr	sl, .L416+24
1880:../uvc.c      **** 						  shutter = shutter+index;
 5326              		.loc 1 1880 0
 5327 2e3c 0120A091 		movls	r2, r1
 5328 2e40 0720A083 		movhi	r2, #7
 5329 2e44 012082E2 		add	r2, r2, #1
 5330 2e48 FFE002E2 		and	lr, r2, #255
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5331              		.loc 1 1883 0
 5332 2e4c 0010E0E3 		mvn	r1, #0
 5333 2e50 1C009AE5 		ldr	r0, [sl, #28]
1880:../uvc.c      **** 						  shutter = shutter+index;
 5334              		.loc 1 1880 0
 5335 2e54 38E08DE5 		str	lr, [sp, #56]
 5336              	.LVL493:
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5337              		.loc 1 1883 0
 5338 2e58 2C308DE5 		str	r3, [sp, #44]
 5339 2e5c FEFFFFEB 		bl	_txe_mutex_get
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5340              		.loc 1 1884 0
 5341 2e60 38C09DE5 		ldr	ip, [sp, #56]
 5342 2e64 0310A0E3 		mov	r1, #3
 5343 2e68 0B20A0E1 		mov	r2, fp
 5344 2e6c 2C309DE5 		ldr	r3, [sp, #44]
 5345 2e70 00C08DE5 		str	ip, [sp, #0]
 5346 2e74 0A00A0E1 		mov	r0, sl
 5347 2e78 00C0A0E3 		mov	ip, #0
 5348 2e7c 04C08DE5 		str	ip, [sp, #4]
 5349 2e80 FEFFFFEB 		bl	cmdSet
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5350              		.loc 1 1885 0
 5351 2e84 1C009AE5 		ldr	r0, [sl, #28]
 5352 2e88 FEFFFFEB 		bl	_txe_mutex_put
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5353              		.loc 1 1888 0
 5354 2e8c 30009DE5 		ldr	r0, [sp, #48]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5355              		.loc 1 1889 0
 5356 2e90 34C09DE5 		ldr	ip, [sp, #52]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5357              		.loc 1 1891 0
 5358 2e94 38309DE5 		ldr	r3, [sp, #56]
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5359              		.loc 1 1888 0
 5360 2e98 061089E0 		add	r1, r9, r6
 5361 2e9c 816188E0 		add	r6, r8, r1, asl #3
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5362              		.loc 1 1890 0
 5363 2ea0 0120A0E3 		mov	r2, #1
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5364              		.loc 1 1888 0
 5365 2ea4 2D05C6E5 		strb	r0, [r6, #1325]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5366              		.loc 1 1889 0
 5367 2ea8 2EC5C6E5 		strb	ip, [r6, #1326]
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5368              		.loc 1 1890 0
 5369 2eac 3025C6E5 		strb	r2, [r6, #1328]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5370              		.loc 1 1891 0
 5371 2eb0 0D33C8E5 		strb	r3, [r8, #781]
 5372 2eb4 3FFFFFEA 		b	.L406
 5373              	.LVL494:
 5374              	.L352:
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5375              		.loc 1 1818 0
 5376 2eb8 062089E0 		add	r2, r9, r6
 5377 2ebc 826188E0 		add	r6, r8, r2, asl #3
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5378              		.loc 1 1819 0
 5379 2ec0 0110A0E3 		mov	r1, #1
1822:../uvc.c      **** 		  		    switch (getData){
 5380              		.loc 1 1822 0
 5381 2ec4 01E040E2 		sub	lr, r0, #1
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5382              		.loc 1 1818 0
 5383 2ec8 2D05C6E5 		strb	r0, [r6, #1325]
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5384              		.loc 1 1819 0
 5385 2ecc 3015C6E5 		strb	r1, [r6, #1328]
 5386              	.LVL495:
1822:../uvc.c      **** 		  		    switch (getData){
 5387              		.loc 1 1822 0
 5388 2ed0 07005EE3 		cmp	lr, #7
 5389 2ed4 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5390 2ed8 980000EA 		b	.L357
 5391              	.L362:
 5392 2edc D4300000 		.word	.L358
 5393 2ee0 38300000 		.word	.L359
 5394 2ee4 40310000 		.word	.L357
 5395 2ee8 D02F0000 		.word	.L360
 5396 2eec 40310000 		.word	.L357
 5397 2ef0 40310000 		.word	.L357
 5398 2ef4 40310000 		.word	.L357
 5399 2ef8 302F0000 		.word	.L361
 5400              	.LVL496:
 5401              	.L351:
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5402              		.loc 1 1938 0
 5403 2efc 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5404              		.loc 1 1937 0
 5405 2f00 30A09DE5 		ldr	sl, [sp, #48]
 5406 2f04 069089E0 		add	r9, r9, r6
 5407 2f08 89E188E0 		add	lr, r8, r9, asl #3
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5408              		.loc 1 1938 0
 5409 2f0c 0620A0E1 		mov	r2, r6
 5410 2f10 0400A0E3 		mov	r0, #4
 5411 2f14 C0129FE5 		ldr	r1, .L416+36
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5412              		.loc 1 1937 0
 5413 2f18 2DA5CEE5 		strb	sl, [lr, #1325]
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5414              		.loc 1 1938 0
 5415 2f1c FEFFFFEB 		bl	CyU3PDebugPrint
1939:../uvc.c      **** 			  		 break;
 5416              		.loc 1 1939 0
 5417 2f20 FFC0A0E3 		mov	ip, #255
 5418 2f24 0C60A0E1 		mov	r6, ip
 5419 2f28 0C80A0E1 		mov	r8, ip
 5420 2f2c 68FEFFEA 		b	.L342
 5421              	.LVL497:
 5422              	.L361:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5423              		.loc 1 1841 0
 5424 2f30 98629FE5 		ldr	r6, .L416+24
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5425              		.loc 1 1839 0
 5426 2f34 00A0A0E3 		mov	sl, #0
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5427              		.loc 1 1841 0
 5428 2f38 1C0096E5 		ldr	r0, [r6, #28]
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5429              		.loc 1 1839 0
 5430 2f3c 0DA3C8E5 		strb	sl, [r8, #781]
 5431              	.LVL498:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5432              		.loc 1 1841 0
 5433 2f40 0010E0E3 		mvn	r1, #0
 5434 2f44 2C308DE5 		str	r3, [sp, #44]
 5435 2f48 FEFFFFEB 		bl	_txe_mutex_get
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5436              		.loc 1 1842 0
 5437 2f4c 0B20A0E1 		mov	r2, fp
 5438 2f50 2C309DE5 		ldr	r3, [sp, #44]
 5439 2f54 1010A0E3 		mov	r1, #16
 5440 2f58 0600A0E1 		mov	r0, r6
 5441 2f5c 00A08DE5 		str	sl, [sp, #0]
 5442 2f60 04A08DE5 		str	sl, [sp, #4]
 5443 2f64 FEFFFFEB 		bl	cmdSet
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5444              		.loc 1 1843 0
 5445 2f68 1C0096E5 		ldr	r0, [r6, #28]
 5446 2f6c FEFFFFEB 		bl	_txe_mutex_put
 5447              	.LVL499:
 5448              	.LBB71:
 5449              	.LBB72:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5450              		.loc 1 736 0
 5451 2f70 0010E0E3 		mvn	r1, #0
 5452 2f74 1C0096E5 		ldr	r0, [r6, #28]
 5453 2f78 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5454              		.loc 1 737 0
 5455 2f7c 01C0A0E3 		mov	ip, #1
 5456 2f80 2010A0E3 		mov	r1, #32
 5457 2f84 2720A0E3 		mov	r2, #39
 5458 2f88 3030A0E3 		mov	r3, #48
 5459 2f8c 0600A0E1 		mov	r0, r6
 5460 2f90 00C08DE5 		str	ip, [sp, #0]
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5461              		.loc 1 738 0
 5462 2f94 0280A0E3 		mov	r8, #2
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5463              		.loc 1 737 0
 5464 2f98 04A08DE5 		str	sl, [sp, #4]
 5465 2f9c FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5466              		.loc 1 738 0
 5467 2fa0 2110A0E3 		mov	r1, #33
 5468 2fa4 2520A0E3 		mov	r2, #37
 5469 2fa8 3030A0E3 		mov	r3, #48
 5470 2fac 0600A0E1 		mov	r0, r6
 5471 2fb0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5472 2fb4 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5473              		.loc 1 739 0
 5474 2fb8 1C0096E5 		ldr	r0, [r6, #28]
 5475 2fbc FEFFFFEB 		bl	_txe_mutex_put
 5476              	.LBE72:
 5477              	.LBE71:
1845:../uvc.c      **** 							break;
 5478              		.loc 1 1845 0
 5479 2fc0 FFC0A0E3 		mov	ip, #255
 5480 2fc4 0C60A0E1 		mov	r6, ip
 5481 2fc8 0880A0E3 		mov	r8, #8
 5482 2fcc 40FEFFEA 		b	.L342
 5483              	.LVL500:
 5484              	.L360:
 5485              	.LBB73:
 5486              	.LBB74:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5487              		.loc 1 736 0
 5488 2fd0 F8619FE5 		ldr	r6, .L416+24
 5489 2fd4 0010E0E3 		mvn	r1, #0
 5490 2fd8 1C0096E5 		ldr	r0, [r6, #28]
 5491 2fdc FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5492              		.loc 1 737 0
 5493 2fe0 0080A0E3 		mov	r8, #0
 5494 2fe4 2010A0E3 		mov	r1, #32
 5495 2fe8 2720A0E3 		mov	r2, #39
 5496 2fec 3030A0E3 		mov	r3, #48
 5497 2ff0 0600A0E1 		mov	r0, r6
 5498 2ff4 00808DE5 		str	r8, [sp, #0]
 5499 2ff8 04808DE5 		str	r8, [sp, #4]
 5500 2ffc FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5501              		.loc 1 738 0
 5502 3000 01C0A0E3 		mov	ip, #1
 5503 3004 2110A0E3 		mov	r1, #33
 5504 3008 2520A0E3 		mov	r2, #37
 5505 300c 3030A0E3 		mov	r3, #48
 5506 3010 0600A0E1 		mov	r0, r6
 5507 3014 00C08DE5 		str	ip, [sp, #0]
 5508 3018 04808DE5 		str	r8, [sp, #4]
 5509 301c FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5510              		.loc 1 739 0
 5511 3020 1C0096E5 		ldr	r0, [r6, #28]
 5512 3024 FEFFFFEB 		bl	_txe_mutex_put
 5513 3028 FFC0A0E3 		mov	ip, #255
 5514 302c 0C60A0E1 		mov	r6, ip
 5515 3030 0480A0E3 		mov	r8, #4
 5516 3034 26FEFFEA 		b	.L342
 5517              	.LVL501:
 5518              	.L359:
 5519              	.LBE74:
 5520              	.LBE73:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5521              		.loc 1 1829 0
 5522 3038 90619FE5 		ldr	r6, .L416+24
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5523              		.loc 1 1827 0
 5524 303c 00A0A0E3 		mov	sl, #0
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5525              		.loc 1 1829 0
 5526 3040 1C0096E5 		ldr	r0, [r6, #28]
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5527              		.loc 1 1827 0
 5528 3044 0DA3C8E5 		strb	sl, [r8, #781]
 5529              	.LVL502:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5530              		.loc 1 1829 0
 5531 3048 0010E0E3 		mvn	r1, #0
 5532 304c 2C308DE5 		str	r3, [sp, #44]
 5533 3050 FEFFFFEB 		bl	_txe_mutex_get
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5534              		.loc 1 1830 0
 5535 3054 0B20A0E1 		mov	r2, fp
 5536 3058 2C309DE5 		ldr	r3, [sp, #44]
 5537 305c 1010A0E3 		mov	r1, #16
 5538 3060 0600A0E1 		mov	r0, r6
 5539 3064 00A08DE5 		str	sl, [sp, #0]
 5540 3068 04A08DE5 		str	sl, [sp, #4]
 5541 306c FEFFFFEB 		bl	cmdSet
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5542              		.loc 1 1831 0
 5543 3070 1C0096E5 		ldr	r0, [r6, #28]
 5544 3074 FEFFFFEB 		bl	_txe_mutex_put
 5545              	.LVL503:
 5546              	.LBB75:
 5547              	.LBB76:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5548              		.loc 1 736 0
 5549 3078 0010E0E3 		mvn	r1, #0
 5550 307c 1C0096E5 		ldr	r0, [r6, #28]
 5551 3080 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5552              		.loc 1 737 0
 5553 3084 2010A0E3 		mov	r1, #32
 5554 3088 2720A0E3 		mov	r2, #39
 5555 308c 3030A0E3 		mov	r3, #48
 5556 3090 0600A0E1 		mov	r0, r6
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5557              		.loc 1 738 0
 5558 3094 0180A0E3 		mov	r8, #1
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5559              		.loc 1 737 0
 5560 3098 00A08DE5 		str	sl, [sp, #0]
 5561 309c 04A08DE5 		str	sl, [sp, #4]
 5562 30a0 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5563              		.loc 1 738 0
 5564 30a4 2110A0E3 		mov	r1, #33
 5565 30a8 2520A0E3 		mov	r2, #37
 5566 30ac 3030A0E3 		mov	r3, #48
 5567 30b0 0600A0E1 		mov	r0, r6
 5568 30b4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5569 30b8 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5570              		.loc 1 739 0
 5571 30bc 1C0096E5 		ldr	r0, [r6, #28]
 5572 30c0 FEFFFFEB 		bl	_txe_mutex_put
 5573 30c4 FFC0A0E3 		mov	ip, #255
 5574 30c8 0C60A0E1 		mov	r6, ip
 5575 30cc 0280A0E3 		mov	r8, #2
 5576 30d0 FFFDFFEA 		b	.L342
 5577              	.LVL504:
 5578              	.L358:
 5579              	.LBE76:
 5580              	.LBE75:
 5581              	.LBB77:
 5582              	.LBB78:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5583              		.loc 1 736 0
 5584 30d4 F4609FE5 		ldr	r6, .L416+24
 5585 30d8 0010E0E3 		mvn	r1, #0
 5586 30dc 1C0096E5 		ldr	r0, [r6, #28]
 5587 30e0 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5588              		.loc 1 737 0
 5589 30e4 0080A0E3 		mov	r8, #0
 5590 30e8 01A0A0E3 		mov	sl, #1
 5591 30ec 2010A0E3 		mov	r1, #32
 5592 30f0 2720A0E3 		mov	r2, #39
 5593 30f4 3030A0E3 		mov	r3, #48
 5594 30f8 0600A0E1 		mov	r0, r6
 5595 30fc 04808DE5 		str	r8, [sp, #4]
 5596 3100 00A08DE5 		str	sl, [sp, #0]
 5597 3104 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5598              		.loc 1 738 0
 5599 3108 02C0A0E3 		mov	ip, #2
 5600 310c 2110A0E3 		mov	r1, #33
 5601 3110 2520A0E3 		mov	r2, #37
 5602 3114 3030A0E3 		mov	r3, #48
 5603 3118 0600A0E1 		mov	r0, r6
 5604 311c 00C08DE5 		str	ip, [sp, #0]
 5605 3120 04808DE5 		str	r8, [sp, #4]
 5606 3124 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5607              		.loc 1 739 0
 5608 3128 1C0096E5 		ldr	r0, [r6, #28]
 5609 312c FEFFFFEB 		bl	_txe_mutex_put
 5610              	.LBE78:
 5611              	.LBE77:
1825:../uvc.c      **** 							break;
 5612              		.loc 1 1825 0
 5613 3130 FFC0A0E3 		mov	ip, #255
 5614 3134 0C60A0E1 		mov	r6, ip
 5615 3138 0A80A0E1 		mov	r8, sl
 5616 313c E4FDFFEA 		b	.L342
 5617              	.LVL505:
 5618              	.L357:
1822:../uvc.c      **** 		  		    switch (getData){
 5619              		.loc 1 1822 0
 5620 3140 FFC0A0E3 		mov	ip, #255
 5621 3144 0080A0E1 		mov	r8, r0
 5622 3148 0C60A0E1 		mov	r6, ip
 5623 314c E0FDFFEA 		b	.L342
 5624              	.LVL506:
 5625              	.L363:
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5626              		.loc 1 1893 0
 5627 3150 0000A0E3 		mov	r0, #0
 5628 3154 0110A0E3 		mov	r1, #1
 5629 3158 0020A0E1 		mov	r2, r0
 5630 315c FEFFFFEB 		bl	CyU3PUsbStall
 5631              	.LVL507:
 5632 3160 94FEFFEA 		b	.L406
 5633              	.LVL508:
 5634              	.L405:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5635              		.loc 1 1911 0
 5636 3164 0110A0E3 		mov	r1, #1
 5637 3168 0020A0E1 		mov	r2, r0
 5638 316c FEFFFFEB 		bl	CyU3PUsbStall
 5639 3170 90FEFFEA 		b	.L406
 5640              	.LVL509:
 5641              	.L415:
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5642              		.loc 1 1926 0
 5643 3174 08E0A0E3 		mov	lr, #8
 5644 3178 00C0A0E3 		mov	ip, #0
 5645 317c 0600A0E1 		mov	r0, r6
 5646 3180 2310A0E3 		mov	r1, #35
 5647 3184 0B20A0E1 		mov	r2, fp
 5648 3188 00E08DE5 		str	lr, [sp, #0]
 5649 318c 04C08DE5 		str	ip, [sp, #4]
 5650 3190 FEFFFFEB 		bl	cmdSet
 5651 3194 5DFEFFEA 		b	.L408
 5652              	.L414:
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5653              		.loc 1 1924 0
 5654 3198 0480A0E3 		mov	r8, #4
 5655 319c 00E0A0E3 		mov	lr, #0
 5656 31a0 0600A0E1 		mov	r0, r6
 5657 31a4 2310A0E3 		mov	r1, #35
 5658 31a8 0B20A0E1 		mov	r2, fp
 5659 31ac 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5660 31b0 FEFFFFEB 		bl	cmdSet
 5661 31b4 55FEFFEA 		b	.L408
 5662              	.L417:
 5663              		.align	2
 5664              	.L416:
 5665 31b8 00000000 		.word	bRequest
 5666 31bc 00000000 		.word	.LANCHOR1
 5667 31c0 00000000 		.word	.LANCHOR0
 5668 31c4 D4050000 		.word	.LC34
 5669 31c8 F8050000 		.word	.LC35
 5670 31cc 1C010000 		.word	.LANCHOR0+284
 5671 31d0 00000000 		.word	cmdQu
 5672 31d4 88050000 		.word	.LC32
 5673 31d8 FFFF0000 		.word	65535
 5674 31dc B0050000 		.word	.LC33
 5675              		.cfi_endproc
 5676              	.LFE4:
 5678              		.align	2
 5679              		.global	UVCAppEP0Thread_Entry
 5681              	UVCAppEP0Thread_Entry:
 5682              	.LFB26:
4210:../uvc.c      **** {
 5683              		.loc 1 4210 0
 5684              		.cfi_startproc
 5685              		@ args = 0, pretend = 0, frame = 40
 5686              		@ frame_needed = 0, uses_anonymous_args = 0
 5687              	.LVL510:
 5688 31e0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 5689              	.LCFI20:
 5690              		.cfi_def_cfa_offset 24
 5691 31e4 6C4F9FE5 		ldr	r4, .L640
 5692              		.cfi_offset 14, -4
 5693              		.cfi_offset 8, -8
 5694              		.cfi_offset 7, -12
 5695              		.cfi_offset 6, -16
 5696              		.cfi_offset 5, -20
 5697              		.cfi_offset 4, -24
 5698 31e8 6C7F9FE5 		ldr	r7, .L640+4
 5699 31ec 30D04DE2 		sub	sp, sp, #48
 5700              	.LCFI21:
 5701              		.cfi_def_cfa_offset 72
 5702              	.LVL511:
4231:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5703              		.loc 1 4231 0
 5704 31f0 0450A0E1 		mov	r5, r4
 5705              	.LVL512:
 5706              	.L581:
 5707 31f4 00C0E0E3 		mvn	ip, #0
 5708 31f8 580F9FE5 		ldr	r0, .L640
 5709 31fc 5C10A0E3 		mov	r1, #92
 5710 3200 0120A0E3 		mov	r2, #1
 5711 3204 28308DE2 		add	r3, sp, #40
 5712 3208 00C08DE5 		str	ip, [sp, #0]
 5713 320c FEFFFFEB 		bl	_txe_event_flags_get
 5714 3210 000050E3 		cmp	r0, #0
 5715 3214 6600001A 		bne	.L419
4235:../uvc.c      ****             if (!isUsbConnected)
 5716              		.loc 1 4235 0
 5717 3218 B03095E5 		ldr	r3, [r5, #176]
 5718 321c 000053E3 		cmp	r3, #0
 5719 3220 9D00000A 		beq	.L626
 5720              	.L420:
4251:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5721              		.loc 1 4251 0
 5722 3224 28309DE5 		ldr	r3, [sp, #40]
 5723 3228 040013E3 		tst	r3, #4
 5724 322c 1C00000A 		beq	.L421
4253:../uvc.c      ****             	switch ((wIndex >> 8))
 5725              		.loc 1 4253 0
 5726 3230 28EF9FE5 		ldr	lr, .L640+8
 5727 3234 B060DEE1 		ldrh	r6, [lr, #0]
 5728 3238 2624A0E1 		mov	r2, r6, lsr #8
 5729 323c 030052E3 		cmp	r2, #3
 5730 3240 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5731 3244 110000EA 		b	.L422
 5732              	.L427:
 5733 3248 68340000 		.word	.L423
 5734 324c E0330000 		.word	.L424
 5735 3250 28340000 		.word	.L425
 5736 3254 58320000 		.word	.L426
 5737              	.L426:
 5738              	.LBB101:
 5739              	.LBB105:
3728:../uvc.c      ****     switch (wValue)
 5740              		.loc 1 3728 0
 5741 3258 041F9FE5 		ldr	r1, .L640+12
 5742 325c B030D1E1 		ldrh	r3, [r1, #0]
 5743 3260 090C53E3 		cmp	r3, #2304
 5744 3264 DC01000A 		beq	.L470
 5745 3268 C500008A 		bhi	.L480
 5746 326c 010B53E3 		cmp	r3, #1024
 5747 3270 2404000A 		beq	.L465
 5748 3274 B900008A 		bhi	.L481
 5749 3278 020C53E3 		cmp	r3, #512
 5750 327c 1D04000A 		beq	.L463
 5751 3280 030C53E3 		cmp	r3, #768
 5752 3284 1704000A 		beq	.L464
 5753 3288 010C53E3 		cmp	r3, #256
 5754 328c 1104000A 		beq	.L627
 5755              	.L422:
 5756              	.LBE105:
 5757              	.LBE101:
4274:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5758              		.loc 1 4274 0
 5759 3290 0000A0E3 		mov	r0, #0
 5760 3294 0110A0E3 		mov	r1, #1
 5761 3298 0020A0E1 		mov	r2, r0
 5762 329c FEFFFFEB 		bl	CyU3PUsbStall
 5763 32a0 28309DE5 		ldr	r3, [sp, #40]
 5764              	.L421:
4279:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5765              		.loc 1 4279 0
 5766 32a4 080013E3 		tst	r3, #8
 5767 32a8 0800000A 		beq	.L486
4283:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5768              		.loc 1 4283 0
 5769 32ac ACCE9FE5 		ldr	ip, .L640+8
 5770 32b0 B030DCE1 		ldrh	r3, [ip, #0]
 5771 32b4 010053E3 		cmp	r3, #1
 5772 32b8 4C01000A 		beq	.L487
 5773              	.L488:
 5774              	.LBB109:
 5775              	.LBB112:
4199:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5776              		.loc 1 4199 0
 5777 32bc 0000A0E3 		mov	r0, #0
 5778 32c0 0110A0E3 		mov	r1, #1
 5779 32c4 0020A0E1 		mov	r2, r0
 5780 32c8 FEFFFFEB 		bl	CyU3PUsbStall
 5781              	.L616:
 5782 32cc 28309DE5 		ldr	r3, [sp, #40]
 5783              	.L486:
 5784              	.LBE112:
 5785              	.LBE109:
4294:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5786              		.loc 1 4294 0
 5787 32d0 400013E3 		tst	r3, #64
 5788 32d4 7600001A 		bne	.L628
 5789              	.L563:
4417:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
 5790              		.loc 1 4417 0
 5791 32d8 100013E3 		tst	r3, #16
 5792 32dc 3400000A 		beq	.L419
4420:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
 5793              		.loc 1 4420 0
 5794 32e0 800E9FE5 		ldr	r0, .L640+16
 5795 32e4 14108DE2 		add	r1, sp, #20
 5796 32e8 0020E0E3 		mvn	r2, #0
 5797 32ec FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 5798              	.LVL513:
4421:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5799              		.loc 1 4421 0
 5800 32f0 006050E2 		subs	r6, r0, #0
 5801 32f4 1801001A 		bne	.L629
4434:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
 5802              		.loc 1 4434 0
 5803 32f8 14E09DE5 		ldr	lr, [sp, #20]
 5804 32fc B821DDE1 		ldrh	r2, [sp, #24]
 5805 3300 0100DEE5 		ldrb	r0, [lr, #1]	@ zero_extendqisi2
 5806              	.LVL514:
 5807 3304 0030DEE5 		ldrb	r3, [lr, #0]	@ zero_extendqisi2
 5808 3308 00008DE5 		str	r0, [sp, #0]
 5809 330c 02C0DEE5 		ldrb	ip, [lr, #2]	@ zero_extendqisi2
 5810 3310 0400A0E3 		mov	r0, #4
 5811 3314 501E9FE5 		ldr	r1, .L640+20
 5812 3318 04C08DE5 		str	ip, [sp, #4]
 5813 331c FEFFFFEB 		bl	CyU3PDebugPrint
4435:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
 5814              		.loc 1 4435 0
 5815 3320 14C09DE5 		ldr	ip, [sp, #20]
 5816 3324 0030DCE5 		ldrb	r3, [ip, #0]	@ zero_extendqisi2
 5817 3328 000053E3 		cmp	r3, #0
 5818 332c F900001A 		bne	.L571
4437:../uvc.c      ****                     if (dmaInfo.count == 3)
 5819              		.loc 1 4437 0
 5820 3330 B821DDE1 		ldrh	r2, [sp, #24]
 5821 3334 030052E3 		cmp	r2, #3
4441:../uvc.c      ****                         dmaInfo.count = 3;
 5822              		.loc 1 4441 0
 5823 3338 B821CD01 		streqh	r2, [sp, #24]	@ movhi
4437:../uvc.c      ****                     if (dmaInfo.count == 3)
 5824              		.loc 1 4437 0
 5825 333c 0100000A 		beq	.L573
4443:../uvc.c      ****                     else if (dmaInfo.count == 4)
 5826              		.loc 1 4443 0
 5827 3340 040052E3 		cmp	r2, #4
 5828 3344 CF03000A 		beq	.L630
 5829              	.LVL515:
 5830              	.L573:
4452:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
 5831              		.loc 1 4452 0
 5832 3348 000097E5 		ldr	r0, [r7, #0]
 5833 334c 1C1E9FE5 		ldr	r1, .L640+24
 5834 3350 01C0D0E5 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
 5835 3354 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 5836 3358 00C08DE5 		str	ip, [sp, #0]
 5837 335c 0260D0E5 		ldrb	r6, [r0, #2]	@ zero_extendqisi2
 5838 3360 0400A0E3 		mov	r0, #4
 5839 3364 04608DE5 		str	r6, [sp, #4]
 5840 3368 FEFFFFEB 		bl	CyU3PDebugPrint
 5841              	.L575:
4482:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
 5842              		.loc 1 4482 0
 5843 336c 002097E5 		ldr	r2, [r7, #0]
4483:../uvc.c      ****                 dmaInfo.size   = 1024;
 5844              		.loc 1 4483 0
 5845 3370 01EBA0E3 		mov	lr, #1024	@ movhi
4484:../uvc.c      ****                 dmaInfo.status = 0;
 5846              		.loc 1 4484 0
 5847 3374 0030A0E3 		mov	r3, #0	@ movhi
4487:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
 5848              		.loc 1 4487 0
 5849 3378 E80D9FE5 		ldr	r0, .L640+16
4482:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
 5850              		.loc 1 4482 0
 5851 337c 14208DE5 		str	r2, [sp, #20]
4483:../uvc.c      ****                 dmaInfo.size   = 1024;
 5852              		.loc 1 4483 0
 5853 3380 BAE1CDE1 		strh	lr, [sp, #26]	@ movhi
4484:../uvc.c      ****                 dmaInfo.status = 0;
 5854              		.loc 1 4484 0
 5855 3384 BC31CDE1 		strh	r3, [sp, #28]	@ movhi
4487:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
 5856              		.loc 1 4487 0
 5857 3388 FEFFFFEB 		bl	CyU3PDmaChannelDiscardBuffer
 5858              	.LVL516:
4488:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5859              		.loc 1 4488 0
 5860 338c 002050E2 		subs	r2, r0, #0
 5861 3390 A000001A 		bne	.L631
4495:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
 5862              		.loc 1 4495 0
 5863 3394 0010E0E3 		mvn	r1, #0
 5864 3398 D40D9FE5 		ldr	r0, .L640+28
 5865              	.LVL517:
 5866 339c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 5867              	.LVL518:
4497:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
 5868              		.loc 1 4497 0
 5869 33a0 CC0D9FE5 		ldr	r0, .L640+28
 5870 33a4 14108DE2 		add	r1, sp, #20
 5871 33a8 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5872              	.LVL519:
4498:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5873              		.loc 1 4498 0
 5874 33ac 002050E2 		subs	r2, r0, #0
 5875 33b0 0100001A 		bne	.L632
 5876              	.LVL520:
 5877              	.L419:
4507:../uvc.c      ****         CyU3PThreadRelinquish ();
 5878              		.loc 1 4507 0
 5879 33b4 FEFFFFEB 		bl	_txe_thread_relinquish
4508:../uvc.c      ****     }
 5880              		.loc 1 4508 0
 5881 33b8 8DFFFFEA 		b	.L581
 5882              	.LVL521:
 5883              	.L632:
4500:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
 5884              		.loc 1 4500 0
 5885 33bc 0400A0E3 		mov	r0, #4
 5886              	.LVL522:
 5887 33c0 B01D9FE5 		ldr	r1, .L640+32
 5888 33c4 FEFFFFEB 		bl	CyU3PDebugPrint
 5889              	.LVL523:
 5890              	.L580:
 5891              	.LBB121:
 5892              	.LBB122:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5893              		.loc 1 2061 0
 5894 33c8 201E9FE5 		ldr	r1, .L640+152
 5895 33cc 0400A0E3 		mov	r0, #4
 5896 33d0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 5897              		.loc 1 2062 0
 5898 33d4 FA0FA0E3 		mov	r0, #1000
 5899 33d8 FEFFFFEB 		bl	_tx_thread_sleep
 5900 33dc F9FFFFEA 		b	.L580
 5901              	.L424:
 5902              	.LBE122:
 5903              	.LBE121:
 5904              	.LBB123:
 5905              	.LBB126:
3498:../uvc.c      ****     switch (wValue)
 5906              		.loc 1 3498 0
 5907 33e0 7C0D9FE5 		ldr	r0, .L640+12
 5908 33e4 B020D0E1 		ldrh	r2, [r0, #0]
 5909 33e8 060C52E3 		cmp	r2, #1536
 5910 33ec A103000A 		beq	.L448
 5911 33f0 AC00008A 		bhi	.L454
 5912 33f4 030C52E3 		cmp	r2, #768
 5913 33f8 9A03000A 		beq	.L445
 5914 33fc A100008A 		bhi	.L455
 5915 3400 010C52E3 		cmp	r2, #256
 5916 3404 9303000A 		beq	.L443
 5917 3408 020C52E3 		cmp	r2, #512
 5918 340c 8D03000A 		beq	.L633
 5919              	.L442:
3555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5920              		.loc 1 3555 0
 5921 3410 643D9FE5 		ldr	r3, .L640+36
 5922 3414 641D9FE5 		ldr	r1, .L640+40
 5923 3418 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5924 341c 0400A0E3 		mov	r0, #4
 5925 3420 FEFFFFEB 		bl	CyU3PDebugPrint
 5926 3424 99FFFFEA 		b	.L422
 5927              	.L425:
 5928              	.LBE126:
 5929              	.LBE123:
 5930              	.LBB130:
 5931              	.LBB133:
3423:../uvc.c      ****     switch (wValue)
 5932              		.loc 1 3423 0
 5933 3428 34CD9FE5 		ldr	ip, .L640+12
 5934 342c B020DCE1 		ldrh	r2, [ip, #0]
 5935 3430 060C52E3 		cmp	r2, #1536
 5936 3434 7F03000A 		beq	.L433
 5937 3438 8700008A 		bhi	.L439
 5938 343c 030C52E3 		cmp	r2, #768
 5939 3440 7803000A 		beq	.L431
 5940 3444 7C00008A 		bhi	.L440
 5941 3448 010C52E3 		cmp	r2, #256
 5942 344c 7103000A 		beq	.L429
 5943 3450 020C52E3 		cmp	r2, #512
 5944 3454 EDFFFF1A 		bne	.L442
 5945              	.LVL524:
3431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5946              		.loc 1 3431 0
 5947 3458 0100A0E3 		mov	r0, #1
 5948 345c FEFFFFEB 		bl	ControlHandle
 5949              	.LVL525:
 5950 3460 28309DE5 		ldr	r3, [sp, #40]
 5951 3464 8EFFFFEA 		b	.L421
 5952              	.L423:
 5953              	.LBE133:
 5954              	.LBE130:
 5955              	.LBB137:
 5956              	.LBB138:
3693:../uvc.c      **** 	if(valIdx < 32){
 5957              		.loc 1 3693 0
 5958 3468 146D9FE5 		ldr	r6, .L640+44
 5959 346c 8E24D6E5 		ldrb	r2, [r6, #1166]	@ zero_extendqisi2
 5960 3470 1F0052E3 		cmp	r2, #31
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5961              		.loc 1 3694 0
 5962 3474 E83C9F95 		ldrls	r3, .L640+12
3696:../uvc.c      **** 		valIdx++;
 5963              		.loc 1 3696 0
 5964 3478 01108292 		addls	r1, r2, #1
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5965              		.loc 1 3694 0
 5966 347c B0C0D391 		ldrlsh	ip, [r3, #0]
 5967 3480 82208490 		addls	r2, r4, r2, asl #1
 5968 3484 2CE4A091 		movls	lr, ip, lsr #8
 5969 3488 DCE0C295 		strlsb	lr, [r2, #220]
3695:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 5970              		.loc 1 3695 0
 5971 348c DDC0C295 		strlsb	ip, [r2, #221]
3696:../uvc.c      **** 		valIdx++;
 5972              		.loc 1 3696 0
 5973 3490 8E14C695 		strlsb	r1, [r6, #1166]
3697:../uvc.c      **** 		value[0][1] = valIdx;
 5974              		.loc 1 3697 0
 5975 3494 DD10C495 		strlsb	r1, [r4, #221]
 5976 3498 7CFFFFEA 		b	.L422
 5977              	.L626:
 5978              	.LBE138:
 5979              	.LBE137:
4237:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5980              		.loc 1 4237 0
 5981 349c FEFFFFEB 		bl	CyU3PUsbGetSpeed
4238:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5982              		.loc 1 4238 0
 5983 34a0 000050E3 		cmp	r0, #0
4237:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5984              		.loc 1 4237 0
 5985 34a4 C800C5E5 		strb	r0, [r5, #200]
4240:../uvc.c      ****                     isUsbConnected = CyTrue;
 5986              		.loc 1 4240 0
 5987 34a8 0100A013 		movne	r0, #1
 5988 34ac B0008515 		strne	r0, [r5, #176]
 5989 34b0 5BFFFFEA 		b	.L420
 5990              	.L628:
4356:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5991              		.loc 1 4356 0
 5992 34b4 C88C9FE5 		ldr	r8, .L640+44
4299:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5993              		.loc 1 4299 0
 5994 34b8 1800A0E3 		mov	r0, #24
 5995 34bc 24108DE2 		add	r1, sp, #36
 5996 34c0 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4356:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5997              		.loc 1 4356 0
 5998 34c4 0B27D8E5 		ldrb	r2, [r8, #1803]	@ zero_extendqisi2
 5999 34c8 0F0052E3 		cmp	r2, #15
 6000 34cc 0003000A 		beq	.L634
4383:../uvc.c      **** 				}else if(!snapButFlag){
 6001              		.loc 1 4383 0
 6002 34d0 000052E3 		cmp	r2, #0
 6003 34d4 28309D15 		ldrne	r3, [sp, #40]
 6004 34d8 7EFFFF1A 		bne	.L563
4385:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 6005              		.loc 1 4385 0
 6006 34dc A43C9FE5 		ldr	r3, .L640+48
 6007 34e0 02E0A0E3 		mov	lr, #2
 6008 34e4 001093E5 		ldr	r1, [r3, #0]
4386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6009              		.loc 1 4386 0
 6010 34e8 0160A0E3 		mov	r6, #1
4385:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 6011              		.loc 1 4385 0
 6012 34ec 00E0C1E5 		strb	lr, [r1, #0]
4386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6013              		.loc 1 4386 0
 6014 34f0 000093E5 		ldr	r0, [r3, #0]
4397:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6015              		.loc 1 4397 0
 6016 34f4 0010E0E3 		mvn	r1, #0
4386:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6017              		.loc 1 4386 0
 6018 34f8 0160C0E5 		strb	r6, [r0, #1]
4387:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 6019              		.loc 1 4387 0
 6020 34fc 00C093E5 		ldr	ip, [r3, #0]
4397:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6021              		.loc 1 4397 0
 6022 3500 840C9FE5 		ldr	r0, .L640+52
4387:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 6023              		.loc 1 4387 0
 6024 3504 0220CCE5 		strb	r2, [ip, #2]
4388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 6025              		.loc 1 4388 0
 6026 3508 00E093E5 		ldr	lr, [r3, #0]
4391:../uvc.c      **** 					interStabuf.size   = 1024;
 6027              		.loc 1 4391 0
 6028 350c 01CBA0E3 		mov	ip, #1024	@ movhi
4388:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 6029              		.loc 1 4388 0
 6030 3510 0360CEE5 		strb	r6, [lr, #3]
4390:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6031              		.loc 1 4390 0
 6032 3514 00E093E5 		ldr	lr, [r3, #0]
4394:../uvc.c      **** 					interStabuf.count = 4;
 6033              		.loc 1 4394 0
 6034 3518 0430A0E3 		mov	r3, #4	@ movhi
4392:../uvc.c      **** 					interStabuf.status = 0;
 6035              		.loc 1 4392 0
 6036 351c B021CDE1 		strh	r2, [sp, #16]	@ movhi
4391:../uvc.c      **** 					interStabuf.size   = 1024;
 6037              		.loc 1 4391 0
 6038 3520 BEC0CDE1 		strh	ip, [sp, #14]	@ movhi
4390:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6039              		.loc 1 4390 0
 6040 3524 08E08DE5 		str	lr, [sp, #8]
4394:../uvc.c      **** 					interStabuf.count = 4;
 6041              		.loc 1 4394 0
 6042 3528 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
4397:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6043              		.loc 1 4397 0
 6044 352c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4400:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 6045              		.loc 1 4400 0
 6046 3530 540C9FE5 		ldr	r0, .L640+52
 6047 3534 08108DE2 		add	r1, sp, #8
 6048 3538 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 6049              	.LVL526:
4402:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 6050              		.loc 1 4402 0
 6051 353c 002050E2 		subs	r2, r0, #0
 6052 3540 DA02001A 		bne	.L635
4408:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 6053              		.loc 1 4408 0
 6054 3544 0500A0E3 		mov	r0, #5
 6055              	.LVL527:
 6056 3548 3010A0E3 		mov	r1, #48
 6057 354c 0620A0E1 		mov	r2, r6
 6058              	.LVL528:
 6059 3550 FEFFFFEB 		bl	SensorSetControl
 6060 3554 28309DE5 		ldr	r3, [sp, #40]
4409:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 6061              		.loc 1 4409 0
 6062 3558 0B67C8E5 		strb	r6, [r8, #1803]
 6063 355c 5DFFFFEA 		b	.L563
 6064              	.L481:
 6065              	.LBB139:
 6066              	.LBB104:
3728:../uvc.c      ****     switch (wValue)
 6067              		.loc 1 3728 0
 6068 3560 060C53E3 		cmp	r3, #1536
 6069 3564 CD02000A 		beq	.L467
 6070 3568 1100008A 		bhi	.L482
 6071 356c 050C53E3 		cmp	r3, #1280
 6072 3570 46FFFF1A 		bne	.L422
 6073              	.LVL529:
3748:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6074              		.loc 1 3748 0
 6075 3574 1400A0E3 		mov	r0, #20
 6076 3578 FEFFFFEB 		bl	ControlHandle
 6077              	.LVL530:
 6078 357c 28309DE5 		ldr	r3, [sp, #40]
 6079 3580 47FFFFEA 		b	.L421
 6080              	.L480:
3728:../uvc.c      ****     switch (wValue)
 6081              		.loc 1 3728 0
 6082 3584 0F0C53E3 		cmp	r3, #3840
 6083 3588 C002000A 		beq	.L475
 6084 358c 1800008A 		bhi	.L483
 6085 3590 0B0C53E3 		cmp	r3, #2816
 6086 3594 B902000A 		beq	.L472
 6087 3598 0D00008A 		bhi	.L484
 6088 359c 0A0C53E3 		cmp	r3, #2560
 6089 35a0 3AFFFF1A 		bne	.L422
 6090              	.LVL531:
3769:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 6091              		.loc 1 3769 0
 6092 35a4 1900A0E3 		mov	r0, #25
 6093 35a8 FEFFFFEB 		bl	ControlHandle
 6094              	.LVL532:
 6095 35ac 28309DE5 		ldr	r3, [sp, #40]
 6096 35b0 3BFFFFEA 		b	.L421
 6097              	.L482:
3728:../uvc.c      ****     switch (wValue)
 6098              		.loc 1 3728 0
 6099 35b4 070C53E3 		cmp	r3, #1792
 6100 35b8 AC02000A 		beq	.L468
 6101 35bc 020B53E3 		cmp	r3, #2048
 6102 35c0 32FFFF1A 		bne	.L422
 6103              	.LVL533:
3760:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6104              		.loc 1 3760 0
 6105 35c4 1700A0E3 		mov	r0, #23
 6106 35c8 FEFFFFEB 		bl	ControlHandle
 6107              	.LVL534:
 6108 35cc 28309DE5 		ldr	r3, [sp, #40]
 6109 35d0 33FFFFEA 		b	.L421
 6110              	.L484:
3728:../uvc.c      ****     switch (wValue)
 6111              		.loc 1 3728 0
 6112 35d4 030B53E3 		cmp	r3, #3072
 6113 35d8 A002000A 		beq	.L473
 6114 35dc 0D0C53E3 		cmp	r3, #3328
 6115 35e0 2AFFFF1A 		bne	.L422
 6116              	.LVL535:
3785:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6117              		.loc 1 3785 0
 6118 35e4 1C00A0E3 		mov	r0, #28
 6119 35e8 FEFFFFEB 		bl	ControlHandle
 6120              	.LVL536:
 6121 35ec 28309DE5 		ldr	r3, [sp, #40]
 6122 35f0 2BFFFFEA 		b	.L421
 6123              	.L483:
3728:../uvc.c      ****     switch (wValue)
 6124              		.loc 1 3728 0
 6125 35f4 110C53E3 		cmp	r3, #4352
 6126 35f8 9402000A 		beq	.L477
 6127 35fc C900008A 		bhi	.L485
 6128 3600 010A53E3 		cmp	r3, #4096
 6129 3604 21FFFF1A 		bne	.L422
 6130              	.LVL537:
3797:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6131              		.loc 1 3797 0
 6132 3608 1F00A0E3 		mov	r0, #31
 6133 360c FEFFFFEB 		bl	ControlHandle
 6134              	.LVL538:
 6135 3610 28309DE5 		ldr	r3, [sp, #40]
 6136 3614 22FFFFEA 		b	.L421
 6137              	.LVL539:
 6138              	.L631:
 6139              	.LBE104:
 6140              	.LBE139:
4490:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
 6141              		.loc 1 4490 0
 6142 3618 0400A0E3 		mov	r0, #4
 6143              	.LVL540:
 6144 361c 6C1B9FE5 		ldr	r1, .L640+56
 6145 3620 FEFFFFEB 		bl	CyU3PDebugPrint
 6146              	.LVL541:
 6147              	.L579:
 6148              	.LBB140:
 6149              	.LBB141:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6150              		.loc 1 2061 0
 6151 3624 C41B9FE5 		ldr	r1, .L640+152
 6152 3628 0400A0E3 		mov	r0, #4
 6153 362c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6154              		.loc 1 2062 0
 6155 3630 FA0FA0E3 		mov	r0, #1000
 6156 3634 FEFFFFEB 		bl	_tx_thread_sleep
 6157 3638 F9FFFFEA 		b	.L579
 6158              	.L440:
 6159              	.LBE141:
 6160              	.LBE140:
 6161              	.LBB142:
 6162              	.LBB134:
3423:../uvc.c      ****     switch (wValue)
 6163              		.loc 1 3423 0
 6164 363c 010B52E3 		cmp	r2, #1024
 6165 3640 17FFFF0A 		beq	.L421
 6166 3644 050C52E3 		cmp	r2, #1280
 6167 3648 70FFFF1A 		bne	.L442
 6168              	.LVL542:
3442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6169              		.loc 1 3442 0
 6170 364c 0400A0E3 		mov	r0, #4
 6171 3650 FEFFFFEB 		bl	ControlHandle
 6172              	.LVL543:
 6173 3654 28309DE5 		ldr	r3, [sp, #40]
 6174 3658 11FFFFEA 		b	.L421
 6175              	.L439:
3423:../uvc.c      ****     switch (wValue)
 6176              		.loc 1 3423 0
 6177 365c 0A0C52E3 		cmp	r2, #2560
 6178 3660 7602000A 		beq	.L436
 6179 3664 1700008A 		bhi	.L441
 6180 3668 070C52E3 		cmp	r2, #1792
 6181 366c 6F02000A 		beq	.L434
 6182 3670 020B52E3 		cmp	r2, #2048
 6183 3674 65FFFF1A 		bne	.L442
 6184              	.LVL544:
3454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 6185              		.loc 1 3454 0
 6186 3678 0700A0E3 		mov	r0, #7
 6187 367c FEFFFFEB 		bl	ControlHandle
 6188              	.LVL545:
 6189 3680 28309DE5 		ldr	r3, [sp, #40]
 6190 3684 06FFFFEA 		b	.L421
 6191              	.L455:
 6192              	.LBE134:
 6193              	.LBE142:
 6194              	.LBB143:
 6195              	.LBB127:
3498:../uvc.c      ****     switch (wValue)
 6196              		.loc 1 3498 0
 6197 3688 010B52E3 		cmp	r2, #1024
 6198 368c 6302000A 		beq	.L446
 6199 3690 050C52E3 		cmp	r2, #1280
 6200 3694 5DFFFF1A 		bne	.L442
 6201              	.LVL546:
3520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6202              		.loc 1 3520 0
 6203 3698 0400A0E3 		mov	r0, #4
 6204 369c FEFFFFEB 		bl	CTControlHandle
 6205              	.LVL547:
 6206 36a0 28309DE5 		ldr	r3, [sp, #40]
 6207 36a4 FEFEFFEA 		b	.L421
 6208              	.L454:
3498:../uvc.c      ****     switch (wValue)
 6209              		.loc 1 3498 0
 6210 36a8 090C52E3 		cmp	r2, #2304
 6211 36ac 5702000A 		beq	.L450
 6212 36b0 0E00008A 		bhi	.L456
 6213 36b4 070C52E3 		cmp	r2, #1792
 6214 36b8 5002000A 		beq	.L449
 6215 36bc 020B52E3 		cmp	r2, #2048
 6216 36c0 52FFFF1A 		bne	.L442
 6217 36c4 F6FEFFEA 		b	.L421
 6218              	.L441:
 6219              	.LBE127:
 6220              	.LBE143:
 6221              	.LBB144:
 6222              	.LBB132:
3423:../uvc.c      ****     switch (wValue)
 6223              		.loc 1 3423 0
 6224 36c8 0D0C52E3 		cmp	r2, #3328
 6225 36cc 5B02000A 		beq	.L436
 6226 36d0 0E0C52E3 		cmp	r2, #3584
 6227 36d4 4502000A 		beq	.L438
 6228 36d8 030B52E3 		cmp	r2, #3072
 6229 36dc 4BFFFF1A 		bne	.L442
 6230              	.LVL548:
3464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6231              		.loc 1 3464 0
 6232 36e0 0B00A0E3 		mov	r0, #11
 6233 36e4 FEFFFFEB 		bl	ControlHandle
 6234              	.LVL549:
 6235 36e8 28309DE5 		ldr	r3, [sp, #40]
 6236 36ec ECFEFFEA 		b	.L421
 6237              	.L456:
 6238              	.LBE132:
 6239              	.LBE144:
 6240              	.LBB145:
 6241              	.LBB125:
3498:../uvc.c      ****     switch (wValue)
 6242              		.loc 1 3498 0
 6243 36f0 0B0C52E3 		cmp	r2, #2816
 6244 36f4 3902000A 		beq	.L452
 6245 36f8 030B52E3 		cmp	r2, #3072
 6246 36fc 3302000A 		beq	.L453
 6247 3700 0A0C52E3 		cmp	r2, #2560
 6248 3704 41FFFF1A 		bne	.L442
 6249              	.LVL550:
3539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6250              		.loc 1 3539 0
 6251 3708 0800A0E3 		mov	r0, #8
 6252 370c FEFFFFEB 		bl	CTControlHandle
 6253              	.LVL551:
 6254 3710 28309DE5 		ldr	r3, [sp, #40]
 6255 3714 E2FEFFEA 		b	.L421
 6256              	.LVL552:
 6257              	.L571:
 6258              	.LBE125:
 6259              	.LBE145:
4458:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
 6260              		.loc 1 4458 0
 6261 3718 010053E3 		cmp	r3, #1
 6262 371c 1800000A 		beq	.L636
4478:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
 6263              		.loc 1 4478 0
 6264 3720 000097E5 		ldr	r0, [r7, #0]
 6265 3724 0C10A0E1 		mov	r1, ip
 6266 3728 B821DDE1 		ldrh	r2, [sp, #24]
 6267 372c FEFFFFEB 		bl	CyU3PMemCopy
4479:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
 6268              		.loc 1 4479 0
 6269 3730 001097E5 		ldr	r1, [r7, #0]
 6270 3734 B821DDE1 		ldrh	r2, [sp, #24]
 6271 3738 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 6272 373c 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6273 3740 00008DE5 		str	r0, [sp, #0]
 6274 3744 02C0D1E5 		ldrb	ip, [r1, #2]	@ zero_extendqisi2
 6275 3748 0400A0E3 		mov	r0, #4
 6276 374c 401A9FE5 		ldr	r1, .L640+60
 6277 3750 04C08DE5 		str	ip, [sp, #4]
 6278 3754 FEFFFFEB 		bl	CyU3PDebugPrint
 6279 3758 03FFFFEA 		b	.L575
 6280              	.L629:
4423:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
 6281              		.loc 1 4423 0
 6282 375c 0400A0E3 		mov	r0, #4
 6283 3760 301A9FE5 		ldr	r1, .L640+64
 6284 3764 0620A0E1 		mov	r2, r6
 6285 3768 FEFFFFEB 		bl	CyU3PDebugPrint
 6286              	.L570:
 6287              	.LBB146:
 6288              	.LBB147:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6289              		.loc 1 2061 0
 6290 376c 7C1A9FE5 		ldr	r1, .L640+152
 6291 3770 0400A0E3 		mov	r0, #4
 6292 3774 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6293              		.loc 1 2062 0
 6294 3778 FA0FA0E3 		mov	r0, #1000
 6295 377c FEFFFFEB 		bl	_tx_thread_sleep
 6296 3780 F9FFFFEA 		b	.L570
 6297              	.L636:
 6298              	.LBE147:
 6299              	.LBE146:
4462:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
 6300              		.loc 1 4462 0
 6301 3784 0110DCE5 		ldrb	r1, [ip, #1]	@ zero_extendqisi2
 6302 3788 0220DCE5 		ldrb	r2, [ip, #2]	@ zero_extendqisi2
 6303 378c 03C0DCE5 		ldrb	ip, [ip, #3]	@ zero_extendqisi2
 6304 3790 0630A0E1 		mov	r3, r6
 6305 3794 7000A0E3 		mov	r0, #112
 6306 3798 006097E5 		ldr	r6, [r7, #0]
 6307              	.LVL553:
 6308 379c 00C08DE5 		str	ip, [sp, #0]
 6309 37a0 FEFFFFEB 		bl	SensorWrite2B
 6310              	.LVL554:
4464:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
 6311              		.loc 1 4464 0
 6312 37a4 F0199FE5 		ldr	r1, .L640+68
4462:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
 6313              		.loc 1 4462 0
 6314 37a8 0000C6E5 		strb	r0, [r6, #0]
4464:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
 6315              		.loc 1 4464 0
 6316 37ac 14009DE5 		ldr	r0, [sp, #20]
 6317 37b0 B821DDE1 		ldrh	r2, [sp, #24]
 6318 37b4 03E0D0E5 		ldrb	lr, [r0, #3]	@ zero_extendqisi2
 6319 37b8 0230D0E5 		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 6320 37bc 03C080E2 		add	ip, r0, #3
 6321 37c0 0400A0E3 		mov	r0, #4
 6322 37c4 00E08DE5 		str	lr, [sp, #0]
 6323 37c8 04C08DE5 		str	ip, [sp, #4]
 6324 37cc FEFFFFEB 		bl	CyU3PDebugPrint
4465:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
 6325              		.loc 1 4465 0
 6326 37d0 001097E5 		ldr	r1, [r7, #0]
 6327 37d4 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6328 37d8 000053E3 		cmp	r3, #0
 6329 37dc F901001A 		bne	.L418
4471:../uvc.c      ****                     dmaInfo.count -= 2;
 6330              		.loc 1 4471 0
 6331 37e0 B861DDE1 		ldrh	r6, [sp, #24]
 6332 37e4 022046E2 		sub	r2, r6, #2
 6333 37e8 B821CDE1 		strh	r2, [sp, #24]	@ movhi
 6334 37ec DEFEFFEA 		b	.L575
 6335              	.L487:
 6336              	.LVL555:
 6337              	.LBB148:
 6338              	.LBB111:
3829:../uvc.c      ****     switch (wValue)
 6339              		.loc 1 3829 0
 6340 37f0 6C099FE5 		ldr	r0, .L640+12
 6341 37f4 B020D0E1 		ldrh	r2, [r0, #0]
 6342 37f8 030C52E3 		cmp	r2, #768
 6343 37fc BA01000A 		beq	.L491
 6344 3800 5000008A 		bhi	.L494
 6345 3804 010C52E3 		cmp	r2, #256
 6346 3808 9701000A 		beq	.L489
 6347 380c 020C52E3 		cmp	r2, #512
 6348 3810 A9FEFF1A 		bne	.L488
3894:../uvc.c      ****             switch (bRequest)
 6349              		.loc 1 3894 0
 6350 3814 60299FE5 		ldr	r2, .L640+36
 6351 3818 0060D2E5 		ldrb	r6, [r2, #0]	@ zero_extendqisi2
 6352 381c 810056E3 		cmp	r6, #129
 6353 3820 8200000A 		beq	.L555
 6354 3824 2501008A 		bhi	.L507
 6355 3828 010056E3 		cmp	r6, #1
 6356 382c 9B00001A 		bne	.L532
3917:../uvc.c      ****                     CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 6357              		.loc 1 3917 0
 6358 3830 68199FE5 		ldr	r1, .L640+72
 6359 3834 0400A0E3 		mov	r0, #4
 6360 3838 FEFFFFEB 		bl	CyU3PDebugPrint
3920:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 6361              		.loc 1 3920 0
 6362 383c 0600A0E1 		mov	r0, r6
 6363 3840 FEFFFFEB 		bl	CyU3PGpifDisable
3921:../uvc.c      ****                     gpif_initialized = 0;
 6364              		.loc 1 3921 0
 6365 3844 0080A0E3 		mov	r8, #0
3925:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 6366              		.loc 1 3925 0
 6367 3848 0610A0E1 		mov	r1, r6
 6368 384c 8300A0E3 		mov	r0, #131
3921:../uvc.c      ****                     gpif_initialized = 0;
 6369              		.loc 1 3921 0
 6370 3850 A88084E5 		str	r8, [r4, #168]
3922:../uvc.c      ****                     streamingStarted = CyFalse;
 6371              		.loc 1 3922 0
 6372 3854 AC8084E5 		str	r8, [r4, #172]
3925:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 6373              		.loc 1 3925 0
 6374 3858 FEFFFFEB 		bl	CyU3PUsbSetEpNak
3926:../uvc.c      ****                     CyU3PBusyWait (100);
 6375              		.loc 1 3926 0
 6376 385c 6400A0E3 		mov	r0, #100
 6377 3860 FEFFFFEB 		bl	CyU3PBusyWait
3929:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6378              		.loc 1 3929 0
 6379 3864 38099FE5 		ldr	r0, .L640+76
 6380 3868 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
3930:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6381              		.loc 1 3930 0
 6382 386c 8300A0E3 		mov	r0, #131
 6383 3870 FEFFFFEB 		bl	CyU3PUsbFlushEp
3931:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 6384              		.loc 1 3931 0
 6385 3874 0810A0E1 		mov	r1, r8
 6386 3878 8300A0E3 		mov	r0, #131
 6387 387c FEFFFFEB 		bl	CyU3PUsbSetEpNak
3932:../uvc.c      ****                     CyU3PBusyWait (100);
 6388              		.loc 1 3932 0
 6389 3880 6400A0E3 		mov	r0, #100
 6390 3884 FEFFFFEB 		bl	CyU3PBusyWait
3935:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 6391              		.loc 1 3935 0
 6392 3888 0810A0E1 		mov	r1, r8
 6393 388c 0620A0E1 		mov	r2, r6
 6394 3890 8300A0E3 		mov	r0, #131
 6395 3894 FEFFFFEB 		bl	CyU3PUsbStall
3939:../uvc.c      ****                     CyU3PUsbAckSetup ();
 6396              		.loc 1 3939 0
 6397 3898 FEFFFFEB 		bl	CyU3PUsbAckSetup
3942:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x10; //set bit0
 6398              		.loc 1 3942 0
 6399 389c 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 6400              	.LBB115:
 6401              	.LBB117:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 6402              		.loc 1 2074 0
 6403 38a0 B0089FE5 		ldr	r0, .L640
 6404              	.LBE117:
 6405              	.LBE115:
3942:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x10; //set bit0
 6406              		.loc 1 3942 0
 6407 38a4 10C081E3 		orr	ip, r1, #16
 6408              	.LBB114:
 6409              	.LBB116:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 6410              		.loc 1 2074 0
 6411 38a8 0220A0E3 		mov	r2, #2
 6412 38ac 0610A0E1 		mov	r1, r6
 6413 38b0 20308DE2 		add	r3, sp, #32
 6414              	.LBE116:
 6415              	.LBE114:
3941:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 6416              		.loc 1 3941 0
 6417 38b4 C46084E5 		str	r6, [r4, #196]
3942:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x10; //set bit0
 6418              		.loc 1 3942 0
 6419 38b8 2AC0C4E5 		strb	ip, [r4, #42]
 6420              	.LBB113:
 6421              	.LBB118:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 6422              		.loc 1 2074 0
 6423 38bc 00808DE5 		str	r8, [sp, #0]
 6424 38c0 FEFFFFEB 		bl	_txe_event_flags_get
 6425 38c4 080050E1 		cmp	r0, r8
 6426 38c8 0700001A 		bne	.L509
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 6427              		.loc 1 2077 0
 6428 38cc 0110E0E3 		mvn	r1, #1
 6429 38d0 0220A0E3 		mov	r2, #2
 6430 38d4 7C089FE5 		ldr	r0, .L640
 6431 38d8 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 6432              		.loc 1 2080 0
 6433 38dc 74089FE5 		ldr	r0, .L640
 6434 38e0 0210A0E3 		mov	r1, #2
 6435 38e4 0820A0E1 		mov	r2, r8
 6436 38e8 FEFFFFEB 		bl	_txe_event_flags_set
 6437              	.L509:
 6438              	.LBE118:
 6439              	.LBE113:
3949:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6440              		.loc 1 3949 0
 6441 38ec 2000A0E3 		mov	r0, #32
 6442 38f0 B0189FE5 		ldr	r1, .L640+80
 6443 38f4 2E208DE2 		add	r2, sp, #46
 6444 38f8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6445              	.LVL556:
3951:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6446              		.loc 1 3951 0
 6447 38fc 000050E3 		cmp	r0, #0
 6448 3900 71FEFF1A 		bne	.L616
3953:../uvc.c      ****                         switch (glCommitCtrl[3])
 6449              		.loc 1 3953 0
 6450 3904 83E1D5E5 		ldrb	lr, [r5, #387]	@ zero_extendqisi2
 6451 3908 01004EE2 		sub	r0, lr, #1
 6452              	.LVL557:
 6453 390c 030050E3 		cmp	r0, #3
 6454 3910 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 6455 3914 050100EA 		b	.L510
 6456              	.L515:
 6457 3918 743D0000 		.word	.L511
 6458 391c 203E0000 		.word	.L512
 6459 3920 C03D0000 		.word	.L513
 6460 3924 D43C0000 		.word	.L514
 6461              	.L485:
 6462              	.LBE111:
 6463              	.LBE148:
 6464              	.LBB149:
 6465              	.LBB106:
3728:../uvc.c      ****     switch (wValue)
 6466              		.loc 1 3728 0
 6467 3928 120C53E3 		cmp	r3, #4608
 6468 392c DF00000A 		beq	.L478
 6469 3930 130C53E3 		cmp	r3, #4864
 6470 3934 55FEFF1A 		bne	.L422
 6471              	.LVL558:
3809:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6472              		.loc 1 3809 0
 6473 3938 2600A0E3 		mov	r0, #38
 6474 393c FEFFFFEB 		bl	ControlHandle
 6475              	.LVL559:
 6476 3940 28309DE5 		ldr	r3, [sp, #40]
 6477 3944 56FEFFEA 		b	.L421
 6478              	.LVL560:
 6479              	.L494:
 6480              	.LBE106:
 6481              	.LBE149:
 6482              	.LBB150:
 6483              	.LBB119:
3829:../uvc.c      ****     switch (wValue)
 6484              		.loc 1 3829 0
 6485 3948 010B52E3 		cmp	r2, #1024
 6486 394c 4C00000A 		beq	.L492
 6487 3950 050C52E3 		cmp	r2, #1280
 6488 3954 58FEFF1A 		bne	.L488
4144:../uvc.c      ****             	switch (bRequest)
 6489              		.loc 1 4144 0
 6490 3958 1C189FE5 		ldr	r1, .L640+36
 6491 395c 0020D1E5 		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 6492 3960 810052E3 		cmp	r2, #129
 6493 3964 3100000A 		beq	.L555
 6494 3968 2500008A 		bhi	.L558
 6495 396c 010052E3 		cmp	r2, #1
 6496 3970 51FEFF1A 		bne	.L488
4169:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6497              		.loc 1 4169 0
 6498 3974 2000A0E3 		mov	r0, #32
 6499 3978 28189FE5 		ldr	r1, .L640+80
 6500 397c 2E208DE2 		add	r2, sp, #46
 6501 3980 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6502              	.LVL561:
4171:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6503              		.loc 1 4171 0
 6504 3984 000050E3 		cmp	r0, #0
 6505 3988 1700001A 		bne	.L560
4175:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6506              		.loc 1 4175 0
 6507 398c 0020A0E3 		mov	r2, #0
 6508 3990 C0079FE5 		ldr	r0, .L640
 6509              	.LVL562:
 6510 3994 8010A0E3 		mov	r1, #128
 6511 3998 FEFFFFEB 		bl	_txe_event_flags_set
 6512              	.LVL563:
4176:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 6513              		.loc 1 4176 0
 6514 399c 002050E2 		subs	r2, r0, #0
4182:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 6515              		.loc 1 4182 0
 6516 39a0 0F60E003 		mvneq	r6, #15
 6517 39a4 BA60C505 		streqb	r6, [r5, #186]
4176:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 6518              		.loc 1 4176 0
 6519 39a8 0200000A 		beq	.L562
4178:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 6520              		.loc 1 4178 0
 6521 39ac F8179FE5 		ldr	r1, .L640+84
 6522 39b0 0400A0E3 		mov	r0, #4
 6523              	.LVL564:
 6524 39b4 FEFFFFEB 		bl	CyU3PDebugPrint
 6525              	.LVL565:
 6526              	.L562:
4185:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 6527              		.loc 1 4185 0
 6528 39b8 81E1D4E5 		ldrb	lr, [r4, #385]	@ zero_extendqisi2
 6529 39bc 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6530 39c0 BE22DDE1 		ldrh	r2, [sp, #46]
 6531              	.LVL566:
 6532 39c4 0400A0E3 		mov	r0, #4
 6533 39c8 E0179FE5 		ldr	r1, .L640+88
 6534 39cc 00E08DE5 		str	lr, [sp, #0]
 6535 39d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6536 39d4 28309DE5 		ldr	r3, [sp, #40]
 6537 39d8 3CFEFFEA 		b	.L486
 6538              	.LVL567:
 6539              	.L470:
 6540              	.LBE119:
 6541              	.LBE150:
 6542              	.LBB151:
 6543              	.LBB103:
3764:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6544              		.loc 1 3764 0
 6545 39dc 1800A0E3 		mov	r0, #24
 6546 39e0 FEFFFFEB 		bl	ControlHandle
 6547              	.LVL568:
 6548 39e4 28309DE5 		ldr	r3, [sp, #40]
 6549 39e8 2DFEFFEA 		b	.L421
 6550              	.LVL569:
 6551              	.L560:
 6552              	.LBE103:
 6553              	.LBE151:
 6554              	.LBB152:
 6555              	.LBB110:
4187:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6556              		.loc 1 4187 0
 6557 39ec C0179FE5 		ldr	r1, .L640+92
 6558 39f0 BE22DDE1 		ldrh	r2, [sp, #46]
 6559 39f4 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6560 39f8 0400A0E3 		mov	r0, #4
 6561              	.LVL570:
 6562 39fc FEFFFFEB 		bl	CyU3PDebugPrint
 6563 3a00 2DFEFFEA 		b	.L488
 6564              	.LVL571:
 6565              	.L558:
4144:../uvc.c      ****             	switch (bRequest)
 6566              		.loc 1 4144 0
 6567 3a04 850052E3 		cmp	r2, #133
 6568 3a08 1000000A 		beq	.L556
 6569 3a0c 860052E3 		cmp	r2, #134
 6570 3a10 29FEFF1A 		bne	.L488
 6571              	.L621:
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6572              		.loc 1 3898 0
 6573 3a14 0100A0E3 		mov	r0, #1
 6574              	.L615:
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6575              		.loc 1 3897 0
 6576 3a18 0330A0E3 		mov	r3, #3
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6577              		.loc 1 3898 0
 6578 3a1c 94179FE5 		ldr	r1, .L640+96
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6579              		.loc 1 3897 0
 6580 3a20 1C31C4E5 		strb	r3, [r4, #284]
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6581              		.loc 1 3898 0
 6582 3a24 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6583 3a28 28309DE5 		ldr	r3, [sp, #40]
 6584 3a2c 27FEFFEA 		b	.L486
 6585              	.L555:
4156:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6586              		.loc 1 4156 0
 6587 3a30 C8C0D4E5 		ldrb	ip, [r4, #200]	@ zero_extendqisi2
 6588 3a34 03005CE3 		cmp	ip, #3
 6589 3a38 0C00000A 		beq	.L637
 6590              	.L559:
4162:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6591              		.loc 1 4162 0
 6592 3a3c 1A00A0E3 		mov	r0, #26
 6593 3a40 74179FE5 		ldr	r1, .L640+100
 6594 3a44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6595 3a48 28309DE5 		ldr	r3, [sp, #40]
 6596 3a4c 1FFEFFEA 		b	.L486
 6597              	.L556:
4153:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6598              		.loc 1 4153 0
 6599 3a50 60179FE5 		ldr	r1, .L640+96
 6600 3a54 0200A0E3 		mov	r0, #2
 6601              	.L617:
4152:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6602              		.loc 1 4152 0
 6603 3a58 0020A0E3 		mov	r2, #0
4151:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 6604              		.loc 1 4151 0
 6605 3a5c 1C31C4E5 		strb	r3, [r4, #284]
4152:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6606              		.loc 1 4152 0
 6607 3a60 1D21C4E5 		strb	r2, [r4, #285]
4153:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6608              		.loc 1 4153 0
 6609 3a64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6610 3a68 28309DE5 		ldr	r3, [sp, #40]
 6611 3a6c 17FEFFEA 		b	.L486
 6612              	.L637:
4158:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6613              		.loc 1 4158 0
 6614 3a70 1A00A0E3 		mov	r0, #26
 6615 3a74 44179FE5 		ldr	r1, .L640+104
 6616 3a78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6617 3a7c 28309DE5 		ldr	r3, [sp, #40]
 6618 3a80 12FEFFEA 		b	.L486
 6619              	.L492:
4058:../uvc.c      ****                 switch (bRequest)
 6620              		.loc 1 4058 0
 6621 3a84 F0269FE5 		ldr	r2, .L640+36
 6622 3a88 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 6623 3a8c 810052E3 		cmp	r2, #129
 6624 3a90 1D00000A 		beq	.L534
 6625 3a94 1600008A 		bhi	.L537
 6626 3a98 010052E3 		cmp	r2, #1
 6627 3a9c 0500000A 		beq	.L638
 6628              	.L532:
4137:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 6629              		.loc 1 4137 0
 6630 3aa0 0000A0E3 		mov	r0, #0
 6631 3aa4 0110A0E3 		mov	r1, #1
 6632 3aa8 0020A0E1 		mov	r2, r0
 6633 3aac FEFFFFEB 		bl	CyU3PUsbStall
 6634 3ab0 28309DE5 		ldr	r3, [sp, #40]
 6635 3ab4 05FEFFEA 		b	.L486
 6636              	.L638:
4083:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6637              		.loc 1 4083 0
 6638 3ab8 2000A0E3 		mov	r0, #32
 6639 3abc E4169FE5 		ldr	r1, .L640+80
 6640 3ac0 2E208DE2 		add	r2, sp, #46
 6641 3ac4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6642              	.LVL572:
4085:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6643              		.loc 1 4085 0
 6644 3ac8 000050E3 		cmp	r0, #0
 6645 3acc FEFDFF1A 		bne	.L616
4104:../uvc.c      ****                            switch (glCommitCtrl[1])
 6646              		.loc 1 4104 0
 6647 3ad0 8101D5E5 		ldrb	r0, [r5, #385]	@ zero_extendqisi2
 6648              	.LVL573:
 6649 3ad4 011040E2 		sub	r1, r0, #1
 6650 3ad8 030051E3 		cmp	r1, #3
 6651 3adc 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6652 3ae0 210000EA 		b	.L539
 6653              	.L544:
 6654 3ae4 003C0000 		.word	.L540
 6655 3ae8 583C0000 		.word	.L541
 6656 3aec BC3B0000 		.word	.L542
 6657 3af0 2C3B0000 		.word	.L543
 6658              	.LVL574:
 6659              	.L537:
4058:../uvc.c      ****                 switch (bRequest)
 6660              		.loc 1 4058 0
 6661 3af4 850052E3 		cmp	r2, #133
 6662 3af8 2B00000A 		beq	.L535
 6663 3afc 860052E3 		cmp	r2, #134
 6664 3b00 E6FFFF1A 		bne	.L532
 6665              	.L620:
4062:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6666              		.loc 1 4062 0
 6667 3b04 0300A0E1 		mov	r0, r3
 6668 3b08 C2FFFFEA 		b	.L615
 6669              	.L534:
4070:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6670              		.loc 1 4070 0
 6671 3b0c C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
4072:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6672              		.loc 1 4072 0
 6673 3b10 0B00A0E3 		mov	r0, #11
4070:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6674              		.loc 1 4070 0
 6675 3b14 030053E3 		cmp	r3, #3
4072:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6676              		.loc 1 4072 0
 6677 3b18 A4169F05 		ldreq	r1, .L640+108
4076:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6678              		.loc 1 4076 0
 6679 3b1c A4169F15 		ldrne	r1, .L640+112
 6680 3b20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6681 3b24 28309DE5 		ldr	r3, [sp, #40]
 6682 3b28 E8FDFFEA 		b	.L486
 6683              	.LVL575:
 6684              	.L543:
4107:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6685              		.loc 1 4107 0
 6686 3b2c D82094E5 		ldr	r2, [r4, #216]
 6687 3b30 3010A0E3 		mov	r1, #48
 6688 3b34 000052E3 		cmp	r2, #0
 6689 3b38 E420A003 		moveq	r2, #228
 6690 3b3c 6420A013 		movne	r2, #100
 6691 3b40 5230A0E3 		mov	r3, #82
 6692 3b44 0100A0E3 		mov	r0, #1
 6693 3b48 FEFFFFEB 		bl	SensorSetIrisControl
4109:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6694              		.loc 1 4109 0
 6695 3b4c D82094E5 		ldr	r2, [r4, #216]
 6696 3b50 74169FE5 		ldr	r1, .L640+116
 6697 3b54 000052E3 		cmp	r2, #0
 6698 3b58 D83094E5 		ldr	r3, [r4, #216]
 6699 3b5c E420A003 		moveq	r2, #228
 6700 3b60 6420A013 		movne	r2, #100
 6701 3b64 0400A0E3 		mov	r0, #4
 6702 3b68 FEFFFFEB 		bl	CyU3PDebugPrint
 6703              	.L539:
4129:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6704              		.loc 1 4129 0
 6705 3b6c 81E1D4E5 		ldrb	lr, [r4, #385]	@ zero_extendqisi2
4131:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6706              		.loc 1 4131 0
 6707 3b70 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6708 3b74 BE22DDE1 		ldrh	r2, [sp, #46]
 6709              	.LVL576:
 6710 3b78 0400A0E3 		mov	r0, #4
 6711 3b7c 4C169FE5 		ldr	r1, .L640+120
4129:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6712              		.loc 1 4129 0
 6713 3b80 A0E1C4E5 		strb	lr, [r4, #416]
4131:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6714              		.loc 1 4131 0
 6715 3b84 00E08DE5 		str	lr, [sp, #0]
 6716 3b88 FEFFFFEB 		bl	CyU3PDebugPrint
 6717 3b8c 28309DE5 		ldr	r3, [sp, #40]
 6718 3b90 CEFDFFEA 		b	.L486
 6719              	.LVL577:
 6720              	.L529:
4008:../uvc.c      ****                 switch (bRequest)
 6721              		.loc 1 4008 0
 6722 3b94 860052E3 		cmp	r2, #134
 6723 3b98 D9FFFF0A 		beq	.L620
 6724 3b9c 870052E3 		cmp	r2, #135
 6725 3ba0 D9FFFF0A 		beq	.L534
 6726              	.L625:
 6727 3ba4 850052E3 		cmp	r2, #133
 6728 3ba8 BCFFFF1A 		bne	.L532
 6729              	.L535:
4067:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6730              		.loc 1 4067 0
 6731 3bac 0200A0E3 		mov	r0, #2
 6732 3bb0 00169FE5 		ldr	r1, .L640+96
4065:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 6733              		.loc 1 4065 0
 6734 3bb4 1A30A0E3 		mov	r3, #26
 6735 3bb8 A6FFFFEA 		b	.L617
 6736              	.LVL578:
 6737              	.L542:
4112:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6738              		.loc 1 4112 0
 6739 3bbc D82094E5 		ldr	r2, [r4, #216]
 6740 3bc0 3010A0E3 		mov	r1, #48
 6741 3bc4 000052E3 		cmp	r2, #0
 6742 3bc8 D420A003 		moveq	r2, #212
 6743 3bcc 5420A013 		movne	r2, #84
 6744 3bd0 5230A0E3 		mov	r3, #82
 6745 3bd4 0100A0E3 		mov	r0, #1
 6746 3bd8 FEFFFFEB 		bl	SensorSetIrisControl
4114:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6747              		.loc 1 4114 0
 6748 3bdc D82094E5 		ldr	r2, [r4, #216]
 6749 3be0 E4159FE5 		ldr	r1, .L640+116
 6750 3be4 000052E3 		cmp	r2, #0
 6751 3be8 D83094E5 		ldr	r3, [r4, #216]
 6752 3bec D420A003 		moveq	r2, #212
 6753 3bf0 5420A013 		movne	r2, #84
 6754 3bf4 0400A0E3 		mov	r0, #4
 6755 3bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 6756 3bfc DAFFFFEA 		b	.L539
 6757              	.L540:
4122:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6758              		.loc 1 4122 0
 6759 3c00 7C659FE5 		ldr	r6, .L640+44
 6760 3c04 D80094E5 		ldr	r0, [r4, #216]
 6761 3c08 8D34D6E5 		ldrb	r3, [r6, #1165]	@ zero_extendqisi2
 6762 3c0c 000050E3 		cmp	r0, #0
 6763 3c10 F400A003 		moveq	r0, #244
 6764 3c14 7400A013 		movne	r0, #116
 6765 3c18 032080E1 		orr	r2, r0, r3
 6766 3c1c 3010A0E3 		mov	r1, #48
 6767 3c20 5230A0E3 		mov	r3, #82
 6768 3c24 0100A0E3 		mov	r0, #1
 6769 3c28 FEFFFFEB 		bl	SensorSetIrisControl
4124:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6770              		.loc 1 4124 0
 6771 3c2c D8C094E5 		ldr	ip, [r4, #216]
 6772 3c30 8D64D6E5 		ldrb	r6, [r6, #1165]	@ zero_extendqisi2
 6773 3c34 00005CE3 		cmp	ip, #0
 6774 3c38 F4C0A003 		moveq	ip, #244
 6775 3c3c 74C0A013 		movne	ip, #116
 6776 3c40 D83094E5 		ldr	r3, [r4, #216]
 6777 3c44 80159FE5 		ldr	r1, .L640+116
 6778 3c48 06208CE1 		orr	r2, ip, r6
 6779 3c4c 0400A0E3 		mov	r0, #4
 6780 3c50 FEFFFFEB 		bl	CyU3PDebugPrint
 6781 3c54 C4FFFFEA 		b	.L539
 6782              	.L541:
4117:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6783              		.loc 1 4117 0
 6784 3c58 24659FE5 		ldr	r6, .L640+44
 6785 3c5c D8E094E5 		ldr	lr, [r4, #216]
 6786 3c60 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 6787 3c64 00005EE3 		cmp	lr, #0
 6788 3c68 C4E0A003 		moveq	lr, #196
 6789 3c6c 44E0A013 		movne	lr, #68
 6790 3c70 02208EE1 		orr	r2, lr, r2
 6791 3c74 3010A0E3 		mov	r1, #48
 6792 3c78 5230A0E3 		mov	r3, #82
 6793 3c7c 0100A0E3 		mov	r0, #1
 6794 3c80 FEFFFFEB 		bl	SensorSetIrisControl
4119:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6795              		.loc 1 4119 0
 6796 3c84 D8C094E5 		ldr	ip, [r4, #216]
 6797 3c88 8D64D6E5 		ldrb	r6, [r6, #1165]	@ zero_extendqisi2
 6798 3c8c 00005CE3 		cmp	ip, #0
 6799 3c90 C4C0A003 		moveq	ip, #196
 6800 3c94 44C0A013 		movne	ip, #68
 6801 3c98 D83094E5 		ldr	r3, [r4, #216]
 6802 3c9c 28159FE5 		ldr	r1, .L640+116
 6803 3ca0 06208CE1 		orr	r2, ip, r6
 6804 3ca4 0400A0E3 		mov	r0, #4
 6805 3ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 6806 3cac AEFFFFEA 		b	.L539
 6807              	.L478:
 6808              	.LVL579:
 6809              	.LBE110:
 6810              	.LBE152:
 6811              	.LBB153:
 6812              	.LBB107:
3805:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6813              		.loc 1 3805 0
 6814 3cb0 2500A0E3 		mov	r0, #37
 6815 3cb4 FEFFFFEB 		bl	ControlHandle
 6816              	.LVL580:
 6817 3cb8 28309DE5 		ldr	r3, [sp, #40]
 6818 3cbc 78FDFFEA 		b	.L421
 6819              	.LVL581:
 6820              	.L507:
 6821              	.LBE107:
 6822              	.LBE153:
 6823              	.LBB154:
 6824              	.LBB120:
3894:../uvc.c      ****             switch (bRequest)
 6825              		.loc 1 3894 0
 6826 3cc0 850056E3 		cmp	r6, #133
 6827 3cc4 B8FFFF0A 		beq	.L535
 6828 3cc8 860056E3 		cmp	r6, #134
 6829 3ccc 73FFFF1A 		bne	.L532
 6830 3cd0 4FFFFFEA 		b	.L621
 6831              	.LVL582:
 6832              	.L514:
3971:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6833              		.loc 1 3971 0
 6834 3cd4 A8649FE5 		ldr	r6, .L640+44
 6835 3cd8 D80094E5 		ldr	r0, [r4, #216]
 6836 3cdc 8DE4D6E5 		ldrb	lr, [r6, #1165]	@ zero_extendqisi2
 6837 3ce0 000050E3 		cmp	r0, #0
 6838 3ce4 F400A003 		moveq	r0, #244
 6839 3ce8 7400A013 		movne	r0, #116
 6840 3cec 0E2080E1 		orr	r2, r0, lr
 6841 3cf0 3010A0E3 		mov	r1, #48
 6842 3cf4 5230A0E3 		mov	r3, #82
 6843 3cf8 0100A0E3 		mov	r0, #1
 6844 3cfc FEFFFFEB 		bl	SensorSetIrisControl
3972:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6845              		.loc 1 3972 0
 6846 3d00 7D0FA0E3 		mov	r0, #500
 6847 3d04 FEFFFFEB 		bl	_tx_thread_sleep
3973:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6848              		.loc 1 3973 0
 6849 3d08 D8C094E5 		ldr	ip, [r4, #216]
 6850 3d0c 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 6851 3d10 00005CE3 		cmp	ip, #0
 6852 3d14 F4C0A003 		moveq	ip, #244
 6853 3d18 74C0A013 		movne	ip, #116
 6854 3d1c D83094E5 		ldr	r3, [r4, #216]
 6855 3d20 0400A0E3 		mov	r0, #4
 6856 3d24 A8149FE5 		ldr	r1, .L640+124
 6857 3d28 02208CE1 		orr	r2, ip, r2
 6858 3d2c FEFFFFEB 		bl	CyU3PDebugPrint
 6859              	.L510:
3978:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6860              		.loc 1 3978 0
 6861 3d30 8331D4E5 		ldrb	r3, [r4, #387]	@ zero_extendqisi2
3979:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6862              		.loc 1 3979 0
 6863 3d34 9C149FE5 		ldr	r1, .L640+128
 6864 3d38 0320A0E1 		mov	r2, r3
 6865 3d3c 0400A0E3 		mov	r0, #4
3978:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6866              		.loc 1 3978 0
 6867 3d40 7D31C4E5 		strb	r3, [r4, #381]
3979:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6868              		.loc 1 3979 0
 6869 3d44 FEFFFFEB 		bl	CyU3PDebugPrint
3992:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6870              		.loc 1 3992 0
 6871 3d48 0020A0E3 		mov	r2, #0
 6872 3d4c 04049FE5 		ldr	r0, .L640
 6873 3d50 0110A0E3 		mov	r1, #1
 6874 3d54 FEFFFFEB 		bl	_txe_event_flags_set
 6875              	.LVL583:
3993:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6876              		.loc 1 3993 0
 6877 3d58 002050E2 		subs	r2, r0, #0
 6878 3d5c 5AFDFF0A 		beq	.L616
3995:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6879              		.loc 1 3995 0
 6880 3d60 0400A0E3 		mov	r0, #4
 6881              	.LVL584:
 6882 3d64 70149FE5 		ldr	r1, .L640+132
 6883 3d68 FEFFFFEB 		bl	CyU3PDebugPrint
 6884              	.LVL585:
 6885 3d6c 28309DE5 		ldr	r3, [sp, #40]
 6886 3d70 56FDFFEA 		b	.L486
 6887              	.L511:
3956:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6888              		.loc 1 3956 0
 6889 3d74 D82094E5 		ldr	r2, [r4, #216]
 6890 3d78 3010A0E3 		mov	r1, #48
 6891 3d7c 000052E3 		cmp	r2, #0
 6892 3d80 E420A003 		moveq	r2, #228
 6893 3d84 6420A013 		movne	r2, #100
 6894 3d88 5230A0E3 		mov	r3, #82
 6895 3d8c 0100A0E3 		mov	r0, #1
 6896 3d90 FEFFFFEB 		bl	SensorSetIrisControl
3957:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6897              		.loc 1 3957 0
 6898 3d94 7D0FA0E3 		mov	r0, #500
 6899 3d98 FEFFFFEB 		bl	_tx_thread_sleep
3958:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6900              		.loc 1 3958 0
 6901 3d9c D82094E5 		ldr	r2, [r4, #216]
 6902 3da0 2C149FE5 		ldr	r1, .L640+124
 6903 3da4 000052E3 		cmp	r2, #0
 6904 3da8 D83094E5 		ldr	r3, [r4, #216]
 6905 3dac E420A003 		moveq	r2, #228
 6906 3db0 6420A013 		movne	r2, #100
 6907 3db4 0400A0E3 		mov	r0, #4
 6908 3db8 FEFFFFEB 		bl	CyU3PDebugPrint
 6909 3dbc DBFFFFEA 		b	.L510
 6910              	.L513:
3966:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6911              		.loc 1 3966 0
 6912 3dc0 BC639FE5 		ldr	r6, .L640+44
 6913 3dc4 D8C094E5 		ldr	ip, [r4, #216]
 6914 3dc8 8D34D6E5 		ldrb	r3, [r6, #1165]	@ zero_extendqisi2
 6915 3dcc 00005CE3 		cmp	ip, #0
 6916 3dd0 C4C0A003 		moveq	ip, #196
 6917 3dd4 44C0A013 		movne	ip, #68
 6918 3dd8 03208CE1 		orr	r2, ip, r3
 6919 3ddc 3010A0E3 		mov	r1, #48
 6920 3de0 5230A0E3 		mov	r3, #82
 6921 3de4 0100A0E3 		mov	r0, #1
 6922 3de8 FEFFFFEB 		bl	SensorSetIrisControl
3967:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6923              		.loc 1 3967 0
 6924 3dec 7D0FA0E3 		mov	r0, #500
 6925 3df0 FEFFFFEB 		bl	_tx_thread_sleep
3968:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6926              		.loc 1 3968 0
 6927 3df4 D82094E5 		ldr	r2, [r4, #216]
 6928 3df8 8D64D6E5 		ldrb	r6, [r6, #1165]	@ zero_extendqisi2
 6929 3dfc 000052E3 		cmp	r2, #0
 6930 3e00 C420A003 		moveq	r2, #196
 6931 3e04 4420A013 		movne	r2, #68
 6932 3e08 D83094E5 		ldr	r3, [r4, #216]
 6933 3e0c C0139FE5 		ldr	r1, .L640+124
 6934 3e10 062082E1 		orr	r2, r2, r6
 6935 3e14 0400A0E3 		mov	r0, #4
 6936 3e18 FEFFFFEB 		bl	CyU3PDebugPrint
 6937 3e1c C3FFFFEA 		b	.L510
 6938              	.L512:
3961:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6939              		.loc 1 3961 0
 6940 3e20 D82094E5 		ldr	r2, [r4, #216]
 6941 3e24 3010A0E3 		mov	r1, #48
 6942 3e28 000052E3 		cmp	r2, #0
 6943 3e2c D420A003 		moveq	r2, #212
 6944 3e30 5420A013 		movne	r2, #84
 6945 3e34 5230A0E3 		mov	r3, #82
 6946 3e38 0100A0E3 		mov	r0, #1
 6947 3e3c FEFFFFEB 		bl	SensorSetIrisControl
3962:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6948              		.loc 1 3962 0
 6949 3e40 7D0FA0E3 		mov	r0, #500
 6950 3e44 FEFFFFEB 		bl	_tx_thread_sleep
3963:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6951              		.loc 1 3963 0
 6952 3e48 D82094E5 		ldr	r2, [r4, #216]
 6953 3e4c 80139FE5 		ldr	r1, .L640+124
 6954 3e50 000052E3 		cmp	r2, #0
 6955 3e54 D83094E5 		ldr	r3, [r4, #216]
 6956 3e58 D420A003 		moveq	r2, #212
 6957 3e5c 5420A013 		movne	r2, #84
 6958 3e60 0400A0E3 		mov	r0, #4
 6959 3e64 FEFFFFEB 		bl	CyU3PDebugPrint
 6960 3e68 B0FFFFEA 		b	.L510
 6961              	.LVL586:
 6962              	.L489:
3832:../uvc.c      ****             switch (bRequest)
 6963              		.loc 1 3832 0
 6964 3e6c 08639FE5 		ldr	r6, .L640+36
 6965 3e70 0020D6E5 		ldrb	r2, [r6, #0]	@ zero_extendqisi2
 6966 3e74 830052E3 		cmp	r2, #131
 6967 3e78 4200008A 		bhi	.L500
 6968 3e7c 810052E3 		cmp	r2, #129
 6969 3e80 4400002A 		bcs	.L497
 6970 3e84 010052E3 		cmp	r2, #1
 6971 3e88 04FFFF1A 		bne	.L532
3859:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6972              		.loc 1 3859 0
 6973 3e8c 2000A0E3 		mov	r0, #32
 6974 3e90 10139FE5 		ldr	r1, .L640+80
 6975 3e94 2E208DE2 		add	r2, sp, #46
 6976 3e98 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6977              	.LVL587:
3861:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6978              		.loc 1 3861 0
 6979 3e9c 000050E3 		cmp	r0, #0
 6980 3ea0 09FDFF1A 		bne	.L616
3863:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6981              		.loc 1 3863 0
 6982 3ea4 C860D5E5 		ldrb	r6, [r5, #200]	@ zero_extendqisi2
 6983 3ea8 030056E3 		cmp	r6, #3
 6984 3eac 06FDFF1A 		bne	.L616
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6985              		.loc 1 3867 0
 6986 3eb0 CC329FE5 		ldr	r3, .L640+44
 6987 3eb4 8261D4E5 		ldrb	r6, [r4, #386]	@ zero_extendqisi2
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6988              		.loc 1 3868 0
 6989 3eb8 83E1D4E5 		ldrb	lr, [r4, #387]	@ zero_extendqisi2
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6990              		.loc 1 3869 0
 6991 3ebc 84C1D4E5 		ldrb	ip, [r4, #388]	@ zero_extendqisi2
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6992              		.loc 1 3870 0
 6993 3ec0 8501D4E5 		ldrb	r0, [r4, #389]	@ zero_extendqisi2
 6994              	.LVL588:
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6995              		.loc 1 3871 0
 6996 3ec4 8611D4E5 		ldrb	r1, [r4, #390]	@ zero_extendqisi2
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6997              		.loc 1 3872 0
 6998 3ec8 8721D4E5 		ldrb	r2, [r4, #391]	@ zero_extendqisi2
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6999              		.loc 1 3867 0
 7000 3ecc A266C3E5 		strb	r6, [r3, #1698]
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 7001              		.loc 1 3868 0
 7002 3ed0 A3E6C3E5 		strb	lr, [r3, #1699]
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 7003              		.loc 1 3869 0
 7004 3ed4 A4C6C3E5 		strb	ip, [r3, #1700]
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 7005              		.loc 1 3870 0
 7006 3ed8 A506C3E5 		strb	r0, [r3, #1701]
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 7007              		.loc 1 3871 0
 7008 3edc A616C3E5 		strb	r1, [r3, #1702]
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 7009              		.loc 1 3872 0
 7010 3ee0 A726C3E5 		strb	r2, [r3, #1703]
 7011 3ee4 28309DE5 		ldr	r3, [sp, #40]
 7012 3ee8 F8FCFFEA 		b	.L486
 7013              	.LVL589:
 7014              	.L491:
4008:../uvc.c      ****                 switch (bRequest)
 7015              		.loc 1 4008 0
 7016 3eec 88229FE5 		ldr	r2, .L640+36
 7017 3ef0 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 7018 3ef4 830052E3 		cmp	r2, #131
 7019 3ef8 25FFFF8A 		bhi	.L529
 7020 3efc 810052E3 		cmp	r2, #129
 7021 3f00 01FFFF2A 		bcs	.L534
 7022 3f04 010052E3 		cmp	r2, #1
 7023 3f08 E4FEFF1A 		bne	.L532
4033:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 7024              		.loc 1 4033 0
 7025 3f0c 2000A0E3 		mov	r0, #32
 7026 3f10 90129FE5 		ldr	r1, .L640+80
 7027 3f14 2E208DE2 		add	r2, sp, #46
 7028 3f18 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 7029              	.LVL590:
4035:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 7030              		.loc 1 4035 0
 7031 3f1c 000050E3 		cmp	r0, #0
 7032 3f20 E9FCFF1A 		bne	.L616
4037:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 7033              		.loc 1 4037 0
 7034 3f24 C810D5E5 		ldrb	r1, [r5, #200]	@ zero_extendqisi2
 7035 3f28 030051E3 		cmp	r1, #3
 7036 3f2c 0C00001A 		bne	.L531
4041:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 7037              		.loc 1 4041 0
 7038 3f30 4C329FE5 		ldr	r3, .L640+44
 7039 3f34 8161D5E5 		ldrb	r6, [r5, #385]	@ zero_extendqisi2
4042:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 7040              		.loc 1 4042 0
 7041 3f38 82E1D5E5 		ldrb	lr, [r5, #386]	@ zero_extendqisi2
4043:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 7042              		.loc 1 4043 0
 7043 3f3c 83C1D5E5 		ldrb	ip, [r5, #387]	@ zero_extendqisi2
4044:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 7044              		.loc 1 4044 0
 7045 3f40 8401D5E5 		ldrb	r0, [r5, #388]	@ zero_extendqisi2
 7046              	.LVL591:
4045:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 7047              		.loc 1 4045 0
 7048 3f44 8511D5E5 		ldrb	r1, [r5, #389]	@ zero_extendqisi2
4046:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 7049              		.loc 1 4046 0
 7050 3f48 8621D5E5 		ldrb	r2, [r5, #390]	@ zero_extendqisi2
4041:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 7051              		.loc 1 4041 0
 7052 3f4c F566C3E5 		strb	r6, [r3, #1781]
4042:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 7053              		.loc 1 4042 0
 7054 3f50 F6E6C3E5 		strb	lr, [r3, #1782]
4043:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 7055              		.loc 1 4043 0
 7056 3f54 F7C6C3E5 		strb	ip, [r3, #1783]
4044:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 7057              		.loc 1 4044 0
 7058 3f58 F806C3E5 		strb	r0, [r3, #1784]
4045:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 7059              		.loc 1 4045 0
 7060 3f5c F916C3E5 		strb	r1, [r3, #1785]
4046:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 7061              		.loc 1 4046 0
 7062 3f60 FA26C3E5 		strb	r2, [r3, #1786]
 7063              	.L531:
4048:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 7064              		.loc 1 4048 0
 7065 3f64 81C1D4E5 		ldrb	ip, [r4, #385]	@ zero_extendqisi2
 7066 3f68 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 7067 3f6c BE22DDE1 		ldrh	r2, [sp, #46]
 7068              	.LVL592:
 7069 3f70 0400A0E3 		mov	r0, #4
 7070 3f74 64129FE5 		ldr	r1, .L640+136
 7071 3f78 00C08DE5 		str	ip, [sp, #0]
 7072 3f7c FEFFFFEB 		bl	CyU3PDebugPrint
 7073 3f80 28309DE5 		ldr	r3, [sp, #40]
 7074 3f84 D1FCFFEA 		b	.L486
 7075              	.LVL593:
 7076              	.L500:
3832:../uvc.c      ****             switch (bRequest)
 7077              		.loc 1 3832 0
 7078 3f88 860052E3 		cmp	r2, #134
 7079 3f8c DCFEFF0A 		beq	.L620
 7080 3f90 870052E3 		cmp	r2, #135
 7081 3f94 02FFFF1A 		bne	.L625
 7082              	.L497:
3847:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 7083              		.loc 1 3847 0
 7084 3f98 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
 7085 3f9c 030053E3 		cmp	r3, #3
 7086 3fa0 A5FEFF1A 		bne	.L559
3849:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 7087              		.loc 1 3849 0
 7088 3fa4 38129FE5 		ldr	r1, .L640+140
 7089 3fa8 1A00A0E3 		mov	r0, #26
 7090 3fac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3850:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 7091              		.loc 1 3850 0
 7092 3fb0 0400A0E3 		mov	r0, #4
 7093 3fb4 2C129FE5 		ldr	r1, .L640+144
 7094 3fb8 0020D6E5 		ldrb	r2, [r6, #0]	@ zero_extendqisi2
 7095 3fbc FEFFFFEB 		bl	CyU3PDebugPrint
 7096 3fc0 28309DE5 		ldr	r3, [sp, #40]
 7097 3fc4 C1FCFFEA 		b	.L486
 7098              	.LVL594:
 7099              	.L418:
 7100              	.LBE120:
 7101              	.LBE154:
4509:../uvc.c      **** }
 7102              		.loc 1 4509 0
 7103 3fc8 30D08DE2 		add	sp, sp, #48
 7104 3fcc F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 7105              	.L453:
 7106              	.LVL595:
 7107              	.LBB155:
 7108              	.LBB128:
3547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 7109              		.loc 1 3547 0
 7110 3fd0 0A00A0E3 		mov	r0, #10
 7111 3fd4 FEFFFFEB 		bl	CTControlHandle
 7112              	.LVL596:
 7113 3fd8 28309DE5 		ldr	r3, [sp, #40]
 7114 3fdc B0FCFFEA 		b	.L421
 7115              	.L452:
 7116              	.LVL597:
3543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 7117              		.loc 1 3543 0
 7118 3fe0 0900A0E3 		mov	r0, #9
 7119 3fe4 FEFFFFEB 		bl	CTControlHandle
 7120              	.LVL598:
 7121 3fe8 28309DE5 		ldr	r3, [sp, #40]
 7122 3fec ACFCFFEA 		b	.L421
 7123              	.L438:
 7124              	.LVL599:
 7125              	.LBE128:
 7126              	.LBE155:
 7127              	.LBB156:
 7128              	.LBB135:
3468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 7129              		.loc 1 3468 0
 7130 3ff0 0E00A0E3 		mov	r0, #14
 7131 3ff4 FEFFFFEB 		bl	ControlHandle
 7132              	.LVL600:
 7133 3ff8 28309DE5 		ldr	r3, [sp, #40]
 7134 3ffc A8FCFFEA 		b	.L421
 7135              	.L449:
 7136              	.LVL601:
 7137              	.LBE135:
 7138              	.LBE156:
 7139              	.LBB157:
 7140              	.LBB124:
3528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 7141              		.loc 1 3528 0
 7142 4000 0600A0E3 		mov	r0, #6
 7143 4004 FEFFFFEB 		bl	CTControlHandle
 7144              	.LVL602:
 7145 4008 28309DE5 		ldr	r3, [sp, #40]
 7146 400c A4FCFFEA 		b	.L421
 7147              	.L450:
 7148              	.LVL603:
3534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 7149              		.loc 1 3534 0
 7150 4010 0700A0E3 		mov	r0, #7
 7151 4014 FEFFFFEB 		bl	CTControlHandle
 7152              	.LVL604:
 7153 4018 28309DE5 		ldr	r3, [sp, #40]
 7154 401c A0FCFFEA 		b	.L421
 7155              	.L446:
 7156              	.LVL605:
3515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 7157              		.loc 1 3515 0
 7158 4020 0300A0E3 		mov	r0, #3
 7159 4024 FEFFFFEB 		bl	CTControlHandle
 7160              	.LVL606:
 7161 4028 28309DE5 		ldr	r3, [sp, #40]
 7162 402c 9CFCFFEA 		b	.L421
 7163              	.L434:
 7164              	.LVL607:
 7165              	.LBE124:
 7166              	.LBE157:
 7167              	.LBB158:
 7168              	.LBB131:
3450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 7169              		.loc 1 3450 0
 7170 4030 0600A0E3 		mov	r0, #6
 7171 4034 FEFFFFEB 		bl	ControlHandle
 7172              	.LVL608:
 7173 4038 28309DE5 		ldr	r3, [sp, #40]
 7174 403c 98FCFFEA 		b	.L421
 7175              	.L436:
 7176              	.LVL609:
3460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 7177              		.loc 1 3460 0
 7178 4040 0900A0E3 		mov	r0, #9
 7179 4044 FEFFFFEB 		bl	ControlHandle
 7180              	.LVL610:
 7181 4048 28309DE5 		ldr	r3, [sp, #40]
 7182 404c 94FCFFEA 		b	.L421
 7183              	.L477:
 7184              	.LVL611:
 7185              	.LBE131:
 7186              	.LBE158:
 7187              	.LBB159:
 7188              	.LBB102:
3801:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 7189              		.loc 1 3801 0
 7190 4050 2400A0E3 		mov	r0, #36
 7191 4054 FEFFFFEB 		bl	ControlHandle
 7192              	.LVL612:
 7193 4058 28309DE5 		ldr	r3, [sp, #40]
 7194 405c 90FCFFEA 		b	.L421
 7195              	.L473:
 7196              	.LVL613:
3779:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 7197              		.loc 1 3779 0
 7198 4060 1B00A0E3 		mov	r0, #27
 7199 4064 FEFFFFEB 		bl	ControlHandle
 7200              	.LVL614:
 7201 4068 28309DE5 		ldr	r3, [sp, #40]
 7202 406c 8CFCFFEA 		b	.L421
 7203              	.L468:
 7204              	.LVL615:
3756:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 7205              		.loc 1 3756 0
 7206 4070 1600A0E3 		mov	r0, #22
 7207 4074 FEFFFFEB 		bl	ControlHandle
 7208              	.LVL616:
 7209 4078 28309DE5 		ldr	r3, [sp, #40]
 7210 407c 88FCFFEA 		b	.L421
 7211              	.L472:
 7212              	.LVL617:
3775:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 7213              		.loc 1 3775 0
 7214 4080 1A00A0E3 		mov	r0, #26
 7215 4084 FEFFFFEB 		bl	ControlHandle
 7216              	.LVL618:
 7217 4088 28309DE5 		ldr	r3, [sp, #40]
 7218 408c 84FCFFEA 		b	.L421
 7219              	.L475:
 7220              	.LVL619:
3793:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 7221              		.loc 1 3793 0
 7222 4090 1E00A0E3 		mov	r0, #30
 7223 4094 FEFFFFEB 		bl	ControlHandle
 7224              	.LVL620:
 7225 4098 28309DE5 		ldr	r3, [sp, #40]
 7226 409c 80FCFFEA 		b	.L421
 7227              	.L467:
 7228              	.LVL621:
3752:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 7229              		.loc 1 3752 0
 7230 40a0 1500A0E3 		mov	r0, #21
 7231 40a4 FEFFFFEB 		bl	ControlHandle
 7232              	.LVL622:
 7233 40a8 28309DE5 		ldr	r3, [sp, #40]
 7234 40ac 7CFCFFEA 		b	.L421
 7235              	.LVL623:
 7236              	.L635:
 7237              	.LBE102:
 7238              	.LBE159:
4404:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 7239              		.loc 1 4404 0
 7240 40b0 0400A0E3 		mov	r0, #4
 7241              	.LVL624:
 7242 40b4 30119FE5 		ldr	r1, .L640+148
 7243 40b8 FEFFFFEB 		bl	CyU3PDebugPrint
 7244              	.LVL625:
 7245              	.L568:
 7246              	.LBB160:
 7247              	.LBB161:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7248              		.loc 1 2061 0
 7249 40bc 2C119FE5 		ldr	r1, .L640+152
 7250 40c0 0400A0E3 		mov	r0, #4
 7251 40c4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7252              		.loc 1 2062 0
 7253 40c8 FA0FA0E3 		mov	r0, #1000
 7254 40cc FEFFFFEB 		bl	_tx_thread_sleep
 7255 40d0 F9FFFFEA 		b	.L568
 7256              	.L634:
 7257              	.LBE161:
 7258              	.LBE160:
4358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 7259              		.loc 1 4358 0
 7260 40d4 AC309FE5 		ldr	r3, .L640+48
 7261 40d8 02C0A0E3 		mov	ip, #2
 7262 40dc 002093E5 		ldr	r2, [r3, #0]
4359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7263              		.loc 1 4359 0
 7264 40e0 0160A0E3 		mov	r6, #1
4358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 7265              		.loc 1 4358 0
 7266 40e4 00C0C2E5 		strb	ip, [r2, #0]
4359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7267              		.loc 1 4359 0
 7268 40e8 001093E5 		ldr	r1, [r3, #0]
4360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7269              		.loc 1 4360 0
 7270 40ec 0020A0E3 		mov	r2, #0
4359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7271              		.loc 1 4359 0
 7272 40f0 0160C1E5 		strb	r6, [r1, #1]
4360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7273              		.loc 1 4360 0
 7274 40f4 000093E5 		ldr	r0, [r3, #0]
4364:../uvc.c      **** 					interStabuf.size   = 1024;
 7275              		.loc 1 4364 0
 7276 40f8 01CBA0E3 		mov	ip, #1024	@ movhi
4360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7277              		.loc 1 4360 0
 7278 40fc 0220C0E5 		strb	r2, [r0, #2]
4361:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7279              		.loc 1 4361 0
 7280 4100 00E093E5 		ldr	lr, [r3, #0]
4370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7281              		.loc 1 4370 0
 7282 4104 0010E0E3 		mvn	r1, #0
4361:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7283              		.loc 1 4361 0
 7284 4108 0320CEE5 		strb	r2, [lr, #3]
4363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 7285              		.loc 1 4363 0
 7286 410c 00E093E5 		ldr	lr, [r3, #0]
4370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7287              		.loc 1 4370 0
 7288 4110 74009FE5 		ldr	r0, .L640+52
4367:../uvc.c      **** 					interStabuf.count = 4;
 7289              		.loc 1 4367 0
 7290 4114 0430A0E3 		mov	r3, #4	@ movhi
4365:../uvc.c      **** 					interStabuf.status = 0;
 7291              		.loc 1 4365 0
 7292 4118 B021CDE1 		strh	r2, [sp, #16]	@ movhi
4364:../uvc.c      **** 					interStabuf.size   = 1024;
 7293              		.loc 1 4364 0
 7294 411c BEC0CDE1 		strh	ip, [sp, #14]	@ movhi
4363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 7295              		.loc 1 4363 0
 7296 4120 08E08DE5 		str	lr, [sp, #8]
4367:../uvc.c      **** 					interStabuf.count = 4;
 7297              		.loc 1 4367 0
 7298 4124 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
4370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7299              		.loc 1 4370 0
 7300 4128 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4373:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 7301              		.loc 1 4373 0
 7302 412c 58009FE5 		ldr	r0, .L640+52
 7303 4130 08108DE2 		add	r1, sp, #8
 7304 4134 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7305              	.LVL626:
4375:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 7306              		.loc 1 4375 0
 7307 4138 002050E2 		subs	r2, r0, #0
 7308 413c 2C00001A 		bne	.L639
4380:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 7309              		.loc 1 4380 0
 7310 4140 0500A0E3 		mov	r0, #5
 7311              	.LVL627:
 7312 4144 3010A0E3 		mov	r1, #48
 7313 4148 FEFFFFEB 		bl	SensorSetControl
 7314              	.LVL628:
4382:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 7315              		.loc 1 4382 0
 7316 414c 0B67C8E5 		strb	r6, [r8, #1803]
 7317 4150 28309DE5 		ldr	r3, [sp, #40]
 7318 4154 5FFCFFEA 		b	.L563
 7319              	.L641:
 7320              		.align	2
 7321              	.L640:
 7322 4158 00000000 		.word	.LANCHOR0
 7323 415c 00000000 		.word	glDebugRspBuffer
 7324 4160 00000000 		.word	wIndex
 7325 4164 00000000 		.word	wValue
 7326 4168 00000000 		.word	glDebugCmdChannel
 7327 416c 54080000 		.word	.LC48
 7328 4170 80080000 		.word	.LC49
 7329 4174 00000000 		.word	glDebugRspChannel
 7330 4178 2C090000 		.word	.LC53
 7331 417c 00000000 		.word	bRequest
 7332 4180 5C060000 		.word	.LC36
 7333 4184 00000000 		.word	.LANCHOR1
 7334 4188 00000000 		.word	glInterStaBuffer
 7335 418c 00000000 		.word	glChHandleInterStat
 7336 4190 F0080000 		.word	.LC52
 7337 4194 C8080000 		.word	.LC51
 7338 4198 20080000 		.word	.LC47
 7339 419c A8080000 		.word	.LC50
 7340 41a0 E0010000 		.word	.LC11
 7341 41a4 00000000 		.word	glChHandleUVCStream
 7342 41a8 80010000 		.word	.LANCHOR0+384
 7343 41ac 74070000 		.word	.LC43
 7344 41b0 98070000 		.word	.LC44
 7345 41b4 C4070000 		.word	.LC45
 7346 41b8 1C010000 		.word	.LANCHOR0+284
 7347 41bc BC060000 		.word	.LANCHOR1+1724
 7348 41c0 D8060000 		.word	.LANCHOR1+1752
 7349 41c4 F4060000 		.word	.LANCHOR1+1780
 7350 41c8 00070000 		.word	.LANCHOR1+1792
 7351 41cc 28070000 		.word	.LC41
 7352 41d0 4C070000 		.word	.LC42
 7353 41d4 B0060000 		.word	.LC38
 7354 41d8 D4060000 		.word	.LC39
 7355 41dc EC020000 		.word	.LC18
 7356 41e0 FC060000 		.word	.LC40
 7357 41e4 A0060000 		.word	.LANCHOR1+1696
 7358 41e8 88060000 		.word	.LC37
 7359 41ec EC070000 		.word	.LC46
 7360 41f0 4C020000 		.word	.LC14
 7361              	.LVL629:
 7362              	.L639:
4377:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 7363              		.loc 1 4377 0
 7364 41f4 0400A0E3 		mov	r0, #4
 7365              	.LVL630:
 7366 41f8 14101FE5 		ldr	r1, .L640+148
 7367 41fc FEFFFFEB 		bl	CyU3PDebugPrint
 7368              	.LVL631:
 7369              	.L566:
 7370              	.LBB162:
 7371              	.LBB163:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7372              		.loc 1 2061 0
 7373 4200 18101FE5 		ldr	r1, .L640+152
 7374 4204 0400A0E3 		mov	r0, #4
 7375 4208 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7376              		.loc 1 2062 0
 7377 420c FA0FA0E3 		mov	r0, #1000
 7378 4210 FEFFFFEB 		bl	_tx_thread_sleep
 7379 4214 F9FFFFEA 		b	.L566
 7380              	.L429:
 7381              	.LVL632:
 7382              	.LBE163:
 7383              	.LBE162:
 7384              	.LBB164:
 7385              	.LBB136:
3427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 7386              		.loc 1 3427 0
 7387 4218 0000A0E3 		mov	r0, #0
 7388 421c FEFFFFEB 		bl	ControlHandle
 7389              	.LVL633:
 7390 4220 28309DE5 		ldr	r3, [sp, #40]
 7391 4224 1EFCFFEA 		b	.L421
 7392              	.L431:
 7393              	.LVL634:
3435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 7394              		.loc 1 3435 0
 7395 4228 0200A0E3 		mov	r0, #2
 7396 422c FEFFFFEB 		bl	ControlHandle
 7397              	.LVL635:
 7398 4230 28309DE5 		ldr	r3, [sp, #40]
 7399 4234 1AFCFFEA 		b	.L421
 7400              	.L433:
 7401              	.LVL636:
3446:../uvc.c      ****      		ControlHandle(HueCtlID5);
 7402              		.loc 1 3446 0
 7403 4238 0500A0E3 		mov	r0, #5
 7404 423c FEFFFFEB 		bl	ControlHandle
 7405              	.LVL637:
 7406 4240 28309DE5 		ldr	r3, [sp, #40]
 7407 4244 16FCFFEA 		b	.L421
 7408              	.L633:
 7409              	.LVL638:
 7410              	.LBE136:
 7411              	.LBE164:
 7412              	.LBB165:
 7413              	.LBB129:
3506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 7414              		.loc 1 3506 0
 7415 4248 0100A0E3 		mov	r0, #1
 7416 424c FEFFFFEB 		bl	CTControlHandle
 7417              	.LVL639:
 7418 4250 28309DE5 		ldr	r3, [sp, #40]
 7419 4254 12FCFFEA 		b	.L421
 7420              	.L443:
 7421              	.LVL640:
3502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 7422              		.loc 1 3502 0
 7423 4258 0000A0E3 		mov	r0, #0
 7424 425c FEFFFFEB 		bl	CTControlHandle
 7425              	.LVL641:
 7426 4260 28309DE5 		ldr	r3, [sp, #40]
 7427 4264 0EFCFFEA 		b	.L421
 7428              	.L445:
 7429              	.LVL642:
3510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 7430              		.loc 1 3510 0
 7431 4268 0200A0E3 		mov	r0, #2
 7432 426c FEFFFFEB 		bl	CTControlHandle
 7433              	.LVL643:
 7434 4270 28309DE5 		ldr	r3, [sp, #40]
 7435 4274 0AFCFFEA 		b	.L421
 7436              	.L448:
 7437              	.LVL644:
3524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 7438              		.loc 1 3524 0
 7439 4278 0500A0E3 		mov	r0, #5
 7440 427c FEFFFFEB 		bl	CTControlHandle
 7441              	.LVL645:
 7442 4280 28309DE5 		ldr	r3, [sp, #40]
 7443 4284 06FCFFEA 		b	.L421
 7444              	.LVL646:
 7445              	.L630:
 7446              	.LBE129:
 7447              	.LBE165:
4445:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
 7448              		.loc 1 4445 0
 7449 4288 0330DCE5 		ldrb	r3, [ip, #3]	@ zero_extendqisi2
 7450 428c 000053E3 		cmp	r3, #0
 7451 4290 0A00000A 		beq	.L574
4447:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
 7452              		.loc 1 4447 0
 7453 4294 006097E5 		ldr	r6, [r7, #0]
 7454              	.LVL647:
 7455 4298 8330A0E1 		mov	r3, r3, asl #1
 7456 429c 0110DCE5 		ldrb	r1, [ip, #1]	@ zero_extendqisi2
 7457 42a0 0220DCE5 		ldrb	r2, [ip, #2]	@ zero_extendqisi2
 7458 42a4 7100A0E3 		mov	r0, #113
 7459 42a8 01C086E2 		add	ip, r6, #1
 7460 42ac FE3003E2 		and	r3, r3, #254
 7461 42b0 00C08DE5 		str	ip, [sp, #0]
 7462 42b4 FEFFFFEB 		bl	SensorRead
 7463 42b8 0000C6E5 		strb	r0, [r6, #0]
 7464 42bc 14C09DE5 		ldr	ip, [sp, #20]
 7465              	.L574:
4450:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
 7466              		.loc 1 4450 0
 7467 42c0 03E0DCE5 		ldrb	lr, [ip, #3]	@ zero_extendqisi2
 7468 42c4 8E20A0E1 		mov	r2, lr, asl #1
 7469 42c8 011082E2 		add	r1, r2, #1
 7470 42cc 0120A0E1 		mov	r2, r1
 7471 42d0 B811CDE1 		strh	r1, [sp, #24]	@ movhi
 7472 42d4 1BFCFFEA 		b	.L573
 7473              	.L627:
 7474              	.LVL648:
 7475              	.LBB166:
 7476              	.LBB108:
3732:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 7477              		.loc 1 3732 0
 7478 42d8 1000A0E3 		mov	r0, #16
 7479 42dc FEFFFFEB 		bl	ControlHandle
 7480              	.LVL649:
 7481 42e0 28309DE5 		ldr	r3, [sp, #40]
 7482 42e4 EEFBFFEA 		b	.L421
 7483              	.L464:
 7484              	.LVL650:
3740:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 7485              		.loc 1 3740 0
 7486 42e8 1200A0E3 		mov	r0, #18
 7487 42ec FEFFFFEB 		bl	ControlHandle
 7488              	.LVL651:
 7489 42f0 28309DE5 		ldr	r3, [sp, #40]
 7490 42f4 EAFBFFEA 		b	.L421
 7491              	.L463:
 7492              	.LVL652:
3736:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 7493              		.loc 1 3736 0
 7494 42f8 1100A0E3 		mov	r0, #17
 7495 42fc FEFFFFEB 		bl	ControlHandle
 7496              	.LVL653:
 7497 4300 28309DE5 		ldr	r3, [sp, #40]
 7498 4304 E6FBFFEA 		b	.L421
 7499              	.L465:
 7500              	.LVL654:
3744:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 7501              		.loc 1 3744 0
 7502 4308 1300A0E3 		mov	r0, #19
 7503 430c FEFFFFEB 		bl	ControlHandle
 7504              	.LVL655:
 7505 4310 28309DE5 		ldr	r3, [sp, #40]
 7506 4314 E2FBFFEA 		b	.L421
 7507              	.LBE108:
 7508              	.LBE166:
 7509              		.cfi_endproc
 7510              	.LFE26:
 7512              		.align	2
 7513              		.global	CamDefSet
 7515              	CamDefSet:
 7516              	.LFB5:
1954:../uvc.c      **** {
 7517              		.loc 1 1954 0
 7518              		.cfi_startproc
 7519              		@ args = 0, pretend = 0, frame = 24
 7520              		@ frame_needed = 0, uses_anonymous_args = 0
 7521              	.LVL656:
 7522 4318 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7523              	.LCFI22:
 7524              		.cfi_def_cfa_offset 36
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7525              		.loc 1 1961 0
 7526 431c B0429FE5 		ldr	r4, .L645
 7527              		.cfi_offset 14, -4
 7528              		.cfi_offset 11, -8
 7529              		.cfi_offset 10, -12
 7530              		.cfi_offset 9, -16
 7531              		.cfi_offset 8, -20
 7532              		.cfi_offset 7, -24
 7533              		.cfi_offset 6, -28
 7534              		.cfi_offset 5, -32
 7535              		.cfi_offset 4, -36
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7536              		.loc 1 1966 0
 7537 4320 B0229FE5 		ldr	r2, .L645+4
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 7538              		.loc 1 1963 0
 7539 4324 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1954:../uvc.c      **** {
 7540              		.loc 1 1954 0
 7541 4328 2CD04DE2 		sub	sp, sp, #44
 7542              	.LCFI23:
 7543              		.cfi_def_cfa_offset 80
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7544              		.loc 1 1966 0
 7545 432c 1C0092E5 		ldr	r0, [r2, #28]
 7546 4330 0010E0E3 		mvn	r1, #0
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7547              		.loc 1 1968 0
 7548 4334 2963A0E1 		mov	r6, r9, lsr #6
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7549              		.loc 1 1962 0
 7550 4338 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7551              		.loc 1 1961 0
 7552 433c 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 7553              	.LVL657:
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7554              		.loc 1 1966 0
 7555 4340 FEFFFFEB 		bl	_txe_mutex_get
1967:../uvc.c      ****     if(Data1&0x80){
 7556              		.loc 1 1967 0
 7557 4344 800019E3 		tst	r9, #128
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7558              		.loc 1 1968 0
 7559 4348 01600612 		andne	r6, r6, #1
 7560 434c 0660E011 		mvnne	r6, r6
 7561 4350 3B600612 		andne	r6, r6, #59
 7562 4354 0660E011 		mvnne	r6, r6
 7563 4358 FF600612 		andne	r6, r6, #255
 7564              	.LVL658:
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 7565              		.loc 1 1970 0
 7566 435c C6608603 		orreq	r6, r6, #198
 7567              	.LVL659:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7568              		.loc 1 1974 0
 7569 4360 0080A0E3 		mov	r8, #0
 7570 4364 0A20A0E1 		mov	r2, sl
 7571 4368 0730A0E1 		mov	r3, r7
 7572 436c 0110A0E3 		mov	r1, #1
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7573              		.loc 1 1972 0
 7574 4370 0951A0E1 		mov	r5, r9, asl #2
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7575              		.loc 1 1974 0
 7576 4374 5C029FE5 		ldr	r0, .L645+4
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7577              		.loc 1 1977 0
 7578 4378 0190A0E3 		mov	r9, #1
 7579              	.LVL660:
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7580              		.loc 1 1972 0
 7581 437c FF5005E2 		and	r5, r5, #255
 7582              	.LVL661:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7583              		.loc 1 1974 0
 7584 4380 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7585 4384 FEFFFFEB 		bl	cmdSet
 7586              	.LVL662:
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7587              		.loc 1 1977 0
 7588 4388 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 7589 438c 0910A0E1 		mov	r1, r9
 7590 4390 0730A0E1 		mov	r3, r7
 7591 4394 3C029FE5 		ldr	r0, .L645+4
 7592 4398 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 7593 439c FEFFFFEB 		bl	cmdSet
 7594              	.LVL663:
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7595              		.loc 1 1980 0
 7596 43a0 0620A0E1 		mov	r2, r6
 7597 43a4 0530A0E1 		mov	r3, r5
 7598 43a8 2C129FE5 		ldr	r1, .L645+8
 7599 43ac 0400A0E3 		mov	r0, #4
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 7600              		.loc 1 1979 0
 7601 43b0 A661C4E5 		strb	r6, [r4, #422]
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7602              		.loc 1 1978 0
 7603 43b4 A551C4E5 		strb	r5, [r4, #421]
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7604              		.loc 1 1980 0
 7605 43b8 FEFFFFEB 		bl	CyU3PDebugPrint
 7606              	.LVL664:
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7607              		.loc 1 1985 0
 7608 43bc BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 7609              	.LVL665:
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 7610              		.loc 1 1986 0
 7611 43c0 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 7612 43c4 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 7613 43c8 0210A0E3 		mov	r1, #2
 7614 43cc 04029FE5 		ldr	r0, .L645+4
 7615 43d0 00B08DE5 		str	fp, [sp, #0]
 7616 43d4 04808DE5 		str	r8, [sp, #4]
 7617 43d8 FEFFFFEB 		bl	cmdSet
 7618              	.LVL666:
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7619              		.loc 1 1989 0
 7620 43dc 0B20A0E1 		mov	r2, fp
 7621 43e0 0530A0E1 		mov	r3, r5
 7622 43e4 F0119FE5 		ldr	r1, .L645+8
 7623 43e8 0400A0E3 		mov	r0, #4
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7624              		.loc 1 1987 0
 7625 43ec BD51C4E5 		strb	r5, [r4, #445]
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 7626              		.loc 1 1988 0
 7627 43f0 FD53C4E5 		strb	r5, [r4, #1021]
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7628              		.loc 1 1989 0
 7629 43f4 FEFFFFEB 		bl	CyU3PDebugPrint
 7630              	.LVL667:
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7631              		.loc 1 1994 0
 7632 43f8 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7633              		.loc 1 1993 0
 7634 43fc 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 7635              	.LVL668:
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7636              		.loc 1 1995 0
 7637 4400 80B047E2 		sub	fp, r7, #128
 7638 4404 FF100BE2 		and	r1, fp, #255
 7639 4408 14108DE5 		str	r1, [sp, #20]
 7640 440c 14C09DE5 		ldr	ip, [sp, #20]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7641              		.loc 1 1996 0
 7642 4410 760047E2 		sub	r0, r7, #118
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7643              		.loc 1 1997 0
 7644 4414 7EE087E2 		add	lr, r7, #126
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7645              		.loc 1 1995 0
 7646 4418 0630A0E1 		mov	r3, r6
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7647              		.loc 1 1996 0
 7648 441c 18008DE5 		str	r0, [sp, #24]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7649              		.loc 1 1995 0
 7650 4420 0510A0E3 		mov	r1, #5
 7651 4424 DF20A0E3 		mov	r2, #223
 7652 4428 A8019FE5 		ldr	r0, .L645+4
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7653              		.loc 1 1997 0
 7654 442c 1CE08DE5 		str	lr, [sp, #28]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7655              		.loc 1 1995 0
 7656 4430 00C08DE5 		str	ip, [sp, #0]
 7657 4434 04808DE5 		str	r8, [sp, #4]
 7658 4438 FEFFFFEB 		bl	cmdSet
 7659              	.LVL669:
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7660              		.loc 1 1996 0
 7661 443c 18A09DE5 		ldr	sl, [sp, #24]
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7662              		.loc 1 1998 0
 7663 4440 72E087E2 		add	lr, r7, #114
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7664              		.loc 1 1996 0
 7665 4444 FFC00AE2 		and	ip, sl, #255
 7666 4448 0630A0E1 		mov	r3, r6
 7667 444c 0510A0E3 		mov	r1, #5
 7668 4450 DC20A0E3 		mov	r2, #220
 7669 4454 7C019FE5 		ldr	r0, .L645+4
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7670              		.loc 1 1998 0
 7671 4458 20E08DE5 		str	lr, [sp, #32]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7672              		.loc 1 1996 0
 7673 445c 00C08DE5 		str	ip, [sp, #0]
 7674 4460 04908DE5 		str	r9, [sp, #4]
 7675 4464 FEFFFFEB 		bl	cmdSet
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7676              		.loc 1 1997 0
 7677 4468 1C009DE5 		ldr	r0, [sp, #28]
 7678 446c 02E0A0E3 		mov	lr, #2
 7679 4470 FFC000E2 		and	ip, r0, #255
 7680 4474 0630A0E1 		mov	r3, r6
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7681              		.loc 1 1999 0
 7682 4478 6FA047E2 		sub	sl, r7, #111
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7683              		.loc 1 1997 0
 7684 447c 0510A0E3 		mov	r1, #5
 7685 4480 DE20A0E3 		mov	r2, #222
 7686 4484 4C019FE5 		ldr	r0, .L645+4
 7687 4488 04E08DE5 		str	lr, [sp, #4]
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7688              		.loc 1 1999 0
 7689 448c 24A08DE5 		str	sl, [sp, #36]
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7690              		.loc 1 1997 0
 7691 4490 00C08DE5 		str	ip, [sp, #0]
 7692 4494 FEFFFFEB 		bl	cmdSet
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7693              		.loc 1 1998 0
 7694 4498 20A09DE5 		ldr	sl, [sp, #32]
 7695 449c 0630A0E1 		mov	r3, r6
 7696 44a0 FFC00AE2 		and	ip, sl, #255
 7697 44a4 00C08DE5 		str	ip, [sp, #0]
 7698 44a8 0510A0E3 		mov	r1, #5
 7699 44ac 03C0A0E3 		mov	ip, #3
 7700 44b0 E020A0E3 		mov	r2, #224
 7701 44b4 1C019FE5 		ldr	r0, .L645+4
 7702 44b8 04C08DE5 		str	ip, [sp, #4]
 7703 44bc FEFFFFEB 		bl	cmdSet
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7704              		.loc 1 1999 0
 7705 44c0 24009DE5 		ldr	r0, [sp, #36]
 7706 44c4 04A0A0E3 		mov	sl, #4
 7707 44c8 FFC000E2 		and	ip, r0, #255
 7708 44cc 0630A0E1 		mov	r3, r6
 7709 44d0 0510A0E3 		mov	r1, #5
 7710 44d4 DD20A0E3 		mov	r2, #221
 7711 44d8 F8009FE5 		ldr	r0, .L645+4
 7712 44dc 00C08DE5 		str	ip, [sp, #0]
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7713              		.loc 1 2000 0
 7714 44e0 7F7087E2 		add	r7, r7, #127
 7715              	.LVL670:
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7716              		.loc 1 1999 0
 7717 44e4 04A08DE5 		str	sl, [sp, #4]
 7718 44e8 FEFFFFEB 		bl	cmdSet
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7719              		.loc 1 2000 0
 7720 44ec 05E0A0E3 		mov	lr, #5
 7721 44f0 0E10A0E1 		mov	r1, lr
 7722 44f4 0630A0E1 		mov	r3, r6
 7723 44f8 E120A0E3 		mov	r2, #225
 7724 44fc FF6007E2 		and	r6, r7, #255
 7725              	.LVL671:
 7726 4500 D0009FE5 		ldr	r0, .L645+4
 7727 4504 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7728 4508 FEFFFFEB 		bl	cmdSet
 7729              	.LVL672:
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7730              		.loc 1 2001 0
 7731 450c 14C09DE5 		ldr	ip, [sp, #20]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7732              		.loc 1 2002 0
 7733 4510 24E09DE5 		ldr	lr, [sp, #36]
 7734 4514 1C609DE5 		ldr	r6, [sp, #28]
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7735              		.loc 1 2001 0
 7736 4518 05C2C4E5 		strb	ip, [r4, #517]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7737              		.loc 1 2002 0
 7738 451c 20C09DE5 		ldr	ip, [sp, #32]
 7739 4520 0B20A0E1 		mov	r2, fp
 7740 4524 18309DE5 		ldr	r3, [sp, #24]
 7741 4528 B0109FE5 		ldr	r1, .L645+12
 7742 452c 0A00A0E1 		mov	r0, sl
 7743 4530 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7744 4534 0C708DE5 		str	r7, [sp, #12]
 7745 4538 FEFFFFEB 		bl	CyU3PDebugPrint
 7746              	.LVL673:
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7747              		.loc 1 2006 0
 7748 453c 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7749              	.LVL674:
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7750              		.loc 1 2007 0
 7751 4540 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7752              	.LVL675:
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7753              		.loc 1 2008 0
 7754 4544 0730A0E1 		mov	r3, r7
 7755 4548 0610A0E3 		mov	r1, #6
 7756 454c 8520A0E3 		mov	r2, #133
 7757 4550 80009FE5 		ldr	r0, .L645+4
 7758 4554 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7759 4558 FEFFFFEB 		bl	cmdSet
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7760              		.loc 1 2009 0
 7761 455c 0730A0E1 		mov	r3, r7
 7762 4560 0610A0E3 		mov	r1, #6
 7763 4564 8620A0E3 		mov	r2, #134
 7764 4568 68009FE5 		ldr	r0, .L645+4
 7765 456c 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7766 4570 FEFFFFEB 		bl	cmdSet
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7767              		.loc 1 2011 0
 7768 4574 0620A0E1 		mov	r2, r6
 7769 4578 0530A0E1 		mov	r3, r5
 7770 457c 58109FE5 		ldr	r1, .L645+8
 7771 4580 0A00A0E1 		mov	r0, sl
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7772              		.loc 1 2010 0
 7773 4584 1D62C4E5 		strb	r6, [r4, #541]
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7774              		.loc 1 2011 0
 7775 4588 FEFFFFEB 		bl	CyU3PDebugPrint
 7776              	.LVL676:
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7777              		.loc 1 2016 0
 7778 458c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7779              	.LVL677:
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7780              		.loc 1 2017 0
 7781 4590 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7782 4594 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7783 4598 0710A0E3 		mov	r1, #7
 7784 459c 34009FE5 		ldr	r0, .L645+4
 7785 45a0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7786 45a4 FEFFFFEB 		bl	cmdSet
 7787              	.LVL678:
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7788              		.loc 1 2019 0
 7789 45a8 0530A0E1 		mov	r3, r5
 7790 45ac 0A00A0E1 		mov	r0, sl
 7791 45b0 24109FE5 		ldr	r1, .L645+8
 7792 45b4 0620A0E1 		mov	r2, r6
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7793              		.loc 1 2018 0
 7794 45b8 3552C4E5 		strb	r5, [r4, #565]
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7795              		.loc 1 2019 0
 7796 45bc FEFFFFEB 		bl	CyU3PDebugPrint
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7797              		.loc 1 2021 0
 7798 45c0 10309FE5 		ldr	r3, .L645+4
 7799 45c4 1C0093E5 		ldr	r0, [r3, #28]
2024:../uvc.c      **** }
 7800              		.loc 1 2024 0
 7801 45c8 2CD08DE2 		add	sp, sp, #44
 7802 45cc F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7803              		.loc 1 2021 0
 7804 45d0 FEFFFFEA 		b	_txe_mutex_put
 7805              	.L646:
 7806              		.align	2
 7807              	.L645:
 7808 45d4 00000000 		.word	.LANCHOR1
 7809 45d8 00000000 		.word	statQu
 7810 45dc 60090000 		.word	.LC54
 7811 45e0 80090000 		.word	.LC55
 7812              		.cfi_endproc
 7813              	.LFE5:
 7815              		.align	2
 7816              		.global	CyFxUVCAddHeader
 7818              	CyFxUVCAddHeader:
 7819              	.LFB6:
2032:../uvc.c      **** {
 7820              		.loc 1 2032 0
 7821              		.cfi_startproc
 7822              		@ args = 0, pretend = 0, frame = 0
 7823              		@ frame_needed = 0, uses_anonymous_args = 0
 7824              	.LVL679:
 7825 45e4 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7826              	.LCFI24:
 7827              		.cfi_def_cfa_offset 16
2032:../uvc.c      **** {
 7828              		.loc 1 2032 0
 7829 45e8 0040A0E1 		mov	r4, r0
 7830              		.cfi_offset 14, -4
 7831              		.cfi_offset 5, -8
 7832              		.cfi_offset 4, -12
 7833              		.cfi_offset 3, -16
 7834 45ec 0150A0E1 		mov	r5, r1
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7835              		.loc 1 2034 0
 7836 45f0 30009FE5 		ldr	r0, .L649
 7837              	.LVL680:
 7838 45f4 0010E0E3 		mvn	r1, #0
 7839              	.LVL681:
 7840 45f8 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7841              		.loc 1 2035 0
 7842 45fc 0400A0E1 		mov	r0, r4
 7843 4600 24109FE5 		ldr	r1, .L649+4
 7844 4604 0C20A0E3 		mov	r2, #12
 7845 4608 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7846              		.loc 1 2036 0
 7847 460c 14009FE5 		ldr	r0, .L649
 7848 4610 FEFFFFEB 		bl	_txe_mutex_put
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7849              		.loc 1 2039 0
 7850 4614 020015E3 		tst	r5, #2
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7851              		.loc 1 2041 0
 7852 4618 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7853 461c 02308313 		orrne	r3, r3, #2
 7854 4620 0130C415 		strneb	r3, [r4, #1]
 7855 4624 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7856              	.L650:
 7857              		.align	2
 7858              	.L649:
 7859 4628 00000000 		.word	imgHdMux
 7860 462c 80040000 		.word	.LANCHOR1+1152
 7861              		.cfi_endproc
 7862              	.LFE6:
 7864              		.align	2
 7865              		.global	CyFxAppErrorHandler
 7867              	CyFxAppErrorHandler:
 7868              	.LFB7:
2051:../uvc.c      **** {
 7869              		.loc 1 2051 0
 7870              		.cfi_startproc
 7871              		@ args = 0, pretend = 0, frame = 0
 7872              		@ frame_needed = 0, uses_anonymous_args = 0
 7873              	.LVL682:
 7874 4630 08402DE9 		stmfd	sp!, {r3, lr}
 7875              	.LCFI25:
 7876              		.cfi_def_cfa_offset 8
 7877              	.LVL683:
 7878              	.L652:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7879              		.loc 1 2061 0 discriminator 1
 7880 4634 10109FE5 		ldr	r1, .L653
 7881 4638 0400A0E3 		mov	r0, #4
 7882              		.cfi_offset 14, -4
 7883              		.cfi_offset 3, -8
 7884 463c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7885              		.loc 1 2062 0 discriminator 1
 7886 4640 FA0FA0E3 		mov	r0, #1000
 7887 4644 FEFFFFEB 		bl	_tx_thread_sleep
 7888 4648 F9FFFFEA 		b	.L652
 7889              	.L654:
 7890              		.align	2
 7891              	.L653:
 7892 464c 4C020000 		.word	.LC14
 7893              		.cfi_endproc
 7894              	.LFE7:
 7896              		.align	2
 7897              		.global	UVCAppThread_Entry
 7899              	UVCAppThread_Entry:
 7900              	.LFB20:
3052:../uvc.c      **** {
 7901              		.loc 1 3052 0
 7902              		.cfi_startproc
 7903              		@ args = 0, pretend = 0, frame = 200
 7904              		@ frame_needed = 0, uses_anonymous_args = 0
 7905              	.LVL684:
 7906 4650 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7907              	.LCFI26:
 7908              		.cfi_def_cfa_offset 36
 7909 4654 D4D04DE2 		sub	sp, sp, #212
 7910              	.LCFI27:
 7911              		.cfi_def_cfa_offset 248
 7912              	.LBB231:
 7913              	.LBB232:
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7914              		.loc 1 2508 0
 7915              		.cfi_offset 14, -4
 7916              		.cfi_offset 11, -8
 7917              		.cfi_offset 10, -12
 7918              		.cfi_offset 9, -16
 7919              		.cfi_offset 8, -20
 7920              		.cfi_offset 7, -24
 7921              		.cfi_offset 6, -28
 7922              		.cfi_offset 5, -32
 7923              		.cfi_offset 4, -36
 7924 4658 FEFFFFEB 		bl	CyU3PUartInit
 7925              	.LVL685:
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7926              		.loc 1 2509 0
 7927 465c 004050E2 		subs	r4, r0, #0
 7928 4660 0400000A 		beq	.L656
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7929              		.loc 1 2511 0
 7930 4664 0400A0E3 		mov	r0, #4
 7931              	.LVL686:
 7932 4668 C81E9FE5 		ldr	r1, .L791
 7933 466c FEFFFFEB 		bl	CyU3PDebugPrint
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7934              		.loc 1 2512 0
 7935 4670 0400A0E1 		mov	r0, r4
 7936 4674 FEFFFFEB 		bl	CyFxAppErrorHandler
 7937              	.L656:
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7938              		.loc 1 2516 0
 7939 4678 BCCE9FE5 		ldr	ip, .L791+4
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7940              		.loc 1 2518 0
 7941 467c 0030A0E3 		mov	r3, #0
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7942              		.loc 1 2517 0
 7943 4680 0120A0E3 		mov	r2, #1
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7944              		.loc 1 2525 0
 7945 4684 68008DE2 		add	r0, sp, #104
 7946 4688 0310A0E1 		mov	r1, r3
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7947              		.loc 1 2516 0
 7948 468c 78C08DE5 		str	ip, [sp, #120]
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7949              		.loc 1 2517 0
 7950 4690 7C20CDE5 		strb	r2, [sp, #124]
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7951              		.loc 1 2518 0
 7952 4694 7D30CDE5 		strb	r3, [sp, #125]
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7953              		.loc 1 2519 0
 7954 4698 68208DE5 		str	r2, [sp, #104]
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7955              		.loc 1 2520 0
 7956 469c 6C308DE5 		str	r3, [sp, #108]
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7957              		.loc 1 2521 0
 7958 46a0 70308DE5 		str	r3, [sp, #112]
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7959              		.loc 1 2522 0
 7960 46a4 74208DE5 		str	r2, [sp, #116]
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7961              		.loc 1 2525 0
 7962 46a8 FEFFFFEB 		bl	CyU3PUartSetConfig
 7963              	.LVL687:
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7964              		.loc 1 2526 0
 7965 46ac 000050E3 		cmp	r0, #0
 7966 46b0 0000000A 		beq	.L657
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7967              		.loc 1 2528 0
 7968 46b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7969              	.LVL688:
 7970              	.L657:
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7971              		.loc 1 2532 0
 7972 46b8 0000E0E3 		mvn	r0, #0
 7973 46bc FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7974              	.LVL689:
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7975              		.loc 1 2533 0
 7976 46c0 000050E3 		cmp	r0, #0
 7977 46c4 0000000A 		beq	.L658
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7978              		.loc 1 2535 0
 7979 46c8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7980              	.LVL690:
 7981              	.L658:
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7982              		.loc 1 2539 0
 7983 46cc 0300A0E3 		mov	r0, #3
 7984 46d0 0410A0E3 		mov	r1, #4
 7985 46d4 FEFFFFEB 		bl	CyU3PDebugInit
 7986              	.LVL691:
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7987              		.loc 1 2540 0
 7988 46d8 000050E3 		cmp	r0, #0
 7989 46dc 0000000A 		beq	.L659
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7990              		.loc 1 2542 0
 7991 46e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7992              	.LVL692:
 7993              	.L659:
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7994              		.loc 1 2546 0
 7995 46e4 0000A0E3 		mov	r0, #0
 7996 46e8 FEFFFFEB 		bl	CyU3PDebugPreamble
 7997              	.LVL693:
 7998              	.LBE232:
 7999              	.LBE231:
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
 8000              		.loc 1 3068 0
 8001 46ec 7D0FA0E3 		mov	r0, #500
 8002 46f0 FEFFFFEB 		bl	_tx_thread_sleep
 8003              	.LVL694:
 8004 46f4 7D0FA0E3 		mov	r0, #500
 8005 46f8 FEFFFFEB 		bl	_tx_thread_sleep
 8006 46fc 7D0FA0E3 		mov	r0, #500
 8007 4700 FEFFFFEB 		bl	_tx_thread_sleep
 8008 4704 7D0FA0E3 		mov	r0, #500
 8009 4708 FEFFFFEB 		bl	_tx_thread_sleep
 8010 470c 7D0FA0E3 		mov	r0, #500
 8011 4710 FEFFFFEB 		bl	_tx_thread_sleep
 8012 4714 7D0FA0E3 		mov	r0, #500
 8013 4718 FEFFFFEB 		bl	_tx_thread_sleep
 8014              	.LBB233:
 8015              	.LBB234:
2556:../uvc.c      ****     status = CyU3PI2cInit ();
 8016              		.loc 1 2556 0
 8017 471c FEFFFFEB 		bl	CyU3PI2cInit
 8018              	.LVL695:
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 8019              		.loc 1 2557 0
 8020 4720 004050E2 		subs	r4, r0, #0
 8021 4724 0400000A 		beq	.L660
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 8022              		.loc 1 2559 0
 8023 4728 0400A0E3 		mov	r0, #4
 8024              	.LVL696:
 8025 472c 0C1E9FE5 		ldr	r1, .L791+8
 8026 4730 FEFFFFEB 		bl	CyU3PDebugPrint
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
 8027              		.loc 1 2560 0
 8028 4734 0400A0E1 		mov	r0, r4
 8029 4738 FEFFFFEB 		bl	CyFxAppErrorHandler
 8030              	.L660:
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 8031              		.loc 1 2564 0
 8032 473c 006E9FE5 		ldr	r6, .L791+12
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 8033              		.loc 1 2565 0
 8034 4740 0050A0E3 		mov	r5, #0
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 8035              		.loc 1 2566 0
 8036 4744 0040E0E3 		mvn	r4, #0
 8037              	.LVL697:
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 8038              		.loc 1 2569 0
 8039 4748 A4008DE2 		add	r0, sp, #164
 8040 474c 0510A0E1 		mov	r1, r5
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 8041              		.loc 1 2566 0
 8042 4750 AC408DE5 		str	r4, [sp, #172]
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 8043              		.loc 1 2567 0
 8044 4754 B04BCDE1 		strh	r4, [sp, #176]	@ movhi
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 8045              		.loc 1 2564 0
 8046 4758 A4608DE5 		str	r6, [sp, #164]
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 8047              		.loc 1 2565 0
 8048 475c A8508DE5 		str	r5, [sp, #168]
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 8049              		.loc 1 2569 0
 8050 4760 FEFFFFEB 		bl	CyU3PI2cSetConfig
 8051              	.LVL698:
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 8052              		.loc 1 2570 0
 8053 4764 004050E2 		subs	r4, r0, #0
 8054 4768 0400000A 		beq	.L661
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 8055              		.loc 1 2572 0
 8056 476c 0400A0E3 		mov	r0, #4
 8057              	.LVL699:
 8058 4770 D01D9FE5 		ldr	r1, .L791+16
 8059 4774 FEFFFFEB 		bl	CyU3PDebugPrint
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
 8060              		.loc 1 2573 0
 8061 4778 0400A0E1 		mov	r0, r4
 8062 477c FEFFFFEB 		bl	CyFxAppErrorHandler
 8063              	.L661:
 8064              	.LBE234:
 8065              	.LBE233:
 8066              	.LBB235:
 8067              	.LBB237:
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 8068              		.loc 1 2643 0
 8069 4780 C45D9FE5 		ldr	r5, .L791+20
 8070 4784 2820A0E3 		mov	r2, #40
 8071 4788 0010A0E3 		mov	r1, #0
 8072 478c 0500A0E1 		mov	r0, r5
 8073 4790 FEFFFFEB 		bl	_txe_event_flags_create
 8074              	.LVL700:
2644:../uvc.c      ****     if (apiRetStatus != 0)
 8075              		.loc 1 2644 0
 8076 4794 002050E2 		subs	r2, r0, #0
 8077 4798 4501001A 		bne	.L761
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 8078              		.loc 1 2658 0
 8079 479c 0260A0E3 		mov	r6, #2
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 8080              		.loc 1 2665 0
 8081 47a0 0210A0E1 		mov	r1, r2
2654:../uvc.c      ****     isUsbConnected = CyFalse;
 8082              		.loc 1 2654 0
 8083 47a4 B02085E5 		str	r2, [r5, #176]
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 8084              		.loc 1 2655 0
 8085 47a8 C42085E5 		str	r2, [r5, #196]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 8086              		.loc 1 2661 0
 8087 47ac 0380A0E3 		mov	r8, #3
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 8088              		.loc 1 2665 0
 8089 47b0 B4008DE2 		add	r0, sp, #180
 8090              	.LVL701:
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 8091              		.loc 1 2660 0
 8092 47b4 BC20CDE5 		strb	r2, [sp, #188]
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
 8093              		.loc 1 2662 0
 8094 47b8 B8208DE5 		str	r2, [sp, #184]
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 8095              		.loc 1 2658 0
 8096 47bc B460CDE5 		strb	r6, [sp, #180]
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 8097              		.loc 1 2659 0
 8098 47c0 B560CDE5 		strb	r6, [sp, #181]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 8099              		.loc 1 2661 0
 8100 47c4 BD80CDE5 		strb	r8, [sp, #189]
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 8101              		.loc 1 2665 0
 8102 47c8 FEFFFFEB 		bl	CyU3PGpioInit
 8103              	.LVL702:
2666:../uvc.c      ****     if (apiRetStatus != 0)
 8104              		.loc 1 2666 0
 8105 47cc 002050E2 		subs	r2, r0, #0
 8106 47d0 4901001A 		bne	.L762
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 8107              		.loc 1 2674 0
 8108 47d4 1600A0E3 		mov	r0, #22
 8109              	.LVL703:
 8110 47d8 0110A0E3 		mov	r1, #1
 8111 47dc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8112              	.LVL704:
2675:../uvc.c      ****     if (apiRetStatus != 0)
 8113              		.loc 1 2675 0
 8114 47e0 002050E2 		subs	r2, r0, #0
 8115 47e4 3B01001A 		bne	.L763
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 8116              		.loc 1 2680 0
 8117 47e8 1400A0E3 		mov	r0, #20
 8118              	.LVL705:
 8119 47ec 0110A0E3 		mov	r1, #1
 8120 47f0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8121              	.LVL706:
2681:../uvc.c      ****     if (apiRetStatus != 0)
 8122              		.loc 1 2681 0
 8123 47f4 002050E2 		subs	r2, r0, #0
 8124 47f8 4801001A 		bne	.L764
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 8125              		.loc 1 2686 0
 8126 47fc 1800A0E3 		mov	r0, #24
 8127              	.LVL707:
 8128 4800 0110A0E3 		mov	r1, #1
 8129 4804 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8130              	.LVL708:
2687:../uvc.c      ****     if (apiRetStatus != 0)
 8131              		.loc 1 2687 0
 8132 4808 002050E2 		subs	r2, r0, #0
 8133 480c 8A02001A 		bne	.L765
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8134              		.loc 1 2694 0
 8135 4810 0140A0E3 		mov	r4, #1
 8136              	.LVL709:
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 8137              		.loc 1 2699 0
 8138 4814 1600A0E3 		mov	r0, #22
 8139              	.LVL710:
 8140 4818 80108DE2 		add	r1, sp, #128
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 8141              		.loc 1 2697 0
 8142 481c 8C208DE5 		str	r2, [sp, #140]
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8143              		.loc 1 2698 0
 8144 4820 9020CDE5 		strb	r2, [sp, #144]
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8145              		.loc 1 2694 0
 8146 4824 80408DE5 		str	r4, [sp, #128]
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 8147              		.loc 1 2695 0
 8148 4828 84408DE5 		str	r4, [sp, #132]
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 8149              		.loc 1 2696 0
 8150 482c 88408DE5 		str	r4, [sp, #136]
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 8151              		.loc 1 2699 0
 8152 4830 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8153              	.LVL711:
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8154              		.loc 1 2700 0
 8155 4834 002050E2 		subs	r2, r0, #0
 8156 4838 7602001A 		bne	.L766
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 8157              		.loc 1 2713 0
 8158 483c 1400A0E3 		mov	r0, #20
 8159              	.LVL712:
 8160 4840 80108DE2 		add	r1, sp, #128
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 8161              		.loc 1 2711 0
 8162 4844 8C208DE5 		str	r2, [sp, #140]
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8163              		.loc 1 2712 0
 8164 4848 9020CDE5 		strb	r2, [sp, #144]
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8165              		.loc 1 2708 0
 8166 484c 80408DE5 		str	r4, [sp, #128]
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 8167              		.loc 1 2709 0
 8168 4850 84408DE5 		str	r4, [sp, #132]
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 8169              		.loc 1 2710 0
 8170 4854 88408DE5 		str	r4, [sp, #136]
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 8171              		.loc 1 2713 0
 8172 4858 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8173              	.LVL713:
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8174              		.loc 1 2714 0
 8175 485c 002050E2 		subs	r2, r0, #0
 8176 4860 7E02001A 		bne	.L767
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 8177              		.loc 1 2727 0
 8178 4864 1800A0E3 		mov	r0, #24
 8179              	.LVL714:
 8180 4868 80108DE2 		add	r1, sp, #128
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 8181              		.loc 1 2722 0
 8182 486c 80208DE5 		str	r2, [sp, #128]
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 8183              		.loc 1 2723 0
 8184 4870 84208DE5 		str	r2, [sp, #132]
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 8185              		.loc 1 2724 0
 8186 4874 88208DE5 		str	r2, [sp, #136]
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8187              		.loc 1 2726 0
 8188 4878 9020CDE5 		strb	r2, [sp, #144]
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 8189              		.loc 1 2725 0
 8190 487c 8C408DE5 		str	r4, [sp, #140]
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 8191              		.loc 1 2727 0
 8192 4880 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8193              	.LVL715:
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8194              		.loc 1 2728 0
 8195 4884 002050E2 		subs	r2, r0, #0
 8196 4888 5902001A 		bne	.L768
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 8197              		.loc 1 2740 0
 8198 488c 0400A0E1 		mov	r0, r4
 8199              	.LVL716:
 8200 4890 94108DE2 		add	r1, sp, #148
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 8201              		.loc 1 2737 0
 8202 4894 9C208DE5 		str	r2, [sp, #156]
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 8203              		.loc 1 2738 0
 8204 4898 98208DE5 		str	r2, [sp, #152]
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
 8205              		.loc 1 2735 0
 8206 489c B469CDE1 		strh	r6, [sp, #148]	@ movhi
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 8207              		.loc 1 2736 0
 8208 48a0 A080CDE5 		strb	r8, [sp, #160]
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 8209              		.loc 1 2740 0
 8210 48a4 FEFFFFEB 		bl	CyU3PPibInit
 8211              	.LVL717:
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8212              		.loc 1 2741 0
 8213 48a8 002050E2 		subs	r2, r0, #0
 8214 48ac 4702001A 		bne	.L769
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 8215              		.loc 1 2748 0
 8216 48b0 980C9FE5 		ldr	r0, .L791+24
 8217              	.LVL718:
 8218 48b4 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 8219              	.LVL719:
2756:../uvc.c      ****     SensorReset ();
 8220              		.loc 1 2756 0
 8221 48b8 FEFFFFEB 		bl	SensorReset
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
 8222              		.loc 1 2757 0
 8223 48bc 900C9FE5 		ldr	r0, .L791+28
 8224 48c0 FEFFFFEB 		bl	_tx_thread_sleep
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 8225              		.loc 1 2761 0
 8226 48c4 FEFFFFEB 		bl	CyU3PUsbStart
 8227              	.LVL720:
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8228              		.loc 1 2762 0
 8229 48c8 002050E2 		subs	r2, r0, #0
 8230 48cc 3602001A 		bne	.L770
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 8231              		.loc 1 2768 0
 8232 48d0 0010A0E3 		mov	r1, #0
 8233 48d4 7C0C9FE5 		ldr	r0, .L791+32
 8234              	.LVL721:
 8235 48d8 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 8236              	.LVL722:
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 8237              		.loc 1 2771 0
 8238 48dc 780C9FE5 		ldr	r0, .L791+36
 8239 48e0 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 8240              		.loc 1 2777 0
 8241 48e4 0010A0E3 		mov	r1, #0
 8242 48e8 702C9FE5 		ldr	r2, .L791+40
 8243 48ec 0100A0E3 		mov	r0, #1
 8244 48f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 8245              		.loc 1 2778 0
 8246 48f4 0000A0E3 		mov	r0, #0
 8247 48f8 0010A0E1 		mov	r1, r0
 8248 48fc 602C9FE5 		ldr	r2, .L791+44
 8249 4900 FEFFFFEB 		bl	CyU3PUsbSetDesc
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 8250              		.loc 1 2781 0
 8251 4904 0010A0E3 		mov	r1, #0
 8252 4908 582C9FE5 		ldr	r2, .L791+48
 8253 490c 0200A0E3 		mov	r0, #2
 8254 4910 FEFFFFEB 		bl	CyU3PUsbSetDesc
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 8255              		.loc 1 2782 0
 8256 4914 0010A0E3 		mov	r1, #0
 8257 4918 4C2C9FE5 		ldr	r2, .L791+52
 8258 491c 0700A0E3 		mov	r0, #7
 8259 4920 FEFFFFEB 		bl	CyU3PUsbSetDesc
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 8260              		.loc 1 2785 0
 8261 4924 0010A0E3 		mov	r1, #0
 8262 4928 402C9FE5 		ldr	r2, .L791+56
 8263 492c 0400A0E3 		mov	r0, #4
 8264 4930 FEFFFFEB 		bl	CyU3PUsbSetDesc
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 8265              		.loc 1 2786 0
 8266 4934 0010A0E3 		mov	r1, #0
 8267 4938 342C9FE5 		ldr	r2, .L791+60
 8268 493c 0300A0E3 		mov	r0, #3
 8269 4940 FEFFFFEB 		bl	CyU3PUsbSetDesc
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 8270              		.loc 1 2787 0
 8271 4944 0010A0E3 		mov	r1, #0
 8272 4948 282C9FE5 		ldr	r2, .L791+64
 8273 494c 0600A0E3 		mov	r0, #6
 8274 4950 FEFFFFEB 		bl	CyU3PUsbSetDesc
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 8275              		.loc 1 2790 0
 8276 4954 0010A0E3 		mov	r1, #0
 8277 4958 1C2C9FE5 		ldr	r2, .L791+68
 8278 495c 0500A0E3 		mov	r0, #5
 8279 4960 FEFFFFEB 		bl	CyU3PUsbSetDesc
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 8280              		.loc 1 2791 0
 8281 4964 0110A0E3 		mov	r1, #1
 8282 4968 102C9FE5 		ldr	r2, .L791+72
 8283 496c 0500A0E3 		mov	r0, #5
 8284 4970 FEFFFFEB 		bl	CyU3PUsbSetDesc
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 8285              		.loc 1 2792 0
 8286 4974 0210A0E3 		mov	r1, #2
 8287 4978 042C9FE5 		ldr	r2, .L791+76
 8288 497c 0500A0E3 		mov	r0, #5
 8289 4980 FEFFFFEB 		bl	CyU3PUsbSetDesc
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8290              		.loc 1 2802 0
 8291 4984 00A0A0E3 		mov	sl, #0
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 8292              		.loc 1 2799 0
 8293 4988 0140A0E3 		mov	r4, #1
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 8294              		.loc 1 2801 0
 8295 498c 4080A0E3 		mov	r8, #64	@ movhi
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 8296              		.loc 1 2800 0
 8297 4990 0390A0E3 		mov	r9, #3
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 8298              		.loc 1 2805 0
 8299 4994 8200A0E3 		mov	r0, #130
 8300 4998 C0108DE2 		add	r1, sp, #192
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 8301              		.loc 1 2801 0
 8302 499c B88CCDE1 		strh	r8, [sp, #200]	@ movhi
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 8303              		.loc 1 2799 0
 8304 49a0 C0408DE5 		str	r4, [sp, #192]
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 8305              		.loc 1 2800 0
 8306 49a4 C490CDE5 		strb	r9, [sp, #196]
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8307              		.loc 1 2802 0
 8308 49a8 CBA0CDE5 		strb	sl, [sp, #203]
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 8309              		.loc 1 2803 0
 8310 49ac B6ACCDE1 		strh	sl, [sp, #198]	@ movhi
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
 8311              		.loc 1 2804 0
 8312 49b0 CA40CDE5 		strb	r4, [sp, #202]
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 8313              		.loc 1 2805 0
 8314 49b4 FEFFFFEB 		bl	CyU3PSetEpConfig
 8315              	.LVL723:
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 8316              		.loc 1 2803 0
 8317 49b8 0A80A0E1 		mov	r8, sl	@ movhi
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8318              		.loc 1 2806 0
 8319 49bc 003050E2 		subs	r3, r0, #0
 8320 49c0 EF01001A 		bne	.L771
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 8321              		.loc 1 2817 0
 8322 49c4 BCCB9FE5 		ldr	ip, .L791+80
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8323              		.loc 1 2816 0
 8324 49c8 BCBB9FE5 		ldr	fp, .L791+84
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 8325              		.loc 1 2814 0
 8326 49cc 016BA0E3 		mov	r6, #1024	@ movhi
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 8327              		.loc 1 2823 0
 8328 49d0 10E0A0E3 		mov	lr, #16
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 8329              		.loc 1 2825 0
 8330 49d4 B40B9FE5 		ldr	r0, .L791+88
 8331              	.LVL724:
 8332 49d8 0410A0E3 		mov	r1, #4
 8333 49dc 4C208DE2 		add	r2, sp, #76
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 8334              		.loc 1 2814 0
 8335 49e0 BC64CDE1 		strh	r6, [sp, #76]	@ movhi
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
 8336              		.loc 1 2815 0
 8337 49e4 BE44CDE1 		strh	r4, [sp, #78]	@ movhi
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8338              		.loc 1 2816 0
 8339 49e8 B0B5CDE1 		strh	fp, [sp, #80]	@ movhi
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 8340              		.loc 1 2817 0
 8341 49ec B2C5CDE1 		strh	ip, [sp, #82]	@ movhi
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 8342              		.loc 1 2818 0
 8343 49f0 B435CDE1 		strh	r3, [sp, #84]	@ movhi
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 8344              		.loc 1 2819 0
 8345 49f4 B635CDE1 		strh	r3, [sp, #86]	@ movhi
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 8346              		.loc 1 2820 0
 8347 49f8 B835CDE1 		strh	r3, [sp, #88]	@ movhi
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 8348              		.loc 1 2821 0
 8349 49fc BA35CDE1 		strh	r3, [sp, #90]	@ movhi
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8350              		.loc 1 2822 0
 8351 4a00 5CA0CDE5 		strb	sl, [sp, #92]
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 8352              		.loc 1 2823 0
 8353 4a04 60E08DE5 		str	lr, [sp, #96]
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 8354              		.loc 1 2824 0
 8355 4a08 64308DE5 		str	r3, [sp, #100]
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 8356              		.loc 1 2825 0
 8357 4a0c FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8358              	.LVL725:
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8359              		.loc 1 2827 0
 8360 4a10 006050E2 		subs	r6, r0, #0
 8361 4a14 D001001A 		bne	.L772
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8362              		.loc 1 2834 0
 8363 4a18 010BA0E3 		mov	r0, #1024
 8364              	.LVL726:
 8365 4a1c FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 8366 4a20 6C1B9FE5 		ldr	r1, .L791+92
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8367              		.loc 1 2835 0
 8368 4a24 000050E3 		cmp	r0, #0
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8369              		.loc 1 2834 0
 8370 4a28 000081E5 		str	r0, [r1, #0]
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8371              		.loc 1 2835 0
 8372 4a2c C101000A 		beq	.L773
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 8373              		.loc 1 2842 0
 8374 4a30 0610A0E1 		mov	r1, r6
 8375 4a34 0620A0E1 		mov	r2, r6
 8376 4a38 3830A0E3 		mov	r3, #56
 8377 4a3c 540B9FE5 		ldr	r0, .L791+96
 8378 4a40 FEFFFFEB 		bl	_txe_mutex_create
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 8379              		.loc 1 2843 0
 8380 4a44 0139A0E3 		mov	r3, #16384	@ movhi
 8381 4a48 B830CDE1 		strh	r3, [sp, #8]	@ movhi
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 8382              		.loc 1 2846 0
 8383 4a4c 013CA0E3 		mov	r3, #256	@ movhi
 8384 4a50 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8385              		.loc 1 2848 0
 8386 4a54 403B9FE5 		ldr	r3, .L791+100
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 8387              		.loc 1 2844 0
 8388 4a58 04C0A0E3 		mov	ip, #4	@ movhi
 8389 4a5c BAC0CDE1 		strh	ip, [sp, #10]	@ movhi
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8390              		.loc 1 2847 0
 8391 4a60 38CB9FE5 		ldr	ip, .L791+104
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8392              		.loc 1 2848 0
 8393 4a64 B631CDE1 		strh	r3, [sp, #22]	@ movhi
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8394              		.loc 1 2851 0
 8395 4a68 0430A0E3 		mov	r3, #4	@ movhi
 8396 4a6c B232CDE1 		strh	r3, [sp, #34]	@ movhi
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8397              		.loc 1 2855 0
 8398 4a70 2C3B9FE5 		ldr	r3, .L791+108
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8399              		.loc 1 2847 0
 8400 4a74 B0C1CDE1 		strh	ip, [sp, #16]	@ movhi
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 8401              		.loc 1 2850 0
 8402 4a78 0CC0A0E3 		mov	ip, #12	@ movhi
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8403              		.loc 1 2856 0
 8404 4a7c 08208DE2 		add	r2, sp, #8
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 8405              		.loc 1 2850 0
 8406 4a80 B0C2CDE1 		strh	ip, [sp, #32]	@ movhi
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8407              		.loc 1 2845 0
 8408 4a84 02A0A0E3 		mov	sl, #2	@ movhi
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8409              		.loc 1 2854 0
 8410 4a88 18C0A0E3 		mov	ip, #24
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8411              		.loc 1 2856 0
 8412 4a8c 140B9FE5 		ldr	r0, .L791+112
 8413 4a90 0710A0E3 		mov	r1, #7
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8414              		.loc 1 2845 0
 8415 4a94 BCA0CDE1 		strh	sl, [sp, #12]	@ movhi
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 8416              		.loc 1 2849 0
 8417 4a98 BE61CDE1 		strh	r6, [sp, #30]	@ movhi
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 8418              		.loc 1 2852 0
 8419 4a9c B462CDE1 		strh	r6, [sp, #36]	@ movhi
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8420              		.loc 1 2853 0
 8421 4aa0 2680CDE5 		strb	r8, [sp, #38]
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8422              		.loc 1 2854 0
 8423 4aa4 28C08DE5 		str	ip, [sp, #40]
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8424              		.loc 1 2855 0
 8425 4aa8 2C308DE5 		str	r3, [sp, #44]
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8426              		.loc 1 2856 0
 8427 4aac FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 8428              	.LVL727:
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8429              		.loc 1 2858 0
 8430 4ab0 002050E2 		subs	r2, r0, #0
 8431 4ab4 9601001A 		bne	.L774
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8432              		.loc 1 2873 0
 8433 4ab8 C4A0CDE5 		strb	sl, [sp, #196]
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
 8434              		.loc 1 2879 0
 8435 4abc 0400A0E3 		mov	r0, #4
 8436              	.LVL728:
 8437 4ac0 C0108DE2 		add	r1, sp, #192
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
 8438              		.loc 1 2874 0
 8439 4ac4 01ABA0E3 		mov	sl, #1024	@ movhi
2876:../uvc.c      ****     endPointConfig.streams  = 0;
 8440              		.loc 1 2876 0
 8441 4ac8 B62CCDE1 		strh	r2, [sp, #198]	@ movhi
2872:../uvc.c      ****     endPointConfig.enable   = 1;
 8442              		.loc 1 2872 0
 8443 4acc C0408DE5 		str	r4, [sp, #192]
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
 8444              		.loc 1 2874 0
 8445 4ad0 B8ACCDE1 		strh	sl, [sp, #200]	@ movhi
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8446              		.loc 1 2875 0
 8447 4ad4 CB80CDE5 		strb	r8, [sp, #203]
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
 8448              		.loc 1 2877 0
 8449 4ad8 CA40CDE5 		strb	r4, [sp, #202]
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
 8450              		.loc 1 2879 0
 8451 4adc FEFFFFEB 		bl	CyU3PSetEpConfig
 8452              	.LVL729:
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8453              		.loc 1 2880 0
 8454 4ae0 002050E2 		subs	r2, r0, #0
 8455 4ae4 8101001A 		bne	.L775
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
 8456              		.loc 1 2886 0
 8457 4ae8 0410A0E1 		mov	r1, r4
 8458 4aec 0400A0E3 		mov	r0, #4
 8459              	.LVL730:
 8460 4af0 FEFFFFEB 		bl	CyU3PUsbSetEpPktMode
 8461              	.LVL731:
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
 8462              		.loc 1 2888 0
 8463 4af4 8400A0E3 		mov	r0, #132
 8464 4af8 C0108DE2 		add	r1, sp, #192
 8465 4afc FEFFFFEB 		bl	CyU3PSetEpConfig
 8466              	.LVL732:
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8467              		.loc 1 2889 0
 8468 4b00 003050E2 		subs	r3, r0, #0
 8469 4b04 6F01001A 		bne	.L776
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8470              		.loc 1 2907 0
 8471 4b08 0910A0E1 		mov	r1, r9
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
 8472              		.loc 1 2897 0
 8473 4b0c 986A9FE5 		ldr	r6, .L791+116
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 8474              		.loc 1 2905 0
 8475 4b10 989A9FE5 		ldr	r9, .L791+120
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8476              		.loc 1 2907 0
 8477 4b14 30208DE2 		add	r2, sp, #48
2895:../uvc.c      ****     channelConfig.size           = 1024;
 8478              		.loc 1 2895 0
 8479 4b18 01CBA0E3 		mov	ip, #1024	@ movhi
2896:../uvc.c      ****     channelConfig.count          = 1;
 8480              		.loc 1 2896 0
 8481 4b1c B243CDE1 		strh	r4, [sp, #50]	@ movhi
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
 8482              		.loc 1 2898 0
 8483 4b20 3FECA0E3 		mov	lr, #16128	@ movhi
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8484              		.loc 1 2907 0
 8485 4b24 880A9FE5 		ldr	r0, .L791+124
 8486              	.LVL733:
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
 8487              		.loc 1 2904 0
 8488 4b28 0840A0E3 		mov	r4, #8
2895:../uvc.c      ****     channelConfig.size           = 1024;
 8489              		.loc 1 2895 0
 8490 4b2c B0C3CDE1 		strh	ip, [sp, #48]	@ movhi
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
 8491              		.loc 1 2897 0
 8492 4b30 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
 8493              		.loc 1 2898 0
 8494 4b34 B6E3CDE1 		strh	lr, [sp, #54]	@ movhi
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
 8495              		.loc 1 2899 0
 8496 4b38 B833CDE1 		strh	r3, [sp, #56]	@ movhi
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
 8497              		.loc 1 2900 0
 8498 4b3c BA33CDE1 		strh	r3, [sp, #58]	@ movhi
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
 8499              		.loc 1 2901 0
 8500 4b40 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
 8501              		.loc 1 2902 0
 8502 4b44 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8503              		.loc 1 2903 0
 8504 4b48 4080CDE5 		strb	r8, [sp, #64]
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
 8505              		.loc 1 2904 0
 8506 4b4c 44408DE5 		str	r4, [sp, #68]
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 8507              		.loc 1 2905 0
 8508 4b50 48908DE5 		str	r9, [sp, #72]
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8509              		.loc 1 2907 0
 8510 4b54 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8511              	.LVL734:
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8512              		.loc 1 2908 0
 8513 4b58 002050E2 		subs	r2, r0, #0
 8514 4b5c 5001001A 		bne	.L777
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
 8515              		.loc 1 2914 0
 8516 4b60 4C0A9FE5 		ldr	r0, .L791+124
 8517              	.LVL735:
 8518 4b64 0210A0E1 		mov	r1, r2
 8519 4b68 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 8520              	.LVL736:
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8521              		.loc 1 2915 0
 8522 4b6c 003050E2 		subs	r3, r0, #0
 8523 4b70 4101001A 		bne	.L778
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8524              		.loc 1 2933 0
 8525 4b74 30208DE2 		add	r2, sp, #48
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8526              		.loc 1 2923 0
 8527 4b78 B4B3CDE1 		strh	fp, [sp, #52]	@ movhi
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8528              		.loc 1 2933 0
 8529 4b7c 340A9FE5 		ldr	r0, .L791+128
 8530              	.LVL737:
 8531 4b80 0410A0E3 		mov	r1, #4
2921:../uvc.c      ****     channelConfig.size           = 1024;
 8532              		.loc 1 2921 0
 8533 4b84 01ABA0E3 		mov	sl, #1024	@ movhi
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
 8534              		.loc 1 2924 0
 8535 4b88 C1BFA0E3 		mov	fp, #772	@ movhi
2921:../uvc.c      ****     channelConfig.size           = 1024;
 8536              		.loc 1 2921 0
 8537 4b8c B0A3CDE1 		strh	sl, [sp, #48]	@ movhi
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 8538              		.loc 1 2922 0
 8539 4b90 B233CDE1 		strh	r3, [sp, #50]	@ movhi
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
 8540              		.loc 1 2924 0
 8541 4b94 B6B3CDE1 		strh	fp, [sp, #54]	@ movhi
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
 8542              		.loc 1 2925 0
 8543 4b98 B833CDE1 		strh	r3, [sp, #56]	@ movhi
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
 8544              		.loc 1 2926 0
 8545 4b9c BA33CDE1 		strh	r3, [sp, #58]	@ movhi
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
 8546              		.loc 1 2927 0
 8547 4ba0 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
 8548              		.loc 1 2928 0
 8549 4ba4 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8550              		.loc 1 2929 0
 8551 4ba8 4080CDE5 		strb	r8, [sp, #64]
2930:../uvc.c      ****     channelConfig.notification   = 0;
 8552              		.loc 1 2930 0
 8553 4bac 44308DE5 		str	r3, [sp, #68]
2931:../uvc.c      ****     channelConfig.cb             = 0;
 8554              		.loc 1 2931 0
 8555 4bb0 48308DE5 		str	r3, [sp, #72]
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8556              		.loc 1 2933 0
 8557 4bb4 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8558              	.LVL738:
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8559              		.loc 1 2934 0
 8560 4bb8 002050E2 		subs	r2, r0, #0
 8561 4bbc 2501001A 		bne	.L779
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8562              		.loc 1 2940 0
 8563 4bc0 010BA0E3 		mov	r0, #1024
 8564              	.LVL739:
 8565 4bc4 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 8566              	.LVL740:
 8567 4bc8 EC299FE5 		ldr	r2, .L791+132
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
 8568              		.loc 1 2941 0
 8569 4bcc 000050E3 		cmp	r0, #0
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8570              		.loc 1 2940 0
 8571 4bd0 000082E5 		str	r0, [r2, #0]
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
 8572              		.loc 1 2941 0
 8573 4bd4 1601000A 		beq	.L780
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 8574              		.loc 1 2949 0
 8575 4bd8 0100A0E3 		mov	r0, #1
 8576 4bdc 0010A0E1 		mov	r1, r0
 8577 4be0 FEFFFFEB 		bl	CyU3PConnectState
 8578              	.LVL741:
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8579              		.loc 1 2950 0
 8580 4be4 002050E2 		subs	r2, r0, #0
 8581 4be8 0801001A 		bne	.L781
2956:../uvc.c      ****     CyU3PBusyWait(100);
 8582              		.loc 1 2956 0
 8583 4bec 6400A0E3 		mov	r0, #100
 8584              	.LVL742:
 8585 4bf0 FEFFFFEB 		bl	CyU3PBusyWait
 8586              	.LVL743:
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8587              		.loc 1 2958 0
 8588 4bf4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2960:../uvc.c      ****     endPointConfig.enable   = 1;
 8589              		.loc 1 2960 0
 8590 4bf8 0110A0E3 		mov	r1, #1
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8591              		.loc 1 2961 0
 8592 4bfc 0230A0E3 		mov	r3, #2
2960:../uvc.c      ****     endPointConfig.enable   = 1;
 8593              		.loc 1 2960 0
 8594 4c00 C0108DE5 		str	r1, [sp, #192]
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8595              		.loc 1 2961 0
 8596 4c04 C430CDE5 		strb	r3, [sp, #196]
2972:../uvc.c      ****     endPointConfig.streams  = 0;
 8597              		.loc 1 2972 0
 8598 4c08 0080A0E3 		mov	r8, #0	@ movhi
 8599 4c0c B68CCDE1 		strh	r8, [sp, #198]	@ movhi
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 8600              		.loc 1 2962 0
 8601 4c10 030050E3 		cmp	r0, #3
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
 8602              		.loc 1 2965 0
 8603 4c14 0F108102 		addeq	r1, r1, #15
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8604              		.loc 1 2958 0
 8605 4c18 C800C5E5 		strb	r0, [r5, #200]
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8606              		.loc 1 2969 0
 8607 4c1c 020CA013 		movne	r0, #512	@ movhi
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8608              		.loc 1 2964 0
 8609 4c20 013BA003 		moveq	r3, #1024	@ movhi
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8610              		.loc 1 2969 0
 8611 4c24 B80CCD11 		strneh	r0, [sp, #200]	@ movhi
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
 8612              		.loc 1 2970 0
 8613 4c28 CA10CDE5 		strb	r1, [sp, #202]
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8614              		.loc 1 2973 0
 8615 4c2c 8300A0E3 		mov	r0, #131
 8616 4c30 C0108DE2 		add	r1, sp, #192
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8617              		.loc 1 2964 0
 8618 4c34 B83CCD01 		streqh	r3, [sp, #200]	@ movhi
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8619              		.loc 1 2973 0
 8620 4c38 FEFFFFEB 		bl	CyU3PSetEpConfig
 8621              	.LVL744:
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8622              		.loc 1 2974 0
 8623 4c3c 002050E2 		subs	r2, r0, #0
 8624 4c40 A400001A 		bne	.L706
 8625 4c44 74899FE5 		ldr	r8, .L791+136
 8626              	.LBE237:
 8627              	.LBE235:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8628              		.loc 1 3097 0
 8629 4c48 FC489FE5 		ldr	r4, .L791+20
 8630 4c4c 0260A0E1 		mov	r6, r2
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
 8631              		.loc 1 3328 0
 8632 4c50 00A0E0E3 		mvn	sl, #0
 8633              	.LVL745:
 8634              	.L707:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8635              		.loc 1 3097 0
 8636 4c54 F0089FE5 		ldr	r0, .L791+20
 8637 4c58 0110A0E3 		mov	r1, #1
 8638 4c5c 0220A0E3 		mov	r2, #2
 8639 4c60 CC308DE2 		add	r3, sp, #204
 8640 4c64 00608DE5 		str	r6, [sp, #0]
 8641 4c68 FEFFFFEB 		bl	_txe_event_flags_get
 8642 4c6c 000050E3 		cmp	r0, #0
 8643 4c70 3300001A 		bne	.L709
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8644              		.loc 1 3101 0
 8645 4c74 29E0D4E5 		ldrb	lr, [r4, #41]	@ zero_extendqisi2
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8646              		.loc 1 3146 0
 8647 4c78 BC9094E5 		ldr	r9, [r4, #188]
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8648              		.loc 1 3101 0
 8649 4c7c 01308EE3 		orr	r3, lr, #1
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8650              		.loc 1 3146 0
 8651 4c80 000059E3 		cmp	r9, #0
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8652              		.loc 1 3101 0
 8653 4c84 2930C4E5 		strb	r3, [r4, #41]
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8654              		.loc 1 3146 0
 8655 4c88 0300000A 		beq	.L710
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8656              		.loc 1 3146 0 is_stmt 0 discriminator 1
 8657 4c8c B0CCD4E1 		ldrh	ip, [r4, #192]
 8658 4c90 B2BCD4E1 		ldrh	fp, [r4, #194]
 8659 4c94 0B005CE1 		cmp	ip, fp
 8660 4c98 7901000A 		beq	.L782
 8661              	.L710:
3404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 8662              		.loc 1 3404 0 is_stmt 1
 8663 4c9c 4010A0E3 		mov	r1, #64
 8664 4ca0 0020A0E3 		mov	r2, #0
 8665 4ca4 A0089FE5 		ldr	r0, .L791+20
 8666 4ca8 FEFFFFEB 		bl	_txe_event_flags_set
3407:../uvc.c      ****         CyU3PThreadRelinquish ();
 8667              		.loc 1 3407 0
 8668 4cac FEFFFFEB 		bl	_txe_thread_relinquish
3408:../uvc.c      ****     }
 8669              		.loc 1 3408 0
 8670 4cb0 E7FFFFEA 		b	.L707
 8671              	.LVL746:
 8672              	.L761:
 8673              	.LBB284:
 8674              	.LBB282:
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 8675              		.loc 1 2646 0
 8676 4cb4 0400A0E3 		mov	r0, #4
 8677              	.LVL747:
 8678 4cb8 04199FE5 		ldr	r1, .L791+140
 8679 4cbc FEFFFFEB 		bl	CyU3PDebugPrint
 8680              	.LVL748:
 8681              	.L663:
 8682              	.LBB240:
 8683              	.LBB241:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8684              		.loc 1 2061 0
 8685 4cc0 00199FE5 		ldr	r1, .L791+144
 8686 4cc4 0400A0E3 		mov	r0, #4
 8687 4cc8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8688              		.loc 1 2062 0
 8689 4ccc FA0FA0E3 		mov	r0, #1000
 8690 4cd0 FEFFFFEB 		bl	_tx_thread_sleep
 8691 4cd4 F9FFFFEA 		b	.L663
 8692              	.LVL749:
 8693              	.L763:
 8694              	.LBE241:
 8695              	.LBE240:
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 8696              		.loc 1 2677 0
 8697 4cd8 0400A0E3 		mov	r0, #4
 8698              	.LVL750:
 8699 4cdc E8189FE5 		ldr	r1, .L791+148
 8700 4ce0 FEFFFFEB 		bl	CyU3PDebugPrint
 8701              	.LVL751:
 8702              	.L667:
 8703              	.LBB242:
 8704              	.LBB243:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8705              		.loc 1 2061 0
 8706 4ce4 DC189FE5 		ldr	r1, .L791+144
 8707 4ce8 0400A0E3 		mov	r0, #4
 8708 4cec FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8709              		.loc 1 2062 0
 8710 4cf0 FA0FA0E3 		mov	r0, #1000
 8711 4cf4 FEFFFFEB 		bl	_tx_thread_sleep
 8712 4cf8 F9FFFFEA 		b	.L667
 8713              	.LVL752:
 8714              	.L762:
 8715              	.LBE243:
 8716              	.LBE242:
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 8717              		.loc 1 2668 0
 8718 4cfc 0400A0E3 		mov	r0, #4
 8719              	.LVL753:
 8720 4d00 C8189FE5 		ldr	r1, .L791+152
 8721 4d04 FEFFFFEB 		bl	CyU3PDebugPrint
 8722              	.LVL754:
 8723              	.L665:
 8724              	.LBB244:
 8725              	.LBB245:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8726              		.loc 1 2061 0
 8727 4d08 B8189FE5 		ldr	r1, .L791+144
 8728 4d0c 0400A0E3 		mov	r0, #4
 8729 4d10 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8730              		.loc 1 2062 0
 8731 4d14 FA0FA0E3 		mov	r0, #1000
 8732 4d18 FEFFFFEB 		bl	_tx_thread_sleep
 8733 4d1c F9FFFFEA 		b	.L665
 8734              	.LVL755:
 8735              	.L764:
 8736              	.LBE245:
 8737              	.LBE244:
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 8738              		.loc 1 2683 0
 8739 4d20 0400A0E3 		mov	r0, #4
 8740              	.LVL756:
 8741 4d24 A8189FE5 		ldr	r1, .L791+156
 8742 4d28 FEFFFFEB 		bl	CyU3PDebugPrint
 8743              	.LVL757:
 8744              	.L669:
 8745              	.LBB246:
 8746              	.LBB247:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8747              		.loc 1 2061 0
 8748 4d2c 94189FE5 		ldr	r1, .L791+144
 8749 4d30 0400A0E3 		mov	r0, #4
 8750 4d34 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8751              		.loc 1 2062 0
 8752 4d38 FA0FA0E3 		mov	r0, #1000
 8753 4d3c FEFFFFEB 		bl	_tx_thread_sleep
 8754 4d40 F9FFFFEA 		b	.L669
 8755              	.LVL758:
 8756              	.L709:
 8757              	.LBE247:
 8758              	.LBE246:
 8759              	.LBE282:
 8760              	.LBE284:
3259:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 8761              		.loc 1 3259 0
 8762 4d44 00089FE5 		ldr	r0, .L791+20
 8763 4d48 0210A0E3 		mov	r1, #2
 8764 4d4c 0320A0E3 		mov	r2, #3
 8765 4d50 CC308DE2 		add	r3, sp, #204
 8766 4d54 00608DE5 		str	r6, [sp, #0]
 8767 4d58 FEFFFFEB 		bl	_txe_event_flags_get
 8768 4d5c 000050E3 		cmp	r0, #0
 8769 4d60 2D00001A 		bne	.L732
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8770              		.loc 1 3262 0
 8771 4d64 2910D4E5 		ldrb	r1, [r4, #41]	@ zero_extendqisi2
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8772              		.loc 1 3276 0
 8773 4d68 C42094E5 		ldr	r2, [r4, #196]
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8774              		.loc 1 3262 0
 8775 4d6c 7F9001E2 		and	r9, r1, #127
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8776              		.loc 1 3263 0
 8777 4d70 047089E3 		orr	r7, r9, #4
 8778              	.LVL759:
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8779              		.loc 1 3276 0
 8780 4d74 000052E3 		cmp	r2, #0
3264:../uvc.c      ****             	hitFV     = CyFalse;
 8781              		.loc 1 3264 0
 8782 4d78 BC6084E5 		str	r6, [r4, #188]
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8783              		.loc 1 3263 0
 8784 4d7c 2970C4E5 		strb	r7, [r4, #41]
3265:../uvc.c      ****                 prodCount = 0;
 8785              		.loc 1 3265 0
 8786 4d80 B06CC4E1 		strh	r6, [r4, #192]	@ movhi
3272:../uvc.c      ****                 fb=0;
 8787              		.loc 1 3272 0
 8788 4d84 B46BC4E1 		strh	r6, [r4, #180]	@ movhi
3266:../uvc.c      ****                 consCount = 0;
 8789              		.loc 1 3266 0
 8790 4d88 B26CC4E1 		strh	r6, [r4, #194]	@ movhi
3273:../uvc.c      ****                 pb=0;
 8791              		.loc 1 3273 0
 8792 4d8c B66BC4E1 		strh	r6, [r4, #182]	@ movhi
3274:../uvc.c      ****                 pbc=0;
 8793              		.loc 1 3274 0
 8794 4d90 B86BC4E1 		strh	r6, [r4, #184]	@ movhi
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8795              		.loc 1 3276 0
 8796 4d94 0D00001A 		bne	.L733
3278:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8797              		.loc 1 3278 0
 8798 4d98 08089FE5 		ldr	r0, .L791+112
 8799 4d9c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8800              	.LVL760:
3279:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8801              		.loc 1 3279 0
 8802 4da0 007050E2 		subs	r7, r0, #0
 8803 4da4 0300001A 		bne	.L759
3285:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8804              		.loc 1 3285 0
 8805 4da8 8300A0E3 		mov	r0, #131
 8806              	.LVL761:
 8807 4dac FEFFFFEB 		bl	CyU3PUsbFlushEp
 8808              	.L736:
3297:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 8809              		.loc 1 3297 0
 8810 4db0 C46085E5 		str	r6, [r5, #196]
 8811 4db4 B8FFFFEA 		b	.L710
 8812              	.L759:
 8813              	.LBB285:
 8814              	.LBB286:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8815              		.loc 1 2061 0
 8816 4db8 08189FE5 		ldr	r1, .L791+144
 8817 4dbc 0400A0E3 		mov	r0, #4
 8818 4dc0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8819              		.loc 1 2062 0
 8820 4dc4 FA0FA0E3 		mov	r0, #1000
 8821 4dc8 FEFFFFEB 		bl	_tx_thread_sleep
 8822 4dcc F9FFFFEA 		b	.L759
 8823              	.LVL762:
 8824              	.L733:
 8825              	.LBE286:
 8826              	.LBE285:
3287:../uvc.c      ****                     apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT
 8827              		.loc 1 3287 0
 8828 4dd0 74079FE5 		ldr	r0, .L791+20
 8829 4dd4 011CA0E3 		mov	r1, #256
 8830 4dd8 0620A0E1 		mov	r2, r6
 8831 4ddc FEFFFFEB 		bl	_txe_event_flags_set
 8832              	.LVL763:
3288:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]&0x7F;
 8833              		.loc 1 3288 0
 8834 4de0 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
 8835 4de4 7FB00CE2 		and	fp, ip, #127
3289:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]|0x10;
 8836              		.loc 1 3289 0
 8837 4de8 10308BE3 		orr	r3, fp, #16
 8838 4dec 2930C4E5 		strb	r3, [r4, #41]
3290:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8839              		.loc 1 3290 0
 8840 4df0 007050E2 		subs	r7, r0, #0
 8841 4df4 0300000A 		beq	.L737
3292:../uvc.c      ****                         CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus)
 8842              		.loc 1 3292 0
 8843 4df8 0400A0E3 		mov	r0, #4
 8844              	.LVL764:
 8845 4dfc D4179FE5 		ldr	r1, .L791+160
 8846 4e00 0720A0E1 		mov	r2, r7
 8847 4e04 FEFFFFEB 		bl	CyU3PDebugPrint
 8848              	.L737:
3294:../uvc.c      ****                     CyU3PDebugPrint (4, "clear feature stream set %x\n", apiRetStatus);
 8849              		.loc 1 3294 0
 8850 4e08 CC179FE5 		ldr	r1, .L791+164
 8851 4e0c 0720A0E1 		mov	r2, r7
 8852 4e10 0400A0E3 		mov	r0, #4
 8853 4e14 FEFFFFEB 		bl	CyU3PDebugPrint
 8854 4e18 E4FFFFEA 		b	.L736
 8855              	.L732:
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8856              		.loc 1 3320 0
 8857 4e1c 2920D4E5 		ldrb	r2, [r4, #41]	@ zero_extendqisi2
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8858              		.loc 1 3322 0
 8859 4e20 B8179FE5 		ldr	r1, .L791+168
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8860              		.loc 1 3320 0
 8861 4e24 7F0002E2 		and	r0, r2, #127
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
 8862              		.loc 1 3321 0
 8863 4e28 20E080E3 		orr	lr, r0, #32
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8864              		.loc 1 3322 0
 8865 4e2c 0720A0E1 		mov	r2, r7
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
 8866              		.loc 1 3321 0
 8867 4e30 29E0C4E5 		strb	lr, [r4, #41]
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8868              		.loc 1 3322 0
 8869 4e34 0400A0E3 		mov	r0, #4
 8870 4e38 FEFFFFEB 		bl	CyU3PDebugPrint
3323:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
 8871              		.loc 1 3323 0
 8872 4e3c 08079FE5 		ldr	r0, .L791+20
 8873 4e40 011CA0E3 		mov	r1, #256
 8874 4e44 0220A0E3 		mov	r2, #2
 8875 4e48 CC308DE2 		add	r3, sp, #204
 8876 4e4c 00608DE5 		str	r6, [sp, #0]
 8877 4e50 FEFFFFEB 		bl	_txe_event_flags_get
 8878 4e54 000050E3 		cmp	r0, #0
 8879 4e58 6500001A 		bne	.L738
3325:../uvc.c      ****                     		CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 8880              		.loc 1 3325 0
 8881 4e5c 0110A0E3 		mov	r1, #1
 8882 4e60 0620A0E1 		mov	r2, r6
 8883 4e64 E0069FE5 		ldr	r0, .L791+20
 8884 4e68 FEFFFFEB 		bl	_txe_event_flags_set
 8885              	.L739:
3332:../uvc.c      ****             	CyU3PDebugPrint (4, "post wait stream set %x\n", apiRetStatus);
 8886              		.loc 1 3332 0
 8887 4e6c 0720A0E1 		mov	r2, r7
 8888 4e70 6C179FE5 		ldr	r1, .L791+172
 8889 4e74 0400A0E3 		mov	r0, #4
 8890 4e78 FEFFFFEB 		bl	CyU3PDebugPrint
3333:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8891              		.loc 1 3333 0
 8892 4e7c 0010A0E3 		mov	r1, #0
 8893 4e80 20079FE5 		ldr	r0, .L791+112
 8894 4e84 0120A0E1 		mov	r2, r1
 8895 4e88 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8896              	.LVL765:
3334:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8897              		.loc 1 3334 0
 8898 4e8c 007050E2 		subs	r7, r0, #0
 8899 4e90 4D00001A 		bne	.L783
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8900              		.loc 1 3340 0
 8901 4e94 29B0D5E5 		ldrb	fp, [r5, #41]	@ zero_extendqisi2
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8902              		.loc 1 3343 0
 8903 4e98 A81095E5 		ldr	r1, [r5, #168]
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8904              		.loc 1 3340 0
 8905 4e9c 7F300BE2 		and	r3, fp, #127
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8906              		.loc 1 3341 0
 8907 4ea0 089083E3 		orr	r9, r3, #8
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8908              		.loc 1 3343 0
 8909 4ea4 000051E3 		cmp	r1, #0
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8910              		.loc 1 3341 0
 8911 4ea8 2990C5E5 		strb	r9, [r5, #41]
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8912              		.loc 1 3343 0
 8913 4eac 3500001A 		bne	.L742
 8914              	.LVL766:
 8915              	.LBB287:
 8916              	.LBB289:
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8917              		.loc 1 3002 0
 8918 4eb0 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
 8919 4eb4 030053E3 		cmp	r3, #3
 8920 4eb8 2B00000A 		beq	.L784
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8921              		.loc 1 3007 0
 8922 4ebc 020053E3 		cmp	r3, #2
 8923 4ec0 0D00000A 		beq	.L785
 8924              	.LVL767:
 8925              	.L745:
 8926              	.LBE289:
 8927              	.LBE287:
3391:../uvc.c      ****                     gpif_initialized = CyTrue;
 8928              		.loc 1 3391 0
 8929 4ec4 01C0A0E3 		mov	ip, #1
 8930 4ec8 A8C085E5 		str	ip, [r5, #168]
3393:../uvc.c      ****                     CyU3PThreadSleep(200);
 8931              		.loc 1 3393 0
 8932 4ecc C800A0E3 		mov	r0, #200
 8933 4ed0 FEFFFFEB 		bl	_tx_thread_sleep
 8934 4ed4 70FFFFEA 		b	.L710
 8935              	.LVL768:
 8936              	.L706:
 8937              	.LBB295:
 8938              	.LBB236:
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8939              		.loc 1 2977 0
 8940 4ed8 0400A0E3 		mov	r0, #4
 8941              	.LVL769:
 8942 4edc 04179FE5 		ldr	r1, .L791+176
 8943 4ee0 FEFFFFEB 		bl	CyU3PDebugPrint
 8944              	.LVL770:
 8945              	.L708:
 8946              	.LBB238:
 8947              	.LBB239:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8948              		.loc 1 2061 0
 8949 4ee4 DC169FE5 		ldr	r1, .L791+144
 8950 4ee8 0400A0E3 		mov	r0, #4
 8951 4eec FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8952              		.loc 1 2062 0
 8953 4ef0 FA0FA0E3 		mov	r0, #1000
 8954 4ef4 FEFFFFEB 		bl	_tx_thread_sleep
 8955 4ef8 F9FFFFEA 		b	.L708
 8956              	.LVL771:
 8957              	.L785:
 8958              	.LBE239:
 8959              	.LBE238:
 8960              	.LBE236:
 8961              	.LBE295:
 8962              	.LBB296:
 8963              	.LBB288:
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8964              		.loc 1 3009 0
 8965 4efc E8169FE5 		ldr	r1, .L791+180
 8966 4f00 0100A0E3 		mov	r0, #1
 8967              	.LVL772:
 8968 4f04 FEFFFFEB 		bl	CyU3PDebugPrint
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8969              		.loc 1 3010 0
 8970 4f08 E0069FE5 		ldr	r0, .L791+184
 8971 4f0c FEFFFFEB 		bl	CyU3PGpifLoad
 8972 4f10 0020A0E1 		mov	r2, r0
 8973              	.LVL773:
 8974              	.L744:
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8975              		.loc 1 3012 0
 8976 4f14 000052E3 		cmp	r2, #0
 8977 4f18 2200001A 		bne	.L786
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8978              		.loc 1 3020 0
 8979 4f1c C830D5E5 		ldrb	r3, [r5, #200]	@ zero_extendqisi2
 8980 4f20 030053E3 		cmp	r3, #3
 8981 4f24 0100000A 		beq	.L760
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8982              		.loc 1 3024 0
 8983 4f28 020053E3 		cmp	r3, #2
 8984 4f2c E4FFFF1A 		bne	.L745
 8985              	.L760:
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8986              		.loc 1 3026 0
 8987 4f30 0200A0E1 		mov	r0, r2
 8988              	.LVL774:
 8989 4f34 0210A0E1 		mov	r1, r2
 8990 4f38 FEFFFFEB 		bl	CyU3PGpifSMStart
 8991              	.LVL775:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8992              		.loc 1 3028 0
 8993 4f3c 000050E3 		cmp	r0, #0
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8994              		.loc 1 3026 0
 8995 4f40 0020A0E1 		mov	r2, r0
 8996              	.LVL776:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8997              		.loc 1 3028 0
 8998 4f44 DEFFFF0A 		beq	.L745
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8999              		.loc 1 3031 0
 9000 4f48 0400A0E3 		mov	r0, #4
 9001              	.LVL777:
 9002 4f4c A0169FE5 		ldr	r1, .L791+188
 9003 4f50 FEFFFFEB 		bl	CyU3PDebugPrint
 9004              	.LVL778:
 9005              	.L750:
 9006              	.LBB290:
 9007              	.LBB291:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9008              		.loc 1 2061 0
 9009 4f54 6C169FE5 		ldr	r1, .L791+144
 9010 4f58 0400A0E3 		mov	r0, #4
 9011 4f5c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9012              		.loc 1 2062 0
 9013 4f60 FA0FA0E3 		mov	r0, #1000
 9014 4f64 FEFFFFEB 		bl	_tx_thread_sleep
 9015 4f68 F9FFFFEA 		b	.L750
 9016              	.LVL779:
 9017              	.L784:
 9018              	.LBE291:
 9019              	.LBE290:
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 9020              		.loc 1 3004 0
 9021 4f6c 84169FE5 		ldr	r1, .L791+192
 9022 4f70 0100A0E3 		mov	r0, #1
 9023 4f74 FEFFFFEB 		bl	CyU3PDebugPrint
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 9024              		.loc 1 3005 0
 9025 4f78 7C069FE5 		ldr	r0, .L791+196
 9026 4f7c FEFFFFEB 		bl	CyU3PGpifLoad
 9027 4f80 0020A0E1 		mov	r2, r0
 9028              	.LVL780:
 9029 4f84 E2FFFFEA 		b	.L744
 9030              	.LVL781:
 9031              	.L742:
 9032              	.LBE288:
 9033              	.LBE296:
3400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 9034              		.loc 1 3400 0
 9035 4f88 10069FE5 		ldr	r0, .L791+104
 9036              	.LVL782:
 9037 4f8c 02E0A0E3 		mov	lr, #2
 9038 4f90 0710A0E1 		mov	r1, r7
 9039 4f94 0020A0E1 		mov	r2, r0
 9040 4f98 0730A0E1 		mov	r3, r7
 9041 4f9c 00E08DE5 		str	lr, [sp, #0]
 9042 4fa0 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 9043 4fa4 3CFFFFEA 		b	.L710
 9044              	.LVL783:
 9045              	.L786:
 9046              	.LBB297:
 9047              	.LBB294:
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 9048              		.loc 1 3015 0
 9049 4fa8 0400A0E3 		mov	r0, #4
 9050              	.LVL784:
 9051 4fac 4C169FE5 		ldr	r1, .L791+200
 9052 4fb0 FEFFFFEB 		bl	CyU3PDebugPrint
 9053              	.LVL785:
 9054              	.L747:
 9055              	.LBB292:
 9056              	.LBB293:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9057              		.loc 1 2061 0
 9058 4fb4 0C169FE5 		ldr	r1, .L791+144
 9059 4fb8 0400A0E3 		mov	r0, #4
 9060 4fbc FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9061              		.loc 1 2062 0
 9062 4fc0 FA0FA0E3 		mov	r0, #1000
 9063 4fc4 FEFFFFEB 		bl	_tx_thread_sleep
 9064 4fc8 F9FFFFEA 		b	.L747
 9065              	.L783:
 9066              	.LBE293:
 9067              	.LBE292:
 9068              	.LBE294:
 9069              	.LBE297:
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 9070              		.loc 1 3337 0
 9071 4fcc 0400A0E3 		mov	r0, #4
 9072 4fd0 2C169FE5 		ldr	r1, .L791+204
 9073 4fd4 0720A0E1 		mov	r2, r7
 9074 4fd8 FEFFFFEB 		bl	CyU3PDebugPrint
 9075              	.L741:
 9076              	.LBB298:
 9077              	.LBB299:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9078              		.loc 1 2061 0
 9079 4fdc E4159FE5 		ldr	r1, .L791+144
 9080 4fe0 0400A0E3 		mov	r0, #4
 9081 4fe4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9082              		.loc 1 2062 0
 9083 4fe8 FA0FA0E3 		mov	r0, #1000
 9084 4fec FEFFFFEB 		bl	_tx_thread_sleep
 9085 4ff0 F9FFFFEA 		b	.L741
 9086              	.L738:
 9087              	.LBE299:
 9088              	.LBE298:
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
 9089              		.loc 1 3328 0
 9090 4ff4 0110A0E3 		mov	r1, #1
 9091 4ff8 0220A0E3 		mov	r2, #2
 9092 4ffc CC308DE2 		add	r3, sp, #204
 9093 5000 44059FE5 		ldr	r0, .L791+20
 9094 5004 00A08DE5 		str	sl, [sp, #0]
 9095 5008 FEFFFFEB 		bl	_txe_event_flags_get
 9096 500c 96FFFFEA 		b	.L739
 9097              	.LVL786:
 9098              	.L781:
 9099              	.LBB300:
 9100              	.LBB283:
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 9101              		.loc 1 2952 0
 9102 5010 0400A0E3 		mov	r0, #4
 9103              	.LVL787:
 9104 5014 EC159FE5 		ldr	r1, .L791+208
 9105 5018 FEFFFFEB 		bl	CyU3PDebugPrint
 9106              	.LVL788:
 9107              	.L703:
 9108              	.LBB248:
 9109              	.LBB249:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9110              		.loc 1 2061 0
 9111 501c A4159FE5 		ldr	r1, .L791+144
 9112 5020 0400A0E3 		mov	r0, #4
 9113 5024 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9114              		.loc 1 2062 0
 9115 5028 FA0FA0E3 		mov	r0, #1000
 9116 502c FEFFFFEB 		bl	_tx_thread_sleep
 9117 5030 F9FFFFEA 		b	.L703
 9118              	.L780:
 9119              	.LBE249:
 9120              	.LBE248:
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
 9121              		.loc 1 2943 0
 9122 5034 040080E2 		add	r0, r0, #4
 9123 5038 CC159FE5 		ldr	r1, .L791+212
 9124 503c FEFFFFEB 		bl	CyU3PDebugPrint
 9125              	.LVL789:
 9126              	.L701:
 9127              	.LBB250:
 9128              	.LBB251:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9129              		.loc 1 2061 0
 9130 5040 80159FE5 		ldr	r1, .L791+144
 9131 5044 0400A0E3 		mov	r0, #4
 9132 5048 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9133              		.loc 1 2062 0
 9134 504c FA0FA0E3 		mov	r0, #1000
 9135 5050 FEFFFFEB 		bl	_tx_thread_sleep
 9136 5054 F9FFFFEA 		b	.L701
 9137              	.LVL790:
 9138              	.L779:
 9139              	.LBE251:
 9140              	.LBE250:
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
 9141              		.loc 1 2936 0
 9142 5058 0400A0E3 		mov	r0, #4
 9143              	.LVL791:
 9144 505c AC159FE5 		ldr	r1, .L791+216
 9145 5060 FEFFFFEB 		bl	CyU3PDebugPrint
 9146              	.LVL792:
 9147              	.L699:
 9148              	.LBB252:
 9149              	.LBB253:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9150              		.loc 1 2061 0
 9151 5064 5C159FE5 		ldr	r1, .L791+144
 9152 5068 0400A0E3 		mov	r0, #4
 9153 506c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9154              		.loc 1 2062 0
 9155 5070 FA0FA0E3 		mov	r0, #1000
 9156 5074 FEFFFFEB 		bl	_tx_thread_sleep
 9157 5078 F9FFFFEA 		b	.L699
 9158              	.LVL793:
 9159              	.L778:
 9160              	.LBE253:
 9161              	.LBE252:
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
 9162              		.loc 1 2917 0
 9163 507c 0400A0E3 		mov	r0, #4
 9164              	.LVL794:
 9165 5080 8C159FE5 		ldr	r1, .L791+220
 9166 5084 0320A0E1 		mov	r2, r3
 9167 5088 FEFFFFEB 		bl	CyU3PDebugPrint
 9168              	.LVL795:
 9169              	.L697:
 9170              	.LBB254:
 9171              	.LBB255:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9172              		.loc 1 2061 0
 9173 508c 34159FE5 		ldr	r1, .L791+144
 9174 5090 0400A0E3 		mov	r0, #4
 9175 5094 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9176              		.loc 1 2062 0
 9177 5098 FA0FA0E3 		mov	r0, #1000
 9178 509c FEFFFFEB 		bl	_tx_thread_sleep
 9179 50a0 F9FFFFEA 		b	.L697
 9180              	.LVL796:
 9181              	.L777:
 9182              	.LBE255:
 9183              	.LBE254:
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
 9184              		.loc 1 2910 0
 9185 50a4 0400A0E3 		mov	r0, #4
 9186              	.LVL797:
 9187 50a8 68159FE5 		ldr	r1, .L791+224
 9188 50ac FEFFFFEB 		bl	CyU3PDebugPrint
 9189              	.LVL798:
 9190              	.L695:
 9191              	.LBB256:
 9192              	.LBB257:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9193              		.loc 1 2061 0
 9194 50b0 10159FE5 		ldr	r1, .L791+144
 9195 50b4 0400A0E3 		mov	r0, #4
 9196 50b8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9197              		.loc 1 2062 0
 9198 50bc FA0FA0E3 		mov	r0, #1000
 9199 50c0 FEFFFFEB 		bl	_tx_thread_sleep
 9200 50c4 F9FFFFEA 		b	.L695
 9201              	.LVL799:
 9202              	.L776:
 9203              	.LBE257:
 9204              	.LBE256:
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
 9205              		.loc 1 2891 0
 9206 50c8 0400A0E3 		mov	r0, #4
 9207              	.LVL800:
 9208 50cc 48159FE5 		ldr	r1, .L791+228
 9209 50d0 0320A0E1 		mov	r2, r3
 9210 50d4 FEFFFFEB 		bl	CyU3PDebugPrint
 9211              	.LVL801:
 9212              	.L693:
 9213              	.LBB258:
 9214              	.LBB259:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9215              		.loc 1 2061 0
 9216 50d8 E8149FE5 		ldr	r1, .L791+144
 9217 50dc 0400A0E3 		mov	r0, #4
 9218 50e0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9219              		.loc 1 2062 0
 9220 50e4 FA0FA0E3 		mov	r0, #1000
 9221 50e8 FEFFFFEB 		bl	_tx_thread_sleep
 9222 50ec F9FFFFEA 		b	.L693
 9223              	.LVL802:
 9224              	.L775:
 9225              	.LBE259:
 9226              	.LBE258:
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
 9227              		.loc 1 2882 0
 9228 50f0 0400A0E3 		mov	r0, #4
 9229              	.LVL803:
 9230 50f4 24159FE5 		ldr	r1, .L791+232
 9231 50f8 FEFFFFEB 		bl	CyU3PDebugPrint
 9232              	.LVL804:
 9233              	.L691:
 9234              	.LBB260:
 9235              	.LBB261:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9236              		.loc 1 2061 0
 9237 50fc C4149FE5 		ldr	r1, .L791+144
 9238 5100 0400A0E3 		mov	r0, #4
 9239 5104 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9240              		.loc 1 2062 0
 9241 5108 FA0FA0E3 		mov	r0, #1000
 9242 510c FEFFFFEB 		bl	_tx_thread_sleep
 9243 5110 F9FFFFEA 		b	.L691
 9244              	.LVL805:
 9245              	.L774:
 9246              	.LBE261:
 9247              	.LBE260:
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 9248              		.loc 1 2861 0
 9249 5114 0400A0E3 		mov	r0, #4
 9250              	.LVL806:
 9251 5118 04159FE5 		ldr	r1, .L791+236
 9252 511c FEFFFFEB 		bl	CyU3PDebugPrint
 9253              	.LVL807:
 9254              	.L689:
 9255              	.LBB262:
 9256              	.LBB263:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9257              		.loc 1 2061 0
 9258 5120 A0149FE5 		ldr	r1, .L791+144
 9259 5124 0400A0E3 		mov	r0, #4
 9260 5128 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9261              		.loc 1 2062 0
 9262 512c FA0FA0E3 		mov	r0, #1000
 9263 5130 FEFFFFEB 		bl	_tx_thread_sleep
 9264 5134 F9FFFFEA 		b	.L689
 9265              	.LVL808:
 9266              	.L773:
 9267              	.LBE263:
 9268              	.LBE262:
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 9269              		.loc 1 2837 0
 9270 5138 040080E2 		add	r0, r0, #4
 9271 513c E4149FE5 		ldr	r1, .L791+240
 9272 5140 FEFFFFEB 		bl	CyU3PDebugPrint
 9273              	.LVL809:
 9274              	.L687:
 9275              	.LBB264:
 9276              	.LBB265:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9277              		.loc 1 2061 0
 9278 5144 7C149FE5 		ldr	r1, .L791+144
 9279 5148 0400A0E3 		mov	r0, #4
 9280 514c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9281              		.loc 1 2062 0
 9282 5150 FA0FA0E3 		mov	r0, #1000
 9283 5154 FEFFFFEB 		bl	_tx_thread_sleep
 9284 5158 F9FFFFEA 		b	.L687
 9285              	.LVL810:
 9286              	.L772:
 9287              	.LBE265:
 9288              	.LBE264:
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 9289              		.loc 1 2830 0
 9290 515c 0400A0E3 		mov	r0, #4
 9291 5160 C4149FE5 		ldr	r1, .L791+244
 9292 5164 0620A0E1 		mov	r2, r6
 9293 5168 FEFFFFEB 		bl	CyU3PDebugPrint
 9294              	.L685:
 9295              	.LBB266:
 9296              	.LBB267:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9297              		.loc 1 2061 0
 9298 516c 54149FE5 		ldr	r1, .L791+144
 9299 5170 0400A0E3 		mov	r0, #4
 9300 5174 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9301              		.loc 1 2062 0
 9302 5178 FA0FA0E3 		mov	r0, #1000
 9303 517c FEFFFFEB 		bl	_tx_thread_sleep
 9304 5180 F9FFFFEA 		b	.L685
 9305              	.LVL811:
 9306              	.L771:
 9307              	.LBE267:
 9308              	.LBE266:
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 9309              		.loc 1 2809 0
 9310 5184 0400A0E3 		mov	r0, #4
 9311              	.LVL812:
 9312 5188 58149FE5 		ldr	r1, .L791+176
 9313 518c 0320A0E1 		mov	r2, r3
 9314 5190 FEFFFFEB 		bl	CyU3PDebugPrint
 9315              	.LVL813:
 9316              	.L683:
 9317              	.LBB268:
 9318              	.LBB269:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9319              		.loc 1 2061 0
 9320 5194 2C149FE5 		ldr	r1, .L791+144
 9321 5198 0400A0E3 		mov	r0, #4
 9322 519c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9323              		.loc 1 2062 0
 9324 51a0 FA0FA0E3 		mov	r0, #1000
 9325 51a4 FEFFFFEB 		bl	_tx_thread_sleep
 9326 51a8 F9FFFFEA 		b	.L683
 9327              	.LVL814:
 9328              	.L770:
 9329              	.LBE269:
 9330              	.LBE268:
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 9331              		.loc 1 2764 0
 9332 51ac 0400A0E3 		mov	r0, #4
 9333              	.LVL815:
 9334 51b0 78149FE5 		ldr	r1, .L791+248
 9335 51b4 FEFFFFEB 		bl	CyU3PDebugPrint
 9336              	.LVL816:
 9337              	.L681:
 9338              	.LBB270:
 9339              	.LBB271:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9340              		.loc 1 2061 0
 9341 51b8 08149FE5 		ldr	r1, .L791+144
 9342 51bc 0400A0E3 		mov	r0, #4
 9343 51c0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9344              		.loc 1 2062 0
 9345 51c4 FA0FA0E3 		mov	r0, #1000
 9346 51c8 FEFFFFEB 		bl	_tx_thread_sleep
 9347 51cc F9FFFFEA 		b	.L681
 9348              	.LVL817:
 9349              	.L769:
 9350              	.LBE271:
 9351              	.LBE270:
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 9352              		.loc 1 2743 0
 9353 51d0 0400A0E3 		mov	r0, #4
 9354              	.LVL818:
 9355 51d4 58149FE5 		ldr	r1, .L791+252
 9356 51d8 FEFFFFEB 		bl	CyU3PDebugPrint
 9357              	.LVL819:
 9358              	.L679:
 9359              	.LBB272:
 9360              	.LBB273:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9361              		.loc 1 2061 0
 9362 51dc E4139FE5 		ldr	r1, .L791+144
 9363 51e0 0400A0E3 		mov	r0, #4
 9364 51e4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9365              		.loc 1 2062 0
 9366 51e8 FA0FA0E3 		mov	r0, #1000
 9367 51ec FEFFFFEB 		bl	_tx_thread_sleep
 9368 51f0 F9FFFFEA 		b	.L679
 9369              	.LVL820:
 9370              	.L768:
 9371              	.LBE273:
 9372              	.LBE272:
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 9373              		.loc 1 2730 0
 9374 51f4 0400A0E3 		mov	r0, #4
 9375              	.LVL821:
 9376 51f8 38149FE5 		ldr	r1, .L791+256
 9377 51fc FEFFFFEB 		bl	CyU3PDebugPrint
 9378              	.LVL822:
 9379              	.L677:
 9380              	.LBB274:
 9381              	.LBB275:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9382              		.loc 1 2061 0
 9383 5200 C0139FE5 		ldr	r1, .L791+144
 9384 5204 0400A0E3 		mov	r0, #4
 9385 5208 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9386              		.loc 1 2062 0
 9387 520c FA0FA0E3 		mov	r0, #1000
 9388 5210 FEFFFFEB 		bl	_tx_thread_sleep
 9389 5214 F9FFFFEA 		b	.L677
 9390              	.LVL823:
 9391              	.L766:
 9392              	.LBE275:
 9393              	.LBE274:
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 9394              		.loc 1 2702 0
 9395 5218 0400A0E3 		mov	r0, #4
 9396              	.LVL824:
 9397 521c 18149FE5 		ldr	r1, .L791+260
 9398 5220 FEFFFFEB 		bl	CyU3PDebugPrint
 9399              	.LVL825:
 9400              	.L673:
 9401              	.LBB276:
 9402              	.LBB277:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9403              		.loc 1 2061 0
 9404 5224 9C139FE5 		ldr	r1, .L791+144
 9405 5228 0400A0E3 		mov	r0, #4
 9406 522c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9407              		.loc 1 2062 0
 9408 5230 FA0FA0E3 		mov	r0, #1000
 9409 5234 FEFFFFEB 		bl	_tx_thread_sleep
 9410 5238 F9FFFFEA 		b	.L673
 9411              	.LVL826:
 9412              	.L765:
 9413              	.LBE277:
 9414              	.LBE276:
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 9415              		.loc 1 2689 0
 9416 523c 0400A0E3 		mov	r0, #4
 9417              	.LVL827:
 9418 5240 F8139FE5 		ldr	r1, .L791+264
 9419 5244 FEFFFFEB 		bl	CyU3PDebugPrint
 9420              	.LVL828:
 9421              	.L671:
 9422              	.LBB278:
 9423              	.LBB279:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9424              		.loc 1 2061 0
 9425 5248 78139FE5 		ldr	r1, .L791+144
 9426 524c 0400A0E3 		mov	r0, #4
 9427 5250 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9428              		.loc 1 2062 0
 9429 5254 FA0FA0E3 		mov	r0, #1000
 9430 5258 FEFFFFEB 		bl	_tx_thread_sleep
 9431 525c F9FFFFEA 		b	.L671
 9432              	.LVL829:
 9433              	.L767:
 9434              	.LBE279:
 9435              	.LBE278:
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 9436              		.loc 1 2716 0
 9437 5260 0400A0E3 		mov	r0, #4
 9438              	.LVL830:
 9439 5264 D8139FE5 		ldr	r1, .L791+268
 9440 5268 FEFFFFEB 		bl	CyU3PDebugPrint
 9441              	.LVL831:
 9442              	.L675:
 9443              	.LBB280:
 9444              	.LBB281:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9445              		.loc 1 2061 0
 9446 526c 54139FE5 		ldr	r1, .L791+144
 9447 5270 0400A0E3 		mov	r0, #4
 9448 5274 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9449              		.loc 1 2062 0
 9450 5278 FA0FA0E3 		mov	r0, #1000
 9451 527c FEFFFFEB 		bl	_tx_thread_sleep
 9452 5280 F9FFFFEA 		b	.L675
 9453              	.LVL832:
 9454              	.L782:
 9455              	.LBE281:
 9456              	.LBE280:
 9457              	.LBE283:
 9458              	.LBE300:
3153:../uvc.c      ****             	debugData[0][0]++;
 9459              		.loc 1 3153 0
 9460 5284 28E0D4E5 		ldrb	lr, [r4, #40]	@ zero_extendqisi2
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 9461              		.loc 1 3154 0
 9462 5288 03C0E0E1 		mvn	ip, r3
 9463 528c 7D000CE2 		and	r0, ip, #125
 9464 5290 0030E0E1 		mvn	r3, r0
3153:../uvc.c      ****             	debugData[0][0]++;
 9465              		.loc 1 3153 0
 9466 5294 01908EE2 		add	r9, lr, #1
3158:../uvc.c      ****                 prodCount = 0;
 9467              		.loc 1 3158 0
 9468 5298 B06CC4E1 		strh	r6, [r4, #192]	@ movhi
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9469              		.loc 1 3173 0
 9470 529c 0010E0E3 		mvn	r1, #0
3159:../uvc.c      ****                 consCount = 0;
 9471              		.loc 1 3159 0
 9472 52a0 B26CC4E1 		strh	r6, [r4, #194]	@ movhi
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9473              		.loc 1 3173 0
 9474 52a4 EC029FE5 		ldr	r0, .L791+96
3153:../uvc.c      ****             	debugData[0][0]++;
 9475              		.loc 1 3153 0
 9476 52a8 2890C4E5 		strb	r9, [r4, #40]
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 9477              		.loc 1 3154 0
 9478 52ac 2930C4E5 		strb	r3, [r4, #41]
3155:../uvc.c      ****             	fb=0;
 9479              		.loc 1 3155 0
 9480 52b0 B46BC4E1 		strh	r6, [r4, #180]	@ movhi
3156:../uvc.c      ****             	pb=0;
 9481              		.loc 1 3156 0
 9482 52b4 B66BC4E1 		strh	r6, [r4, #182]	@ movhi
3157:../uvc.c      ****             	pbc=0;
 9483              		.loc 1 3157 0
 9484 52b8 B86BC4E1 		strh	r6, [r4, #184]	@ movhi
3160:../uvc.c      ****                 hitFV     = CyFalse;
 9485              		.loc 1 3160 0
 9486 52bc BC6084E5 		str	r6, [r4, #188]
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9487              		.loc 1 3173 0
 9488 52c0 FEFFFFEB 		bl	_txe_mutex_get
3174:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 9489              		.loc 1 3174 0
 9490 52c4 8114D8E5 		ldrb	r1, [r8, #1153]	@ zero_extendqisi2
 9491 52c8 012021E2 		eor	r2, r1, #1
 9492 52cc 8124C8E5 		strb	r2, [r8, #1153]
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9493              		.loc 1 3176 0
 9494 52d0 BA70D4E5 		ldrb	r7, [r4, #186]	@ zero_extendqisi2
 9495              	.LVL833:
 9496 52d4 F00057E3 		cmp	r7, #240
 9497 52d8 1A00000A 		beq	.L787
 9498              	.L711:
3184:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 9499              		.loc 1 3184 0
 9500 52dc BAB0D5E5 		ldrb	fp, [r5, #186]	@ zero_extendqisi2
 9501 52e0 FF005BE3 		cmp	fp, #255
 9502 52e4 3900000A 		beq	.L788
3196:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 9503              		.loc 1 3196 0
 9504 52e8 BA00D4E5 		ldrb	r0, [r4, #186]	@ zero_extendqisi2
 9505 52ec AA0050E3 		cmp	r0, #170
 9506 52f0 2800000A 		beq	.L789
 9507              	.L712:
3234:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 9508              		.loc 1 3234 0
 9509 52f4 9C029FE5 		ldr	r0, .L791+96
 9510 52f8 FEFFFFEB 		bl	_txe_mutex_put
3236:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 9511              		.loc 1 3236 0
 9512 52fc A4029FE5 		ldr	r0, .L791+112
 9513 5300 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 9514              	.LVL834:
3237:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9515              		.loc 1 3237 0
 9516 5304 002050E2 		subs	r2, r0, #0
 9517 5308 1900001A 		bne	.L790
3244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 9518              		.loc 1 3244 0
 9519 530c 0210A0E1 		mov	r1, r2
 9520 5310 90029FE5 		ldr	r0, .L791+112
 9521              	.LVL835:
 9522 5314 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 9523              	.LVL836:
3245:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9524              		.loc 1 3245 0
 9525 5318 007050E2 		subs	r7, r0, #0
 9526 531c 19FFFF0A 		beq	.L742
3247:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 9527              		.loc 1 3247 0
 9528 5320 0400A0E3 		mov	r0, #4
 9529              	.LVL837:
 9530 5324 1C139FE5 		ldr	r1, .L791+272
 9531 5328 0720A0E1 		mov	r2, r7
 9532 532c FEFFFFEB 		bl	CyU3PDebugPrint
 9533              	.L731:
 9534              	.LBB301:
 9535              	.LBB302:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9536              		.loc 1 2061 0
 9537 5330 90129FE5 		ldr	r1, .L791+144
 9538 5334 0400A0E3 		mov	r0, #4
 9539 5338 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9540              		.loc 1 2062 0
 9541 533c FA0FA0E3 		mov	r0, #1000
 9542 5340 FEFFFFEB 		bl	_tx_thread_sleep
 9543 5344 F9FFFFEA 		b	.L731
 9544              	.LVL838:
 9545              	.L787:
 9546              	.LBE302:
 9547              	.LBE301:
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9548              		.loc 1 3176 0 discriminator 1
 9549 5348 FC019FE5 		ldr	r0, .L791+20
 9550 534c 8010A0E3 		mov	r1, #128
 9551 5350 0320A0E3 		mov	r2, #3
 9552 5354 CC308DE2 		add	r3, sp, #204
 9553 5358 00608DE5 		str	r6, [sp, #0]
 9554 535c FEFFFFEB 		bl	_txe_event_flags_get
 9555 5360 000050E3 		cmp	r0, #0
3181:../uvc.c      ****                 		stiflag = 0xFF;
 9556              		.loc 1 3181 0 discriminator 1
 9557 5364 BAA0C405 		streqb	sl, [r4, #186]
3182:../uvc.c      ****                 		IMcount = 0;
 9558              		.loc 1 3182 0 discriminator 1
 9559 5368 A161C405 		streqb	r6, [r4, #417]
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9560              		.loc 1 3176 0 discriminator 1
 9561 536c E0FFFF0A 		beq	.L712
 9562 5370 D9FFFFEA 		b	.L711
 9563              	.LVL839:
 9564              	.L790:
3239:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 9565              		.loc 1 3239 0
 9566 5374 0400A0E3 		mov	r0, #4
 9567              	.LVL840:
 9568 5378 CC129FE5 		ldr	r1, .L791+276
 9569 537c FEFFFFEB 		bl	CyU3PDebugPrint
 9570              	.LVL841:
 9571              	.L729:
 9572              	.LBB303:
 9573              	.LBB304:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9574              		.loc 1 2061 0
 9575 5380 40129FE5 		ldr	r1, .L791+144
 9576 5384 0400A0E3 		mov	r0, #4
 9577 5388 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9578              		.loc 1 2062 0
 9579 538c FA0FA0E3 		mov	r0, #1000
 9580 5390 FEFFFFEB 		bl	_tx_thread_sleep
 9581 5394 F9FFFFEA 		b	.L729
 9582              	.L789:
 9583              	.LBE304:
 9584              	.LBE303:
3202:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 9585              		.loc 1 3202 0
 9586 5398 A1C1D4E5 		ldrb	ip, [r4, #417]	@ zero_extendqisi2
 9587 539c 01E08CE2 		add	lr, ip, #1
 9588 53a0 02005CE3 		cmp	ip, #2
 9589 53a4 A1E1C4E5 		strb	lr, [r4, #417]
 9590 53a8 D1FFFF9A 		bls	.L712
3204:../uvc.c      ****                     switch (setRes)
 9591              		.loc 1 3204 0
 9592 53ac 7D71D4E5 		ldrb	r7, [r4, #381]	@ zero_extendqisi2
 9593 53b0 01B047E2 		sub	fp, r7, #1
 9594 53b4 03005BE3 		cmp	fp, #3
 9595 53b8 0BF19F97 		ldrls	pc, [pc, fp, asl #2]
 9596 53bc 230000EA 		b	.L714
 9597              	.L719:
 9598 53c0 B0540000 		.word	.L715
 9599 53c4 F4540000 		.word	.L716
 9600 53c8 5C540000 		.word	.L717
 9601 53cc 00540000 		.word	.L718
 9602              	.L788:
3186:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 9603              		.loc 1 3186 0
 9604 53d0 A121D4E5 		ldrb	r2, [r4, #417]	@ zero_extendqisi2
 9605 53d4 017082E2 		add	r7, r2, #1
 9606 53d8 020052E3 		cmp	r2, #2
 9607 53dc A171C4E5 		strb	r7, [r4, #417]
 9608 53e0 C3FFFF9A 		bls	.L712
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9609              		.loc 1 3187 0
 9610 53e4 8194D8E5 		ldrb	r9, [r8, #1153]	@ zero_extendqisi2
3188:../uvc.c      ****                 		stiflag = 0x0F;
 9611              		.loc 1 3188 0
 9612 53e8 0F10A0E3 		mov	r1, #15
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9613              		.loc 1 3187 0
 9614 53ec 203089E3 		orr	r3, r9, #32
 9615 53f0 8134C8E5 		strb	r3, [r8, #1153]
3189:../uvc.c      ****                 		IMcount = 0;
 9616              		.loc 1 3189 0
 9617 53f4 A161C4E5 		strb	r6, [r4, #417]
3188:../uvc.c      ****                 		stiflag = 0x0F;
 9618              		.loc 1 3188 0
 9619 53f8 BA10C4E5 		strb	r1, [r4, #186]
 9620 53fc BCFFFFEA 		b	.L712
 9621              	.L718:
3222:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 9622              		.loc 1 3222 0
 9623 5400 D80095E5 		ldr	r0, [r5, #216]
 9624 5404 8DE4D8E5 		ldrb	lr, [r8, #1165]	@ zero_extendqisi2
 9625 5408 000050E3 		cmp	r0, #0
 9626 540c F400A003 		moveq	r0, #244
 9627 5410 7400A013 		movne	r0, #116
 9628 5414 0E2080E1 		orr	r2, r0, lr
 9629 5418 3010A0E3 		mov	r1, #48
 9630 541c 5230A0E3 		mov	r3, #82
 9631 5420 0100A0E3 		mov	r0, #1
 9632 5424 FEFFFFEB 		bl	SensorSetIrisControl
3224:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 9633              		.loc 1 3224 0
 9634 5428 D8C095E5 		ldr	ip, [r5, #216]
 9635 542c 8DB4D8E5 		ldrb	fp, [r8, #1165]	@ zero_extendqisi2
 9636 5430 00005CE3 		cmp	ip, #0
 9637 5434 F4C0A003 		moveq	ip, #244
 9638 5438 74C0A013 		movne	ip, #116
 9639 543c D83095E5 		ldr	r3, [r5, #216]
 9640 5440 0400A0E3 		mov	r0, #4
 9641 5444 04129FE5 		ldr	r1, .L791+280
 9642 5448 0B208CE1 		orr	r2, ip, fp
 9643 544c FEFFFFEB 		bl	CyU3PDebugPrint
 9644              	.L714:
3229:../uvc.c      ****                     IMcount = 0;
 9645              		.loc 1 3229 0
 9646 5450 A161C5E5 		strb	r6, [r5, #417]
3231:../uvc.c      ****                 	stiflag = 0x0;
 9647              		.loc 1 3231 0
 9648 5454 BA60C5E5 		strb	r6, [r5, #186]
 9649 5458 A5FFFFEA 		b	.L712
 9650              	.L717:
3217:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 9651              		.loc 1 3217 0
 9652 545c D81095E5 		ldr	r1, [r5, #216]
 9653 5460 8D34D8E5 		ldrb	r3, [r8, #1165]	@ zero_extendqisi2
 9654 5464 000051E3 		cmp	r1, #0
 9655 5468 C410A003 		moveq	r1, #196
 9656 546c 4410A013 		movne	r1, #68
 9657 5470 032081E1 		orr	r2, r1, r3
 9658 5474 0100A0E3 		mov	r0, #1
 9659 5478 3010A0E3 		mov	r1, #48
 9660 547c 5230A0E3 		mov	r3, #82
 9661 5480 FEFFFFEB 		bl	SensorSetIrisControl
3219:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 9662              		.loc 1 3219 0
 9663 5484 D89095E5 		ldr	r9, [r5, #216]
 9664 5488 8D24D8E5 		ldrb	r2, [r8, #1165]	@ zero_extendqisi2
 9665 548c 000059E3 		cmp	r9, #0
 9666 5490 C490A003 		moveq	r9, #196
 9667 5494 4490A013 		movne	r9, #68
 9668 5498 D83095E5 		ldr	r3, [r5, #216]
 9669 549c AC119FE5 		ldr	r1, .L791+280
 9670 54a0 022089E1 		orr	r2, r9, r2
 9671 54a4 0400A0E3 		mov	r0, #4
 9672 54a8 FEFFFFEB 		bl	CyU3PDebugPrint
3220:../uvc.c      ****                  		break;
 9673              		.loc 1 3220 0
 9674 54ac E7FFFFEA 		b	.L714
 9675              	.L715:
3207:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 9676              		.loc 1 3207 0
 9677 54b0 D82095E5 		ldr	r2, [r5, #216]
 9678 54b4 3010A0E3 		mov	r1, #48
 9679 54b8 000052E3 		cmp	r2, #0
 9680 54bc E420A003 		moveq	r2, #228
 9681 54c0 6420A013 		movne	r2, #100
 9682 54c4 5230A0E3 		mov	r3, #82
 9683 54c8 0100A0E3 		mov	r0, #1
 9684 54cc FEFFFFEB 		bl	SensorSetIrisControl
3209:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 9685              		.loc 1 3209 0
 9686 54d0 D82095E5 		ldr	r2, [r5, #216]
 9687 54d4 74119FE5 		ldr	r1, .L791+280
 9688 54d8 000052E3 		cmp	r2, #0
 9689 54dc D83095E5 		ldr	r3, [r5, #216]
 9690 54e0 E420A003 		moveq	r2, #228
 9691 54e4 6420A013 		movne	r2, #100
 9692 54e8 0400A0E3 		mov	r0, #4
 9693 54ec FEFFFFEB 		bl	CyU3PDebugPrint
3210:../uvc.c      ****                  		break;
 9694              		.loc 1 3210 0
 9695 54f0 D6FFFFEA 		b	.L714
 9696              	.L716:
3212:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 9697              		.loc 1 3212 0
 9698 54f4 D82095E5 		ldr	r2, [r5, #216]
 9699 54f8 3010A0E3 		mov	r1, #48
 9700 54fc 000052E3 		cmp	r2, #0
 9701 5500 D420A003 		moveq	r2, #212
 9702 5504 5420A013 		movne	r2, #84
 9703 5508 5230A0E3 		mov	r3, #82
 9704 550c 0100A0E3 		mov	r0, #1
 9705 5510 FEFFFFEB 		bl	SensorSetIrisControl
3214:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 9706              		.loc 1 3214 0
 9707 5514 D82095E5 		ldr	r2, [r5, #216]
 9708 5518 30119FE5 		ldr	r1, .L791+280
 9709 551c 000052E3 		cmp	r2, #0
 9710 5520 D83095E5 		ldr	r3, [r5, #216]
 9711 5524 D420A003 		moveq	r2, #212
 9712 5528 5420A013 		movne	r2, #84
 9713 552c 0400A0E3 		mov	r0, #4
 9714 5530 FEFFFFEB 		bl	CyU3PDebugPrint
3215:../uvc.c      ****                  		break;
 9715              		.loc 1 3215 0
 9716 5534 C5FFFFEA 		b	.L714
 9717              	.L792:
 9718              		.align	2
 9719              	.L791:
 9720 5538 B8090000 		.word	.LC56
 9721 553c 00C20100 		.word	115200
 9722 5540 D8090000 		.word	.LC57
 9723 5544 A0860100 		.word	100000
 9724 5548 F4090000 		.word	.LC58
 9725 554c 00000000 		.word	.LANCHOR0
 9726 5550 00000000 		.word	CyFxGpifCB
 9727 5554 88130000 		.word	5000
 9728 5558 00000000 		.word	CyFxUVCApplnUSBSetupCB
 9729 555c 00000000 		.word	CyFxUVCApplnUSBEventCB
 9730 5560 00000000 		.word	CyFxUSBDeviceDscr
 9731 5564 00000000 		.word	CyFxUSBDeviceDscrSS
 9732 5568 00000000 		.word	CyFxUSBDeviceQualDscr
 9733 556c 00000000 		.word	CyFxUSBBOSDscr
 9734 5570 00000000 		.word	CyFxUSBHSConfigDscr
 9735 5574 00000000 		.word	CyFxUSBFSConfigDscr
 9736 5578 00000000 		.word	CyFxUSBSSConfigDscr
 9737 557c 00000000 		.word	CyFxUSBStringLangIDDscr
 9738 5580 00000000 		.word	CyFxUSBManufactureDscr
 9739 5584 00000000 		.word	CyFxUSBProductDscr
 9740 5588 02030000 		.word	770
 9741 558c 013F0000 		.word	16129
 9742 5590 00000000 		.word	glChHandleInterStat
 9743 5594 00000000 		.word	glInterStaBuffer
 9744 5598 00000000 		.word	imgHdMux
 9745 559c 03030000 		.word	771
 9746 55a0 01010000 		.word	257
 9747 55a4 00000000 		.word	CyFxUvcApplnDmaCallback
 9748 55a8 00000000 		.word	glChHandleUVCStream
 9749 55ac 04040000 		.word	1028
 9750 55b0 00000000 		.word	CyFxUvcAppDebugCallback
 9751 55b4 00000000 		.word	glDebugCmdChannel
 9752 55b8 00000000 		.word	glDebugRspChannel
 9753 55bc 00000000 		.word	glDebugRspBuffer
 9754 55c0 00000000 		.word	.LANCHOR1
 9755 55c4 100A0000 		.word	.LC59
 9756 55c8 4C020000 		.word	.LC14
 9757 55cc 600A0000 		.word	.LC61
 9758 55d0 3C0A0000 		.word	.LC60
 9759 55d4 880A0000 		.word	.LC62
 9760 55d8 EC020000 		.word	.LC18
 9761 55dc A80E0000 		.word	.LC83
 9762 55e0 C80E0000 		.word	.LC84
 9763 55e4 E00E0000 		.word	.LC85
 9764 55e8 E00B0000 		.word	.LC69
 9765 55ec 400F0000 		.word	.LC88
 9766 55f0 3C000000 		.word	.LANCHOR2+60
 9767 55f4 880F0000 		.word	.LC90
 9768 55f8 300F0000 		.word	.LC87
 9769 55fc 20000000 		.word	.LANCHOR2+32
 9770 5600 500F0000 		.word	.LC89
 9771 5604 FC0E0000 		.word	.LC86
 9772 5608 FC0D0000 		.word	.LC79
 9773 560c CC0D0000 		.word	.LC78
 9774 5610 940D0000 		.word	.LC77
 9775 5614 640D0000 		.word	.LC76
 9776 5618 2C0D0000 		.word	.LC75
 9777 561c F40C0000 		.word	.LC74
 9778 5620 BC0C0000 		.word	.LC73
 9779 5624 8C0C0000 		.word	.LC72
 9780 5628 540C0000 		.word	.LC71
 9781 562c 140C0000 		.word	.LC70
 9782 5630 B00B0000 		.word	.LC68
 9783 5634 800B0000 		.word	.LC67
 9784 5638 480B0000 		.word	.LC66
 9785 563c E00A0000 		.word	.LC64
 9786 5640 B40A0000 		.word	.LC63
 9787 5644 140B0000 		.word	.LC65
 9788 5648 740E0000 		.word	.LC82
 9789 564c 480E0000 		.word	.LC81
 9790 5650 240E0000 		.word	.LC80
 9791              		.cfi_endproc
 9792              	.LFE20:
 9794              		.align	2
 9795              		.global	CyFxApplicationDefine
 9797              	CyFxApplicationDefine:
 9798              	.LFB28:
4783:../uvc.c      **** }
4784:../uvc.c      **** 
4785:../uvc.c      **** 
4786:../uvc.c      **** /*
4787:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4788:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4789:../uvc.c      ****  */
4790:../uvc.c      **** void
4791:../uvc.c      **** CyFxApplicationDefine (
4792:../uvc.c      ****         void)
4793:../uvc.c      **** {
 9799              		.loc 1 4793 0
 9800              		.cfi_startproc
 9801              		@ args = 0, pretend = 0, frame = 32
 9802              		@ frame_needed = 0, uses_anonymous_args = 0
 9803              	.LVL842:
 9804 5654 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 9805              	.LCFI28:
 9806              		.cfi_def_cfa_offset 32
4794:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4795:../uvc.c      ****     uint32_t retThrdCreate;
4796:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4797:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4798:../uvc.c      **** 
4799:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4800:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9807              		.loc 1 4800 0
 9808 5658 010AA0E3 		mov	r0, #4096
4793:../uvc.c      **** {
 9809              		.loc 1 4793 0
 9810 565c 40D04DE2 		sub	sp, sp, #64
 9811              	.LCFI29:
 9812              		.cfi_def_cfa_offset 96
 9813              		.loc 1 4800 0
 9814              		.cfi_offset 14, -4
 9815              		.cfi_offset 10, -8
 9816              		.cfi_offset 9, -12
 9817              		.cfi_offset 8, -16
 9818              		.cfi_offset 7, -20
 9819              		.cfi_offset 6, -24
 9820              		.cfi_offset 5, -28
 9821              		.cfi_offset 4, -32
 9822 5660 FEFFFFEB 		bl	CyU3PMemAlloc
 9823 5664 0080A0E1 		mov	r8, r0
 9824              	.LVL843:
4801:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9825              		.loc 1 4801 0
 9826 5668 010AA0E3 		mov	r0, #4096
 9827              	.LVL844:
 9828 566c FEFFFFEB 		bl	CyU3PMemAlloc
 9829 5670 00A0A0E1 		mov	sl, r0
 9830              	.LVL845:
4802:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9831              		.loc 1 4802 0
 9832 5674 010AA0E3 		mov	r0, #4096
 9833              	.LVL846:
 9834 5678 FEFFFFEB 		bl	CyU3PMemAlloc
4803:../uvc.c      **** 
4804:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 9835              		.loc 1 4804 0
 9836 567c 000058E3 		cmp	r8, #0
 9837 5680 00005A13 		cmpne	sl, #0
 9838 5684 0070A013 		movne	r7, #0
 9839 5688 0170A003 		moveq	r7, #1
4802:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9840              		.loc 1 4802 0
 9841 568c 0090A0E1 		mov	r9, r0
 9842              	.LVL847:
 9843              		.loc 1 4804 0
 9844 5690 0000001A 		bne	.L797
 9845              	.LVL848:
 9846              	.L794:
 9847              	.L796:
 9848 5694 FEFFFFEA 		b	.L796
 9849              	.L797:
 9850              		.loc 1 4804 0 is_stmt 0 discriminator 1
 9851 5698 000050E3 		cmp	r0, #0
 9852 569c FCFFFF0A 		beq	.L794
 9853              	.LVL849:
4805:../uvc.c      ****         goto fatalErrorHandler;
4806:../uvc.c      **** 
4807:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4808:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4809:../uvc.c      ****     char *staName = "I2CstaQue";
4810:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9854              		.loc 1 4810 0 is_stmt 1
 9855 56a0 04619FE5 		ldr	r6, .L798
 9856 56a4 20408DE2 		add	r4, sp, #32
 9857 56a8 0400A0E1 		mov	r0, r4
 9858 56ac 4010A0E3 		mov	r1, #64
 9859 56b0 F8209FE5 		ldr	r2, .L798+4
 9860 56b4 0730A0E1 		mov	r3, r7
 9861 56b8 00608DE5 		str	r6, [sp, #0]
 9862 56bc FEFFFFEB 		bl	cmdbufCreate
 9863 56c0 04E0A0E1 		mov	lr, r4
 9864 56c4 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 9865 56c8 E4C09FE5 		ldr	ip, .L798+8
4811:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4812:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4813:../uvc.c      **** 
4814:../uvc.c      **** 	/****** initialize command descriptor ***********/
4815:../uvc.c      **** 	cmdquInit(cmdQuptr);
4816:../uvc.c      **** 	cmdquInit(statQuptr);
4817:../uvc.c      **** 
4818:../uvc.c      ****     /* Create the UVC application thread. */
4819:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 9866              		.loc 1 4819 0
 9867 56cc 0840A0E3 		mov	r4, #8
4810:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9868              		.loc 1 4810 0
 9869 56d0 0C50A0E1 		mov	r5, ip
 9870 56d4 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 9871 56d8 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 9872              		.loc 1 4819 0
 9873 56dc 0160A0E3 		mov	r6, #1
4810:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9874              		.loc 1 4810 0
 9875 56e0 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
4815:../uvc.c      **** 	cmdquInit(cmdQuptr);
 9876              		.loc 1 4815 0
 9877 56e4 0C00A0E1 		mov	r0, ip
 9878 56e8 FEFFFFEB 		bl	cmdquInit
4816:../uvc.c      **** 	cmdquInit(statQuptr);
 9879              		.loc 1 4816 0
 9880 56ec C4009FE5 		ldr	r0, .L798+12
 9881 56f0 FEFFFFEB 		bl	cmdquInit
 9882              		.loc 1 4819 0
 9883 56f4 A850A0E3 		mov	r5, #168
 9884 56f8 01CAA0E3 		mov	ip, #4096
 9885 56fc B8009FE5 		ldr	r0, .L798+16
 9886 5700 B8109FE5 		ldr	r1, .L798+20
 9887 5704 B8209FE5 		ldr	r2, .L798+24
 9888 5708 0730A0E1 		mov	r3, r7
 9889 570c 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 9890 5710 08408DE5 		str	r4, [sp, #8]
 9891 5714 0C408DE5 		str	r4, [sp, #12]
 9892 5718 10708DE5 		str	r7, [sp, #16]
 9893 571c 14608DE5 		str	r6, [sp, #20]
 9894 5720 18508DE5 		str	r5, [sp, #24]
 9895 5724 FEFFFFEB 		bl	_txe_thread_create
 9896              	.LVL850:
4820:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4821:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4822:../uvc.c      ****             0,                                          /* No input parameter to thread */
4823:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4824:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4825:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4826:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4827:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4828:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4829:../uvc.c      ****             );
4830:../uvc.c      ****     if (retThrdCreate != 0)
 9897              		.loc 1 4830 0
 9898 5728 00C050E2 		subs	ip, r0, #0
 9899 572c D8FFFF1A 		bne	.L794
4831:../uvc.c      ****     {
4832:../uvc.c      ****         goto fatalErrorHandler;
4833:../uvc.c      ****     }
4834:../uvc.c      **** 
4835:../uvc.c      ****     /* Create the control request handling thread. */
4836:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 9900              		.loc 1 4836 0
 9901 5730 0C30A0E1 		mov	r3, ip
 9902 5734 027BA0E3 		mov	r7, #2048
 9903 5738 88009FE5 		ldr	r0, .L798+28
 9904              	.LVL851:
 9905 573c 88109FE5 		ldr	r1, .L798+32
 9906 5740 88209FE5 		ldr	r2, .L798+36
 9907 5744 10C08DE5 		str	ip, [sp, #16]
 9908 5748 00A08DE5 		str	sl, [sp, #0]
 9909 574c 04708DE5 		str	r7, [sp, #4]
 9910 5750 08408DE5 		str	r4, [sp, #8]
 9911 5754 0C408DE5 		str	r4, [sp, #12]
 9912 5758 14608DE5 		str	r6, [sp, #20]
 9913 575c 18508DE5 		str	r5, [sp, #24]
 9914 5760 FEFFFFEB 		bl	_txe_thread_create
 9915              	.LVL852:
4837:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4838:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4839:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4840:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4841:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4842:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4843:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4844:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4845:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4846:../uvc.c      ****             );
4847:../uvc.c      ****     if (retThrdCreate != 0)
 9916              		.loc 1 4847 0
 9917 5764 00C050E2 		subs	ip, r0, #0
 9918 5768 C9FFFF1A 		bne	.L794
4848:../uvc.c      ****     {
4849:../uvc.c      ****         goto fatalErrorHandler;
4850:../uvc.c      ****     }
4851:../uvc.c      **** #if 1
4852:../uvc.c      ****     /* Create the I2C control command handling thread. */
4853:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 9919              		.loc 1 4853 0
 9920 576c 60009FE5 		ldr	r0, .L798+40
 9921              	.LVL853:
 9922 5770 60109FE5 		ldr	r1, .L798+44
 9923 5774 60209FE5 		ldr	r2, .L798+48
 9924 5778 0C30A0E1 		mov	r3, ip
 9925 577c 00908DE5 		str	r9, [sp, #0]
 9926 5780 04708DE5 		str	r7, [sp, #4]
 9927 5784 08408DE5 		str	r4, [sp, #8]
 9928 5788 0C408DE5 		str	r4, [sp, #12]
 9929 578c 10C08DE5 		str	ip, [sp, #16]
 9930 5790 14608DE5 		str	r6, [sp, #20]
 9931 5794 18508DE5 		str	r5, [sp, #24]
 9932 5798 FEFFFFEB 		bl	_txe_thread_create
 9933              	.LVL854:
4854:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4855:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4856:../uvc.c      ****             0,                                          /* No input parameter to thread */
4857:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4858:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4859:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4860:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4861:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4862:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4863:../uvc.c      ****             );
4864:../uvc.c      ****     if (retThrdCreate != 0)
 9934              		.loc 1 4864 0
 9935 579c 000050E3 		cmp	r0, #0
 9936 57a0 BBFFFF1A 		bne	.L794
4865:../uvc.c      ****     {
4866:../uvc.c      ****         goto fatalErrorHandler;
4867:../uvc.c      ****     }
4868:../uvc.c      **** #endif
4869:../uvc.c      **** 
4870:../uvc.c      ****     return;
4871:../uvc.c      **** 
4872:../uvc.c      **** fatalErrorHandler:
4873:../uvc.c      ****     /* Add custom recovery or debug actions here */
4874:../uvc.c      ****     /* Loop indefinitely */
4875:../uvc.c      ****     while (1);
4876:../uvc.c      **** }
 9937              		.loc 1 4876 0
 9938 57a4 40D08DE2 		add	sp, sp, #64
 9939 57a8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 9940              	.L799:
 9941              		.align	2
 9942              	.L798:
 9943 57ac 00000000 		.word	cmdQuMux
 9944 57b0 C00F0000 		.word	.LC91
 9945 57b4 00000000 		.word	cmdQu
 9946 57b8 00000000 		.word	statQu
 9947 57bc A4010000 		.word	.LANCHOR0+420
 9948 57c0 CC0F0000 		.word	.LC92
 9949 57c4 00000000 		.word	UVCAppThread_Entry
 9950 57c8 4C020000 		.word	.LANCHOR0+588
 9951 57cc E00F0000 		.word	.LC93
 9952 57d0 00000000 		.word	UVCAppEP0Thread_Entry
 9953 57d4 F4020000 		.word	.LANCHOR0+756
 9954 57d8 F80F0000 		.word	.LC94
 9955 57dc 00000000 		.word	I2cAppThread_Entry
 9956              		.cfi_endproc
 9957              	.LFE28:
 9959              		.align	2
 9960              		.global	main
 9962              	main:
 9963              	.LFB29:
4877:../uvc.c      **** 
4878:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4879:../uvc.c      ****  * the ThreadX RTOS here.
4880:../uvc.c      ****  */
4881:../uvc.c      **** int
4882:../uvc.c      **** main (
4883:../uvc.c      ****         void)
4884:../uvc.c      **** {
 9964              		.loc 1 4884 0
 9965              		.cfi_startproc
 9966              		@ args = 0, pretend = 0, frame = 56
 9967              		@ frame_needed = 0, uses_anonymous_args = 0
 9968 57e0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 9969              	.LCFI30:
 9970              		.cfi_def_cfa_offset 12
4885:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4886:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4887:../uvc.c      **** 
4888:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4889:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4890:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4891:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4892:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4893:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9971              		.loc 1 4893 0
 9972 57e4 0010A0E3 		mov	r1, #0
4884:../uvc.c      **** {
 9973              		.loc 1 4884 0
 9974 57e8 3CD04DE2 		sub	sp, sp, #60
 9975              	.LCFI31:
 9976              		.cfi_def_cfa_offset 72
4890:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9977              		.loc 1 4890 0
 9978 57ec 0220A0E3 		mov	r2, #2
4894:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9979              		.loc 1 4894 0
 9980 57f0 033081E2 		add	r3, r1, #3
4889:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9981              		.loc 1 4889 0
 9982 57f4 0150A0E3 		mov	r5, #1
 9983              		.cfi_offset 14, -4
 9984              		.cfi_offset 5, -8
 9985              		.cfi_offset 4, -12
4895:../uvc.c      **** 
4896:../uvc.c      ****     /* Initialize the device */
4897:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9986              		.loc 1 4897 0
 9987 57f8 28008DE2 		add	r0, sp, #40
4889:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9988              		.loc 1 4889 0
 9989 57fc 28508DE5 		str	r5, [sp, #40]
4890:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9990              		.loc 1 4890 0
 9991 5800 2C20CDE5 		strb	r2, [sp, #44]
4891:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9992              		.loc 1 4891 0
 9993 5804 2D20CDE5 		strb	r2, [sp, #45]
4892:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9994              		.loc 1 4892 0
 9995 5808 2E20CDE5 		strb	r2, [sp, #46]
4893:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9996              		.loc 1 4893 0
 9997 580c 30108DE5 		str	r1, [sp, #48]
4894:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9998              		.loc 1 4894 0
 9999 5810 3430CDE5 		strb	r3, [sp, #52]
 10000              		.loc 1 4897 0
 10001 5814 FEFFFFEB 		bl	CyU3PDeviceInit
 10002              	.LVL855:
4898:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10003              		.loc 1 4898 0
 10004 5818 004050E2 		subs	r4, r0, #0
 10005 581c 0000000A 		beq	.L803
 10006              	.L801:
 10007              	.L802:
 10008 5820 FEFFFFEA 		b	.L802
 10009              	.L803:
4899:../uvc.c      ****     {
4900:../uvc.c      ****         goto handle_fatal_error;
4901:../uvc.c      ****     }
4902:../uvc.c      **** 
4903:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4904:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 10010              		.loc 1 4904 0
 10011 5824 0410A0E1 		mov	r1, r4
 10012 5828 0420A0E1 		mov	r2, r4
 10013 582c 0500A0E1 		mov	r0, r5
 10014              	.LVL856:
 10015 5830 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 10016              	.LVL857:
4905:../uvc.c      **** 
4906:../uvc.c      ****     /* Configure the IO matrix for the device. */
4907:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4908:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4909:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4910:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4911:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4912:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4913:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4914:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4915:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4916:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4917:../uvc.c      **** 
4918:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 10017              		.loc 1 4918 0
 10018 5834 0D00A0E1 		mov	r0, sp
4908:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 10019              		.loc 1 4908 0
 10020 5838 1640CDE5 		strb	r4, [sp, #22]
4909:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 10021              		.loc 1 4909 0
 10022 583c 18408DE5 		str	r4, [sp, #24]
4910:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 10023              		.loc 1 4910 0
 10024 5840 1C408DE5 		str	r4, [sp, #28]
4911:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 10025              		.loc 1 4911 0
 10026 5844 20408DE5 		str	r4, [sp, #32]
4912:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 10027              		.loc 1 4912 0
 10028 5848 24408DE5 		str	r4, [sp, #36]
4915:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 10029              		.loc 1 4915 0
 10030 584c 0C408DE5 		str	r4, [sp, #12]
4916:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 10031              		.loc 1 4916 0
 10032 5850 10408DE5 		str	r4, [sp, #16]
4907:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 10033              		.loc 1 4907 0
 10034 5854 00508DE5 		str	r5, [sp, #0]
4913:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 10035              		.loc 1 4913 0
 10036 5858 04508DE5 		str	r5, [sp, #4]
4914:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 10037              		.loc 1 4914 0
 10038 585c 08508DE5 		str	r5, [sp, #8]
 10039              		.loc 1 4918 0
 10040 5860 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 10041              	.LVL858:
4919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 10042              		.loc 1 4919 0
 10043 5864 004050E2 		subs	r4, r0, #0
 10044 5868 ECFFFF1A 		bne	.L801
4920:../uvc.c      ****     {
4921:../uvc.c      ****         goto handle_fatal_error;
4922:../uvc.c      ****     }
4923:../uvc.c      **** 
4924:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4925:../uvc.c      ****     CyU3PKernelEntry ();
 10045              		.loc 1 4925 0
 10046 586c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 10047              	.LVL859:
4926:../uvc.c      **** 
4927:../uvc.c      ****     /* Dummy return to make the compiler happy */
4928:../uvc.c      ****     return 0;
4929:../uvc.c      **** 
4930:../uvc.c      **** handle_fatal_error:
4931:../uvc.c      ****     /* Cannot recover from this error. */
4932:../uvc.c      ****     while (1);
4933:../uvc.c      **** }
 10048              		.loc 1 4933 0
 10049 5870 0400A0E1 		mov	r0, r4
 10050 5874 3CD08DE2 		add	sp, sp, #60
 10051 5878 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 10052              		.cfi_endproc
 10053              	.LFE29:
 10055              		.global	CyFxGpifTransition
 10056              		.global	CyFxGpifWavedata
 10057              		.global	CyFxGpifWavedataPosition
 10058              		.global	CyFxGpifRegValue
 10059              		.global	CyFxGpifConfig
 10060              		.global	CyFxGpifTransition_usb2
 10061              		.global	CyFxGpifWavedata_usb2
 10062              		.global	CyFxGpifWavedataPosition_usb2
 10063              		.global	CyFxGpifRegValue_usb2
 10064              		.global	CyFxGpifConfig_usb2
 10065              		.global	snapButFlag
 10066              		.global	testSnap
 10067              		.global	fb
 10068              		.global	pb
 10069              		.global	pbc
 10070              		.global	fbbak
 10071              		.global	pbbak
 10072              		.global	pbcbak
 10073              		.global	pbcpbak
 10074              		.global	isUsbConnected
 10075              		.global	usbSpeed
 10076              		.global	clearFeatureRqtReceived
 10077              		.global	streamingRecove
 10078              		.global	streamingStarted
 10079              		.global	glProbeCtrl
 10080              		.global	glProbeCtrlFull
 10081              		.global	glProbeStilCtrl
 10082              		.global	glProbeCtrl20
 10083              		.global	glProbeStilCtrl20
 10084              		.global	glUVCHeader
 10085              		.comm	glChHandleUVCStream,220,4
 10086              		.comm	glChHandleStillStream,220,4
 10087              		.comm	glChHandleInterStat,160,4
 10088              		.comm	glInterStaBuffer,4,4
 10089              		.comm	cmdQu,32,4
 10090              		.comm	statQu,32,4
 10091              		.comm	cmdQuMux,56,4
 10092              		.comm	staQuMux,56,4
 10093              		.comm	timMux,56,4
 10094              		.comm	imgHdMux,56,4
 10095              		.comm	bmReqType,1,1
 10096              		.comm	bRequest,1,1
 10097              		.comm	wValue,2,2
 10098              		.comm	wIndex,2,2
 10099              		.comm	wLength,2,2
 10100              		.comm	glDebugCmdChannel,160,4
 10101              		.comm	glDebugRspChannel,160,4
 10102              		.comm	glDebugRspBuffer,4,4
 10103              		.comm	posTick,4,4
 10104              		.comm	I2CCmdTimer,44,4
 10105              		.section	.rodata
 10106              		.align	2
 10107              		.set	.LANCHOR2,. + 0
 10110              	ShutSp:
 10111 0000 3582     		.short	-32203
 10112 0002 1B41     		.short	16667
 10113 0004 8D20     		.short	8333
 10114 0006 A00F     		.short	4000
 10115 0008 D007     		.short	2000
 10116 000a E803     		.short	1000
 10117 000c F401     		.short	500
 10118 000e C800     		.short	200
 10119 0010 6400     		.short	100
 10120 0012 0A00     		.short	10
 10121 0014 0000     		.short	0
 10122 0016 00000000 		.space	10
 10122      00000000 
 10122      0000
 10125              	CyFxGpifConfig:
 10126 0020 0F00     		.short	15
 10127 0022 0000     		.space	2
 10128 0024 00000000 		.word	CyFxGpifWavedata
 10129 0028 00000000 		.word	CyFxGpifWavedataPosition
 10130 002c 0500     		.short	5
 10131 002e 0000     		.space	2
 10132 0030 00000000 		.word	CyFxGpifTransition
 10133 0034 4C00     		.short	76
 10134 0036 0000     		.space	2
 10135 0038 00000000 		.word	CyFxGpifRegValue
 10138              	CyFxGpifConfig_usb2:
 10139 003c 9300     		.short	147
 10140 003e 0000     		.space	2
 10141 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10142 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10143 0048 0800     		.short	8
 10144 004a 0000     		.space	2
 10145 004c 00000000 		.word	CyFxGpifTransition_usb2
 10146 0050 4C00     		.short	76
 10147 0052 0000     		.space	2
 10148 0054 00000000 		.word	CyFxGpifRegValue_usb2
 10149              		.data
 10150              		.align	2
 10151              		.set	.LANCHOR1,. + 0
 10154              	ExUCtrlParArry:
 10155 0000 00       		.byte	0
 10156 0001 00       		.byte	0
 10157 0002 04       		.byte	4
 10158 0003 01       		.byte	1
 10159 0004 00       		.byte	0
 10160 0005 38       		.byte	56
 10161 0006 01       		.byte	1
 10162 0007 01       		.byte	1
 10163 0008 00       		.byte	0
 10164 0009 03       		.byte	3
 10165 000a 00       		.byte	0
 10166 000b 4E       		.byte	78
 10167 000c 00       		.byte	0
 10168 000d 4E       		.byte	78
 10169 000e 00       		.byte	0
 10170 000f 30       		.byte	48
 10171 0010 01       		.byte	1
 10172 0011 00       		.byte	0
 10173 0012 00       		.byte	0
 10174 0013 00000000 		.space	5
 10174      00
 10175 0018 00       		.byte	0
 10176 0019 00       		.byte	0
 10177 001a 01       		.byte	1
 10178 001b 00       		.byte	0
 10179 001c 00       		.byte	0
 10180 001d 00       		.byte	0
 10181 001e 00       		.byte	0
 10182 001f 01       		.byte	1
 10183 0020 00       		.byte	0
 10184 0021 03       		.byte	3
 10185 0022 00       		.byte	0
 10186 0023 00       		.byte	0
 10187 0024 00       		.byte	0
 10188 0025 00       		.byte	0
 10189 0026 00       		.byte	0
 10190 0027 30       		.byte	48
 10191 0028 01       		.byte	1
 10192 0029 00       		.byte	0
 10193 002a 00       		.byte	0
 10194 002b 00000000 		.space	5
 10194      00
 10195 0030 00       		.byte	0
 10196 0031 00       		.byte	0
 10197 0032 02       		.byte	2
 10198 0033 00       		.byte	0
 10199 0034 00       		.byte	0
 10200 0035 FF       		.byte	-1
 10201 0036 00       		.byte	0
 10202 0037 01       		.byte	1
 10203 0038 00       		.byte	0
 10204 0039 03       		.byte	3
 10205 003a 00       		.byte	0
 10206 003b 01       		.byte	1
 10207 003c 00       		.byte	0
 10208 003d 00       		.byte	0
 10209 003e 00       		.byte	0
 10210 003f 30       		.byte	48
 10211 0040 01       		.byte	1
 10212 0041 01       		.byte	1
 10213 0042 00       		.byte	0
 10214 0043 00000000 		.space	5
 10214      00
 10215 0048 00       		.byte	0
 10216 0049 00       		.byte	0
 10217 004a 02       		.byte	2
 10218 004b 00       		.byte	0
 10219 004c 00       		.byte	0
 10220 004d 00       		.byte	0
 10221 004e 00       		.byte	0
 10222 004f 00       		.byte	0
 10223 0050 00       		.byte	0
 10224 0051 03       		.byte	3
 10225 0052 00       		.byte	0
 10226 0053 00       		.byte	0
 10227 0054 00       		.byte	0
 10228 0055 00       		.byte	0
 10229 0056 00       		.byte	0
 10230 0057 30       		.byte	48
 10231 0058 01       		.byte	1
 10232 0059 01       		.byte	1
 10233 005a 00       		.byte	0
 10234 005b 00000000 		.space	5
 10234      00
 10235 0060 13       		.byte	19
 10236 0061 14       		.byte	20
 10237 0062 02       		.byte	2
 10238 0063 00       		.byte	0
 10239 0064 00       		.byte	0
 10240 0065 FF       		.byte	-1
 10241 0066 FF       		.byte	-1
 10242 0067 01       		.byte	1
 10243 0068 00       		.byte	0
 10244 0069 03       		.byte	3
 10245 006a 00       		.byte	0
 10246 006b 66       		.byte	102
 10247 006c 66       		.byte	102
 10248 006d 66       		.byte	102
 10249 006e 66       		.byte	102
 10250 006f 30       		.byte	48
 10251 0070 01       		.byte	1
 10252 0071 00       		.byte	0
 10253 0072 00       		.byte	0
 10254 0073 00000000 		.space	5
 10254      00
 10255 0078 11       		.byte	17
 10256 0079 00       		.byte	0
 10257 007a 02       		.byte	2
 10258 007b 01       		.byte	1
 10259 007c 00       		.byte	0
 10260 007d 03       		.byte	3
 10261 007e 00       		.byte	0
 10262 007f 01       		.byte	1
 10263 0080 00       		.byte	0
 10264 0081 03       		.byte	3
 10265 0082 00       		.byte	0
 10266 0083 80       		.byte	-128
 10267 0084 00       		.byte	0
 10268 0085 80       		.byte	-128
 10269 0086 00       		.byte	0
 10270 0087 30       		.byte	48
 10271 0088 01       		.byte	1
 10272 0089 01       		.byte	1
 10273 008a 00       		.byte	0
 10274 008b 00000000 		.space	5
 10274      00
 10275 0090 10       		.byte	16
 10276 0091 00       		.byte	0
 10277 0092 01       		.byte	1
 10278 0093 01       		.byte	1
 10279 0094 00       		.byte	0
 10280 0095 02       		.byte	2
 10281 0096 00       		.byte	0
 10282 0097 01       		.byte	1
 10283 0098 00       		.byte	0
 10284 0099 03       		.byte	3
 10285 009a 00       		.byte	0
 10286 009b 00       		.byte	0
 10287 009c 00       		.byte	0
 10288 009d 00       		.byte	0
 10289 009e 00       		.byte	0
 10290 009f 30       		.byte	48
 10291 00a0 01       		.byte	1
 10292 00a1 01       		.byte	1
 10293 00a2 00       		.byte	0
 10294 00a3 00000000 		.space	5
 10294      00
 10295 00a8 00       		.byte	0
 10296 00a9 00       		.byte	0
 10297 00aa 04       		.byte	4
 10298 00ab 01       		.byte	1
 10299 00ac 00       		.byte	0
 10300 00ad 38       		.byte	56
 10301 00ae 01       		.byte	1
 10302 00af 01       		.byte	1
 10303 00b0 00       		.byte	0
 10304 00b1 03       		.byte	3
 10305 00b2 00       		.byte	0
 10306 00b3 4E       		.byte	78
 10307 00b4 00       		.byte	0
 10308 00b5 4E       		.byte	78
 10309 00b6 00       		.byte	0
 10310 00b7 30       		.byte	48
 10311 00b8 01       		.byte	1
 10312 00b9 00       		.byte	0
 10313 00ba 00       		.byte	0
 10314 00bb 00000000 		.space	5
 10314      00
 10315 00c0 00       		.byte	0
 10316 00c1 00       		.byte	0
 10317 00c2 01       		.byte	1
 10318 00c3 00       		.byte	0
 10319 00c4 00       		.byte	0
 10320 00c5 00       		.byte	0
 10321 00c6 00       		.byte	0
 10322 00c7 01       		.byte	1
 10323 00c8 00       		.byte	0
 10324 00c9 03       		.byte	3
 10325 00ca 00       		.byte	0
 10326 00cb 00       		.byte	0
 10327 00cc 00       		.byte	0
 10328 00cd 00       		.byte	0
 10329 00ce 00       		.byte	0
 10330 00cf 30       		.byte	48
 10331 00d0 01       		.byte	1
 10332 00d1 00       		.byte	0
 10333 00d2 00       		.byte	0
 10334 00d3 00000000 		.space	5
 10334      00
 10335 00d8 00       		.byte	0
 10336 00d9 00       		.byte	0
 10337 00da 02       		.byte	2
 10338 00db 00       		.byte	0
 10339 00dc 00       		.byte	0
 10340 00dd 05       		.byte	5
 10341 00de 00       		.byte	0
 10342 00df 01       		.byte	1
 10343 00e0 00       		.byte	0
 10344 00e1 03       		.byte	3
 10345 00e2 00       		.byte	0
 10346 00e3 00       		.byte	0
 10347 00e4 00       		.byte	0
 10348 00e5 00       		.byte	0
 10349 00e6 00       		.byte	0
 10350 00e7 30       		.byte	48
 10351 00e8 01       		.byte	1
 10352 00e9 00       		.byte	0
 10353 00ea 00       		.byte	0
 10354 00eb 00000000 		.space	5
 10354      00
 10355 00f0 00       		.byte	0
 10356 00f1 00       		.byte	0
 10357 00f2 03       		.byte	3
 10358 00f3 00       		.byte	0
 10359 00f4 00       		.byte	0
 10360 00f5 0A       		.byte	10
 10361 00f6 00       		.byte	0
 10362 00f7 01       		.byte	1
 10363 00f8 00       		.byte	0
 10364 00f9 03       		.byte	3
 10365 00fa 00       		.byte	0
 10366 00fb 00       		.byte	0
 10367 00fc 00       		.byte	0
 10368 00fd 00       		.byte	0
 10369 00fe 00       		.byte	0
 10370 00ff 30       		.byte	48
 10371 0100 01       		.byte	1
 10372 0101 00       		.byte	0
 10373 0102 00       		.byte	0
 10374 0103 00000000 		.space	5
 10374      00
 10375 0108 00       		.byte	0
 10376 0109 00       		.byte	0
 10377 010a 02       		.byte	2
 10378 010b 00       		.byte	0
 10379 010c 00       		.byte	0
 10380 010d 40       		.byte	64
 10381 010e 00       		.byte	0
 10382 010f 01       		.byte	1
 10383 0110 00       		.byte	0
 10384 0111 03       		.byte	3
 10385 0112 00       		.byte	0
 10386 0113 0F       		.byte	15
 10387 0114 11       		.byte	17
 10388 0115 00       		.byte	0
 10389 0116 00       		.byte	0
 10390 0117 30       		.byte	48
 10391 0118 01       		.byte	1
 10392 0119 00       		.byte	0
 10393 011a 00       		.byte	0
 10394 011b 00000000 		.space	5
 10394      00
 10395 0120 00       		.byte	0
 10396 0121 00       		.byte	0
 10397 0122 02       		.byte	2
 10398 0123 00       		.byte	0
 10399 0124 00       		.byte	0
 10400 0125 64       		.byte	100
 10401 0126 00       		.byte	0
 10402 0127 01       		.byte	1
 10403 0128 00       		.byte	0
 10404 0129 03       		.byte	3
 10405 012a 00       		.byte	0
 10406 012b 00       		.byte	0
 10407 012c 00       		.byte	0
 10408 012d 00       		.byte	0
 10409 012e 00       		.byte	0
 10410 012f 30       		.byte	48
 10411 0130 01       		.byte	1
 10412 0131 00       		.byte	0
 10413 0132 00       		.byte	0
 10414 0133 00000000 		.space	5
 10414      00
 10415 0138 00       		.byte	0
 10416 0139 00       		.byte	0
 10417 013a 02       		.byte	2
 10418 013b 00       		.byte	0
 10419 013c 00       		.byte	0
 10420 013d 64       		.byte	100
 10421 013e 00       		.byte	0
 10422 013f 01       		.byte	1
 10423 0140 00       		.byte	0
 10424 0141 03       		.byte	3
 10425 0142 00       		.byte	0
 10426 0143 00       		.byte	0
 10427 0144 00       		.byte	0
 10428 0145 00       		.byte	0
 10429 0146 00       		.byte	0
 10430 0147 30       		.byte	48
 10431 0148 01       		.byte	1
 10432 0149 00       		.byte	0
 10433 014a 00       		.byte	0
 10434 014b 00000000 		.space	5
 10434      00
 10435 0150 00       		.byte	0
 10436 0151 00       		.byte	0
 10437 0152 02       		.byte	2
 10438 0153 00       		.byte	0
 10439 0154 00       		.byte	0
 10440 0155 64       		.byte	100
 10441 0156 00       		.byte	0
 10442 0157 01       		.byte	1
 10443 0158 00       		.byte	0
 10444 0159 03       		.byte	3
 10445 015a 00       		.byte	0
 10446 015b 00       		.byte	0
 10447 015c 00       		.byte	0
 10448 015d 00       		.byte	0
 10449 015e 00       		.byte	0
 10450 015f 30       		.byte	48
 10451 0160 01       		.byte	1
 10452 0161 00       		.byte	0
 10453 0162 00       		.byte	0
 10454 0163 00000000 		.space	5
 10454      00
 10455 0168 00       		.byte	0
 10456 0169 00       		.byte	0
 10457 016a 02       		.byte	2
 10458 016b 00       		.byte	0
 10459 016c 00       		.byte	0
 10460 016d 64       		.byte	100
 10461 016e 00       		.byte	0
 10462 016f 01       		.byte	1
 10463 0170 00       		.byte	0
 10464 0171 03       		.byte	3
 10465 0172 00       		.byte	0
 10466 0173 00       		.byte	0
 10467 0174 00       		.byte	0
 10468 0175 00       		.byte	0
 10469 0176 00       		.byte	0
 10470 0177 30       		.byte	48
 10471 0178 01       		.byte	1
 10472 0179 00       		.byte	0
 10473 017a 00       		.byte	0
 10474 017b 00000000 		.space	5
 10474      00
 10477              	CtrlParArry:
 10478 0180 10       		.byte	16
 10479 0181 10       		.byte	16
 10480 0182 02       		.byte	2
 10481 0183 00       		.byte	0
 10482 0184 00       		.byte	0
 10483 0185 03       		.byte	3
 10484 0186 00       		.byte	0
 10485 0187 01       		.byte	1
 10486 0188 00       		.byte	0
 10487 0189 03       		.byte	3
 10488 018a 00       		.byte	0
 10489 018b 03       		.byte	3
 10490 018c 00       		.byte	0
 10491 018d 03       		.byte	3
 10492 018e 00       		.byte	0
 10493 018f 30       		.byte	48
 10494 0190 01       		.byte	1
 10495 0191 00       		.byte	0
 10496 0192 00       		.byte	0
 10497 0193 00000000 		.space	5
 10497      00
 10498 0198 15       		.byte	21
 10499 0199 15       		.byte	21
 10500 019a 02       		.byte	2
 10501 019b 00       		.byte	0
 10502 019c 00       		.byte	0
 10503 019d FF       		.byte	-1
 10504 019e 00       		.byte	0
 10505 019f 01       		.byte	1
 10506 01a0 00       		.byte	0
 10507 01a1 03       		.byte	3
 10508 01a2 00       		.byte	0
 10509 01a3 76       		.byte	118
 10510 01a4 00       		.byte	0
 10511 01a5 76       		.byte	118
 10512 01a6 C7       		.byte	-57
 10513 01a7 30       		.byte	48
 10514 01a8 01       		.byte	1
 10515 01a9 01       		.byte	1
 10516 01aa 00       		.byte	0
 10517 01ab 00000000 		.space	5
 10517      00
 10518 01b0 04       		.byte	4
 10519 01b1 04       		.byte	4
 10520 01b2 02       		.byte	2
 10521 01b3 00       		.byte	0
 10522 01b4 00       		.byte	0
 10523 01b5 FF       		.byte	-1
 10524 01b6 00       		.byte	0
 10525 01b7 01       		.byte	1
 10526 01b8 00       		.byte	0
 10527 01b9 03       		.byte	3
 10528 01ba 00       		.byte	0
 10529 01bb 70       		.byte	112
 10530 01bc 00       		.byte	0
 10531 01bd 70       		.byte	112
 10532 01be 00       		.byte	0
 10533 01bf 30       		.byte	48
 10534 01c0 01       		.byte	1
 10535 01c1 01       		.byte	1
 10536 01c2 00       		.byte	0
 10537 01c3 00000000 		.space	5
 10537      00
 10538 01c8 00       		.byte	0
 10539 01c9 00       		.byte	0
 10540 01ca 02       		.byte	2
 10541 01cb 00       		.byte	0
 10542 01cc 00       		.byte	0
 10543 01cd 64       		.byte	100
 10544 01ce 00       		.byte	0
 10545 01cf 01       		.byte	1
 10546 01d0 00       		.byte	0
 10547 01d1 03       		.byte	3
 10548 01d2 00       		.byte	0
 10549 01d3 00       		.byte	0
 10550 01d4 00       		.byte	0
 10551 01d5 00       		.byte	0
 10552 01d6 00       		.byte	0
 10553 01d7 30       		.byte	48
 10554 01d8 01       		.byte	1
 10555 01d9 00       		.byte	0
 10556 01da 00       		.byte	0
 10557 01db 00000000 		.space	5
 10557      00
 10558 01e0 07       		.byte	7
 10559 01e1 07       		.byte	7
 10560 01e2 02       		.byte	2
 10561 01e3 00       		.byte	0
 10562 01e4 00       		.byte	0
 10563 01e5 01       		.byte	1
 10564 01e6 00       		.byte	0
 10565 01e7 01       		.byte	1
 10566 01e8 00       		.byte	0
 10567 01e9 03       		.byte	3
 10568 01ea 00       		.byte	0
 10569 01eb 01       		.byte	1
 10570 01ec 00       		.byte	0
 10571 01ed 01       		.byte	1
 10572 01ee 00       		.byte	0
 10573 01ef 30       		.byte	48
 10574 01f0 01       		.byte	1
 10575 01f1 00       		.byte	0
 10576 01f2 00       		.byte	0
 10577 01f3 00000000 		.space	5
 10577      00
 10578 01f8 DF       		.byte	-33
 10579 01f9 E1       		.byte	-31
 10580 01fa 02       		.byte	2
 10581 01fb 00       		.byte	0
 10582 01fc 00       		.byte	0
 10583 01fd FF       		.byte	-1
 10584 01fe 00       		.byte	0
 10585 01ff 01       		.byte	1
 10586 0200 00       		.byte	0
 10587 0201 03       		.byte	3
 10588 0202 00       		.byte	0
 10589 0203 80       		.byte	-128
 10590 0204 00       		.byte	0
 10591 0205 00       		.byte	0
 10592 0206 00       		.byte	0
 10593 0207 C6       		.byte	-58
 10594 0208 01       		.byte	1
 10595 0209 01       		.byte	1
 10596 020a 00       		.byte	0
 10597 020b 00000000 		.space	5
 10597      00
 10598 0210 85       		.byte	-123
 10599 0211 86       		.byte	-122
 10600 0212 02       		.byte	2
 10601 0213 00       		.byte	0
 10602 0214 00       		.byte	0
 10603 0215 64       		.byte	100
 10604 0216 00       		.byte	0
 10605 0217 01       		.byte	1
 10606 0218 00       		.byte	0
 10607 0219 03       		.byte	3
 10608 021a 00       		.byte	0
 10609 021b 32       		.byte	50
 10610 021c 00       		.byte	0
 10611 021d 32       		.byte	50
 10612 021e 00       		.byte	0
 10613 021f F2       		.byte	-14
 10614 0220 01       		.byte	1
 10615 0221 01       		.byte	1
 10616 0222 00       		.byte	0
 10617 0223 00000000 		.space	5
 10617      00
 10618 0228 06       		.byte	6
 10619 0229 06       		.byte	6
 10620 022a 02       		.byte	2
 10621 022b 00       		.byte	0
 10622 022c 00       		.byte	0
 10623 022d FF       		.byte	-1
 10624 022e 00       		.byte	0
 10625 022f 01       		.byte	1
 10626 0230 00       		.byte	0
 10627 0231 03       		.byte	3
 10628 0232 00       		.byte	0
 10629 0233 20       		.byte	32
 10630 0234 00       		.byte	0
 10631 0235 20       		.byte	32
 10632 0236 00       		.byte	0
 10633 0237 30       		.byte	48
 10634 0238 01       		.byte	1
 10635 0239 01       		.byte	1
 10636 023a 00       		.byte	0
 10637 023b 00000000 		.space	5
 10637      00
 10638 0240 00       		.byte	0
 10639 0241 00       		.byte	0
 10640 0242 02       		.byte	2
 10641 0243 00       		.byte	0
 10642 0244 00       		.byte	0
 10643 0245 64       		.byte	100
 10644 0246 00       		.byte	0
 10645 0247 01       		.byte	1
 10646 0248 00       		.byte	0
 10647 0249 03       		.byte	3
 10648 024a 00       		.byte	0
 10649 024b 00       		.byte	0
 10650 024c 00       		.byte	0
 10651 024d 00       		.byte	0
 10652 024e 00       		.byte	0
 10653 024f 30       		.byte	48
 10654 0250 01       		.byte	1
 10655 0251 00       		.byte	0
 10656 0252 00       		.byte	0
 10657 0253 00000000 		.space	5
 10657      00
 10658 0258 08       		.byte	8
 10659 0259 08       		.byte	8
 10660 025a 02       		.byte	2
 10661 025b 00       		.byte	0
 10662 025c 00       		.byte	0
 10663 025d 05       		.byte	5
 10664 025e 00       		.byte	0
 10665 025f 01       		.byte	1
 10666 0260 00       		.byte	0
 10667 0261 03       		.byte	3
 10668 0262 00       		.byte	0
 10669 0263 00       		.byte	0
 10670 0264 00       		.byte	0
 10671 0265 00       		.byte	0
 10672 0266 00       		.byte	0
 10673 0267 30       		.byte	48
 10674 0268 01       		.byte	1
 10675 0269 00       		.byte	0
 10676 026a 00       		.byte	0
 10677 026b 00000000 		.space	5
 10677      00
 10678 0270 00       		.byte	0
 10679 0271 00       		.byte	0
 10680 0272 02       		.byte	2
 10681 0273 00       		.byte	0
 10682 0274 00       		.byte	0
 10683 0275 40       		.byte	64
 10684 0276 00       		.byte	0
 10685 0277 01       		.byte	1
 10686 0278 00       		.byte	0
 10687 0279 03       		.byte	3
 10688 027a 00       		.byte	0
 10689 027b 00       		.byte	0
 10690 027c 00       		.byte	0
 10691 027d 00       		.byte	0
 10692 027e 00       		.byte	0
 10693 027f 30       		.byte	48
 10694 0280 01       		.byte	1
 10695 0281 00       		.byte	0
 10696 0282 00       		.byte	0
 10697 0283 00000000 		.space	5
 10697      00
 10698 0288 09       		.byte	9
 10699 0289 0A       		.byte	10
 10700 028a 04       		.byte	4
 10701 028b 00       		.byte	0
 10702 028c 00       		.byte	0
 10703 028d 40       		.byte	64
 10704 028e 00       		.byte	0
 10705 028f 01       		.byte	1
 10706 0290 00       		.byte	0
 10707 0291 03       		.byte	3
 10708 0292 00       		.byte	0
 10709 0293 20       		.byte	32
 10710 0294 38       		.byte	56
 10711 0295 20       		.byte	32
 10712 0296 38       		.byte	56
 10713 0297 30       		.byte	48
 10714 0298 01       		.byte	1
 10715 0299 00       		.byte	0
 10716 029a 00       		.byte	0
 10717 029b 00000000 		.space	5
 10717      00
 10718 02a0 00       		.byte	0
 10719 02a1 00       		.byte	0
 10720 02a2 02       		.byte	2
 10721 02a3 00       		.byte	0
 10722 02a4 00       		.byte	0
 10723 02a5 64       		.byte	100
 10724 02a6 00       		.byte	0
 10725 02a7 01       		.byte	1
 10726 02a8 00       		.byte	0
 10727 02a9 03       		.byte	3
 10728 02aa 00       		.byte	0
 10729 02ab 00       		.byte	0
 10730 02ac 00       		.byte	0
 10731 02ad 00       		.byte	0
 10732 02ae 00       		.byte	0
 10733 02af 30       		.byte	48
 10734 02b0 01       		.byte	1
 10735 02b1 00       		.byte	0
 10736 02b2 00       		.byte	0
 10737 02b3 00000000 		.space	5
 10737      00
 10738 02b8 00       		.byte	0
 10739 02b9 00       		.byte	0
 10740 02ba 02       		.byte	2
 10741 02bb 00       		.byte	0
 10742 02bc 00       		.byte	0
 10743 02bd 64       		.byte	100
 10744 02be 00       		.byte	0
 10745 02bf 01       		.byte	1
 10746 02c0 00       		.byte	0
 10747 02c1 03       		.byte	3
 10748 02c2 00       		.byte	0
 10749 02c3 00       		.byte	0
 10750 02c4 00       		.byte	0
 10751 02c5 00       		.byte	0
 10752 02c6 00       		.byte	0
 10753 02c7 30       		.byte	48
 10754 02c8 01       		.byte	1
 10755 02c9 00       		.byte	0
 10756 02ca 00       		.byte	0
 10757 02cb 00000000 		.space	5
 10757      00
 10758 02d0 2A       		.byte	42
 10759 02d1 2A       		.byte	42
 10760 02d2 02       		.byte	2
 10761 02d3 00       		.byte	0
 10762 02d4 00       		.byte	0
 10763 02d5 1B       		.byte	27
 10764 02d6 00       		.byte	0
 10765 02d7 01       		.byte	1
 10766 02d8 00       		.byte	0
 10767 02d9 03       		.byte	3
 10768 02da 00       		.byte	0
 10769 02db 00       		.byte	0
 10770 02dc 00       		.byte	0
 10771 02dd 00       		.byte	0
 10772 02de 00       		.byte	0
 10773 02df 30       		.byte	48
 10774 02e0 01       		.byte	1
 10775 02e1 00       		.byte	0
 10776 02e2 00       		.byte	0
 10777 02e3 00000000 		.space	5
 10777      00
 10778 02e8 00       		.byte	0
 10779 02e9 00       		.byte	0
 10780 02ea 02       		.byte	2
 10781 02eb 00       		.byte	0
 10782 02ec 00       		.byte	0
 10783 02ed 64       		.byte	100
 10784 02ee 00       		.byte	0
 10785 02ef 01       		.byte	1
 10786 02f0 00       		.byte	0
 10787 02f1 03       		.byte	3
 10788 02f2 00       		.byte	0
 10789 02f3 00       		.byte	0
 10790 02f4 00       		.byte	0
 10791 02f5 00       		.byte	0
 10792 02f6 00       		.byte	0
 10793 02f7 30       		.byte	48
 10794 02f8 01       		.byte	1
 10795 02f9 00       		.byte	0
 10796 02fa 00       		.byte	0
 10797 02fb 00000000 		.space	5
 10797      00
 10798 0300 00       		.byte	0
 10799 0301 00       		.byte	0
 10800 0302 02       		.byte	2
 10801 0303 00       		.byte	0
 10802 0304 00       		.byte	0
 10803 0305 12       		.byte	18
 10804 0306 00       		.byte	0
 10805 0307 01       		.byte	1
 10806 0308 00       		.byte	0
 10807 0309 03       		.byte	3
 10808 030a 00       		.byte	0
 10809 030b 00       		.byte	0
 10810 030c 00       		.byte	0
 10811 030d 00       		.byte	0
 10812 030e 00       		.byte	0
 10813 030f 30       		.byte	48
 10814 0310 01       		.byte	1
 10815 0311 00       		.byte	0
 10816 0312 00       		.byte	0
 10817 0313 00000000 		.space	5
 10817      00
 10818 0318 01       		.byte	1
 10819 0319 01       		.byte	1
 10820 031a 02       		.byte	2
 10821 031b 00       		.byte	0
 10822 031c 00       		.byte	0
 10823 031d 09       		.byte	9
 10824 031e 00       		.byte	0
 10825 031f 01       		.byte	1
 10826 0320 00       		.byte	0
 10827 0321 03       		.byte	3
 10828 0322 00       		.byte	0
 10829 0323 00       		.byte	0
 10830 0324 00       		.byte	0
 10831 0325 01       		.byte	1
 10832 0326 00       		.byte	0
 10833 0327 30       		.byte	48
 10834 0328 01       		.byte	1
 10835 0329 00       		.byte	0
 10836 032a 00       		.byte	0
 10837 032b 00000000 		.space	5
 10837      00
 10838 0330 05       		.byte	5
 10839 0331 05       		.byte	5
 10840 0332 02       		.byte	2
 10841 0333 00       		.byte	0
 10842 0334 00       		.byte	0
 10843 0335 03       		.byte	3
 10844 0336 00       		.byte	0
 10845 0337 01       		.byte	1
 10846 0338 00       		.byte	0
 10847 0339 03       		.byte	3
 10848 033a 00       		.byte	0
 10849 033b 00       		.byte	0
 10850 033c 00       		.byte	0
 10851 033d 00       		.byte	0
 10852 033e 00       		.byte	0
 10853 033f 30       		.byte	48
 10854 0340 01       		.byte	1
 10855 0341 00       		.byte	0
 10856 0342 00       		.byte	0
 10857 0343 00000000 		.space	5
 10857      00
 10858 0348 18       		.byte	24
 10859 0349 18       		.byte	24
 10860 034a 02       		.byte	2
 10861 034b 00       		.byte	0
 10862 034c 00       		.byte	0
 10863 034d 01       		.byte	1
 10864 034e 00       		.byte	0
 10865 034f 01       		.byte	1
 10866 0350 00       		.byte	0
 10867 0351 03       		.byte	3
 10868 0352 00       		.byte	0
 10869 0353 00       		.byte	0
 10870 0354 00       		.byte	0
 10871 0355 00       		.byte	0
 10872 0356 00       		.byte	0
 10873 0357 30       		.byte	48
 10874 0358 01       		.byte	1
 10875 0359 00       		.byte	0
 10876 035a 00       		.byte	0
 10877 035b 00000000 		.space	5
 10877      00
 10878 0360 19       		.byte	25
 10879 0361 19       		.byte	25
 10880 0362 01       		.byte	1
 10881 0363 00       		.byte	0
 10882 0364 00       		.byte	0
 10883 0365 40       		.byte	64
 10884 0366 00       		.byte	0
 10885 0367 01       		.byte	1
 10886 0368 00       		.byte	0
 10887 0369 03       		.byte	3
 10888 036a 00       		.byte	0
 10889 036b 20       		.byte	32
 10890 036c 00       		.byte	0
 10891 036d 20       		.byte	32
 10892 036e 00       		.byte	0
 10893 036f 30       		.byte	48
 10894 0370 01       		.byte	1
 10895 0371 00       		.byte	0
 10896 0372 00       		.byte	0
 10897 0373 00000000 		.space	5
 10897      00
 10898 0378 20       		.byte	32
 10899 0379 20       		.byte	32
 10900 037a 02       		.byte	2
 10901 037b 00       		.byte	0
 10902 037c 00       		.byte	0
 10903 037d 02       		.byte	2
 10904 037e 00       		.byte	0
 10905 037f 01       		.byte	1
 10906 0380 00       		.byte	0
 10907 0381 03       		.byte	3
 10908 0382 00       		.byte	0
 10909 0383 00       		.byte	0
 10910 0384 00       		.byte	0
 10911 0385 00       		.byte	0
 10912 0386 00       		.byte	0
 10913 0387 30       		.byte	48
 10914 0388 01       		.byte	1
 10915 0389 00       		.byte	0
 10916 038a 00       		.byte	0
 10917 038b 00000000 		.space	5
 10917      00
 10918 0390 22       		.byte	34
 10919 0391 22       		.byte	34
 10920 0392 02       		.byte	2
 10921 0393 00       		.byte	0
 10922 0394 00       		.byte	0
 10923 0395 3F       		.byte	63
 10924 0396 00       		.byte	0
 10925 0397 01       		.byte	1
 10926 0398 00       		.byte	0
 10927 0399 03       		.byte	3
 10928 039a 00       		.byte	0
 10929 039b 00       		.byte	0
 10930 039c 00       		.byte	0
 10931 039d 00       		.byte	0
 10932 039e 00       		.byte	0
 10933 039f 30       		.byte	48
 10934 03a0 01       		.byte	1
 10935 03a1 00       		.byte	0
 10936 03a2 00       		.byte	0
 10937 03a3 00000000 		.space	5
 10937      00
 10938 03a8 23       		.byte	35
 10939 03a9 23       		.byte	35
 10940 03aa 02       		.byte	2
 10941 03ab 00       		.byte	0
 10942 03ac 00       		.byte	0
 10943 03ad 64       		.byte	100
 10944 03ae 00       		.byte	0
 10945 03af 01       		.byte	1
 10946 03b0 00       		.byte	0
 10947 03b1 03       		.byte	3
 10948 03b2 00       		.byte	0
 10949 03b3 10       		.byte	16
 10950 03b4 00       		.byte	0
 10951 03b5 10       		.byte	16
 10952 03b6 00       		.byte	0
 10953 03b7 30       		.byte	48
 10954 03b8 01       		.byte	1
 10955 03b9 00       		.byte	0
 10956 03ba 00       		.byte	0
 10957 03bb 00000000 		.space	5
 10957      00
 10958 03c0 24       		.byte	36
 10959 03c1 24       		.byte	36
 10960 03c2 02       		.byte	2
 10961 03c3 00       		.byte	0
 10962 03c4 00       		.byte	0
 10963 03c5 64       		.byte	100
 10964 03c6 00       		.byte	0
 10965 03c7 01       		.byte	1
 10966 03c8 00       		.byte	0
 10967 03c9 03       		.byte	3
 10968 03ca 00       		.byte	0
 10969 03cb 10       		.byte	16
 10970 03cc 00       		.byte	0
 10971 03cd 10       		.byte	16
 10972 03ce 00       		.byte	0
 10973 03cf 30       		.byte	48
 10974 03d0 01       		.byte	1
 10975 03d1 00       		.byte	0
 10976 03d2 00       		.byte	0
 10977 03d3 00000000 		.space	5
 10977      00
 10978 03d8 02       		.byte	2
 10979 03d9 03       		.byte	3
 10980 03da 04       		.byte	4
 10981 03db 00       		.byte	0
 10982 03dc 00       		.byte	0
 10983 03dd 7F       		.byte	127
 10984 03de 00       		.byte	0
 10985 03df 01       		.byte	1
 10986 03e0 00       		.byte	0
 10987 03e1 03       		.byte	3
 10988 03e2 00       		.byte	0
 10989 03e3 00       		.byte	0
 10990 03e4 20       		.byte	32
 10991 03e5 00       		.byte	0
 10992 03e6 20       		.byte	32
 10993 03e7 30       		.byte	48
 10994 03e8 01       		.byte	1
 10995 03e9 00       		.byte	0
 10996 03ea 00       		.byte	0
 10997 03eb 00000000 		.space	5
 10997      00
 10998 03f0 04       		.byte	4
 10999 03f1 04       		.byte	4
 11000 03f2 02       		.byte	2
 11001 03f3 00       		.byte	0
 11002 03f4 00       		.byte	0
 11003 03f5 FF       		.byte	-1
 11004 03f6 00       		.byte	0
 11005 03f7 01       		.byte	1
 11006 03f8 00       		.byte	0
 11007 03f9 03       		.byte	3
 11008 03fa 00       		.byte	0
 11009 03fb 60       		.byte	96
 11010 03fc 00       		.byte	0
 11011 03fd 60       		.byte	96
 11012 03fe 00       		.byte	0
 11013 03ff 30       		.byte	48
 11014 0400 01       		.byte	1
 11015 0401 00       		.byte	0
 11016 0402 00       		.byte	0
 11017 0403 00000000 		.space	5
 11017      00
 11018 0408 00       		.byte	0
 11019 0409 00       		.byte	0
 11020 040a 02       		.byte	2
 11021 040b 00       		.byte	0
 11022 040c 00       		.byte	0
 11023 040d 19       		.byte	25
 11024 040e 00       		.byte	0
 11025 040f 01       		.byte	1
 11026 0410 00       		.byte	0
 11027 0411 03       		.byte	3
 11028 0412 00       		.byte	0
 11029 0413 00       		.byte	0
 11030 0414 00       		.byte	0
 11031 0415 00       		.byte	0
 11032 0416 00       		.byte	0
 11033 0417 30       		.byte	48
 11034 0418 01       		.byte	1
 11035 0419 00       		.byte	0
 11036 041a 00       		.byte	0
 11037 041b 00000000 		.space	5
 11037      00
 11038 0420 10       		.byte	16
 11039 0421 10       		.byte	16
 11040 0422 02       		.byte	2
 11041 0423 00       		.byte	0
 11042 0424 00       		.byte	0
 11043 0425 06       		.byte	6
 11044 0426 00       		.byte	0
 11045 0427 01       		.byte	1
 11046 0428 00       		.byte	0
 11047 0429 03       		.byte	3
 11048 042a 00       		.byte	0
 11049 042b 03       		.byte	3
 11050 042c 00       		.byte	0
 11051 042d 03       		.byte	3
 11052 042e 00       		.byte	0
 11053 042f 30       		.byte	48
 11054 0430 01       		.byte	1
 11055 0431 00       		.byte	0
 11056 0432 00       		.byte	0
 11057 0433 00000000 		.space	5
 11057      00
 11058 0438 00       		.byte	0
 11059 0439 00       		.byte	0
 11060 043a 02       		.byte	2
 11061 043b 00       		.byte	0
 11062 043c 00       		.byte	0
 11063 043d 03       		.byte	3
 11064 043e 00       		.byte	0
 11065 043f 01       		.byte	1
 11066 0440 00       		.byte	0
 11067 0441 03       		.byte	3
 11068 0442 00       		.byte	0
 11069 0443 00       		.byte	0
 11070 0444 00       		.byte	0
 11071 0445 00       		.byte	0
 11072 0446 00       		.byte	0
 11073 0447 30       		.byte	48
 11074 0448 01       		.byte	1
 11075 0449 00       		.byte	0
 11076 044a 00       		.byte	0
 11077 044b 00000000 		.space	5
 11077      00
 11078 0450 50       		.byte	80
 11079 0451 50       		.byte	80
 11080 0452 01       		.byte	1
 11081 0453 00       		.byte	0
 11082 0454 00       		.byte	0
 11083 0455 03       		.byte	3
 11084 0456 00       		.byte	0
 11085 0457 01       		.byte	1
 11086 0458 00       		.byte	0
 11087 0459 03       		.byte	3
 11088 045a 00       		.byte	0
 11089 045b 00       		.byte	0
 11090 045c 00       		.byte	0
 11091 045d 00       		.byte	0
 11092 045e 00       		.byte	0
 11093 045f 30       		.byte	48
 11094 0460 01       		.byte	1
 11095 0461 00       		.byte	0
 11096 0462 00       		.byte	0
 11097 0463 00000000 		.space	5
 11097      00
 11098 0468 00       		.byte	0
 11099 0469 00       		.byte	0
 11100 046a 0B       		.byte	11
 11101 046b 00       		.byte	0
 11102 046c 00       		.byte	0
 11103 046d FF       		.byte	-1
 11104 046e FF       		.byte	-1
 11105 046f 01       		.byte	1
 11106 0470 00       		.byte	0
 11107 0471 03       		.byte	3
 11108 0472 00       		.byte	0
 11109 0473 00       		.byte	0
 11110 0474 00       		.byte	0
 11111 0475 00       		.byte	0
 11112 0476 00       		.byte	0
 11113 0477 00       		.byte	0
 11114 0478 01       		.byte	1
 11115 0479 00       		.byte	0
 11116 047a 00       		.byte	0
 11117 047b 00000000 		.space	5
 11117      00
 11120              	glUVCHeader:
 11121 0480 0C       		.byte	12
 11122 0481 8C       		.byte	-116
 11123 0482 00       		.byte	0
 11124 0483 00       		.byte	0
 11125 0484 00       		.byte	0
 11126 0485 00       		.byte	0
 11127 0486 00       		.byte	0
 11128 0487 00       		.byte	0
 11129 0488 00       		.byte	0
 11130 0489 00       		.byte	0
 11131 048a 00       		.byte	0
 11132 048b 00       		.byte	0
 11135              	dbgIdx:
 11136 048c 02       		.byte	2
 11139              	ROIMode:
 11140 048d 01       		.byte	1
 11143              	valIdx:
 11144 048e 01       		.byte	1
 11145 048f 00       		.space	1
 11148              	EXTBLCWinPos:
 11149 0490 14       		.byte	20
 11150 0491 13       		.byte	19
 11151 0492 02       		.byte	2
 11152 0493 00       		.byte	0
 11153 0494 00       		.byte	0
 11154 0495 FF       		.byte	-1
 11155 0496 FF       		.byte	-1
 11156 0497 01       		.byte	1
 11157 0498 00       		.byte	0
 11158 0499 03       		.byte	3
 11159 049a 00       		.byte	0
 11160 049b 66       		.byte	102
 11161 049c 66       		.byte	102
 11162 049d 66       		.byte	102
 11163 049e 66       		.byte	102
 11164 049f 30       		.byte	48
 11165 04a0 01       		.byte	1
 11166 04a1 00       		.byte	0
 11167 04a2 0000     		.space	2
 11170              	EXTBLCWeight:
 11171 04a4 11       		.byte	17
 11172 04a5 11       		.byte	17
 11173 04a6 02       		.byte	2
 11174 04a7 00       		.byte	0
 11175 04a8 00       		.byte	0
 11176 04a9 FF       		.byte	-1
 11177 04aa 00       		.byte	0
 11178 04ab 01       		.byte	1
 11179 04ac 00       		.byte	0
 11180 04ad 03       		.byte	3
 11181 04ae 00       		.byte	0
 11182 04af 80       		.byte	-128
 11183 04b0 00       		.byte	0
 11184 04b1 80       		.byte	-128
 11185 04b2 00       		.byte	0
 11186 04b3 30       		.byte	48
 11187 04b4 01       		.byte	1
 11188 04b5 00       		.byte	0
 11189 04b6 0000     		.space	2
 11192              	EXTShutter:
 11193 04b8 00       		.byte	0
 11194 04b9 02       		.byte	2
 11195 04ba 02       		.byte	2
 11196 04bb 00       		.byte	0
 11197 04bc 00       		.byte	0
 11198 04bd 08       		.byte	8
 11199 04be 00       		.byte	0
 11200 04bf 01       		.byte	1
 11201 04c0 00       		.byte	0
 11202 04c1 03       		.byte	3
 11203 04c2 00       		.byte	0
 11204 04c3 00       		.byte	0
 11205 04c4 00       		.byte	0
 11206 04c5 00       		.byte	0
 11207 04c6 00       		.byte	0
 11208 04c7 30       		.byte	48
 11209 04c8 01       		.byte	1
 11210 04c9 00       		.byte	0
 11211 04ca 0000     		.space	2
 11214              	EXTShutlev:
 11215 04cc 02       		.byte	2
 11216 04cd 12       		.byte	18
 11217 04ce 02       		.byte	2
 11218 04cf 00       		.byte	0
 11219 04d0 00       		.byte	0
 11220 04d1 FF       		.byte	-1
 11221 04d2 7F       		.byte	127
 11222 04d3 01       		.byte	1
 11223 04d4 00       		.byte	0
 11224 04d5 03       		.byte	3
 11225 04d6 00       		.byte	0
 11226 04d7 3F       		.byte	63
 11227 04d8 00       		.byte	0
 11228 04d9 3F       		.byte	63
 11229 04da 00       		.byte	0
 11230 04db 30       		.byte	48
 11231 04dc 01       		.byte	1
 11232 04dd 00       		.byte	0
 11233 04de 0000     		.space	2
 11236              	EXTAexModGainlev:
 11237 04e0 00       		.byte	0
 11238 04e1 03       		.byte	3
 11239 04e2 04       		.byte	4
 11240 04e3 00       		.byte	0
 11241 04e4 00       		.byte	0
 11242 04e5 03       		.byte	3
 11243 04e6 7F       		.byte	127
 11244 04e7 01       		.byte	1
 11245 04e8 00       		.byte	0
 11246 04e9 03       		.byte	3
 11247 04ea 00       		.byte	0
 11248 04eb 00       		.byte	0
 11249 04ec 3F       		.byte	63
 11250 04ed 00       		.byte	0
 11251 04ee 3F       		.byte	63
 11252 04ef 30       		.byte	48
 11253 04f0 01       		.byte	1
 11254 04f1 00       		.byte	0
 11255 04f2 0000     		.space	2
 11258              	WBMenuCmpArry:
 11259 04f4 20       		.byte	32
 11260 04f5 0F       		.byte	15
 11261 04f6 38       		.byte	56
 11262 04f7 F0       		.byte	-16
 11265              	PUCBLC:
 11266 04f8 10       		.byte	16
 11267 04f9 11       		.byte	17
 11268 04fa 02       		.byte	2
 11269 04fb 00       		.byte	0
 11270 04fc 00       		.byte	0
 11271 04fd 03       		.byte	3
 11272 04fe 00       		.byte	0
 11273 04ff 01       		.byte	1
 11274 0500 00       		.byte	0
 11275 0501 03       		.byte	3
 11276 0502 00       		.byte	0
 11277 0503 03       		.byte	3
 11278 0504 00       		.byte	0
 11279 0505 03       		.byte	3
 11280 0506 00       		.byte	0
 11281 0507 30       		.byte	48
 11282 0508 01       		.byte	1
 11283 0509 00       		.byte	0
 11284 050a 0000     		.space	2
 11287              	PUCSharp:
 11288 050c 06       		.byte	6
 11289 050d 07       		.byte	7
 11290 050e 02       		.byte	2
 11291 050f 00       		.byte	0
 11292 0510 00       		.byte	0
 11293 0511 08       		.byte	8
 11294 0512 00       		.byte	0
 11295 0513 01       		.byte	1
 11296 0514 00       		.byte	0
 11297 0515 03       		.byte	3
 11298 0516 00       		.byte	0
 11299 0517 00       		.byte	0
 11300 0518 00       		.byte	0
 11301 0519 00       		.byte	0
 11302 051a 00       		.byte	0
 11303 051b 30       		.byte	48
 11304 051c 01       		.byte	1
 11305 051d 00       		.byte	0
 11306 051e 0000     		.space	2
 11309              	CTCtrlParArry:
 11310 0520 00       		.byte	0
 11311 0521 00       		.byte	0
 11312 0522 01       		.byte	1
 11313 0523 00       		.byte	0
 11314 0524 00       		.byte	0
 11315 0525 03       		.byte	3
 11316 0526 00       		.byte	0
 11317 0527 01       		.byte	1
 11318 0528 00       		.byte	0
 11319 0529 03       		.byte	3
 11320 052a 00       		.byte	0
 11321 052b 03       		.byte	3
 11322 052c 00       		.byte	0
 11323 052d 03       		.byte	3
 11324 052e 00       		.byte	0
 11325 052f 30       		.byte	48
 11326 0530 01       		.byte	1
 11327 0531 00       		.byte	0
 11328 0532 00       		.byte	0
 11329 0533 00000000 		.space	5
 11329      00
 11330 0538 00       		.byte	0
 11331 0539 00       		.byte	0
 11332 053a 01       		.byte	1
 11333 053b 01       		.byte	1
 11334 053c 00       		.byte	0
 11335 053d 0F       		.byte	15
 11336 053e 00       		.byte	0
 11337 053f 0F       		.byte	15
 11338 0540 00       		.byte	0
 11339 0541 03       		.byte	3
 11340 0542 00       		.byte	0
 11341 0543 02       		.byte	2
 11342 0544 00       		.byte	0
 11343 0545 02       		.byte	2
 11344 0546 00       		.byte	0
 11345 0547 30       		.byte	48
 11346 0548 01       		.byte	1
 11347 0549 01       		.byte	1
 11348 054a 00       		.byte	0
 11349 054b 00000000 		.space	5
 11349      00
 11350 0550 02       		.byte	2
 11351 0551 00       		.byte	0
 11352 0552 01       		.byte	1
 11353 0553 00       		.byte	0
 11354 0554 00       		.byte	0
 11355 0555 01       		.byte	1
 11356 0556 00       		.byte	0
 11357 0557 01       		.byte	1
 11358 0558 00       		.byte	0
 11359 0559 03       		.byte	3
 11360 055a 00       		.byte	0
 11361 055b 00       		.byte	0
 11362 055c 00       		.byte	0
 11363 055d 00       		.byte	0
 11364 055e 00       		.byte	0
 11365 055f 30       		.byte	48
 11366 0560 01       		.byte	1
 11367 0561 01       		.byte	1
 11368 0562 00       		.byte	0
 11369 0563 00000000 		.space	5
 11369      00
 11370 0568 00       		.byte	0
 11371 0569 00       		.byte	0
 11372 056a 04       		.byte	4
 11373 056b 01       		.byte	1
 11374 056c 00       		.byte	0
 11375 056d 38       		.byte	56
 11376 056e 01       		.byte	1
 11377 056f 01       		.byte	1
 11378 0570 00       		.byte	0
 11379 0571 03       		.byte	3
 11380 0572 00       		.byte	0
 11381 0573 4E       		.byte	78
 11382 0574 00       		.byte	0
 11383 0575 4E       		.byte	78
 11384 0576 00       		.byte	0
 11385 0577 30       		.byte	48
 11386 0578 01       		.byte	1
 11387 0579 00       		.byte	0
 11388 057a 00       		.byte	0
 11389 057b 00000000 		.space	5
 11389      00
 11390 0580 04       		.byte	4
 11391 0581 00       		.byte	0
 11392 0582 01       		.byte	1
 11393 0583 00       		.byte	0
 11394 0584 00       		.byte	0
 11395 0585 00       		.byte	0
 11396 0586 00       		.byte	0
 11397 0587 01       		.byte	1
 11398 0588 00       		.byte	0
 11399 0589 03       		.byte	3
 11400 058a 00       		.byte	0
 11401 058b 00       		.byte	0
 11402 058c 00       		.byte	0
 11403 058d 00       		.byte	0
 11404 058e 00       		.byte	0
 11405 058f 30       		.byte	48
 11406 0590 01       		.byte	1
 11407 0591 00       		.byte	0
 11408 0592 00       		.byte	0
 11409 0593 00000000 		.space	5
 11409      00
 11410 0598 05       		.byte	5
 11411 0599 00       		.byte	0
 11412 059a 02       		.byte	2
 11413 059b 00       		.byte	0
 11414 059c 00       		.byte	0
 11415 059d FF       		.byte	-1
 11416 059e 00       		.byte	0
 11417 059f 01       		.byte	1
 11418 05a0 00       		.byte	0
 11419 05a1 03       		.byte	3
 11420 05a2 00       		.byte	0
 11421 05a3 01       		.byte	1
 11422 05a4 00       		.byte	0
 11423 05a5 00       		.byte	0
 11424 05a6 00       		.byte	0
 11425 05a7 30       		.byte	48
 11426 05a8 01       		.byte	1
 11427 05a9 01       		.byte	1
 11428 05aa 00       		.byte	0
 11429 05ab 00000000 		.space	5
 11429      00
 11430 05b0 06       		.byte	6
 11431 05b1 00       		.byte	0
 11432 05b2 02       		.byte	2
 11433 05b3 00       		.byte	0
 11434 05b4 00       		.byte	0
 11435 05b5 00       		.byte	0
 11436 05b6 00       		.byte	0
 11437 05b7 00       		.byte	0
 11438 05b8 00       		.byte	0
 11439 05b9 03       		.byte	3
 11440 05ba 00       		.byte	0
 11441 05bb 00       		.byte	0
 11442 05bc 00       		.byte	0
 11443 05bd 00       		.byte	0
 11444 05be 00       		.byte	0
 11445 05bf 30       		.byte	48
 11446 05c0 01       		.byte	1
 11447 05c1 01       		.byte	1
 11448 05c2 00       		.byte	0
 11449 05c3 00000000 		.space	5
 11449      00
 11450 05c8 23       		.byte	35
 11451 05c9 00       		.byte	0
 11452 05ca 02       		.byte	2
 11453 05cb 00       		.byte	0
 11454 05cc 00       		.byte	0
 11455 05cd 30       		.byte	48
 11456 05ce 00       		.byte	0
 11457 05cf 01       		.byte	1
 11458 05d0 00       		.byte	0
 11459 05d1 03       		.byte	3
 11460 05d2 0A       		.byte	10
 11461 05d3 00       		.byte	0
 11462 05d4 00       		.byte	0
 11463 05d5 0A       		.byte	10
 11464 05d6 00       		.byte	0
 11465 05d7 30       		.byte	48
 11466 05d8 01       		.byte	1
 11467 05d9 01       		.byte	1
 11468 05da 00       		.byte	0
 11469 05db 00000000 		.space	5
 11469      00
 11470 05e0 08       		.byte	8
 11471 05e1 00       		.byte	0
 11472 05e2 01       		.byte	1
 11473 05e3 00       		.byte	0
 11474 05e4 00       		.byte	0
 11475 05e5 7F       		.byte	127
 11476 05e6 00       		.byte	0
 11477 05e7 01       		.byte	1
 11478 05e8 00       		.byte	0
 11479 05e9 03       		.byte	3
 11480 05ea 00       		.byte	0
 11481 05eb 00       		.byte	0
 11482 05ec 00       		.byte	0
 11483 05ed 00       		.byte	0
 11484 05ee 00       		.byte	0
 11485 05ef 30       		.byte	48
 11486 05f0 01       		.byte	1
 11487 05f1 00       		.byte	0
 11488 05f2 00       		.byte	0
 11489 05f3 00000000 		.space	5
 11489      00
 11490 05f8 09       		.byte	9
 11491 05f9 00       		.byte	0
 11492 05fa 02       		.byte	2
 11493 05fb 00       		.byte	0
 11494 05fc 00       		.byte	0
 11495 05fd 05       		.byte	5
 11496 05fe 00       		.byte	0
 11497 05ff 01       		.byte	1
 11498 0600 00       		.byte	0
 11499 0601 03       		.byte	3
 11500 0602 00       		.byte	0
 11501 0603 00       		.byte	0
 11502 0604 00       		.byte	0
 11503 0605 00       		.byte	0
 11504 0606 00       		.byte	0
 11505 0607 30       		.byte	48
 11506 0608 01       		.byte	1
 11507 0609 00       		.byte	0
 11508 060a 00       		.byte	0
 11509 060b 00000000 		.space	5
 11509      00
 11510 0610 10       		.byte	16
 11511 0611 00       		.byte	0
 11512 0612 03       		.byte	3
 11513 0613 00       		.byte	0
 11514 0614 00       		.byte	0
 11515 0615 00       		.byte	0
 11516 0616 00       		.byte	0
 11517 0617 00       		.byte	0
 11518 0618 00       		.byte	0
 11519 0619 03       		.byte	3
 11520 061a 00       		.byte	0
 11521 061b 00       		.byte	0
 11522 061c 00       		.byte	0
 11523 061d 00       		.byte	0
 11524 061e 00       		.byte	0
 11525 061f 30       		.byte	48
 11526 0620 01       		.byte	1
 11527 0621 00       		.byte	0
 11528 0622 00       		.byte	0
 11529 0623 00000000 		.space	5
 11529      00
 11530 0628 00       		.byte	0
 11531 0629 00       		.byte	0
 11532 062a 02       		.byte	2
 11533 062b 00       		.byte	0
 11534 062c 00       		.byte	0
 11535 062d 40       		.byte	64
 11536 062e 00       		.byte	0
 11537 062f 01       		.byte	1
 11538 0630 00       		.byte	0
 11539 0631 03       		.byte	3
 11540 0632 00       		.byte	0
 11541 0633 0F       		.byte	15
 11542 0634 11       		.byte	17
 11543 0635 00       		.byte	0
 11544 0636 00       		.byte	0
 11545 0637 30       		.byte	48
 11546 0638 01       		.byte	1
 11547 0639 00       		.byte	0
 11548 063a 00       		.byte	0
 11549 063b 00000000 		.space	5
 11549      00
 11550 0640 00       		.byte	0
 11551 0641 00       		.byte	0
 11552 0642 02       		.byte	2
 11553 0643 00       		.byte	0
 11554 0644 00       		.byte	0
 11555 0645 64       		.byte	100
 11556 0646 00       		.byte	0
 11557 0647 01       		.byte	1
 11558 0648 00       		.byte	0
 11559 0649 03       		.byte	3
 11560 064a 00       		.byte	0
 11561 064b 00       		.byte	0
 11562 064c 00       		.byte	0
 11563 064d 00       		.byte	0
 11564 064e 00       		.byte	0
 11565 064f 30       		.byte	48
 11566 0650 01       		.byte	1
 11567 0651 00       		.byte	0
 11568 0652 00       		.byte	0
 11569 0653 00000000 		.space	5
 11569      00
 11570 0658 00       		.byte	0
 11571 0659 00       		.byte	0
 11572 065a 02       		.byte	2
 11573 065b 00       		.byte	0
 11574 065c 00       		.byte	0
 11575 065d 64       		.byte	100
 11576 065e 00       		.byte	0
 11577 065f 01       		.byte	1
 11578 0660 00       		.byte	0
 11579 0661 03       		.byte	3
 11580 0662 00       		.byte	0
 11581 0663 00       		.byte	0
 11582 0664 00       		.byte	0
 11583 0665 00       		.byte	0
 11584 0666 00       		.byte	0
 11585 0667 30       		.byte	48
 11586 0668 01       		.byte	1
 11587 0669 00       		.byte	0
 11588 066a 00       		.byte	0
 11589 066b 00000000 		.space	5
 11589      00
 11590 0670 00       		.byte	0
 11591 0671 00       		.byte	0
 11592 0672 02       		.byte	2
 11593 0673 00       		.byte	0
 11594 0674 00       		.byte	0
 11595 0675 64       		.byte	100
 11596 0676 00       		.byte	0
 11597 0677 01       		.byte	1
 11598 0678 00       		.byte	0
 11599 0679 03       		.byte	3
 11600 067a 00       		.byte	0
 11601 067b 00       		.byte	0
 11602 067c 00       		.byte	0
 11603 067d 00       		.byte	0
 11604 067e 00       		.byte	0
 11605 067f 30       		.byte	48
 11606 0680 01       		.byte	1
 11607 0681 00       		.byte	0
 11608 0682 00       		.byte	0
 11609 0683 00000000 		.space	5
 11609      00
 11610 0688 00       		.byte	0
 11611 0689 00       		.byte	0
 11612 068a 02       		.byte	2
 11613 068b 00       		.byte	0
 11614 068c 00       		.byte	0
 11615 068d 64       		.byte	100
 11616 068e 00       		.byte	0
 11617 068f 01       		.byte	1
 11618 0690 00       		.byte	0
 11619 0691 03       		.byte	3
 11620 0692 00       		.byte	0
 11621 0693 00       		.byte	0
 11622 0694 00       		.byte	0
 11623 0695 00       		.byte	0
 11624 0696 00       		.byte	0
 11625 0697 30       		.byte	48
 11626 0698 01       		.byte	1
 11627 0699 00       		.byte	0
 11628 069a 00       		.byte	0
 11629 069b 00000000 		.space	5
 11629      00
 11632              	glProbeCtrlFull:
 11633 06a0 00       		.byte	0
 11634 06a1 00       		.byte	0
 11635 06a2 01       		.byte	1
 11636 06a3 01       		.byte	1
 11637 06a4 15       		.byte	21
 11638 06a5 16       		.byte	22
 11639 06a6 05       		.byte	5
 11640 06a7 00       		.byte	0
 11641 06a8 00       		.byte	0
 11642 06a9 00       		.byte	0
 11643 06aa 00       		.byte	0
 11644 06ab 00       		.byte	0
 11645 06ac 00       		.byte	0
 11646 06ad 00       		.byte	0
 11647 06ae 00       		.byte	0
 11648 06af 00       		.byte	0
 11649 06b0 00       		.byte	0
 11650 06b1 00       		.byte	0
 11651 06b2 00       		.byte	0
 11652 06b3 C6       		.byte	-58
 11653 06b4 99       		.byte	-103
 11654 06b5 00       		.byte	0
 11655 06b6 00       		.byte	0
 11656 06b7 40       		.byte	64
 11657 06b8 00       		.byte	0
 11658 06b9 00       		.byte	0
 11659 06ba 0000     		.space	2
 11662              	glProbeCtrl20:
 11663 06bc 00       		.byte	0
 11664 06bd 00       		.byte	0
 11665 06be 01       		.byte	1
 11666 06bf 01       		.byte	1
 11667 06c0 80       		.byte	-128
 11668 06c1 1A       		.byte	26
 11669 06c2 06       		.byte	6
 11670 06c3 00       		.byte	0
 11671 06c4 00       		.byte	0
 11672 06c5 00       		.byte	0
 11673 06c6 00       		.byte	0
 11674 06c7 00       		.byte	0
 11675 06c8 00       		.byte	0
 11676 06c9 00       		.byte	0
 11677 06ca 00       		.byte	0
 11678 06cb 00       		.byte	0
 11679 06cc 00       		.byte	0
 11680 06cd 00       		.byte	0
 11681 06ce 00       		.byte	0
 11682 06cf D2       		.byte	-46
 11683 06d0 0F       		.byte	15
 11684 06d1 00       		.byte	0
 11685 06d2 00       		.byte	0
 11686 06d3 40       		.byte	64
 11687 06d4 00       		.byte	0
 11688 06d5 00       		.byte	0
 11689 06d6 0000     		.space	2
 11692              	glProbeCtrl:
 11693 06d8 00       		.byte	0
 11694 06d9 00       		.byte	0
 11695 06da 01       		.byte	1
 11696 06db 01       		.byte	1
 11697 06dc 15       		.byte	21
 11698 06dd 16       		.byte	22
 11699 06de 05       		.byte	5
 11700 06df 00       		.byte	0
 11701 06e0 00       		.byte	0
 11702 06e1 00       		.byte	0
 11703 06e2 00       		.byte	0
 11704 06e3 00       		.byte	0
 11705 06e4 00       		.byte	0
 11706 06e5 00       		.byte	0
 11707 06e6 00       		.byte	0
 11708 06e7 00       		.byte	0
 11709 06e8 00       		.byte	0
 11710 06e9 00       		.byte	0
 11711 06ea 00       		.byte	0
 11712 06eb 48       		.byte	72
 11713 06ec 3F       		.byte	63
 11714 06ed 00       		.byte	0
 11715 06ee 00       		.byte	0
 11716 06ef 40       		.byte	64
 11717 06f0 00       		.byte	0
 11718 06f1 00       		.byte	0
 11719 06f2 0000     		.space	2
 11722              	glProbeStilCtrl:
 11723 06f4 01       		.byte	1
 11724 06f5 02       		.byte	2
 11725 06f6 00       		.byte	0
 11726 06f7 00       		.byte	0
 11727 06f8 C6       		.byte	-58
 11728 06f9 99       		.byte	-103
 11729 06fa 00       		.byte	0
 11730 06fb 00       		.byte	0
 11731 06fc 40       		.byte	64
 11732 06fd 00       		.byte	0
 11733 06fe 00       		.byte	0
 11734 06ff 00       		.space	1
 11737              	glProbeStilCtrl20:
 11738 0700 01       		.byte	1
 11739 0701 01       		.byte	1
 11740 0702 00       		.byte	0
 11741 0703 00       		.byte	0
 11742 0704 D2       		.byte	-46
 11743 0705 0F       		.byte	15
 11744 0706 00       		.byte	0
 11745 0707 00       		.byte	0
 11746 0708 40       		.byte	64
 11747 0709 00       		.byte	0
 11748 070a 00       		.byte	0
 11751              	snapButFlag:
 11752 070b 01       		.byte	1
 11755              	CyFxGpifTransition:
 11756 070c 0000     		.short	0
 11757 070e 5555     		.short	21845
 11758 0710 8888     		.short	-30584
 11759 0712 AAAA     		.short	-21846
 11760 0714 3333     		.short	13107
 11761 0716 0000     		.space	2
 11764              	CyFxGpifWavedata:
 11765 0718 0181731E 		.word	510886145
 11766 071c 00000000 		.word	0
 11767 0720 00000080 		.word	-2147483648
 11768 0724 00000000 		.word	0
 11769 0728 00000000 		.word	0
 11770 072c 00000000 		.word	0
 11771 0730 0201702E 		.word	779092226
 11772 0734 00010000 		.word	256
 11773 0738 A0000080 		.word	-2147483488
 11774 073c 00000000 		.word	0
 11775 0740 00000000 		.word	0
 11776 0744 00000000 		.word	0
 11777 0748 0380722E 		.word	779255811
 11778 074c 02010020 		.word	536871170
 11779 0750 60000080 		.word	-2147483552
 11780 0754 00000000 		.word	0
 11781 0758 00000000 		.word	0
 11782 075c 00000000 		.word	0
 11783 0760 0460722E 		.word	779247620
 11784 0764 02010024 		.word	603980034
 11785 0768 90000080 		.word	-2147483504
 11786 076c 0594731E 		.word	510891013
 11787 0770 06000000 		.word	6
 11788 0774 00000080 		.word	-2147483648
 11789 0778 0380722E 		.word	779255811
 11790 077c 02010020 		.word	536871170
 11791 0780 60000080 		.word	-2147483552
 11792 0784 0693731E 		.word	510890758
 11793 0788 06000000 		.word	6
 11794 078c 00000080 		.word	-2147483648
 11795 0790 0720703E 		.word	1047535623
 11796 0794 08010000 		.word	264
 11797 0798 00000080 		.word	-2147483648
 11798 079c 0820703E 		.word	1047535624
 11799 07a0 08010000 		.word	264
 11800 07a4 00000080 		.word	-2147483648
 11801 07a8 0920703E 		.word	1047535625
 11802 07ac 08010000 		.word	264
 11803 07b0 00000080 		.word	-2147483648
 11804 07b4 0A20703E 		.word	1047535626
 11805 07b8 08010000 		.word	264
 11806 07bc 00000080 		.word	-2147483648
 11807 07c0 0380722E 		.word	779255811
 11808 07c4 02010020 		.word	536871170
 11809 07c8 60000080 		.word	-2147483552
 11810 07cc 0B000000 		.word	11
 11811 07d0 00000000 		.word	0
 11812 07d4 00010080 		.word	-2147483392
 11813 07d8 0460722E 		.word	779247620
 11814 07dc 02010024 		.word	603980034
 11815 07e0 90000080 		.word	-2147483504
 11816 07e4 0D000000 		.word	13
 11817 07e8 00000000 		.word	0
 11818 07ec 00010080 		.word	-2147483392
 11819 07f0 0460722E 		.word	779247620
 11820 07f4 02010024 		.word	603980034
 11821 07f8 90000080 		.word	-2147483504
 11822 07fc 0C000000 		.word	12
 11823 0800 00000000 		.word	0
 11824 0804 00010080 		.word	-2147483392
 11825 0808 0380722E 		.word	779255811
 11826 080c 02010020 		.word	536871170
 11827 0810 60000080 		.word	-2147483552
 11828 0814 0E000000 		.word	14
 11829 0818 00000000 		.word	0
 11830 081c 00010080 		.word	-2147483392
 11831 0820 00000000 		.word	0
 11832 0824 00000000 		.word	0
 11833 0828 00000000 		.word	0
 11834 082c 00000000 		.word	0
 11835 0830 00000000 		.word	0
 11836 0834 00000000 		.word	0
 11839              	CyFxGpifWavedataPosition:
 11840 0838 00       		.byte	0
 11841 0839 01       		.byte	1
 11842 083a 02       		.byte	2
 11843 083b 03       		.byte	3
 11844 083c 04       		.byte	4
 11845 083d 05       		.byte	5
 11846 083e 06       		.byte	6
 11847 083f 07       		.byte	7
 11848 0840 08       		.byte	8
 11849 0841 09       		.byte	9
 11850 0842 0A       		.byte	10
 11851 0843 0B       		.byte	11
 11852 0844 0B       		.byte	11
 11853 0845 0B       		.byte	11
 11854 0846 0B       		.byte	11
 11855 0847 00       		.space	1
 11858              	CyFxGpifRegValue:
 11859 0848 08830080 		.word	-2147450104
 11860 084c 67000000 		.word	103
 11861 0850 00000000 		.word	0
 11862 0854 46000000 		.word	70
 11863 0858 00000000 		.word	0
 11864 085c 00000000 		.word	0
 11865 0860 02000000 		.word	2
 11866 0864 82000000 		.word	130
 11867 0868 82070000 		.word	1922
 11868 086c 40040000 		.word	1088
 11869 0870 FCFF0000 		.word	65532
 11870 0874 28000000 		.word	40
 11871 0878 00000000 		.word	0
 11872 087c 00000000 		.word	0
 11873 0880 00000000 		.word	0
 11874 0884 00000000 		.word	0
 11875 0888 01000000 		.word	1
 11876 088c 00000000 		.word	0
 11877 0890 00000000 		.word	0
 11878 0894 00000000 		.word	0
 11879 0898 00000000 		.word	0
 11880 089c 00000000 		.word	0
 11881 08a0 00000000 		.word	0
 11882 08a4 00000000 		.word	0
 11883 08a8 00000000 		.word	0
 11884 08ac 00000000 		.word	0
 11885 08b0 00000000 		.word	0
 11886 08b4 00000000 		.word	0
 11887 08b8 00000000 		.word	0
 11888 08bc 06000000 		.word	6
 11889 08c0 00000000 		.word	0
 11890 08c4 FFFF0000 		.word	65535
 11891 08c8 09010000 		.word	265
 11892 08cc 00000000 		.word	0
 11893 08d0 F71F0000 		.word	8183
 11894 08d4 00000000 		.word	0
 11895 08d8 FFFF0000 		.word	65535
 11896 08dc 09010000 		.word	265
 11897 08e0 00000000 		.word	0
 11898 08e4 F71F0000 		.word	8183
 11899 08e8 00000000 		.word	0
 11900 08ec 00000000 		.word	0
 11901 08f0 00000000 		.word	0
 11902 08f4 00000000 		.word	0
 11903 08f8 00000000 		.word	0
 11904 08fc 00000000 		.word	0
 11905 0900 00000000 		.word	0
 11906 0904 00000000 		.word	0
 11907 0908 00000000 		.word	0
 11908 090c 00000000 		.word	0
 11909 0910 00000000 		.word	0
 11910 0914 00000000 		.word	0
 11911 0918 00000000 		.word	0
 11912 091c 00000000 		.word	0
 11913 0920 00000000 		.word	0
 11914 0924 00000000 		.word	0
 11915 0928 00000000 		.word	0
 11916 092c 00000000 		.word	0
 11917 0930 00000000 		.word	0
 11918 0934 00000000 		.word	0
 11919 0938 00000000 		.word	0
 11920 093c 00000000 		.word	0
 11921 0940 00000000 		.word	0
 11922 0944 00040180 		.word	-2147417088
 11923 0948 01040180 		.word	-2147417087
 11924 094c 02040180 		.word	-2147417086
 11925 0950 03040180 		.word	-2147417085
 11926 0954 00000000 		.word	0
 11927 0958 00000000 		.word	0
 11928 095c 00000000 		.word	0
 11929 0960 00000000 		.word	0
 11930 0964 00000000 		.word	0
 11931 0968 00000000 		.word	0
 11932 096c 00000000 		.word	0
 11933 0970 00000000 		.word	0
 11934 0974 C1FFFFFF 		.word	-63
 11937              	CyFxGpifTransition_usb2:
 11938 0978 0000     		.short	0
 11939 097a 5555     		.short	21845
 11940 097c AAAA     		.short	-21846
 11941 097e 8888     		.short	-30584
 11942 0980 1111     		.short	4369
 11943 0982 4444     		.short	17476
 11944 0984 3333     		.short	13107
 11945 0986 CCCC     		.short	-13108
 11948              	CyFxGpifWavedata_usb2:
 11949 0988 0181731E 		.word	510886145
 11950 098c 00000000 		.word	0
 11951 0990 00000080 		.word	-2147483648
 11952 0994 00000000 		.word	0
 11953 0998 00000000 		.word	0
 11954 099c 00000000 		.word	0
 11955 09a0 0201703E 		.word	1047527682
 11956 09a4 00010000 		.word	256
 11957 09a8 A00000C0 		.word	-1073741664
 11958 09ac 00000000 		.word	0
 11959 09b0 00000000 		.word	0
 11960 09b4 00000000 		.word	0
 11961 09b8 0394731E 		.word	510891011
 11962 09bc 04000020 		.word	536870916
 11963 09c0 60004080 		.word	-2143289248
 11964 09c4 00000000 		.word	0
 11965 09c8 00000000 		.word	0
 11966 09cc 00000000 		.word	0
 11967 09d0 0620702E 		.word	779100166
 11968 09d4 0C000000 		.word	12
 11969 09d8 00000080 		.word	-2147483648
 11970 09dc 0620702E 		.word	779100166
 11971 09e0 0C000000 		.word	12
 11972 09e4 00000080 		.word	-2147483648
 11973 09e8 0394731E 		.word	510891011
 11974 09ec 04000020 		.word	536870916
 11975 09f0 60004080 		.word	-2143289248
 11976 09f4 0620702E 		.word	779100166
 11977 09f8 0C000000 		.word	12
 11978 09fc 00000080 		.word	-2147483648
 11979 0a00 0C93731E 		.word	510890764
 11980 0a04 04000024 		.word	603979780
 11981 0a08 90004080 		.word	-2143289200
 11982 0a0c 0D20702E 		.word	779100173
 11983 0a10 0C000000 		.word	12
 11984 0a14 00000080 		.word	-2147483648
 11985 0a18 0780724E 		.word	1316126727
 11986 0a1c 0A000000 		.word	10
 11987 0a20 00000080 		.word	-2147483648
 11988 0a24 08000000 		.word	8
 11989 0a28 00000000 		.word	0
 11990 0a2c 00010080 		.word	-2147483392
 11991 0a30 0920702E 		.word	779100169
 11992 0a34 0C010000 		.word	268
 11993 0a38 00000080 		.word	-2147483648
 11994 0a3c 0A01701E 		.word	510656778
 11995 0a40 0E000100 		.word	65550
 11996 0a44 00000080 		.word	-2147483648
 11997 0a48 00000000 		.word	0
 11998 0a4c 00000000 		.word	0
 11999 0a50 00000000 		.word	0
 12000 0a54 00000000 		.word	0
 12001 0a58 00000000 		.word	0
 12002 0a5c 00000000 		.word	0
 12003 0a60 0394731E 		.word	510891011
 12004 0a64 04000020 		.word	536870916
 12005 0a68 60004080 		.word	-2143289248
 12006 0a6c 08000000 		.word	8
 12007 0a70 00000000 		.word	0
 12008 0a74 00010080 		.word	-2147483392
 12009 0a78 0B000000 		.word	11
 12010 0a7c 00000000 		.word	0
 12011 0a80 00010080 		.word	-2147483392
 12012 0a84 0C93731E 		.word	510890764
 12013 0a88 04000024 		.word	603979780
 12014 0a8c 90004080 		.word	-2143289200
 12015 0a90 0D20702E 		.word	779100173
 12016 0a94 0C000000 		.word	12
 12017 0a98 00000080 		.word	-2147483648
 12018 0a9c 0D20702E 		.word	779100173
 12019 0aa0 0C000000 		.word	12
 12020 0aa4 00000080 		.word	-2147483648
 12021 0aa8 0E60724E 		.word	1316118542
 12022 0aac 0A000000 		.word	10
 12023 0ab0 00000080 		.word	-2147483648
 12024 0ab4 0F000000 		.word	15
 12025 0ab8 00000000 		.word	0
 12026 0abc 00010080 		.word	-2147483392
 12027 0ac0 1020702E 		.word	779100176
 12028 0ac4 0C010000 		.word	268
 12029 0ac8 00000080 		.word	-2147483648
 12030 0acc 1101701E 		.word	510656785
 12031 0ad0 0E000100 		.word	65550
 12032 0ad4 00000080 		.word	-2147483648
 12033 0ad8 0C93731E 		.word	510890764
 12034 0adc 04000024 		.word	603979780
 12035 0ae0 90004080 		.word	-2143289200
 12036 0ae4 0F000000 		.word	15
 12037 0ae8 00000000 		.word	0
 12038 0aec 00010080 		.word	-2147483392
 12039 0af0 12000000 		.word	18
 12040 0af4 00000000 		.word	0
 12041 0af8 00010080 		.word	-2147483392
 12042 0afc 0394731E 		.word	510891011
 12043 0b00 04000020 		.word	536870916
 12044 0b04 60004080 		.word	-2143289248
 12045 0b08 0480732E 		.word	779321348
 12046 0b0c 02010000 		.word	258
 12047 0b10 0000C0C0 		.word	-1061158912
 12048 0b14 0580732E 		.word	779321349
 12049 0b18 02010000 		.word	258
 12050 0b1c 0000C0C0 		.word	-1061158912
 12051 0b20 0580732E 		.word	779321349
 12052 0b24 02010000 		.word	258
 12053 0b28 0000C0C0 		.word	-1061158912
 12054 0b2c 0480732E 		.word	779321348
 12055 0b30 02010000 		.word	258
 12056 0b34 0000C0C0 		.word	-1061158912
 12059              	CyFxGpifWavedataPosition_usb2:
 12060 0b38 00       		.byte	0
 12061 0b39 01       		.byte	1
 12062 0b3a 02       		.byte	2
 12063 0b3b 03       		.byte	3
 12064 0b3c 04       		.byte	4
 12065 0b3d 05       		.byte	5
 12066 0b3e 06       		.byte	6
 12067 0b3f 07       		.byte	7
 12068 0b40 08       		.byte	8
 12069 0b41 09       		.byte	9
 12070 0b42 0A       		.byte	10
 12071 0b43 08       		.byte	8
 12072 0b44 0B       		.byte	11
 12073 0b45 0C       		.byte	12
 12074 0b46 0D       		.byte	13
 12075 0b47 08       		.byte	8
 12076 0b48 0E       		.byte	14
 12077 0b49 0F       		.byte	15
 12078 0b4a 08       		.byte	8
 12079 0b4b 08       		.byte	8
 12080 0b4c 08       		.byte	8
 12081 0b4d 08       		.byte	8
 12082 0b4e 08       		.byte	8
 12083 0b4f 08       		.byte	8
 12084 0b50 08       		.byte	8
 12085 0b51 08       		.byte	8
 12086 0b52 08       		.byte	8
 12087 0b53 08       		.byte	8
 12088 0b54 08       		.byte	8
 12089 0b55 08       		.byte	8
 12090 0b56 08       		.byte	8
 12091 0b57 08       		.byte	8
 12092 0b58 08       		.byte	8
 12093 0b59 08       		.byte	8
 12094 0b5a 08       		.byte	8
 12095 0b5b 08       		.byte	8
 12096 0b5c 08       		.byte	8
 12097 0b5d 08       		.byte	8
 12098 0b5e 08       		.byte	8
 12099 0b5f 08       		.byte	8
 12100 0b60 08       		.byte	8
 12101 0b61 08       		.byte	8
 12102 0b62 08       		.byte	8
 12103 0b63 08       		.byte	8
 12104 0b64 08       		.byte	8
 12105 0b65 08       		.byte	8
 12106 0b66 08       		.byte	8
 12107 0b67 08       		.byte	8
 12108 0b68 08       		.byte	8
 12109 0b69 08       		.byte	8
 12110 0b6a 08       		.byte	8
 12111 0b6b 08       		.byte	8
 12112 0b6c 08       		.byte	8
 12113 0b6d 08       		.byte	8
 12114 0b6e 08       		.byte	8
 12115 0b6f 08       		.byte	8
 12116 0b70 08       		.byte	8
 12117 0b71 08       		.byte	8
 12118 0b72 08       		.byte	8
 12119 0b73 08       		.byte	8
 12120 0b74 08       		.byte	8
 12121 0b75 08       		.byte	8
 12122 0b76 08       		.byte	8
 12123 0b77 08       		.byte	8
 12124 0b78 08       		.byte	8
 12125 0b79 08       		.byte	8
 12126 0b7a 08       		.byte	8
 12127 0b7b 08       		.byte	8
 12128 0b7c 08       		.byte	8
 12129 0b7d 08       		.byte	8
 12130 0b7e 08       		.byte	8
 12131 0b7f 08       		.byte	8
 12132 0b80 08       		.byte	8
 12133 0b81 08       		.byte	8
 12134 0b82 08       		.byte	8
 12135 0b83 08       		.byte	8
 12136 0b84 08       		.byte	8
 12137 0b85 08       		.byte	8
 12138 0b86 08       		.byte	8
 12139 0b87 08       		.byte	8
 12140 0b88 08       		.byte	8
 12141 0b89 08       		.byte	8
 12142 0b8a 08       		.byte	8
 12143 0b8b 08       		.byte	8
 12144 0b8c 08       		.byte	8
 12145 0b8d 08       		.byte	8
 12146 0b8e 08       		.byte	8
 12147 0b8f 08       		.byte	8
 12148 0b90 08       		.byte	8
 12149 0b91 08       		.byte	8
 12150 0b92 08       		.byte	8
 12151 0b93 08       		.byte	8
 12152 0b94 08       		.byte	8
 12153 0b95 08       		.byte	8
 12154 0b96 08       		.byte	8
 12155 0b97 08       		.byte	8
 12156 0b98 08       		.byte	8
 12157 0b99 08       		.byte	8
 12158 0b9a 08       		.byte	8
 12159 0b9b 08       		.byte	8
 12160 0b9c 08       		.byte	8
 12161 0b9d 08       		.byte	8
 12162 0b9e 08       		.byte	8
 12163 0b9f 08       		.byte	8
 12164 0ba0 08       		.byte	8
 12165 0ba1 08       		.byte	8
 12166 0ba2 08       		.byte	8
 12167 0ba3 08       		.byte	8
 12168 0ba4 08       		.byte	8
 12169 0ba5 08       		.byte	8
 12170 0ba6 08       		.byte	8
 12171 0ba7 08       		.byte	8
 12172 0ba8 08       		.byte	8
 12173 0ba9 08       		.byte	8
 12174 0baa 08       		.byte	8
 12175 0bab 08       		.byte	8
 12176 0bac 08       		.byte	8
 12177 0bad 08       		.byte	8
 12178 0bae 08       		.byte	8
 12179 0baf 08       		.byte	8
 12180 0bb0 08       		.byte	8
 12181 0bb1 08       		.byte	8
 12182 0bb2 08       		.byte	8
 12183 0bb3 08       		.byte	8
 12184 0bb4 08       		.byte	8
 12185 0bb5 08       		.byte	8
 12186 0bb6 08       		.byte	8
 12187 0bb7 08       		.byte	8
 12188 0bb8 00       		.byte	0
 12189 0bb9 01       		.byte	1
 12190 0bba 02       		.byte	2
 12191 0bbb 10       		.byte	16
 12192 0bbc 04       		.byte	4
 12193 0bbd 05       		.byte	5
 12194 0bbe 06       		.byte	6
 12195 0bbf 07       		.byte	7
 12196 0bc0 08       		.byte	8
 12197 0bc1 09       		.byte	9
 12198 0bc2 0A       		.byte	10
 12199 0bc3 08       		.byte	8
 12200 0bc4 11       		.byte	17
 12201 0bc5 0C       		.byte	12
 12202 0bc6 0D       		.byte	13
 12203 0bc7 08       		.byte	8
 12204 0bc8 0E       		.byte	14
 12205 0bc9 0F       		.byte	15
 12206 0bca 08       		.byte	8
 12207 0bcb 00       		.space	1
 12210              	CyFxGpifRegValue_usb2:
 12211 0bcc 08830080 		.word	-2147450104
 12212 0bd0 67000000 		.word	103
 12213 0bd4 01000000 		.word	1
 12214 0bd8 46000000 		.word	70
 12215 0bdc 00000000 		.word	0
 12216 0be0 00000000 		.word	0
 12217 0be4 02000000 		.word	2
 12218 0be8 82000000 		.word	130
 12219 0bec 82070000 		.word	1922
 12220 0bf0 40040000 		.word	1088
 12221 0bf4 FCFF0000 		.word	65532
 12222 0bf8 28000000 		.word	40
 12223 0bfc 00000000 		.word	0
 12224 0c00 00000000 		.word	0
 12225 0c04 00000000 		.word	0
 12226 0c08 00000000 		.word	0
 12227 0c0c 01000000 		.word	1
 12228 0c10 00000000 		.word	0
 12229 0c14 00000000 		.word	0
 12230 0c18 00000000 		.word	0
 12231 0c1c 00000000 		.word	0
 12232 0c20 00000000 		.word	0
 12233 0c24 00000000 		.word	0
 12234 0c28 00000000 		.word	0
 12235 0c2c 00000000 		.word	0
 12236 0c30 00000000 		.word	0
 12237 0c34 00000000 		.word	0
 12238 0c38 00000000 		.word	0
 12239 0c3c 00000000 		.word	0
 12240 0c40 06000000 		.word	6
 12241 0c44 00000000 		.word	0
 12242 0c48 FFFF0000 		.word	65535
 12243 0c4c 09010000 		.word	265
 12244 0c50 00000000 		.word	0
 12245 0c54 F71F0000 		.word	8183
 12246 0c58 00000000 		.word	0
 12247 0c5c FFFF0000 		.word	65535
 12248 0c60 09010000 		.word	265
 12249 0c64 00000000 		.word	0
 12250 0c68 F71F0000 		.word	8183
 12251 0c6c 00000000 		.word	0
 12252 0c70 00000000 		.word	0
 12253 0c74 00000000 		.word	0
 12254 0c78 00000000 		.word	0
 12255 0c7c 00000000 		.word	0
 12256 0c80 00000000 		.word	0
 12257 0c84 00000000 		.word	0
 12258 0c88 00000000 		.word	0
 12259 0c8c 00000000 		.word	0
 12260 0c90 00000000 		.word	0
 12261 0c94 00000000 		.word	0
 12262 0c98 00000000 		.word	0
 12263 0c9c 00000000 		.word	0
 12264 0ca0 00000000 		.word	0
 12265 0ca4 00000000 		.word	0
 12266 0ca8 00000000 		.word	0
 12267 0cac 00000000 		.word	0
 12268 0cb0 00000000 		.word	0
 12269 0cb4 00000000 		.word	0
 12270 0cb8 00000000 		.word	0
 12271 0cbc 00000000 		.word	0
 12272 0cc0 00000000 		.word	0
 12273 0cc4 00000000 		.word	0
 12274 0cc8 00040180 		.word	-2147417088
 12275 0ccc 01040180 		.word	-2147417087
 12276 0cd0 02040180 		.word	-2147417086
 12277 0cd4 03040180 		.word	-2147417085
 12278 0cd8 00000000 		.word	0
 12279 0cdc 00000000 		.word	0
 12280 0ce0 00000000 		.word	0
 12281 0ce4 00000000 		.word	0
 12282 0ce8 00000000 		.word	0
 12283 0cec 00000000 		.word	0
 12284 0cf0 00000000 		.word	0
 12285 0cf4 00000000 		.word	0
 12286 0cf8 C1FFFFFF 		.word	-63
 12287              		.section	.rodata.str1.4,"aMS",%progbits,1
 12288              		.align	2
 12289              	.LC0:
 12290 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12290      7065722D 
 12290      74696D65 
 12290      72202564 
 12290      0D0A00
 12291 0013 00       		.space	1
 12292              	.LC1:
 12293 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12293      636F6D6D 
 12293      616E6420 
 12293      71756575 
 12293      65206973 
 12294 0037 00       		.space	1
 12295              	.LC2:
 12296 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 12296      706F732D 
 12296      74696D65 
 12296      72202564 
 12296      2025640D 
 12297 004e 0000     		.space	2
 12298              	.LC3:
 12299 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12299      5420656E 
 12299      636F756E 
 12299      74657265 
 12299      642E2E2E 
 12300              	.LC4:
 12301 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12301      454E4420 
 12301      656E636F 
 12301      756E7465 
 12301      7265642E 
 12302 0092 0000     		.space	2
 12303              	.LC5:
 12304 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12304      64697363 
 12304      6F6E6E65 
 12304      63746564 
 12304      2E2E2E30 
 12305 00b3 00       		.space	1
 12306              	.LC6:
 12307 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 12307      7220696E 
 12307      206D756C 
 12307      74696368 
 12307      616E6E65 
 12308 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 12308      2025782C 
 12308      20646D61 
 12308      446F6E65 
 12308      20256420 
 12309              	.LC7:
 12310 0100 626D5265 		.ascii	"bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wInd"
 12310      71547970 
 12310      65203D20 
 12310      30782578 
 12310      20625265 
 12311 0133 6578203D 		.ascii	"ex = 0x%x wLength = 0x%x isflag 0x%x\015\012\000"
 12311      20307825 
 12311      7820774C 
 12311      656E6774 
 12311      68203D20 
 12312 015a 0000     		.space	2
 12313              	.LC8:
 12314 015c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12314      43595F46 
 12314      585F5556 
 12314      435F5649 
 12314      44454F5F 
 12315 018f 0A00     		.ascii	"\012\000"
 12316 0191 000000   		.space	3
 12317              	.LC9:
 12318 0194 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12318      43595F46 
 12318      585F5556 
 12318      435F5649 
 12318      44454F5F 
 12319 01c7 00       		.ascii	"\000"
 12320              	.LC10:
 12321 01c8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12321      726E6174 
 12321      65207365 
 12321      7474696E 
 12321      6720302E 
 12322              	.LC11:
 12323 01e0 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12323      72206665 
 12323      61747572 
 12323      65207265 
 12323      71756573 
 12324 0203 00       		.space	1
 12325              	.LC12:
 12326 0204 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 12326      6F6D6D69 
 12326      74656F66 
 12326      20737461 
 12326      7465203D 
 12327              	.LC13:
 12328 021c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 12328      6E656C20 
 12328      53657420 
 12328      57726170 
 12328      55702066 
 12329 0249 000000   		.space	3
 12330              	.LC14:
 12331 024c 4572726F 		.ascii	"Error handler...\015\012\000"
 12331      72206861 
 12331      6E646C65 
 12331      722E2E2E 
 12331      0D0A00
 12332 025f 00       		.space	1
 12333              	.LC15:
 12334 0260 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 12334      69742045 
 12334      4F462066 
 12334      61696C65 
 12334      64210D0A 
 12335 0275 000000   		.space	3
 12336              	.LC16:
 12337 0278 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12337      49324320 
 12337      636F6D6D 
 12337      616E6420 
 12337      69732030 
 12338 02ab 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12338      78257820 
 12338      30782578 
 12338      20307825 
 12338      78203078 
 12339              	.LC17:
 12340 02c4 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 12340      49324320 
 12340      636F6D6D 
 12340      616E6420 
 12340      73657474 
 12341 02ea 0000     		.space	2
 12342              	.LC18:
 12343 02ec 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 12343      43595F46 
 12343      585F5556 
 12343      435F5354 
 12343      5245414D 
 12344 0312 0000     		.space	2
 12345              	.LC19:
 12346 0314 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 12346      73687574 
 12346      74657220 
 12346      73657420 
 12346      76616C75 
 12347 033e 0000     		.space	2
 12348              	.LC20:
 12349 0340 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 12349      20736875 
 12349      74746572 
 12349      20737065 
 12349      65642E20 
 12350 0365 000000   		.space	3
 12351              	.LC21:
 12352 0368 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 12352      20736875 
 12352      74746572 
 12352      20737065 
 12352      6564322E 
 12353 038e 0000     		.space	2
 12354              	.LC22:
 12355 0390 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12355      206C6967 
 12355      68742063 
 12355      6F6D7065 
 12355      6E736174 
 12356 03c3 25640D0A 		.ascii	"%d\015\012\000"
 12356      00
 12357              	.LC23:
 12358 03c8 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12358      49324320 
 12358      63757272 
 12358      656E7420 
 12358      64617461 
 12359 03fb 64202564 		.ascii	"d %d\015\012\000"
 12359      0D0A00
 12360 0402 0000     		.space	2
 12361              	.LC24:
 12362 0404 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12362      26414743 
 12362      2073656E 
 12362      7420746F 
 12362      20686F73 
 12363 042a 0000     		.space	2
 12364              	.LC25:
 12365 042c 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12365      73687574 
 12365      74657226 
 12365      6578706F 
 12365      73757265 
 12366 0457 00       		.space	1
 12367              	.LC26:
 12368 0458 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 12368      26414743 
 12368      20676F74 
 12368      74656E20 
 12368      66726F6D 
 12369 0489 0A00     		.ascii	"\012\000"
 12370 048b 00       		.space	1
 12371              	.LC27:
 12372 048c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 12372      74657220 
 12372      6C657665 
 12372      6C20676F 
 12372      7474656E 
 12373 04bf 25640D0A 		.ascii	"%d\015\012\000"
 12373      00
 12374              	.LC28:
 12375 04c4 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 12375      75656E63 
 12375      79207365 
 12375      7474696E 
 12375      67206973 
 12376 04e2 0000     		.space	2
 12377              	.LC29:
 12378 04e4 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 12378      20746865 
 12378      20766964 
 12378      656F206D 
 12378      6F646520 
 12379 0506 0000     		.space	2
 12380              	.LC30:
 12381 0508 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12381      67657420 
 12381      64617461 
 12381      2066726F 
 12381      6D20686F 
 12382 0535 000000   		.space	3
 12383              	.LC31:
 12384 0538 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12384      52657175 
 12384      65737420 
 12384      30782578 
 12384      20706172 
 12385 056b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12385      6E642074 
 12385      6F20686F 
 12385      73742030 
 12385      78257820 
 12386 0586 0000     		.space	2
 12387              	.LC32:
 12388 0588 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 12388      204F7020 
 12388      72656365 
 12388      69766573 
 12388      20284354 
 12389 05af 00       		.space	1
 12390              	.LC33:
 12391 05b0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 12391      756C7420 
 12391      73656C65 
 12391      63746F72 
 12391      20284354 
 12392 05d2 0000     		.space	2
 12393              	.LC34:
 12394 05d4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 12394      756C7420 
 12394      72657175 
 12394      65737420 
 12394      28435429 
 12395 05f5 000000   		.space	3
 12396              	.LC35:
 12397 05f8 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 12397      52657175 
 12397      65737420 
 12397      30782578 
 12397      20706172 
 12398 062b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 12398      20307825 
 12398      78202F20 
 12398      73656E64 
 12398      20746F20 
 12399 0658 00       		.ascii	"\000"
 12400 0659 000000   		.space	3
 12401              	.LC36:
 12402 065c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 12402      64656661 
 12402      756C7420 
 12402      73657475 
 12402      70207265 
 12403              	.LC37:
 12404 0688 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 12404      6F207374 
 12404      7265616D 
 12404      20474554 
 12404      20726571 
 12405 06ad 000000   		.space	3
 12406              	.LC38:
 12407 06b0 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 12407      74686520 
 12407      76696465 
 12407      6F206D6F 
 12407      64652066 
 12408 06d1 000000   		.space	3
 12409              	.LC39:
 12410 06d4 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 12410      74686520 
 12410      76696465 
 12410      6F206D6F 
 12410      64652066 
 12411 06f9 000000   		.space	3
 12412              	.LC40:
 12413 06fc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 12413      55564320 
 12413      7374696C 
 12413      6C205072 
 12413      6F622873 
 12414 0727 00       		.space	1
 12415              	.LC41:
 12416 0728 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 12416      74686520 
 12416      7374696C 
 12416      6C206D6F 
 12416      64652066 
 12417 0749 000000   		.space	3
 12418              	.LC42:
 12419 074c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 12419      7374696C 
 12419      6C20636F 
 12419      6D6D6974 
 12419      20636F6E 
 12420              	.LC43:
 12421 0774 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 12421      43595F46 
 12421      585F5556 
 12421      435F5354 
 12421      494C5F45 
 12422              	.LC44:
 12423 0798 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 12423      55564320 
 12423      7374696C 
 12423      6C207472 
 12423      69676765 
 12424 07c1 000000   		.space	3
 12425              	.LC45:
 12426 07c4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 12426      7374696C 
 12426      6C207472 
 12426      69676765 
 12426      7220636F 
 12427 07eb 00       		.space	1
 12428              	.LC46:
 12429 07ec 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 12429      65642074 
 12429      6F207365 
 12429      6E642069 
 12429      6E746572 
 12430 081d 0A00     		.ascii	"\012\000"
 12431 081f 00       		.space	1
 12432              	.LC47:
 12433 0820 4661696C 		.ascii	"Failed to receive debug command, Error code = %d\015"
 12433      65642074 
 12433      6F207265 
 12433      63656976 
 12433      65206465 
 12434 0851 0A00     		.ascii	"\012\000"
 12435 0853 00       		.space	1
 12436              	.LC48:
 12437 0854 44656275 		.ascii	"Debug interface conut %d data %d %d %d\015\012\000"
 12437      6720696E 
 12437      74657266 
 12437      61636520 
 12437      636F6E75 
 12438 087d 000000   		.space	3
 12439              	.LC49:
 12440 0880 44656275 		.ascii	"Debug responsR conut %d data %d %d %d\015\012\000"
 12440      67207265 
 12440      73706F6E 
 12440      73522063 
 12440      6F6E7574 
 12441              	.LC50:
 12442 08a8 44656275 		.ascii	"Debug write %d data %d %d %d\015\012\000"
 12442      67207772 
 12442      69746520 
 12442      25642064 
 12442      61746120 
 12443 08c7 00       		.space	1
 12444              	.LC51:
 12445 08c8 44656275 		.ascii	"Debug respons conut %d data %d %d %d\015\012\000"
 12445      67207265 
 12445      73706F6E 
 12445      7320636F 
 12445      6E757420 
 12446 08ef 00       		.space	1
 12447              	.LC52:
 12448 08f0 4661696C 		.ascii	"Failed to free up command OUT EP buffer, Error code"
 12448      65642074 
 12448      6F206672 
 12448      65652075 
 12448      7020636F 
 12449 0923 203D2025 		.ascii	" = %d\015\012\000"
 12449      640D0A00 
 12450 092b 00       		.space	1
 12451              	.LC53:
 12452 092c 4661696C 		.ascii	"Failed to send debug response, Error code = %d\015\012"
 12452      65642074 
 12452      6F207365 
 12452      6E642064 
 12452      65627567 
 12453 095c 00       		.ascii	"\000"
 12454 095d 000000   		.space	3
 12455              	.LC54:
 12456 0960 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 12456      73657420 
 12456      64656620 
 12456      64617461 
 12456      20307825 
 12457 097f 00       		.space	1
 12458              	.LC55:
 12459 0980 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 12459      73657420 
 12459      64656620 
 12459      64617461 
 12459      20307825 
 12460 09b3 2E0D0A00 		.ascii	".\015\012\000"
 12461 09b7 00       		.space	1
 12462              	.LC56:
 12463 09b8 55415254 		.ascii	"UART initialization failed!\012\000"
 12463      20696E69 
 12463      7469616C 
 12463      697A6174 
 12463      696F6E20 
 12464 09d5 000000   		.space	3
 12465              	.LC57:
 12466 09d8 49324320 		.ascii	"I2C initialization failed!\012\000"
 12466      696E6974 
 12466      69616C69 
 12466      7A617469 
 12466      6F6E2066 
 12467              	.LC58:
 12468 09f4 49324320 		.ascii	"I2C configuration failed!\012\000"
 12468      636F6E66 
 12468      69677572 
 12468      6174696F 
 12468      6E206661 
 12469 0a0f 00       		.space	1
 12470              	.LC59:
 12471 0a10 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 12471      43726561 
 12471      74652045 
 12471      76656E74 
 12471      20666169 
 12472 0a3a 0000     		.space	2
 12473              	.LC60:
 12474 0a3c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 12474      20496E69 
 12474      74206661 
 12474      696C6564 
 12474      2C204572 
 12475 0a5f 00       		.space	1
 12476              	.LC61:
 12477 0a60 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 12477      204F7665 
 12477      72726964 
 12477      65206661 
 12477      696C6564 
 12478 0a87 00       		.space	1
 12479              	.LC62:
 12480 0a88 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 12480      28323029 
 12480      204F7665 
 12480      72726964 
 12480      65206661 
 12481 0ab3 00       		.space	1
 12482              	.LC63:
 12483 0ab4 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 12483      28323429 
 12483      204F7665 
 12483      72726964 
 12483      65206661 
 12484 0adf 00       		.space	1
 12485              	.LC64:
 12486 0ae0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 12486      20536574 
 12486      20287265 
 12486      73657420 
 12486      32322920 
 12487 0b12 00       		.ascii	"\000"
 12488 0b13 00       		.space	1
 12489              	.LC65:
 12490 0b14 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 12490      20536574 
 12490      2028706F 
 12490      77657220 
 12490      32302920 
 12491 0b46 00       		.ascii	"\000"
 12492 0b47 00       		.space	1
 12493              	.LC66:
 12494 0b48 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 12494      20536574 
 12494      2028736E 
 12494      61702073 
 12494      686F7420 
 12495 0b7b 25640A00 		.ascii	"%d\012\000"
 12496 0b7f 00       		.space	1
 12497              	.LC67:
 12498 0b80 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 12498      46756E63 
 12498      74696F6E 
 12498      20466169 
 12498      6C656420 
 12499 0baf 00       		.space	1
 12500              	.LC68:
 12501 0bb0 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 12501      46756E63 
 12501      74696F6E 
 12501      20466169 
 12501      6C656420 
 12502 0bdf 00       		.space	1
 12503              	.LC69:
 12504 0be0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 12504      53657420 
 12504      456E6470 
 12504      6F696E74 
 12504      20636F6E 
 12505 0c10 00       		.ascii	"\000"
 12506 0c11 000000   		.space	3
 12507              	.LC70:
 12508 0c14 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 12508      496E7465 
 12508      72727570 
 12508      74205374 
 12508      61747573 
 12509 0c47 20436F64 		.ascii	" Code = %d\012\000"
 12509      65203D20 
 12509      25640A00 
 12510 0c53 00       		.space	1
 12511              	.LC71:
 12512 0c54 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 12512      65642074 
 12512      6F20616C 
 12512      6C6F6361 
 12512      7465206D 
 12513 0c87 65720D0A 		.ascii	"er\015\012\000"
 12513      00
 12514              	.LC72:
 12515 0c8c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 12515      4368616E 
 12515      6E656C20 
 12515      43726561 
 12515      74696F6E 
 12516 0cba 0000     		.space	2
 12517              	.LC73:
 12518 0cbc 44656275 		.ascii	"Debug Command endpoint config failed, Error code = "
 12518      6720436F 
 12518      6D6D616E 
 12518      6420656E 
 12518      64706F69 
 12519 0cef 25640A00 		.ascii	"%d\012\000"
 12520 0cf3 00       		.space	1
 12521              	.LC74:
 12522 0cf4 44656275 		.ascii	"Debug Response endpoint config failed, Error code ="
 12522      67205265 
 12522      73706F6E 
 12522      73652065 
 12522      6E64706F 
 12523 0d27 2025640A 		.ascii	" %d\012\000"
 12523      00
 12524              	.LC75:
 12525 0d2c 44656275 		.ascii	"Debug Command channel create failed, Error code = %"
 12525      6720436F 
 12525      6D6D616E 
 12525      64206368 
 12525      616E6E65 
 12526 0d5f 640A00   		.ascii	"d\012\000"
 12527 0d62 0000     		.space	2
 12528              	.LC76:
 12529 0d64 44656275 		.ascii	"Debug channel SetXfer failed, Error code = %d\012\000"
 12529      67206368 
 12529      616E6E65 
 12529      6C205365 
 12529      74586665 
 12530 0d93 00       		.space	1
 12531              	.LC77:
 12532 0d94 44656275 		.ascii	"Debug Response channel create failed, Error code = "
 12532      67205265 
 12532      73706F6E 
 12532      73652063 
 12532      68616E6E 
 12533 0dc7 25640A00 		.ascii	"%d\012\000"
 12534 0dcb 00       		.space	1
 12535              	.LC78:
 12536 0dcc 4661696C 		.ascii	"Failed to allocate memory for debug buffer\015\012\000"
 12536      65642074 
 12536      6F20616C 
 12536      6C6F6361 
 12536      7465206D 
 12537 0df9 000000   		.space	3
 12538              	.LC79:
 12539 0dfc 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 12539      436F6E6E 
 12539      65637420 
 12539      6661696C 
 12539      65642C20 
 12540 0e21 000000   		.space	3
 12541              	.LC80:
 12542 0e24 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 12542      74686520 
 12542      76696465 
 12542      6F206D6F 
 12542      64652066 
 12543 0e46 0000     		.space	2
 12544              	.LC81:
 12545 0e48 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 12545      4368616E 
 12545      6E656C20 
 12545      52657365 
 12545      74204661 
 12546 0e73 00       		.space	1
 12547              	.LC82:
 12548 0e74 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 12548      4368616E 
 12548      6E656C20 
 12548      53657420 
 12548      5472616E 
 12549 0ea5 00       		.ascii	"\000"
 12550 0ea6 0000     		.space	2
 12551              	.LC83:
 12552 0ea8 636C6561 		.ascii	"clear feature stream set %x\012\000"
 12552      72206665 
 12552      61747572 
 12552      65207374 
 12552      7265616D 
 12553 0ec5 000000   		.space	3
 12554              	.LC84:
 12555 0ec8 70726520 		.ascii	"pre wait stream set %x\012\000"
 12555      77616974 
 12555      20737472 
 12555      65616D20 
 12555      73657420 
 12556              	.LC85:
 12557 0ee0 706F7374 		.ascii	"post wait stream set %x\012\000"
 12557      20776169 
 12557      74207374 
 12557      7265616D 
 12557      20736574 
 12558 0ef9 000000   		.space	3
 12559              	.LC86:
 12560 0efc 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 12560      4368616E 
 12560      6E656C20 
 12560      53657420 
 12560      5472616E 
 12561 0f2d 0A00     		.ascii	"\012\000"
 12562 0f2f 00       		.space	1
 12563              	.LC87:
 12564 0f30 0D0A2073 		.ascii	"\015\012 super gpif\000"
 12564      75706572 
 12564      20677069 
 12564      6600
 12565 0f3e 0000     		.space	2
 12566              	.LC88:
 12567 0f40 0D0A2068 		.ascii	"\015\012 high gpif\000"
 12567      69676820 
 12567      67706966 
 12567      00
 12568 0f4d 000000   		.space	3
 12569              	.LC89:
 12570 0f50 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 12570      696E6720 
 12570      47504946 
 12570      20436F6E 
 12570      66696775 
 12571 0f83 0A00     		.ascii	"\012\000"
 12572 0f85 000000   		.space	3
 12573              	.LC90:
 12574 0f88 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 12574      74696E67 
 12574      20475049 
 12574      46207374 
 12574      61746520 
 12575 0fbb 0D0A00   		.ascii	"\015\012\000"
 12576 0fbe 0000     		.space	2
 12577              	.LC91:
 12578 0fc0 49324363 		.ascii	"I2CcmdQue\000"
 12578      6D645175 
 12578      6500
 12579 0fca 0000     		.space	2
 12580              	.LC92:
 12581 0fcc 33303A55 		.ascii	"30:UVC App Thread\000"
 12581      56432041 
 12581      70702054 
 12581      68726561 
 12581      6400
 12582 0fde 0000     		.space	2
 12583              	.LC93:
 12584 0fe0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 12584      56432041 
 12584      70702045 
 12584      50302054 
 12584      68726561 
 12585 0ff6 0000     		.space	2
 12586              	.LC94:
 12587 0ff8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 12587      32432041 
 12587      70702043 
 12587      54524C20 
 12587      54687265 
 12588 100f 00       		.bss
 12589              		.align	2
 12590              		.set	.LANCHOR0,. + 0
 12593              	glFxUVCEvent:
 12594 0000 00000000 		.space	40
 12594      00000000 
 12594      00000000 
 12594      00000000 
 12594      00000000 
 12597              	debugData:
 12598 0028 00000000 		.space	128
 12598      00000000 
 12598      00000000 
 12598      00000000 
 12598      00000000 
 12601              	gpif_initialized:
 12602 00a8 00000000 		.space	4
 12605              	streamingStarted:
 12606 00ac 00000000 		.space	4
 12609              	isUsbConnected:
 12610 00b0 00000000 		.space	4
 12613              	fb:
 12614 00b4 0000     		.space	2
 12617              	pb:
 12618 00b6 0000     		.space	2
 12621              	pbc:
 12622 00b8 0000     		.space	2
 12625              	stiflag:
 12626 00ba 00       		.space	1
 12627 00bb 00       		.space	1
 12630              	hitFV:
 12631 00bc 00000000 		.space	4
 12634              	prodCount:
 12635 00c0 0000     		.space	2
 12638              	consCount:
 12639 00c2 0000     		.space	2
 12642              	clearFeatureRqtReceived:
 12643 00c4 00000000 		.space	4
 12646              	usbSpeed:
 12647 00c8 00       		.space	1
 12648 00c9 000000   		.space	3
 12651              	I2CCMDArry:
 12652 00cc 00000000 		.space	12
 12652      00000000 
 12652      00000000 
 12655              	is60Hz:
 12656 00d8 00000000 		.space	4
 12659              	value:
 12660 00dc 00000000 		.space	64
 12660      00000000 
 12660      00000000 
 12660      00000000 
 12660      00000000 
 12663              	glEp0Buffer:
 12664 011c 00000000 		.space	32
 12664      00000000 
 12664      00000000 
 12664      00000000 
 12664      00000000 
 12667              	curFlag:
 12668 013c 00000000 		.space	64
 12668      00000000 
 12668      00000000 
 12668      00000000 
 12668      00000000 
 12671              	CamMode:
 12672 017c 00       		.space	1
 12675              	setRes:
 12676 017d 00       		.space	1
 12677 017e 0000     		.space	2
 12680              	glCommitCtrl:
 12681 0180 00000000 		.space	32
 12681      00000000 
 12681      00000000 
 12681      00000000 
 12681      00000000 
 12684              	setstilRes:
 12685 01a0 00       		.space	1
 12688              	IMcount.7874:
 12689 01a1 00       		.space	1
 12690 01a2 0000     		.space	2
 12693              	uvcAppThread:
 12694 01a4 00000000 		.space	168
 12694      00000000 
 12694      00000000 
 12694      00000000 
 12694      00000000 
 12697              	uvcAppEP0Thread:
 12698 024c 00000000 		.space	168
 12698      00000000 
 12698      00000000 
 12698      00000000 
 12698      00000000 
 12701              	i2cAppThread:
 12702 02f4 00000000 		.space	168
 12702      00000000 
 12702      00000000 
 12702      00000000 
 12702      00000000 
 12705              	testSnap:
 12706 039c 00       		.space	1
 12707 039d 00       		.space	1
 12710              	fbbak:
 12711 039e 0000     		.space	2
 12714              	pbbak:
 12715 03a0 0000     		.space	2
 12718              	pbcbak:
 12719 03a2 0000     		.space	2
 12722              	pbcpbak:
 12723 03a4 0000     		.space	2
 12724 03a6 0000     		.space	2
 12727              	streamingRecove:
 12728 03a8 00000000 		.space	4
 12729              		.text
 12730              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:199    .text:00000168 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:206    .text:00000178 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:307    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:351    .text:00000278 I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:318    .text:0000025c $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:320    .text:0000025c CyFxUvcAppDebugCallback
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:344    .text:00000274 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:348    .text:00000278 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:385    .text:000002a8 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:391    .text:000002b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:393    .text:000002b4 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:595    .text:00000438 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:604    .text:00000448 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:607    .text:00000448 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:829    .text:000005e8 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:839    .text:00000604 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:841    .text:00000604 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1231   .text:0000097c $d
                            *COM*:00000001 bRequest
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wLength
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1249   .text:000009b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1252   .text:000009b0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1289   .text:000009e8 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1302   .text:00000a14 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1349   .text:00000a68 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1356   .text:00000a78 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1374   .text:00000a94 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1383   .text:00000aac $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1386   .text:00000aac I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1731   .text:00000dfc $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1740   .text:00000e14 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1743   .text:00000e14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1806   .text:00000e94 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1829   .text:00000eac $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1842   .text:00000ed4 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1948   .text:00000fc8 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1956   .text:00000fdc $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:1959   .text:00000fdc ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:2171   .text:00001178 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:2213   .text:00001214 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:2279   .text:00001294 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:2320   .text:00001330 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:3679   .text:00001f10 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:3702   .text:00001f60 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:4107   .text:00002318 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:4113   .text:00002328 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:4716   .text:00002848 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:4884   .text:000029a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:4897   .text:000029cc $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5392   .text:00002edc $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5403   .text:00002efc $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5665   .text:000031b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5678   .text:000031e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5681   .text:000031e0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5733   .text:00003248 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:5741   .text:00003258 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:6457   .text:00003918 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:6467   .text:00003928 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:6654   .text:00003ae4 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:6661   .text:00003af4 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7322   .text:00004158 $d
                            *COM*:00000004 glDebugRspBuffer
                            *COM*:000000a0 glDebugCmdChannel
                            *COM*:000000a0 glDebugRspChannel
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7364   .text:000041f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7515   .text:00004318 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7808   .text:000045d4 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7815   .text:000045e4 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7818   .text:000045e4 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7859   .text:00004628 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7864   .text:00004630 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7867   .text:00004630 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7892   .text:0000464c $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7896   .text:00004650 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:7899   .text:00004650 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9598   .text:000053c0 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9604   .text:000053d0 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9720   .text:00005538 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9794   .text:00005654 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9797   .text:00005654 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9943   .text:000057ac $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9959   .text:000057e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:9962   .text:000057e0 main
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11755  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11764  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11839  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11858  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10125  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11937  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11948  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12059  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12210  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10138  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11751  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12705  .bss:0000039c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12613  .bss:000000b4 fb
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12617  .bss:000000b6 pb
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12621  .bss:000000b8 pbc
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12710  .bss:0000039e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12714  .bss:000003a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12718  .bss:000003a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12722  .bss:000003a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12609  .bss:000000b0 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12646  .bss:000000c8 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12642  .bss:000000c4 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12727  .bss:000003a8 streamingRecove
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12605  .bss:000000ac streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11692  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11632  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11722  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11662  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11737  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11120  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 staQuMux
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10106  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10110  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10150  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10154  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:10477  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11135  .data:0000048c dbgIdx
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11139  .data:0000048d ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11143  .data:0000048e valIdx
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11148  .data:00000490 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11170  .data:000004a4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11192  .data:000004b8 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11214  .data:000004cc EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11236  .data:000004e0 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11258  .data:000004f4 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11265  .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11287  .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:11309  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12288  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12589  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12593  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12597  .bss:00000028 debugData
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12601  .bss:000000a8 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12625  .bss:000000ba stiflag
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12630  .bss:000000bc hitFV
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12634  .bss:000000c0 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12638  .bss:000000c2 consCount
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12651  .bss:000000cc I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12655  .bss:000000d8 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12659  .bss:000000dc value
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12663  .bss:0000011c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12667  .bss:0000013c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12671  .bss:0000017c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12675  .bss:0000017d setRes
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12680  .bss:00000180 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12684  .bss:000001a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12688  .bss:000001a1 IMcount.7874
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12693  .bss:000001a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12697  .bss:0000024c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccrCtggM.s:12701  .bss:000002f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbAckSetup
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
SensorWrite2B2
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PDmaChannelGetBuffer
CyU3PDmaChannelDiscardBuffer
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PGpioSimpleGetValue
SensorRead
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PUsbSetEpPktMode
CyU3PDmaChannelSetXfer
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
