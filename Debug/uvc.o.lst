   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 807:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 808:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 809:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 810:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 811:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 812:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 813:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 815:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 816:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 817:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 818:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 819:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 820:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 821:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 822:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 823:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 824:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 825:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 826:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 827:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 829:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //
 848:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 849:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 850:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 851:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 852:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 853:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 854:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 855:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 856:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 857:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 858:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 859:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 860:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 861:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 862:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 863:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 864:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 865:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 866:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 867:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 868:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 869:../uvc.c      **** 		}; //
 870:../uvc.c      **** 
 871:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 872:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 873:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 891:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 892:../uvc.c      **** 
 893:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 894:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 895:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 896:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 897:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 898:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 899:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 900:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 901:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 902:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 903:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 904:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 905:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 906:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 907:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 908:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 909:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 910:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 911:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 912:../uvc.c      **** 		}; //
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 915:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 936:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 957:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 978:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
 999:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1000:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1020:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1041:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1062:../uvc.c      **** 		&EXTShutter,
1063:../uvc.c      **** 		&EXTSensUp,
1064:../uvc.c      **** 		&EXTMirror,
1065:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1066:../uvc.c      **** 		&EXT3DNoiseLev,
1067:../uvc.c      **** 		&EXTDayNightMode,
1068:../uvc.c      **** 		&EXTDayNightdely,
1069:../uvc.c      **** 		&EXTDayNightlev,
1070:../uvc.c      **** 		&EXTNightDaylev,
1071:../uvc.c      **** 		&EXTAexModGainlev,
1072:../uvc.c      **** 		&EXTExpReflev,
1073:../uvc.c      **** 		&EXTShutlev,
1074:../uvc.c      **** 		&EXTCamMode,
1075:../uvc.c      **** 		0, //&EXTSnapshot,
1076:../uvc.c      **** 		&EXTSensorPare,
1077:../uvc.c      **** 		0, //&EXTI2Ccmd,
1078:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1079:../uvc.c      **** 		0, //&Ext1CtlID1,
1080:../uvc.c      **** 		0, //&Ext1CtlID2,
1081:../uvc.c      **** 		0, //&Ext1CtlID3,
1082:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1083:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1084:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1085:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1086:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1087:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1088:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1089:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1090:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1091:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1092:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1093:../uvc.c      **** 		0, //&Ext1CtlID15,
1094:../uvc.c      **** 		0
1095:../uvc.c      **** };
1096:../uvc.c      **** 
1097:../uvc.c      **** #endif //end of the new control structure
1098:../uvc.c      **** 
1099:../uvc.c      **** #ifndef CAM720
1100:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1101:../uvc.c      **** #else
1102:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1103:../uvc.c      **** #endif
1104:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1105:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1106:../uvc.c      **** 
1107:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1108:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1109:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1110:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1111:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1112:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1113:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1114:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1115:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1116:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1117:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1118:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1119:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1120:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1121:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1122:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1123:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1124:../uvc.c      **** };
1125:../uvc.c      **** 
1126:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1127:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1128:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1129:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1130:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1131:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1132:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1133:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1134:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1135:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1136:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1137:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1138:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1139:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1140:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1141:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1142:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1143:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1144:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1145:../uvc.c      **** };
1146:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1147:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1148:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1149:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1150:../uvc.c      **** /*
1151:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1152:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1153:../uvc.c      ****  */
1154:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1155:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1156:../uvc.c      **** };
1157:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1158:../uvc.c      **** 		0
1159:../uvc.c      **** };
1160:../uvc.c      **** 
1161:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1162:../uvc.c      **** 
1163:../uvc.c      **** void I2CCmdHandler(){
1164:../uvc.c      **** 	uint8_t buf[2];
1165:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1166:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1167:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1168:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1169:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1170:../uvc.c      **** 	uint8_t i;
1171:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1172:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1173:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1174:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1175:../uvc.c      **** 	{
1176:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1177:../uvc.c      **** 		if(is60Hz==CyFalse)
1178:../uvc.c      **** 			{
1179:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1180:../uvc.c      **** 			}
1181:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1182:../uvc.c      **** 
1183:../uvc.c      **** 	}
1184:../uvc.c      **** 	if(CmdType == 0)//I2C read
1185:../uvc.c      **** 	{
1186:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1187:../uvc.c      **** #if 0 //for debugging
1188:../uvc.c      **** 		/* test still image operation */
1189:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1190:../uvc.c      **** 			snapButFlag = 0; //press
1191:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1192:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1193:../uvc.c      **** 			snapButFlag = 0xf; //release
1194:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1195:../uvc.c      **** 		}
1196:../uvc.c      **** 
1197:../uvc.c      **** 		/* end of the test */
1198:../uvc.c      **** #endif
1199:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1200:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1201:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1202:../uvc.c      **** 				if(CmdDataLen == 2){
1203:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1204:../uvc.c      **** 				}
1205:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1206:../uvc.c      **** 		}else{//not support currently
1207:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1208:../uvc.c      **** 		}
1209:../uvc.c      **** 	}else if(CmdType == 1){
1210:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1211:../uvc.c      **** 			if(CmdRegLen == 2){
1212:../uvc.c      **** 				for(i = 0; i<4; i++)
1213:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1214:../uvc.c      **** 			}
1215:../uvc.c      **** 			else{
1216:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1217:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1218:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1219:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1220:../uvc.c      **** 				}
1221:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 		}else{//not support currently
1224:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1225:../uvc.c      **** 		}
1226:../uvc.c      **** 
1227:../uvc.c      **** 	}
1228:../uvc.c      **** }
1229:../uvc.c      **** 
1230:../uvc.c      **** /************************************
1231:../uvc.c      ****  * set Iris mode
1232:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1233:../uvc.c      ****  */
1234:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1235:../uvc.c      **** 	uint8_t dataIdx = 0;
1236:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1238:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1239:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1240:../uvc.c      **** }
1241:../uvc.c      **** 
1242:../uvc.c      **** 
1243:../uvc.c      **** 
1244:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1245:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1246:../uvc.c      **** 	uint16_t NumLn;
1247:../uvc.c      **** 	uint16_t fRate, shutTm;
1248:../uvc.c      **** 	uint8_t LnVal;
1249:../uvc.c      **** 	switch (Data){
1250:../uvc.c      **** 	case 1:
1251:../uvc.c      **** 	case 2:
1252:../uvc.c      **** 	case 3:
1253:../uvc.c      **** 	case 4:
1254:../uvc.c      **** 	case 5:
1255:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1256:../uvc.c      **** 		fRate = 30;
1257:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1258:../uvc.c      **** 		if(NumLn > 1944)
1259:../uvc.c      **** 			NumLn =1944;
1260:../uvc.c      **** 		else if(NumLn < 8)
1261:../uvc.c      **** 			NumLn = 8;
1262:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1263:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1264:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1265:../uvc.c      **** 		break;
1266:../uvc.c      **** 	case 6:
1267:../uvc.c      **** 	case 7:
1268:../uvc.c      **** 	case 8:
1269:../uvc.c      **** 	case 9:
1270:../uvc.c      **** 	case 10:
1271:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1272:../uvc.c      **** 		fRate = 30;
1273:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1274:../uvc.c      **** 		if(NumLn > 1944)
1275:../uvc.c      **** 			NumLn =1944;
1276:../uvc.c      **** 		else if(NumLn < 8)
1277:../uvc.c      **** 			NumLn = 8;
1278:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1279:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1280:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1281:../uvc.c      **** 		break;
1282:../uvc.c      **** 	case 0: //auto
1283:../uvc.c      **** 	default:
1284:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1285:../uvc.c      **** 		LnVal = 1;
1286:../uvc.c      **** 		break;
1287:../uvc.c      **** 	}
1288:../uvc.c      **** 	return LnVal;
1289:../uvc.c      **** }
1290:../uvc.c      **** 
1291:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1292:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1293:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1294:../uvc.c      ****     uint16_t readCount;
1295:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1296:../uvc.c      ****     uint8_t devAdd;
1297:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1298:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1299:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1300:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1301:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1302:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1303:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1304:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1305:../uvc.c      ****     }else{
1306:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1307:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1308:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1309:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1310:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1311:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1312:../uvc.c      ****     }
1313:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1314:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1315:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1316:../uvc.c      **** #endif
1317:../uvc.c      ****     reqData = bRequest;
1318:../uvc.c      ****     /*
1319:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1320:../uvc.c      ****      */
1321:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1322:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1323:../uvc.c      ****     	//goto EndofSet;
1324:../uvc.c      ****     //}
1325:../uvc.c      ****     switch (bRequest)
1326:../uvc.c      **** 		 {
1327:../uvc.c      **** 
1328:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1329:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1330:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1331:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1332:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1333:../uvc.c      **** 			  break;
1334:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1335:../uvc.c      **** 
1336:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1337:../uvc.c      **** 				 switch(CtrlID)
1338:../uvc.c      **** 				 {
1339:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1340:../uvc.c      **** 						 if(curFlag[CtrlID]){
1341:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1342:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1343:../uvc.c      **** 						 }else{
1344:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1345:../uvc.c      **** 							if(Data0&0x80)
1346:../uvc.c      **** 								glEp0Buffer[0] = 1;
1347:../uvc.c      **** 							else
1348:../uvc.c      **** 								glEp0Buffer[0] = 0;
1349:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1350:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1351:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1352:../uvc.c      **** 						 }
1353:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1354:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1355:../uvc.c      **** 						 break;
1356:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1357:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1358:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1359:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1360:../uvc.c      **** 			 	 		 }else{
1361:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1362:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
1363:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1364:../uvc.c      **** 
1365:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1366:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1367:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1368:../uvc.c      **** 			 	 		 }
1369:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1370:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1371:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1372:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1373:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1
1374:../uvc.c      **** 						 break;
1375:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1376:../uvc.c      **** #if 0 //not be used
1377:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1378:../uvc.c      **** 
1379:../uvc.c      **** 						 if(CamMode == 1){//720p
1380:../uvc.c      **** 							if(sendData >= 3){
1381:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1382:../uvc.c      **** 								sendData = 0; //set back to default
1383:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1384:../uvc.c      **** 							}
1385:../uvc.c      **** 							sendData += 4;
1386:../uvc.c      **** 						 }
1387:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1388:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1389:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1390:../uvc.c      **** #endif
1391:../uvc.c      **** 						 break;
1392:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1393:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1394:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1395:../uvc.c      **** 				 		 }
1396:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1397:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1398:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1399:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1400:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1401:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1402:../uvc.c      **** 	#endif
1403:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1404:../uvc.c      **** 				 		 {
1405:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1406:../uvc.c      **** 				 		 }
1407:../uvc.c      **** 				 		 break;
1408:../uvc.c      **** 				 		 case Ext1BLCRangeCtlID4:
1409:../uvc.c      **** /*			 	 		 if(curFlag[CtrlID]){
1410:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1411:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1412:../uvc.c      **** 			 	 		 }else{
1413:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1414:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1415:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1416:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1417:../uvc.c      **** 			 	 		 }
1418:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1419:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1420:../uvc.c      **** 						 break;
1421:../uvc.c      **** 						 */
1422:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1423:../uvc.c      **** 			 	 		 /*
1424:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
1425:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
1426:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1427:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1428:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1429:../uvc.c      **** 			 	 		 }else{
1430:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1431:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
1432:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1433:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1434:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1435:../uvc.c      **** 			 	 		 }
1436:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1437:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1438:../uvc.c      **** 			 	 		 break;
1439:../uvc.c      **** 			 	 		 */
1440:../uvc.c      **** 				 	 case ExtShutCtlID0:
1441:../uvc.c      **** 				 		 /*
1442:../uvc.c      **** 					     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1443:../uvc.c      **** 					     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1444:../uvc.c      **** 					     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1445:../uvc.c      **** 
1446:../uvc.c      **** 						 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1447:../uvc.c      **** 								 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1448:../uvc.c      **** 						 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1449:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1450:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1451:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1452:../uvc.c      **** 			 	 		 }else{
1453:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1454:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1455:../uvc.c      **** 			 	 			Data1 = (Data0&0x70)>>4;
1456:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data1;
1457:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1458:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1459:../uvc.c      **** 							CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
1460:../uvc.c      **** 
1461:../uvc.c      **** 			 	 		 }
1462:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1463:../uvc.c      **** 						 sendData1 = Data1;//glEp0Buffer[1];
1464:../uvc.c      **** 						 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, sen
1465:../uvc.c      **** 				 		 break;
1466:../uvc.c      **** 				 		 */
1467:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1468:../uvc.c      **** 				 		 /*
1469:../uvc.c      **** 					     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1470:../uvc.c      **** 					     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1471:../uvc.c      **** 					     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1472:../uvc.c      **** 
1473:../uvc.c      **** 						 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1474:../uvc.c      **** 								 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1475:../uvc.c      **** 						 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1476:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1477:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1478:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1479:../uvc.c      **** 			 	 		 }else{
1480:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1481:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1482:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1483:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1484:../uvc.c      **** 			 	 		 }
1485:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1486:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1487:../uvc.c      **** 				 		 break;
1488:../uvc.c      **** 				 		 */
1489:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1490:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1491:../uvc.c      **** 			 	 		 /*
1492:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1493:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1494:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1495:../uvc.c      **** 			 	 		 }else{
1496:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1497:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1498:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1499:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1500:../uvc.c      **** 			 	 		 }
1501:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1502:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1503:../uvc.c      **** 						 break;
1504:../uvc.c      **** 						 */
1505:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1506:../uvc.c      **** 			 	 		 /*
1507:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1508:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1509:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1510:../uvc.c      **** 			 	 		 }else{
1511:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1512:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1513:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1514:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1515:../uvc.c      **** 			 	 		 }
1516:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1517:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1518:../uvc.c      **** 						 break;
1519:../uvc.c      **** 						 */
1520:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1521:../uvc.c      **** 			 	 		 /*
1522:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1523:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1524:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1525:../uvc.c      **** 			 	 		 }else{
1526:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1527:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1528:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1529:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1530:../uvc.c      **** 			 	 		 }
1531:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1532:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1533:../uvc.c      **** 						 break;
1534:../uvc.c      **** 						 */
1535:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1536:../uvc.c      **** 			 	 		 /*
1537:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1538:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1539:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1540:../uvc.c      **** 			 	 		 }else{
1541:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1542:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1543:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1544:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1545:../uvc.c      **** 			 	 		 }
1546:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1547:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1548:../uvc.c      **** 						 break;
1549:../uvc.c      **** 						 */
1550:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1551:../uvc.c      **** 			 	 		 /*
1552:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1553:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1554:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1555:../uvc.c      **** 			 	 		 }else{
1556:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1557:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1558:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1559:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1560:../uvc.c      **** 			 	 		 }
1561:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1562:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1563:../uvc.c      **** 						 break;
1564:../uvc.c      **** 						 */
1565:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1566:../uvc.c      **** 			 	 		 /*
1567:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1568:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1569:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1570:../uvc.c      **** 			 	 		 }else{
1571:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1572:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1573:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1574:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1575:../uvc.c      **** 			 	 		 }
1576:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1577:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1578:../uvc.c      **** 						 break;
1579:../uvc.c      **** 						 */
1580:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1581:../uvc.c      **** 			 	 		 /*
1582:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1583:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1584:../uvc.c      **** 							 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1585:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;//ext_control array;
1586:../uvc.c      **** 							 glEp0Buffer[3] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1587:../uvc.c      **** 			 	 		 }else{
1588:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1589:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1590:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1591:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1592:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1593:../uvc.c      **** 			 	 		 }
1594:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1595:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1596:../uvc.c      **** 						 break;
1597:../uvc.c      **** 						 */
1598:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1599:../uvc.c      **** 			 	 		 /*
1600:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1601:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1602:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1603:../uvc.c      **** 			 	 		 }else{
1604:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1605:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1606:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1607:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1608:../uvc.c      **** 			 	 		 }
1609:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1610:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1611:../uvc.c      **** 						 break;
1612:../uvc.c      **** 			 	 		  */
1613:../uvc.c      **** 					 case ExtExRefCtlID10:
1614:../uvc.c      **** 			 	 	 default:
1615:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1616:../uvc.c      **** 			 	 			 if(Len == 2)
1617:../uvc.c      **** 			 	 			 {
1618:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1619:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1620:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1621:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1622:../uvc.c      **** 			 	 			 }else if(Len == 4){
1623:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1624:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1625:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1626:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1627:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1628:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1629:../uvc.c      **** 			 	 			 }
1630:../uvc.c      **** 			 	 		 }else{
1631:../uvc.c      **** 			 	 			 if(Len == 2)
1632:../uvc.c      **** 			 	 			 {
1633:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1634:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1635:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1636:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1637:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1638:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1639:../uvc.c      **** 			 	 			 }else if(Len == 4){
1640:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1641:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1642:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1643:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1645:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1646:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1647:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1648:../uvc.c      **** 			 	 			 }
1649:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1650:../uvc.c      **** 			 	 		 }
1651:../uvc.c      **** 			 	 		 break;
1652:../uvc.c      **** 			 	 }
1653:../uvc.c      **** 		 	 }
1654:../uvc.c      **** 		 	 else{
1655:../uvc.c      **** 				 switch(CtrlID)
1656:../uvc.c      **** 				 {
1657:../uvc.c      **** 					 case BrgtCtlID1:
1658:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1659:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1660:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1661:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1662:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1663:../uvc.c      **** 						 }else{
1664:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1665:../uvc.c      **** 						 }
1666:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1667:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1668:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1669:../uvc.c      **** 						 */
1670:../uvc.c      **** 						 if(curFlag[CtrlID]){
1671:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1672:../uvc.c      **** 						 }else{
1673:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1674:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1675:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1676:../uvc.c      **** 						 }
1677:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1678:../uvc.c      **** 						  if(Data0&0x80){
1679:../uvc.c      **** 							  Data0 = ~Data0;
1680:../uvc.c      **** 						  }else{
1681:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1682:../uvc.c      **** 						  }
1683:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1684:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1685:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1686:../uvc.c      **** 						 break;
1687:../uvc.c      **** 					 case HueCtlID5:
1688:../uvc.c      **** 						 if(curFlag[CtrlID]){
1689:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1690:../uvc.c      **** 						 }else{
1691:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1692:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1693:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1694:../uvc.c      **** 						 }
1695:../uvc.c      **** 
1696:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1697:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1698:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1699:../uvc.c      **** 						 break;
1700:../uvc.c      **** 					 case MFreqCtlID4:
1701:../uvc.c      **** 
1702:../uvc.c      **** 						 if(curFlag[CtrlID]){
1703:../uvc.c      **** 
1704:../uvc.c      **** 							 if(is60Hz)
1705:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1706:../uvc.c      **** 							 else
1707:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1708:../uvc.c      **** 
1709:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1710:../uvc.c      **** 						 }else{
1711:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1712:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1713:../uvc.c      **** 							glEp0Buffer[0]++;
1714:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1715:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1716:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1717:../uvc.c      **** 						 }
1718:../uvc.c      **** 
1719:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1720:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1721:../uvc.c      **** 						 break;
1722:../uvc.c      **** 					 case WBTLevCtlID11:
1723:../uvc.c      **** 						 if(curFlag[CtrlID]){
1724:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1725:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1726:../uvc.c      **** 						 }else{
1727:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1728:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1729:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1730:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1731:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1732:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1733:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1734:../uvc.c      **** 						 }
1735:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1736:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1737:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1738:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1739:../uvc.c      **** 						 break;
1740:../uvc.c      **** 					 case BLCCtlID0:
1741:../uvc.c      **** 						 /*
1742:../uvc.c      **** 						 if(curFlag[CtrlID]){
1743:../uvc.c      **** 							 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1744:../uvc.c      **** 							 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1745:../uvc.c      **** 						 }else{
1746:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1747:../uvc.c      **** 							glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1748:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1749:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1750:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1751:../uvc.c      **** 						 }
1752:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1753:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1754:../uvc.c      **** 						 break;
1755:../uvc.c      **** 						 */
1756:../uvc.c      **** 					 case ShapCtlID7:
1757:../uvc.c      **** 						 /*
1758:../uvc.c      **** 						 if(curFlag[CtrlID]){
1759:../uvc.c      **** 							 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1760:../uvc.c      **** 							 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1761:../uvc.c      **** 						 }else{
1762:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1763:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1764:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1765:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1766:../uvc.c      **** 						 }
1767:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1768:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1769:../uvc.c      **** 						 break;
1770:../uvc.c      **** 						 */
1771:../uvc.c      **** 					 case ConsCtlID2:
1772:../uvc.c      **** 						 /*
1773:../uvc.c      **** 						 if(curFlag[CtrlID]){
1774:../uvc.c      **** 							 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1775:../uvc.c      **** 							 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1776:../uvc.c      **** 						 }else{
1777:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1778:../uvc.c      **** 							CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1779:../uvc.c      **** 							glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1780:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1781:../uvc.c      **** 						 }
1782:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1783:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1784:../uvc.c      **** 						 break;
1785:../uvc.c      **** 						 */
1786:../uvc.c      **** 					 case WBTMdCtlID9:
1787:../uvc.c      **** 						 /*
1788:../uvc.c      **** 						 if(curFlag[CtrlID]){
1789:../uvc.c      **** 							 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1790:../uvc.c      **** 							 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1791:../uvc.c      **** 							 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1792:../uvc.c      **** 						 }else{
1793:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1794:../uvc.c      **** 							CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1795:../uvc.c      **** 							glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1796:../uvc.c      **** 							glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1797:../uvc.c      **** 
1798:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1799:../uvc.c      **** 						 }
1800:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1801:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1802:../uvc.c      **** 						 break;
1803:../uvc.c      **** 						 */
1804:../uvc.c      **** 					 case SaturCtlID6:
1805:../uvc.c      **** 					 default:
1806:../uvc.c      **** 						 if(curFlag[CtrlID]){
1807:../uvc.c      **** 			 	 			 if(Len == 2)
1808:../uvc.c      **** 			 	 			 {
1809:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1810:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1811:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1812:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1813:../uvc.c      **** 			 	 			 }else if(Len == 4){
1814:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1815:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1816:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1817:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1818:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1819:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1820:../uvc.c      **** 			 	 			 }
1821:../uvc.c      **** 			 	 		 }else{
1822:../uvc.c      **** 			 	 			 if(Len == 2)
1823:../uvc.c      **** 			 	 			 {
1824:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1825:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1826:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1827:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1828:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1829:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1830:../uvc.c      **** 			 	 			 }else if(Len == 4){
1831:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1832:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1833:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1834:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1836:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1837:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1838:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1839:../uvc.c      **** 			 	 			 }
1840:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1841:../uvc.c      **** 			 	 		 }
1842:../uvc.c      **** 						 break;
1843:../uvc.c      **** 				 }
1844:../uvc.c      **** 		 	 }
1845:../uvc.c      **** 
1846:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1847:../uvc.c      **** 
1848:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1849:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1850:../uvc.c      **** //#endif
1851:../uvc.c      **** 			  break;
1852:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1853:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1854:../uvc.c      **** 		 		 if(Len == 2){
1855:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1856:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1857:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1858:../uvc.c      **** 		 		 }else //if(Len == 4)
1859:../uvc.c      **** 		 		 {
1860:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1861:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1862:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1863:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1864:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1865:../uvc.c      **** 				 }
1866:../uvc.c      **** 			 }else{
1867:../uvc.c      **** 			 	 if(Len ==2){
1868:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1869:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1870:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1871:../uvc.c      **** 				 }else{
1872:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1873:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1874:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1875:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1876:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1877:../uvc.c      **** 				 }
1878:../uvc.c      **** 			 }
1879:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1880:../uvc.c      **** 		 	 if(Len == 2){
1881:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1882:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1883:../uvc.c      **** 		 	 }else{
1884:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1885:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1886:../uvc.c      **** 			  }
1887:../uvc.c      **** 			  break;
1888:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1889:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1890:../uvc.c      **** 		 		 if(Len == 2){
1891:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1892:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1893:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1894:../uvc.c      **** 		 		 }else //if(Len == 4)
1895:../uvc.c      **** 		 		 {
1896:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1897:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1898:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1899:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1900:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1901:../uvc.c      **** 				 }
1902:../uvc.c      **** 			 }else{
1903:../uvc.c      **** 			 	 if(Len ==2){
1904:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1905:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1906:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1907:../uvc.c      **** 				 }else{
1908:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1909:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1910:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1911:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1912:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1913:../uvc.c      **** 				 }
1914:../uvc.c      **** 			 }
1915:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1916:../uvc.c      **** 				  if(Len == 2){
1917:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1918:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1919:../uvc.c      **** 				  }else{
1920:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1921:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1922:../uvc.c      **** 				  }
1923:../uvc.c      **** 				  break;
1924:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1925:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1926:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1927:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1928:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1929:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1930:../uvc.c      **** 		 	 }
1931:../uvc.c      **** 		 	 else{
1932:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1933:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1934:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1935:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1936:../uvc.c      **** 		 	 }
1937:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1938:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1939:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1940:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1941:../uvc.c      **** 			  break;
1942:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1943:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1944:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1945:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1946:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1947:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1948:../uvc.c      **** 		 	 }
1949:../uvc.c      **** 		 	 else{
1950:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1951:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1952:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1953:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1954:../uvc.c      **** 		 	 }
1955:../uvc.c      **** 		 	 Len = 1;
1956:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1957:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1958:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1959:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1960:../uvc.c      **** 		 	 break;
1961:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1962:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1963:../uvc.c      **** 		 		 if(Len == 2){
1964:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1965:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1966:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1967:../uvc.c      **** 		 		 }else //if(Len == 4)
1968:../uvc.c      **** 		 		 {
1969:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1970:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1971:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1973:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1974:../uvc.c      **** 				 }
1975:../uvc.c      **** 			 }else{
1976:../uvc.c      **** 			 	 if(Len ==2){
1977:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1978:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1979:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1980:../uvc.c      **** 				 }else{
1981:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1982:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1983:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1984:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1985:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1986:../uvc.c      **** 				 }
1987:../uvc.c      **** 			 }
1988:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1989:../uvc.c      **** 		 	 if(Len == 2){
1990:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1991:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1992:../uvc.c      **** 		 	 }else{
1993:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1994:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1995:../uvc.c      **** 		 	 }
1996:../uvc.c      **** 		 	 break;
1997:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1998:../uvc.c      **** 
1999:../uvc.c      ****  // set request control will be removed.
2000:../uvc.c      **** /*********************************************************/
2001:../uvc.c      **** #if 0 //old implementation
2002:../uvc.c      **** 
2003:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2004:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2005:../uvc.c      **** 			  getData = glEp0Buffer[0];
2006:../uvc.c      **** 			  getData1 = glEp0Buffer[2];
2007:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2008:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, glE
2009:../uvc.c      **** #endif
2010:../uvc.c      **** 			  switch(CtrlID)
2011:../uvc.c      **** 				 {
2012:../uvc.c      **** 					 case ExtShutCtlID0:
2013:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2014:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
2015:../uvc.c      **** 						 //devAdd = EXTShutter.DeviceAdd;
2016:../uvc.c      **** 						 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
2017:../uvc.c      **** #if 1	// register setting directly
2018:../uvc.c      **** 					     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vie
2019:../uvc.c      **** 					     {
2020:../uvc.c      **** 					    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
2021:../uvc.c      **** 					    	 dataIdx = 0;
2022:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2023:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
2024:../uvc.c      **** 							 dataIdx++;
2025:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2026:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2027:../uvc.c      **** 					     }
2028:../uvc.c      **** 					     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
2029:../uvc.c      **** 					    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
2030:../uvc.c      **** 					     break;
2031:../uvc.c      **** #else	// old fashion
2032:../uvc.c      **** 						 if(Data0 == 0){//set exposure mode auto
2033:../uvc.c      **** 							 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
2034:../uvc.c      **** 								 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
2035:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
2036:../uvc.c      **** 								 }else{
2037:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
2038:../uvc.c      **** 								 }
2039:../uvc.c      **** 							 }
2040:../uvc.c      **** 						 }else{
2041:../uvc.c      **** 							 Data1 = Data0 - 1;
2042:../uvc.c      **** 							 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
2043:../uvc.c      **** 								 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
2044:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
2045:../uvc.c      **** 								 }else{
2046:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
2047:../uvc.c      **** 								 }
2048:../uvc.c      **** 							 }
2049:../uvc.c      **** 							 if(Data1 < 8){
2050:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
2051:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
2052:../uvc.c      **** 							 }else{
2053:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
2054:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
2055:../uvc.c      **** 							 }
2056:../uvc.c      **** 						 }
2057:../uvc.c      **** 						 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
2058:../uvc.c      **** 						 dataIdx = 0;
2059:../uvc.c      **** 						 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
2060:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2061:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
2062:../uvc.c      **** 						 if(AxMode){
2063:../uvc.c      **** 							 dataIdx++;
2064:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
2065:../uvc.c      **** 							 dataIdx++;
2066:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustmen
2067:../uvc.c      **** 						 }
2068:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2069:../uvc.c      **** 						 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlPa
2070:../uvc.c      **** 						 break;
2071:../uvc.c      **** #endif
2072:../uvc.c      **** 					 case ExtAexModCtlID9://exposure&AGC 4bytes standard operation!!!
2073:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2074:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2075:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2076:../uvc.c      **** 					     dataIdx = 0;
2077:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2078:../uvc.c      **** 						 if(EXTAexModGainlev.UVCCurVLo != getData)
2079:../uvc.c      **** 						 {
2080:../uvc.c      **** 							 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlP
2081:../uvc.c      **** 							 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2082:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2083:../uvc.c      **** 							 /*
2084:../uvc.c      **** 							 dataIdx++;
2085:../uvc.c      **** 							 if(getData == 1 || getData == 3){
2086:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shut
2087:../uvc.c      **** 								 dataIdx++;
2088:../uvc.c      **** 							 }else{
2089:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
2090:../uvc.c      **** 								 dataIdx++;
2091:../uvc.c      **** 							 }
2092:../uvc.c      **** 							 */
2093:../uvc.c      **** 						 }
2094:../uvc.c      **** 						 if(EXTAexModGainlev.UVCCurVHi != getData1){
2095:../uvc.c      **** 							 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
2096:../uvc.c      **** 							 if(getData == 2 || getData == 3){
2097:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
2098:../uvc.c      **** 							 }
2099:../uvc.c      **** 						 }
2100:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2101:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2102:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2103:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getDa
2104:../uvc.c      **** 						 break;
2105:../uvc.c      **** 
2106:../uvc.c      **** 					 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
2107:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2108:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2109:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2110:../uvc.c      **** 					     dataIdx = 0;
2111:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2112:../uvc.c      **** 						 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2113:../uvc.c      **** 						 {
2114:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2115:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2116:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2117:../uvc.c      **** 							 dataIdx++;
2118:../uvc.c      **** 						 }
2119:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
2120:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
2121:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
2122:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
2123:../uvc.c      **** 								 dataIdx++;
2124:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
2125:../uvc.c      **** 							 }
2126:../uvc.c      **** 						 }
2127:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2128:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2129:../uvc.c      **** 						 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2130:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, get
2131:../uvc.c      **** 						 break;
2132:../uvc.c      **** 
2133:../uvc.c      **** 						 /* the exposure hysteresis to gamma correction */
2134:../uvc.c      **** 					 case Ext1ExHysterCtlID7:    // exposure hysteresis level (5MP b/w)
2135:../uvc.c      **** 					 case Ext1ExCtrlSpeedCtlID8:    // exposure control speed level (5MP b/w)
2136:../uvc.c      **** 					 case Ext1EnhanceModeCtlID9:    // edge enhancement mode (5MP b/w)
2137:../uvc.c      **** 					 case Ext1EnhanceGainCtlID10:    // edge enhancement gain level (5MP b/w)
2138:../uvc.c      **** 					 case Ext1GammaCorCtlID14:   // Gamma correction (5MP b/w)
2139:../uvc.c      **** 
2140:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2141:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2142:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2143:../uvc.c      **** 					     dataIdx = 0;
2144:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2145:../uvc.c      **** 						 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2146:../uvc.c      **** 						 {
2147:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2148:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2149:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2150:../uvc.c      **** 							 dataIdx++;
2151:../uvc.c      **** 						 }
2152:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
2153:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
2154:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
2155:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
2156:../uvc.c      **** 								 //dataIdx++;
2157:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //shutter level
2158:../uvc.c      **** 							 }
2159:../uvc.c      **** 						 }
2160:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2161:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2162:../uvc.c      **** 						 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2163:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, get
2164:../uvc.c      **** 						 break;
2165:../uvc.c      **** 
2166:../uvc.c      **** 					 case Ext1EnhanceStarEndCtlID11: // edge enhancement start/end level (5MP b/w) 4bytes
2167:../uvc.c      **** 					 case Ext12DNRGainEnblCtlID12:  // 2D NR gain enable/gain level (5MP b/w) 4bytes
2168:../uvc.c      **** 					 case Ext12DNRGainStarEndCtlID13:  // 2D NR gain start/end level (5MP b/w) 4bytes
2169:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2170:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2171:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2172:../uvc.c      **** 					     dataIdx = 0;
2173:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2174:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2175:../uvc.c      **** 						 {
2176:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2177:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2179:../uvc.c      **** 							 /*
2180:../uvc.c      **** 							 dataIdx++;
2181:../uvc.c      **** 							 if(getData == 1 || getData == 3){
2182:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shut
2183:../uvc.c      **** 								 dataIdx++;
2184:../uvc.c      **** 							 }else{
2185:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
2186:../uvc.c      **** 								 dataIdx++;
2187:../uvc.c      **** 							 }
2188:../uvc.c      **** 							 */
2189:../uvc.c      **** 						 }
2190:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != getData1){
2191:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
2192:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
2193:../uvc.c      **** 						 }
2194:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2195:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2196:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2197:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, EXTShutter.U
2198:../uvc.c      **** 						 break;
2199:../uvc.c      **** 
2200:../uvc.c      **** 					 case ExtCamMCtlID12:
2201:../uvc.c      **** 						 dataIdx = 0;
2202:../uvc.c      **** 						 if(Data0 <= 3){
2203:../uvc.c      **** 							 CamMode = 0; //set 1080p flag
2204:../uvc.c      **** 							 Data1 = Data0;
2205:../uvc.c      **** 						 }else{
2206:../uvc.c      **** 							 CamMode = 1; //set 720p flag
2207:../uvc.c      **** 							 Data1 = Data0-4;
2208:../uvc.c      **** 						 }
2209:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2210:../uvc.c      **** 						 CtrlParArry[BLCIndex][13] = Data1;
2211:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2212:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2213:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2214:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2215:../uvc.c      **** 						 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParArr
2216:../uvc.c      **** 						 break;
2217:../uvc.c      **** 					 case ExtSensorParCtlID14://TODO
2218:../uvc.c      **** 						 dataIdx = 0;
2219:../uvc.c      **** 						 if(Data0 == 0){ //set default sensor parameters.
2220:../uvc.c      **** 							 Data0 = 1;
2221:../uvc.c      **** 						 }else{ //save current sensor parameters.
2222:../uvc.c      **** 							 Data0 = 0;
2223:../uvc.c      **** 						 }
2224:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2225:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2226:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2227:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2228:../uvc.c      **** 						 break;
2229:../uvc.c      **** 					 case ExtI2CCtlID15:
2230:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
2231:../uvc.c      **** 				 			I2CCMDArry[idx] = glEp0Buffer[idx];
2232:../uvc.c      **** 				 		 }
2233:../uvc.c      **** 				 		I2CCmdHandler();
2234:../uvc.c      **** 						 break;
2235:../uvc.c      **** 					 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (0
2236:../uvc.c      **** 					     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
2237:../uvc.c      **** 					     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
2238:../uvc.c      **** 						 devAdd = EXTBLCWinPos.DeviceAdd;
2239:../uvc.c      **** 
2240:../uvc.c      **** 						 dataIdx = 0;
2241:../uvc.c      **** #if 0 //seperate version
2242:../uvc.c      **** 						 getData = Data0&0xF; //get LSB H-Pos.
2243:../uvc.c      **** 						 getData1 = Data0>>4; //get MSB V-Pos.
2244:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2245:../uvc.c      **** 						 if(getData1&0x8){//enable BLD window
2246:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
2247:../uvc.c      **** 						 }else{ //disable BLD window
2248:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
2249:../uvc.c      **** 						 }
2250:../uvc.c      **** 						 getData1 = getData1&0x7; //mask bit7 ~ bit3/
2251:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
2252:../uvc.c      **** 						 dataIdx++;
2253:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
2254:../uvc.c      **** 						 dataIdx++;
2255:../uvc.c      **** 						 getData = Data1&0xf; //get LSB H-size.
2256:../uvc.c      **** 						 getData1 = Data1>>4; //get MSB V-size.
2257:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
2258:../uvc.c      **** 						 dataIdx++;
2259:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2260:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2261:../uvc.c      **** #else //combination version
2262:../uvc.c      **** 						 //Data0 = Data0&0x7F; //mask window show flag bit.
2263:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2264:../uvc.c      **** 					     /* end test */
2265:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2266:../uvc.c      **** 						 dataIdx++;
2267:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2268:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2269:../uvc.c      **** 						 getData1 = Data1;
2270:../uvc.c      **** #endif
2271:../uvc.c      **** 						 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
2272:../uvc.c      **** 						 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2273:../uvc.c      **** 						 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2274:../uvc.c      **** 						 break;
2275:../uvc.c      **** 					 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
2276:../uvc.c      **** 					     //RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
2277:../uvc.c      **** 					     //RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
2278:../uvc.c      **** 						 //devAdd = EXTBLCWeight.DeviceAdd;
2279:../uvc.c      **** 
2280:../uvc.c      **** 						 dataIdx = 0;
2281:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2282:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
2283:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2284:../uvc.c      **** 						 EXTBLCWeight.UVCCurVLo = Data0;
2285:../uvc.c      **** 						 EXTBLCWeight.AvailableF = CyTrue;
2286:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][13] = Data0;
2287:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2288:../uvc.c      **** 						 break;
2289:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
2290:../uvc.c      **** 						 dataIdx = 0;
2291:../uvc.c      **** 						 ExUCtrlParArry[locCtrlID][13] = Data0;
2292:../uvc.c      **** 						 if(Data0 == 1){
2293:../uvc.c      **** 							 Data0 = PUCBLC.UVCCurVLo|0x80;
2294:../uvc.c      **** 						 }else{
2295:../uvc.c      **** 							 Data0 = PUCBLC.UVCCurVLo&0x7f;
2296:../uvc.c      **** 						 }
2297:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2298:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
2299:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2300:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][13] = Data0;
2301:../uvc.c      **** 						 ExUCtrlParArry[locCtrlID][16] = CyTrue;
2302:../uvc.c      **** 						 break;
2303:../uvc.c      **** 			  	  	 case BrgtCtlID1:
2304:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
2305:../uvc.c      **** 						 dataIdx = 0;
2306:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2307:../uvc.c      **** 						  /****** double check the register0 Data1 ******/
2308:../uvc.c      **** 						  if(Data0&0x80){
2309:../uvc.c      **** 							  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2310:../uvc.c      **** 						  }else{
2311:../uvc.c      **** 							  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2312:../uvc.c      **** 						  }
2313:../uvc.c      **** 						 Data1 |= ~0x03;
2314:../uvc.c      **** 						 Data1 &= 0xC7;
2315:../uvc.c      **** 					  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2316:../uvc.c      **** 					  	 dataIdx++;
2317:../uvc.c      **** 
2318:../uvc.c      **** 						 Data0 = (Data0 << 2);
2319:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2320:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2321:../uvc.c      **** 
2322:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2323:../uvc.c      **** 						 CtrlParArry[CtrlID][14] = Data1;
2324:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2325:../uvc.c      **** #endif
2326:../uvc.c      **** 						 dataIdx = 0;
2327:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2328:../uvc.c      **** 						  /****** double check the register0 Data1 ******/
2329:../uvc.c      **** 						  if(Data0&0x80){
2330:../uvc.c      **** 							  Data0 = Data0 - 0x80;
2331:../uvc.c      **** 						  }else{
2332:../uvc.c      **** 							  Data0 = ~Data0;
2333:../uvc.c      **** 						  }
2334:../uvc.c      **** 					  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2335:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2336:../uvc.c      **** 
2337:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2338:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2339:../uvc.c      **** 
2340:../uvc.c      **** 
2341:../uvc.c      **** 						 break;
2342:../uvc.c      **** 					 case HueCtlID5:  //mapping to hue control registers
2343:../uvc.c      **** 						 dataIdx = 0;
2344:../uvc.c      **** 
2345:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2346:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2347:../uvc.c      **** 						 dataIdx++;
2348:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2349:../uvc.c      **** 						 dataIdx++;
2350:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2351:../uvc.c      **** 						 dataIdx++;
2352:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2353:../uvc.c      **** 						 dataIdx++;
2354:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2355:../uvc.c      **** 						 dataIdx++;
2356:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2357:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2358:../uvc.c      **** 
2359:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
2360:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2361:../uvc.c      **** 						 break;
2362:../uvc.c      **** 					 case SaturCtlID6:
2363:../uvc.c      **** 						 dataIdx = 0;
2364:../uvc.c      **** 						 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
2365:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2366:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2367:../uvc.c      **** 						 dataIdx++;
2368:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
2369:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2370:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2371:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2372:../uvc.c      **** 						 break;
2373:../uvc.c      **** 
2374:../uvc.c      **** 					 case WBTLevCtlID11:
2375:../uvc.c      **** 						 Data0 = glEp0Buffer[0]; //blue
2376:../uvc.c      **** 						 Data1 = glEp0Buffer[2]; //red
2377:../uvc.c      **** 						 dataIdx = 0;
2378:../uvc.c      **** 
2379:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2380:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2381:../uvc.c      **** 						 dataIdx++;
2382:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2383:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2384:../uvc.c      **** 
2385:../uvc.c      **** 						 WBMenuCmpArry[0] = Data0;//using for blue part
2386:../uvc.c      **** 						 WBMenuCmpArry[2] = Data1;//using for red part
2387:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2388:../uvc.c      **** 						 break;
2389:../uvc.c      **** 					 case MFreqCtlID4:
2390:../uvc.c      **** 						 dataIdx = 0;
2391:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2392:../uvc.c      **** 						 Data0 = Data0 - 1;
2393:../uvc.c      **** 						 is60Hz = Data0;
2394:../uvc.c      **** 						 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2395:../uvc.c      **** 						 {
2396:../uvc.c      **** 							 Data0 = 0;  // 50Hz (PAL)
2397:../uvc.c      **** 							 is60Hz = CyFalse;
2398:../uvc.c      **** 						 }
2399:../uvc.c      **** 						 else if(Data0 >2)
2400:../uvc.c      **** 						 {
2401:../uvc.c      **** 							 Data0 = 1;  // 60Hz (NTSC)
2402:../uvc.c      **** 							 is60Hz = CyTrue;
2403:../uvc.c      **** 						 }
2404:../uvc.c      **** 						 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2405:../uvc.c      **** 						 if (gpif_initialized == CyTrue)
2406:../uvc.c      **** 						 {
2407:../uvc.c      **** 							 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2408:../uvc.c      **** 		                       switch (setRes)
2409:../uvc.c      **** 		                         {
2410:../uvc.c      **** 		                         	case 1: //1944
2411:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_W
2412:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2413:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz?
2414:../uvc.c      **** 		                         		break;
2415:../uvc.c      **** 		                         	case 2: //1080
2416:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_W
2417:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2418:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz?
2419:../uvc.c      **** 		                         		break;
2420:../uvc.c      **** 		                         	case 3: //720
2421:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2
2422:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2423:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60H
2424:../uvc.c      **** 		                         		break;
2425:../uvc.c      **** 		                         	case 4: //VGA
2426:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2
2427:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2428:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60H
2429:../uvc.c      **** 		                         	default:
2430:../uvc.c      **** 		                         		break;
2431:../uvc.c      **** 		                         }
2432:../uvc.c      **** 							 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2433:../uvc.c      **** 						 }
2434:../uvc.c      **** 
2435:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2436:../uvc.c      **** 						 break;
2437:../uvc.c      **** 				 	 case BLCCtlID0:
2438:../uvc.c      **** 					     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2439:../uvc.c      **** 					     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2440:../uvc.c      **** 					     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
2441:../uvc.c      **** 					     dataIdx = 0;
2442:../uvc.c      **** 
2443:../uvc.c      **** 						 //CtrlParArry[CtrlID][13] = Data0;
2444:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2445:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2446:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2447:../uvc.c      **** 
2448:../uvc.c      **** 						 if(CamMode == 1) //mode 720p
2449:../uvc.c      **** 						 {
2450:../uvc.c      **** 							 if(Data0 < 3){
2451:../uvc.c      **** 				 				 Data0 += 4;
2452:../uvc.c      **** 				 			 }else{
2453:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, g
2454:../uvc.c      **** 								Data0 = 4; //set to default.
2455:../uvc.c      **** 				 			 }
2456:../uvc.c      **** 				 		 }
2457:../uvc.c      **** 						 //CtrlParArry[CamModeIndex][13] = Data0;
2458:../uvc.c      **** 						 dataIdx = 0;
2459:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2460:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2461:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2462:../uvc.c      **** 
2463:../uvc.c      **** 				 		 break;
2464:../uvc.c      **** 				 	 case ShapCtlID7:
2465:../uvc.c      **** 					     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2466:../uvc.c      **** 					     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2467:../uvc.c      **** 					     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
2468:../uvc.c      **** 					     dataIdx = 0;
2469:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2470:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2471:../uvc.c      **** 						 if(Data0 != 0){
2472:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2473:../uvc.c      **** #ifdef COLOR
2474:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement value
2475:../uvc.c      **** #else
2476:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2477:../uvc.c      **** 							 dataIdx++;
2478:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement value
2479:../uvc.c      **** #endif
2480:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2481:../uvc.c      **** 						 }else{
2482:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2483:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2484:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2485:../uvc.c      **** 
2486:../uvc.c      **** 						 }
2487:../uvc.c      **** 						 break;
2488:../uvc.c      **** 					 case ExtExRefCtlID10:
2489:../uvc.c      **** 					 case ConsCtlID2:
2490:../uvc.c      **** 						 dataIdx = 0;
2491:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2492:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2493:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2494:../uvc.c      **** 
2495:../uvc.c      **** 						 CtrlParArry[ConsCtlID2][13] = Data0;
2496:../uvc.c      **** 						 CtrlParArry[ConsCtlID2][16] = CyTrue;
2497:../uvc.c      **** 						 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same control
2498:../uvc.c      **** 						 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
2499:../uvc.c      **** 
2500:../uvc.c      **** 						 break;
2501:../uvc.c      **** 					 default:
2502:../uvc.c      **** 						 dataIdx = 0;
2503:../uvc.c      **** 
2504:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2505:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2506:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2507:../uvc.c      **** 
2508:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2509:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2510:../uvc.c      **** 						 break;
2511:../uvc.c      **** 				 }
2512:../uvc.c      **** 
2513:../uvc.c      **** #endif
2514:../uvc.c      **** /*********************************************************/
2515:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2516:../uvc.c      **** 				  glEp0Buffer, &readCount);
2517:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
2518:../uvc.c      **** 			   {
2519:../uvc.c      **** 				 if(Len == 2){
2520:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
2521:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
2522:../uvc.c      **** 				 }else{
2523:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
2524:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
2525:../uvc.c      **** 				 }
2526:../uvc.c      **** 				 dataIdx = 0;
2527:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
2528:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
2529:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
2530:../uvc.c      **** 					 switch(CtrlID)
2531:../uvc.c      **** 					 {
2532:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
2533:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
2534:../uvc.c      **** 							 if(Data0 == 1){
2535:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
2536:../uvc.c      **** 							 }else{
2537:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
2538:../uvc.c      **** 							 }
2539:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
2541:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2542:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2543:../uvc.c      **** 							 break;
2544:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
2545:../uvc.c      **** 	#if 0 // not be used
2546:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
2547:../uvc.c      **** 
2548:../uvc.c      **** 							 if(CamMode == 1){//720p
2549:../uvc.c      **** 								if(sendData >= 3){
2550:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2551:../uvc.c      **** 									sendData = 0; //set back to default
2552:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
2553:../uvc.c      **** 								}
2554:../uvc.c      **** 								sendData += 4;
2555:../uvc.c      **** 							 }
2556:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2557:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
2558:../uvc.c      **** 							 glEp0Buffer[1] = 0;
2559:../uvc.c      **** 	#endif
2560:../uvc.c      **** 							 break;
2561:../uvc.c      **** 					 	 case ExtI2CCtlID15:
2562:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
2563:../uvc.c      **** 					 			glEp0Buffer[idx] = I2CCMDArry[idx];
2564:../uvc.c      **** 					 		 }
2565:../uvc.c      **** 					 		 sendData = glEp0Buffer[9];
2566:../uvc.c      **** 					 		 sendData1 = glEp0Buffer[10];
2567:../uvc.c      **** 		#ifdef USB_DEBUG_PRINT
2568:../uvc.c      **** 					 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0
2569:../uvc.c      **** 					 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
2570:../uvc.c      **** 					 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
2571:../uvc.c      **** 		#endif
2572:../uvc.c      **** 					 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
2573:../uvc.c      **** 					 		 {
2574:../uvc.c      **** 					 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDA
2575:../uvc.c      **** 					 		 }
2576:../uvc.c      **** 					 		 break;
2577:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
2578:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2579:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2580:../uvc.c      **** 							 {
2581:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wind
2582:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2583:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2584:../uvc.c      **** 							 }
2585:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2586:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2587:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
2588:../uvc.c      **** 									 dataIdx++;
2589:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
2590:../uvc.c      **** 								 }
2591:../uvc.c      **** 							 }
2592:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2593:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2594:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2595:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
2596:../uvc.c      **** 							 break;
2597:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
2598:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
2599:../uvc.c      **** 	#if 1	// register setting directly
2600:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vi
2601:../uvc.c      **** 						     {
2602:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
2603:../uvc.c      **** 						    	 dataIdx = 0;
2604:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2605:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
2606:../uvc.c      **** 								 dataIdx++;
2607:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2608:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2609:../uvc.c      **** 						     }
2610:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
2611:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
2612:../uvc.c      **** 						     break;
2613:../uvc.c      **** 	#else	// old fashion
2614:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
2615:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
2616:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
2617:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
2618:../uvc.c      **** 									 }else{
2619:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
2620:../uvc.c      **** 									 }
2621:../uvc.c      **** 								 }
2622:../uvc.c      **** 							 }else{
2623:../uvc.c      **** 								 Data1 = Data0 - 1;
2624:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
2625:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
2626:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
2627:../uvc.c      **** 									 }else{
2628:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
2629:../uvc.c      **** 									 }
2630:../uvc.c      **** 								 }
2631:../uvc.c      **** 								 if(Data1 < 8){
2632:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
2633:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
2634:../uvc.c      **** 								 }else{
2635:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
2636:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
2637:../uvc.c      **** 								 }
2638:../uvc.c      **** 							 }
2639:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
2640:../uvc.c      **** 							 dataIdx = 0;
2641:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
2642:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2643:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
2644:../uvc.c      **** 							 if(AxMode){
2645:../uvc.c      **** 								 dataIdx++;
2646:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
2647:../uvc.c      **** 								 dataIdx++;
2648:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
2649:../uvc.c      **** 							 }
2650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2651:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
2652:../uvc.c      **** 							 break;
2653:../uvc.c      **** 	#endif
2654:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
2655:../uvc.c      **** 	#if 0 //seperate version
2656:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
2657:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
2658:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2659:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
2660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
2661:../uvc.c      **** 							 }else{ //disable BLD window
2662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
2663:../uvc.c      **** 							 }
2664:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
2665:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
2666:../uvc.c      **** 							 dataIdx++;
2667:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
2668:../uvc.c      **** 							 dataIdx++;
2669:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
2670:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
2671:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
2672:../uvc.c      **** 							 dataIdx++;
2673:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2674:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2675:../uvc.c      **** 	#else //combination version
2676:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2678:../uvc.c      **** 						     /* end test */
2679:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2680:../uvc.c      **** 							 dataIdx++;
2681:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2682:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2683:../uvc.c      **** 							 getData1 = Data1;
2684:../uvc.c      **** 	#endif
2685:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2686:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2687:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2688:../uvc.c      **** 							 break;
2689:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2690:../uvc.c      **** 					 	 case ExtCtlShutlevCtlID11: //viewer should add fine shutter enable control!!!
2691:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2692:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2693:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2694:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2695:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2696:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2697:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2698:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2699:../uvc.c      **** 						 case ExtExRefCtlID10:
2700:../uvc.c      **** 				 	 	 default:
2701:../uvc.c      **** 				 	 			 if(Len == 2)
2702:../uvc.c      **** 				 	 			 {
2703:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2704:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2705:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2706:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2708:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2709:../uvc.c      **** 									 }
2710:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2711:../uvc.c      **** 				 	 			 }else if(Len == 4){
2712:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2713:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2714:../uvc.c      **** 									 {
2715:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2716:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2717:../uvc.c      **** 										 dataIdx++;
2718:../uvc.c      **** 									 }
2719:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2720:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2721:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2722:../uvc.c      **** 									 }
2723:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2724:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2725:../uvc.c      **** 
2726:../uvc.c      **** 				 	 			 }
2727:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2728:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2729:../uvc.c      **** 				 	 			 break;
2730:../uvc.c      **** 					 }
2731:../uvc.c      **** 			 	 }
2732:../uvc.c      **** 			 	 else{
2733:../uvc.c      **** 					 switch(CtrlID)
2734:../uvc.c      **** 					 {
2735:../uvc.c      **** 						 case BrgtCtlID1:
2736:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2737:../uvc.c      **** 								 dataIdx = 0;
2738:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2739:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2740:../uvc.c      **** 								  if(Data0&0x80){
2741:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2742:../uvc.c      **** 								  }else{
2743:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2744:../uvc.c      **** 								  }
2745:../uvc.c      **** 								 Data1 |= ~0x03;
2746:../uvc.c      **** 								 Data1 &= 0xC7;
2747:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2748:../uvc.c      **** 							  	 dataIdx++;
2749:../uvc.c      **** 
2750:../uvc.c      **** 								 Data0 = (Data0 << 2);
2751:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2752:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2753:../uvc.c      **** 
2754:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2755:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2756:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2757:../uvc.c      **** 	#endif
2758:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2759:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2760:../uvc.c      **** 								  if(Data0&0x80){
2761:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2762:../uvc.c      **** 								  }else{
2763:../uvc.c      **** 									  Data0 = ~Data0;
2764:../uvc.c      **** 								  }
2765:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2766:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2767:../uvc.c      **** 
2768:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2769:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2770:../uvc.c      **** 							 break;
2771:../uvc.c      **** 						 case HueCtlID5://not being used
2772:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2774:../uvc.c      **** 							 dataIdx++;
2775:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2776:../uvc.c      **** 							 dataIdx++;
2777:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2778:../uvc.c      **** 							 dataIdx++;
2779:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2780:../uvc.c      **** 							 dataIdx++;
2781:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2782:../uvc.c      **** 							 dataIdx++;
2783:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2784:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2785:../uvc.c      **** 
2786:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2787:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2788:../uvc.c      **** 							 break;
2789:../uvc.c      **** 						 case MFreqCtlID4:
2790:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2791:../uvc.c      **** 							 Data0 = Data0 - 1;
2792:../uvc.c      **** 							 is60Hz = Data0;
2793:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2794:../uvc.c      **** 							 {
2795:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
2796:../uvc.c      **** 								 is60Hz = CyFalse;
2797:../uvc.c      **** 							 }
2798:../uvc.c      **** 							 else if(Data0 >2)
2799:../uvc.c      **** 							 {
2800:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
2801:../uvc.c      **** 								 is60Hz = CyTrue;
2802:../uvc.c      **** 							 }
2803:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2804:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2805:../uvc.c      **** 							 {
2806:../uvc.c      **** 			                       switch (setRes)
2807:../uvc.c      **** 			                         {
2808:../uvc.c      **** 			                         	case 1: //1944
2809:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
2810:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2811:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2812:../uvc.c      **** 			                         		break;
2813:../uvc.c      **** 			                         	case 2: //1080
2814:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
2815:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2816:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2817:../uvc.c      **** 			                         		break;
2818:../uvc.c      **** 			                         	case 3: //720
2819:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
2820:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2821:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2822:../uvc.c      **** 			                         		break;
2823:../uvc.c      **** 			                         	case 4: //VGA
2824:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
2825:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2826:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2827:../uvc.c      **** 			                         	default:
2828:../uvc.c      **** 			                         		break;
2829:../uvc.c      **** 			                         }
2830:../uvc.c      **** 							 }
2831:../uvc.c      **** 
2832:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2833:../uvc.c      **** 							 break;
2834:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2835:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2836:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2837:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2838:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2839:../uvc.c      **** 							 dataIdx++;
2840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2841:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2842:../uvc.c      **** 
2843:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2844:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2845:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2846:../uvc.c      **** 							 break;
2847:../uvc.c      **** 						 case BLCCtlID0:
2848:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2849:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2850:../uvc.c      **** 							 {
2851:../uvc.c      **** 								 if(Data0 < 3){
2852:../uvc.c      **** 					 				 Data0 += 4;
2853:../uvc.c      **** 					 			 }else{
2854:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2855:../uvc.c      **** 									Data0 = 4; //set to default.
2856:../uvc.c      **** 					 			 }
2857:../uvc.c      **** 					 		 }
2858:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2859:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2860:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2861:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2862:../uvc.c      **** 					 		 break;
2863:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2864:../uvc.c      **** 
2865:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2866:../uvc.c      **** 							 if(Data0 != 0){
2867:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2868:../uvc.c      **** 	#ifdef COLOR
2869:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2870:../uvc.c      **** 	#else
2871:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2872:../uvc.c      **** 								 dataIdx++;
2873:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2874:../uvc.c      **** 	#endif
2875:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2876:../uvc.c      **** 							 }else{
2877:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2878:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2879:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2880:../uvc.c      **** 							 }
2881:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2882:../uvc.c      **** 							 break;
2883:../uvc.c      **** 						 case ConsCtlID2:
2884:../uvc.c      **** 						 case WBTMdCtlID9:
2885:../uvc.c      **** 						 case SaturCtlID6:
2886:../uvc.c      **** 						 default:
2887:../uvc.c      **** 			 	 			 if(Len == 2)
2888:../uvc.c      **** 			 	 			 {
2889:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2890:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2891:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2892:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2893:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2894:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2895:../uvc.c      **** 								 }
2896:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2897:../uvc.c      **** 			 	 			 }else if(Len == 4){
2898:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2899:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2900:../uvc.c      **** 								 {
2901:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2902:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2903:../uvc.c      **** 									 dataIdx++;
2904:../uvc.c      **** 								 }
2905:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2906:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2907:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2908:../uvc.c      **** 								 }
2909:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2910:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2911:../uvc.c      **** 
2912:../uvc.c      **** 			 	 			 }
2913:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2914:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2915:../uvc.c      **** 			 	 			 break;
2916:../uvc.c      **** 					 }
2917:../uvc.c      **** 			 	 }
2918:../uvc.c      **** 			   }else{
2919:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2920:../uvc.c      **** 			   }
2921:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2922:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2923:../uvc.c      **** #endif
2924:../uvc.c      **** 
2925:../uvc.c      **** 			  break;
2926:../uvc.c      **** 		  default:
2927:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2928:../uvc.c      **** 			  break;
2929:../uvc.c      **** 		 }
2930:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2931:../uvc.c      **** }
2932:../uvc.c      **** /************** CT control requests handler *************************/
2933:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2934:../uvc.c      **** 
2935:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2936:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2937:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2938:../uvc.c      ****     uint16_t readCount;
2939:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2940:../uvc.c      ****     uint16_t diff, value, diffRd;
2941:../uvc.c      ****     uint8_t i, shutter, index;
2942:../uvc.c      ****     diff = 0xffff;
2943:../uvc.c      ****     shutter = 1;
2944:../uvc.c      ****     index = 1;
2945:../uvc.c      **** 
2946:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2947:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2948:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2949:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2950:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2951:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2952:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2953:../uvc.c      **** #endif
2954:../uvc.c      ****     reqData = bRequest;
2955:../uvc.c      **** 
2956:../uvc.c      ****     switch (bRequest)
2957:../uvc.c      **** 		 {
2958:../uvc.c      **** 
2959:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2960:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2961:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2963:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2964:../uvc.c      **** 			  break;
2965:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2966:../uvc.c      **** 
2967:../uvc.c      **** 			 switch(CtrlID)
2968:../uvc.c      **** 			 {
2969:../uvc.c      **** 				 default:
2970:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2971:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2972:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2973:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2974:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2975:../uvc.c      **** 					 break;
2976:../uvc.c      **** 			 }
2977:../uvc.c      **** 
2978:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2979:../uvc.c      **** 
2980:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2981:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2982:../uvc.c      **** #endif
2983:../uvc.c      **** 			  break;
2984:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2985:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2986:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2987:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2988:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2989:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2990:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2991:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2992:../uvc.c      **** 			  break;
2993:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2994:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2995:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2996:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2997:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2998:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2999:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3000:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3001:../uvc.c      **** 			  break;
3002:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
3003:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
3004:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
3005:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
3006:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3007:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3008:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3009:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3010:../uvc.c      **** 			  break;
3011:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
3012:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
3013:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3014:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3015:../uvc.c      **** 			  Len = 1;
3016:../uvc.c      **** 			  break;
3017:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
3018:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
3019:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
3020:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
3021:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3022:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3023:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3024:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3025:../uvc.c      **** 			  break;
3026:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
3027:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3028:../uvc.c      **** 			  glEp0Buffer, &readCount);
3029:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
3030:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
3031:../uvc.c      **** 			  value = Data1;
3032:../uvc.c      **** 
3033:../uvc.c      **** 			  switch(CtrlID)
3034:../uvc.c      **** 			  {
3035:../uvc.c      **** 		  	      case AutoExMCtlID1:
3036:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
3037:../uvc.c      **** 
3038:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
3039:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
3040:../uvc.c      **** 				    getData = glEp0Buffer[0];
3041:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
3042:../uvc.c      **** 		  		    switch (getData){
3043:../uvc.c      **** 						case 1:
3044:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
3045:../uvc.c      **** 							break;
3046:../uvc.c      **** 						case 2:
3047:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3048:../uvc.c      **** 							dataIdx = 0;
3049:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3050:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3051:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3052:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
3053:../uvc.c      **** 
3054:../uvc.c      **** 							break;
3055:../uvc.c      **** 						case 4:
3056:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
3057:../uvc.c      **** 							break;
3058:../uvc.c      **** 						case 8:
3059:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3060:../uvc.c      **** 			  		    	dataIdx = 0;
3061:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3062:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3063:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3064:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
3065:../uvc.c      **** 							break;
3066:../uvc.c      **** 		  		    }
3067:../uvc.c      **** #if 0
3068:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
3069:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3070:../uvc.c      **** 						  dataIdx = 0;
3071:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3072:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3073:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3074:../uvc.c      **** 		  		    }
3075:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
3076:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
3077:../uvc.c      **** 		  		    }
3078:../uvc.c      **** #endif
3079:../uvc.c      **** 				    break;
3080:../uvc.c      **** 
3081:../uvc.c      **** 			  	  case ExTmACtlID3:
3082:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
3083:../uvc.c      **** 
3084:../uvc.c      **** 					  value = (value << 8)|Data0;
3085:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
3086:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
3087:../uvc.c      **** 					  {
3088:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
3089:../uvc.c      **** 						  {
3090:../uvc.c      **** 							if(value > ShutValueArry[i]){
3091:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
3092:../uvc.c      **** 							}else{
3093:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
3094:../uvc.c      **** 							}
3095:../uvc.c      **** 							  if(diff > diffRd){
3096:../uvc.c      **** 								  diff = diffRd;
3097:../uvc.c      **** 								  index = i;
3098:../uvc.c      **** 							  }
3099:../uvc.c      **** 						  }
3100:../uvc.c      **** 						  shutter = shutter+index;
3101:../uvc.c      **** 
3102:../uvc.c      **** 						  dataIdx = 0;
3103:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3104:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
3105:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3106:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
3107:../uvc.c      **** 
3108:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
3109:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
3110:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
3111:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
3112:../uvc.c      **** 					  }else{
3113:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
3114:../uvc.c      **** 					  }
3115:../uvc.c      **** 					  getData = glEp0Buffer[0];
3116:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3117:../uvc.c      **** 					  break;
3118:../uvc.c      **** 			  	  case IriACtlID7:
3119:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
3120:../uvc.c      **** 					  {
3121:../uvc.c      **** 							 dataIdx = 0;
3122:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3123:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
3124:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3125:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
3126:../uvc.c      **** 
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
3128:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
3129:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
3130:../uvc.c      **** 					  }else{
3131:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
3132:../uvc.c      **** 					  }
3133:../uvc.c      **** 					  getData = glEp0Buffer[0];
3134:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3135:../uvc.c      **** 
3136:../uvc.c      **** 					  break;
3137:../uvc.c      **** 			  	  case ZmOpRCtlID10:
3138:../uvc.c      **** 					  getData = glEp0Buffer[0];
3139:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3140:../uvc.c      **** #if 1
3141:../uvc.c      **** 					  dataIdx = 0;
3142:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3143:../uvc.c      **** 					  if(getData == 1)
3144:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
3145:../uvc.c      **** 					  else if(getData == 0xff)
3146:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
3147:../uvc.c      **** 					  else
3148:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
3149:../uvc.c      **** 					  //dataIdx++;
3150:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
3151:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3152:../uvc.c      **** #endif
3153:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
3154:../uvc.c      **** 					  break;
3155:../uvc.c      **** 
3156:../uvc.c      **** 			  	  default:
3157:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
3158:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
3159:../uvc.c      **** 			  		 break;
3160:../uvc.c      **** 			  }
3161:../uvc.c      **** 			  break;
3162:../uvc.c      **** 		  default:
3163:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
3164:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
3165:../uvc.c      **** 			  break;
3166:../uvc.c      **** 		 }
3167:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
3168:../uvc.c      **** 
3169:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
3170:../uvc.c      **** }
3171:../uvc.c      **** 
3172:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
3173:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
3174:../uvc.c      **** {
3175:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
3176:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3177:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
3178:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
3179:../uvc.c      **** 
3180:../uvc.c      ****     CtrlID = BrgtCtlID1;
3181:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
3182:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3183:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
3184:../uvc.c      ****     Data1 = Data0;
3185:../uvc.c      **** 
3186:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3187:../uvc.c      ****     if(Data1&0x80){
3188:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
3189:../uvc.c      ****     }else{
3190:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
3191:../uvc.c      ****     }
3192:../uvc.c      ****     Data0 = (Data0 << 2);
3193:../uvc.c      **** 
3194:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
3195:../uvc.c      **** 
3196:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
3197:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
3198:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3199:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
3200:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
3201:../uvc.c      **** 
3202:../uvc.c      ****     CtrlID = ConsCtlID2;
3203:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3204:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3205:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3206:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
3207:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3208:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
3209:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3210:../uvc.c      **** 
3211:../uvc.c      ****     CtrlID = HueCtlID5;
3212:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3213:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3214:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3215:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
3218:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
3219:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
3220:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
3221:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
3222:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
3223:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
3224:../uvc.c      **** 
3225:../uvc.c      ****     CtrlID = SaturCtlID6;
3226:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3227:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3228:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
3229:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
3230:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
3231:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3232:../uvc.c      **** 
3233:../uvc.c      ****     CtrlID = ShapCtlID7;
3234:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3235:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3236:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3237:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
3238:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3239:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3240:../uvc.c      **** 
3241:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3242:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
3243:../uvc.c      **** 	return;
3244:../uvc.c      **** }
3245:../uvc.c      **** 
3246:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
3247:../uvc.c      **** void
3248:../uvc.c      **** CyFxUVCAddHeader (
3249:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
3250:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
3251:../uvc.c      ****         )
3252:../uvc.c      **** {
3253:../uvc.c      ****     /* Copy header to buffer */
3254:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3255:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
3256:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
3257:../uvc.c      **** 
3258:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
3259:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
3260:../uvc.c      ****     {
3261:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
3262:../uvc.c      ****     }
3263:../uvc.c      **** }
3264:../uvc.c      **** 
3265:../uvc.c      **** 
3266:../uvc.c      **** /* Application Error Handler */
3267:../uvc.c      **** void
3268:../uvc.c      **** CyFxAppErrorHandler (
3269:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
3270:../uvc.c      ****         )
3271:../uvc.c      **** {
3272:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
3273:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
3274:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
3275:../uvc.c      **** 
3276:../uvc.c      ****        This function can be modified to take additional error handling actions such
3277:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
3278:../uvc.c      ****      */
3279:../uvc.c      ****     for (;;)
3280:../uvc.c      ****     {
3281:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
3282:../uvc.c      ****         CyU3PThreadSleep (1000);
3283:../uvc.c      ****     }
3284:../uvc.c      **** }
3285:../uvc.c      **** 
3286:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
3287:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
3288:../uvc.c      ****  */
3289:../uvc.c      **** static void
3290:../uvc.c      **** CyFxUVCApplnAbortHandler (
3291:../uvc.c      ****         void)
3292:../uvc.c      **** {
3293:../uvc.c      **** 	uint32_t flag;
3294:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
3295:../uvc.c      **** 	{
3296:../uvc.c      ****         /* Clear the Video Stream Request Event */
3297:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
3298:../uvc.c      **** 
3299:../uvc.c      ****         /* Set Video Stream Abort Event */
3300:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
3301:../uvc.c      **** 	}
3302:../uvc.c      **** }
3303:../uvc.c      **** 
3304:../uvc.c      **** /* This is the Callback function to handle the USB Events */
3305:../uvc.c      **** static void
3306:../uvc.c      **** CyFxUVCApplnUSBEventCB (
3307:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
3308:../uvc.c      ****         uint16_t             evdata  /* Event data */
3309:../uvc.c      ****         )
3310:../uvc.c      **** {
3311:../uvc.c      ****     switch (evtype)
3312:../uvc.c      ****     {
3313:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
3314:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
3315:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3316:../uvc.c      ****             gpif_initialized = 0;
3317:../uvc.c      ****             streamingStarted = CyFalse;
3318:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3319:../uvc.c      ****             break;
3320:../uvc.c      **** 
3321:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
3322:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
3323:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3324:../uvc.c      ****             gpif_initialized = 0;
3325:../uvc.c      ****             streamingStarted = CyFalse;
3326:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3327:../uvc.c      ****             break;
3328:../uvc.c      **** 
3329:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
3330:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
3331:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3332:../uvc.c      ****             gpif_initialized = 0;
3333:../uvc.c      ****             isUsbConnected = CyFalse;
3334:../uvc.c      ****             streamingStarted = CyFalse;
3335:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3336:../uvc.c      ****             break;
3337:../uvc.c      **** 
3338:../uvc.c      **** #ifdef BACKFLOW_DETECT
3339:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
3340:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
3341:../uvc.c      ****             break;
3342:../uvc.c      **** #endif
3343:../uvc.c      **** 
3344:../uvc.c      ****         default:
3345:../uvc.c      ****             break;
3346:../uvc.c      ****     }
3347:../uvc.c      **** }
3348:../uvc.c      **** 
3349:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
3350:../uvc.c      **** static CyBool_t
3351:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
3352:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
3353:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
3354:../uvc.c      ****         )
3355:../uvc.c      **** {
3356:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
3357:../uvc.c      ****     uint32_t status;
3358:../uvc.c      **** 
3359:../uvc.c      ****     /* Obtain Request Type and Request */
3360:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
3361:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
3362:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
3363:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
3364:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
3365:../uvc.c      **** 
3366:../uvc.c      ****     /* Check for UVC Class Requests */
3367:../uvc.c      ****     switch (bmReqType)
3368:../uvc.c      ****     {
3369:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
3370:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
3371:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
3372:../uvc.c      ****             switch (wIndex & 0xFF)
3373:../uvc.c      ****             {
3374:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
3375:../uvc.c      ****                     {
3376:../uvc.c      ****                         uvcHandleReq = CyTrue;
3377:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
3378:../uvc.c      ****                                 CYU3P_EVENT_OR);
3379:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
3380:../uvc.c      ****                         {
3381:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
3382:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
3383:../uvc.c      ****                         }
3384:../uvc.c      ****                     }
3385:../uvc.c      ****                     break;
3386:../uvc.c      **** 
3387:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
3388:../uvc.c      ****                     {
3389:../uvc.c      ****                         uvcHandleReq = CyTrue;
3390:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
3391:../uvc.c      ****                                 CYU3P_EVENT_OR);
3392:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
3393:../uvc.c      ****                         {
3394:../uvc.c      ****                             /* Error handling */
3395:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
3396:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
3397:../uvc.c      ****                         }
3398:../uvc.c      ****                     }
3399:../uvc.c      ****                     break;
3400:../uvc.c      **** 
3401:../uvc.c      ****                 default:
3402:../uvc.c      ****                     break;
3403:../uvc.c      ****             }
3404:../uvc.c      ****             break;
3405:../uvc.c      **** 
3406:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
3407:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
3408:../uvc.c      ****             {
3409:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
3410:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
3411:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
3412:../uvc.c      ****                 {
3413:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
3414:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
3415:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
3416:../uvc.c      ****                     gpif_initialized = 0;
3417:../uvc.c      ****                     streamingStarted = CyFalse;
3418:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
3419:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3420:../uvc.c      ****                     CyU3PBusyWait (100);
3421:../uvc.c      **** 
3422:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
3423:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3424:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3425:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3426:../uvc.c      ****                     CyU3PBusyWait (100);
3427:../uvc.c      **** 
3428:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
3429:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3430:../uvc.c      ****                     uvcHandleReq = CyTrue;
3431:../uvc.c      ****                     /* Complete Control request handshake */
3432:../uvc.c      ****                     CyU3PUsbAckSetup ();
3433:../uvc.c      ****                     /* Indicate stop streaming to main thread */
3434:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
3435:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
3436:../uvc.c      **** 
3437:../uvc.c      ****                 }
3438:../uvc.c      ****             }
3439:../uvc.c      ****             break;
3440:../uvc.c      **** 
3441:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
3442:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
3443:../uvc.c      ****             {
3444:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
3445:../uvc.c      ****                 {
3446:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
3447:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
3448:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
3449:../uvc.c      ****                 	 * has started. */
3450:../uvc.c      ****                     if (streamingStarted == CyTrue)
3451:../uvc.c      ****                     {
3452:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
3453:../uvc.c      **** 
3454:../uvc.c      ****                         /* Disable the GPIF state machine. */
3455:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
3456:../uvc.c      ****                         gpif_initialized = 0;
3457:../uvc.c      ****                         streamingStarted = CyFalse;
3458:../uvc.c      **** 
3459:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
3460:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3461:../uvc.c      ****                         CyU3PBusyWait (100);
3462:../uvc.c      **** 
3463:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
3464:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3465:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3466:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3467:../uvc.c      ****                         CyU3PBusyWait (100);
3468:../uvc.c      **** 
3469:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
3470:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3471:../uvc.c      **** 
3472:../uvc.c      ****                         uvcHandleReq = CyTrue;
3473:../uvc.c      ****                         /* Complete Control request handshake */
3474:../uvc.c      ****                         CyU3PUsbAckSetup ();
3475:../uvc.c      ****                         /* Indicate stop streaming to main thread */
3476:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
3477:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
3478:../uvc.c      ****                     }
3479:../uvc.c      ****                     else
3480:../uvc.c      ****                     {
3481:../uvc.c      ****                         uvcHandleReq = CyTrue;
3482:../uvc.c      ****                         CyU3PUsbAckSetup ();
3483:../uvc.c      ****                     }
3484:../uvc.c      ****                 }
3485:../uvc.c      ****             }
3486:../uvc.c      ****             break;
3487:../uvc.c      **** 
3488:../uvc.c      ****         default:
3489:../uvc.c      ****             break;
3490:../uvc.c      ****     }
3491:../uvc.c      **** 
3492:../uvc.c      ****     /* Return status of request handling to the USB driver */
3493:../uvc.c      ****     return uvcHandleReq;
3494:../uvc.c      **** }
3495:../uvc.c      **** 
3496:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
3497:../uvc.c      **** 
3498:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
3499:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
3500:../uvc.c      ****  */
3501:../uvc.c      **** void
3502:../uvc.c      **** CyFxUvcApplnDmaCallback (
3503:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
3504:../uvc.c      ****         CyU3PDmaCbType_t      type,
3505:../uvc.c      ****         CyU3PDmaCBInput_t    *input
3506:../uvc.c      ****         )
3507:../uvc.c      **** {
3508:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
3509:../uvc.c      **** #if 1
3510:../uvc.c      ****     CyU3PReturnStatus_t status;
3511:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
3512:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
3513:../uvc.c      **** 
3514:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3515:../uvc.c      ****     {
3516:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
3517:../uvc.c      ****             {
3518:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
3519:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
3520:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3521:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
3522:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3523:../uvc.c      ****                 	stiflag = 0x03;
3524:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
3525:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3526:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3527:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
3528:../uvc.c      ****                 }
3529:../uvc.c      **** #endif
3530:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
3531:../uvc.c      ****                 fb++;
3532:../uvc.c      ****             }
3533:../uvc.c      ****             else
3534:../uvc.c      ****             {
3535:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
3536:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
3537:../uvc.c      ****                 pb++;
3538:../uvc.c      ****                 pbc = input->buffer_p.count;
3539:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
3540:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
3541:../uvc.c      ****                 //lineCount = 0; //res test
3542:../uvc.c      **** #if 1   //remove the still flag clearing here
3543:../uvc.c      ****                 if(stiflag == 0x0F){
3544:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3545:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3546:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
3547:../uvc.c      ****                 	stiflag = 0xAA;
3548:../uvc.c      ****                 }
3549:../uvc.c      **** #endif
3550:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
3551:../uvc.c      ****             }
3552:../uvc.c      **** 
3553:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
3554:../uvc.c      ****             prodCount++;
3555:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3556:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
3557:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
3558:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
3559:../uvc.c      ****             {
3560:../uvc.c      ****                 prodCount--;
3561:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
3562:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
3563:../uvc.c      ****             }
3564:../uvc.c      ****     }
3565:../uvc.c      **** #endif
3566:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
3567:../uvc.c      ****     {
3568:../uvc.c      ****         consCount++;
3569:../uvc.c      ****         streamingStarted = CyTrue;
3570:../uvc.c      ****     }
3571:../uvc.c      **** }
3572:../uvc.c      **** 
3573:../uvc.c      **** /*
3574:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
3575:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
3576:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
3577:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
3578:../uvc.c      ****  * to commit the buffer.
3579:../uvc.c      ****  */
3580:../uvc.c      **** static uint8_t
3581:../uvc.c      **** CyFxUvcAppCommitEOF (
3582:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
3583:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
3584:../uvc.c      ****         )
3585:../uvc.c      **** {
3586:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3587:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
3588:../uvc.c      **** 
3589:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
3590:../uvc.c      **** 
3591:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3592:../uvc.c      ****     {
3593:../uvc.c      ****         switch (stateId)
3594:../uvc.c      ****         {
3595:../uvc.c      **** 
3596:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
3597:../uvc.c      ****             case FULL_BUF_IN_SCK1:
3598:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3599:../uvc.c      ****                 break;
3600:../uvc.c      **** 
3601:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
3602:../uvc.c      ****                 socket = 0;
3603:../uvc.c      ****                 break;
3604:../uvc.c      **** 
3605:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
3606:../uvc.c      ****                 socket = 1;
3607:../uvc.c      ****                 break;
3608:../uvc.c      **** 
3609:../uvc.c      ****             default:
3610:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3611:../uvc.c      ****                 /* Unexpected current state. Return error. */
3612:../uvc.c      ****             	//lineCount++;
3613:../uvc.c      ****             	return 1;
3614:../uvc.c      ****         }
3615:../uvc.c      ****     }
3616:../uvc.c      **** 
3617:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3618:../uvc.c      ****     {
3619:../uvc.c      ****         switch (stateId)
3620:../uvc.c      ****         {
3621:../uvc.c      **** #ifndef CAM720
3622:../uvc.c      **** #ifdef GPIFIIM
3623:../uvc.c      ****             case 13:
3624:../uvc.c      ****             case 24:
3625:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3626:../uvc.c      ****                 break;
3627:../uvc.c      **** 
3628:../uvc.c      ****             case 8:
3629:../uvc.c      ****                 socket = 0;
3630:../uvc.c      ****                 break;
3631:../uvc.c      **** 
3632:../uvc.c      ****             case 20:
3633:../uvc.c      ****                 socket = 1;
3634:../uvc.c      ****                 break;
3635:../uvc.c      **** #else
3636:../uvc.c      ****             case 11:
3637:../uvc.c      ****             case 18:
3638:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3639:../uvc.c      ****                 break;
3640:../uvc.c      **** 
3641:../uvc.c      ****             case 8:
3642:../uvc.c      ****                 socket = 0;
3643:../uvc.c      ****                 break;
3644:../uvc.c      **** 
3645:../uvc.c      ****             case 15:
3646:../uvc.c      ****                 socket = 1;
3647:../uvc.c      ****                 break;
3648:../uvc.c      **** #endif
3649:../uvc.c      **** #else
3650:../uvc.c      ****             case 11:
3651:../uvc.c      ****             case 18:
3652:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3653:../uvc.c      ****                 break;
3654:../uvc.c      **** 
3655:../uvc.c      ****             case 8:
3656:../uvc.c      ****                 socket = 0;
3657:../uvc.c      ****                 break;
3658:../uvc.c      **** 
3659:../uvc.c      ****             case 15:
3660:../uvc.c      ****                 socket = 1;
3661:../uvc.c      ****                 break;
3662:../uvc.c      **** 
3663:../uvc.c      **** #endif
3664:../uvc.c      ****              default:
3665:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3666:../uvc.c      ****                 /* Unexpected current state. Return error. */
3667:../uvc.c      ****                return 1;
3668:../uvc.c      ****         }
3669:../uvc.c      ****     }
3670:../uvc.c      **** 
3671:../uvc.c      ****     if (socket != 0xFF)
3672:../uvc.c      ****     {
3673:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3674:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3675:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3676:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3677:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3678:../uvc.c      ****         {
3679:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3680:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3681:../uvc.c      ****         }
3682:../uvc.c      ****     }
3683:../uvc.c      **** 
3684:../uvc.c      ****     return 0;
3685:../uvc.c      **** }
3686:../uvc.c      **** 
3687:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3688:../uvc.c      **** void
3689:../uvc.c      **** CyFxGpifCB (
3690:../uvc.c      ****         CyU3PGpifEventType event,
3691:../uvc.c      ****         uint8_t currentState
3692:../uvc.c      ****         )
3693:../uvc.c      **** {
3694:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3695:../uvc.c      ****     {
3696:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3697:../uvc.c      ****     	           in the UVC implementation. */
3698:../uvc.c      ****     	//hitFV = CyTrue;
3699:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3700:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3701:../uvc.c      ****     }
3702:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3703:../uvc.c      **** }
3704:../uvc.c      **** 
3705:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3706:../uvc.c      **** static void
3707:../uvc.c      **** CyFxUVCApplnDebugInit (
3708:../uvc.c      ****         void)
3709:../uvc.c      **** {
3710:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3711:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3712:../uvc.c      **** 
3713:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3714:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3715:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3716:../uvc.c      ****     {
3717:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3718:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3719:../uvc.c      ****     }
3720:../uvc.c      **** 
3721:../uvc.c      ****     /* Set UART Configuration */
3722:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3723:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3724:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3725:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3726:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3727:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3728:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3729:../uvc.c      **** 
3730:../uvc.c      ****     /* Set the UART configuration */
3731:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3732:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3733:../uvc.c      ****     {
3734:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3735:../uvc.c      ****     }
3736:../uvc.c      **** 
3737:../uvc.c      ****     /* Set the UART transfer */
3738:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3740:../uvc.c      ****     {
3741:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3742:../uvc.c      ****     }
3743:../uvc.c      **** 
3744:../uvc.c      ****     /* Initialize the Debug logger module. */
3745:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3746:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3747:../uvc.c      ****     {
3748:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3749:../uvc.c      ****     }
3750:../uvc.c      **** 
3751:../uvc.c      ****     /* Disable log message headers. */
3752:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3753:../uvc.c      **** }
3754:../uvc.c      **** 
3755:../uvc.c      **** /* I2C initialization. */
3756:../uvc.c      **** static void
3757:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3758:../uvc.c      **** {
3759:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3760:../uvc.c      ****     CyU3PReturnStatus_t status;
3761:../uvc.c      **** 
3762:../uvc.c      ****     status = CyU3PI2cInit ();
3763:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3764:../uvc.c      ****     {
3765:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3766:../uvc.c      ****         CyFxAppErrorHandler (status);
3767:../uvc.c      ****     }
3768:../uvc.c      **** 
3769:../uvc.c      ****     /*  Set I2C Configuration */
3770:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3771:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3772:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3773:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3774:../uvc.c      **** 
3775:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3776:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3777:../uvc.c      ****     {
3778:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3779:../uvc.c      ****         CyFxAppErrorHandler (status);
3780:../uvc.c      ****     }
3781:../uvc.c      **** }
3782:../uvc.c      **** 
3783:../uvc.c      **** #ifdef BACKFLOW_DETECT
3784:../uvc.c      **** static void CyFxUvcAppPibCallback (
3785:../uvc.c      ****         CyU3PPibIntrType cbType,
3786:../uvc.c      ****         uint16_t cbArg)
3787:../uvc.c      **** {
3788:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3789:../uvc.c      ****     {
3790:../uvc.c      ****         if (!back_flow_detected)
3791:../uvc.c      ****         {
3792:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3793:../uvc.c      ****             back_flow_detected = 1;
3794:../uvc.c      ****         }
3795:../uvc.c      ****     }
3796:../uvc.c      **** }
3797:../uvc.c      **** #endif
3798:../uvc.c      **** 
3799:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3800:../uvc.c      **** static void
3801:../uvc.c      **** CyFxUvcAppDebugCallback (
3802:../uvc.c      ****         CyU3PDmaChannel   *handle,
3803:../uvc.c      ****         CyU3PDmaCbType_t   type,
3804:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3805:../uvc.c      **** {
3806:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3807:../uvc.c      ****     {
3808:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3809:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3810:../uvc.c      ****     }
3811:../uvc.c      **** }
3812:../uvc.c      **** #endif
3813:../uvc.c      **** 
3814:../uvc.c      **** #if 0
3815:../uvc.c      **** static void CyFxAppIntEpCb(
3816:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3817:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3818:../uvc.c      **** 		uint8_t  ebNum)
3819:../uvc.c      **** 		{
3820:../uvc.c      **** 			//CyBool_t value;
3821:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3822:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3823:../uvc.c      **** 
3824:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3825:../uvc.c      **** 		}
3826:../uvc.c      **** #endif
3827:../uvc.c      **** 
3828:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3829:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3830:../uvc.c      ****    configures the DMA module for the UVC Application */
3831:../uvc.c      **** static void
3832:../uvc.c      **** CyFxUVCApplnInit (void)
3833:../uvc.c      **** {
3834:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3835:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3836:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3837:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3838:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3839:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3840:../uvc.c      **** 
3841:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3842:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3843:../uvc.c      **** 
3844:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3845:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3846:../uvc.c      **** #endif
3847:../uvc.c      **** 
3848:../uvc.c      ****     /* Create UVC event group */
3849:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3850:../uvc.c      ****     if (apiRetStatus != 0)
3851:../uvc.c      ****     {
3852:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3853:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3854:../uvc.c      ****     }
3855:../uvc.c      **** 
3856:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3857:../uvc.c      ****     CyFxUvcAppPTZInit ();
3858:../uvc.c      **** #endif
3859:../uvc.c      **** 
3860:../uvc.c      ****     isUsbConnected = CyFalse;
3861:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3862:../uvc.c      **** 
3863:../uvc.c      ****     /* Init the GPIO module */
3864:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3865:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3866:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3867:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3868:../uvc.c      ****     gpioClock.halfDiv    = 0;
3869:../uvc.c      **** 
3870:../uvc.c      ****     /* Initialize Gpio interface */
3871:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3872:../uvc.c      ****     if (apiRetStatus != 0)
3873:../uvc.c      ****     {
3874:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3875:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3876:../uvc.c      ****     }
3877:../uvc.c      **** 
3878:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3879:../uvc.c      ****      * must use GpioOverride to configure it */
3880:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3881:../uvc.c      ****     if (apiRetStatus != 0)
3882:../uvc.c      ****     {
3883:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3884:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3885:../uvc.c      ****     }
3886:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3887:../uvc.c      ****     if (apiRetStatus != 0)
3888:../uvc.c      ****     {
3889:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3890:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3891:../uvc.c      ****     }
3892:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3893:../uvc.c      ****     if (apiRetStatus != 0)
3894:../uvc.c      ****     {
3895:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3896:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3897:../uvc.c      ****     }
3898:../uvc.c      **** 
3899:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3900:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3901:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3902:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3903:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3904:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3905:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3906:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3907:../uvc.c      ****     {
3908:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3909:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3910:../uvc.c      ****     }
3911:../uvc.c      **** 
3912:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3913:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3914:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3915:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3916:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3917:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3918:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3919:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3920:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3921:../uvc.c      ****     {
3922:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3923:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3924:../uvc.c      ****     }
3925:../uvc.c      **** 
3926:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3927:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3928:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3929:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3930:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3931:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3932:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3933:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3935:../uvc.c      ****     {
3936:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3938:../uvc.c      ****     }
3939:../uvc.c      **** 
3940:../uvc.c      ****     /* Initialize the P-port. */
3941:../uvc.c      ****     pibclock.clkDiv      = 2;
3942:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3943:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3944:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3945:../uvc.c      **** 
3946:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3947:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3948:../uvc.c      ****     {
3949:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3951:../uvc.c      ****     }
3952:../uvc.c      **** 
3953:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3954:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3955:../uvc.c      **** 
3956:../uvc.c      **** #ifdef BACKFLOW_DETECT
3957:../uvc.c      ****     back_flow_detected = 0;
3958:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3959:../uvc.c      **** #endif
3960:../uvc.c      **** 
3961:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3962:../uvc.c      ****     SensorReset ();
3963:../uvc.c      ****     CyU3PThreadSleep(5000);
3964:../uvc.c      ****     //SensorInit ();
3965:../uvc.c      **** 
3966:../uvc.c      ****     /* USB initialization. */
3967:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3968:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3969:../uvc.c      ****     {
3970:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3971:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3972:../uvc.c      ****     }
3973:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3974:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3975:../uvc.c      **** 
3976:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3977:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3978:../uvc.c      **** 
3979:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3980:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3981:../uvc.c      **** 
3982:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3983:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3984:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3985:../uvc.c      **** 
3986:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3987:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3988:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3989:../uvc.c      **** 
3990:../uvc.c      ****     /* Configuration descriptors. */
3991:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3992:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3993:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3994:../uvc.c      **** 
3995:../uvc.c      ****     /* String Descriptors */
3996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3997:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3998:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3999:../uvc.c      **** 
4000:../uvc.c      ****     /* Configure the status interrupt endpoint.
4001:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
4002:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
4003:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
4004:../uvc.c      ****      */
4005:../uvc.c      ****     endPointConfig.enable   = 1;
4006:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
4007:../uvc.c      ****     endPointConfig.pcktSize = 64;
4008:../uvc.c      ****     endPointConfig.isoPkts  = 0;
4009:../uvc.c      ****     endPointConfig.streams  = 0;
4010:../uvc.c      ****     endPointConfig.burstLen = 1;
4011:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
4012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4013:../uvc.c      ****     {
4014:../uvc.c      ****         /* Error Handling */
4015:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
4016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4017:../uvc.c      ****     }
4018:../uvc.c      **** 
4019:../uvc.c      ****     /* create a DMA for interrupt endpoint */
4020:../uvc.c      ****     dmaInterConfig.size           = 1024;
4021:../uvc.c      ****     dmaInterConfig.count          = 1;
4022:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
4023:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
4024:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
4025:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
4026:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
4027:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
4028:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4029:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
4030:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
4031:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
4032:../uvc.c      ****             &dmaInterConfig);
4033:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4034:../uvc.c      ****     {
4035:../uvc.c      ****         /* Error handling */
4036:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
4037:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4038:../uvc.c      ****     }
4039:../uvc.c      **** 
4040:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
4041:../uvc.c      ****     if (glInterStaBuffer == 0)
4042:../uvc.c      ****     {
4043:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
4044:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
4045:../uvc.c      ****     }
4046:../uvc.c      **** 
4047:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
4048:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
4049:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
4050:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
4051:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
4052:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
4053:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
4054:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
4055:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
4056:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
4057:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
4058:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
4059:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4060:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
4061:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
4062:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
4063:../uvc.c      ****             &dmaMultiConfig);
4064:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4065:../uvc.c      ****     {
4066:../uvc.c      ****         /* Error handling */
4067:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
4068:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4069:../uvc.c      ****     }
4070:../uvc.c      **** 
4071:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4072:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
4073:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
4074:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
4075:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
4076:../uvc.c      ****      */
4077:../uvc.c      **** 
4078:../uvc.c      ****     endPointConfig.enable   = 1;
4079:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
4080:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
4081:../uvc.c      ****     endPointConfig.isoPkts  = 0;
4082:../uvc.c      ****     endPointConfig.streams  = 0;
4083:../uvc.c      ****     endPointConfig.burstLen = 1;
4084:../uvc.c      **** 
4085:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
4086:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4087:../uvc.c      ****     {
4088:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
4089:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4090:../uvc.c      ****     }
4091:../uvc.c      **** 
4092:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
4093:../uvc.c      **** 
4094:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
4095:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4096:../uvc.c      ****     {
4097:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
4098:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4099:../uvc.c      ****     }
4100:../uvc.c      **** 
4101:../uvc.c      ****     channelConfig.size           = 1024;
4102:../uvc.c      ****     channelConfig.count          = 1;
4103:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
4104:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
4105:../uvc.c      ****     channelConfig.prodAvailCount = 0;
4106:../uvc.c      ****     channelConfig.prodHeader     = 0;
4107:../uvc.c      ****     channelConfig.prodFooter     = 0;
4108:../uvc.c      ****     channelConfig.consHeader     = 0;
4109:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4110:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
4111:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
4112:../uvc.c      **** 
4113:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
4114:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4115:../uvc.c      ****     {
4116:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
4117:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4118:../uvc.c      ****     }
4119:../uvc.c      **** 
4120:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
4121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4122:../uvc.c      ****     {
4123:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
4124:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4125:../uvc.c      ****     }
4126:../uvc.c      **** 
4127:../uvc.c      ****     channelConfig.size           = 1024;
4128:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
4129:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
4130:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
4131:../uvc.c      ****     channelConfig.prodAvailCount = 0;
4132:../uvc.c      ****     channelConfig.prodHeader     = 0;
4133:../uvc.c      ****     channelConfig.prodFooter     = 0;
4134:../uvc.c      ****     channelConfig.consHeader     = 0;
4135:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4136:../uvc.c      ****     channelConfig.notification   = 0;
4137:../uvc.c      ****     channelConfig.cb             = 0;
4138:../uvc.c      **** 
4139:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
4140:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4141:../uvc.c      ****     {
4142:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
4143:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4144:../uvc.c      ****     }
4145:../uvc.c      **** 
4146:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
4147:../uvc.c      ****     if (glDebugRspBuffer == 0)
4148:../uvc.c      ****     {
4149:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
4150:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
4151:../uvc.c      ****     }
4152:../uvc.c      **** #endif
4153:../uvc.c      **** 
4154:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
4155:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
4156:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4157:../uvc.c      ****     {
4158:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
4159:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4160:../uvc.c      ****     }
4161:../uvc.c      **** 
4162:../uvc.c      ****     CyU3PBusyWait(100);
4163:../uvc.c      **** 
4164:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
4165:../uvc.c      **** 
4166:../uvc.c      ****     endPointConfig.enable   = 1;
4167:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
4168:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
4169:../uvc.c      ****     {
4170:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
4171:../uvc.c      ****     	endPointConfig.burstLen = 16;
4172:../uvc.c      ****     }
4173:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
4174:../uvc.c      ****     {
4175:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
4176:../uvc.c      ****     	endPointConfig.burstLen = 1;
4177:../uvc.c      ****     }
4178:../uvc.c      ****     endPointConfig.streams  = 0;
4179:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
4180:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4181:../uvc.c      ****     {
4182:../uvc.c      ****         /* Error Handling */
4183:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
4184:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4185:../uvc.c      ****     }
4186:../uvc.c      **** #if 0    //for still image method 3 using
4187:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
4188:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4189:../uvc.c      ****     {
4190:../uvc.c      ****         /* Error Handling */
4191:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
4192:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4193:../uvc.c      ****     }
4194:../uvc.c      **** #endif
4195:../uvc.c      **** 
4196:../uvc.c      **** }
4197:../uvc.c      **** 
4198:../uvc.c      **** /*
4199:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
4200:../uvc.c      ****  * streaming session is started.
4201:../uvc.c      ****  */
4202:../uvc.c      **** static void
4203:../uvc.c      **** CyFxUvcAppGpifInit (
4204:../uvc.c      ****         void)
4205:../uvc.c      **** {
4206:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
4207:../uvc.c      **** 
4208:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
4209:../uvc.c      ****     {
4210:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
4211:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
4212:../uvc.c      ****     }
4213:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
4214:../uvc.c      ****     {
4215:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
4216:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
4217:../uvc.c      ****     }
4218:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4219:../uvc.c      ****     {
4220:../uvc.c      ****         /* Error Handling */
4221:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
4222:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4223:../uvc.c      ****     }
4224:../uvc.c      **** 
4225:../uvc.c      ****     /* Start the state machine from the designated start state. */
4226:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
4227:../uvc.c      ****     {
4228:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
4229:../uvc.c      ****     }
4230:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
4231:../uvc.c      ****     {
4232:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
4233:../uvc.c      ****     }
4234:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4235:../uvc.c      ****     {
4236:../uvc.c      ****         /* Error Handling */
4237:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
4238:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4239:../uvc.c      ****     }
4240:../uvc.c      **** }
4241:../uvc.c      **** 
4242:../uvc.c      **** /*
4243:../uvc.c      ****  * Entry function for the UVC Application Thread
4244:../uvc.c      ****  */
4245:../uvc.c      **** 
4246:../uvc.c      **** uint32_t posTick;
4247:../uvc.c      **** CyU3PTimer I2CCmdTimer;
4248:../uvc.c      **** 
4249:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 4249 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
4250:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 4250 0
  28 0000 28209FE5 		ldr	r2, .L2
4249:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 4249 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 4250 0
  36 0008 002092E5 		ldr	r2, [r2]
4249:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 4249 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 4250 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
4251:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 4251 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
4252:../uvc.c      **** }
  49              		.loc 1 4252 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
4251:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 4251 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
4253:../uvc.c      **** 
4254:../uvc.c      **** 
4255:../uvc.c      **** void
4256:../uvc.c      **** UVCAppThread_Entry (
4257:../uvc.c      ****         uint32_t input)
4258:../uvc.c      **** {
4259:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
4260:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
4261:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
4262:../uvc.c      ****     uint8_t i = 0;
4263:../uvc.c      ****     uint32_t flag;
4264:../uvc.c      ****     uint32_t prinflag = 0;
4265:../uvc.c      **** static uint8_t IMcount = 0;
4266:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
4267:../uvc.c      ****     uint32_t frameCnt = 0;
4268:../uvc.c      **** #endif
4269:../uvc.c      ****     /* Initialize the Uart Debug Module */
4270:../uvc.c      ****     CyFxUVCApplnDebugInit ();
4271:../uvc.c      **** 
4272:../uvc.c      ****     /* Initialize the I2C interface */
4273:../uvc.c      **** 	while (i++ < 6){
4274:../uvc.c      **** 		CyU3PThreadSleep(500);
4275:../uvc.c      **** 	}
4276:../uvc.c      **** 
4277:../uvc.c      ****     CyFxUVCApplnI2CInit ();
4278:../uvc.c      **** 
4279:../uvc.c      ****     /* Initialize the UVC Application */
4280:../uvc.c      ****     CyFxUVCApplnInit ();
4281:../uvc.c      ****     /*
4282:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
4283:../uvc.c      **** 
4284:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
4285:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
4286:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
4287:../uvc.c      **** 
4288:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
4289:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
4290:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
4291:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
4292:../uvc.c      **** 
4293:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
4294:../uvc.c      ****        of handling the abort request.
4295:../uvc.c      ****      */
4296:../uvc.c      **** 
4297:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
4298:../uvc.c      ****     //CyU3PThreadSleep(1000);
4299:../uvc.c      **** 
4300:../uvc.c      ****     for (;;)
4301:../uvc.c      ****     {
4302:../uvc.c      ****         /* Waiting for the Video Stream Event */
4303:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
4304:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
4305:../uvc.c      ****         {
4306:../uvc.c      **** #if 0 //test for new firmware no video bring up
4307:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
4308:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
4309:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
4310:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
4311:../uvc.c      ****             {
4312:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
4313:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
4314:../uvc.c      ****                 {
4315:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
4316:../uvc.c      **** #ifdef  USB_LOWRES_IMG
4317:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
4318:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
4319:../uvc.c      **** #endif
4320:../uvc.c      **** #endif
4321:../uvc.c      ****                     }
4322:../uvc.c      ****                 else
4323:../uvc.c      ****                 {
4324:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
4325:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
4326:../uvc.c      **** #ifdef USB_LOWRES_IMG
4327:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
4328:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4329:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
4330:../uvc.c      **** #endif
4331:../uvc.c      **** #endif
4332:../uvc.c      ****                 }
4333:../uvc.c      **** 
4334:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
4335:../uvc.c      ****                 prodCount++;
4336:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
4337:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
4338:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
4339:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4340:../uvc.c      ****                 {
4341:../uvc.c      ****                     prodCount--;
4342:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
4343:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
4344:../uvc.c      ****                 }
4345:../uvc.c      ****             }
4346:../uvc.c      **** #endif
4347:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
4348:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
4349:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
4350:../uvc.c      ****             {
4351:../uvc.c      ****             	if(0&&(prinflag == 0)){
4352:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
4353:../uvc.c      ****             		prinflag = 1;
4354:../uvc.c      ****             	}
4355:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
4356:../uvc.c      ****             	fb=0;
4357:../uvc.c      ****             	pb=0;
4358:../uvc.c      ****             	pbc=0;
4359:../uvc.c      ****                 prodCount = 0;
4360:../uvc.c      ****                 consCount = 0;
4361:../uvc.c      ****                 hitFV     = CyFalse;
4362:../uvc.c      **** 
4363:../uvc.c      **** #ifdef BACKFLOW_DETECT
4364:../uvc.c      ****                 back_flow_detected = 0;
4365:../uvc.c      **** #endif
4366:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
4367:../uvc.c      ****                 frameCnt++;
4368:../uvc.c      **** #endif
4369:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
4370:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
4371:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
4372:../uvc.c      ****                 //}
4373:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
4374:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
4375:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
4376:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
4377:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4378:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
4379:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
4380:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
4381:../uvc.c      ****                      	//CyU3PThreadSleep(100);
4382:../uvc.c      ****                 		stiflag = 0xFF;
4383:../uvc.c      ****                 		IMcount = 0;
4384:../uvc.c      ****                 	}
4385:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
4386:../uvc.c      **** 
4387:../uvc.c      ****                  		if(IMcount++ >= 0x3){
4388:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
4389:../uvc.c      ****                 		stiflag = 0x0F;
4390:../uvc.c      ****                 		IMcount = 0;
4391:../uvc.c      ****                 		}
4392:../uvc.c      ****                  		/*if(IMcount > 0x4){
4393:../uvc.c      ****                 			stiflag = 0x0F;
4394:../uvc.c      ****                 			IMcount = 0;
4395:../uvc.c      ****                 		}*/
4396:../uvc.c      **** 
4397:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
4398:../uvc.c      ****                     //CyU3PThreadSleep(400);
4399:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
4400:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
4401:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
4402:../uvc.c      **** 
4403:../uvc.c      ****                 	if(IMcount++ >= 0x3)
4404:../uvc.c      ****                 	{
4405:../uvc.c      ****                     switch (setRes)
4406:../uvc.c      ****                      {
4407:../uvc.c      ****                  	case 1: //1944
4408:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
4409:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4410:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
4411:../uvc.c      ****                  		break;
4412:../uvc.c      ****                  	case 2: //1080
4413:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
4414:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4415:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
4416:../uvc.c      ****                  		break;
4417:../uvc.c      ****                  	case 3: //720
4418:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
4419:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4420:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
4421:../uvc.c      ****                  		break;
4422:../uvc.c      ****                  	case 4: //VGA
4423:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
4424:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4425:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
4426:../uvc.c      ****                  		break;
4427:../uvc.c      ****                  	default:
4428:../uvc.c      ****                  		break;
4429:../uvc.c      ****                      }
4430:../uvc.c      ****                     IMcount = 0;
4431:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
4432:../uvc.c      ****                 	stiflag = 0x0;
4433:../uvc.c      ****                 	}
4434:../uvc.c      ****                 }
4435:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
4436:../uvc.c      ****                 /* Reset the DMA channel. */
4437:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
4438:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4439:../uvc.c      ****                 {
4440:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
4441:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4442:../uvc.c      ****                 }
4443:../uvc.c      **** 
4444:../uvc.c      ****                 /* Start Channel Immediately */
4445:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
4446:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4447:../uvc.c      ****                 {
4448:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
4449:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4450:../uvc.c      ****                 }
4451:../uvc.c      **** 
4452:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
4453:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
4454:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
4455:../uvc.c      ****                 }
4456:../uvc.c      ****         }
4457:../uvc.c      ****         else
4458:../uvc.c      ****         {
4459:../uvc.c      ****             /* If we have a stream abort request pending. */
4460:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
4461:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
4462:../uvc.c      ****             {
4463:../uvc.c      ****                 hitFV     = CyFalse;
4464:../uvc.c      ****                 prodCount = 0;
4465:../uvc.c      ****                 consCount = 0;
4466:../uvc.c      ****                 if(0&&(prinflag == 0)){
4467:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
4468:../uvc.c      ****                 	prinflag = 1;
4469:../uvc.c      ****                 }
4470:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
4471:../uvc.c      ****                 fb=0;
4472:../uvc.c      ****                 pb=0;
4473:../uvc.c      ****                 pbc=0;
4474:../uvc.c      **** 
4475:../uvc.c      ****                 if (!clearFeatureRqtReceived)
4476:../uvc.c      ****                 {
4477:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
4478:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
4479:../uvc.c      ****                     {
4480:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
4481:../uvc.c      ****                     }
4482:../uvc.c      **** 
4483:../uvc.c      ****                     /* Flush the Endpoint memory */
4484:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
4485:../uvc.c      ****                 }
4486:../uvc.c      **** 
4487:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
4488:../uvc.c      ****             }
4489:../uvc.c      ****             else
4490:../uvc.c      ****             {
4491:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
4492:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
4493:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
4494:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
4495:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
4496:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
4497:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4498:../uvc.c      ****                 {
4499:../uvc.c      ****                     /* Error handling */
4500:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
4501:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4502:../uvc.c      ****                 }
4503:../uvc.c      **** 
4504:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
4505:../uvc.c      ****                 if (gpif_initialized == CyFalse)
4506:../uvc.c      ****                 {
4507:../uvc.c      **** #if 0
4508:../uvc.c      ****                 	//for start up of the AF Lens
4509:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
4510:../uvc.c      ****                     CyU3PThreadSleep(500);
4511:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
4512:../uvc.c      ****                     CyU3PThreadSleep(500);
4513:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
4514:../uvc.c      ****                    	CyU3PThreadSleep(300);
4515:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
4516:../uvc.c      ****                     CyU3PThreadSleep(500);
4517:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
4518:../uvc.c      ****                     CyU3PThreadSleep(500);
4519:../uvc.c      **** #endif
4520:../uvc.c      **** #if 0
4521:../uvc.c      ****                     switch (setRes)
4522:../uvc.c      ****                     {
4523:../uvc.c      ****                     	case 1: //1944
4524:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4525:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4526:../uvc.c      ****                     		break;
4527:../uvc.c      ****                     	case 2: //1080
4528:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4529:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4530:../uvc.c      ****                     		break;
4531:../uvc.c      ****                     	case 3: //720
4532:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4533:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4534:../uvc.c      ****                     		break;
4535:../uvc.c      ****                     	default:
4536:../uvc.c      ****                     		break;
4537:../uvc.c      ****                     }
4538:../uvc.c      **** #endif
4539:../uvc.c      ****                     CyFxUvcAppGpifInit ();
4540:../uvc.c      **** 
4541:../uvc.c      ****                     gpif_initialized = CyTrue;
4542:../uvc.c      ****                     CyU3PThreadSleep(200);
4543:../uvc.c      ****                     
4544:../uvc.c      ****                 }
4545:../uvc.c      ****                 else
4546:../uvc.c      ****                 {
4547:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
4548:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
4549:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
4550:../uvc.c      ****                 }
4551:../uvc.c      ****             }
4552:../uvc.c      ****         }
4553:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
4554:../uvc.c      **** 
4555:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
4556:../uvc.c      ****         CyU3PThreadRelinquish ();
4557:../uvc.c      ****     }
4558:../uvc.c      **** }
4559:../uvc.c      **** 
4560:../uvc.c      **** /*
4561:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
4562:../uvc.c      ****  */
4563:../uvc.c      **** 
4564:../uvc.c      **** static void
4565:../uvc.c      **** UVCHandleProcessingUnitRqts (
4566:../uvc.c      ****         void)
4567:../uvc.c      **** {
4568:../uvc.c      ****     uint8_t CtrlAdd;
4569:../uvc.c      **** #ifdef DbgInfo
4570:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4571:../uvc.c      **** #endif
4572:../uvc.c      ****     switch (wValue)
4573:../uvc.c      ****     {
4574:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
4575:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
4576:../uvc.c      ****     		ControlHandle(BLCCtlID0);
4577:../uvc.c      ****     		break;
4578:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
4579:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
4580:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
4581:../uvc.c      ****     		break;
4582:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
4583:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
4584:../uvc.c      **** 			ControlHandle(ConsCtlID2);
4585:../uvc.c      **** 			break;
4586:../uvc.c      **** 
4587:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
4588:../uvc.c      **** 
4589:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
4590:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
4591:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
4592:../uvc.c      ****       		break;
4593:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
4594:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
4595:../uvc.c      ****      		ControlHandle(HueCtlID5);
4596:../uvc.c      ****      		break;
4597:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
4598:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
4599:../uvc.c      ****           		ControlHandle(SaturCtlID6);
4600:../uvc.c      ****           		break;
4601:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
4602:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
4603:../uvc.c      ****           		ControlHandle(ShapCtlID7);
4604:../uvc.c      ****           		break;
4605:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
4606:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
4607:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
4608:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
4609:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
4610:../uvc.c      ****     		break;
4611:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
4612:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
4613:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
4614:../uvc.c      ****     		break;
4615:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
4616:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
4617:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
4618:../uvc.c      ****     		break;
4619:../uvc.c      **** 
4620:../uvc.c      ****         default:
4621:../uvc.c      ****             /*
4622:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4623:../uvc.c      ****              * other controls.
4624:../uvc.c      ****              */
4625:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4626:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4627:../uvc.c      ****             break;
4628:../uvc.c      ****     }
4629:../uvc.c      **** }
4630:../uvc.c      **** 
4631:../uvc.c      **** /*
4632:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
4633:../uvc.c      ****  */
4634:../uvc.c      **** static void
4635:../uvc.c      **** UVCHandleCameraTerminalRqts (
4636:../uvc.c      ****         void)
4637:../uvc.c      **** {
4638:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4639:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4640:../uvc.c      ****     uint16_t readCount;
4641:../uvc.c      ****     uint16_t zoomVal;
4642:../uvc.c      ****     int32_t  panVal, tiltVal;
4643:../uvc.c      ****     CyBool_t sendData = CyFalse;
4644:../uvc.c      **** #endif
4645:../uvc.c      ****     uint8_t CtrlAdd;
4646:../uvc.c      **** 
4647:../uvc.c      ****     switch (wValue)
4648:../uvc.c      ****     {
4649:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
4650:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
4651:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
4652:../uvc.c      ****     		break;
4653:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
4654:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
4655:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
4656:../uvc.c      ****     		break;
4657:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
4658:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
4659:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
4660:../uvc.c      **** 			break;
4661:../uvc.c      **** 
4662:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4663:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4664:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4665:../uvc.c      **** 			break;
4666:../uvc.c      **** 
4667:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4668:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4669:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4670:../uvc.c      ****       		break;
4671:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4672:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4673:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4674:../uvc.c      ****      		break;
4675:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4676:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4677:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4678:../uvc.c      ****           		break;
4679:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4680:../uvc.c      ****           		break;
4681:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4682:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4683:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4684:../uvc.c      ****      		break;
4685:../uvc.c      **** 
4686:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4687:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4688:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4689:../uvc.c      ****     		break;
4690:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4691:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4692:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4693:../uvc.c      ****     		break;
4694:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4695:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4696:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4697:../uvc.c      ****     		break;
4698:../uvc.c      **** 
4699:../uvc.c      ****         default:
4700:../uvc.c      ****             /*
4701:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4702:../uvc.c      ****              * other controls.
4703:../uvc.c      ****              */
4704:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4705:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4706:../uvc.c      ****             break;
4707:../uvc.c      ****     }
4708:../uvc.c      **** 
4709:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4710:../uvc.c      ****     switch (wValue)
4711:../uvc.c      ****     {
4712:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4713:../uvc.c      ****             switch (bRequest)
4714:../uvc.c      ****             {
4715:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4716:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4717:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4718:../uvc.c      ****                     break;
4719:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4720:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4721:../uvc.c      ****                     sendData = CyTrue;
4722:../uvc.c      ****                     break;
4723:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4724:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4725:../uvc.c      ****                     sendData = CyTrue;
4726:../uvc.c      ****                     break;
4727:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4728:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4729:../uvc.c      ****                     sendData = CyTrue;
4730:../uvc.c      ****                     break;
4731:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4732:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4733:../uvc.c      ****                     sendData = CyTrue;
4734:../uvc.c      ****                     break;
4735:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4736:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4737:../uvc.c      ****                     sendData = CyTrue;
4738:../uvc.c      ****                     break;
4739:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4740:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4741:../uvc.c      ****                             glEp0Buffer, &readCount);
4742:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4743:../uvc.c      ****                     {
4744:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4745:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4746:../uvc.c      ****                     }
4747:../uvc.c      ****                     break;
4748:../uvc.c      ****                 default:
4749:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4750:../uvc.c      ****                     break;
4751:../uvc.c      ****             }
4752:../uvc.c      **** 
4753:../uvc.c      ****             if (sendData)
4754:../uvc.c      ****             {
4755:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4756:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4757:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4758:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4759:../uvc.c      ****             }
4760:../uvc.c      ****             break;
4761:../uvc.c      **** 
4762:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4763:../uvc.c      ****             switch (bRequest)
4764:../uvc.c      ****             {
4765:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4766:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4767:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4768:../uvc.c      ****                     break;
4769:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4770:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4771:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4772:../uvc.c      ****                     sendData = CyTrue;
4773:../uvc.c      ****                     break;
4774:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4775:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4776:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4777:../uvc.c      ****                     sendData = CyTrue;
4778:../uvc.c      ****                     break;
4779:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4780:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4781:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4782:../uvc.c      ****                     sendData = CyTrue;
4783:../uvc.c      ****                     break;
4784:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4785:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4786:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4787:../uvc.c      ****                     sendData = CyTrue;
4788:../uvc.c      ****                     break;
4789:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4790:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4791:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4792:../uvc.c      ****                     sendData = CyTrue;
4793:../uvc.c      ****                     break;
4794:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4795:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4796:../uvc.c      ****                             glEp0Buffer, &readCount);
4797:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4798:../uvc.c      ****                     {
4799:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4800:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4801:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4802:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4803:../uvc.c      **** 
4804:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4805:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4806:../uvc.c      ****                     }
4807:../uvc.c      ****                     break;
4808:../uvc.c      ****                 default:
4809:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4810:../uvc.c      ****                     break;
4811:../uvc.c      ****             }
4812:../uvc.c      **** 
4813:../uvc.c      ****             if (sendData)
4814:../uvc.c      ****             {
4815:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4816:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4817:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4818:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4819:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4820:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4821:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4822:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4823:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4824:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4825:../uvc.c      ****             }
4826:../uvc.c      ****             break;
4827:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4828:../uvc.c      ****         default:
4829:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4830:../uvc.c      ****             break;
4831:../uvc.c      ****     }
4832:../uvc.c      **** #endif
4833:../uvc.c      **** }
4834:../uvc.c      **** 
4835:../uvc.c      **** /*
4836:../uvc.c      ****  * Handler for UVC Interface control requests.
4837:../uvc.c      ****  */
4838:../uvc.c      **** static void
4839:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4840:../uvc.c      ****         void)
4841:../uvc.c      **** {
4842:../uvc.c      **** 
4843:../uvc.c      ****     switch (wValue)
4844:../uvc.c      ****     {
4845:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4846:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4847:../uvc.c      ****     		break;
4848:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4849:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4850:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4851:../uvc.c      ****     		break;
4852:../uvc.c      ****     	default:
4853:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4854:../uvc.c      ****      		break;
4855:../uvc.c      ****     }
4856:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4857:../uvc.c      **** 
4858:../uvc.c      **** }
4859:../uvc.c      **** 
4860:../uvc.c      **** /*
4861:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4862:../uvc.c      ****  */
4863:../uvc.c      **** static void
4864:../uvc.c      **** UVCHandleExtensionUnitRqts (
4865:../uvc.c      ****         void)
4866:../uvc.c      **** {
4867:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4868:../uvc.c      **** 
4869:../uvc.c      **** #ifdef DbgInfo
4870:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4871:../uvc.c      **** #endif
4872:../uvc.c      ****     switch (wValue)
4873:../uvc.c      ****     {
4874:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4875:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4876:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4877:../uvc.c      ****     		break;
4878:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4879:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4880:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4881:../uvc.c      ****     		break;
4882:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4883:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4884:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4885:../uvc.c      ****      		break;
4886:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4887:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4888:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4889:../uvc.c      ****     		break;
4890:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4891:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4892:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4893:../uvc.c      ****     		break;
4894:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4895:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4896:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4897:../uvc.c      ****      		break;
4898:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4899:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4900:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4901:../uvc.c      ****     		break;
4902:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4903:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4904:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4905:../uvc.c      ****     		break;
4906:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4907:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4908:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4909:../uvc.c      ****      		break;
4910:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4911:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4912:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4913:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4914:../uvc.c      ****     		}else/* no support for 1080p camera */
4915:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4916:../uvc.c      ****     		break;
4917:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4918:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4919:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4920:../uvc.c      ****     		break;
4921:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4922:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4923:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4924:../uvc.c      ****     		break;
4925:../uvc.c      **** 
4926:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4927:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4928:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4929:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4930:../uvc.c      ****     		break;
4931:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4932:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4933:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4934:../uvc.c      ****     		//break;
4935:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4936:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4937:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4938:../uvc.c      ****     		break;
4939:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4940:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4941:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4942:../uvc.c      ****     		break;
4943:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4944:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4945:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4946:../uvc.c      ****     		break;
4947:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4948:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4949:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4950:../uvc.c      ****     		break;
4951:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4952:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4953:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4954:../uvc.c      ****     		break;
4955:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4956:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4957:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4958:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4959:../uvc.c      ****     		break;
4960:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4961:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4962:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4963:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4964:../uvc.c      ****     		break;
4965:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4966:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4967:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4968:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4969:../uvc.c      ****     		break;
4970:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4971:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4972:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4973:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4974:../uvc.c      ****    		break;
4975:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4976:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4977:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4978:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4979:../uvc.c      ****     		break;
4980:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4981:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4982:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4983:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4984:../uvc.c      ****     		break;
4985:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4986:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4987:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4988:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4989:../uvc.c      ****     		break;
4990:../uvc.c      **** 
4991:../uvc.c      ****    	default:
4992:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4993:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4994:../uvc.c      ****     		break;
4995:../uvc.c      ****     }
4996:../uvc.c      **** 
4997:../uvc.c      **** }
4998:../uvc.c      **** 
4999:../uvc.c      **** /*
5000:../uvc.c      ****  * Handler for the video streaming control requests.
5001:../uvc.c      ****  */
5002:../uvc.c      **** static void
5003:../uvc.c      **** UVCHandleVideoStreamingRqts (
5004:../uvc.c      ****         void)
5005:../uvc.c      **** {
  67              		.loc 1 5005 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
5006:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
5007:../uvc.c      ****     uint16_t readCount;
5008:../uvc.c      **** 
5009:../uvc.c      ****     switch (wValue)
  72              		.loc 1 5009 0
  73 003c A8369FE5 		ldr	r3, .L133
5005:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 5005 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 5009 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
5005:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 5005 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 5009 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
5010:../uvc.c      ****     {
5011:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
5012:../uvc.c      ****             switch (bRequest)
5013:../uvc.c      ****             {
5014:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
5015:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
5016:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5017:../uvc.c      ****                     break;
5018:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
5019:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5020:../uvc.c      ****                     glEp0Buffer[1] = 0;
5021:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5022:../uvc.c      ****                     break;
5023:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
5024:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
5025:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
5026:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
5027:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
5028:../uvc.c      ****                     {
5029:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
5030:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
5031:../uvc.c      **** 
5032:../uvc.c      ****                     }
5033:../uvc.c      ****                     else
5034:../uvc.c      ****                     {
5035:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
5036:../uvc.c      ****                     }
5037:../uvc.c      ****                     break;
5038:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
5039:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5040:../uvc.c      ****                             glCommitCtrl, &readCount);
5041:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
5042:../uvc.c      ****                     {
5043:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5044:../uvc.c      ****                         {
5045:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
5046:../uvc.c      ****                                active data structure. */
5047:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
5048:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
5049:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
5050:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
5051:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
5052:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
5053:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
5054:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
5055:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
5056:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
5057:../uvc.c      **** #if 0
5058:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
5059:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
5060:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
5061:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
5062:../uvc.c      **** #endif
5063:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
5064:../uvc.c      ****                        }
5065:../uvc.c      ****                     }
5066:../uvc.c      ****                     break;
5067:../uvc.c      ****                 default:
5068:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5069:../uvc.c      ****                     break;
5070:../uvc.c      ****             }
5071:../uvc.c      ****             break;
5072:../uvc.c      **** 
5073:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
5074:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 5074 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
5075:../uvc.c      ****             {
5076:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
5077:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
5078:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5079:../uvc.c      ****                     break;
5080:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
5081:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5082:../uvc.c      ****                     glEp0Buffer[1] = 0;
5083:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5084:../uvc.c      ****                     break;
5085:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
5086:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
5087:../uvc.c      ****                     {
5088:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
5089:../uvc.c      ****                     }
5090:../uvc.c      ****                     else
5091:../uvc.c      ****                     {
5092:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
5093:../uvc.c      ****                     }
5094:../uvc.c      ****                     break;
5095:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
5096:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
5097:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
5098:../uvc.c      ****                        */
5099:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5100:../uvc.c      ****                             glCommitCtrl, &readCount);
5101:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
5102:../uvc.c      ****                     {
5103:../uvc.c      ****                         switch (glCommitCtrl[3])
5104:../uvc.c      ****                          {
5105:../uvc.c      ****                          	case 1: //1944
5106:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
5107:../uvc.c      ****                          		CyU3PThreadSleep(500);
5108:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
5109:../uvc.c      ****                          		break;
5110:../uvc.c      ****                          	case 2: //1080
5111:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
5112:../uvc.c      ****                          		CyU3PThreadSleep(500);
5113:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
5114:../uvc.c      ****                          		break;
5115:../uvc.c      ****                          	case 3: //720
5116:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
5117:../uvc.c      ****                          		CyU3PThreadSleep(500);
5118:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
5119:../uvc.c      ****                          		break;
5120:../uvc.c      ****                          	case 4: //VGA
5121:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
5122:../uvc.c      ****                          		CyU3PThreadSleep(500);
5123:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
5124:../uvc.c      ****                          		break;
5125:../uvc.c      ****                          	default:
5126:../uvc.c      ****                          		break;
5127:../uvc.c      ****                          }
5128:../uvc.c      ****                         setRes = glCommitCtrl[3];
5129:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
5130:../uvc.c      **** 
5131:../uvc.c      **** #if 0
5132:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
5133:../uvc.c      ****                         {
5134:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
5135:../uvc.c      ****                         }
5136:../uvc.c      ****                         else
5137:../uvc.c      ****                         {
5138:../uvc.c      ****                             SensorScaling_VGA ();
5139:../uvc.c      ****                         }
5140:../uvc.c      **** #endif
5141:../uvc.c      ****                         /* We can start streaming video now. */
5142:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
5143:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
5144:../uvc.c      ****                         {
5145:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
5146:../uvc.c      ****                         }
5147:../uvc.c      ****                     }
5148:../uvc.c      ****                     break;
5149:../uvc.c      **** 
5150:../uvc.c      ****                 default:
5151:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5152:../uvc.c      ****                     break;
5153:../uvc.c      ****             }
5154:../uvc.c      ****             break;
5155:../uvc.c      **** 
5156:../uvc.c      **** /* still image streaming handler */
5157:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
5158:../uvc.c      ****                 switch (bRequest)
5159:../uvc.c      ****                 {
5160:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5161:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
5162:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5163:../uvc.c      ****                         break;
5164:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5165:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5166:../uvc.c      ****                         glEp0Buffer[1] = 0;
5167:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5168:../uvc.c      ****                         break;
5169:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
5170:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
5171:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
5172:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
5173:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5174:../uvc.c      ****                         {
5175:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5176:../uvc.c      ****                         }
5177:../uvc.c      ****                         else
5178:../uvc.c      ****                         {
5179:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5180:../uvc.c      ****                         }
5181:../uvc.c      ****                         break;
5182:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5183:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5184:../uvc.c      ****                                 glCommitCtrl, &readCount);
5185:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5186:../uvc.c      ****                         {
5187:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
5188:../uvc.c      ****                             {
5189:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
5190:../uvc.c      ****                                    active data structure. */
5191:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
5192:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
5193:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
5194:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
5195:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
5196:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
5197:../uvc.c      ****                             }
5198:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
5199:../uvc.c      ****                         }
5200:../uvc.c      ****                         break;
5201:../uvc.c      ****                     default:
5202:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5203:../uvc.c      ****                         break;
5204:../uvc.c      ****                 }
5205:../uvc.c      ****                 break;
5206:../uvc.c      **** 
5207:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
5208:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 5208 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
5209:../uvc.c      ****                 {
5210:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5211:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
5212:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5213:../uvc.c      ****                         break;
5214:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5215:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5216:../uvc.c      ****                         glEp0Buffer[1] = 0;
5217:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5218:../uvc.c      ****                         break;
5219:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
5220:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5221:../uvc.c      ****                         {
5222:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5223:../uvc.c      ****                         }
5224:../uvc.c      ****                         else
5225:../uvc.c      ****                         {
5226:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5227:../uvc.c      ****                         }
5228:../uvc.c      ****                         break;
5229:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5230:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
5231:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
5232:../uvc.c      ****                            */
5233:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5234:../uvc.c      ****                                 glCommitCtrl, &readCount);
5235:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5236:../uvc.c      ****                         {
5237:../uvc.c      ****     #if 0
5238:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
5239:../uvc.c      ****                             {
5240:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
5241:../uvc.c      ****                             }
5242:../uvc.c      ****                             else
5243:../uvc.c      ****                             {
5244:../uvc.c      ****                                 SensorScaling_VGA ();
5245:../uvc.c      ****                             }
5246:../uvc.c      ****                             /* We can start streaming video now. */
5247:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
5248:../uvc.c      **** 
5249:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
5250:../uvc.c      ****                             {
5251:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
5252:../uvc.c      ****                             }
5253:../uvc.c      **** 	#endif
5254:../uvc.c      ****                            switch (glCommitCtrl[1])
5255:../uvc.c      ****                              {
5256:../uvc.c      ****                              	case 4: //1944
5257:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
5258:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5259:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
5260:../uvc.c      ****                              		break;
5261:../uvc.c      ****                              	case 3: //1080
5262:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
5263:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5264:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
5265:../uvc.c      ****                              		break;
5266:../uvc.c      ****                              	case 2: //720
5267:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
5268:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5269:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
5270:../uvc.c      ****                              		break;
5271:../uvc.c      ****                             	case 1: //VGA
5272:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
5273:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5274:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
5275:../uvc.c      ****                              		break;
5276:../uvc.c      ****                               	default:
5277:../uvc.c      ****                              		break;
5278:../uvc.c      ****                              }
5279:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
5280:../uvc.c      **** 
5281:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
5282:../uvc.c      **** 
5283:../uvc.c      ****                         }
5284:../uvc.c      ****                         break;
5285:../uvc.c      **** 
5286:../uvc.c      ****                     default:
5287:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5288:../uvc.c      ****                         break;
5289:../uvc.c      ****                 }
5290:../uvc.c      ****                 break;
5291:../uvc.c      **** 
5292:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
5293:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
5294:../uvc.c      ****             	switch (bRequest)
5295:../uvc.c      ****                 {
5296:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5297:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 5297 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
5298:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 5298 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
5299:../uvc.c      ****                         break;
5300:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5301:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
5302:../uvc.c      ****                         glEp0Buffer[1] = 0;
5303:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5304:../uvc.c      ****                         break;
5305:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
5306:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5307:../uvc.c      ****                         {
5308:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
5309:../uvc.c      ****                         }
5310:../uvc.c      ****                         else
5311:../uvc.c      ****                         {
5312:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
5313:../uvc.c      ****                         }
5314:../uvc.c      ****                         break;
5315:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5316:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
5317:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
5318:../uvc.c      ****                            */
5319:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5320:../uvc.c      ****                                 glCommitCtrl, &readCount);
5321:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5322:../uvc.c      ****                         {
5323:../uvc.c      ****     #if 1
5324:../uvc.c      ****                             /* We can start still streaming video now. */
5325:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
5326:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
5327:../uvc.c      ****                             {
5328:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
5329:../uvc.c      ****                             }
5330:../uvc.c      ****     #endif
5331:../uvc.c      ****                             else{
5332:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
5333:../uvc.c      ****                             //stillcont = 0;
5334:../uvc.c      ****                             }
5335:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
5336:../uvc.c      ****                         }else{
5337:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
5338:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
5339:../uvc.c      ****                         }
5340:../uvc.c      ****                         break;
5341:../uvc.c      **** 
5342:../uvc.c      ****                     default:
5343:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5344:../uvc.c      ****                         break;
5345:../uvc.c      ****                 }
5346:../uvc.c      ****                 break;
5347:../uvc.c      **** 
5348:../uvc.c      ****         default:
5349:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
5350:../uvc.c      ****             break;
5351:../uvc.c      ****     }
5352:../uvc.c      **** }
 117              		.loc 1 5352 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
5009:../uvc.c      ****     {
 122              		.loc 1 5009 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
5294:../uvc.c      ****                 {
 127              		.loc 1 5294 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
5349:../uvc.c      ****             break;
 138              		.loc 1 5349 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 5352 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
5012:../uvc.c      ****             {
 151              		.loc 1 5012 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
5158:../uvc.c      ****                 {
 161              		.loc 1 5158 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
5215:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 5215 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
5302:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 5302 0
 170 0124 0020A0E3 		mov	r2, #0
5303:../uvc.c      ****                         break;
 171              		.loc 1 5303 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
5301:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 5301 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
5302:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 5302 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
5303:../uvc.c      ****                         break;
 178              		.loc 1 5303 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 5352 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
5208:../uvc.c      ****                 {
 186              		.loc 1 5208 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
5233:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 5233 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
5235:../uvc.c      ****                         {
 201              		.loc 1 5235 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
5254:../uvc.c      ****                              {
 204              		.loc 1 5254 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
5158:../uvc.c      ****                 {
 217              		.loc 1 5158 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
5173:../uvc.c      ****                         {
 227              		.loc 1 5173 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
5175:../uvc.c      ****                         }
 229              		.loc 1 5175 0
 230 01c4 0B00A0E3 		mov	r0, #11
5173:../uvc.c      ****                         {
 231              		.loc 1 5173 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
5175:../uvc.c      ****                         }
 234              		.loc 1 5175 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
5179:../uvc.c      ****                         }
 236              		.loc 1 5179 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
5158:../uvc.c      ****                 {
 242              		.loc 1 5158 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
5183:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 5183 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
5185:../uvc.c      ****                         {
 254              		.loc 1 5185 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
5187:../uvc.c      ****                             {
 257              		.loc 1 5187 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
5191:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 5191 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
5192:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 5192 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
5191:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 5191 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
5192:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 5192 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
5198:../uvc.c      ****                         }
 272              		.loc 1 5198 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
5012:../uvc.c      ****             {
 283              		.loc 1 5012 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
5039:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 5039 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
5041:../uvc.c      ****                     {
 295              		.loc 1 5041 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
5043:../uvc.c      ****                         {
 298              		.loc 1 5043 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
5047:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 5047 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
5048:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 5048 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
5049:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 5049 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
5050:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 5050 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
5051:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 5051 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
5052:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 5052 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
5047:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 5047 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
5048:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 5048 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
5049:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 5049 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
5050:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 5050 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
5051:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 5051 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
5052:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 5052 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
5086:../uvc.c      ****                     {
 331              		.loc 1 5086 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
5035:../uvc.c      ****                     }
 337              		.loc 1 5035 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
5294:../uvc.c      ****                 {
 344              		.loc 1 5294 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
5319:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 5319 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
5321:../uvc.c      ****                         {
 354              		.loc 1 5321 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
5325:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 5325 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
5326:../uvc.c      ****                             {
 363              		.loc 1 5326 0
 364 030c 002050E2 		subs	r2, r0, #0
5332:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 5332 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
5326:../uvc.c      ****                             {
 368              		.loc 1 5326 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
5335:../uvc.c      ****                         }else{
 372              		.loc 1 5335 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
5074:../uvc.c      ****             {
 384              		.loc 1 5074 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
5099:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 5099 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
5101:../uvc.c      ****                     {
 394              		.loc 1 5101 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
5103:../uvc.c      ****                          {
 397              		.loc 1 5103 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
5088:../uvc.c      ****                     }
 410              		.loc 1 5088 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
5121:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 5121 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 F420A003 		moveq	r2, #244
 424 03a8 7420A013 		movne	r2, #116
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
5122:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 5122 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
5123:../uvc.c      ****                          		break;
 436              		.loc 1 5123 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 F410A003 		moveq	r1, #244
 442 03dc 7410A013 		movne	r1, #116
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
5129:../uvc.c      **** 
 451              		.loc 1 5129 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
5128:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 5128 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
5129:../uvc.c      **** 
 457              		.loc 1 5129 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
5142:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 5142 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
5143:../uvc.c      ****                         {
 466              		.loc 1 5143 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
5145:../uvc.c      ****                         }
 469              		.loc 1 5145 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
5262:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 5262 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c D420A003 		moveq	r2, #212
 483 0440 5420A013 		movne	r2, #84
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
5264:../uvc.c      ****                              		break;
 489              		.loc 1 5264 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 D420A003 		moveq	r2, #212
 495 0464 5420A013 		movne	r2, #84
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
5281:../uvc.c      **** 
 501              		.loc 1 5281 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
5279:../uvc.c      **** 
 506              		.loc 1 5279 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
5281:../uvc.c      **** 
 508              		.loc 1 5281 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
5267:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 5267 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 C420A003 		moveq	r2, #196
 521 04a8 4420A013 		movne	r2, #68
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
5269:../uvc.c      ****                              		break;
 529              		.loc 1 5269 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 C410A003 		moveq	r1, #196
 535 04d4 4410A013 		movne	r1, #68
 536              	.L118:
5274:../uvc.c      ****                              		break;
 537              		.loc 1 5274 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
5275:../uvc.c      ****                               	default:
 544              		.loc 1 5275 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
5272:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 5272 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
5274:../uvc.c      ****                              		break;
 562              		.loc 1 5274 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
5116:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 5116 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 C420A003 		moveq	r2, #196
 578 054c 4420A013 		movne	r2, #68
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
5117:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 5117 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
5118:../uvc.c      ****                          		break;
 590              		.loc 1 5118 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c C410A003 		moveq	r1, #196
 596 0580 4410A013 		movne	r1, #68
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
5111:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 5111 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 D420A003 		moveq	r2, #212
 605 0598 5420A013 		movne	r2, #84
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
5112:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 5112 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
5113:../uvc.c      ****                          		break;
 615              		.loc 1 5113 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 D420A003 		moveq	r2, #212
 621 05c4 5420A013 		movne	r2, #84
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
5114:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 5114 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
5106:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 5106 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 E420A003 		moveq	r2, #228
 635 05e8 6420A013 		movne	r2, #100
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
5107:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 5107 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
5108:../uvc.c      ****                          		break;
 645              		.loc 1 5108 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 E420A003 		moveq	r2, #228
 651 0614 6420A013 		movne	r2, #100
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
5109:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 5109 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
5257:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 5257 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 E420A003 		moveq	r2, #228
 665 0638 6420A013 		movne	r2, #100
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
5259:../uvc.c      ****                              		break;
 671              		.loc 1 5259 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 E420A003 		moveq	r2, #228
 677 065c 6420A013 		movne	r2, #100
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
5260:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 5260 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
5301:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 5301 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
5027:../uvc.c      ****                     {
 691              		.loc 1 5027 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
5029:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 5029 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
5030:../uvc.c      **** 
 701              		.loc 1 5030 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
5337:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 5337 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
5338:../uvc.c      ****                         }
 718              		.loc 1 5338 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
5328:../uvc.c      ****                             }
 727              		.loc 1 5328 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
5103:../uvc.c      ****                          {
 736              		.loc 1 5103 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
5353:../uvc.c      **** 
5354:../uvc.c      **** /*
5355:../uvc.c      ****  * Entry function for the UVC control request processing thread.
5356:../uvc.c      ****  */
5357:../uvc.c      **** void
5358:../uvc.c      **** UVCAppEP0Thread_Entry (
5359:../uvc.c      ****         uint32_t input)
5360:../uvc.c      **** {
5361:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
5362:../uvc.c      ****     uint32_t eventFlag;
5363:../uvc.c      **** 	CyBool_t value;
5364:../uvc.c      **** 	CyBool_t *valueptr = &value;
5365:../uvc.c      **** 
5366:../uvc.c      **** 
5367:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
5368:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5369:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
5370:../uvc.c      **** 
5371:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
5372:../uvc.c      **** #endif
5373:../uvc.c      **** 
5374:../uvc.c      ****     /* for interrupt status test */
5375:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5376:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
5377:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
5378:../uvc.c      **** 
5379:../uvc.c      ****     for (;;)
5380:../uvc.c      ****     {
5381:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
5382:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
5383:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
5384:../uvc.c      ****         {
5385:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
5386:../uvc.c      ****             if (!isUsbConnected)
5387:../uvc.c      ****             {
5388:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
5389:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
5390:../uvc.c      ****                 {
5391:../uvc.c      ****                     isUsbConnected = CyTrue;
5392:../uvc.c      ****                 }
5393:../uvc.c      ****             }
5394:../uvc.c      **** //#ifdef DbgInfo
5395:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
5396:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
5397:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
5398:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
5399:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
5400:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
5401:../uvc.c      **** //#endif
5402:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
5403:../uvc.c      ****             {
5404:../uvc.c      ****             	switch ((wIndex >> 8))
5405:../uvc.c      ****                 {
5406:../uvc.c      **** 
5407:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
5408:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
5409:../uvc.c      ****                         break;
5410:../uvc.c      **** 
5411:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
5412:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
5413:../uvc.c      ****                         break;
5414:../uvc.c      **** 
5415:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
5416:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
5417:../uvc.c      ****                         break;
5418:../uvc.c      **** 
5419:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
5420:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
5421:../uvc.c      ****                         break;
5422:../uvc.c      **** 
5423:../uvc.c      ****                     default:
5424:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
5425:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5426:../uvc.c      ****                         break;
5427:../uvc.c      ****                 }
5428:../uvc.c      ****             }
5429:../uvc.c      **** 
5430:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
5431:../uvc.c      ****             {
5432:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
5433:../uvc.c      **** 
5434:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
5435:../uvc.c      ****                 {
5436:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5437:../uvc.c      ****                 }
5438:../uvc.c      ****                 else
5439:../uvc.c      ****                 {
5440:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
5441:../uvc.c      ****                 }
5442:../uvc.c      ****             }
5443:../uvc.c      **** 
5444:../uvc.c      ****             /* handle interrupt status event */
5445:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
5446:../uvc.c      ****             {
5447:../uvc.c      **** 
5448:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
5449:../uvc.c      ****             	/** preparing interrupt status data **/
5450:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
5451:../uvc.c      **** 
5452:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5453:../uvc.c      **** 
5454:../uvc.c      **** #if 0 //for real button
5455:../uvc.c      **** 				if(value&&(!snapButFlag)){
5456:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5457:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5458:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5459:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5460:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
5461:../uvc.c      **** 
5462:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5463:../uvc.c      **** 					interStabuf.size   = 1024;
5464:../uvc.c      **** 					interStabuf.status = 0;
5465:../uvc.c      **** 
5466:../uvc.c      **** 					interStabuf.count = 4;
5467:../uvc.c      **** 
5468:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5469:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5470:../uvc.c      **** 
5471:../uvc.c      **** 					/** send a interrupt status data **/
5472:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5473:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5474:../uvc.c      **** 					{
5475:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5476:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5477:../uvc.c      **** 					}
5478:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
5479:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
5480:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5481:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5482:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5483:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5484:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
5485:../uvc.c      **** 
5486:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5487:../uvc.c      **** 					interStabuf.size   = 1024;
5488:../uvc.c      **** 					interStabuf.status = 0;
5489:../uvc.c      **** 
5490:../uvc.c      **** 					interStabuf.count = 4;
5491:../uvc.c      **** 
5492:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5493:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5494:../uvc.c      **** 
5495:../uvc.c      **** 					/** send a interrupt status data **/
5496:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5497:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5498:../uvc.c      **** 					{
5499:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5500:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5501:../uvc.c      **** 					}
5502:../uvc.c      **** 
5503:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
5504:../uvc.c      **** 					stiflag = 0xFF;
5505:../uvc.c      **** 				}
5506:../uvc.c      **** #else			//for botton simulation
5507:../uvc.c      **** 				if(snapButFlag == 0x0f){
5508:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5509:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5510:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5511:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5512:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
5513:../uvc.c      **** 
5514:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5515:../uvc.c      **** 					interStabuf.size   = 1024;
5516:../uvc.c      **** 					interStabuf.status = 0;
5517:../uvc.c      **** 
5518:../uvc.c      **** 					interStabuf.count = 4;
5519:../uvc.c      **** 
5520:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5521:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5522:../uvc.c      **** 
5523:../uvc.c      **** 					/** send a interrupt status data **/
5524:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5525:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
5526:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5527:../uvc.c      **** 					{
5528:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5529:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5530:../uvc.c      **** 					}
5531:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
5532:../uvc.c      **** 
5533:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
5534:../uvc.c      **** 				}else if(!snapButFlag){
5535:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5536:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5537:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5538:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5539:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
5540:../uvc.c      **** 
5541:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5542:../uvc.c      **** 					interStabuf.size   = 1024;
5543:../uvc.c      **** 					interStabuf.status = 0;
5544:../uvc.c      **** 
5545:../uvc.c      **** 					interStabuf.count = 4;
5546:../uvc.c      **** 
5547:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5548:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5549:../uvc.c      **** 
5550:../uvc.c      **** 					/** send a interrupt status data **/
5551:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5552:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
5553:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5554:../uvc.c      **** 					{
5555:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5556:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5557:../uvc.c      **** 					}
5558:../uvc.c      **** 
5559:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
5560:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
5561:../uvc.c      **** 				}
5562:../uvc.c      **** #endif
5563:../uvc.c      **** 
5564:../uvc.c      ****             }
5565:../uvc.c      **** 
5566:../uvc.c      **** 
5567:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
5568:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
5569:../uvc.c      ****             {
5570:../uvc.c      ****                 /* Get the command buffer */
5571:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
5572:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5573:../uvc.c      ****                 {
5574:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
5575:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5576:../uvc.c      ****                 }
5577:../uvc.c      **** 
5578:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
5579:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
5580:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
5581:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
5582:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
5583:../uvc.c      ****                  * register value high byte and register value low byte.
5584:../uvc.c      ****                  */
5585:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
5586:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
5587:../uvc.c      ****                 {
5588:../uvc.c      ****                     if (dmaInfo.count == 3)
5589:../uvc.c      ****                     {
5590:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
5591:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
5592:../uvc.c      ****                         dmaInfo.count = 3;
5593:../uvc.c      ****                     }
5594:../uvc.c      ****                     else if (dmaInfo.count == 4)
5595:../uvc.c      ****                     {
5596:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
5597:../uvc.c      ****                         {
5598:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
5599:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
5600:../uvc.c      ****                         }
5601:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
5602:../uvc.c      ****                     }
5603:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
5604:../uvc.c      ****                 }
5605:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
5606:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
5607:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
5608:../uvc.c      ****                  */
5609:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
5610:../uvc.c      ****                 {
5611:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
5612:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
5613:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
5614:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
5615:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
5616:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
5617:../uvc.c      ****                         	break;
5618:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
5619:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
5620:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
5621:../uvc.c      ****                         	break;*/
5622:../uvc.c      ****                     dmaInfo.count -= 2;
5623:../uvc.c      ****                 }
5624:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
5625:../uvc.c      ****                 else
5626:../uvc.c      ****                 {
5627:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
5628:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
5629:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
5630:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
5631:../uvc.c      ****                 }
5632:../uvc.c      **** 
5633:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
5634:../uvc.c      ****                 dmaInfo.size   = 1024;
5635:../uvc.c      ****                 dmaInfo.status = 0;
5636:../uvc.c      **** 
5637:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
5638:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
5639:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5640:../uvc.c      ****                 {
5641:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
5642:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5643:../uvc.c      ****                 }
5644:../uvc.c      **** 
5645:../uvc.c      ****                 /* Wait until the response has gone out. */
5646:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
5647:../uvc.c      **** 
5648:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
5649:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5650:../uvc.c      ****                 {
5651:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
5652:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5653:../uvc.c      ****                 }
5654:../uvc.c      ****             }
5655:../uvc.c      **** #endif
5656:../uvc.c      ****         }
5657:../uvc.c      ****         /* Allow other ready threads to run. */
5658:../uvc.c      ****         CyU3PThreadRelinquish ();
5659:../uvc.c      ****     }
5660:../uvc.c      **** }
5661:../uvc.c      **** 
5662:../uvc.c      **** /*
5663:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5664:../uvc.c      ****  * added 10/2013
5665:../uvc.c      ****  */
5666:../uvc.c      **** /*
5667:../uvc.c      **** static uint8_t timeDelay[64] = {
5668:../uvc.c      **** 
5669:../uvc.c      **** };
5670:../uvc.c      **** */
5671:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5671 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5672:../uvc.c      **** 
5673:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5674:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5675:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5676:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5677:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5678:../uvc.c      **** 	uint32_t flag = 0;
5679:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5680:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5681:../uvc.c      **** 	uint8_t i;
5682:../uvc.c      **** 	uint16_t delaytime;
5683:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5684:../uvc.c      **** 
5685:../uvc.c      **** #if 0 //for test the command queue
5686:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5687:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5688:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5689:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5690:../uvc.c      **** 		lcCmdDes += 1;
5691:../uvc.c      **** 	}
5692:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5693:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5694:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5695:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5696:../uvc.c      **** 		lcCmdDes += 1;
5697:../uvc.c      **** 	}
5698:../uvc.c      **** 
5699:../uvc.c      **** #endif
5700:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5701:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5701 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5671:../uvc.c      **** 
 786              		.loc 1 5671 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5678:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5678 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5701 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5678:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5678 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5701 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5702:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5702 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5703:../uvc.c      **** 	CyU3PThreadSleep(50);
5704:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5705:../uvc.c      **** 
5706:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5706 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5702:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5702 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5703:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5703 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5704:../uvc.c      **** 
 823              		.loc 1 5704 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5706 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5707:../uvc.c      ****         /* Allow other ready threads to run. */
5708:../uvc.c      **** 
5709:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5709 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5706:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5706 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5710:../uvc.c      **** 	}
5711:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5711 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5712:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5713:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5714:../uvc.c      **** 	//CyU3PThreadSleep(100);
5715:../uvc.c      **** 	//SetCurCmd();
5716:../uvc.c      **** 	/*********** the loop of the thread ***********/
5717:../uvc.c      **** 	for(;;){
5718:../uvc.c      **** 
5719:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5719 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5720:../uvc.c      **** /*  // for test GPIO output
5721:../uvc.c      **** 		if(trigger)
5722:../uvc.c      **** 		{
5723:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5724:../uvc.c      **** 			{
5725:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5726:../uvc.c      **** 			}
5727:../uvc.c      **** 
5728:../uvc.c      **** 		}else{
5729:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5730:../uvc.c      **** 			{
5731:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5732:../uvc.c      **** 			}
5733:../uvc.c      **** 
5734:../uvc.c      **** 		}
5735:../uvc.c      **** */
5736:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5736 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5737:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5738:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5739:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5740:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5741:../uvc.c      **** 				i = 0;
5742:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5742 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5743:../uvc.c      **** 					i++;
5744:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5745:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5746:../uvc.c      **** 				}
5747:../uvc.c      **** #if 0
5748:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5749:../uvc.c      **** 				i = lcStaDes->curNum;
5750:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5751:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5752:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5753:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5754:../uvc.c      **** 
5755:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5756:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5757:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5758:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5759:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5760:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5761:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5762:../uvc.c      **** #endif
5763:../uvc.c      **** 				//}
5764:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5765:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5766:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5767:../uvc.c      **** 				/* setting delay */
5768:../uvc.c      **** 				delaytime = 300;
5769:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5770:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5771:../uvc.c      **** 			} //end of the if condition statment
5772:../uvc.c      **** #endif
5773:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5773 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5774:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5775:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5775 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5776:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5776 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5777:../uvc.c      **** 
5778:../uvc.c      **** 				/*
5779:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5780:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5781:../uvc.c      **** 				*/
5782:../uvc.c      **** 
5783:../uvc.c      **** 				/* find a available command */
5784:../uvc.c      **** 				i = 0;
5785:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5785 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5785 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5786:../uvc.c      **** 					i++;
5787:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5787 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5785:../uvc.c      **** 					i++;
 905              		.loc 1 5785 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5788:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5789:../uvc.c      **** 				}
5790:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5791:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5792:../uvc.c      **** 					i = lcCmdDes->curNum;
5793:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5794:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5795:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5796:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5797:../uvc.c      **** #if 1
5798:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5798 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5793:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5793 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5794:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5794 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5795:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5795 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5796:../uvc.c      **** #if 1
 927              		.loc 1 5796 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5798 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5799:../uvc.c      **** 						case 0x20:
5800:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5801:../uvc.c      **** 							delaytime = 500;
5802:../uvc.c      **** 							break;
5803:../uvc.c      **** 						case 0x21:
5804:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5805:../uvc.c      **** 							delaytime = 500;
5806:../uvc.c      **** 							break;
5807:../uvc.c      **** 						case 0x22:
5808:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5809:../uvc.c      **** 							delaytime = 300;
5810:../uvc.c      **** 							break;
5811:../uvc.c      **** 						case 0x23:
5812:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5812 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5813:../uvc.c      **** 							delaytime = 300;
5814:../uvc.c      **** 							break;
 945              		.loc 1 5814 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5815:../uvc.c      **** 						default:
5816:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5817:../uvc.c      **** 							break;
5818:../uvc.c      **** 					}
5819:../uvc.c      **** #endif
5820:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5821:../uvc.c      **** 					/** timer's ticket modify **/
5822:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5823:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5823 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5824:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5824 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5825:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5826:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5827:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5828:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5829:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5830:../uvc.c      **** #endif
5831:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5831 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5832:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5833:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5834:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5835:../uvc.c      **** 						}else{
5836:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5837:../uvc.c      **** 						}
5838:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5839:../uvc.c      **** 					}else{
5840:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5840 0
 964 08d4 013083E2 		add	r3, r3, #1
5841:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5841 0
 966 08d8 0F20A0E3 		mov	r2, #15
5840:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5840 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5841 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5842:../uvc.c      **** 					}
5843:../uvc.c      **** 				}else{
5844:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5845:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5846:../uvc.c      **** 				}
5847:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5847 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5848:../uvc.c      **** 			}
5849:../uvc.c      **** /*
5850:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5851:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5852:../uvc.c      **** */
5853:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5854:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5855:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5856:../uvc.c      **** #endif
5857:../uvc.c      **** 
5858:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5859:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5860:../uvc.c      **** #if 0
5861:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5862:../uvc.c      **** 
5863:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5864:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5865:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5866:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5867:../uvc.c      **** 			    i = 0;
5868:../uvc.c      **** 				 switch(cmdCopyIdx)
5869:../uvc.c      **** 				 {
5870:../uvc.c      **** 					 case BrgtCtlID1:
5871:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5872:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5873:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5874:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5875:../uvc.c      **** 							 i++;
5876:../uvc.c      **** 						 }
5877:../uvc.c      **** 						 else{
5878:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5879:../uvc.c      **** 						 }
5880:../uvc.c      **** 
5881:../uvc.c      **** 						 CyU3PBusyWait(500);
5882:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5883:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5884:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5885:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5886:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5887:../uvc.c      **** 						 }
5888:../uvc.c      **** 						 else{
5889:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5890:../uvc.c      **** 						 }
5891:../uvc.c      **** 						 break;
5892:../uvc.c      **** 					 case HueCtlID5:
5893:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5894:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5895:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5896:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5897:../uvc.c      **** 						 }
5898:../uvc.c      **** 						 else{
5899:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5900:../uvc.c      **** 						 }
5901:../uvc.c      **** 						 break;
5902:../uvc.c      **** 					 case SaturCtlID6:
5903:../uvc.c      **** 					 case WBTLevCtlID10:
5904:../uvc.c      **** 					 default:
5905:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5906:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5907:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5909:../uvc.c      **** 						 }
5910:../uvc.c      **** 						 else{
5911:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5912:../uvc.c      **** 						 }
5913:../uvc.c      **** 						 break;
5914:../uvc.c      **** 				 }
5915:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5916:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5917:../uvc.c      **** 			}
5918:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5919:../uvc.c      **** #endif
5920:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5921:../uvc.c      **** 		/* Allow other ready threads to run. */
5922:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5923:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5923 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5924:../uvc.c      **** 		}
 980              		.loc 1 5924 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5804:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5804 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5806:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5806 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5800:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5800 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5802:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5802 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5844:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5844 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5845:../uvc.c      **** 				}
 1010              		.loc 1 5845 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5833:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5833 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5832:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5832 0
 1020 0934 0020A0E3 		mov	r2, #0
5833:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5833 0
 1022 0938 230053E3 		cmp	r3, #35
5834:../uvc.c      **** 						}else{
 1023              		.loc 1 5834 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5836:../uvc.c      **** 						}
 1026              		.loc 1 5836 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5834:../uvc.c      **** 						}else{
 1028              		.loc 1 5834 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5836:../uvc.c      **** 						}
 1030              		.loc 1 5836 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5834:../uvc.c      **** 						}else{
 1032              		.loc 1 5834 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5836:../uvc.c      **** 						}
 1034              		.loc 1 5836 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5838:../uvc.c      **** 					}else{
 1036              		.loc 1 5838 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5832:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5832 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5838:../uvc.c      **** 					}else{
 1040              		.loc 1 5838 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5816:../uvc.c      **** 							break;
 1045              		.loc 1 5816 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5817:../uvc.c      **** 					}
 1049              		.loc 1 5817 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
3507:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 3507 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
3514:../uvc.c      ****     {
 1075              		.loc 1 3514 0
 1076 0994 080051E3 		cmp	r1, #8
3507:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 3507 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
3514:../uvc.c      ****     {
 1089              		.loc 1 3514 0
 1090 09a4 0B00000A 		beq	.L174
3566:../uvc.c      ****     {
 1091              		.loc 1 3566 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
3568:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 3568 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
3569:../uvc.c      ****     }
 1096              		.loc 1 3569 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
3568:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 3568 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
3569:../uvc.c      ****     }
 1102              		.loc 1 3569 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
3568:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 3568 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
3571:../uvc.c      **** 
 1111              		.loc 1 3571 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
3516:../uvc.c      ****             {
 1117              		.loc 1 3516 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
3530:../uvc.c      ****                 fb++;
 1121              		.loc 1 3530 0
 1122 09e0 006095E5 		ldr	r6, [r5]
3516:../uvc.c      ****             {
 1123              		.loc 1 3516 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
3254:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 3254 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
3516:../uvc.c      ****             {
 1132              		.loc 1 3516 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
3254:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 3254 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
3255:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 3255 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
3256:../uvc.c      **** 
 1147              		.loc 1 3256 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
3261:../uvc.c      ****     }
 1151              		.loc 1 3261 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
3537:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 3537 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
3261:../uvc.c      ****     }
 1159              		.loc 1 3261 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
3543:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 3543 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
3537:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 3537 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
3538:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 3538 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
3537:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 3537 0
 1171 0a2c 012082E2 		add	r2, r2, #1
3543:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 3543 0
 1173 0a30 0F0051E3 		cmp	r1, #15
3537:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 3537 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
3538:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 3538 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
3255:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 3255 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
3543:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 3543 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
3550:../uvc.c      ****             }
 1187              		.loc 1 3550 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 3554 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
3555:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 3555 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 3554 0
 1196 0a54 013082E2 		add	r3, r2, #1
3555:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 3555 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 3554 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
3555:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 3555 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 3554 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
3555:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 3555 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 3554 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
3555:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 3555 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
3554:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 3554 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
3558:../uvc.c      ****             {
 1215              		.loc 1 3558 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
3560:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 3560 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
3561:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 3561 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
3560:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 3560 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
3561:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 3561 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
3254:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 3254 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
3531:../uvc.c      ****             }
 1246              		.loc 1 3531 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
3254:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 3254 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
3530:../uvc.c      ****                 fb++;
 1255              		.loc 1 3530 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
3255:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 3255 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
3256:../uvc.c      **** 
 1266              		.loc 1 3256 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
3531:../uvc.c      ****             }
 1272              		.loc 1 3531 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
3544:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 3544 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
3545:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 3545 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
3546:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 3546 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
3545:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 3545 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
3546:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 3546 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
3547:../uvc.c      ****                 }
 1295              		.loc 1 3547 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
3310:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 3310 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
3311:../uvc.c      ****     {
 1322              		.loc 1 3311 0
 1323 0b40 020050E3 		cmp	r0, #2
3310:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 3310 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
3311:../uvc.c      ****     {
 1336              		.loc 1 3311 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
3347:../uvc.c      **** 
 1344              		.loc 1 3347 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
3330:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 3330 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
3332:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 3332 0
 1356 0b74 40519FE5 		ldr	r5, .L188
3330:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 3330 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
3331:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 3331 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
3332:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 3332 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
3294:../uvc.c      **** 	{
 1372              		.loc 1 3294 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
3332:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 3332 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
3333:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 3333 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
3334:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 3334 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
3294:../uvc.c      **** 	{
 1388              		.loc 1 3294 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
3297:../uvc.c      **** 
 1395              		.loc 1 3297 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
3300:../uvc.c      **** 	}
 1401              		.loc 1 3300 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
3314:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 3314 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
3316:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 3316 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
3315:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 3315 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
3316:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 3316 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
3294:../uvc.c      **** 	{
 1433              		.loc 1 3294 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
3316:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 3316 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
3317:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 3317 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
3294:../uvc.c      **** 	{
 1447              		.loc 1 3294 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
3297:../uvc.c      **** 
 1454              		.loc 1 3297 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
3300:../uvc.c      **** 	}
 1460              		.loc 1 3300 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
3322:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 3322 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
3324:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 3324 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
3322:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 3322 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
3323:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 3323 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
3324:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 3324 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
3294:../uvc.c      **** 	{
 1493              		.loc 1 3294 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
3324:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 3324 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
3325:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 3325 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
3294:../uvc.c      **** 	{
 1507              		.loc 1 3294 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
3297:../uvc.c      **** 
 1514              		.loc 1 3297 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
3300:../uvc.c      **** 	}
 1520              		.loc 1 3300 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
3355:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 3355 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
3364:../uvc.c      **** 
 1560              		.loc 1 3364 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
3361:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 3361 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
3363:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 3363 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
3360:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 3360 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
3362:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 3362 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
3363:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 3363 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
3360:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 3360 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
3361:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 3361 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
3363:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 3363 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
3364:../uvc.c      **** 
 1579              		.loc 1 3364 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
3362:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 3362 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
3367:../uvc.c      ****     {
 1584              		.loc 1 3367 0
 1585 0d00 020054E3 		cmp	r4, #2
3355:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 3355 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
3361:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 3361 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
3363:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 3363 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
3364:../uvc.c      **** 
 1594              		.loc 1 3364 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
3360:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 3360 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
3362:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 3362 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
3367:../uvc.c      ****     {
 1600              		.loc 1 3367 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
3356:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 3356 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
3494:../uvc.c      **** 
 1612              		.loc 1 3494 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
3367:../uvc.c      ****     {
 1618              		.loc 1 3367 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
3407:../uvc.c      ****             {
 1621              		.loc 1 3407 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
3411:../uvc.c      ****                 {
 1624              		.loc 1 3411 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
3411:../uvc.c      ****                 {
 1627              		.loc 1 3411 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
3416:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 3416 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
3414:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 3414 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
3415:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 3415 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
3419:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 3419 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
3416:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 3416 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
3417:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 3417 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
3419:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 3419 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
3420:../uvc.c      **** 
 1652              		.loc 1 3420 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
3423:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 3423 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
3424:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 3424 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
3425:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 3425 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
3426:../uvc.c      **** 
 1669              		.loc 1 3426 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
3429:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 3429 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
3432:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 3432 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
3294:../uvc.c      **** 	{
 1684              		.loc 1 3294 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
3434:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 3434 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
3294:../uvc.c      **** 	{
 1696              		.loc 1 3294 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
3297:../uvc.c      **** 
 1703              		.loc 1 3297 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
3300:../uvc.c      **** 	}
 1709              		.loc 1 3300 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
3372:../uvc.c      ****             {
 1722              		.loc 1 3372 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
3390:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 3390 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
3392:../uvc.c      ****                         {
 1736              		.loc 1 3392 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
3376:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 3376 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
3494:../uvc.c      **** 
 1744              		.loc 1 3494 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
3442:../uvc.c      ****             {
 1750              		.loc 1 3442 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
3444:../uvc.c      ****                 {
 1753              		.loc 1 3444 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
3450:../uvc.c      ****                     {
 1756              		.loc 1 3450 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
3482:../uvc.c      ****                     }
 1762              		.loc 1 3482 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
3481:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 3481 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
3377:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 3377 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
3379:../uvc.c      ****                         {
 1777              		.loc 1 3379 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
3381:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 3381 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
3382:../uvc.c      ****                         }
 1786              		.loc 1 3382 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
3395:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 3395 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
3396:../uvc.c      ****                         }
 1801              		.loc 1 3396 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
3389:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 3389 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
3452:../uvc.c      **** 
 1812              		.loc 1 3452 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
3455:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 3455 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
3456:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 3456 0
 1823 0ee8 0050A0E3 		mov	r5, #0
3460:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 3460 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
3456:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 3456 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
3457:../uvc.c      **** 
 1829              		.loc 1 3457 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
3460:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 3460 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
3461:../uvc.c      **** 
 1834              		.loc 1 3461 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
3464:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 3464 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
3465:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 3465 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
3466:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 3466 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
3467:../uvc.c      **** 
 1851              		.loc 1 3467 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
3470:../uvc.c      **** 
 1855              		.loc 1 3470 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
3474:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 3474 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
3294:../uvc.c      **** 	{
 1866              		.loc 1 3294 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
3476:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 3476 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
3294:../uvc.c      **** 	{
 1878              		.loc 1 3294 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
3297:../uvc.c      **** 
 1885              		.loc 1 3297 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
3300:../uvc.c      **** 	}
 1891              		.loc 1 3300 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1163:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1163 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1166:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1166 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1163:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1163 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1171:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1171 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1166:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1166 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1167:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1167 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1168:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1168 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1171:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1171 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1174:../uvc.c      **** 	{
 1980              		.loc 1 1174 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1184:../uvc.c      **** 	{
 1985              		.loc 1 1184 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1209:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1209 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1228:../uvc.c      **** 
 1993              		.loc 1 1228 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1211:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1211 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1216:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1216 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1216:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1216 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1221:../uvc.c      **** 			}
 2018              		.loc 1 1221 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1228:../uvc.c      **** 
 2025              		.loc 1 1228 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1200:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1200 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1186:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1186 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1200:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1200 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1186:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1186 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1200:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1200 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1201:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1201 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1202:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1202 0
 2051 10c4 020056E3 		cmp	r6, #2
1201:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1201 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1203:../uvc.c      **** 				}
 2054              		.loc 1 1203 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1186:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1186 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1203:../uvc.c      **** 				}
 2058              		.loc 1 1203 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1205:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1205 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1228:../uvc.c      **** 
 2063              		.loc 1 1228 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1174:../uvc.c      **** 	{
 2069              		.loc 1 1174 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1176:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1176 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1177:../uvc.c      **** 			{
 2081              		.loc 1 1177 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1181:../uvc.c      **** 
 2083              		.loc 1 1181 0
 2084 1114 0400A0E3 		mov	r0, #4
1177:../uvc.c      **** 			{
 2085              		.loc 1 1177 0
 2086 1118 000051E3 		cmp	r1, #0
1179:../uvc.c      **** 			}
 2087              		.loc 1 1179 0
 2088 111c 80208203 		orreq	r2, r2, #128
1181:../uvc.c      **** 
 2089              		.loc 1 1181 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1179:../uvc.c      **** 			}
 2092              		.loc 1 1179 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1181:../uvc.c      **** 
 2094              		.loc 1 1181 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1211:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1211 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1213:../uvc.c      **** 			}
 2103              		.loc 1 1213 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1212:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1212 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1216:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1216 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1217:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1217 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1218:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1218 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1219:../uvc.c      **** 				}
 2142              		.loc 1 1219 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1234:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1234 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1234:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1234 0
 2180 11d8 0040A0E1 		mov	r4, r0
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1237 0
 2182 11dc 0060A0E3 		mov	r6, #0
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1236 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1237 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1238:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1238 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1239:../uvc.c      **** }
 2213              		.loc 1 1239 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1240:../uvc.c      **** 
 2215              		.loc 1 1240 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1239:../uvc.c      **** }
 2220              		.loc 1 1239 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1244:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1244 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1249:../uvc.c      **** 	case 1:
 2236              		.loc 1 1249 0
 2237 1248 013040E2 		sub	r3, r0, #1
1244:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1244 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1249:../uvc.c      **** 	case 1:
 2249              		.loc 1 1249 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1271:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1271 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1273:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1273 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1274:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1274 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1273:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1273 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1274:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1274 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1276:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1276 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1279:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1279 0
 2298 12d8 0150A0E3 		mov	r5, #1
1280:../uvc.c      **** 		break;
 2299              		.loc 1 1280 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1279:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1279 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1280:../uvc.c      **** 		break;
 2305              		.loc 1 1280 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1289:../uvc.c      **** 
 2310              		.loc 1 1289 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1255:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1255 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1257:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1257 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1258:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1258 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1257:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1257 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1258:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1258 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1285:../uvc.c      **** 		break;
 2345              		.loc 1 1285 0
 2346 133c 0140A0E3 		mov	r4, #1
1284:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1284 0
 2348 1340 0030A0E3 		mov	r3, #0
1289:../uvc.c      **** 
 2349              		.loc 1 1289 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1284:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1284 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1289:../uvc.c      **** 
 2355              		.loc 1 1289 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1291:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1291 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 24
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1299 0
 2399 137c E47F9FE5 		ldr	r7, .L463
1298:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1298 0
 2401 1380 0F0050E3 		cmp	r0, #15
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1299 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1306 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1291:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1291 0
 2408 1390 2CD04DE2 		sub	sp, sp, #44
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 80
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1306 0
 2412 1394 00A0D3E5 		ldrb	r10, [r3]	@ zero_extendqisi2
1307:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1307 0
 2414 1398 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
1308:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1308 0
 2416 139c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
1309:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1309 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1317:../uvc.c      ****     /*
 2419              		.loc 1 1317 0
 2420 13a4 C03F9FE5 		ldr	r3, .L463+4
1291:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2421              		.loc 1 1291 0
 2422 13a8 0050A0E1 		mov	r5, r0
1317:../uvc.c      ****     /*
 2423              		.loc 1 1317 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2425              		.loc 1 1306 0
 2426 13b0 FFA00AE2 		and	r10, r10, #255
 2427              	.LVL269:
1325:../uvc.c      **** 		 {
 2428              		.loc 1 1325 0
 2429 13b4 830056E3 		cmp	r6, #131
1307:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2430              		.loc 1 1307 0
 2431 13b8 FFB00CE2 		and	fp, ip, #255
 2432              	.LVL270:
1308:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2433              		.loc 1 1308 0
 2434 13bc FF9009E2 		and	r9, r9, #255
 2435              	.LVL271:
1309:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2436              		.loc 1 1309 0
 2437 13c0 FF8008E2 		and	r8, r8, #255
 2438              	.LVL272:
1325:../uvc.c      **** 		 {
 2439              		.loc 1 1325 0
 2440 13c4 A300000A 		beq	.L275
 2441 13c8 1500009A 		bls	.L445
 2442 13cc 850056E3 		cmp	r6, #133
 2443 13d0 9400000A 		beq	.L280
 2444 13d4 AE00003A 		bcc	.L281
 2445 13d8 860056E3 		cmp	r6, #134
 2446 13dc 5900000A 		beq	.L282
 2447 13e0 870056E3 		cmp	r6, #135
 2448 13e4 8600001A 		bne	.L274
1962:../uvc.c      **** 		 		 if(Len == 2){
 2449              		.loc 1 1962 0
 2450 13e8 0F0050E3 		cmp	r0, #15
1964:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2451              		.loc 1 1964 0
 2452 13ec 005187E0 		add	r5, r7, r0, asl #2
1962:../uvc.c      **** 		 		 if(Len == 2){
 2453              		.loc 1 1962 0
 2454 13f0 B500009A 		bls	.L342
1963:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2455              		.loc 1 1963 0
 2456 13f4 020058E3 		cmp	r8, #2
 2457 13f8 FA00000A 		beq	.L446
1969:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2458              		.loc 1 1969 0
 2459 13fc 202015E5 		ldr	r2, [r5, #-32]
 2460 1400 684F9FE5 		ldr	r4, .L463+8
 2461 1404 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1970:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2462              		.loc 1 1970 0
 2463 1408 0030A0E3 		mov	r3, #0
1969:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2464              		.loc 1 1969 0
 2465 140c 2810C4E5 		strb	r1, [r4, #40]
1970:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2466              		.loc 1 1970 0
 2467 1410 2930C4E5 		strb	r3, [r4, #41]
1971:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2468              		.loc 1 1971 0
 2469 1414 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1972:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2470              		.loc 1 1972 0
 2471 1418 2B30C4E5 		strb	r3, [r4, #43]
1971:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2472              		.loc 1 1971 0
 2473 141c 2A20C4E5 		strb	r2, [r4, #42]
 2474 1420 D90000EA 		b	.L345
 2475              	.L445:
1325:../uvc.c      **** 		 {
 2476              		.loc 1 1325 0
 2477 1424 810056E3 		cmp	r6, #129
 2478 1428 6100000A 		beq	.L277
 2479 142c 3600008A 		bhi	.L278
 2480 1430 010056E3 		cmp	r6, #1
 2481 1434 7200001A 		bne	.L274
2515:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2482              		.loc 1 2515 0
 2483 1438 304F9FE5 		ldr	r4, .L463+8
 2484 143c 26208DE2 		add	r2, sp, #38
 2485 1440 2000A0E3 		mov	r0, #32
 2486              	.LVL273:
 2487 1444 281084E2 		add	r1, r4, #40
 2488 1448 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2489              	.LVL274:
2517:../uvc.c      **** 			   {
 2490              		.loc 1 2517 0
 2491 144c 002050E2 		subs	r2, r0, #0
 2492 1450 6503001A 		bne	.L347
2519:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2493              		.loc 1 2519 0
 2494 1454 020058E3 		cmp	r8, #2
2520:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2495              		.loc 1 2520 0
 2496 1458 2800D405 		ldreqb	r0, [r4, #40]	@ zero_extendqisi2
 2497              	.LVL275:
2521:../uvc.c      **** 				 }else{
 2498              		.loc 1 2521 0
 2499 145c 2910D405 		ldreqb	r1, [r4, #41]	@ zero_extendqisi2
2523:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2500              		.loc 1 2523 0
 2501 1460 2820D415 		ldrneb	r2, [r4, #40]	@ zero_extendqisi2
 2502              	.LVL276:
2524:../uvc.c      **** 				 }
 2503              		.loc 1 2524 0
 2504 1464 2A30D415 		ldrneb	r3, [r4, #42]	@ zero_extendqisi2
2520:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2505              		.loc 1 2520 0
 2506 1468 18008D05 		streq	r0, [sp, #24]
 2507              	.LVL277:
2521:../uvc.c      **** 				 }else{
 2508              		.loc 1 2521 0
 2509 146c 1C108D05 		streq	r1, [sp, #28]
 2510              	.LVL278:
2523:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2511              		.loc 1 2523 0
 2512 1470 18208D15 		strne	r2, [sp, #24]
 2513              	.LVL279:
2524:../uvc.c      **** 				 }
 2514              		.loc 1 2524 0
 2515 1474 1C308D15 		strne	r3, [sp, #28]
 2516              	.LVL280:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 2517              		.loc 1 2527 0
 2518 1478 00B08DE5 		str	fp, [sp]
 2519 147c 04908DE5 		str	r9, [sp, #4]
 2520 1480 08808DE5 		str	r8, [sp, #8]
 2521 1484 0400A0E3 		mov	r0, #4
 2522 1488 E41E9FE5 		ldr	r1, .L463+12
 2523 148c 0520A0E1 		mov	r2, r5
 2524 1490 0A30A0E1 		mov	r3, r10
 2525 1494 FEFFFFEB 		bl	CyU3PDebugPrint
 2526              	.LVL281:
2529:../uvc.c      **** 					 switch(CtrlID)
 2527              		.loc 1 2529 0
 2528 1498 0F0055E3 		cmp	r5, #15
 2529 149c C200009A 		bls	.L350
2530:../uvc.c      **** 					 {
 2530              		.loc 1 2530 0
 2531 14a0 103045E2 		sub	r3, r5, #16
 2532 14a4 160053E3 		cmp	r3, #22
 2533 14a8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2534 14ac 470300EA 		b	.L351
 2535              	.L353:
 2536 14b0 B81B0000 		.word	.L352
 2537 14b4 D0210000 		.word	.L351
 2538 14b8 D0210000 		.word	.L351
 2539 14bc D0210000 		.word	.L351
 2540 14c0 D0210000 		.word	.L351
 2541 14c4 D0210000 		.word	.L351
 2542 14c8 D0210000 		.word	.L351
 2543 14cc D0210000 		.word	.L351
 2544 14d0 D0210000 		.word	.L351
 2545 14d4 181B0000 		.word	.L354
 2546 14d8 D0210000 		.word	.L351
 2547 14dc D0210000 		.word	.L351
 2548 14e0 041B0000 		.word	.L355
 2549 14e4 D0210000 		.word	.L351
 2550 14e8 D0210000 		.word	.L351
 2551 14ec AC200000 		.word	.L356
 2552 14f0 D0210000 		.word	.L351
 2553 14f4 D0210000 		.word	.L351
 2554 14f8 D0210000 		.word	.L351
 2555 14fc D0210000 		.word	.L351
 2556 1500 781A0000 		.word	.L357
 2557 1504 D0210000 		.word	.L351
 2558 1508 781C0000 		.word	.L358
 2559              	.LVL282:
 2560              	.L278:
1853:../uvc.c      **** 		 		 if(Len == 2){
 2561              		.loc 1 1853 0
 2562 150c 0F0050E3 		cmp	r0, #15
1855:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2563              		.loc 1 1855 0
 2564 1510 005187E0 		add	r5, r7, r0, asl #2
1853:../uvc.c      **** 		 		 if(Len == 2){
 2565              		.loc 1 1853 0
 2566 1514 8700009A 		bls	.L328
1854:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2567              		.loc 1 1854 0
 2568 1518 020058E3 		cmp	r8, #2
 2569 151c BE00000A 		beq	.L447
1860:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2570              		.loc 1 1860 0
 2571 1520 202015E5 		ldr	r2, [r5, #-32]
 2572 1524 444E9FE5 		ldr	r4, .L463+8
 2573 1528 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1861:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2574              		.loc 1 1861 0
 2575 152c 0030A0E3 		mov	r3, #0
1860:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2576              		.loc 1 1860 0
 2577 1530 2810C4E5 		strb	r1, [r4, #40]
1861:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2578              		.loc 1 1861 0
 2579 1534 2930C4E5 		strb	r3, [r4, #41]
1862:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2580              		.loc 1 1862 0
 2581 1538 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1863:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2582              		.loc 1 1863 0
 2583 153c 2B30C4E5 		strb	r3, [r4, #43]
1862:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2584              		.loc 1 1862 0
 2585 1540 2A20C4E5 		strb	r2, [r4, #42]
 2586 1544 900000EA 		b	.L345
 2587              	.L282:
 2588              	.LVL283:
1943:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2589              		.loc 1 1943 0
 2590 1548 0F0050E3 		cmp	r0, #15
1944:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2591              		.loc 1 1944 0
 2592 154c 005187E0 		add	r5, r7, r0, asl #2
 2593 1550 20301585 		ldrhi	r3, [r5, #-32]
1950:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2594              		.loc 1 1950 0
 2595 1554 20319595 		ldrls	r3, [r5, #288]
 2596 1558 104E9FE5 		ldr	r4, .L463+8
 2597 155c 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1956:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2598              		.loc 1 1956 0
 2599 1560 0100A0E3 		mov	r0, #1
 2600              	.LVL284:
1951:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2601              		.loc 1 1951 0
 2602 1564 0030A0E3 		mov	r3, #0
1950:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2603              		.loc 1 1950 0
 2604 1568 2820C4E5 		strb	r2, [r4, #40]
1951:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2605              		.loc 1 1951 0
 2606 156c 2930C4E5 		strb	r3, [r4, #41]
1952:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2607              		.loc 1 1952 0
 2608 1570 2A30C4E5 		strb	r3, [r4, #42]
1953:../uvc.c      **** 		 	 }
 2609              		.loc 1 1953 0
 2610 1574 2B30C4E5 		strb	r3, [r4, #43]
 2611              	.LVL285:
 2612              	.L438:
1915:../uvc.c      **** 				  if(Len == 2){
 2613              		.loc 1 1915 0
 2614 1578 F81D9FE5 		ldr	r1, .L463+16
 2615 157c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2616              	.LVL286:
 2617 1580 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2618              	.LVL287:
 2619 1584 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2620 1588 0090A0E3 		mov	r9, #0
 2621              	.LVL288:
 2622 158c 0950A0E1 		mov	r5, r9
 2623              	.LVL289:
 2624              	.L284:
2930:../uvc.c      **** }
 2625              		.loc 1 2930 0
 2626 1590 20048DE8 		stmia	sp, {r5, r10}
 2627 1594 E01D9FE5 		ldr	r1, .L463+20
 2628 1598 08708DE5 		str	r7, [sp, #8]
 2629 159c 0620A0E1 		mov	r2, r6
 2630 15a0 0930A0E1 		mov	r3, r9
 2631 15a4 0400A0E3 		mov	r0, #4
 2632 15a8 FEFFFFEB 		bl	CyU3PDebugPrint
 2633              	.LVL290:
2931:../uvc.c      **** /************** CT control requests handler *************************/
 2634              		.loc 1 2931 0
 2635 15ac 2CD08DE2 		add	sp, sp, #44
 2636              		@ sp needed
 2637 15b0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2638              	.LVL291:
 2639              	.L277:
1336:../uvc.c      **** 				 switch(CtrlID)
 2640              		.loc 1 1336 0
 2641 15b4 0F0050E3 		cmp	r0, #15
 2642 15b8 4E00009A 		bls	.L285
1337:../uvc.c      **** 				 {
 2643              		.loc 1 1337 0
 2644 15bc 193040E2 		sub	r3, r0, #25
 2645 15c0 0D0053E3 		cmp	r3, #13
 2646 15c4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2647 15c8 D70200EA 		b	.L286
 2648              	.L288:
 2649 15cc 9C190000 		.word	.L287
 2650 15d0 2C210000 		.word	.L286
 2651 15d4 2C210000 		.word	.L286
 2652 15d8 F8190000 		.word	.L289
 2653 15dc 2C210000 		.word	.L286
 2654 15e0 2C210000 		.word	.L286
 2655 15e4 0C190000 		.word	.L290
 2656 15e8 2C210000 		.word	.L286
 2657 15ec 2C210000 		.word	.L286
 2658 15f0 2C210000 		.word	.L286
 2659 15f4 2C210000 		.word	.L286
 2660 15f8 2C210000 		.word	.L286
 2661 15fc 2C210000 		.word	.L286
 2662 1600 7C180000 		.word	.L291
 2663              	.L274:
2927:../uvc.c      **** 			  break;
 2664              		.loc 1 2927 0
 2665 1604 0000A0E3 		mov	r0, #0
 2666              	.LVL292:
 2667 1608 0020A0E1 		mov	r2, r0
 2668 160c 0110A0E3 		mov	r1, #1
2928:../uvc.c      **** 		 }
 2669              		.loc 1 2928 0
 2670 1610 FF70A0E3 		mov	r7, #255
 2671 1614 0090A0E3 		mov	r9, #0
 2672              	.LVL293:
2927:../uvc.c      **** 			  break;
 2673              		.loc 1 2927 0
 2674 1618 FEFFFFEB 		bl	CyU3PUsbStall
 2675              	.LVL294:
2928:../uvc.c      **** 		 }
 2676              		.loc 1 2928 0
 2677 161c 07A0A0E1 		mov	r10, r7
 2678              	.LVL295:
 2679 1620 0950A0E1 		mov	r5, r9
 2680 1624 D9FFFFEA 		b	.L284
 2681              	.LVL296:
 2682              	.L280:
1329:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2683              		.loc 1 1329 0
 2684 1628 404D9FE5 		ldr	r4, .L463+8
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2685              		.loc 1 1330 0
 2686 162c 0030A0E3 		mov	r3, #0
 2687 1630 0390A0E1 		mov	r9, r3
 2688              	.LVL297:
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2689              		.loc 1 1331 0
 2690 1634 281084E2 		add	r1, r4, #40
 2691 1638 0200A0E3 		mov	r0, #2
 2692              	.LVL298:
1329:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2693              		.loc 1 1329 0
 2694 163c 2880C4E5 		strb	r8, [r4, #40]
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2695              		.loc 1 1330 0
 2696 1640 2930C4E5 		strb	r3, [r4, #41]
 2697 1644 0950A0E1 		mov	r5, r9
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2698              		.loc 1 1331 0
 2699 1648 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2700              	.LVL299:
1333:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2701              		.loc 1 1333 0
 2702 164c FF70A0E3 		mov	r7, #255
 2703 1650 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2704              	.LVL300:
 2705 1654 CDFFFFEA 		b	.L284
 2706              	.LVL301:
 2707              	.L275:
1889:../uvc.c      **** 		 		 if(Len == 2){
 2708              		.loc 1 1889 0
 2709 1658 0F0050E3 		cmp	r0, #15
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2710              		.loc 1 1891 0
 2711 165c 005187E0 		add	r5, r7, r0, asl #2
1889:../uvc.c      **** 		 		 if(Len == 2){
 2712              		.loc 1 1889 0
 2713 1660 3F00009A 		bls	.L333
1890:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2714              		.loc 1 1890 0
 2715 1664 020058E3 		cmp	r8, #2
 2716 1668 7200000A 		beq	.L448
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2717              		.loc 1 1896 0
 2718 166c 202015E5 		ldr	r2, [r5, #-32]
 2719 1670 F84C9FE5 		ldr	r4, .L463+8
 2720 1674 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2721              		.loc 1 1897 0
 2722 1678 0030A0E3 		mov	r3, #0
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2723              		.loc 1 1896 0
 2724 167c 2810C4E5 		strb	r1, [r4, #40]
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2725              		.loc 1 1897 0
 2726 1680 2930C4E5 		strb	r3, [r4, #41]
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2727              		.loc 1 1898 0
 2728 1684 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1899:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2729              		.loc 1 1899 0
 2730 1688 2B30C4E5 		strb	r3, [r4, #43]
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2731              		.loc 1 1898 0
 2732 168c 2A20C4E5 		strb	r2, [r4, #42]
 2733 1690 3D0000EA 		b	.L345
 2734              	.L281:
1925:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2735              		.loc 1 1925 0
 2736 1694 0F0050E3 		cmp	r0, #15
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2737              		.loc 1 1926 0
 2738 1698 005187E0 		add	r5, r7, r0, asl #2
 2739 169c 20201585 		ldrhi	r2, [r5, #-32]
1932:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2740              		.loc 1 1932 0
 2741 16a0 20219595 		ldrls	r2, [r5, #288]
 2742 16a4 C44C9FE5 		ldr	r4, .L463+8
 2743 16a8 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1934:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2744              		.loc 1 1934 0
 2745 16ac 0030A0E3 		mov	r3, #0
1932:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2746              		.loc 1 1932 0
 2747 16b0 2810C4E5 		strb	r1, [r4, #40]
1933:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2748              		.loc 1 1933 0
 2749 16b4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2750              		.loc 1 1937 0
 2751 16b8 0800A0E1 		mov	r0, r8
 2752              	.LVL302:
1934:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2753              		.loc 1 1934 0
 2754 16bc 2A30C4E5 		strb	r3, [r4, #42]
1933:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2755              		.loc 1 1933 0
 2756 16c0 2920C4E5 		strb	r2, [r4, #41]
1935:../uvc.c      **** 		 	 }
 2757              		.loc 1 1935 0
 2758 16c4 2B30C4E5 		strb	r3, [r4, #43]
 2759 16c8 AAFFFFEA 		b	.L438
 2760              	.LVL303:
 2761              	.L342:
1976:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2762              		.loc 1 1976 0
 2763 16cc 020058E3 		cmp	r8, #2
1977:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2764              		.loc 1 1977 0
 2765 16d0 203195E5 		ldr	r3, [r5, #288]
 2766 16d4 944C9FE5 		ldr	r4, .L463+8
1976:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2767              		.loc 1 1976 0
 2768 16d8 4A00000A 		beq	.L449
1981:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2769              		.loc 1 1981 0
 2770 16dc 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1984:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2771              		.loc 1 1984 0
 2772 16e0 0020A0E3 		mov	r2, #0
1981:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2773              		.loc 1 1981 0
 2774 16e4 2810C4E5 		strb	r1, [r4, #40]
1983:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2775              		.loc 1 1983 0
 2776 16e8 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1984:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2777              		.loc 1 1984 0
 2778 16ec 2B20C4E5 		strb	r2, [r4, #43]
1983:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2779              		.loc 1 1983 0
 2780 16f0 2930C4E5 		strb	r3, [r4, #41]
 2781 16f4 240000EA 		b	.L345
 2782              	.L285:
1655:../uvc.c      **** 				 {
 2783              		.loc 1 1655 0
 2784 16f8 013040E2 		sub	r3, r0, #1
1806:../uvc.c      **** 			 	 			 if(Len == 2)
 2785              		.loc 1 1806 0
 2786 16fc 6C4C9FE5 		ldr	r4, .L463+8
1655:../uvc.c      **** 				 {
 2787              		.loc 1 1655 0
 2788 1700 0A0053E3 		cmp	r3, #10
 2789 1704 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2790 1708 7B0200EA 		b	.L306
 2791              	.L308:
 2792 170c 58190000 		.word	.L307
 2793 1710 FC200000 		.word	.L306
 2794 1714 FC200000 		.word	.L306
 2795 1718 E0180000 		.word	.L309
 2796 171c 401A0000 		.word	.L310
 2797 1720 FC200000 		.word	.L306
 2798 1724 FC200000 		.word	.L306
 2799 1728 FC200000 		.word	.L306
 2800 172c FC200000 		.word	.L306
 2801 1730 FC200000 		.word	.L306
 2802 1734 0C1A0000 		.word	.L311
 2803              	.L328:
1867:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2804              		.loc 1 1867 0
 2805 1738 020058E3 		cmp	r8, #2
1868:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2806              		.loc 1 1868 0
 2807 173c 203195E5 		ldr	r3, [r5, #288]
 2808 1740 284C9FE5 		ldr	r4, .L463+8
1867:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2809              		.loc 1 1867 0
 2810 1744 4200000A 		beq	.L450
1872:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2811              		.loc 1 1872 0
 2812 1748 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1875:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2813              		.loc 1 1875 0
 2814 174c 0020A0E3 		mov	r2, #0
1872:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2815              		.loc 1 1872 0
 2816 1750 2810C4E5 		strb	r1, [r4, #40]
1874:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2817              		.loc 1 1874 0
 2818 1754 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1875:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2819              		.loc 1 1875 0
 2820 1758 2B20C4E5 		strb	r2, [r4, #43]
1874:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2821              		.loc 1 1874 0
 2822 175c 2930C4E5 		strb	r3, [r4, #41]
 2823 1760 090000EA 		b	.L345
 2824              	.L333:
1903:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2825              		.loc 1 1903 0
 2826 1764 020058E3 		cmp	r8, #2
1904:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2827              		.loc 1 1904 0
 2828 1768 203195E5 		ldr	r3, [r5, #288]
 2829 176c FC4B9FE5 		ldr	r4, .L463+8
1903:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2830              		.loc 1 1903 0
 2831 1770 3C00000A 		beq	.L451
1908:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2832              		.loc 1 1908 0
 2833 1774 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1911:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2834              		.loc 1 1911 0
 2835 1778 0020A0E3 		mov	r2, #0
1908:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2836              		.loc 1 1908 0
 2837 177c 2810C4E5 		strb	r1, [r4, #40]
1910:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2838              		.loc 1 1910 0
 2839 1780 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1911:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2840              		.loc 1 1911 0
 2841 1784 2B20C4E5 		strb	r2, [r4, #43]
1910:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2842              		.loc 1 1910 0
 2843 1788 2930C4E5 		strb	r3, [r4, #41]
 2844              	.L345:
1988:../uvc.c      **** 		 	 if(Len == 2){
 2845              		.loc 1 1988 0
 2846 178c 0800A0E1 		mov	r0, r8
 2847              	.LVL304:
 2848 1790 E01B9FE5 		ldr	r1, .L463+16
 2849 1794 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2850              	.LVL305:
 2851 1798 0090A0E3 		mov	r9, #0
 2852              	.LVL306:
 2853 179c 0950A0E1 		mov	r5, r9
 2854 17a0 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2855              	.LVL307:
 2856 17a4 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2857 17a8 78FFFFEA 		b	.L284
 2858              	.LVL308:
 2859              	.L350:
2733:../uvc.c      **** 					 {
 2860              		.loc 1 2733 0
 2861 17ac 0B0055E3 		cmp	r5, #11
 2862 17b0 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2863 17b4 720200EA 		b	.L376
 2864              	.L378:
 2865 17b8 48200000 		.word	.L377
 2866 17bc D01F0000 		.word	.L379
 2867 17c0 84210000 		.word	.L376
 2868 17c4 84210000 		.word	.L376
 2869 17c8 681F0000 		.word	.L380
 2870 17cc 141E0000 		.word	.L381
 2871 17d0 84210000 		.word	.L376
 2872 17d4 841D0000 		.word	.L382
 2873 17d8 84210000 		.word	.L376
 2874 17dc 84210000 		.word	.L376
 2875 17e0 84210000 		.word	.L376
 2876 17e4 F01C0000 		.word	.L383
 2877              	.LVL309:
 2878              	.L446:
1964:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2879              		.loc 1 1964 0
 2880 17e8 203015E5 		ldr	r3, [r5, #-32]
 2881 17ec 7C4B9FE5 		ldr	r4, .L463+8
 2882 17f0 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2883 17f4 2820C4E5 		strb	r2, [r4, #40]
1965:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2884              		.loc 1 1965 0
 2885 17f8 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2886 17fc 2930C4E5 		strb	r3, [r4, #41]
 2887              	.L335:
1915:../uvc.c      **** 				  if(Len == 2){
 2888              		.loc 1 1915 0
 2889 1800 0200A0E3 		mov	r0, #2
 2890              	.LVL310:
 2891 1804 5BFFFFEA 		b	.L438
 2892              	.LVL311:
 2893              	.L449:
1977:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2894              		.loc 1 1977 0
 2895 1808 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2896 180c 2820C4E5 		strb	r2, [r4, #40]
1978:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2897              		.loc 1 1978 0
 2898 1810 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2899 1814 2930C4E5 		strb	r3, [r4, #41]
 2900 1818 F8FFFFEA 		b	.L335
 2901              	.L447:
1855:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2902              		.loc 1 1855 0
 2903 181c 203015E5 		ldr	r3, [r5, #-32]
 2904 1820 484B9FE5 		ldr	r4, .L463+8
 2905 1824 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2906 1828 2820C4E5 		strb	r2, [r4, #40]
1856:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2907              		.loc 1 1856 0
 2908 182c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2909 1830 2930C4E5 		strb	r3, [r4, #41]
 2910 1834 F1FFFFEA 		b	.L335
 2911              	.L448:
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2912              		.loc 1 1891 0
 2913 1838 203015E5 		ldr	r3, [r5, #-32]
 2914 183c 2C4B9FE5 		ldr	r4, .L463+8
 2915 1840 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2916 1844 2820C4E5 		strb	r2, [r4, #40]
1892:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2917              		.loc 1 1892 0
 2918 1848 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2919 184c 2930C4E5 		strb	r3, [r4, #41]
 2920 1850 EAFFFFEA 		b	.L335
 2921              	.L450:
1868:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2922              		.loc 1 1868 0
 2923 1854 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2924 1858 2820C4E5 		strb	r2, [r4, #40]
1869:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2925              		.loc 1 1869 0
 2926 185c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2927 1860 2930C4E5 		strb	r3, [r4, #41]
 2928 1864 E5FFFFEA 		b	.L335
 2929              	.L451:
1904:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2930              		.loc 1 1904 0
 2931 1868 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2932 186c 2820C4E5 		strb	r2, [r4, #40]
1905:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2933              		.loc 1 1905 0
 2934 1870 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2935 1874 2930C4E5 		strb	r3, [r4, #41]
 2936 1878 E0FFFFEA 		b	.L335
 2937              	.L291:
1340:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
 2938              		.loc 1 1340 0
 2939 187c EC4A9FE5 		ldr	r4, .L463+8
 2940 1880 C650D4E5 		ldrb	r5, [r4, #198]	@ zero_extendqisi2
 2941 1884 000055E3 		cmp	r5, #0
 2942 1888 8902000A 		beq	.L296
1341:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 2943              		.loc 1 1341 0
 2944 188c 0C3B9FE5 		ldr	r3, .L463+56
 2945 1890 05A5D3E5 		ldrb	r10, [r3, #1285]	@ zero_extendqisi2
 2946              	.LVL312:
1342:../uvc.c      **** 						 }else{
 2947              		.loc 1 1342 0
 2948 1894 0675D3E5 		ldrb	r7, [r3, #1286]	@ zero_extendqisi2
1341:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 2949              		.loc 1 1341 0
 2950 1898 FFA00AE2 		and	r10, r10, #255
1342:../uvc.c      **** 						 }else{
 2951              		.loc 1 1342 0
 2952 189c FF7007E2 		and	r7, r7, #255
1341:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 2953              		.loc 1 1341 0
 2954 18a0 28A0C4E5 		strb	r10, [r4, #40]
1342:../uvc.c      **** 						 }else{
 2955              		.loc 1 1342 0
 2956 18a4 2970C4E5 		strb	r7, [r4, #41]
 2957              	.LVL313:
 2958              	.L320:
 2959 18a8 0290A0E1 		mov	r9, r2
 2960              	.LVL314:
 2961              	.L292:
1846:../uvc.c      **** 
 2962              		.loc 1 1846 0
 2963 18ac C41A9FE5 		ldr	r1, .L463+16
 2964 18b0 0800A0E1 		mov	r0, r8
 2965 18b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2966              	.LVL315:
1849:../uvc.c      **** //#endif
 2967              		.loc 1 1849 0
 2968 18b8 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2969 18bc 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 2970 18c0 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 2971 18c4 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 2972 18c8 03018DE8 		stmia	sp, {r0, r1, r8}
 2973 18cc AC1A9FE5 		ldr	r1, .L463+24
 2974 18d0 0400A0E3 		mov	r0, #4
 2975 18d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2976              	.LVL316:
 2977 18d8 18509DE5 		ldr	r5, [sp, #24]
1851:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 2978              		.loc 1 1851 0
 2979 18dc 2BFFFFEA 		b	.L284
 2980              	.LVL317:
 2981              	.L309:
1702:../uvc.c      **** 
 2982              		.loc 1 1702 0
 2983 18e0 A430D4E5 		ldrb	r3, [r4, #164]	@ zero_extendqisi2
 2984 18e4 000053E3 		cmp	r3, #0
 2985 18e8 AF02000A 		beq	.L318
1704:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2986              		.loc 1 1704 0
 2987 18ec 6C3094E5 		ldr	r3, [r4, #108]
1709:../uvc.c      **** 						 }else{
 2988              		.loc 1 1709 0
 2989 18f0 0070A0E3 		mov	r7, #0
1704:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2990              		.loc 1 1704 0
 2991 18f4 000053E3 		cmp	r3, #0
 2992 18f8 02A0A013 		movne	r10, #2
 2993              	.LVL318:
 2994 18fc 01A0A003 		moveq	r10, #1
 2995 1900 28A0C4E5 		strb	r10, [r4, #40]
1709:../uvc.c      **** 						 }else{
 2996              		.loc 1 1709 0
 2997 1904 2970C4E5 		strb	r7, [r4, #41]
 2998 1908 E6FFFFEA 		b	.L320
 2999              	.LVL319:
 3000              	.L290:
1393:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3001              		.loc 1 1393 0 discriminator 1
 3002 190c 000058E3 		cmp	r8, #0
 3003 1910 0300000A 		beq	.L300
 3004 1914 5C0A9FE5 		ldr	r0, .L463+16
 3005              	.LVL320:
 3006 1918 0820A0E1 		mov	r2, r8
 3007 191c 6C1080E2 		add	r1, r0, #108
 3008 1920 FEFFFFEB 		bl	memcpy
 3009              	.LVL321:
 3010              	.L300:
1396:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3011              		.loc 1 1396 0
 3012 1924 444A9FE5 		ldr	r4, .L463+8
1403:../uvc.c      **** 				 		 {
 3013              		.loc 1 1403 0
 3014 1928 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1396:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3015              		.loc 1 1396 0
 3016 192c 31A0D4E5 		ldrb	r10, [r4, #49]	@ zero_extendqisi2
 3017              	.LVL322:
1403:../uvc.c      **** 				 		 {
 3018              		.loc 1 1403 0
 3019 1930 FF0053E3 		cmp	r3, #255
1397:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3020              		.loc 1 1397 0
 3021 1934 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3022              	.LVL323:
1403:../uvc.c      **** 				 		 {
 3023              		.loc 1 1403 0
 3024 1938 3C02000A 		beq	.L434
1405:../uvc.c      **** 				 		 }
 3025              		.loc 1 1405 0
 3026 193c 0400A0E3 		mov	r0, #4
 3027 1940 3C1A9FE5 		ldr	r1, .L463+28
 3028 1944 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3029 1948 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3030 194c FEFFFFEB 		bl	CyU3PDebugPrint
 3031              	.LVL324:
 3032 1950 0090A0E3 		mov	r9, #0
 3033              	.LVL325:
 3034 1954 D4FFFFEA 		b	.L292
 3035              	.LVL326:
 3036              	.L307:
1670:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
 3037              		.loc 1 1670 0
 3038 1958 A130D4E5 		ldrb	r3, [r4, #161]	@ zero_extendqisi2
 3039 195c 000053E3 		cmp	r3, #0
 3040 1960 6102000A 		beq	.L312
1671:../uvc.c      **** 						 }else{
 3041              		.loc 1 1671 0
 3042 1964 343A9FE5 		ldr	r3, .L463+56
 3043 1968 2D05D3E5 		ldrb	r0, [r3, #1325]	@ zero_extendqisi2
 3044              	.LVL327:
 3045 196c FF0000E2 		and	r0, r0, #255
 3046              	.LVL328:
 3047              	.L313:
1678:../uvc.c      **** 							  Data0 = ~Data0;
 3048              		.loc 1 1678 0
 3049 1970 800010E3 		tst	r0, #128
1679:../uvc.c      **** 						  }else{
 3050              		.loc 1 1679 0
 3051 1974 0030E011 		mvnne	r3, r0
1681:../uvc.c      **** 						  }
 3052              		.loc 1 1681 0
 3053 1978 80304002 		subeq	r3, r0, #128
 3054 197c FF3003E2 		and	r3, r3, #255
 3055              	.LVL329:
1684:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3056              		.loc 1 1684 0
 3057 1980 0020A0E3 		mov	r2, #0
 3058 1984 0390A0E1 		mov	r9, r3
 3059              	.LVL330:
1683:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3060              		.loc 1 1683 0
 3061 1988 2830C4E5 		strb	r3, [r4, #40]
1686:../uvc.c      **** 					 case HueCtlID5:
 3062              		.loc 1 1686 0
 3063 198c 03A0A0E1 		mov	r10, r3
 3064              	.LVL331:
1684:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3065              		.loc 1 1684 0
 3066 1990 2920C4E5 		strb	r2, [r4, #41]
 3067              	.LVL332:
1686:../uvc.c      **** 					 case HueCtlID5:
 3068              		.loc 1 1686 0
 3069 1994 FF70A0E3 		mov	r7, #255
 3070 1998 C3FFFFEA 		b	.L292
 3071              	.LVL333:
 3072              	.L287:
1357:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3073              		.loc 1 1357 0
 3074 199c CC499FE5 		ldr	r4, .L463+8
 3075 19a0 B930D4E5 		ldrb	r3, [r4, #185]	@ zero_extendqisi2
 3076 19a4 000053E3 		cmp	r3, #0
 3077 19a8 9102000A 		beq	.L298
1358:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3078              		.loc 1 1358 0
 3079 19ac EC399FE5 		ldr	r3, .L463+56
 3080 19b0 19A5D3E5 		ldrb	r10, [r3, #1305]	@ zero_extendqisi2
 3081              	.LVL334:
1359:../uvc.c      **** 			 	 		 }else{
 3082              		.loc 1 1359 0
 3083 19b4 1A75D3E5 		ldrb	r7, [r3, #1306]	@ zero_extendqisi2
1358:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3084              		.loc 1 1358 0
 3085 19b8 FFA00AE2 		and	r10, r10, #255
1359:../uvc.c      **** 			 	 		 }else{
 3086              		.loc 1 1359 0
 3087 19bc FF7007E2 		and	r7, r7, #255
1358:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3088              		.loc 1 1358 0
 3089 19c0 28A0C4E5 		strb	r10, [r4, #40]
1359:../uvc.c      **** 			 	 		 }else{
 3090              		.loc 1 1359 0
 3091 19c4 2A70C4E5 		strb	r7, [r4, #42]
 3092              	.LVL335:
 3093              	.L299:
1369:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3094              		.loc 1 1369 0
 3095 19c8 00C0A0E3 		mov	ip, #0
1373:../uvc.c      **** 						 break;
 3096              		.loc 1 1373 0
 3097 19cc 00708DE5 		str	r7, [sp]
 3098 19d0 04C08DE5 		str	ip, [sp, #4]
 3099 19d4 0A20A0E1 		mov	r2, r10
 3100 19d8 0C30A0E1 		mov	r3, ip
 3101 19dc A4199FE5 		ldr	r1, .L463+32
1369:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3102              		.loc 1 1369 0
 3103 19e0 29C0C4E5 		strb	ip, [r4, #41]
1370:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3104              		.loc 1 1370 0
 3105 19e4 2BC0C4E5 		strb	ip, [r4, #43]
 3106              	.LVL336:
1373:../uvc.c      **** 						 break;
 3107              		.loc 1 1373 0
 3108 19e8 0400A0E3 		mov	r0, #4
 3109 19ec 0C90A0E1 		mov	r9, ip
 3110              	.LVL337:
 3111 19f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3112              	.LVL338:
1374:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3113              		.loc 1 1374 0
 3114 19f4 ACFFFFEA 		b	.L292
 3115              	.LVL339:
 3116              	.L289:
1337:../uvc.c      **** 				 {
 3117              		.loc 1 1337 0
 3118 19f8 FF70A0E3 		mov	r7, #255
 3119 19fc 07A0A0E1 		mov	r10, r7
 3120              	.LVL340:
 3121 1a00 0090A0E3 		mov	r9, #0
 3122              	.LVL341:
 3123 1a04 64499FE5 		ldr	r4, .L463+8
 3124 1a08 A7FFFFEA 		b	.L292
 3125              	.LVL342:
 3126              	.L311:
1723:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 3127              		.loc 1 1723 0
 3128 1a0c AB30D4E5 		ldrb	r3, [r4, #171]	@ zero_extendqisi2
 3129 1a10 000053E3 		cmp	r3, #0
 3130 1a14 1202000A 		beq	.L321
1724:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3131              		.loc 1 1724 0
 3132 1a18 80399FE5 		ldr	r3, .L463+56
 3133 1a1c 5CA5D3E5 		ldrb	r10, [r3, #1372]	@ zero_extendqisi2
 3134              	.LVL343:
1725:../uvc.c      **** 						 }else{
 3135              		.loc 1 1725 0
 3136 1a20 5E75D3E5 		ldrb	r7, [r3, #1374]	@ zero_extendqisi2
1724:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3137              		.loc 1 1724 0
 3138 1a24 28A0C4E5 		strb	r10, [r4, #40]
1725:../uvc.c      **** 						 }else{
 3139              		.loc 1 1725 0
 3140 1a28 2A70C4E5 		strb	r7, [r4, #42]
 3141              	.LVL344:
 3142              	.L322:
1735:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3143              		.loc 1 1735 0
 3144 1a2c 0030A0E3 		mov	r3, #0
 3145 1a30 0290A0E1 		mov	r9, r2
 3146              	.LVL345:
 3147 1a34 2930C4E5 		strb	r3, [r4, #41]
1736:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3148              		.loc 1 1736 0
 3149 1a38 2B30C4E5 		strb	r3, [r4, #43]
 3150              	.LVL346:
1739:../uvc.c      **** 					 case BLCCtlID0:
 3151              		.loc 1 1739 0
 3152 1a3c 9AFFFFEA 		b	.L292
 3153              	.LVL347:
 3154              	.L310:
1688:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
 3155              		.loc 1 1688 0
 3156 1a40 A530D4E5 		ldrb	r3, [r4, #165]	@ zero_extendqisi2
 3157 1a44 000053E3 		cmp	r3, #0
 3158 1a48 3E02000A 		beq	.L316
1689:../uvc.c      **** 						 }else{
 3159              		.loc 1 1689 0
 3160 1a4c 4C399FE5 		ldr	r3, .L463+56
 3161 1a50 4195D3E5 		ldrb	r9, [r3, #1345]	@ zero_extendqisi2
 3162              	.LVL348:
 3163 1a54 FF0009E2 		and	r0, r9, #255
 3164              	.LVL349:
 3165              	.L317:
1696:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3166              		.loc 1 1696 0
 3167 1a58 80A040E2 		sub	r10, r0, #128
 3168              	.LVL350:
 3169 1a5c FFA00AE2 		and	r10, r10, #255
1697:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3170              		.loc 1 1697 0
 3171 1a60 0030A0E3 		mov	r3, #0
1696:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3172              		.loc 1 1696 0
 3173 1a64 28A0C4E5 		strb	r10, [r4, #40]
 3174 1a68 0090A0E1 		mov	r9, r0
1697:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3175              		.loc 1 1697 0
 3176 1a6c 2930C4E5 		strb	r3, [r4, #41]
 3177              	.LVL351:
1699:../uvc.c      **** 					 case MFreqCtlID4:
 3178              		.loc 1 1699 0
 3179 1a70 FF70A0E3 		mov	r7, #255
 3180 1a74 8CFFFFEA 		b	.L292
 3181              	.LVL352:
 3182              	.L357:
2677:../uvc.c      **** 						     /* end test */
 3183              		.loc 1 2677 0
 3184 1a78 28599FE5 		ldr	r5, .L463+64
 3185 1a7c 0010E0E3 		mvn	r1, #0
 3186 1a80 1C0095E5 		ldr	r0, [r5, #28]
 3187 1a84 FEFFFFEB 		bl	_txe_mutex_get
 3188              	.LVL353:
2679:../uvc.c      **** 							 dataIdx++;
 3189              		.loc 1 2679 0
 3190 1a88 18009DE5 		ldr	r0, [sp, #24]
 3191 1a8c 0030A0E3 		mov	r3, #0
 3192 1a90 0A20A0E1 		mov	r2, r10
 3193 1a94 00008DE5 		str	r0, [sp]
 3194 1a98 04308DE5 		str	r3, [sp, #4]
 3195 1a9c 0500A0E1 		mov	r0, r5
 3196 1aa0 0930A0E1 		mov	r3, r9
 3197 1aa4 2410A0E3 		mov	r1, #36
 3198 1aa8 FEFFFFEB 		bl	cmdSet
 3199              	.LVL354:
2681:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3200              		.loc 1 2681 0
 3201 1aac 1C109DE5 		ldr	r1, [sp, #28]
 3202 1ab0 0140A0E3 		mov	r4, #1
 3203 1ab4 0930A0E1 		mov	r3, r9
 3204 1ab8 0B20A0E1 		mov	r2, fp
 3205 1abc 00108DE5 		str	r1, [sp]
 3206 1ac0 0500A0E1 		mov	r0, r5
 3207 1ac4 2410A0E3 		mov	r1, #36
 3208 1ac8 04408DE5 		str	r4, [sp, #4]
 3209 1acc FEFFFFEB 		bl	cmdSet
 3210              	.LVL355:
2682:../uvc.c      **** 							 getData1 = Data1;
 3211              		.loc 1 2682 0
 3212 1ad0 1C0095E5 		ldr	r0, [r5, #28]
 3213 1ad4 FEFFFFEB 		bl	_txe_mutex_put
 3214              	.LVL356:
2685:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3215              		.loc 1 2685 0
 3216 1ad8 C0389FE5 		ldr	r3, .L463+56
 3217 1adc 18209DE5 		ldr	r2, [sp, #24]
2686:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3218              		.loc 1 2686 0
 3219 1ae0 1C009DE5 		ldr	r0, [sp, #28]
2688:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3220              		.loc 1 2688 0
 3221 1ae4 FF70A0E3 		mov	r7, #255
2685:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3222              		.loc 1 2685 0
 3223 1ae8 9525C3E5 		strb	r2, [r3, #1429]
 3224 1aec 0290A0E1 		mov	r9, r2
 3225              	.LVL357:
2686:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3226              		.loc 1 2686 0
 3227 1af0 9605C3E5 		strb	r0, [r3, #1430]
 3228 1af4 0050A0E1 		mov	r5, r0
2687:../uvc.c      **** 							 break;
 3229              		.loc 1 2687 0
 3230 1af8 9945C3E5 		strb	r4, [r3, #1433]
2688:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3231              		.loc 1 2688 0
 3232 1afc 07A0A0E1 		mov	r10, r7
 3233              	.LVL358:
 3234 1b00 A2FEFFEA 		b	.L284
 3235              	.LVL359:
 3236              	.L355:
2530:../uvc.c      **** 					 {
 3237              		.loc 1 2530 0
 3238 1b04 FF70A0E3 		mov	r7, #255
 3239 1b08 18909DE5 		ldr	r9, [sp, #24]
 3240              	.LVL360:
 3241 1b0c 1C509DE5 		ldr	r5, [sp, #28]
 3242 1b10 07A0A0E1 		mov	r10, r7
 3243              	.LVL361:
 3244 1b14 9DFEFFEA 		b	.L284
 3245              	.LVL362:
 3246              	.L354:
2578:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 3247              		.loc 1 2578 0
 3248 1b18 88489FE5 		ldr	r4, .L463+64
 3249 1b1c 0010E0E3 		mvn	r1, #0
 3250 1b20 1C0094E5 		ldr	r0, [r4, #28]
 3251 1b24 14308DE5 		str	r3, [sp, #20]
 3252 1b28 FEFFFFEB 		bl	_txe_mutex_get
 3253              	.LVL363:
2579:../uvc.c      **** 							 {
 3254              		.loc 1 2579 0
 3255 1b2c 14309DE5 		ldr	r3, [sp, #20]
 3256 1b30 18109DE5 		ldr	r1, [sp, #24]
 3257 1b34 033187E0 		add	r3, r7, r3, asl #2
 3258 1b38 207093E5 		ldr	r7, [r3, #32]
 3259 1b3c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3260 1b40 010053E1 		cmp	r3, r1
 3261 1b44 F001001A 		bne	.L429
 3262 1b48 50589FE5 		ldr	r5, .L463+56
 3263              	.L365:
2585:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3264              		.loc 1 2585 0
 3265 1b4c 0E30D7E5 		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3266 1b50 1C209DE5 		ldr	r2, [sp, #28]
 3267 1b54 020053E1 		cmp	r3, r2
 3268 1b58 0500000A 		beq	.L367
2587:../uvc.c      **** 									 dataIdx++;
 3269              		.loc 1 2587 0
 3270 1b5c 18009DE5 		ldr	r0, [sp, #24]
2586:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 3271              		.loc 1 2586 0
 3272 1b60 0E20C7E5 		strb	r2, [r7, #14]
2587:../uvc.c      **** 									 dataIdx++;
 3273              		.loc 1 2587 0
 3274 1b64 023040E2 		sub	r3, r0, #2
 3275 1b68 FF3003E2 		and	r3, r3, #255
 3276 1b6c 010053E3 		cmp	r3, #1
 3277 1b70 D902009A 		bls	.L452
 3278              	.LVL364:
 3279              	.L367:
2592:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3280              		.loc 1 2592 0
 3281 1b74 0130A0E3 		mov	r3, #1
 3282 1b78 1130C7E5 		strb	r3, [r7, #17]
2593:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3283              		.loc 1 2593 0
 3284 1b7c 1C0094E5 		ldr	r0, [r4, #28]
 3285 1b80 FEFFFFEB 		bl	_txe_mutex_put
 3286              	.LVL365:
2595:../uvc.c      **** 							 break;
 3287              		.loc 1 2595 0
 3288 1b84 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
2594:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3289              		.loc 1 2594 0
 3290 1b88 18909DE5 		ldr	r9, [sp, #24]
 3291              	.LVL366:
2595:../uvc.c      **** 							 break;
 3292              		.loc 1 2595 0
 3293 1b8c 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3294 1b90 8115D5E5 		ldrb	r1, [r5, #1409]	@ zero_extendqisi2
2594:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3295              		.loc 1 2594 0
 3296 1b94 FF70A0E3 		mov	r7, #255
 3297 1b98 02028DE8 		stmia	sp, {r1, r9}
 3298 1b9c E8179FE5 		ldr	r1, .L463+36
 3299 1ba0 08708DE5 		str	r7, [sp, #8]
 3300 1ba4 0400A0E3 		mov	r0, #4
 3301 1ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 3302              	.LVL367:
2596:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 3303              		.loc 1 2596 0
 3304 1bac 07A0A0E1 		mov	r10, r7
 3305              	.LVL368:
 3306 1bb0 1C509DE5 		ldr	r5, [sp, #28]
 3307 1bb4 75FEFFEA 		b	.L284
 3308              	.LVL369:
 3309              	.L352:
2598:../uvc.c      **** 	#if 1	// register setting directly
 3310              		.loc 1 2598 0
 3311 1bb8 033187E0 		add	r3, r7, r3, asl #2
 3312 1bbc 203093E5 		ldr	r3, [r3, #32]
2600:../uvc.c      **** 						     {
 3313              		.loc 1 2600 0
 3314 1bc0 D8579FE5 		ldr	r5, .L463+56
2598:../uvc.c      **** 	#if 1	// register setting directly
 3315              		.loc 1 2598 0
 3316 1bc4 18109DE5 		ldr	r1, [sp, #24]
 3317 1bc8 0D10C3E5 		strb	r1, [r3, #13]
2600:../uvc.c      **** 						     {
 3318              		.loc 1 2600 0
 3319 1bcc 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3320 1bd0 030013E3 		tst	r3, #3
 3321 1bd4 1A00000A 		beq	.L369
2602:../uvc.c      **** 						    	 dataIdx = 0;
 3322              		.loc 1 2602 0
 3323 1bd8 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
2604:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3324              		.loc 1 2604 0
 3325 1bdc C4479FE5 		ldr	r4, .L463+64
2602:../uvc.c      **** 						    	 dataIdx = 0;
 3326              		.loc 1 2602 0
 3327 1be0 013283E1 		orr	r3, r3, r1, asl #4
 3328 1be4 FF3003E2 		and	r3, r3, #255
2604:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3329              		.loc 1 2604 0
 3330 1be8 0010E0E3 		mvn	r1, #0
 3331 1bec 1C0094E5 		ldr	r0, [r4, #28]
2602:../uvc.c      **** 						    	 dataIdx = 0;
 3332              		.loc 1 2602 0
 3333 1bf0 18308DE5 		str	r3, [sp, #24]
 3334              	.LVL370:
2604:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3335              		.loc 1 2604 0
 3336 1bf4 FEFFFFEB 		bl	_txe_mutex_get
 3337              	.LVL371:
2605:../uvc.c      **** 								 dataIdx++;
 3338              		.loc 1 2605 0
 3339 1bf8 0030A0E3 		mov	r3, #0
 3340 1bfc 0B20A0E1 		mov	r2, fp
 3341 1c00 00308DE5 		str	r3, [sp]
 3342 1c04 04308DE5 		str	r3, [sp, #4]
 3343 1c08 1010A0E3 		mov	r1, #16
 3344 1c0c 0930A0E1 		mov	r3, r9
 3345 1c10 0400A0E1 		mov	r0, r4
 3346 1c14 FEFFFFEB 		bl	cmdSet
 3347              	.LVL372:
2607:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3348              		.loc 1 2607 0
 3349 1c18 18209DE5 		ldr	r2, [sp, #24]
 3350 1c1c 0110A0E3 		mov	r1, #1
 3351 1c20 00208DE5 		str	r2, [sp]
 3352 1c24 04108DE5 		str	r1, [sp, #4]
 3353 1c28 0A20A0E1 		mov	r2, r10
 3354 1c2c 0930A0E1 		mov	r3, r9
 3355 1c30 0400A0E1 		mov	r0, r4
 3356 1c34 1010A0E3 		mov	r1, #16
 3357 1c38 FEFFFFEB 		bl	cmdSet
 3358              	.LVL373:
2608:../uvc.c      **** 						     }
 3359              		.loc 1 2608 0
 3360 1c3c 1C0094E5 		ldr	r0, [r4, #28]
 3361 1c40 FEFFFFEB 		bl	_txe_mutex_put
 3362              	.LVL374:
 3363              	.L369:
2611:../uvc.c      **** 						     break;
 3364              		.loc 1 2611 0
 3365 1c44 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
2610:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3366              		.loc 1 2610 0
 3367 1c48 18909DE5 		ldr	r9, [sp, #24]
 3368              	.LVL375:
2611:../uvc.c      **** 						     break;
 3369              		.loc 1 2611 0
 3370 1c4c 8135D5E5 		ldrb	r3, [r5, #1409]	@ zero_extendqisi2
2610:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3371              		.loc 1 2610 0
 3372 1c50 1C509DE5 		ldr	r5, [sp, #28]
 3373 1c54 0C008DE8 		stmia	sp, {r2, r3}
 3374 1c58 30179FE5 		ldr	r1, .L463+40
 3375 1c5c 0520A0E1 		mov	r2, r5
 3376 1c60 0930A0E1 		mov	r3, r9
 3377 1c64 0400A0E3 		mov	r0, #4
2612:../uvc.c      **** 	#else	// old fashion
 3378              		.loc 1 2612 0
 3379 1c68 FF70A0E3 		mov	r7, #255
2610:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3380              		.loc 1 2610 0
 3381 1c6c FEFFFFEB 		bl	CyU3PDebugPrint
 3382              	.LVL376:
2612:../uvc.c      **** 	#else	// old fashion
 3383              		.loc 1 2612 0
 3384 1c70 07A0A0E1 		mov	r10, r7
 3385              	.LVL377:
 3386 1c74 45FEFFEA 		b	.L284
 3387              	.LVL378:
 3388              	.L358:
2533:../uvc.c      **** 							 if(Data0 == 1){
 3389              		.loc 1 2533 0
 3390 1c78 033187E0 		add	r3, r7, r3, asl #2
 3391 1c7c 204093E5 		ldr	r4, [r3, #32]
2534:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3392              		.loc 1 2534 0
 3393 1c80 18009DE5 		ldr	r0, [sp, #24]
2535:../uvc.c      **** 							 }else{
 3394              		.loc 1 2535 0
 3395 1c84 14379FE5 		ldr	r3, .L463+56
2539:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3396              		.loc 1 2539 0
 3397 1c88 18579FE5 		ldr	r5, .L463+64
2533:../uvc.c      **** 							 if(Data0 == 1){
 3398              		.loc 1 2533 0
 3399 1c8c 0D00C4E5 		strb	r0, [r4, #13]
2535:../uvc.c      **** 							 }else{
 3400              		.loc 1 2535 0
 3401 1c90 6DB5D3E5 		ldrb	fp, [r3, #1389]	@ zero_extendqisi2
 3402              	.LVL379:
2534:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3403              		.loc 1 2534 0
 3404 1c94 010050E3 		cmp	r0, #1
2539:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3405              		.loc 1 2539 0
 3406 1c98 0010E0E3 		mvn	r1, #0
 3407 1c9c 1C0095E5 		ldr	r0, [r5, #28]
2535:../uvc.c      **** 							 }else{
 3408              		.loc 1 2535 0
 3409 1ca0 80B08B03 		orreq	fp, fp, #128
 3410              	.LVL380:
2537:../uvc.c      **** 							 }
 3411              		.loc 1 2537 0
 3412 1ca4 7FB00B12 		andne	fp, fp, #127
 3413              	.LVL381:
2539:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3414              		.loc 1 2539 0
 3415 1ca8 FEFFFFEB 		bl	_txe_mutex_get
 3416              	.LVL382:
2540:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3417              		.loc 1 2540 0
 3418 1cac 0010A0E3 		mov	r1, #0
 3419 1cb0 0930A0E1 		mov	r3, r9
 3420 1cb4 0A20A0E1 		mov	r2, r10
 3421 1cb8 0500A0E1 		mov	r0, r5
 3422 1cbc 04108DE5 		str	r1, [sp, #4]
 3423 1cc0 00B08DE5 		str	fp, [sp]
 3424 1cc4 2610A0E3 		mov	r1, #38
 3425 1cc8 FEFFFFEB 		bl	cmdSet
 3426              	.LVL383:
2541:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3427              		.loc 1 2541 0
 3428 1ccc 1C0095E5 		ldr	r0, [r5, #28]
 3429 1cd0 FEFFFFEB 		bl	_txe_mutex_put
 3430              	.LVL384:
2543:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3431              		.loc 1 2543 0
 3432 1cd4 FF70A0E3 		mov	r7, #255
2542:../uvc.c      **** 							 break;
 3433              		.loc 1 2542 0
 3434 1cd8 0130A0E3 		mov	r3, #1
 3435 1cdc 1C509DE5 		ldr	r5, [sp, #28]
 3436 1ce0 0B90A0E1 		mov	r9, fp
 3437              	.LVL385:
 3438 1ce4 1130C4E5 		strb	r3, [r4, #17]
 3439              	.LVL386:
2543:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3440              		.loc 1 2543 0
 3441 1ce8 07A0A0E1 		mov	r10, r7
 3442              	.LVL387:
 3443 1cec 27FEFFEA 		b	.L284
 3444              	.LVL388:
 3445              	.L383:
2837:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3446              		.loc 1 2837 0
 3447 1cf0 B0469FE5 		ldr	r4, .L463+64
 3448 1cf4 0010E0E3 		mvn	r1, #0
 3449 1cf8 1C0094E5 		ldr	r0, [r4, #28]
 3450 1cfc FEFFFFEB 		bl	_txe_mutex_get
 3451              	.LVL389:
2838:../uvc.c      **** 							 dataIdx++;
 3452              		.loc 1 2838 0
 3453 1d00 18209DE5 		ldr	r2, [sp, #24]
 3454 1d04 0030A0E3 		mov	r3, #0
 3455 1d08 00208DE5 		str	r2, [sp]
 3456 1d0c 04308DE5 		str	r3, [sp, #4]
 3457 1d10 0A20A0E1 		mov	r2, r10
 3458 1d14 0930A0E1 		mov	r3, r9
 3459 1d18 0B10A0E3 		mov	r1, #11
 3460 1d1c 0400A0E1 		mov	r0, r4
 3461 1d20 FEFFFFEB 		bl	cmdSet
 3462              	.LVL390:
2840:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3463              		.loc 1 2840 0
 3464 1d24 1C309DE5 		ldr	r3, [sp, #28]
 3465 1d28 0180A0E3 		mov	r8, #1
 3466              	.LVL391:
 3467 1d2c 0B20A0E1 		mov	r2, fp
 3468 1d30 0B10A0E3 		mov	r1, #11
 3469 1d34 00308DE5 		str	r3, [sp]
 3470 1d38 0400A0E1 		mov	r0, r4
 3471 1d3c 0930A0E1 		mov	r3, r9
 3472 1d40 04808DE5 		str	r8, [sp, #4]
 3473 1d44 FEFFFFEB 		bl	cmdSet
 3474              	.LVL392:
2845:../uvc.c      **** 							 break;
 3475              		.loc 1 2845 0
 3476 1d48 055187E0 		add	r5, r7, r5, asl #2
2841:../uvc.c      **** 
 3477              		.loc 1 2841 0
 3478 1d4c 1C0094E5 		ldr	r0, [r4, #28]
 3479 1d50 FEFFFFEB 		bl	_txe_mutex_put
 3480              	.LVL393:
2845:../uvc.c      **** 							 break;
 3481              		.loc 1 2845 0
 3482 1d54 202195E5 		ldr	r2, [r5, #288]
2843:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3483              		.loc 1 2843 0
 3484 1d58 40369FE5 		ldr	r3, .L463+56
 3485 1d5c 18009DE5 		ldr	r0, [sp, #24]
2844:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3486              		.loc 1 2844 0
 3487 1d60 1C109DE5 		ldr	r1, [sp, #28]
2846:../uvc.c      **** 						 case BLCCtlID0:
 3488              		.loc 1 2846 0
 3489 1d64 FF70A0E3 		mov	r7, #255
2845:../uvc.c      **** 							 break;
 3490              		.loc 1 2845 0
 3491 1d68 1180C2E5 		strb	r8, [r2, #17]
2843:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3492              		.loc 1 2843 0
 3493 1d6c 5C05C3E5 		strb	r0, [r3, #1372]
2844:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3494              		.loc 1 2844 0
 3495 1d70 5E15C3E5 		strb	r1, [r3, #1374]
 3496 1d74 0090A0E1 		mov	r9, r0
 3497              	.LVL394:
 3498 1d78 0150A0E1 		mov	r5, r1
2846:../uvc.c      **** 						 case BLCCtlID0:
 3499              		.loc 1 2846 0
 3500 1d7c 07A0A0E1 		mov	r10, r7
 3501              	.LVL395:
 3502 1d80 02FEFFEA 		b	.L284
 3503              	.LVL396:
 3504              	.L382:
2866:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3505              		.loc 1 2866 0
 3506 1d84 18009DE5 		ldr	r0, [sp, #24]
2865:../uvc.c      **** 							 if(Data0 != 0){
 3507              		.loc 1 2865 0
 3508 1d88 055187E0 		add	r5, r7, r5, asl #2
 3509 1d8c 204195E5 		ldr	r4, [r5, #288]
2867:../uvc.c      **** 	#ifdef COLOR
 3510              		.loc 1 2867 0
 3511 1d90 10569FE5 		ldr	r5, .L463+64
2866:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3512              		.loc 1 2866 0
 3513 1d94 000050E3 		cmp	r0, #0
2865:../uvc.c      **** 							 if(Data0 != 0){
 3514              		.loc 1 2865 0
 3515 1d98 0D00C4E5 		strb	r0, [r4, #13]
2867:../uvc.c      **** 	#ifdef COLOR
 3516              		.loc 1 2867 0
 3517 1d9c 0010E0E3 		mvn	r1, #0
 3518 1da0 1C0095E5 		ldr	r0, [r5, #28]
2866:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3519              		.loc 1 2866 0
 3520 1da4 A301000A 		beq	.L401
2867:../uvc.c      **** 	#ifdef COLOR
 3521              		.loc 1 2867 0
 3522 1da8 FEFFFFEB 		bl	_txe_mutex_get
 3523              	.LVL397:
2871:../uvc.c      **** 								 dataIdx++;
 3524              		.loc 1 2871 0
 3525 1dac 0170A0E3 		mov	r7, #1
 3526 1db0 0030A0E3 		mov	r3, #0
 3527 1db4 0A20A0E1 		mov	r2, r10
 3528 1db8 04308DE5 		str	r3, [sp, #4]
 3529 1dbc 0710A0E3 		mov	r1, #7
 3530 1dc0 0500A0E1 		mov	r0, r5
 3531 1dc4 00708DE5 		str	r7, [sp]
 3532 1dc8 0930A0E1 		mov	r3, r9
 3533 1dcc FEFFFFEB 		bl	cmdSet
 3534              	.LVL398:
2873:../uvc.c      **** 	#endif
 3535              		.loc 1 2873 0
 3536 1dd0 18109DE5 		ldr	r1, [sp, #24]
 3537 1dd4 0B20A0E1 		mov	r2, fp
 3538 1dd8 04708DE5 		str	r7, [sp, #4]
 3539 1ddc 00108DE5 		str	r1, [sp]
 3540              	.LVL399:
 3541              	.L437:
2878:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3542              		.loc 1 2878 0
 3543 1de0 0930A0E1 		mov	r3, r9
 3544 1de4 0500A0E1 		mov	r0, r5
 3545 1de8 0710A0E3 		mov	r1, #7
 3546 1dec FEFFFFEB 		bl	cmdSet
 3547              	.LVL400:
2879:../uvc.c      **** 							 }
 3548              		.loc 1 2879 0
 3549 1df0 1C0095E5 		ldr	r0, [r5, #28]
 3550 1df4 FEFFFFEB 		bl	_txe_mutex_put
 3551              	.LVL401:
2882:../uvc.c      **** 						 case ConsCtlID2:
 3552              		.loc 1 2882 0
 3553 1df8 FF70A0E3 		mov	r7, #255
2881:../uvc.c      **** 							 break;
 3554              		.loc 1 2881 0
 3555 1dfc 0130A0E3 		mov	r3, #1
 3556 1e00 18909DE5 		ldr	r9, [sp, #24]
 3557              	.LVL402:
 3558 1e04 1C509DE5 		ldr	r5, [sp, #28]
2882:../uvc.c      **** 						 case ConsCtlID2:
 3559              		.loc 1 2882 0
 3560 1e08 07A0A0E1 		mov	r10, r7
 3561              	.LVL403:
2881:../uvc.c      **** 							 break;
 3562              		.loc 1 2881 0
 3563 1e0c 1130C4E5 		strb	r3, [r4, #17]
 3564              	.LVL404:
2882:../uvc.c      **** 						 case ConsCtlID2:
 3565              		.loc 1 2882 0
 3566 1e10 DEFDFFEA 		b	.L284
 3567              	.LVL405:
 3568              	.L381:
2772:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3569              		.loc 1 2772 0
 3570 1e14 8C859FE5 		ldr	r8, .L463+64
 3571              	.LVL406:
 3572 1e18 0010E0E3 		mvn	r1, #0
 3573 1e1c 1C0098E5 		ldr	r0, [r8, #28]
 3574 1e20 FEFFFFEB 		bl	_txe_mutex_get
 3575              	.LVL407:
2773:../uvc.c      **** 							 dataIdx++;
 3576              		.loc 1 2773 0
 3577 1e24 18209DE5 		ldr	r2, [sp, #24]
 3578 1e28 0030A0E3 		mov	r3, #0
 3579 1e2c 801042E2 		sub	r1, r2, #128
 3580 1e30 FF1001E2 		and	r1, r1, #255
 3581 1e34 0A20A0E1 		mov	r2, r10
 3582 1e38 00108DE5 		str	r1, [sp]
 3583 1e3c 04308DE5 		str	r3, [sp, #4]
 3584 1e40 0510A0E3 		mov	r1, #5
 3585 1e44 0930A0E1 		mov	r3, r9
 3586 1e48 0800A0E1 		mov	r0, r8
 3587 1e4c FEFFFFEB 		bl	cmdSet
 3588              	.LVL408:
2775:../uvc.c      **** 							 dataIdx++;
 3589              		.loc 1 2775 0
 3590 1e50 18009DE5 		ldr	r0, [sp, #24]
 3591 1e54 01C0A0E3 		mov	ip, #1
 3592 1e58 763040E2 		sub	r3, r0, #118
 3593 1e5c FF3003E2 		and	r3, r3, #255
 3594 1e60 04C08DE5 		str	ip, [sp, #4]
 3595 1e64 00308DE5 		str	r3, [sp]
 3596 1e68 0510A0E3 		mov	r1, #5
 3597 1e6c 0930A0E1 		mov	r3, r9
 3598 1e70 DC20A0E3 		mov	r2, #220
 3599 1e74 0800A0E1 		mov	r0, r8
 3600 1e78 14C08DE5 		str	ip, [sp, #20]
 3601 1e7c FEFFFFEB 		bl	cmdSet
 3602              	.LVL409:
2777:../uvc.c      **** 							 dataIdx++;
 3603              		.loc 1 2777 0
 3604 1e80 18109DE5 		ldr	r1, [sp, #24]
 3605 1e84 0230A0E3 		mov	r3, #2
 3606 1e88 7E2081E2 		add	r2, r1, #126
 3607 1e8c FF2002E2 		and	r2, r2, #255
 3608 1e90 00208DE5 		str	r2, [sp]
 3609 1e94 04308DE5 		str	r3, [sp, #4]
 3610 1e98 0510A0E3 		mov	r1, #5
 3611 1e9c 0930A0E1 		mov	r3, r9
 3612 1ea0 DE20A0E3 		mov	r2, #222
 3613 1ea4 0800A0E1 		mov	r0, r8
 3614 1ea8 FEFFFFEB 		bl	cmdSet
 3615              	.LVL410:
2779:../uvc.c      **** 							 dataIdx++;
 3616              		.loc 1 2779 0
 3617 1eac 18309DE5 		ldr	r3, [sp, #24]
 3618 1eb0 0510A0E3 		mov	r1, #5
 3619 1eb4 722083E2 		add	r2, r3, #114
 3620 1eb8 FF2002E2 		and	r2, r2, #255
 3621 1ebc 0330A0E3 		mov	r3, #3
 3622 1ec0 00208DE5 		str	r2, [sp]
 3623 1ec4 04308DE5 		str	r3, [sp, #4]
 3624 1ec8 E020A0E3 		mov	r2, #224
 3625 1ecc 0930A0E1 		mov	r3, r9
 3626 1ed0 0800A0E1 		mov	r0, r8
 3627 1ed4 FEFFFFEB 		bl	cmdSet
 3628              	.LVL411:
2781:../uvc.c      **** 							 dataIdx++;
 3629              		.loc 1 2781 0
 3630 1ed8 18009DE5 		ldr	r0, [sp, #24]
 3631 1edc 0430A0E3 		mov	r3, #4
 3632 1ee0 6F2040E2 		sub	r2, r0, #111
 3633 1ee4 FF2002E2 		and	r2, r2, #255
 3634 1ee8 00208DE5 		str	r2, [sp]
 3635 1eec 04308DE5 		str	r3, [sp, #4]
 3636 1ef0 0510A0E3 		mov	r1, #5
 3637 1ef4 0930A0E1 		mov	r3, r9
 3638 1ef8 DD20A0E3 		mov	r2, #221
 3639 1efc 0800A0E1 		mov	r0, r8
 3640 1f00 FEFFFFEB 		bl	cmdSet
 3641              	.LVL412:
2783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3642              		.loc 1 2783 0
 3643 1f04 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3644 1f08 0510A0E3 		mov	r1, #5
 3645 1f0c 7F0080E2 		add	r0, r0, #127
 3646 1f10 FF0000E2 		and	r0, r0, #255
 3647 1f14 0930A0E1 		mov	r3, r9
 3648 1f18 0B20A0E1 		mov	r2, fp
 3649 1f1c 00008DE5 		str	r0, [sp]
 3650 1f20 04108DE5 		str	r1, [sp, #4]
 3651 1f24 0800A0E1 		mov	r0, r8
 3652 1f28 FEFFFFEB 		bl	cmdSet
 3653              	.LVL413:
2784:../uvc.c      **** 
 3654              		.loc 1 2784 0
 3655 1f2c 1C0098E5 		ldr	r0, [r8, #28]
 3656 1f30 FEFFFFEB 		bl	_txe_mutex_put
 3657              	.LVL414:
2786:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3658              		.loc 1 2786 0
 3659 1f34 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3660 1f38 055187E0 		add	r5, r7, r5, asl #2
 3661 1f3c 203195E5 		ldr	r3, [r5, #288]
 3662 1f40 802042E2 		sub	r2, r2, #128
 3663 1f44 FF2002E2 		and	r2, r2, #255
 3664 1f48 0D20C3E5 		strb	r2, [r3, #13]
2787:../uvc.c      **** 							 break;
 3665              		.loc 1 2787 0
 3666 1f4c 14C09DE5 		ldr	ip, [sp, #20]
2788:../uvc.c      **** 						 case MFreqCtlID4:
 3667              		.loc 1 2788 0
 3668 1f50 FF70A0E3 		mov	r7, #255
 3669 1f54 1C509DE5 		ldr	r5, [sp, #28]
 3670 1f58 18909DE5 		ldr	r9, [sp, #24]
 3671              	.LVL415:
 3672 1f5c 07A0A0E1 		mov	r10, r7
 3673              	.LVL416:
2787:../uvc.c      **** 							 break;
 3674              		.loc 1 2787 0
 3675 1f60 11C0C3E5 		strb	ip, [r3, #17]
2788:../uvc.c      **** 						 case MFreqCtlID4:
 3676              		.loc 1 2788 0
 3677 1f64 89FDFFEA 		b	.L284
 3678              	.LVL417:
 3679              	.L380:
2791:../uvc.c      **** 							 is60Hz = Data0;
 3680              		.loc 1 2791 0
 3681 1f68 18109DE5 		ldr	r1, [sp, #24]
2790:../uvc.c      **** 							 Data0 = Data0 - 1;
 3682              		.loc 1 2790 0
 3683 1f6c 055187E0 		add	r5, r7, r5, asl #2
 3684 1f70 208195E5 		ldr	r8, [r5, #288]
 3685              	.LVL418:
2791:../uvc.c      **** 							 is60Hz = Data0;
 3686              		.loc 1 2791 0
 3687 1f74 019041E2 		sub	r9, r1, #1
 3688              	.LVL419:
 3689 1f78 FF9009E2 		and	r9, r9, #255
 3690              	.LVL420:
2792:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3691              		.loc 1 2792 0
 3692 1f7c EC339FE5 		ldr	r3, .L463+8
2798:../uvc.c      **** 							 {
 3693              		.loc 1 2798 0
 3694 1f80 020059E3 		cmp	r9, #2
2790:../uvc.c      **** 							 Data0 = Data0 - 1;
 3695              		.loc 1 2790 0
 3696 1f84 0D10C8E5 		strb	r1, [r8, #13]
2792:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3697              		.loc 1 2792 0
 3698 1f88 6C9084E5 		str	r9, [r4, #108]
 3699              	.LVL421:
2801:../uvc.c      **** 							 }
 3700              		.loc 1 2801 0
 3701 1f8c 0190A083 		movhi	r9, #1
 3702 1f90 6C908385 		strhi	r9, [r3, #108]
 3703              	.LVL422:
2803:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3704              		.loc 1 2803 0
 3705 1f94 0920A0E1 		mov	r2, r9
 3706 1f98 6C3094E5 		ldr	r3, [r4, #108]
 3707 1f9c 0400A0E3 		mov	r0, #4
 3708 1fa0 EC139FE5 		ldr	r1, .L463+44
 3709 1fa4 FEFFFFEB 		bl	CyU3PDebugPrint
 3710              	.LVL423:
2804:../uvc.c      **** 							 {
 3711              		.loc 1 2804 0
 3712 1fa8 883094E5 		ldr	r3, [r4, #136]
2803:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3713              		.loc 1 2803 0
 3714 1fac BC239FE5 		ldr	r2, .L463+8
2804:../uvc.c      **** 							 {
 3715              		.loc 1 2804 0
 3716 1fb0 010053E3 		cmp	r3, #1
 3717 1fb4 2501000A 		beq	.L453
 3718              	.L387:
2832:../uvc.c      **** 							 break;
 3719              		.loc 1 2832 0
 3720 1fb8 0130A0E3 		mov	r3, #1
2833:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3721              		.loc 1 2833 0
 3722 1fbc FF70A0E3 		mov	r7, #255
 3723 1fc0 1C509DE5 		ldr	r5, [sp, #28]
2832:../uvc.c      **** 							 break;
 3724              		.loc 1 2832 0
 3725 1fc4 1130C8E5 		strb	r3, [r8, #17]
2833:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3726              		.loc 1 2833 0
 3727 1fc8 07A0A0E1 		mov	r10, r7
 3728              	.LVL424:
 3729 1fcc 6FFDFFEA 		b	.L284
 3730              	.LVL425:
 3731              	.L379:
2758:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3732              		.loc 1 2758 0
 3733 1fd0 D0439FE5 		ldr	r4, .L463+64
 3734 1fd4 0010E0E3 		mvn	r1, #0
 3735 1fd8 1C0094E5 		ldr	r0, [r4, #28]
 3736 1fdc FEFFFFEB 		bl	_txe_mutex_get
 3737              	.LVL426:
2760:../uvc.c      **** 									  Data0 = Data0 - 0x80;
 3738              		.loc 1 2760 0
 3739 1fe0 18309DE5 		ldr	r3, [sp, #24]
2765:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3740              		.loc 1 2765 0
 3741 1fe4 0010A0E3 		mov	r1, #0
2760:../uvc.c      **** 									  Data0 = Data0 - 0x80;
 3742              		.loc 1 2760 0
 3743 1fe8 800013E3 		tst	r3, #128
 3744 1fec 0300A001 		moveq	r0, r3
2761:../uvc.c      **** 								  }else{
 3745              		.loc 1 2761 0
 3746 1ff0 80804312 		subne	r8, r3, #128
 3747              	.LVL427:
2765:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3748              		.loc 1 2765 0
 3749 1ff4 0B20A0E1 		mov	r2, fp
 3750 1ff8 0930A0E1 		mov	r3, r9
 3751 1ffc 04108DE5 		str	r1, [sp, #4]
 3752 2000 0110A0E3 		mov	r1, #1
2768:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3753              		.loc 1 2768 0
 3754 2004 055187E0 		add	r5, r7, r5, asl #2
2770:../uvc.c      **** 						 case HueCtlID5://not being used
 3755              		.loc 1 2770 0
 3756 2008 FF70A0E3 		mov	r7, #255
 3757 200c 07A0A0E1 		mov	r10, r7
 3758              	.LVL428:
2763:../uvc.c      **** 								  }
 3759              		.loc 1 2763 0
 3760 2010 0080E001 		mvneq	r8, r0
 3761 2014 FF8008E2 		and	r8, r8, #255
 3762              	.LVL429:
2765:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3763              		.loc 1 2765 0
 3764 2018 00808DE5 		str	r8, [sp]
 3765 201c 84039FE5 		ldr	r0, .L463+64
 3766 2020 FEFFFFEB 		bl	cmdSet
 3767              	.LVL430:
2766:../uvc.c      **** 
 3768              		.loc 1 2766 0
 3769 2024 1C0094E5 		ldr	r0, [r4, #28]
 3770 2028 FEFFFFEB 		bl	_txe_mutex_put
 3771              	.LVL431:
2768:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3772              		.loc 1 2768 0
 3773 202c 203195E5 		ldr	r3, [r5, #288]
2769:../uvc.c      **** 							 break;
 3774              		.loc 1 2769 0
 3775 2030 0120A0E3 		mov	r2, #1
2768:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3776              		.loc 1 2768 0
 3777 2034 0D80C3E5 		strb	r8, [r3, #13]
 3778 2038 1C509DE5 		ldr	r5, [sp, #28]
 3779 203c 0890A0E1 		mov	r9, r8
 3780              	.LVL432:
2769:../uvc.c      **** 							 break;
 3781              		.loc 1 2769 0
 3782 2040 1120C3E5 		strb	r2, [r3, #17]
2770:../uvc.c      **** 						 case HueCtlID5://not being used
 3783              		.loc 1 2770 0
 3784 2044 51FDFFEA 		b	.L284
 3785              	.LVL433:
 3786              	.L377:
2848:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3787              		.loc 1 2848 0
 3788 2048 055187E0 		add	r5, r7, r5, asl #2
 3789 204c 204195E5 		ldr	r4, [r5, #288]
 3790 2050 18209DE5 		ldr	r2, [sp, #24]
2858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3791              		.loc 1 2858 0
 3792 2054 4C539FE5 		ldr	r5, .L463+64
2848:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3793              		.loc 1 2848 0
 3794 2058 0D20C4E5 		strb	r2, [r4, #13]
2858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3795              		.loc 1 2858 0
 3796 205c 0010E0E3 		mvn	r1, #0
 3797 2060 1C0095E5 		ldr	r0, [r5, #28]
 3798 2064 FEFFFFEB 		bl	_txe_mutex_get
 3799              	.LVL434:
2859:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3800              		.loc 1 2859 0
 3801 2068 18309DE5 		ldr	r3, [sp, #24]
 3802 206c 0010A0E3 		mov	r1, #0
 3803 2070 0A20A0E1 		mov	r2, r10
 3804 2074 00308DE5 		str	r3, [sp]
 3805 2078 0500A0E1 		mov	r0, r5
 3806 207c 0930A0E1 		mov	r3, r9
 3807 2080 04108DE5 		str	r1, [sp, #4]
 3808 2084 FEFFFFEB 		bl	cmdSet
 3809              	.LVL435:
2860:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3810              		.loc 1 2860 0
 3811 2088 1C0095E5 		ldr	r0, [r5, #28]
 3812 208c FEFFFFEB 		bl	_txe_mutex_put
 3813              	.LVL436:
2862:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3814              		.loc 1 2862 0
 3815 2090 FF70A0E3 		mov	r7, #255
2861:../uvc.c      **** 					 		 break;
 3816              		.loc 1 2861 0
 3817 2094 0130A0E3 		mov	r3, #1
 3818 2098 1C509DE5 		ldr	r5, [sp, #28]
 3819 209c 18909DE5 		ldr	r9, [sp, #24]
 3820              	.LVL437:
2862:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3821              		.loc 1 2862 0
 3822 20a0 07A0A0E1 		mov	r10, r7
 3823              	.LVL438:
2861:../uvc.c      **** 					 		 break;
 3824              		.loc 1 2861 0
 3825 20a4 1130C4E5 		strb	r3, [r4, #17]
 3826              	.LVL439:
2862:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3827              		.loc 1 2862 0
 3828 20a8 38FDFFEA 		b	.L284
 3829              	.LVL440:
 3830              	.L356:
2562:../uvc.c      **** 					 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3831              		.loc 1 2562 0 discriminator 1
 3832 20ac 000058E3 		cmp	r8, #0
 3833 20b0 0300000A 		beq	.L364
 3834 20b4 BC029FE5 		ldr	r0, .L463+16
 3835 20b8 0820A0E1 		mov	r2, r8
 3836 20bc 6C1080E2 		add	r1, r0, #108
 3837 20c0 FEFFFFEB 		bl	memcpy
 3838              	.LVL441:
 3839              	.L364:
2572:../uvc.c      **** 					 		 {
 3840              		.loc 1 2572 0
 3841 20c4 9F20D4E5 		ldrb	r2, [r4, #159]	@ zero_extendqisi2
2565:../uvc.c      **** 					 		 sendData1 = glEp0Buffer[10];
 3842              		.loc 1 2565 0
 3843 20c8 A0329FE5 		ldr	r3, .L463+8
2572:../uvc.c      **** 					 		 {
 3844              		.loc 1 2572 0
 3845 20cc FF0052E3 		cmp	r2, #255
2565:../uvc.c      **** 					 		 sendData1 = glEp0Buffer[10];
 3846              		.loc 1 2565 0
 3847 20d0 31A0D4E5 		ldrb	r10, [r4, #49]	@ zero_extendqisi2
 3848              	.LVL442:
2566:../uvc.c      **** 		#ifdef USB_DEBUG_PRINT
 3849              		.loc 1 2566 0
 3850 20d4 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3851              	.LVL443:
2572:../uvc.c      **** 					 		 {
 3852              		.loc 1 2572 0
 3853 20d8 0400000A 		beq	.L439
2574:../uvc.c      **** 					 		 }
 3854              		.loc 1 2574 0
 3855 20dc 9D20D3E5 		ldrb	r2, [r3, #157]	@ zero_extendqisi2
 3856 20e0 0400A0E3 		mov	r0, #4
 3857 20e4 98129FE5 		ldr	r1, .L463+28
 3858 20e8 9E30D3E5 		ldrb	r3, [r3, #158]	@ zero_extendqisi2
 3859 20ec FEFFFFEB 		bl	CyU3PDebugPrint
 3860              	.LVL444:
 3861              	.L439:
 3862 20f0 18909DE5 		ldr	r9, [sp, #24]
 3863              	.LVL445:
 3864 20f4 1C509DE5 		ldr	r5, [sp, #28]
 3865 20f8 24FDFFEA 		b	.L284
 3866              	.LVL446:
 3867              	.L306:
1806:../uvc.c      **** 			 	 			 if(Len == 2)
 3868              		.loc 1 1806 0
 3869 20fc 003084E0 		add	r3, r4, r0
 3870 2100 A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3871 2104 000053E3 		cmp	r3, #0
 3872 2108 4A00000A 		beq	.L323
1807:../uvc.c      **** 			 	 			 {
 3873              		.loc 1 1807 0
 3874 210c 020058E3 		cmp	r8, #2
 3875 2110 6101000A 		beq	.L454
1813:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3876              		.loc 1 1813 0
 3877 2114 040058E3 		cmp	r8, #4
 3878 2118 6C01000A 		beq	.L455
 3879              	.L325:
1699:../uvc.c      **** 					 case MFreqCtlID4:
 3880              		.loc 1 1699 0
 3881 211c FF70A0E3 		mov	r7, #255
 3882 2120 07A0A0E1 		mov	r10, r7
 3883              	.LVL447:
 3884 2124 0090A0E3 		mov	r9, #0
 3885              	.LVL448:
 3886 2128 DFFDFFEA 		b	.L292
 3887              	.LVL449:
 3888              	.L286:
1615:../uvc.c      **** 			 	 			 if(Len == 2)
 3889              		.loc 1 1615 0
 3890 212c 3C429FE5 		ldr	r4, .L463+8
 3891 2130 003084E0 		add	r3, r4, r0
 3892 2134 A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3893 2138 000053E3 		cmp	r3, #0
 3894 213c 3200000A 		beq	.L301
1616:../uvc.c      **** 			 	 			 {
 3895              		.loc 1 1616 0
 3896 2140 020058E3 		cmp	r8, #2
 3897 2144 5E01000A 		beq	.L456
1622:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3898              		.loc 1 1622 0
 3899 2148 040058E3 		cmp	r8, #4
 3900 214c F2FFFF1A 		bne	.L325
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3901              		.loc 1 1623 0
 3902 2150 005187E0 		add	r5, r7, r0, asl #2
 3903 2154 202015E5 		ldr	r2, [r5, #-32]
 3904              	.L433:
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3905              		.loc 1 1814 0
 3906 2158 0DA0D2E5 		ldrb	r10, [r2, #13]	@ zero_extendqisi2
 3907              	.LVL450:
1815:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3908              		.loc 1 1815 0
 3909 215c 0030A0E3 		mov	r3, #0
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3910              		.loc 1 1814 0
 3911 2160 FFA00AE2 		and	r10, r10, #255
1815:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3912              		.loc 1 1815 0
 3913 2164 2930C4E5 		strb	r3, [r4, #41]
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3914              		.loc 1 1814 0
 3915 2168 28A0C4E5 		strb	r10, [r4, #40]
1816:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3916              		.loc 1 1816 0
 3917 216c 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3918 2170 0390A0E1 		mov	r9, r3
 3919              	.LVL451:
 3920 2174 FF7007E2 		and	r7, r7, #255
 3921 2178 2A70C4E5 		strb	r7, [r4, #42]
1817:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3922              		.loc 1 1817 0
 3923 217c 2B30C4E5 		strb	r3, [r4, #43]
 3924              	.LVL452:
 3925 2180 C9FDFFEA 		b	.L292
 3926              	.LVL453:
 3927              	.L376:
2887:../uvc.c      **** 			 	 			 {
 3928              		.loc 1 2887 0
 3929 2184 020058E3 		cmp	r8, #2
 3930 2188 0F01000A 		beq	.L457
2897:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3931              		.loc 1 2897 0
 3932 218c 040058E3 		cmp	r8, #4
 3933 2190 5A01000A 		beq	.L406
 3934 2194 055187E0 		add	r5, r7, r5, asl #2
 3935 2198 207195E5 		ldr	r7, [r5, #288]
 3936              	.LVL454:
 3937              	.L405:
2914:../uvc.c      **** 			 	 			 break;
 3938              		.loc 1 2914 0
 3939 219c 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
2913:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3940              		.loc 1 2913 0
 3941 21a0 18909DE5 		ldr	r9, [sp, #24]
 3942              	.LVL455:
2914:../uvc.c      **** 			 	 			 break;
 3943              		.loc 1 2914 0
 3944 21a4 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
2913:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3945              		.loc 1 2913 0
 3946 21a8 1C509DE5 		ldr	r5, [sp, #28]
 3947 21ac 0C018DE8 		stmia	sp, {r2, r3, r8}
 3948 21b0 E0119FE5 		ldr	r1, .L463+48
 3949 21b4 0920A0E1 		mov	r2, r9
 3950 21b8 0530A0E1 		mov	r3, r5
 3951 21bc 0400A0E3 		mov	r0, #4
2915:../uvc.c      **** 					 }
 3952              		.loc 1 2915 0
 3953 21c0 FF70A0E3 		mov	r7, #255
2913:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3954              		.loc 1 2913 0
 3955 21c4 FEFFFFEB 		bl	CyU3PDebugPrint
 3956              	.LVL456:
2915:../uvc.c      **** 					 }
 3957              		.loc 1 2915 0
 3958 21c8 07A0A0E1 		mov	r10, r7
 3959              	.LVL457:
 3960 21cc EFFCFFEA 		b	.L284
 3961              	.LVL458:
 3962              	.L351:
2701:../uvc.c      **** 				 	 			 {
 3963              		.loc 1 2701 0
 3964 21d0 020058E3 		cmp	r8, #2
 3965 21d4 1701000A 		beq	.L458
2711:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3966              		.loc 1 2711 0
 3967 21d8 040058E3 		cmp	r8, #4
 3968 21dc 6B01000A 		beq	.L373
 3969 21e0 033187E0 		add	r3, r7, r3, asl #2
 3970 21e4 207093E5 		ldr	r7, [r3, #32]
 3971 21e8 EBFFFFEA 		b	.L405
 3972              	.LVL459:
 3973              	.L347:
2919:../uvc.c      **** 			   }
 3974              		.loc 1 2919 0
 3975 21ec 0400A0E3 		mov	r0, #4
 3976              	.LVL460:
 3977 21f0 A4119FE5 		ldr	r1, .L463+52
 3978 21f4 FEFFFFEB 		bl	CyU3PDebugPrint
 3979              	.LVL461:
 3980 21f8 FF70A0E3 		mov	r7, #255
 3981 21fc 0090A0E3 		mov	r9, #0
 3982              	.LVL462:
 3983 2200 07A0A0E1 		mov	r10, r7
 3984              	.LVL463:
 3985 2204 0950A0E1 		mov	r5, r9
 3986 2208 E0FCFFEA 		b	.L284
 3987              	.LVL464:
 3988              	.L301:
1631:../uvc.c      **** 			 	 			 {
 3989              		.loc 1 1631 0
 3990 220c 020058E3 		cmp	r8, #2
 3991 2210 6701000A 		beq	.L459
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 3992              		.loc 1 1639 0
 3993 2214 040058E3 		cmp	r8, #4
 3994 2218 FF70A013 		movne	r7, #255
 3995 221c 07A0A011 		movne	r10, r7
 3996              	.LVL465:
 3997 2220 7F01000A 		beq	.L460
 3998              	.LVL466:
 3999              	.L305:
1649:../uvc.c      **** 			 	 		 }
 4000              		.loc 1 1649 0
 4001 2224 055084E0 		add	r5, r4, r5
 4002 2228 0130A0E3 		mov	r3, #1
 4003 222c A030C5E5 		strb	r3, [r5, #160]
 4004              	.L434:
 4005 2230 0090A0E3 		mov	r9, #0
 4006              	.LVL467:
 4007 2234 9CFDFFEA 		b	.L292
 4008              	.LVL468:
 4009              	.L323:
1822:../uvc.c      **** 			 	 			 {
 4010              		.loc 1 1822 0
 4011 2238 020058E3 		cmp	r8, #2
 4012 223c 6A01000A 		beq	.L461
1830:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4013              		.loc 1 1830 0
 4014 2240 040058E3 		cmp	r8, #4
 4015 2244 FF70A013 		movne	r7, #255
 4016 2248 07A0A011 		movne	r10, r7
 4017              	.LVL469:
 4018 224c 8801000A 		beq	.L462
 4019              	.LVL470:
 4020              	.L327:
1840:../uvc.c      **** 			 	 		 }
 4021              		.loc 1 1840 0
 4022 2250 055084E0 		add	r5, r4, r5
 4023 2254 0130A0E3 		mov	r3, #1
 4024 2258 0090A0E3 		mov	r9, #0
 4025              	.LVL471:
 4026 225c A030C5E5 		strb	r3, [r5, #160]
 4027 2260 91FDFFEA 		b	.L292
 4028              	.LVL472:
 4029              	.L321:
1727:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4030              		.loc 1 1727 0
 4031 2264 0A00A0E1 		mov	r0, r10
 4032              	.LVL473:
 4033 2268 0910A0E1 		mov	r1, r9
 4034 226c FEFFFFEB 		bl	SensorGetControl
 4035              	.LVL474:
1728:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4036              		.loc 1 1728 0
 4037 2270 0910A0E1 		mov	r1, r9
1727:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4038              		.loc 1 1727 0
 4039 2274 0020A0E1 		mov	r2, r0
 4040              	.LVL475:
1728:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4041              		.loc 1 1728 0
 4042 2278 0B00A0E1 		mov	r0, fp
 4043              	.LVL476:
 4044 227c 14208DE5 		str	r2, [sp, #20]
 4045 2280 FEFFFFEB 		bl	SensorGetControl
 4046              	.LVL477:
1733:../uvc.c      **** 						 }
 4047              		.loc 1 1733 0
 4048 2284 14209DE5 		ldr	r2, [sp, #20]
1730:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4049              		.loc 1 1730 0
 4050 2288 10319FE5 		ldr	r3, .L463+56
1733:../uvc.c      **** 						 }
 4051              		.loc 1 1733 0
 4052 228c 0110A0E3 		mov	r1, #1
 4053 2290 02A0A0E1 		mov	r10, r2
 4054              	.LVL478:
1729:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4055              		.loc 1 1729 0
 4056 2294 2820C4E5 		strb	r2, [r4, #40]
1730:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4057              		.loc 1 1730 0
 4058 2298 5C25C3E5 		strb	r2, [r3, #1372]
1733:../uvc.c      **** 						 }
 4059              		.loc 1 1733 0
 4060 229c AB10C4E5 		strb	r1, [r4, #171]
1728:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4061              		.loc 1 1728 0
 4062 22a0 18008DE5 		str	r0, [sp, #24]
 4063              	.LVL479:
1733:../uvc.c      **** 						 }
 4064              		.loc 1 1733 0
 4065 22a4 0070A0E1 		mov	r7, r0
1731:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4066              		.loc 1 1731 0
 4067 22a8 2A00C4E5 		strb	r0, [r4, #42]
1732:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4068              		.loc 1 1732 0
 4069 22ac 5E05C3E5 		strb	r0, [r3, #1374]
 4070 22b0 DDFDFFEA 		b	.L322
 4071              	.LVL480:
 4072              	.L296:
1344:../uvc.c      **** 							if(Data0&0x80)
 4073              		.loc 1 1344 0
 4074 22b4 0A00A0E1 		mov	r0, r10
 4075              	.LVL481:
 4076 22b8 0910A0E1 		mov	r1, r9
 4077 22bc FEFFFFEB 		bl	SensorGetControl
 4078              	.LVL482:
1349:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4079              		.loc 1 1349 0
 4080 22c0 D8109FE5 		ldr	r1, .L463+56
1351:../uvc.c      **** 						 }
 4081              		.loc 1 1351 0
 4082 22c4 0130A0E3 		mov	r3, #1
 4083 22c8 0570A0E1 		mov	r7, r5
1350:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4084              		.loc 1 1350 0
 4085 22cc 2950C4E5 		strb	r5, [r4, #41]
1351:../uvc.c      **** 						 }
 4086              		.loc 1 1351 0
 4087 22d0 C630C4E5 		strb	r3, [r4, #198]
1345:../uvc.c      **** 								glEp0Buffer[0] = 1;
 4088              		.loc 1 1345 0
 4089 22d4 FFA000E2 		and	r10, r0, #255
 4090              	.LVL483:
1346:../uvc.c      **** 							else
 4091              		.loc 1 1346 0
 4092 22d8 AAA3A0E1 		mov	r10, r10, lsr #7
1344:../uvc.c      **** 							if(Data0&0x80)
 4093              		.loc 1 1344 0
 4094 22dc 0020A0E1 		mov	r2, r0
 4095              	.LVL484:
 4096 22e0 28A0C4E5 		strb	r10, [r4, #40]
1349:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4097              		.loc 1 1349 0
 4098 22e4 05A5C1E5 		strb	r10, [r1, #1285]
 4099 22e8 6EFDFFEA 		b	.L320
 4100              	.LVL485:
 4101              	.L312:
1673:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4102              		.loc 1 1673 0
 4103 22ec 0A00A0E1 		mov	r0, r10
 4104              	.LVL486:
 4105 22f0 0910A0E1 		mov	r1, r9
 4106 22f4 FEFFFFEB 		bl	SensorGetControl
 4107              	.LVL487:
1674:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4108              		.loc 1 1674 0
 4109 22f8 A0209FE5 		ldr	r2, .L463+56
1675:../uvc.c      **** 						 }
 4110              		.loc 1 1675 0
 4111 22fc 0130A0E3 		mov	r3, #1
 4112 2300 A130C4E5 		strb	r3, [r4, #161]
1674:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4113              		.loc 1 1674 0
 4114 2304 2D05C2E5 		strb	r0, [r2, #1325]
 4115 2308 98FDFFEA 		b	.L313
 4116              	.LVL488:
 4117              	.L429:
2582:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4118              		.loc 1 2582 0
 4119 230c 8C509FE5 		ldr	r5, .L463+56
2581:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4120              		.loc 1 2581 0
 4121 2310 0D10C7E5 		strb	r1, [r7, #13]
2582:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4122              		.loc 1 2582 0
 4123 2314 8125D5E5 		ldrb	r2, [r5, #1409]	@ zero_extendqisi2
2583:../uvc.c      **** 							 }
 4124              		.loc 1 2583 0
 4125 2318 0030A0E3 		mov	r3, #0
2582:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4126              		.loc 1 2582 0
 4127 231c 022281E1 		orr	r2, r1, r2, asl #4
 4128 2320 FF2002E2 		and	r2, r2, #255
 4129 2324 18208DE5 		str	r2, [sp, #24]
 4130              	.LVL489:
2583:../uvc.c      **** 							 }
 4131              		.loc 1 2583 0
 4132 2328 18109DE5 		ldr	r1, [sp, #24]
 4133 232c 0A20A0E1 		mov	r2, r10
 4134 2330 0A008DE8 		stmia	sp, {r1, r3}
 4135 2334 0400A0E1 		mov	r0, r4
 4136 2338 1910A0E3 		mov	r1, #25
 4137 233c 0930A0E1 		mov	r3, r9
 4138 2340 FEFFFFEB 		bl	cmdSet
 4139              	.LVL490:
 4140 2344 00FEFFEA 		b	.L365
 4141              	.LVL491:
 4142              	.L316:
1691:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4143              		.loc 1 1691 0
 4144 2348 0A00A0E1 		mov	r0, r10
 4145              	.LVL492:
 4146 234c 0910A0E1 		mov	r1, r9
 4147 2350 FEFFFFEB 		bl	SensorGetControl
 4148              	.LVL493:
1692:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4149              		.loc 1 1692 0
 4150 2354 44209FE5 		ldr	r2, .L463+56
1693:../uvc.c      **** 						 }
 4151              		.loc 1 1693 0
 4152 2358 0130A0E3 		mov	r3, #1
 4153 235c A530C4E5 		strb	r3, [r4, #165]
1692:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4154              		.loc 1 1692 0
 4155 2360 4105C2E5 		strb	r0, [r2, #1345]
 4156 2364 BBFDFFEA 		b	.L317
 4157              	.L464:
 4158              		.align	2
 4159              	.L463:
 4160 2368 00000000 		.word	.LANCHOR2
 4161 236c 00000000 		.word	bRequest
 4162 2370 00000000 		.word	.LANCHOR0
 4163 2374 68040000 		.word	.LC27
 4164 2378 28000000 		.word	.LANCHOR0+40
 4165 237c DC050000 		.word	.LC34
 4166 2380 38040000 		.word	.LC26
 4167 2384 FC030000 		.word	.LC25
 4168 2388 D4030000 		.word	.LC24
 4169 238c B4040000 		.word	.LC28
 4170 2390 E8040000 		.word	.LC29
 4171 2394 68050000 		.word	.LC31
 4172 2398 14050000 		.word	.LC30
 4173 239c AC050000 		.word	.LC33
 4174 23a0 00000000 		.word	.LANCHOR1
 4175 23a4 88050000 		.word	.LC32
 4176 23a8 00000000 		.word	cmdQu
 4177              	.LVL494:
 4178              	.L318:
1711:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4179              		.loc 1 1711 0
 4180 23ac 0910A0E1 		mov	r1, r9
 4181 23b0 0100A0E3 		mov	r0, #1
 4182              	.LVL495:
 4183 23b4 FEFFFFEB 		bl	SensorGetControl
 4184              	.LVL496:
1714:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4185              		.loc 1 1714 0
 4186 23b8 20101FE5 		ldr	r1, .L463+56
1712:../uvc.c      **** 							glEp0Buffer[0]++;
 4187              		.loc 1 1712 0
 4188 23bc A033A0E1 		mov	r3, r0, lsr #7
1713:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4189              		.loc 1 1713 0
 4190 23c0 013083E2 		add	r3, r3, #1
 4191 23c4 FF3003E2 		and	r3, r3, #255
1714:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4192              		.loc 1 1714 0
 4193 23c8 5535C1E5 		strb	r3, [r1, #1365]
1715:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4194              		.loc 1 1715 0
 4195 23cc 5615D1E5 		ldrb	r1, [r1, #1366]	@ zero_extendqisi2
1711:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4196              		.loc 1 1711 0
 4197 23d0 0020A0E1 		mov	r2, r0
 4198              	.LVL497:
1715:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4199              		.loc 1 1715 0
 4200 23d4 FF1001E2 		and	r1, r1, #255
1716:../uvc.c      **** 						 }
 4201              		.loc 1 1716 0
 4202 23d8 0100A0E3 		mov	r0, #1
 4203              	.LVL498:
 4204 23dc 03A0A0E1 		mov	r10, r3
 4205              	.LVL499:
 4206 23e0 0170A0E1 		mov	r7, r1
1713:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4207              		.loc 1 1713 0
 4208 23e4 2830C4E5 		strb	r3, [r4, #40]
1715:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4209              		.loc 1 1715 0
 4210 23e8 2910C4E5 		strb	r1, [r4, #41]
1716:../uvc.c      **** 						 }
 4211              		.loc 1 1716 0
 4212 23ec A400C4E5 		strb	r0, [r4, #164]
 4213 23f0 2CFDFFEA 		b	.L320
 4214              	.LVL500:
 4215              	.L298:
1361:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4216              		.loc 1 1361 0
 4217 23f4 0A00A0E1 		mov	r0, r10
 4218              	.LVL501:
 4219 23f8 0910A0E1 		mov	r1, r9
 4220 23fc FEFFFFEB 		bl	SensorGetControl
 4221              	.LVL502:
1363:../uvc.c      **** 
 4222              		.loc 1 1363 0
 4223 2400 68501FE5 		ldr	r5, .L463+56
1365:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4224              		.loc 1 1365 0
 4225 2404 0910A0E1 		mov	r1, r9
1362:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4226              		.loc 1 1362 0
 4227 2408 033000E2 		and	r3, r0, #3
1365:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4228              		.loc 1 1365 0
 4229 240c 0B00A0E1 		mov	r0, fp
1362:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4230              		.loc 1 1362 0
 4231 2410 2830C4E5 		strb	r3, [r4, #40]
1363:../uvc.c      **** 
 4232              		.loc 1 1363 0
 4233 2414 1935C5E5 		strb	r3, [r5, #1305]
1365:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4234              		.loc 1 1365 0
 4235 2418 FEFFFFEB 		bl	SensorGetControl
 4236              	.LVL503:
1367:../uvc.c      **** 			 	 		 }
 4237              		.loc 1 1367 0
 4238 241c 0130A0E3 		mov	r3, #1
 4239 2420 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4240              	.LVL504:
 4241 2424 B930C4E5 		strb	r3, [r4, #185]
 4242 2428 0070A0E1 		mov	r7, r0
1365:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4243              		.loc 1 1365 0
 4244 242c 2A00C4E5 		strb	r0, [r4, #42]
1366:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4245              		.loc 1 1366 0
 4246 2430 1A05C5E5 		strb	r0, [r5, #1306]
 4247 2434 63FDFFEA 		b	.L299
 4248              	.LVL505:
 4249              	.L401:
2877:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4250              		.loc 1 2877 0
 4251 2438 FEFFFFEB 		bl	_txe_mutex_get
 4252              	.LVL506:
2878:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4253              		.loc 1 2878 0
 4254 243c 18209DE5 		ldr	r2, [sp, #24]
 4255 2440 00208DE5 		str	r2, [sp]
 4256 2444 04208DE5 		str	r2, [sp, #4]
 4257 2448 0A20A0E1 		mov	r2, r10
 4258 244c 63FEFFEA 		b	.L437
 4259              	.LVL507:
 4260              	.L453:
2806:../uvc.c      **** 			                         {
 4261              		.loc 1 2806 0
 4262 2450 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4263 2454 013043E2 		sub	r3, r3, #1
 4264 2458 030053E3 		cmp	r3, #3
 4265 245c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4266 2460 D4FEFFEA 		b	.L387
 4267              	.L389:
 4268 2464 80250000 		.word	.L388
 4269 2468 34250000 		.word	.L390
 4270 246c D4240000 		.word	.L391
 4271 2470 74240000 		.word	.L392
 4272              	.L392:
2824:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4273              		.loc 1 2824 0
 4274 2474 DC501FE5 		ldr	r5, .L463+56
 4275 2478 6C2094E5 		ldr	r2, [r4, #108]
 4276 247c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4277 2480 000052E3 		cmp	r2, #0
 4278 2484 F420A003 		moveq	r2, #244
 4279 2488 7420A013 		movne	r2, #116
 4280 248c 032082E1 		orr	r2, r2, r3
 4281 2490 3010A0E3 		mov	r1, #48
 4282 2494 5230A0E3 		mov	r3, #82
 4283 2498 0100A0E3 		mov	r0, #1
 4284 249c FEFFFFEB 		bl	SensorSetIrisControl
 4285              	.LVL508:
2825:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4286              		.loc 1 2825 0
 4287 24a0 7D0FA0E3 		mov	r0, #500
 4288 24a4 FEFFFFEB 		bl	_tx_thread_sleep
 4289              	.LVL509:
2826:../uvc.c      **** 			                         	default:
 4290              		.loc 1 2826 0
 4291 24a8 6C1094E5 		ldr	r1, [r4, #108]
 4292 24ac 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4293 24b0 000051E3 		cmp	r1, #0
 4294 24b4 F410A003 		moveq	r1, #244
 4295 24b8 7410A013 		movne	r1, #116
 4296 24bc 022081E1 		orr	r2, r1, r2
 4297 24c0 6C3094E5 		ldr	r3, [r4, #108]
 4298 24c4 28111FE5 		ldr	r1, .L463+60
 4299 24c8 0400A0E3 		mov	r0, #4
 4300 24cc FEFFFFEB 		bl	CyU3PDebugPrint
 4301              	.LVL510:
 4302 24d0 B8FEFFEA 		b	.L387
 4303              	.L391:
2819:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4304              		.loc 1 2819 0
 4305 24d4 3C511FE5 		ldr	r5, .L463+56
 4306 24d8 6C2094E5 		ldr	r2, [r4, #108]
 4307 24dc 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4308 24e0 000052E3 		cmp	r2, #0
 4309 24e4 C420A003 		moveq	r2, #196
 4310 24e8 4420A013 		movne	r2, #68
 4311 24ec 032082E1 		orr	r2, r2, r3
 4312 24f0 3010A0E3 		mov	r1, #48
 4313 24f4 5230A0E3 		mov	r3, #82
 4314 24f8 0100A0E3 		mov	r0, #1
 4315 24fc FEFFFFEB 		bl	SensorSetIrisControl
 4316              	.LVL511:
2820:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4317              		.loc 1 2820 0
 4318 2500 7D0FA0E3 		mov	r0, #500
 4319 2504 FEFFFFEB 		bl	_tx_thread_sleep
 4320              	.LVL512:
2821:../uvc.c      **** 			                         		break;
 4321              		.loc 1 2821 0
 4322 2508 6C1094E5 		ldr	r1, [r4, #108]
 4323 250c 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4324 2510 000051E3 		cmp	r1, #0
 4325 2514 C410A003 		moveq	r1, #196
 4326 2518 4410A013 		movne	r1, #68
 4327 251c 022081E1 		orr	r2, r1, r2
 4328 2520 6C3094E5 		ldr	r3, [r4, #108]
 4329 2524 88111FE5 		ldr	r1, .L463+60
 4330 2528 0400A0E3 		mov	r0, #4
 4331 252c FEFFFFEB 		bl	CyU3PDebugPrint
 4332              	.LVL513:
2822:../uvc.c      **** 			                         	case 4: //VGA
 4333              		.loc 1 2822 0
 4334 2530 A0FEFFEA 		b	.L387
 4335              	.L390:
2814:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4336              		.loc 1 2814 0
 4337 2534 6C2094E5 		ldr	r2, [r4, #108]
 4338 2538 3010A0E3 		mov	r1, #48
 4339 253c 000052E3 		cmp	r2, #0
 4340 2540 D420A003 		moveq	r2, #212
 4341 2544 5420A013 		movne	r2, #84
 4342 2548 5230A0E3 		mov	r3, #82
 4343 254c 0100A0E3 		mov	r0, #1
 4344 2550 FEFFFFEB 		bl	SensorSetIrisControl
 4345              	.LVL514:
2815:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4346              		.loc 1 2815 0
 4347 2554 7D0FA0E3 		mov	r0, #500
 4348 2558 FEFFFFEB 		bl	_tx_thread_sleep
 4349              	.LVL515:
2816:../uvc.c      **** 			                         		break;
 4350              		.loc 1 2816 0
 4351 255c 6C2094E5 		ldr	r2, [r4, #108]
 4352 2560 C4111FE5 		ldr	r1, .L463+60
 4353 2564 000052E3 		cmp	r2, #0
 4354 2568 6C3094E5 		ldr	r3, [r4, #108]
 4355 256c D420A003 		moveq	r2, #212
 4356 2570 5420A013 		movne	r2, #84
 4357 2574 0400A0E3 		mov	r0, #4
 4358 2578 FEFFFFEB 		bl	CyU3PDebugPrint
 4359              	.LVL516:
2817:../uvc.c      **** 			                         	case 3: //720
 4360              		.loc 1 2817 0
 4361 257c 8DFEFFEA 		b	.L387
 4362              	.L388:
2809:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4363              		.loc 1 2809 0
 4364 2580 6C2094E5 		ldr	r2, [r4, #108]
 4365 2584 3010A0E3 		mov	r1, #48
 4366 2588 000052E3 		cmp	r2, #0
 4367 258c E420A003 		moveq	r2, #228
 4368 2590 6420A013 		movne	r2, #100
 4369 2594 5230A0E3 		mov	r3, #82
 4370 2598 0100A0E3 		mov	r0, #1
 4371 259c FEFFFFEB 		bl	SensorSetIrisControl
 4372              	.LVL517:
2810:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4373              		.loc 1 2810 0
 4374 25a0 7D0FA0E3 		mov	r0, #500
 4375 25a4 FEFFFFEB 		bl	_tx_thread_sleep
 4376              	.LVL518:
2811:../uvc.c      **** 			                         		break;
 4377              		.loc 1 2811 0
 4378 25a8 6C2094E5 		ldr	r2, [r4, #108]
 4379 25ac 10121FE5 		ldr	r1, .L463+60
 4380 25b0 000052E3 		cmp	r2, #0
 4381 25b4 6C3094E5 		ldr	r3, [r4, #108]
 4382 25b8 E420A003 		moveq	r2, #228
 4383 25bc 6420A013 		movne	r2, #100
 4384 25c0 0400A0E3 		mov	r0, #4
 4385 25c4 FEFFFFEB 		bl	CyU3PDebugPrint
 4386              	.LVL519:
2812:../uvc.c      **** 			                         	case 2: //1080
 4387              		.loc 1 2812 0
 4388 25c8 7AFEFFEA 		b	.L387
 4389              	.LVL520:
 4390              	.L457:
2889:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4391              		.loc 1 2889 0
 4392 25cc 057187E0 		add	r7, r7, r5, asl #2
 4393 25d0 207197E5 		ldr	r7, [r7, #288]
 4394 25d4 18009DE5 		ldr	r0, [sp, #24]
 4395 25d8 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4396 25dc 000053E1 		cmp	r3, r0
 4397 25e0 1100000A 		beq	.L404
2890:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4398              		.loc 1 2890 0
 4399 25e4 44421FE5 		ldr	r4, .L463+64
 4400 25e8 0010E0E3 		mvn	r1, #0
 4401 25ec 1C0094E5 		ldr	r0, [r4, #28]
 4402 25f0 FEFFFFEB 		bl	_txe_mutex_get
 4403              	.LVL521:
2891:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4404              		.loc 1 2891 0
 4405 25f4 18109DE5 		ldr	r1, [sp, #24]
 4406 25f8 00B0A0E3 		mov	fp, #0
 4407              	.LVL522:
 4408 25fc 0A20A0E1 		mov	r2, r10
 4409 2600 00108DE5 		str	r1, [sp]
 4410 2604 0930A0E1 		mov	r3, r9
 4411 2608 0510A0E1 		mov	r1, r5
 4412 260c 0400A0E1 		mov	r0, r4
 4413 2610 04B08DE5 		str	fp, [sp, #4]
 4414 2614 FEFFFFEB 		bl	cmdSet
 4415              	.LVL523:
2892:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4416              		.loc 1 2892 0
 4417 2618 1C0094E5 		ldr	r0, [r4, #28]
 4418 261c FEFFFFEB 		bl	_txe_mutex_put
 4419              	.LVL524:
2893:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4420              		.loc 1 2893 0
 4421 2620 18209DE5 		ldr	r2, [sp, #24]
 4422 2624 0D20C7E5 		strb	r2, [r7, #13]
2894:../uvc.c      **** 								 }
 4423              		.loc 1 2894 0
 4424 2628 0EB0C7E5 		strb	fp, [r7, #14]
 4425              	.LVL525:
 4426              	.L404:
2896:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4427              		.loc 1 2896 0
 4428 262c 0130A0E3 		mov	r3, #1
 4429 2630 1130C7E5 		strb	r3, [r7, #17]
 4430 2634 D8FEFFEA 		b	.L405
 4431              	.LVL526:
 4432              	.L458:
2703:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4433              		.loc 1 2703 0
 4434 2638 033187E0 		add	r3, r7, r3, asl #2
 4435 263c 207093E5 		ldr	r7, [r3, #32]
 4436 2640 18109DE5 		ldr	r1, [sp, #24]
 4437 2644 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4438 2648 010053E1 		cmp	r3, r1
 4439 264c F6FFFF0A 		beq	.L404
2704:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4440              		.loc 1 2704 0
 4441 2650 B0421FE5 		ldr	r4, .L463+64
 4442 2654 0010E0E3 		mvn	r1, #0
 4443 2658 1C0094E5 		ldr	r0, [r4, #28]
 4444 265c FEFFFFEB 		bl	_txe_mutex_get
 4445              	.LVL527:
2705:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4446              		.loc 1 2705 0
 4447 2660 18209DE5 		ldr	r2, [sp, #24]
 4448 2664 00B0A0E3 		mov	fp, #0
 4449              	.LVL528:
 4450 2668 0930A0E1 		mov	r3, r9
 4451 266c 00208DE5 		str	r2, [sp]
 4452 2670 0510A0E1 		mov	r1, r5
 4453 2674 0A20A0E1 		mov	r2, r10
 4454 2678 0400A0E1 		mov	r0, r4
 4455 267c 04B08DE5 		str	fp, [sp, #4]
 4456 2680 FEFFFFEB 		bl	cmdSet
 4457              	.LVL529:
2706:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4458              		.loc 1 2706 0
 4459 2684 1C0094E5 		ldr	r0, [r4, #28]
 4460 2688 FEFFFFEB 		bl	_txe_mutex_put
 4461              	.LVL530:
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 4462              		.loc 1 2707 0
 4463 268c 18309DE5 		ldr	r3, [sp, #24]
 4464 2690 0D30C7E5 		strb	r3, [r7, #13]
2708:../uvc.c      **** 									 }
 4465              		.loc 1 2708 0
 4466 2694 0EB0C7E5 		strb	fp, [r7, #14]
 4467              	.LVL531:
 4468 2698 E3FFFFEA 		b	.L404
 4469              	.LVL532:
 4470              	.L454:
1809:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4471              		.loc 1 1809 0
 4472 269c 005187E0 		add	r5, r7, r0, asl #2
 4473 26a0 203195E5 		ldr	r3, [r5, #288]
 4474              	.L432:
 4475 26a4 0DA0D3E5 		ldrb	r10, [r3, #13]	@ zero_extendqisi2
 4476              	.LVL533:
 4477 26a8 0090A0E3 		mov	r9, #0
 4478              	.LVL534:
 4479 26ac FFA00AE2 		and	r10, r10, #255
 4480 26b0 28A0C4E5 		strb	r10, [r4, #40]
1810:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4481              		.loc 1 1810 0
 4482 26b4 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4483 26b8 FF7007E2 		and	r7, r7, #255
 4484 26bc 2970C4E5 		strb	r7, [r4, #41]
 4485              	.LVL535:
 4486 26c0 79FCFFEA 		b	.L292
 4487              	.LVL536:
 4488              	.L456:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4489              		.loc 1 1618 0
 4490 26c4 005187E0 		add	r5, r7, r0, asl #2
 4491 26c8 203015E5 		ldr	r3, [r5, #-32]
 4492 26cc F4FFFFEA 		b	.L432
 4493              	.L455:
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4494              		.loc 1 1814 0
 4495 26d0 005187E0 		add	r5, r7, r0, asl #2
 4496 26d4 202195E5 		ldr	r2, [r5, #288]
 4497 26d8 9EFEFFEA 		b	.L433
 4498              	.LVL537:
 4499              	.L452:
2589:../uvc.c      **** 								 }
 4500              		.loc 1 2589 0
 4501 26dc FF00A0E3 		mov	r0, #255
 4502 26e0 0110A0E3 		mov	r1, #1
 4503 26e4 03008DE8 		stmia	sp, {r0, r1}
 4504 26e8 48031FE5 		ldr	r0, .L463+64
 4505 26ec 0B20A0E1 		mov	r2, fp
 4506 26f0 0930A0E1 		mov	r3, r9
 4507 26f4 1910A0E3 		mov	r1, #25
 4508 26f8 FEFFFFEB 		bl	cmdSet
 4509              	.LVL538:
 4510 26fc 1CFDFFEA 		b	.L367
 4511              	.LVL539:
 4512              	.L406:
2898:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4513              		.loc 1 2898 0
 4514 2700 60431FE5 		ldr	r4, .L463+64
 4515 2704 0010E0E3 		mvn	r1, #0
 4516 2708 1C0094E5 		ldr	r0, [r4, #28]
 4517 270c FEFFFFEB 		bl	_txe_mutex_get
 4518              	.LVL540:
2899:../uvc.c      **** 								 {
 4519              		.loc 1 2899 0
 4520 2710 057187E0 		add	r7, r7, r5, asl #2
 4521 2714 207197E5 		ldr	r7, [r7, #288]
 4522              	.L444:
 4523 2718 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4524 271c 18009DE5 		ldr	r0, [sp, #24]
 4525 2720 000053E1 		cmp	r3, r0
2902:../uvc.c      **** 									 dataIdx++;
 4526              		.loc 1 2902 0
 4527 2724 0030A0E3 		mov	r3, #0
2899:../uvc.c      **** 								 {
 4528              		.loc 1 2899 0
 4529 2728 0700000A 		beq	.L407
2901:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4530              		.loc 1 2901 0
 4531 272c 0D00C7E5 		strb	r0, [r7, #13]
 4532              	.LVL541:
2902:../uvc.c      **** 									 dataIdx++;
 4533              		.loc 1 2902 0
 4534 2730 0A20A0E1 		mov	r2, r10
 4535 2734 09008DE8 		stmia	sp, {r0, r3}
 4536 2738 0510A0E1 		mov	r1, r5
 4537 273c 0930A0E1 		mov	r3, r9
 4538 2740 0400A0E1 		mov	r0, r4
 4539 2744 FEFFFFEB 		bl	cmdSet
 4540              	.LVL542:
2903:../uvc.c      **** 								 }
 4541              		.loc 1 2903 0
 4542 2748 0130A0E3 		mov	r3, #1
 4543              	.LVL543:
 4544              	.L407:
2905:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4545              		.loc 1 2905 0
 4546 274c 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4547 2750 1C109DE5 		ldr	r1, [sp, #28]
 4548 2754 010052E1 		cmp	r2, r1
 4549 2758 0700000A 		beq	.L408
2906:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4550              		.loc 1 2906 0
 4551 275c 0E10C7E5 		strb	r1, [r7, #14]
2907:../uvc.c      **** 								 }
 4552              		.loc 1 2907 0
 4553 2760 1C209DE5 		ldr	r2, [sp, #28]
 4554 2764 0510A0E1 		mov	r1, r5
 4555 2768 0C008DE8 		stmia	sp, {r2, r3}
 4556 276c CC031FE5 		ldr	r0, .L463+64
 4557 2770 0B20A0E1 		mov	r2, fp
 4558 2774 0930A0E1 		mov	r3, r9
 4559              	.LVL544:
 4560 2778 FEFFFFEB 		bl	cmdSet
 4561              	.LVL545:
 4562              	.L408:
2909:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4563              		.loc 1 2909 0
 4564 277c 0130A0E3 		mov	r3, #1
 4565 2780 1130C7E5 		strb	r3, [r7, #17]
2910:../uvc.c      **** 
 4566              		.loc 1 2910 0
 4567 2784 1C0094E5 		ldr	r0, [r4, #28]
 4568 2788 FEFFFFEB 		bl	_txe_mutex_put
 4569              	.LVL546:
 4570 278c 82FEFFEA 		b	.L405
 4571              	.LVL547:
 4572              	.L373:
2712:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4573              		.loc 1 2712 0
 4574 2790 F0431FE5 		ldr	r4, .L463+64
 4575 2794 0010E0E3 		mvn	r1, #0
 4576 2798 1C0094E5 		ldr	r0, [r4, #28]
 4577 279c 14308DE5 		str	r3, [sp, #20]
 4578 27a0 FEFFFFEB 		bl	_txe_mutex_get
 4579              	.LVL548:
2713:../uvc.c      **** 									 {
 4580              		.loc 1 2713 0
 4581 27a4 14309DE5 		ldr	r3, [sp, #20]
 4582 27a8 033187E0 		add	r3, r7, r3, asl #2
 4583 27ac 207093E5 		ldr	r7, [r3, #32]
 4584 27b0 D8FFFFEA 		b	.L444
 4585              	.LVL549:
 4586              	.L459:
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4587              		.loc 1 1633 0
 4588 27b4 0B00A0E1 		mov	r0, fp
 4589              	.LVL550:
 4590 27b8 0910A0E1 		mov	r1, r9
 4591 27bc 14308DE5 		str	r3, [sp, #20]
 4592 27c0 FEFFFFEB 		bl	SensorGetControl
 4593              	.LVL551:
1634:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4594              		.loc 1 1634 0
 4595 27c4 057187E0 		add	r7, r7, r5, asl #2
 4596 27c8 202017E5 		ldr	r2, [r7, #-32]
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4597              		.loc 1 1633 0
 4598 27cc 2800C4E5 		strb	r0, [r4, #40]
1634:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4599              		.loc 1 1634 0
 4600 27d0 0D00C2E5 		strb	r0, [r2, #13]
 4601 27d4 14309DE5 		ldr	r3, [sp, #20]
 4602 27d8 00A0A0E1 		mov	r10, r0
 4603              	.LVL552:
1635:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 4604              		.loc 1 1635 0
 4605 27dc 2930C4E5 		strb	r3, [r4, #41]
 4606 27e0 0370A0E1 		mov	r7, r3
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4607              		.loc 1 1636 0
 4608 27e4 0E30C2E5 		strb	r3, [r2, #14]
 4609              	.LVL553:
 4610 27e8 8DFEFFEA 		b	.L305
 4611              	.LVL554:
 4612              	.L461:
1824:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4613              		.loc 1 1824 0
 4614 27ec 0B00A0E1 		mov	r0, fp
 4615              	.LVL555:
 4616 27f0 0910A0E1 		mov	r1, r9
 4617 27f4 14308DE5 		str	r3, [sp, #20]
 4618 27f8 FEFFFFEB 		bl	SensorGetControl
 4619              	.LVL556:
1825:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4620              		.loc 1 1825 0
 4621 27fc 057187E0 		add	r7, r7, r5, asl #2
 4622 2800 202197E5 		ldr	r2, [r7, #288]
1824:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4623              		.loc 1 1824 0
 4624 2804 2800C4E5 		strb	r0, [r4, #40]
1825:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4625              		.loc 1 1825 0
 4626 2808 0D00C2E5 		strb	r0, [r2, #13]
 4627 280c 14309DE5 		ldr	r3, [sp, #20]
 4628 2810 00A0A0E1 		mov	r10, r0
 4629              	.LVL557:
1826:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4630              		.loc 1 1826 0
 4631 2814 2930C4E5 		strb	r3, [r4, #41]
 4632 2818 0370A0E1 		mov	r7, r3
1827:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4633              		.loc 1 1827 0
 4634 281c 0E30C2E5 		strb	r3, [r2, #14]
 4635              	.LVL558:
 4636 2820 8AFEFFEA 		b	.L327
 4637              	.LVL559:
 4638              	.L460:
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4639              		.loc 1 1640 0
 4640 2824 0B00A0E1 		mov	r0, fp
 4641              	.LVL560:
 4642 2828 0910A0E1 		mov	r1, r9
 4643 282c 14308DE5 		str	r3, [sp, #20]
 4644 2830 FEFFFFEB 		bl	SensorGetControl
 4645              	.LVL561:
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4646              		.loc 1 1641 0
 4647 2834 057187E0 		add	r7, r7, r5, asl #2
 4648 2838 20B017E5 		ldr	fp, [r7, #-32]
 4649              	.LVL562:
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4650              		.loc 1 1640 0
 4651 283c 0010A0E1 		mov	r1, r0
 4652 2840 2800C4E5 		strb	r0, [r4, #40]
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4653              		.loc 1 1642 0
 4654 2844 0A00A0E1 		mov	r0, r10
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4655              		.loc 1 1641 0
 4656 2848 0D10CBE5 		strb	r1, [fp, #13]
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4657              		.loc 1 1642 0
 4658 284c 0910A0E1 		mov	r1, r9
 4659 2850 FEFFFFEB 		bl	SensorGetControl
 4660              	.LVL563:
 4661 2854 2A00C4E5 		strb	r0, [r4, #42]
1643:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4662              		.loc 1 1643 0
 4663 2858 0E00CBE5 		strb	r0, [fp, #14]
1644:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4664              		.loc 1 1644 0
 4665 285c 14309DE5 		ldr	r3, [sp, #20]
 4666 2860 0070A0E1 		mov	r7, r0
 4667 2864 2930C4E5 		strb	r3, [r4, #41]
1645:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4668              		.loc 1 1645 0
 4669 2868 2B30C4E5 		strb	r3, [r4, #43]
 4670              	.LVL564:
 4671 286c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4672 2870 6BFEFFEA 		b	.L305
 4673              	.LVL565:
 4674              	.L462:
1831:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4675              		.loc 1 1831 0
 4676 2874 0B00A0E1 		mov	r0, fp
 4677              	.LVL566:
 4678 2878 0910A0E1 		mov	r1, r9
 4679 287c 14308DE5 		str	r3, [sp, #20]
 4680 2880 FEFFFFEB 		bl	SensorGetControl
 4681              	.LVL567:
1832:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4682              		.loc 1 1832 0
 4683 2884 057187E0 		add	r7, r7, r5, asl #2
 4684 2888 20B197E5 		ldr	fp, [r7, #288]
 4685              	.LVL568:
1831:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4686              		.loc 1 1831 0
 4687 288c 0010A0E1 		mov	r1, r0
 4688 2890 2800C4E5 		strb	r0, [r4, #40]
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4689              		.loc 1 1833 0
 4690 2894 0A00A0E1 		mov	r0, r10
1832:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4691              		.loc 1 1832 0
 4692 2898 0D10CBE5 		strb	r1, [fp, #13]
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4693              		.loc 1 1833 0
 4694 289c 0910A0E1 		mov	r1, r9
 4695 28a0 FEFFFFEB 		bl	SensorGetControl
 4696              	.LVL569:
 4697 28a4 2A00C4E5 		strb	r0, [r4, #42]
1834:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4698              		.loc 1 1834 0
 4699 28a8 0E00CBE5 		strb	r0, [fp, #14]
1835:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4700              		.loc 1 1835 0
 4701 28ac 14309DE5 		ldr	r3, [sp, #20]
 4702 28b0 0070A0E1 		mov	r7, r0
 4703 28b4 2930C4E5 		strb	r3, [r4, #41]
1836:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4704              		.loc 1 1836 0
 4705 28b8 2B30C4E5 		strb	r3, [r4, #43]
 4706              	.LVL570:
 4707 28bc 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4708 28c0 62FEFFEA 		b	.L327
 4709              		.cfi_endproc
 4710              	.LFE3:
 4712              		.align	2
 4713              		.global	CTControlHandle
 4715              	CTControlHandle:
 4716              	.LFB4:
2935:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4717              		.loc 1 2935 0
 4718              		.cfi_startproc
 4719              		@ args = 0, pretend = 0, frame = 24
 4720              		@ frame_needed = 0, uses_anonymous_args = 0
 4721              	.LVL571:
 4722 28c4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4723              	.LCFI19:
 4724              		.cfi_def_cfa_offset 36
 4725              		.cfi_offset 4, -36
 4726              		.cfi_offset 5, -32
 4727              		.cfi_offset 6, -28
 4728              		.cfi_offset 7, -24
 4729              		.cfi_offset 8, -20
 4730              		.cfi_offset 9, -16
 4731              		.cfi_offset 10, -12
 4732              		.cfi_offset 11, -8
 4733              		.cfi_offset 14, -4
2954:../uvc.c      **** 
 4734              		.loc 1 2954 0
 4735 28c8 28B89FE5 		ldr	fp, .L503
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4736              		.loc 1 2946 0
 4737 28cc 28389FE5 		ldr	r3, .L503+4
2954:../uvc.c      **** 
 4738              		.loc 1 2954 0
 4739 28d0 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4740              		.loc 1 2946 0
 4741 28d4 8080A0E1 		mov	r8, r0, asl #1
 4742 28d8 002088E0 		add	r2, r8, r0
 4743 28dc 822183E0 		add	r2, r3, r2, asl #3
2956:../uvc.c      **** 		 {
 4744              		.loc 1 2956 0
 4745 28e0 830055E3 		cmp	r5, #131
2935:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4746              		.loc 1 2935 0
 4747 28e4 34D04DE2 		sub	sp, sp, #52
 4748              	.LCFI20:
 4749              		.cfi_def_cfa_offset 88
2935:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4750              		.loc 1 2935 0
 4751 28e8 0060A0E1 		mov	r6, r0
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4752              		.loc 1 2946 0
 4753 28ec AB95D2E5 		ldrb	r9, [r2, #1451]	@ zero_extendqisi2
 4754              	.LVL572:
2947:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4755              		.loc 1 2947 0
 4756 28f0 9CA5D2E5 		ldrb	r10, [r2, #1436]	@ zero_extendqisi2
 4757              	.LVL573:
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4758              		.loc 1 2949 0
 4759 28f4 9E75D2E5 		ldrb	r7, [r2, #1438]	@ zero_extendqisi2
 4760              	.LVL574:
2956:../uvc.c      **** 		 {
 4761              		.loc 1 2956 0
 4762 28f8 8000000A 		beq	.L467
 4763 28fc 2600009A 		bls	.L501
 4764 2900 850055E3 		cmp	r5, #133
 4765 2904 7200000A 		beq	.L472
 4766 2908 5000003A 		bcc	.L473
 4767 290c 860055E3 		cmp	r5, #134
 4768 2910 4300000A 		beq	.L474
 4769 2914 870055E3 		cmp	r5, #135
 4770 2918 5F00001A 		bne	.L466
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4771              		.loc 1 3018 0
 4772 291c A7C5D2E5 		ldrb	ip, [r2, #1447]	@ zero_extendqisi2
 4773 2920 D8479FE5 		ldr	r4, .L503+8
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4774              		.loc 1 3019 0
 4775 2924 A825D2E5 		ldrb	r2, [r2, #1448]	@ zero_extendqisi2
 4776              	.LVL575:
 4777              	.L500:
2996:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4778              		.loc 1 2996 0
 4779 2928 0A1056E2 		subs	r1, r6, #10
 4780 292c 006071E2 		rsbs	r6, r1, #0
 4781 2930 0160B6E0 		adcs	r6, r6, r1
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4782              		.loc 1 2998 0
 4783 2934 0030A0E3 		mov	r3, #0
 4784              	.LVL576:
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4785              		.loc 1 2999 0
 4786 2938 281084E2 		add	r1, r4, #40
 4787 293c 0700A0E1 		mov	r0, r7
 4788              	.LVL577:
2996:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4789              		.loc 1 2996 0
 4790 2940 2A60C4E5 		strb	r6, [r4, #42]
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4791              		.loc 1 2994 0
 4792 2944 28C0C4E5 		strb	ip, [r4, #40]
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4793              		.loc 1 2995 0
 4794 2948 2920C4E5 		strb	r2, [r4, #41]
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4795              		.loc 1 2998 0
 4796 294c 2B30C4E5 		strb	r3, [r4, #43]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4797              		.loc 1 2999 0
 4798 2950 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4799              	.LVL578:
 4800 2954 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
3001:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4801              		.loc 1 3001 0
 4802 2958 FF80A0E3 		mov	r8, #255
 4803 295c 0860A0E1 		mov	r6, r8
 4804              	.LVL579:
 4805              	.L476:
3169:../uvc.c      **** }
 4806              		.loc 1 3169 0
 4807 2960 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4808 2964 FFC0A0E3 		mov	ip, #255
 4809 2968 04108DE5 		str	r1, [sp, #4]
 4810 296c 10108DE5 		str	r1, [sp, #16]
 4811 2970 08008DE5 		str	r0, [sp, #8]
 4812 2974 00808DE5 		str	r8, [sp]
 4813 2978 14708DE5 		str	r7, [sp, #20]
 4814 297c 0520A0E1 		mov	r2, r5
 4815 2980 0630A0E1 		mov	r3, r6
 4816 2984 0CC08DE5 		str	ip, [sp, #12]
 4817 2988 74179FE5 		ldr	r1, .L503+12
 4818 298c 0400A0E3 		mov	r0, #4
 4819 2990 FEFFFFEB 		bl	CyU3PDebugPrint
 4820              	.LVL580:
3170:../uvc.c      **** 
 4821              		.loc 1 3170 0
 4822 2994 34D08DE2 		add	sp, sp, #52
 4823              		@ sp needed
 4824 2998 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4825              	.LVL581:
 4826              	.L501:
2956:../uvc.c      **** 		 {
 4827              		.loc 1 2956 0
 4828 299c 810055E3 		cmp	r5, #129
 4829 29a0 2E00000A 		beq	.L469
 4830 29a4 1A00008A 		bhi	.L470
 4831 29a8 010055E3 		cmp	r5, #1
 4832 29ac 3A00001A 		bne	.L466
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4833              		.loc 1 3027 0
 4834 29b0 48479FE5 		ldr	r4, .L503+8
 4835 29b4 2E208DE2 		add	r2, sp, #46
 4836              	.LVL582:
 4837 29b8 2000A0E3 		mov	r0, #32
 4838              	.LVL583:
 4839 29bc 281084E2 		add	r1, r4, #40
 4840 29c0 18308DE5 		str	r3, [sp, #24]
 4841 29c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4842              	.LVL584:
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4843              		.loc 1 3029 0
 4844 29c8 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
3033:../uvc.c      **** 			  {
 4845              		.loc 1 3033 0
 4846 29cc 012046E2 		sub	r2, r6, #1
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4847              		.loc 1 3029 0
 4848 29d0 1CC08DE5 		str	ip, [sp, #28]
 4849              	.LVL585:
3030:../uvc.c      **** 			  value = Data1;
 4850              		.loc 1 3030 0
 4851 29d4 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
3033:../uvc.c      **** 			  {
 4852              		.loc 1 3033 0
 4853 29d8 18309DE5 		ldr	r3, [sp, #24]
3030:../uvc.c      **** 			  value = Data1;
 4854              		.loc 1 3030 0
 4855 29dc 20C08DE5 		str	ip, [sp, #32]
 4856              	.LVL586:
3033:../uvc.c      **** 			  {
 4857              		.loc 1 3033 0
 4858 29e0 090052E3 		cmp	r2, #9
 4859 29e4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4860 29e8 1D0100EA 		b	.L477
 4861              	.L479:
 4862 29ec 1C2E0000 		.word	.L478
 4863 29f0 642E0000 		.word	.L477
 4864 29f4 1C2C0000 		.word	.L480
 4865 29f8 642E0000 		.word	.L477
 4866 29fc 642E0000 		.word	.L477
 4867 2a00 642E0000 		.word	.L477
 4868 2a04 8C2B0000 		.word	.L481
 4869 2a08 642E0000 		.word	.L477
 4870 2a0c 642E0000 		.word	.L477
 4871 2a10 102B0000 		.word	.L482
 4872              	.LVL587:
 4873              	.L470:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4874              		.loc 1 2985 0
 4875 2a14 9FC5D2E5 		ldrb	ip, [r2, #1439]	@ zero_extendqisi2
 4876 2a18 E0469FE5 		ldr	r4, .L503+8
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4877              		.loc 1 2986 0
 4878 2a1c A025D2E5 		ldrb	r2, [r2, #1440]	@ zero_extendqisi2
 4879              	.LVL588:
 4880 2a20 C0FFFFEA 		b	.L500
 4881              	.LVL589:
 4882              	.L474:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4883              		.loc 1 3012 0
 4884 2a24 D4469FE5 		ldr	r4, .L503+8
 4885 2a28 A535D2E5 		ldrb	r3, [r2, #1445]	@ zero_extendqisi2
 4886 2a2c 0410A0E1 		mov	r1, r4
 4887 2a30 2830E1E5 		strb	r3, [r1, #40]!
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4888              		.loc 1 3013 0
 4889 2a34 0100A0E3 		mov	r0, #1
 4890              	.LVL590:
3016:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4891              		.loc 1 3016 0
 4892 2a38 FF80A0E3 		mov	r8, #255
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4893              		.loc 1 3013 0
 4894 2a3c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4895              	.LVL591:
3016:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4896              		.loc 1 3016 0
 4897 2a40 0860A0E1 		mov	r6, r8
 4898 2a44 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4899 2a48 0170A0E3 		mov	r7, #1
 4900 2a4c C3FFFFEA 		b	.L476
 4901              	.LVL592:
 4902              	.L473:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4903              		.loc 1 3003 0
 4904 2a50 A3C5D2E5 		ldrb	ip, [r2, #1443]	@ zero_extendqisi2
 4905 2a54 A4469FE5 		ldr	r4, .L503+8
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4906              		.loc 1 3004 0
 4907 2a58 A425D2E5 		ldrb	r2, [r2, #1444]	@ zero_extendqisi2
 4908              	.LVL593:
 4909 2a5c B1FFFFEA 		b	.L500
 4910              	.LVL594:
 4911              	.L469:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4912              		.loc 1 2970 0
 4913 2a60 98469FE5 		ldr	r4, .L503+8
 4914 2a64 A995D2E5 		ldrb	r9, [r2, #1449]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4915              		.loc 1 2971 0
 4916 2a68 AAC5D2E5 		ldrb	ip, [r2, #1450]	@ zero_extendqisi2
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4917              		.loc 1 2972 0
 4918 2a6c 0030A0E3 		mov	r3, #0
2978:../uvc.c      **** 
 4919              		.loc 1 2978 0
 4920 2a70 281084E2 		add	r1, r4, #40
 4921 2a74 0700A0E1 		mov	r0, r7
 4922              	.LVL595:
2983:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4923              		.loc 1 2983 0
 4924 2a78 FF80A0E3 		mov	r8, #255
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4925              		.loc 1 2971 0
 4926 2a7c 29C0C4E5 		strb	ip, [r4, #41]
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4927              		.loc 1 2970 0
 4928 2a80 2890C4E5 		strb	r9, [r4, #40]
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4929              		.loc 1 2972 0
 4930 2a84 2A30C4E5 		strb	r3, [r4, #42]
2973:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4931              		.loc 1 2973 0
 4932 2a88 2B30C4E5 		strb	r3, [r4, #43]
 4933              	.LVL596:
2983:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4934              		.loc 1 2983 0
 4935 2a8c 0860A0E1 		mov	r6, r8
 4936              	.LVL597:
2978:../uvc.c      **** 
 4937              		.loc 1 2978 0
 4938 2a90 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4939              	.LVL598:
 4940 2a94 0900A0E1 		mov	r0, r9
2983:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4941              		.loc 1 2983 0
 4942 2a98 B0FFFFEA 		b	.L476
 4943              	.LVL599:
 4944              	.L466:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4945              		.loc 1 3163 0
 4946 2a9c 0000A0E3 		mov	r0, #0
 4947              	.LVL600:
 4948 2aa0 0020A0E1 		mov	r2, r0
 4949              	.LVL601:
 4950 2aa4 0110A0E3 		mov	r1, #1
 4951 2aa8 FEFFFFEB 		bl	CyU3PUsbStall
 4952              	.LVL602:
3164:../uvc.c      **** 			  break;
 4953              		.loc 1 3164 0
 4954 2aac 0620A0E1 		mov	r2, r6
 4955 2ab0 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 4956 2ab4 0400A0E3 		mov	r0, #4
 4957 2ab8 48169FE5 		ldr	r1, .L503+16
 4958 2abc FEFFFFEB 		bl	CyU3PDebugPrint
 4959              	.LVL603:
3165:../uvc.c      **** 		 }
 4960              		.loc 1 3165 0
 4961 2ac0 FF00A0E3 		mov	r0, #255
 4962 2ac4 34469FE5 		ldr	r4, .L503+8
 4963 2ac8 0080A0E1 		mov	r8, r0
 4964 2acc 0060A0E1 		mov	r6, r0
 4965 2ad0 A2FFFFEA 		b	.L476
 4966              	.LVL604:
 4967              	.L472:
2960:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4968              		.loc 1 2960 0
 4969 2ad4 24469FE5 		ldr	r4, .L503+8
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4970              		.loc 1 2961 0
 4971 2ad8 0030A0E3 		mov	r3, #0
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4972              		.loc 1 2962 0
 4973 2adc 281084E2 		add	r1, r4, #40
 4974 2ae0 0200A0E3 		mov	r0, #2
 4975              	.LVL605:
2964:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4976              		.loc 1 2964 0
 4977 2ae4 FF80A0E3 		mov	r8, #255
2960:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4978              		.loc 1 2960 0
 4979 2ae8 2870C4E5 		strb	r7, [r4, #40]
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4980              		.loc 1 2961 0
 4981 2aec 2930C4E5 		strb	r3, [r4, #41]
2964:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4982              		.loc 1 2964 0
 4983 2af0 0860A0E1 		mov	r6, r8
 4984              	.LVL606:
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4985              		.loc 1 2962 0
 4986 2af4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4987              	.LVL607:
 4988 2af8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2964:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4989              		.loc 1 2964 0
 4990 2afc 97FFFFEA 		b	.L476
 4991              	.LVL608:
 4992              	.L467:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4993              		.loc 1 2994 0
 4994 2b00 A1C5D2E5 		ldrb	ip, [r2, #1441]	@ zero_extendqisi2
 4995 2b04 F4459FE5 		ldr	r4, .L503+8
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4996              		.loc 1 2995 0
 4997 2b08 A225D2E5 		ldrb	r2, [r2, #1442]	@ zero_extendqisi2
 4998              	.LVL609:
 4999 2b0c 85FFFFEA 		b	.L500
 5000              	.LVL610:
 5001              	.L482:
3142:../uvc.c      **** 					  if(getData == 1)
 5002              		.loc 1 3142 0
 5003 2b10 F4659FE5 		ldr	r6, .L503+20
 5004 2b14 0010E0E3 		mvn	r1, #0
 5005 2b18 1C0096E5 		ldr	r0, [r6, #28]
 5006 2b1c FEFFFFEB 		bl	_txe_mutex_get
 5007              	.LVL611:
3143:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5008              		.loc 1 3143 0
 5009 2b20 1CC09DE5 		ldr	ip, [sp, #28]
 5010 2b24 01005CE3 		cmp	ip, #1
3144:../uvc.c      **** 					  else if(getData == 0xff)
 5011              		.loc 1 3144 0
 5012 2b28 0400A003 		moveq	r0, #4
3143:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5013              		.loc 1 3143 0
 5014 2b2c 6901000A 		beq	.L499
3145:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5015              		.loc 1 3145 0
 5016 2b30 FF005CE3 		cmp	ip, #255
 5017 2b34 6601000A 		beq	.L502
3148:../uvc.c      **** 					  //dataIdx++;
 5018              		.loc 1 3148 0
 5019 2b38 0010A0E3 		mov	r1, #0
 5020 2b3c 00108DE5 		str	r1, [sp]
 5021 2b40 04108DE5 		str	r1, [sp, #4]
 5022 2b44 0A20A0E1 		mov	r2, r10
 5023 2b48 0930A0E1 		mov	r3, r9
 5024 2b4c 0600A0E1 		mov	r0, r6
 5025 2b50 2310A0E3 		mov	r1, #35
 5026 2b54 FEFFFFEB 		bl	cmdSet
 5027              	.LVL612:
 5028              	.L494:
3151:../uvc.c      **** #endif
 5029              		.loc 1 3151 0
 5030 2b58 1C0096E5 		ldr	r0, [r6, #28]
 5031 2b5c FEFFFFEB 		bl	_txe_mutex_put
 5032              	.LVL613:
3153:../uvc.c      **** 					  break;
 5033              		.loc 1 3153 0
 5034 2b60 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5035 2b64 1C609DE5 		ldr	r6, [sp, #28]
 5036 2b68 20809DE5 		ldr	r8, [sp, #32]
 5037 2b6c 00108DE5 		str	r1, [sp]
 5038 2b70 0620A0E1 		mov	r2, r6
 5039 2b74 0830A0E1 		mov	r3, r8
 5040 2b78 0400A0E3 		mov	r0, #4
 5041 2b7c 8C159FE5 		ldr	r1, .L503+24
 5042 2b80 FEFFFFEB 		bl	CyU3PDebugPrint
 5043              	.LVL614:
3154:../uvc.c      **** 
 5044              		.loc 1 3154 0
 5045 2b84 FF00A0E3 		mov	r0, #255
 5046 2b88 74FFFFEA 		b	.L476
 5047              	.LVL615:
 5048              	.L481:
3119:../uvc.c      **** 					  {
 5049              		.loc 1 3119 0
 5050 2b8c C105D3E5 		ldrb	r0, [r3, #1473]	@ zero_extendqisi2
 5051 2b90 64C59FE5 		ldr	ip, .L503+4
 5052 2b94 010050E3 		cmp	r0, #1
 5053 2b98 08005013 		cmpne	r0, #8
 5054 2b9c 0000A013 		movne	r0, #0
 5055 2ba0 0100A003 		moveq	r0, #1
 5056 2ba4 4601001A 		bne	.L491
 5057              	.LVL616:
3122:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5058              		.loc 1 3122 0
 5059 2ba8 5CB59FE5 		ldr	fp, .L503+20
 5060 2bac 0010E0E3 		mvn	r1, #0
 5061 2bb0 1C009BE5 		ldr	r0, [fp, #28]
 5062 2bb4 18C08DE5 		str	ip, [sp, #24]
 5063 2bb8 FEFFFFEB 		bl	_txe_mutex_get
 5064              	.LVL617:
3123:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5065              		.loc 1 3123 0
 5066 2bbc 1C009DE5 		ldr	r0, [sp, #28]
 5067 2bc0 0010A0E3 		mov	r1, #0
 5068 2bc4 0A20A0E1 		mov	r2, r10
 5069 2bc8 0930A0E1 		mov	r3, r9
 5070 2bcc 00008DE5 		str	r0, [sp]
 5071 2bd0 04108DE5 		str	r1, [sp, #4]
 5072 2bd4 0B00A0E1 		mov	r0, fp
 5073 2bd8 2210A0E3 		mov	r1, #34
 5074 2bdc FEFFFFEB 		bl	cmdSet
 5075              	.LVL618:
3124:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5076              		.loc 1 3124 0
 5077 2be0 1C009BE5 		ldr	r0, [fp, #28]
 5078 2be4 FEFFFFEB 		bl	_txe_mutex_put
 5079              	.LVL619:
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5080              		.loc 1 3127 0
 5081 2be8 18C09DE5 		ldr	ip, [sp, #24]
 5082 2bec 1C109DE5 		ldr	r1, [sp, #28]
3128:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5083              		.loc 1 3128 0
 5084 2bf0 20209DE5 		ldr	r2, [sp, #32]
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5085              		.loc 1 3127 0
 5086 2bf4 066088E0 		add	r6, r8, r6
 5087 2bf8 86C18CE0 		add	ip, ip, r6, asl #3
3129:../uvc.c      **** 					  }else{
 5088              		.loc 1 3129 0
 5089 2bfc 0130A0E3 		mov	r3, #1
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5090              		.loc 1 3127 0
 5091 2c00 A915CCE5 		strb	r1, [ip, #1449]
3128:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5092              		.loc 1 3128 0
 5093 2c04 AA25CCE5 		strb	r2, [ip, #1450]
3129:../uvc.c      **** 					  }else{
 5094              		.loc 1 3129 0
 5095 2c08 AC35CCE5 		strb	r3, [ip, #1452]
 5096              	.LVL620:
 5097              	.L492:
 5098 2c0c 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5099 2c10 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
3136:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5100              		.loc 1 3136 0
 5101 2c14 FF00A0E3 		mov	r0, #255
 5102 2c18 50FFFFEA 		b	.L476
 5103              	.LVL621:
 5104              	.L480:
3085:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5105              		.loc 1 3085 0
 5106 2c1c C135D3E5 		ldrb	r3, [r3, #1473]	@ zero_extendqisi2
 5107 2c20 010053E3 		cmp	r3, #1
 5108 2c24 04005313 		cmpne	r3, #4
 5109 2c28 2001001A 		bne	.L489
3084:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5110              		.loc 1 3084 0
 5111 2c2c 1CC09DE5 		ldr	ip, [sp, #28]
 5112 2c30 20009DE5 		ldr	r0, [sp, #32]
 5113 2c34 00348CE1 		orr	r3, ip, r0, asl #8
3086:../uvc.c      **** 					  {
 5114              		.loc 1 3086 0
 5115 2c38 F90053E3 		cmp	r3, #249
 5116 2c3c 1B01008A 		bhi	.L489
 5117              	.LVL622:
3091:../uvc.c      **** 							}else{
 5118              		.loc 1 3091 0
 5119 2c40 C80043E2 		sub	r0, r3, #200
 5120 2c44 C80053E3 		cmp	r3, #200
3093:../uvc.c      **** 							}
 5121              		.loc 1 3093 0
 5122 2c48 C82063E2 		rsb	r2, r3, #200
 5123 2c4c C0149FE5 		ldr	r1, .L503+28
 5124 2c50 0208A091 		movls	r0, r2, asl #16
 5125 2c54 0008A081 		movhi	r0, r0, asl #16
 5126 2c58 642063E2 		rsb	r2, r3, #100
 5127 2c5c 640053E3 		cmp	r3, #100
3091:../uvc.c      **** 							}else{
 5128              		.loc 1 3091 0
 5129 2c60 64C043E2 		sub	ip, r3, #100
 5130 2c64 2008A0E1 		mov	r0, r0, lsr #16
 5131 2c68 0C28A081 		movhi	r2, ip, asl #16
 5132 2c6c 0228A091 		movls	r2, r2, asl #16
 5133 2c70 010050E1 		cmp	r0, r1
 5134 2c74 00E0A031 		movcc	lr, r0
 5135 2c78 01E0A021 		movcs	lr, r1
 5136 2c7c 010050E1 		cmp	r0, r1
 5137 2c80 27C043E2 		sub	ip, r3, #39
3093:../uvc.c      **** 							}
 5138              		.loc 1 3093 0
 5139 2c84 271063E2 		rsb	r1, r3, #39
 5140 2c88 00B0A033 		movcc	fp, #0
 5141 2c8c 01B0A023 		movcs	fp, #1
 5142 2c90 270053E3 		cmp	r3, #39
3091:../uvc.c      **** 							}else{
 5143              		.loc 1 3091 0
 5144 2c94 140043E2 		sub	r0, r3, #20
 5145 2c98 01C8A091 		movls	ip, r1, asl #16
 5146 2c9c 2228A0E1 		mov	r2, r2, lsr #16
3093:../uvc.c      **** 							}
 5147              		.loc 1 3093 0
 5148 2ca0 141063E2 		rsb	r1, r3, #20
 5149 2ca4 0CC8A081 		movhi	ip, ip, asl #16
 5150 2ca8 140053E3 		cmp	r3, #20
 5151 2cac 0018A081 		movhi	r1, r0, asl #16
 5152 2cb0 0118A091 		movls	r1, r1, asl #16
 5153 2cb4 0E0052E1 		cmp	r2, lr
3091:../uvc.c      **** 							}else{
 5154              		.loc 1 3091 0
 5155 2cb8 0A0043E2 		sub	r0, r3, #10
 5156 2cbc 01B0A033 		movcc	fp, #1
 5157 2cc0 2CC8A0E1 		mov	ip, ip, lsr #16
 5158 2cc4 02005EE1 		cmp	lr, r2
 5159 2cc8 0E20A031 		movcc	r2, lr
 5160 2ccc 0A0053E3 		cmp	r3, #10
 5161 2cd0 21E8A0E1 		mov	lr, r1, lsr #16
3093:../uvc.c      **** 							}
 5162              		.loc 1 3093 0
 5163 2cd4 0A1063E2 		rsb	r1, r3, #10
 5164 2cd8 0118A091 		movls	r1, r1, asl #16
 5165 2cdc 0018A081 		movhi	r1, r0, asl #16
 5166 2ce0 0C0052E1 		cmp	r2, ip
 5167 2ce4 02B0A083 		movhi	fp, #2
 5168 2ce8 24B08DE5 		str	fp, [sp, #36]
3091:../uvc.c      **** 							}else{
 5169              		.loc 1 3091 0
 5170 2cec 050043E2 		sub	r0, r3, #5
 5171 2cf0 02005CE1 		cmp	ip, r2
 5172 2cf4 0C20A031 		movcc	r2, ip
 5173 2cf8 21B8A0E1 		mov	fp, r1, lsr #16
3093:../uvc.c      **** 							}
 5174              		.loc 1 3093 0
 5175 2cfc 05C063E2 		rsb	ip, r3, #5
 5176 2d00 050053E3 		cmp	r3, #5
 5177 2d04 24109DE5 		ldr	r1, [sp, #36]
 5178 2d08 00C8A081 		movhi	ip, r0, asl #16
 5179 2d0c 0CC8A091 		movls	ip, ip, asl #16
 5180 2d10 0E0052E1 		cmp	r2, lr
 5181 2d14 0310A083 		movhi	r1, #3
 5182 2d18 24108DE5 		str	r1, [sp, #36]
 5183 2d1c 02005EE1 		cmp	lr, r2
 5184 2d20 0E00A031 		movcc	r0, lr
 5185 2d24 0200A021 		movcs	r0, r2
 5186 2d28 021063E2 		rsb	r1, r3, #2
3091:../uvc.c      **** 							}else{
 5187              		.loc 1 3091 0
 5188 2d2c 022043E2 		sub	r2, r3, #2
 5189 2d30 020053E3 		cmp	r3, #2
 5190 2d34 0128A091 		movls	r2, r1, asl #16
 5191 2d38 0228A081 		movhi	r2, r2, asl #16
 5192 2d3c 0B0050E1 		cmp	r0, fp
 5193 2d40 24E09DE5 		ldr	lr, [sp, #36]
 5194 2d44 2CC8A0E1 		mov	ip, ip, lsr #16
 5195 2d48 04E0A083 		movhi	lr, #4
 5196 2d4c 00005BE1 		cmp	fp, r0
 5197 2d50 0B00A031 		movcc	r0, fp
 5198 2d54 00005CE1 		cmp	ip, r0
 5199 2d58 0C10A031 		movcc	r1, ip
 5200 2d5c 0010A021 		movcs	r1, r0
 5201 2d60 0C0050E1 		cmp	r0, ip
 5202 2d64 05E0A083 		movhi	lr, #5
 5203 2d68 01C043E2 		sub	ip, r3, #1
 5204 2d6c 010053E3 		cmp	r3, #1
3093:../uvc.c      **** 							}
 5205              		.loc 1 3093 0
 5206 2d70 010063E2 		rsb	r0, r3, #1
 5207 2d74 0C38A081 		movhi	r3, ip, asl #16
3103:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5208              		.loc 1 3103 0
 5209 2d78 8CC39FE5 		ldr	ip, .L503+20
 5210 2d7c 2228A0E1 		mov	r2, r2, lsr #16
 5211 2d80 0038A091 		movls	r3, r0, asl #16
 5212 2d84 010052E1 		cmp	r2, r1
 5213 2d88 0200A031 		movcc	r0, r2
 5214 2d8c 0100A021 		movcs	r0, r1
 5215 2d90 020051E1 		cmp	r1, r2
 5216 2d94 0E20A091 		movls	r2, lr
 5217 2d98 0620A083 		movhi	r2, #6
 5218              	.LVL623:
 5219 2d9c 0010E0E3 		mvn	r1, #0
 5220              	.LVL624:
 5221 2da0 230850E1 		cmp	r0, r3, lsr #16
 5222 2da4 1C009CE5 		ldr	r0, [ip, #28]
 5223 2da8 02B0A091 		movls	fp, r2
 5224 2dac 07B0A083 		movhi	fp, #7
 5225              	.LVL625:
 5226 2db0 18C08DE5 		str	ip, [sp, #24]
 5227 2db4 FEFFFFEB 		bl	_txe_mutex_get
 5228              	.LVL626:
3104:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5229              		.loc 1 3104 0
 5230 2db8 18C09DE5 		ldr	ip, [sp, #24]
3100:../uvc.c      **** 
 5231              		.loc 1 3100 0
 5232 2dbc 01B08BE2 		add	fp, fp, #1
 5233              	.LVL627:
3104:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5234              		.loc 1 3104 0
 5235 2dc0 0010A0E3 		mov	r1, #0
 5236 2dc4 0A20A0E1 		mov	r2, r10
 5237 2dc8 0930A0E1 		mov	r3, r9
 5238 2dcc 0C00A0E1 		mov	r0, ip
 5239 2dd0 04108DE5 		str	r1, [sp, #4]
 5240 2dd4 00B08DE5 		str	fp, [sp]
 5241 2dd8 0310A0E3 		mov	r1, #3
 5242 2ddc FEFFFFEB 		bl	cmdSet
 5243              	.LVL628:
3105:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5244              		.loc 1 3105 0
 5245 2de0 18C09DE5 		ldr	ip, [sp, #24]
 5246 2de4 1C009CE5 		ldr	r0, [ip, #28]
 5247 2de8 FEFFFFEB 		bl	_txe_mutex_put
 5248              	.LVL629:
3111:../uvc.c      **** 					  }else{
 5249              		.loc 1 3111 0
 5250 2dec 08C39FE5 		ldr	ip, .L503+4
3108:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5251              		.loc 1 3108 0
 5252 2df0 04239FE5 		ldr	r2, .L503+4
3111:../uvc.c      **** 					  }else{
 5253              		.loc 1 3111 0
 5254 2df4 79B3CCE5 		strb	fp, [ip, #889]
3108:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5255              		.loc 1 3108 0
 5256 2df8 1CC09DE5 		ldr	ip, [sp, #28]
 5257 2dfc 063088E0 		add	r3, r8, r6
 5258 2e00 833182E0 		add	r3, r2, r3, asl #3
 5259 2e04 A9C5C3E5 		strb	ip, [r3, #1449]
3109:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5260              		.loc 1 3109 0
 5261 2e08 20C09DE5 		ldr	ip, [sp, #32]
3110:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5262              		.loc 1 3110 0
 5263 2e0c 0120A0E3 		mov	r2, #1
3109:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5264              		.loc 1 3109 0
 5265 2e10 AAC5C3E5 		strb	ip, [r3, #1450]
3110:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5266              		.loc 1 3110 0
 5267 2e14 AC25C3E5 		strb	r2, [r3, #1452]
3111:../uvc.c      **** 					  }else{
 5268              		.loc 1 3111 0
 5269 2e18 7BFFFFEA 		b	.L492
 5270              	.LVL630:
 5271              	.L478:
3042:../uvc.c      **** 						case 1:
 5272              		.loc 1 3042 0
 5273 2e1c 1CC09DE5 		ldr	ip, [sp, #28]
3038:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5274              		.loc 1 3038 0
 5275 2e20 066088E0 		add	r6, r8, r6
 5276 2e24 866183E0 		add	r6, r3, r6, asl #3
3039:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5277              		.loc 1 3039 0
 5278 2e28 0110A0E3 		mov	r1, #1
3042:../uvc.c      **** 						case 1:
 5279              		.loc 1 3042 0
 5280 2e2c 01204CE2 		sub	r2, ip, #1
3038:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5281              		.loc 1 3038 0
 5282 2e30 A9C5C6E5 		strb	ip, [r6, #1449]
3039:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5283              		.loc 1 3039 0
 5284 2e34 AC15C6E5 		strb	r1, [r6, #1452]
 5285              	.LVL631:
3042:../uvc.c      **** 						case 1:
 5286              		.loc 1 3042 0
 5287 2e38 070052E3 		cmp	r2, #7
 5288 2e3c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5289 2e40 960000EA 		b	.L483
 5290              	.L485:
 5291 2e44 3C300000 		.word	.L484
 5292 2e48 A02F0000 		.word	.L486
 5293 2e4c A0300000 		.word	.L483
 5294 2e50 382F0000 		.word	.L487
 5295 2e54 A0300000 		.word	.L483
 5296 2e58 A0300000 		.word	.L483
 5297 2e5c A0300000 		.word	.L483
 5298 2e60 982E0000 		.word	.L488
 5299              	.LVL632:
 5300              	.L477:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5301              		.loc 1 3157 0
 5302 2e64 1CC09DE5 		ldr	ip, [sp, #28]
 5303 2e68 068088E0 		add	r8, r8, r6
 5304 2e6c 888183E0 		add	r8, r3, r8, asl #3
3158:../uvc.c      **** 			  		 break;
 5305              		.loc 1 3158 0
 5306 2e70 0620A0E1 		mov	r2, r6
 5307 2e74 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5308 2e78 0400A0E3 		mov	r0, #4
 5309 2e7c 94129FE5 		ldr	r1, .L503+32
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5310              		.loc 1 3157 0
 5311 2e80 A9C5C8E5 		strb	ip, [r8, #1449]
3158:../uvc.c      **** 			  		 break;
 5312              		.loc 1 3158 0
 5313 2e84 FEFFFFEB 		bl	CyU3PDebugPrint
 5314              	.LVL633:
3159:../uvc.c      **** 			  }
 5315              		.loc 1 3159 0
 5316 2e88 FF00A0E3 		mov	r0, #255
 5317 2e8c 0080A0E1 		mov	r8, r0
 5318 2e90 0060A0E1 		mov	r6, r0
 5319 2e94 B1FEFFEA 		b	.L476
 5320              	.LVL634:
 5321              	.L488:
3061:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5322              		.loc 1 3061 0
 5323 2e98 6C629FE5 		ldr	r6, .L503+20
3059:../uvc.c      **** 			  		    	dataIdx = 0;
 5324              		.loc 1 3059 0
 5325 2e9c 0080A0E3 		mov	r8, #0
3061:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5326              		.loc 1 3061 0
 5327 2ea0 1C0096E5 		ldr	r0, [r6, #28]
 5328 2ea4 0010E0E3 		mvn	r1, #0
3059:../uvc.c      **** 			  		    	dataIdx = 0;
 5329              		.loc 1 3059 0
 5330 2ea8 7983C3E5 		strb	r8, [r3, #889]
 5331              	.LVL635:
3061:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5332              		.loc 1 3061 0
 5333 2eac FEFFFFEB 		bl	_txe_mutex_get
 5334              	.LVL636:
3062:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5335              		.loc 1 3062 0
 5336 2eb0 0A20A0E1 		mov	r2, r10
 5337 2eb4 0930A0E1 		mov	r3, r9
 5338 2eb8 1010A0E3 		mov	r1, #16
 5339 2ebc 00808DE5 		str	r8, [sp]
 5340 2ec0 04808DE5 		str	r8, [sp, #4]
 5341 2ec4 0600A0E1 		mov	r0, r6
 5342 2ec8 FEFFFFEB 		bl	cmdSet
 5343              	.LVL637:
3063:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5344              		.loc 1 3063 0
 5345 2ecc 1C0096E5 		ldr	r0, [r6, #28]
 5346 2ed0 FEFFFFEB 		bl	_txe_mutex_put
 5347              	.LVL638:
 5348              	.LBB82:
 5349              	.LBB83:
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5350              		.loc 1 1236 0
 5351 2ed4 1C0096E5 		ldr	r0, [r6, #28]
 5352 2ed8 0010E0E3 		mvn	r1, #0
 5353 2edc FEFFFFEB 		bl	_txe_mutex_get
 5354              	.LVL639:
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5355              		.loc 1 1237 0
 5356 2ee0 0130A0E3 		mov	r3, #1
 5357 2ee4 04808DE5 		str	r8, [sp, #4]
 5358 2ee8 0600A0E1 		mov	r0, r6
 5359 2eec 00308DE5 		str	r3, [sp]
 5360 2ef0 2010A0E3 		mov	r1, #32
 5361 2ef4 2720A0E3 		mov	r2, #39
 5362 2ef8 3030A0E3 		mov	r3, #48
 5363 2efc FEFFFFEB 		bl	cmdSet
 5364              	.LVL640:
1238:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5365              		.loc 1 1238 0
 5366 2f00 0230A0E3 		mov	r3, #2
 5367 2f04 04808DE5 		str	r8, [sp, #4]
 5368 2f08 0600A0E1 		mov	r0, r6
 5369 2f0c 00308DE5 		str	r3, [sp]
 5370 2f10 2110A0E3 		mov	r1, #33
 5371 2f14 2520A0E3 		mov	r2, #37
 5372 2f18 3030A0E3 		mov	r3, #48
 5373 2f1c FEFFFFEB 		bl	cmdSet
 5374              	.LVL641:
1239:../uvc.c      **** }
 5375              		.loc 1 1239 0
 5376 2f20 1C0096E5 		ldr	r0, [r6, #28]
 5377 2f24 FEFFFFEB 		bl	_txe_mutex_put
 5378              	.LVL642:
 5379 2f28 FF00A0E3 		mov	r0, #255
 5380 2f2c 0080A0E1 		mov	r8, r0
 5381 2f30 0860A0E3 		mov	r6, #8
 5382 2f34 89FEFFEA 		b	.L476
 5383              	.LVL643:
 5384              	.L487:
 5385              	.LBE83:
 5386              	.LBE82:
 5387              	.LBB84:
 5388              	.LBB85:
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5389              		.loc 1 1236 0
 5390 2f38 CC619FE5 		ldr	r6, .L503+20
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5391              		.loc 1 1237 0
 5392 2f3c 0080A0E3 		mov	r8, #0
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5393              		.loc 1 1236 0
 5394 2f40 0010E0E3 		mvn	r1, #0
 5395 2f44 1C0096E5 		ldr	r0, [r6, #28]
 5396 2f48 FEFFFFEB 		bl	_txe_mutex_get
 5397              	.LVL644:
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5398              		.loc 1 1237 0
 5399 2f4c 0600A0E1 		mov	r0, r6
 5400 2f50 00808DE5 		str	r8, [sp]
 5401 2f54 04808DE5 		str	r8, [sp, #4]
 5402 2f58 2010A0E3 		mov	r1, #32
 5403 2f5c 2720A0E3 		mov	r2, #39
 5404 2f60 3030A0E3 		mov	r3, #48
 5405 2f64 FEFFFFEB 		bl	cmdSet
 5406              	.LVL645:
1238:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5407              		.loc 1 1238 0
 5408 2f68 0130A0E3 		mov	r3, #1
 5409 2f6c 04808DE5 		str	r8, [sp, #4]
 5410 2f70 0600A0E1 		mov	r0, r6
 5411 2f74 00308DE5 		str	r3, [sp]
 5412 2f78 2110A0E3 		mov	r1, #33
 5413 2f7c 2520A0E3 		mov	r2, #37
 5414 2f80 3030A0E3 		mov	r3, #48
 5415 2f84 FEFFFFEB 		bl	cmdSet
 5416              	.LVL646:
1239:../uvc.c      **** }
 5417              		.loc 1 1239 0
 5418 2f88 1C0096E5 		ldr	r0, [r6, #28]
 5419 2f8c FEFFFFEB 		bl	_txe_mutex_put
 5420              	.LVL647:
 5421 2f90 FF00A0E3 		mov	r0, #255
 5422 2f94 0080A0E1 		mov	r8, r0
 5423 2f98 0460A0E3 		mov	r6, #4
 5424 2f9c 6FFEFFEA 		b	.L476
 5425              	.LVL648:
 5426              	.L486:
 5427              	.LBE85:
 5428              	.LBE84:
3049:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5429              		.loc 1 3049 0
 5430 2fa0 64619FE5 		ldr	r6, .L503+20
3047:../uvc.c      **** 							dataIdx = 0;
 5431              		.loc 1 3047 0
 5432 2fa4 0080A0E3 		mov	r8, #0
3049:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5433              		.loc 1 3049 0
 5434 2fa8 1C0096E5 		ldr	r0, [r6, #28]
 5435 2fac 0010E0E3 		mvn	r1, #0
3047:../uvc.c      **** 							dataIdx = 0;
 5436              		.loc 1 3047 0
 5437 2fb0 7983C3E5 		strb	r8, [r3, #889]
 5438              	.LVL649:
3049:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5439              		.loc 1 3049 0
 5440 2fb4 FEFFFFEB 		bl	_txe_mutex_get
 5441              	.LVL650:
3050:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5442              		.loc 1 3050 0
 5443 2fb8 0A20A0E1 		mov	r2, r10
 5444 2fbc 0930A0E1 		mov	r3, r9
 5445 2fc0 1010A0E3 		mov	r1, #16
 5446 2fc4 00808DE5 		str	r8, [sp]
 5447 2fc8 04808DE5 		str	r8, [sp, #4]
 5448 2fcc 0600A0E1 		mov	r0, r6
 5449 2fd0 FEFFFFEB 		bl	cmdSet
 5450              	.LVL651:
3051:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5451              		.loc 1 3051 0
 5452 2fd4 1C0096E5 		ldr	r0, [r6, #28]
 5453 2fd8 FEFFFFEB 		bl	_txe_mutex_put
 5454              	.LVL652:
 5455              	.LBB86:
 5456              	.LBB87:
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5457              		.loc 1 1236 0
 5458 2fdc 1C0096E5 		ldr	r0, [r6, #28]
 5459 2fe0 0010E0E3 		mvn	r1, #0
 5460 2fe4 FEFFFFEB 		bl	_txe_mutex_get
 5461              	.LVL653:
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5462              		.loc 1 1237 0
 5463 2fe8 00808DE5 		str	r8, [sp]
 5464 2fec 04808DE5 		str	r8, [sp, #4]
 5465 2ff0 0600A0E1 		mov	r0, r6
 5466 2ff4 2010A0E3 		mov	r1, #32
 5467 2ff8 2720A0E3 		mov	r2, #39
 5468 2ffc 3030A0E3 		mov	r3, #48
 5469 3000 FEFFFFEB 		bl	cmdSet
 5470              	.LVL654:
1238:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5471              		.loc 1 1238 0
 5472 3004 0130A0E3 		mov	r3, #1
 5473 3008 04808DE5 		str	r8, [sp, #4]
 5474 300c 0600A0E1 		mov	r0, r6
 5475 3010 00308DE5 		str	r3, [sp]
 5476 3014 2110A0E3 		mov	r1, #33
 5477 3018 2520A0E3 		mov	r2, #37
 5478 301c 3030A0E3 		mov	r3, #48
 5479 3020 FEFFFFEB 		bl	cmdSet
 5480              	.LVL655:
1239:../uvc.c      **** }
 5481              		.loc 1 1239 0
 5482 3024 1C0096E5 		ldr	r0, [r6, #28]
 5483 3028 FEFFFFEB 		bl	_txe_mutex_put
 5484              	.LVL656:
 5485 302c FF00A0E3 		mov	r0, #255
 5486 3030 0080A0E1 		mov	r8, r0
 5487 3034 0260A0E3 		mov	r6, #2
 5488 3038 48FEFFEA 		b	.L476
 5489              	.LVL657:
 5490              	.L484:
 5491              	.LBE87:
 5492              	.LBE86:
 5493              	.LBB88:
 5494              	.LBB89:
1236:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5495              		.loc 1 1236 0
 5496 303c C8809FE5 		ldr	r8, .L503+20
 5497 3040 0010E0E3 		mvn	r1, #0
 5498 3044 1C0098E5 		ldr	r0, [r8, #28]
 5499 3048 FEFFFFEB 		bl	_txe_mutex_get
 5500              	.LVL658:
1237:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5501              		.loc 1 1237 0
 5502 304c 0090A0E3 		mov	r9, #0
 5503              	.LVL659:
 5504 3050 0160A0E3 		mov	r6, #1
 5505 3054 0800A0E1 		mov	r0, r8
 5506 3058 2010A0E3 		mov	r1, #32
 5507 305c 2720A0E3 		mov	r2, #39
 5508 3060 3030A0E3 		mov	r3, #48
 5509 3064 40028DE8 		stmia	sp, {r6, r9}
 5510 3068 FEFFFFEB 		bl	cmdSet
 5511              	.LVL660:
1238:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5512              		.loc 1 1238 0
 5513 306c 0230A0E3 		mov	r3, #2
 5514 3070 0800A0E1 		mov	r0, r8
 5515 3074 00308DE5 		str	r3, [sp]
 5516 3078 2110A0E3 		mov	r1, #33
 5517 307c 2520A0E3 		mov	r2, #37
 5518 3080 3030A0E3 		mov	r3, #48
 5519 3084 04908DE5 		str	r9, [sp, #4]
 5520 3088 FEFFFFEB 		bl	cmdSet
 5521              	.LVL661:
1239:../uvc.c      **** }
 5522              		.loc 1 1239 0
 5523 308c 1C0098E5 		ldr	r0, [r8, #28]
 5524 3090 FEFFFFEB 		bl	_txe_mutex_put
 5525              	.LVL662:
 5526 3094 FF00A0E3 		mov	r0, #255
 5527 3098 0080A0E1 		mov	r8, r0
 5528 309c 2FFEFFEA 		b	.L476
 5529              	.LVL663:
 5530              	.L483:
 5531              	.LBE89:
 5532              	.LBE88:
3042:../uvc.c      **** 						case 1:
 5533              		.loc 1 3042 0
 5534 30a0 FF00A0E3 		mov	r0, #255
 5535 30a4 0C60A0E1 		mov	r6, ip
 5536 30a8 0080A0E1 		mov	r8, r0
 5537 30ac 2BFEFFEA 		b	.L476
 5538              	.LVL664:
 5539              	.L489:
3113:../uvc.c      **** 					  }
 5540              		.loc 1 3113 0
 5541 30b0 0000A0E3 		mov	r0, #0
 5542 30b4 0020A0E1 		mov	r2, r0
 5543 30b8 0110A0E3 		mov	r1, #1
 5544 30bc FEFFFFEB 		bl	CyU3PUsbStall
 5545              	.LVL665:
 5546 30c0 D1FEFFEA 		b	.L492
 5547              	.LVL666:
 5548              	.L491:
3131:../uvc.c      **** 					  }
 5549              		.loc 1 3131 0
 5550 30c4 0020A0E1 		mov	r2, r0
 5551 30c8 0110A0E3 		mov	r1, #1
 5552 30cc FEFFFFEB 		bl	CyU3PUsbStall
 5553              	.LVL667:
 5554 30d0 CDFEFFEA 		b	.L492
 5555              	.LVL668:
 5556              	.L502:
3146:../uvc.c      **** 					  else
 5557              		.loc 1 3146 0
 5558 30d4 0800A0E3 		mov	r0, #8
 5559              	.L499:
 5560 30d8 0010A0E3 		mov	r1, #0
 5561 30dc 03008DE8 		stmia	sp, {r0, r1}
 5562 30e0 0A20A0E1 		mov	r2, r10
 5563 30e4 0930A0E1 		mov	r3, r9
 5564 30e8 0600A0E1 		mov	r0, r6
 5565 30ec 2310A0E3 		mov	r1, #35
 5566 30f0 FEFFFFEB 		bl	cmdSet
 5567              	.LVL669:
 5568 30f4 97FEFFEA 		b	.L494
 5569              	.L504:
 5570              		.align	2
 5571              	.L503:
 5572 30f8 00000000 		.word	bRequest
 5573 30fc 00000000 		.word	.LANCHOR1
 5574 3100 00000000 		.word	.LANCHOR0
 5575 3104 9C060000 		.word	.LC38
 5576 3108 78060000 		.word	.LC37
 5577 310c 00000000 		.word	cmdQu
 5578 3110 2C060000 		.word	.LC35
 5579 3114 FFFF0000 		.word	65535
 5580 3118 54060000 		.word	.LC36
 5581              		.cfi_endproc
 5582              	.LFE4:
 5584              		.align	2
 5585              		.global	CamDefSet
 5587              	CamDefSet:
 5588              	.LFB5:
3174:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5589              		.loc 1 3174 0
 5590              		.cfi_startproc
 5591              		@ args = 0, pretend = 0, frame = 24
 5592              		@ frame_needed = 0, uses_anonymous_args = 0
 5593              	.LVL670:
 5594 311c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5595              	.LCFI21:
 5596              		.cfi_def_cfa_offset 36
 5597              		.cfi_offset 4, -36
 5598              		.cfi_offset 5, -32
 5599              		.cfi_offset 6, -28
 5600              		.cfi_offset 7, -24
 5601              		.cfi_offset 8, -20
 5602              		.cfi_offset 9, -16
 5603              		.cfi_offset 10, -12
 5604              		.cfi_offset 11, -8
 5605              		.cfi_offset 14, -4
3181:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5606              		.loc 1 3181 0
 5607 3120 B0429FE5 		ldr	r4, .L508
3186:../uvc.c      ****     if(Data1&0x80){
 5608              		.loc 1 3186 0
 5609 3124 B0229FE5 		ldr	r2, .L508+4
3183:../uvc.c      ****     Data1 = Data0;
 5610              		.loc 1 3183 0
 5611 3128 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
3174:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5612              		.loc 1 3174 0
 5613 312c 2CD04DE2 		sub	sp, sp, #44
 5614              	.LCFI22:
 5615              		.cfi_def_cfa_offset 80
3186:../uvc.c      ****     if(Data1&0x80){
 5616              		.loc 1 3186 0
 5617 3130 1C0092E5 		ldr	r0, [r2, #28]
 5618 3134 0010E0E3 		mvn	r1, #0
3188:../uvc.c      ****     }else{
 5619              		.loc 1 3188 0
 5620 3138 2563A0E1 		mov	r6, r5, lsr #6
3182:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5621              		.loc 1 3182 0
 5622 313c 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
3181:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5623              		.loc 1 3181 0
 5624 3140 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5625              	.LVL671:
3186:../uvc.c      ****     if(Data1&0x80){
 5626              		.loc 1 3186 0
 5627 3144 FEFFFFEB 		bl	_txe_mutex_get
 5628              	.LVL672:
3187:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5629              		.loc 1 3187 0
 5630 3148 800015E3 		tst	r5, #128
3188:../uvc.c      ****     }else{
 5631              		.loc 1 3188 0
 5632 314c 01600612 		andne	r6, r6, #1
 5633 3150 0660E011 		mvnne	r6, r6
 5634 3154 3B600612 		andne	r6, r6, #59
 5635 3158 0660E011 		mvnne	r6, r6
 5636 315c FF600612 		andne	r6, r6, #255
 5637              	.LVL673:
3190:../uvc.c      ****     }
 5638              		.loc 1 3190 0
 5639 3160 C6608603 		orreq	r6, r6, #198
 5640              	.LVL674:
3194:../uvc.c      **** 
 5641              		.loc 1 3194 0
 5642 3164 0080A0E3 		mov	r8, #0
3192:../uvc.c      **** 
 5643              		.loc 1 3192 0
 5644 3168 0551A0E1 		mov	r5, r5, asl #2
 5645              	.LVL675:
 5646 316c FF5005E2 		and	r5, r5, #255
 5647              	.LVL676:
3197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5648              		.loc 1 3197 0
 5649 3170 01A0A0E3 		mov	r10, #1
3194:../uvc.c      **** 
 5650              		.loc 1 3194 0
 5651 3174 00608DE5 		str	r6, [sp]
 5652 3178 0920A0E1 		mov	r2, r9
 5653 317c 0730A0E1 		mov	r3, r7
 5654 3180 04808DE5 		str	r8, [sp, #4]
 5655 3184 0110A0E3 		mov	r1, #1
 5656 3188 4C029FE5 		ldr	r0, .L508+4
 5657 318c FEFFFFEB 		bl	cmdSet
 5658              	.LVL677:
3197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5659              		.loc 1 3197 0
 5660 3190 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5661 3194 0730A0E1 		mov	r3, r7
 5662 3198 0A10A0E1 		mov	r1, r10
 5663 319c 00508DE5 		str	r5, [sp]
 5664 31a0 04A08DE5 		str	r10, [sp, #4]
 5665 31a4 30029FE5 		ldr	r0, .L508+4
 5666 31a8 FEFFFFEB 		bl	cmdSet
 5667              	.LVL678:
3200:../uvc.c      **** 
 5668              		.loc 1 3200 0
 5669 31ac 0620A0E1 		mov	r2, r6
 5670 31b0 0530A0E1 		mov	r3, r5
 5671 31b4 24129FE5 		ldr	r1, .L508+8
 5672 31b8 0400A0E3 		mov	r0, #4
3199:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5673              		.loc 1 3199 0
 5674 31bc 1262C4E5 		strb	r6, [r4, #530]
3198:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5675              		.loc 1 3198 0
 5676 31c0 1152C4E5 		strb	r5, [r4, #529]
3200:../uvc.c      **** 
 5677              		.loc 1 3200 0
 5678 31c4 FEFFFFEB 		bl	CyU3PDebugPrint
 5679              	.LVL679:
3205:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5680              		.loc 1 3205 0
 5681 31c8 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5682              	.LVL680:
3206:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5683              		.loc 1 3206 0
 5684 31cc 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5685 31d0 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5686 31d4 40018DE8 		stmia	sp, {r6, r8}
 5687 31d8 FC019FE5 		ldr	r0, .L508+4
 5688 31dc 0210A0E3 		mov	r1, #2
 5689 31e0 FEFFFFEB 		bl	cmdSet
 5690              	.LVL681:
3209:../uvc.c      **** 
 5691              		.loc 1 3209 0
 5692 31e4 0620A0E1 		mov	r2, r6
 5693 31e8 0530A0E1 		mov	r3, r5
 5694 31ec EC119FE5 		ldr	r1, .L508+8
 5695 31f0 0400A0E3 		mov	r0, #4
3207:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5696              		.loc 1 3207 0
 5697 31f4 2952C4E5 		strb	r5, [r4, #553]
3208:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5698              		.loc 1 3208 0
 5699 31f8 6954C4E5 		strb	r5, [r4, #1129]
3209:../uvc.c      **** 
 5700              		.loc 1 3209 0
 5701 31fc FEFFFFEB 		bl	CyU3PDebugPrint
 5702              	.LVL682:
3214:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5703              		.loc 1 3214 0
 5704 3200 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
3213:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5705              		.loc 1 3213 0
 5706 3204 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5707              	.LVL683:
3215:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5708              		.loc 1 3215 0
 5709 3208 80C047E2 		sub	ip, r7, #128
 5710 320c FF300CE2 		and	r3, ip, #255
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5711              		.loc 1 3216 0
 5712 3210 76E047E2 		sub	lr, r7, #118
3215:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5713              		.loc 1 3215 0
 5714 3214 18308DE5 		str	r3, [sp, #24]
 5715 3218 08018DE8 		stmia	sp, {r3, r8}
 5716 321c B8019FE5 		ldr	r0, .L508+4
 5717 3220 0630A0E1 		mov	r3, r6
 5718 3224 0510A0E3 		mov	r1, #5
 5719 3228 DF20A0E3 		mov	r2, #223
 5720 322c 14C08DE5 		str	ip, [sp, #20]
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5721              		.loc 1 3216 0
 5722 3230 1CE08DE5 		str	lr, [sp, #28]
3215:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5723              		.loc 1 3215 0
 5724 3234 FEFFFFEB 		bl	cmdSet
 5725              	.LVL684:
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5726              		.loc 1 3216 0
 5727 3238 1C209DE5 		ldr	r2, [sp, #28]
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5728              		.loc 1 3217 0
 5729 323c 7EE087E2 		add	lr, r7, #126
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5730              		.loc 1 3216 0
 5731 3240 FF3002E2 		and	r3, r2, #255
 5732 3244 08048DE8 		stmia	sp, {r3, r10}
 5733 3248 8C019FE5 		ldr	r0, .L508+4
 5734 324c 0630A0E1 		mov	r3, r6
 5735 3250 0510A0E3 		mov	r1, #5
 5736 3254 DC20A0E3 		mov	r2, #220
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5737              		.loc 1 3217 0
 5738 3258 20E08DE5 		str	lr, [sp, #32]
3216:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5739              		.loc 1 3216 0
 5740 325c FEFFFFEB 		bl	cmdSet
 5741              	.LVL685:
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5742              		.loc 1 3217 0
 5743 3260 20209DE5 		ldr	r2, [sp, #32]
3218:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5744              		.loc 1 3218 0
 5745 3264 72E087E2 		add	lr, r7, #114
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5746              		.loc 1 3217 0
 5747 3268 FF3002E2 		and	r3, r2, #255
 5748 326c 0220A0E3 		mov	r2, #2
 5749 3270 00308DE5 		str	r3, [sp]
 5750 3274 04208DE5 		str	r2, [sp, #4]
 5751 3278 0630A0E1 		mov	r3, r6
 5752 327c 0510A0E3 		mov	r1, #5
 5753 3280 DE20A0E3 		mov	r2, #222
 5754 3284 50019FE5 		ldr	r0, .L508+4
3218:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5755              		.loc 1 3218 0
 5756 3288 24E08DE5 		str	lr, [sp, #36]
3217:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5757              		.loc 1 3217 0
 5758 328c FEFFFFEB 		bl	cmdSet
 5759              	.LVL686:
3218:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5760              		.loc 1 3218 0
 5761 3290 24209DE5 		ldr	r2, [sp, #36]
3219:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5762              		.loc 1 3219 0
 5763 3294 6FB047E2 		sub	fp, r7, #111
3218:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5764              		.loc 1 3218 0
 5765 3298 FF3002E2 		and	r3, r2, #255
 5766 329c 0320A0E3 		mov	r2, #3
 5767 32a0 00308DE5 		str	r3, [sp]
 5768 32a4 04208DE5 		str	r2, [sp, #4]
 5769 32a8 0630A0E1 		mov	r3, r6
 5770 32ac 0510A0E3 		mov	r1, #5
 5771 32b0 E020A0E3 		mov	r2, #224
 5772 32b4 20019FE5 		ldr	r0, .L508+4
 5773 32b8 FEFFFFEB 		bl	cmdSet
 5774              	.LVL687:
3219:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5775              		.loc 1 3219 0
 5776 32bc 0490A0E3 		mov	r9, #4
 5777 32c0 FF300BE2 		and	r3, fp, #255
3220:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5778              		.loc 1 3220 0
 5779 32c4 7F7087E2 		add	r7, r7, #127
 5780              	.LVL688:
3219:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5781              		.loc 1 3219 0
 5782 32c8 00308DE5 		str	r3, [sp]
 5783 32cc 04908DE5 		str	r9, [sp, #4]
 5784 32d0 0630A0E1 		mov	r3, r6
 5785 32d4 0510A0E3 		mov	r1, #5
 5786 32d8 DD20A0E3 		mov	r2, #221
 5787 32dc F8009FE5 		ldr	r0, .L508+4
 5788 32e0 FEFFFFEB 		bl	cmdSet
 5789              	.LVL689:
3220:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5790              		.loc 1 3220 0
 5791 32e4 FF2007E2 		and	r2, r7, #255
 5792 32e8 0510A0E3 		mov	r1, #5
 5793 32ec 0630A0E1 		mov	r3, r6
 5794 32f0 00208DE5 		str	r2, [sp]
 5795 32f4 04108DE5 		str	r1, [sp, #4]
 5796 32f8 E120A0E3 		mov	r2, #225
 5797 32fc D8009FE5 		ldr	r0, .L508+4
 5798 3300 FEFFFFEB 		bl	cmdSet
 5799              	.LVL690:
3222:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5800              		.loc 1 3222 0
 5801 3304 14C09DE5 		ldr	ip, [sp, #20]
 5802 3308 24E09DE5 		ldr	lr, [sp, #36]
 5803 330c 20309DE5 		ldr	r3, [sp, #32]
 5804 3310 0C20A0E1 		mov	r2, ip
3221:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5805              		.loc 1 3221 0
 5806 3314 18C09DE5 		ldr	ip, [sp, #24]
3222:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5807              		.loc 1 3222 0
 5808 3318 04E08DE5 		str	lr, [sp, #4]
 5809 331c 00308DE5 		str	r3, [sp]
 5810 3320 0C708DE5 		str	r7, [sp, #12]
 5811 3324 1C309DE5 		ldr	r3, [sp, #28]
 5812 3328 08B08DE5 		str	fp, [sp, #8]
 5813 332c 0900A0E1 		mov	r0, r9
 5814 3330 AC109FE5 		ldr	r1, .L508+12
3221:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5815              		.loc 1 3221 0
 5816 3334 71C2C4E5 		strb	ip, [r4, #625]
3222:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5817              		.loc 1 3222 0
 5818 3338 FEFFFFEB 		bl	CyU3PDebugPrint
 5819              	.LVL691:
3227:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5820              		.loc 1 3227 0
 5821 333c 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5822              	.LVL692:
3226:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5823              		.loc 1 3226 0
 5824 3340 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5825              	.LVL693:
3228:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5826              		.loc 1 3228 0
 5827 3344 00608DE5 		str	r6, [sp]
 5828 3348 0730A0E1 		mov	r3, r7
 5829 334c 04808DE5 		str	r8, [sp, #4]
 5830 3350 0610A0E3 		mov	r1, #6
 5831 3354 8520A0E3 		mov	r2, #133
 5832 3358 7C009FE5 		ldr	r0, .L508+4
 5833 335c FEFFFFEB 		bl	cmdSet
 5834              	.LVL694:
3229:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5835              		.loc 1 3229 0
 5836 3360 40048DE8 		stmia	sp, {r6, r10}
 5837 3364 70009FE5 		ldr	r0, .L508+4
 5838 3368 0730A0E1 		mov	r3, r7
 5839 336c 0610A0E3 		mov	r1, #6
 5840 3370 8620A0E3 		mov	r2, #134
 5841 3374 FEFFFFEB 		bl	cmdSet
 5842              	.LVL695:
3231:../uvc.c      **** 
 5843              		.loc 1 3231 0
 5844 3378 0620A0E1 		mov	r2, r6
 5845 337c 0530A0E1 		mov	r3, r5
 5846 3380 0900A0E1 		mov	r0, r9
 5847 3384 54109FE5 		ldr	r1, .L508+8
3230:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5848              		.loc 1 3230 0
 5849 3388 8962C4E5 		strb	r6, [r4, #649]
3231:../uvc.c      **** 
 5850              		.loc 1 3231 0
 5851 338c FEFFFFEB 		bl	CyU3PDebugPrint
 5852              	.LVL696:
3236:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5853              		.loc 1 3236 0
 5854 3390 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5855              	.LVL697:
3237:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5856              		.loc 1 3237 0
 5857 3394 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5858 3398 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5859 339c 40018DE8 		stmia	sp, {r6, r8}
 5860 33a0 34009FE5 		ldr	r0, .L508+4
 5861 33a4 0710A0E3 		mov	r1, #7
 5862 33a8 FEFFFFEB 		bl	cmdSet
 5863              	.LVL698:
3239:../uvc.c      **** 
 5864              		.loc 1 3239 0
 5865 33ac 0620A0E1 		mov	r2, r6
 5866 33b0 0530A0E1 		mov	r3, r5
 5867 33b4 0900A0E1 		mov	r0, r9
 5868 33b8 20109FE5 		ldr	r1, .L508+8
3238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5869              		.loc 1 3238 0
 5870 33bc A152C4E5 		strb	r5, [r4, #673]
3239:../uvc.c      **** 
 5871              		.loc 1 3239 0
 5872 33c0 FEFFFFEB 		bl	CyU3PDebugPrint
 5873              	.LVL699:
3241:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5874              		.loc 1 3241 0
 5875 33c4 10209FE5 		ldr	r2, .L508+4
 5876 33c8 1C0092E5 		ldr	r0, [r2, #28]
3244:../uvc.c      **** 
 5877              		.loc 1 3244 0
 5878 33cc 2CD08DE2 		add	sp, sp, #44
 5879              		@ sp needed
 5880 33d0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5881              	.LVL700:
3241:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5882              		.loc 1 3241 0
 5883 33d4 FEFFFFEA 		b	_txe_mutex_put
 5884              	.LVL701:
 5885              	.L509:
 5886              		.align	2
 5887              	.L508:
 5888 33d8 00000000 		.word	.LANCHOR1
 5889 33dc 00000000 		.word	statQu
 5890 33e0 00070000 		.word	.LC39
 5891 33e4 20070000 		.word	.LC40
 5892              		.cfi_endproc
 5893              	.LFE5:
 5895              		.align	2
 5896              		.global	CyFxUVCAddHeader
 5898              	CyFxUVCAddHeader:
 5899              	.LFB6:
3252:../uvc.c      ****     /* Copy header to buffer */
 5900              		.loc 1 3252 0
 5901              		.cfi_startproc
 5902              		@ args = 0, pretend = 0, frame = 0
 5903              		@ frame_needed = 0, uses_anonymous_args = 0
 5904              	.LVL702:
 5905 33e8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5906              	.LCFI23:
 5907              		.cfi_def_cfa_offset 16
 5908              		.cfi_offset 3, -16
 5909              		.cfi_offset 4, -12
 5910              		.cfi_offset 5, -8
 5911              		.cfi_offset 14, -4
3252:../uvc.c      ****     /* Copy header to buffer */
 5912              		.loc 1 3252 0
 5913 33ec 0040A0E1 		mov	r4, r0
 5914 33f0 0150A0E1 		mov	r5, r1
3254:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5915              		.loc 1 3254 0
 5916 33f4 30009FE5 		ldr	r0, .L515
 5917              	.LVL703:
 5918 33f8 0010E0E3 		mvn	r1, #0
 5919              	.LVL704:
 5920 33fc FEFFFFEB 		bl	_txe_mutex_get
 5921              	.LVL705:
3255:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5922              		.loc 1 3255 0
 5923 3400 0400A0E1 		mov	r0, r4
 5924 3404 24109FE5 		ldr	r1, .L515+4
 5925 3408 0C20A0E3 		mov	r2, #12
 5926 340c FEFFFFEB 		bl	CyU3PMemCopy
 5927              	.LVL706:
3256:../uvc.c      **** 
 5928              		.loc 1 3256 0
 5929 3410 14009FE5 		ldr	r0, .L515
 5930 3414 FEFFFFEB 		bl	_txe_mutex_put
 5931              	.LVL707:
3259:../uvc.c      ****     {
 5932              		.loc 1 3259 0
 5933 3418 020015E3 		tst	r5, #2
3261:../uvc.c      ****     }
 5934              		.loc 1 3261 0
 5935 341c 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5936 3420 02308313 		orrne	r3, r3, #2
 5937 3424 0130C415 		strneb	r3, [r4, #1]
 5938 3428 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5939              	.L516:
 5940              		.align	2
 5941              	.L515:
 5942 342c 00000000 		.word	imgHdMux
 5943 3430 EC040000 		.word	.LANCHOR1+1260
 5944              		.cfi_endproc
 5945              	.LFE6:
 5947              		.align	2
 5948              		.global	CyFxAppErrorHandler
 5950              	CyFxAppErrorHandler:
 5951              	.LFB7:
3271:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 5952              		.loc 1 3271 0
 5953              		.cfi_startproc
 5954              		@ Volatile: function does not return.
 5955              		@ args = 0, pretend = 0, frame = 0
 5956              		@ frame_needed = 0, uses_anonymous_args = 0
 5957              	.LVL708:
 5958 3434 08402DE9 		stmfd	sp!, {r3, lr}
 5959              	.LCFI24:
 5960              		.cfi_def_cfa_offset 8
 5961              		.cfi_offset 3, -8
 5962              		.cfi_offset 14, -4
 5963              	.LVL709:
 5964              	.L518:
3281:../uvc.c      ****         CyU3PThreadSleep (1000);
 5965              		.loc 1 3281 0 discriminator 1
 5966 3438 10109FE5 		ldr	r1, .L519
 5967 343c 0400A0E3 		mov	r0, #4
 5968 3440 FEFFFFEB 		bl	CyU3PDebugPrint
 5969              	.LVL710:
3282:../uvc.c      ****     }
 5970              		.loc 1 3282 0 discriminator 1
 5971 3444 FA0FA0E3 		mov	r0, #1000
 5972 3448 FEFFFFEB 		bl	_tx_thread_sleep
 5973              	.LVL711:
 5974 344c F9FFFFEA 		b	.L518
 5975              	.L520:
 5976              		.align	2
 5977              	.L519:
 5978 3450 58070000 		.word	.LC41
 5979              		.cfi_endproc
 5980              	.LFE7:
 5982              		.align	2
 5983              		.global	UVCAppThread_Entry
 5985              	UVCAppThread_Entry:
 5986              	.LFB19:
4258:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 5987              		.loc 1 4258 0
 5988              		.cfi_startproc
 5989              		@ args = 0, pretend = 0, frame = 128
 5990              		@ frame_needed = 0, uses_anonymous_args = 0
 5991              	.LVL712:
 5992 3454 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 5993              	.LCFI25:
 5994              		.cfi_def_cfa_offset 32
 5995              		.cfi_offset 4, -32
 5996              		.cfi_offset 5, -28
 5997              		.cfi_offset 6, -24
 5998              		.cfi_offset 7, -20
 5999              		.cfi_offset 8, -16
 6000              		.cfi_offset 9, -12
 6001              		.cfi_offset 10, -8
 6002              		.cfi_offset 14, -4
 6003 3458 88D04DE2 		sub	sp, sp, #136
 6004              	.LCFI26:
 6005              		.cfi_def_cfa_offset 168
 6006              	.LBB98:
 6007              	.LBB99:
3714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6008              		.loc 1 3714 0
 6009 345c FEFFFFEB 		bl	CyU3PUartInit
 6010              	.LVL713:
3715:../uvc.c      ****     {
 6011              		.loc 1 3715 0
 6012 3460 004050E2 		subs	r4, r0, #0
 6013 3464 2902001A 		bne	.L602
3722:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6014              		.loc 1 3722 0
 6015 3468 582A9FE5 		ldr	r2, .L633
3723:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6016              		.loc 1 3723 0
 6017 346c 0130A0E3 		mov	r3, #1
3731:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6018              		.loc 1 3731 0
 6019 3470 0410A0E1 		mov	r1, r4
 6020 3474 60008DE2 		add	r0, sp, #96
 6021              	.LVL714:
3724:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6022              		.loc 1 3724 0
 6023 3478 7540CDE5 		strb	r4, [sp, #117]
3726:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6024              		.loc 1 3726 0
 6025 347c 64408DE5 		str	r4, [sp, #100]
3727:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6026              		.loc 1 3727 0
 6027 3480 68408DE5 		str	r4, [sp, #104]
3722:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6028              		.loc 1 3722 0
 6029 3484 70208DE5 		str	r2, [sp, #112]
3723:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6030              		.loc 1 3723 0
 6031 3488 7430CDE5 		strb	r3, [sp, #116]
3725:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6032              		.loc 1 3725 0
 6033 348c 60308DE5 		str	r3, [sp, #96]
3728:../uvc.c      **** 
 6034              		.loc 1 3728 0
 6035 3490 6C308DE5 		str	r3, [sp, #108]
3731:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6036              		.loc 1 3731 0
 6037 3494 FEFFFFEB 		bl	CyU3PUartSetConfig
 6038              	.LVL715:
3732:../uvc.c      ****     {
 6039              		.loc 1 3732 0
 6040 3498 000050E3 		cmp	r0, #0
 6041 349c B201001A 		bne	.L601
3738:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6042              		.loc 1 3738 0
 6043 34a0 0000E0E3 		mvn	r0, #0
 6044              	.LVL716:
 6045 34a4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6046              	.LVL717:
3739:../uvc.c      ****     {
 6047              		.loc 1 3739 0
 6048 34a8 000050E3 		cmp	r0, #0
 6049 34ac AE01001A 		bne	.L601
3745:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6050              		.loc 1 3745 0
 6051 34b0 0300A0E3 		mov	r0, #3
 6052              	.LVL718:
 6053 34b4 0410A0E3 		mov	r1, #4
 6054 34b8 FEFFFFEB 		bl	CyU3PDebugInit
 6055              	.LVL719:
3746:../uvc.c      ****     {
 6056              		.loc 1 3746 0
 6057 34bc 000050E3 		cmp	r0, #0
 6058 34c0 A901001A 		bne	.L601
3752:../uvc.c      **** }
 6059              		.loc 1 3752 0
 6060 34c4 FEFFFFEB 		bl	CyU3PDebugPreamble
 6061              	.LVL720:
 6062 34c8 0640A0E3 		mov	r4, #6
 6063              	.LVL721:
 6064              	.L527:
 6065              	.LBE99:
 6066              	.LBE98:
4274:../uvc.c      **** 	}
 6067              		.loc 1 4274 0
 6068 34cc 7D0FA0E3 		mov	r0, #500
 6069 34d0 014044E2 		sub	r4, r4, #1
 6070 34d4 FEFFFFEB 		bl	_tx_thread_sleep
 6071              	.LVL722:
4273:../uvc.c      **** 		CyU3PThreadSleep(500);
 6072              		.loc 1 4273 0
 6073 34d8 FF4014E2 		ands	r4, r4, #255
 6074 34dc FAFFFF1A 		bne	.L527
 6075              	.LBB101:
 6076              	.LBB102:
3762:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6077              		.loc 1 3762 0
 6078 34e0 FEFFFFEB 		bl	CyU3PI2cInit
 6079              	.LVL723:
3763:../uvc.c      ****     {
 6080              		.loc 1 3763 0
 6081 34e4 005050E2 		subs	r5, r0, #0
 6082 34e8 3002001A 		bne	.L603
3770:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6083              		.loc 1 3770 0
 6084 34ec D8299FE5 		ldr	r2, .L633+4
3772:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6085              		.loc 1 3772 0
 6086 34f0 0030E0E3 		mvn	r3, #0
3775:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6087              		.loc 1 3775 0
 6088 34f4 60008DE2 		add	r0, sp, #96
 6089              	.LVL724:
 6090 34f8 0410A0E1 		mov	r1, r4
3771:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6091              		.loc 1 3771 0
 6092 34fc 64408DE5 		str	r4, [sp, #100]
3770:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6093              		.loc 1 3770 0
 6094 3500 60208DE5 		str	r2, [sp, #96]
3772:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6095              		.loc 1 3772 0
 6096 3504 68308DE5 		str	r3, [sp, #104]
3773:../uvc.c      **** 
 6097              		.loc 1 3773 0
 6098 3508 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3775:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6099              		.loc 1 3775 0
 6100 350c FEFFFFEB 		bl	CyU3PI2cSetConfig
 6101              	.LVL725:
3776:../uvc.c      ****     {
 6102              		.loc 1 3776 0
 6103 3510 005050E2 		subs	r5, r0, #0
 6104 3514 2002001A 		bne	.L604
 6105              	.LBE102:
 6106              	.LBE101:
 6107              	.LBB104:
 6108              	.LBB105:
3849:../uvc.c      ****     if (apiRetStatus != 0)
 6109              		.loc 1 3849 0
 6110 3518 B0799FE5 		ldr	r7, .L633+8
 6111 351c 0410A0E1 		mov	r1, r4
 6112 3520 0700A0E1 		mov	r0, r7
 6113              	.LVL726:
 6114 3524 2820A0E3 		mov	r2, #40
 6115 3528 FEFFFFEB 		bl	_txe_event_flags_create
 6116              	.LVL727:
3850:../uvc.c      ****     {
 6117              		.loc 1 3850 0
 6118 352c 005050E2 		subs	r5, r0, #0
 6119              	.LVL728:
 6120 3530 1302001A 		bne	.L605
3864:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6121              		.loc 1 3864 0
 6122 3534 0230A0E3 		mov	r3, #2
3867:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6123              		.loc 1 3867 0
 6124 3538 0320A0E3 		mov	r2, #3
3871:../uvc.c      ****     if (apiRetStatus != 0)
 6125              		.loc 1 3871 0
 6126 353c 14008DE2 		add	r0, sp, #20
 6127              	.LVL729:
 6128 3540 0410A0E1 		mov	r1, r4
3860:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6129              		.loc 1 3860 0
 6130 3544 8C4087E5 		str	r4, [r7, #140]
3861:../uvc.c      **** 
 6131              		.loc 1 3861 0
 6132 3548 904087E5 		str	r4, [r7, #144]
3866:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6133              		.loc 1 3866 0
 6134 354c 1C40CDE5 		strb	r4, [sp, #28]
3868:../uvc.c      **** 
 6135              		.loc 1 3868 0
 6136 3550 18408DE5 		str	r4, [sp, #24]
3864:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6137              		.loc 1 3864 0
 6138 3554 1430CDE5 		strb	r3, [sp, #20]
3865:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6139              		.loc 1 3865 0
 6140 3558 1530CDE5 		strb	r3, [sp, #21]
3867:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6141              		.loc 1 3867 0
 6142 355c 1D20CDE5 		strb	r2, [sp, #29]
3871:../uvc.c      ****     if (apiRetStatus != 0)
 6143              		.loc 1 3871 0
 6144 3560 FEFFFFEB 		bl	CyU3PGpioInit
 6145              	.LVL730:
3872:../uvc.c      ****     {
 6146              		.loc 1 3872 0
 6147 3564 005050E2 		subs	r5, r0, #0
 6148 3568 FF01001A 		bne	.L606
3880:../uvc.c      ****     if (apiRetStatus != 0)
 6149              		.loc 1 3880 0
 6150 356c 1600A0E3 		mov	r0, #22
 6151              	.LVL731:
 6152 3570 0110A0E3 		mov	r1, #1
 6153 3574 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6154              	.LVL732:
3881:../uvc.c      ****     {
 6155              		.loc 1 3881 0
 6156 3578 005050E2 		subs	r5, r0, #0
 6157 357c 3A02001A 		bne	.L607
3886:../uvc.c      ****     if (apiRetStatus != 0)
 6158              		.loc 1 3886 0
 6159 3580 1400A0E3 		mov	r0, #20
 6160              	.LVL733:
 6161 3584 0110A0E3 		mov	r1, #1
 6162 3588 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6163              	.LVL734:
3887:../uvc.c      ****     {
 6164              		.loc 1 3887 0
 6165 358c 005050E2 		subs	r5, r0, #0
 6166 3590 2F02001A 		bne	.L608
3892:../uvc.c      ****     if (apiRetStatus != 0)
 6167              		.loc 1 3892 0
 6168 3594 1800A0E3 		mov	r0, #24
 6169              	.LVL735:
 6170 3598 0110A0E3 		mov	r1, #1
 6171 359c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6172              	.LVL736:
3893:../uvc.c      ****     {
 6173              		.loc 1 3893 0
 6174 35a0 005050E2 		subs	r5, r0, #0
 6175 35a4 2402001A 		bne	.L609
3900:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6176              		.loc 1 3900 0
 6177 35a8 0150A0E3 		mov	r5, #1
3905:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6178              		.loc 1 3905 0
 6179 35ac 30108DE2 		add	r1, sp, #48
 6180 35b0 1600A0E3 		mov	r0, #22
 6181              	.LVL737:
3903:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6182              		.loc 1 3903 0
 6183 35b4 3C408DE5 		str	r4, [sp, #60]
3904:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6184              		.loc 1 3904 0
 6185 35b8 4040CDE5 		strb	r4, [sp, #64]
3900:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6186              		.loc 1 3900 0
 6187 35bc 30508DE5 		str	r5, [sp, #48]
3901:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6188              		.loc 1 3901 0
 6189 35c0 34508DE5 		str	r5, [sp, #52]
3902:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6190              		.loc 1 3902 0
 6191 35c4 38508DE5 		str	r5, [sp, #56]
3905:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6192              		.loc 1 3905 0
 6193 35c8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6194              	.LVL738:
3906:../uvc.c      ****     {
 6195              		.loc 1 3906 0
 6196 35cc 006050E2 		subs	r6, r0, #0
 6197 35d0 1302001A 		bne	.L610
3919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6198              		.loc 1 3919 0
 6199 35d4 1400A0E3 		mov	r0, #20
 6200              	.LVL739:
 6201 35d8 30108DE2 		add	r1, sp, #48
3917:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6202              		.loc 1 3917 0
 6203 35dc 3C408DE5 		str	r4, [sp, #60]
3918:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6204              		.loc 1 3918 0
 6205 35e0 4040CDE5 		strb	r4, [sp, #64]
3914:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6206              		.loc 1 3914 0
 6207 35e4 30508DE5 		str	r5, [sp, #48]
3915:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6208              		.loc 1 3915 0
 6209 35e8 34508DE5 		str	r5, [sp, #52]
3916:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6210              		.loc 1 3916 0
 6211 35ec 38508DE5 		str	r5, [sp, #56]
3919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6212              		.loc 1 3919 0
 6213 35f0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6214              	.LVL740:
3920:../uvc.c      ****     {
 6215              		.loc 1 3920 0
 6216 35f4 004050E2 		subs	r4, r0, #0
 6217 35f8 0302001A 		bne	.L611
3928:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6218              		.loc 1 3928 0
 6219 35fc 0030A0E3 		mov	r3, #0
3933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6220              		.loc 1 3933 0
 6221 3600 30108DE2 		add	r1, sp, #48
3931:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6222              		.loc 1 3931 0
 6223 3604 0150A0E3 		mov	r5, #1
3933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6224              		.loc 1 3933 0
 6225 3608 1800A0E3 		mov	r0, #24
 6226              	.LVL741:
3928:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6227              		.loc 1 3928 0
 6228 360c 30308DE5 		str	r3, [sp, #48]
3929:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6229              		.loc 1 3929 0
 6230 3610 34308DE5 		str	r3, [sp, #52]
3930:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6231              		.loc 1 3930 0
 6232 3614 38308DE5 		str	r3, [sp, #56]
3932:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6233              		.loc 1 3932 0
 6234 3618 4030CDE5 		strb	r3, [sp, #64]
3931:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6235              		.loc 1 3931 0
 6236 361c 3C508DE5 		str	r5, [sp, #60]
3933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6237              		.loc 1 3933 0
 6238 3620 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6239              	.LVL742:
3934:../uvc.c      ****     {
 6240              		.loc 1 3934 0
 6241 3624 004050E2 		subs	r4, r0, #0
 6242 3628 F101001A 		bne	.L612
3941:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6243              		.loc 1 3941 0
 6244 362c 0260A0E3 		mov	r6, #2
3942:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6245              		.loc 1 3942 0
 6246 3630 0380A0E3 		mov	r8, #3
3946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6247              		.loc 1 3946 0
 6248 3634 0500A0E1 		mov	r0, r5
 6249              	.LVL743:
 6250 3638 20108DE2 		add	r1, sp, #32
3943:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6251              		.loc 1 3943 0
 6252 363c 28408DE5 		str	r4, [sp, #40]
3944:../uvc.c      **** 
 6253              		.loc 1 3944 0
 6254 3640 24408DE5 		str	r4, [sp, #36]
3941:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6255              		.loc 1 3941 0
 6256 3644 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3942:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6257              		.loc 1 3942 0
 6258 3648 2C80CDE5 		strb	r8, [sp, #44]
3946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6259              		.loc 1 3946 0
 6260 364c FEFFFFEB 		bl	CyU3PPibInit
 6261              	.LVL744:
3947:../uvc.c      ****     {
 6262              		.loc 1 3947 0
 6263 3650 004050E2 		subs	r4, r0, #0
 6264 3654 E001001A 		bne	.L613
3954:../uvc.c      **** 
 6265              		.loc 1 3954 0
 6266 3658 74089FE5 		ldr	r0, .L633+12
 6267              	.LVL745:
 6268 365c FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6269              	.LVL746:
3962:../uvc.c      ****     CyU3PThreadSleep(5000);
 6270              		.loc 1 3962 0
 6271 3660 FEFFFFEB 		bl	SensorReset
 6272              	.LVL747:
3963:../uvc.c      ****     //SensorInit ();
 6273              		.loc 1 3963 0
 6274 3664 6C089FE5 		ldr	r0, .L633+16
 6275 3668 FEFFFFEB 		bl	_tx_thread_sleep
 6276              	.LVL748:
3967:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6277              		.loc 1 3967 0
 6278 366c FEFFFFEB 		bl	CyU3PUsbStart
 6279              	.LVL749:
3968:../uvc.c      ****     {
 6280              		.loc 1 3968 0
 6281 3670 004050E2 		subs	r4, r0, #0
 6282 3674 D201001A 		bne	.L614
3974:../uvc.c      **** 
 6283              		.loc 1 3974 0
 6284 3678 0410A0E1 		mov	r1, r4
 6285 367c 58089FE5 		ldr	r0, .L633+20
 6286              	.LVL750:
 6287 3680 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6288              	.LVL751:
3977:../uvc.c      **** 
 6289              		.loc 1 3977 0
 6290 3684 54089FE5 		ldr	r0, .L633+24
 6291 3688 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6292              	.LVL752:
3983:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6293              		.loc 1 3983 0
 6294 368c 0410A0E1 		mov	r1, r4
 6295 3690 4C289FE5 		ldr	r2, .L633+28
 6296 3694 0500A0E1 		mov	r0, r5
 6297 3698 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6298              	.LVL753:
3984:../uvc.c      **** 
 6299              		.loc 1 3984 0
 6300 369c 0410A0E1 		mov	r1, r4
 6301 36a0 0400A0E1 		mov	r0, r4
 6302 36a4 3C289FE5 		ldr	r2, .L633+32
 6303 36a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6304              	.LVL754:
3987:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6305              		.loc 1 3987 0
 6306 36ac 0410A0E1 		mov	r1, r4
 6307 36b0 34289FE5 		ldr	r2, .L633+36
 6308 36b4 0600A0E1 		mov	r0, r6
 6309 36b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6310              	.LVL755:
3988:../uvc.c      **** 
 6311              		.loc 1 3988 0
 6312 36bc 0410A0E1 		mov	r1, r4
 6313 36c0 28289FE5 		ldr	r2, .L633+40
 6314 36c4 0700A0E3 		mov	r0, #7
 6315 36c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6316              	.LVL756:
3991:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6317              		.loc 1 3991 0
 6318 36cc 0410A0E1 		mov	r1, r4
 6319 36d0 1C289FE5 		ldr	r2, .L633+44
 6320 36d4 0400A0E3 		mov	r0, #4
 6321 36d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6322              	.LVL757:
3992:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6323              		.loc 1 3992 0
 6324 36dc 0410A0E1 		mov	r1, r4
 6325 36e0 10289FE5 		ldr	r2, .L633+48
 6326 36e4 0800A0E1 		mov	r0, r8
 6327 36e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6328              	.LVL758:
3993:../uvc.c      **** 
 6329              		.loc 1 3993 0
 6330 36ec 0410A0E1 		mov	r1, r4
 6331 36f0 04289FE5 		ldr	r2, .L633+52
 6332 36f4 0600A0E3 		mov	r0, #6
 6333 36f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6334              	.LVL759:
3996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6335              		.loc 1 3996 0
 6336 36fc 0410A0E1 		mov	r1, r4
 6337 3700 F8279FE5 		ldr	r2, .L633+56
 6338 3704 0500A0E3 		mov	r0, #5
 6339 3708 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6340              	.LVL760:
3997:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6341              		.loc 1 3997 0
 6342 370c 0510A0E1 		mov	r1, r5
 6343 3710 EC279FE5 		ldr	r2, .L633+60
 6344 3714 0500A0E3 		mov	r0, #5
 6345 3718 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6346              	.LVL761:
3998:../uvc.c      **** 
 6347              		.loc 1 3998 0
 6348 371c 0610A0E1 		mov	r1, r6
 6349 3720 E0279FE5 		ldr	r2, .L633+64
 6350 3724 0500A0E3 		mov	r0, #5
 6351 3728 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6352              	.LVL762:
4007:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6353              		.loc 1 4007 0
 6354 372c 4030A0E3 		mov	r3, #64
4011:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6355              		.loc 1 4011 0
 6356 3730 08108DE2 		add	r1, sp, #8
 6357 3734 8200A0E3 		mov	r0, #130
4008:../uvc.c      ****     endPointConfig.streams  = 0;
 6358              		.loc 1 4008 0
 6359 3738 1340CDE5 		strb	r4, [sp, #19]
4009:../uvc.c      ****     endPointConfig.burstLen = 1;
 6360              		.loc 1 4009 0
 6361 373c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
4005:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6362              		.loc 1 4005 0
 6363 3740 08508DE5 		str	r5, [sp, #8]
4006:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6364              		.loc 1 4006 0
 6365 3744 0C80CDE5 		strb	r8, [sp, #12]
4010:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6366              		.loc 1 4010 0
 6367 3748 1250CDE5 		strb	r5, [sp, #18]
4007:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6368              		.loc 1 4007 0
 6369 374c B031CDE1 		strh	r3, [sp, #16]	@ movhi
4011:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6370              		.loc 1 4011 0
 6371 3750 FEFFFFEB 		bl	CyU3PSetEpConfig
 6372              	.LVL763:
4012:../uvc.c      ****     {
 6373              		.loc 1 4012 0
 6374 3754 004050E2 		subs	r4, r0, #0
4015:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6375              		.loc 1 4015 0
 6376 3758 0400A013 		movne	r0, #4
 6377              	.LVL764:
4012:../uvc.c      ****     {
 6378              		.loc 1 4012 0
 6379 375c 7101001A 		bne	.L599
4020:../uvc.c      ****     dmaInterConfig.count          = 1;
 6380              		.loc 1 4020 0
 6381 3760 A4C79FE5 		ldr	ip, .L633+68
 6382 3764 413BA0E3 		mov	r3, #66560
4029:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6383              		.loc 1 4029 0
 6384 3768 1080A0E3 		mov	r8, #16
4031:../uvc.c      ****             &dmaInterConfig);
 6385              		.loc 1 4031 0
 6386 376c 9C079FE5 		ldr	r0, .L633+72
 6387 3770 0410A0E3 		mov	r1, #4
 6388 3774 44208DE2 		add	r2, sp, #68
4020:../uvc.c      ****     dmaInterConfig.count          = 1;
 6389              		.loc 1 4020 0
 6390 3778 4C408DE5 		str	r4, [sp, #76]
 6391 377c 50408DE5 		str	r4, [sp, #80]
4028:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6392              		.loc 1 4028 0
 6393 3780 5440CDE5 		strb	r4, [sp, #84]
4030:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6394              		.loc 1 4030 0
 6395 3784 5C408DE5 		str	r4, [sp, #92]
4020:../uvc.c      ****     dmaInterConfig.count          = 1;
 6396              		.loc 1 4020 0
 6397 3788 48C08DE5 		str	ip, [sp, #72]
 6398 378c 44308DE5 		str	r3, [sp, #68]
4029:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6399              		.loc 1 4029 0
 6400 3790 58808DE5 		str	r8, [sp, #88]
4031:../uvc.c      ****             &dmaInterConfig);
 6401              		.loc 1 4031 0
 6402 3794 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6403              	.LVL765:
4033:../uvc.c      ****     {
 6404              		.loc 1 4033 0
 6405 3798 004050E2 		subs	r4, r0, #0
 6406 379c BE01001A 		bne	.L615
4040:../uvc.c      ****     if (glInterStaBuffer == 0)
 6407              		.loc 1 4040 0
 6408 37a0 010BA0E3 		mov	r0, #1024
 6409              	.LVL766:
 6410 37a4 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6411              	.LVL767:
 6412 37a8 64379FE5 		ldr	r3, .L633+76
4041:../uvc.c      ****     {
 6413              		.loc 1 4041 0
 6414 37ac 000050E3 		cmp	r0, #0
4040:../uvc.c      ****     if (glInterStaBuffer == 0)
 6415              		.loc 1 4040 0
 6416 37b0 000083E5 		str	r0, [r3]
4041:../uvc.c      ****     {
 6417              		.loc 1 4041 0
 6418 37b4 BE01000A 		beq	.L616
4048:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6419              		.loc 1 4048 0
 6420 37b8 0410A0E1 		mov	r1, r4
 6421 37bc 0420A0E1 		mov	r2, r4
 6422 37c0 3830A0E3 		mov	r3, #56
 6423 37c4 4C079FE5 		ldr	r0, .L633+80
 6424 37c8 FEFFFFEB 		bl	_txe_mutex_create
 6425              	.LVL768:
4053:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6426              		.loc 1 4053 0
 6427 37cc 48179FE5 		ldr	r1, .L633+84
4054:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6428              		.loc 1 4054 0
 6429 37d0 48279FE5 		ldr	r2, .L633+88
4061:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6430              		.loc 1 4061 0
 6431 37d4 48A79FE5 		ldr	r10, .L633+92
4050:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6432              		.loc 1 4050 0
 6433 37d8 0480A0E3 		mov	r8, #4
4052:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6434              		.loc 1 4052 0
 6435 37dc 01ECA0E3 		mov	lr, #256
4056:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6436              		.loc 1 4056 0
 6437 37e0 0CC0A0E3 		mov	ip, #12
4060:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6438              		.loc 1 4060 0
 6439 37e4 1830A0E3 		mov	r3, #24
4053:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6440              		.loc 1 4053 0
 6441 37e8 B816CDE1 		strh	r1, [sp, #104]	@ movhi
4054:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6442              		.loc 1 4054 0
 6443 37ec BE26CDE1 		strh	r2, [sp, #110]	@ movhi
4049:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6444              		.loc 1 4049 0
 6445 37f0 0199A0E3 		mov	r9, #16384
4062:../uvc.c      ****             &dmaMultiConfig);
 6446              		.loc 1 4062 0
 6447 37f4 2C079FE5 		ldr	r0, .L633+96
 6448 37f8 0710A0E3 		mov	r1, #7
 6449 37fc 60208DE2 		add	r2, sp, #96
4055:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6450              		.loc 1 4055 0
 6451 3800 B647CDE1 		strh	r4, [sp, #118]	@ movhi
4058:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6452              		.loc 1 4058 0
 6453 3804 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
4059:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6454              		.loc 1 4059 0
 6455 3808 7E40CDE5 		strb	r4, [sp, #126]
4051:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6456              		.loc 1 4051 0
 6457 380c B466CDE1 		strh	r6, [sp, #100]	@ movhi
4061:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6458              		.loc 1 4061 0
 6459 3810 84A08DE5 		str	r10, [sp, #132]
4049:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6460              		.loc 1 4049 0
 6461 3814 B096CDE1 		strh	r9, [sp, #96]	@ movhi
4050:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6462              		.loc 1 4050 0
 6463 3818 B286CDE1 		strh	r8, [sp, #98]	@ movhi
4057:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6464              		.loc 1 4057 0
 6465 381c BA87CDE1 		strh	r8, [sp, #122]	@ movhi
4052:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6466              		.loc 1 4052 0
 6467 3820 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
4056:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6468              		.loc 1 4056 0
 6469 3824 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
4060:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6470              		.loc 1 4060 0
 6471 3828 80308DE5 		str	r3, [sp, #128]
4062:../uvc.c      ****             &dmaMultiConfig);
 6472              		.loc 1 4062 0
 6473 382c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6474              	.LVL769:
4064:../uvc.c      ****     {
 6475              		.loc 1 4064 0
 6476 3830 004050E2 		subs	r4, r0, #0
 6477 3834 9201001A 		bne	.L617
4155:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6478              		.loc 1 4155 0
 6479 3838 0500A0E1 		mov	r0, r5
 6480              	.LVL770:
 6481 383c 0510A0E1 		mov	r1, r5
 6482 3840 FEFFFFEB 		bl	CyU3PConnectState
 6483              	.LVL771:
4156:../uvc.c      ****     {
 6484              		.loc 1 4156 0
 6485 3844 004050E2 		subs	r4, r0, #0
 6486 3848 3B01001A 		bne	.L618
4162:../uvc.c      **** 
 6487              		.loc 1 4162 0
 6488 384c 6400A0E3 		mov	r0, #100
 6489              	.LVL772:
 6490 3850 FEFFFFEB 		bl	CyFx3BusyWait
 6491              	.LVL773:
4164:../uvc.c      **** 
 6492              		.loc 1 4164 0
 6493 3854 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6494              	.LVL774:
4179:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6495              		.loc 1 4179 0
 6496 3858 08108DE2 		add	r1, sp, #8
4178:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6497              		.loc 1 4178 0
 6498 385c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
4166:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6499              		.loc 1 4166 0
 6500 3860 08508DE5 		str	r5, [sp, #8]
4167:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6501              		.loc 1 4167 0
 6502 3864 0C60CDE5 		strb	r6, [sp, #12]
4171:../uvc.c      ****     }
 6503              		.loc 1 4171 0
 6504 3868 030050E3 		cmp	r0, #3
4164:../uvc.c      **** 
 6505              		.loc 1 4164 0
 6506 386c 0030A0E1 		mov	r3, r0
4171:../uvc.c      ****     }
 6507              		.loc 1 4171 0
 6508 3870 01C0A013 		movne	ip, #1
 6509 3874 10C0A003 		moveq	ip, #16
 6510 3878 022CA013 		movne	r2, #512
 6511 387c 012BA003 		moveq	r2, #1024
4179:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6512              		.loc 1 4179 0
 6513 3880 8300A0E3 		mov	r0, #131
4164:../uvc.c      **** 
 6514              		.loc 1 4164 0
 6515 3884 4830C7E5 		strb	r3, [r7, #72]
 6516 3888 12C0CDE5 		strb	ip, [sp, #18]
 6517 388c B021CDE1 		strh	r2, [sp, #16]	@ movhi
4179:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6518              		.loc 1 4179 0
 6519 3890 FEFFFFEB 		bl	CyU3PSetEpConfig
 6520              	.LVL775:
4180:../uvc.c      ****     {
 6521              		.loc 1 4180 0
 6522 3894 004050E2 		subs	r4, r0, #0
 6523              	.LBE105:
 6524              	.LBE104:
4303:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6525              		.loc 1 4303 0
 6526 3898 30469F05 		ldreq	r4, .L633+8
 6527              	.LBB110:
 6528              	.LBB106:
4180:../uvc.c      ****     {
 6529              		.loc 1 4180 0
 6530 389c 0C00000A 		beq	.L578
 6531 38a0 1F0100EA 		b	.L632
 6532              	.LVL776:
 6533              	.L621:
 6534              	.LBE106:
 6535              	.LBE110:
4349:../uvc.c      ****             {
 6536              		.loc 1 4349 0
 6537 38a4 7C3094E5 		ldr	r3, [r4, #124]
 6538 38a8 050053E1 		cmp	r3, r5
 6539 38ac 0300000A 		beq	.L548
4349:../uvc.c      ****             {
 6540              		.loc 1 4349 0 is_stmt 0 discriminator 1
 6541 38b0 B028D4E1 		ldrh	r2, [r4, #128]
 6542 38b4 B238D4E1 		ldrh	r3, [r4, #130]
 6543 38b8 030052E1 		cmp	r2, r3
 6544 38bc 3B00000A 		beq	.L620
 6545              	.L548:
4553:../uvc.c      **** 
 6546              		.loc 1 4553 0 is_stmt 1
 6547 38c0 4010A0E3 		mov	r1, #64
 6548 38c4 0020A0E3 		mov	r2, #0
 6549 38c8 00069FE5 		ldr	r0, .L633+8
 6550 38cc FEFFFFEB 		bl	_txe_event_flags_set
 6551              	.LVL777:
4556:../uvc.c      ****     }
 6552              		.loc 1 4556 0
 6553 38d0 FEFFFFEB 		bl	_txe_thread_relinquish
 6554              	.LVL778:
 6555              	.L578:
4303:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6556              		.loc 1 4303 0
 6557 38d4 0050A0E3 		mov	r5, #0
 6558 38d8 00508DE5 		str	r5, [sp]
 6559 38dc EC059FE5 		ldr	r0, .L633+8
 6560 38e0 0110A0E3 		mov	r1, #1
 6561 38e4 0220A0E3 		mov	r2, #2
 6562 38e8 60308DE2 		add	r3, sp, #96
 6563 38ec FEFFFFEB 		bl	_txe_event_flags_get
 6564              	.LVL779:
 6565 38f0 006050E2 		subs	r6, r0, #0
 6566 38f4 EAFFFF0A 		beq	.L621
4460:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6567              		.loc 1 4460 0
 6568 38f8 00508DE5 		str	r5, [sp]
 6569 38fc CC059FE5 		ldr	r0, .L633+8
 6570 3900 0210A0E3 		mov	r1, #2
 6571 3904 0320A0E3 		mov	r2, #3
 6572 3908 60308DE2 		add	r3, sp, #96
 6573 390c FEFFFFEB 		bl	_txe_event_flags_get
 6574              	.LVL780:
 6575 3910 000050E3 		cmp	r0, #0
 6576 3914 0B00001A 		bne	.L570
4475:../uvc.c      ****                 {
 6577              		.loc 1 4475 0
 6578 3918 903094E5 		ldr	r3, [r4, #144]
4463:../uvc.c      ****                 prodCount = 0;
 6579              		.loc 1 4463 0
 6580 391c 7C0084E5 		str	r0, [r4, #124]
4475:../uvc.c      ****                 {
 6581              		.loc 1 4475 0
 6582 3920 000053E3 		cmp	r3, #0
4464:../uvc.c      ****                 consCount = 0;
 6583              		.loc 1 4464 0
 6584 3924 B008C4E1 		strh	r0, [r4, #128]	@ movhi
4471:../uvc.c      ****                 pb=0;
 6585              		.loc 1 4471 0
 6586 3928 B407C4E1 		strh	r0, [r4, #116]	@ movhi
4465:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6587              		.loc 1 4465 0
 6588 392c B208C4E1 		strh	r0, [r4, #130]	@ movhi
4472:../uvc.c      ****                 pbc=0;
 6589              		.loc 1 4472 0
 6590 3930 B607C4E1 		strh	r0, [r4, #118]	@ movhi
4473:../uvc.c      **** 
 6591              		.loc 1 4473 0
 6592 3934 B807C4E1 		strh	r0, [r4, #120]	@ movhi
4475:../uvc.c      ****                 {
 6593              		.loc 1 4475 0
 6594 3938 4600000A 		beq	.L622
 6595              	.L571:
4487:../uvc.c      ****             }
 6596              		.loc 1 4487 0
 6597 393c 0030A0E3 		mov	r3, #0
 6598 3940 903087E5 		str	r3, [r7, #144]
 6599 3944 DDFFFFEA 		b	.L548
 6600              	.L570:
4492:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6601              		.loc 1 4492 0
 6602 3948 0030E0E3 		mvn	r3, #0
 6603 394c 00308DE5 		str	r3, [sp]
 6604 3950 0110A0E3 		mov	r1, #1
 6605 3954 0220A0E3 		mov	r2, #2
 6606 3958 60308DE2 		add	r3, sp, #96
 6607 395c 6C059FE5 		ldr	r0, .L633+8
 6608 3960 FEFFFFEB 		bl	_txe_event_flags_get
 6609              	.LVL781:
4496:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6610              		.loc 1 4496 0
 6611 3964 0510A0E1 		mov	r1, r5
 6612 3968 0520A0E1 		mov	r2, r5
 6613 396c B4059FE5 		ldr	r0, .L633+96
 6614 3970 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6615              	.LVL782:
4497:../uvc.c      ****                 {
 6616              		.loc 1 4497 0
 6617 3974 005050E2 		subs	r5, r0, #0
 6618 3978 9D00001A 		bne	.L623
4505:../uvc.c      ****                 {
 6619              		.loc 1 4505 0
 6620 397c 883094E5 		ldr	r3, [r4, #136]
 6621 3980 000053E3 		cmp	r3, #0
 6622 3984 2B00001A 		bne	.L569
 6623              	.LVL783:
 6624              	.LBB111:
 6625              	.LBB112:
4208:../uvc.c      ****     {
 6626              		.loc 1 4208 0
 6627 3988 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6628 398c 030053E3 		cmp	r3, #3
 6629 3990 5E00000A 		beq	.L624
4213:../uvc.c      ****     {
 6630              		.loc 1 4213 0
 6631 3994 020053E3 		cmp	r3, #2
 6632 3998 7400000A 		beq	.L625
 6633              	.LVL784:
 6634              	.L576:
 6635              	.LBE112:
 6636              	.LBE111:
4541:../uvc.c      ****                     CyU3PThreadSleep(200);
 6637              		.loc 1 4541 0
 6638 399c 0130A0E3 		mov	r3, #1
4542:../uvc.c      ****                     
 6639              		.loc 1 4542 0
 6640 39a0 C800A0E3 		mov	r0, #200
4541:../uvc.c      ****                     CyU3PThreadSleep(200);
 6641              		.loc 1 4541 0
 6642 39a4 883087E5 		str	r3, [r7, #136]
4542:../uvc.c      ****                     
 6643              		.loc 1 4542 0
 6644 39a8 FEFFFFEB 		bl	_tx_thread_sleep
 6645              	.LVL785:
 6646 39ac C3FFFFEA 		b	.L548
 6647              	.L620:
4375:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6648              		.loc 1 4375 0
 6649 39b0 74559FE5 		ldr	r5, .L633+100
4374:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6650              		.loc 1 4374 0
 6651 39b4 5C059FE5 		ldr	r0, .L633+80
 6652 39b8 0010E0E3 		mvn	r1, #0
4359:../uvc.c      ****                 consCount = 0;
 6653              		.loc 1 4359 0
 6654 39bc B068C4E1 		strh	r6, [r4, #128]	@ movhi
4356:../uvc.c      ****             	pb=0;
 6655              		.loc 1 4356 0
 6656 39c0 B467C4E1 		strh	r6, [r4, #116]	@ movhi
4360:../uvc.c      ****                 hitFV     = CyFalse;
 6657              		.loc 1 4360 0
 6658 39c4 B268C4E1 		strh	r6, [r4, #130]	@ movhi
4357:../uvc.c      ****             	pbc=0;
 6659              		.loc 1 4357 0
 6660 39c8 B667C4E1 		strh	r6, [r4, #118]	@ movhi
4358:../uvc.c      ****                 prodCount = 0;
 6661              		.loc 1 4358 0
 6662 39cc B867C4E1 		strh	r6, [r4, #120]	@ movhi
4361:../uvc.c      **** 
 6663              		.loc 1 4361 0
 6664 39d0 7C6084E5 		str	r6, [r4, #124]
4374:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6665              		.loc 1 4374 0
 6666 39d4 FEFFFFEB 		bl	_txe_mutex_get
 6667              	.LVL786:
4375:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6668              		.loc 1 4375 0
 6669 39d8 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6670 39dc 013023E2 		eor	r3, r3, #1
 6671 39e0 ED34C5E5 		strb	r3, [r5, #1261]
4377:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6672              		.loc 1 4377 0
 6673 39e4 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6674 39e8 F00053E3 		cmp	r3, #240
 6675 39ec 3B00000A 		beq	.L626
 6676              	.L549:
4385:../uvc.c      **** 
 6677              		.loc 1 4385 0
 6678 39f0 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6679 39f4 FF0053E3 		cmp	r3, #255
 6680 39f8 1D00000A 		beq	.L627
4397:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6681              		.loc 1 4397 0
 6682 39fc 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6683 3a00 AA0053E3 		cmp	r3, #170
 6684 3a04 2700000A 		beq	.L628
 6685              	.L550:
4435:../uvc.c      ****                 /* Reset the DMA channel. */
 6686              		.loc 1 4435 0
 6687 3a08 08059FE5 		ldr	r0, .L633+80
 6688 3a0c FEFFFFEB 		bl	_txe_mutex_put
 6689              	.LVL787:
4437:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6690              		.loc 1 4437 0
 6691 3a10 10059FE5 		ldr	r0, .L633+96
 6692 3a14 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6693              	.LVL788:
4438:../uvc.c      ****                 {
 6694              		.loc 1 4438 0
 6695 3a18 005050E2 		subs	r5, r0, #0
 6696 3a1c 7A00001A 		bne	.L629
4445:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6697              		.loc 1 4445 0
 6698 3a20 0510A0E1 		mov	r1, r5
 6699 3a24 0520A0E1 		mov	r2, r5
 6700 3a28 F8049FE5 		ldr	r0, .L633+96
 6701              	.LVL789:
 6702 3a2c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6703              	.LVL790:
4446:../uvc.c      ****                 {
 6704              		.loc 1 4446 0
 6705 3a30 005050E2 		subs	r5, r0, #0
 6706 3a34 6800001A 		bne	.L630
 6707              	.L569:
4454:../uvc.c      ****                 }
 6708              		.loc 1 4454 0
 6709 3a38 DC049FE5 		ldr	r0, .L633+84
 6710              	.LVL791:
 6711 3a3c 0230A0E3 		mov	r3, #2
 6712 3a40 0010A0E3 		mov	r1, #0
 6713 3a44 00308DE5 		str	r3, [sp]
 6714 3a48 0020A0E1 		mov	r2, r0
 6715 3a4c 0130A0E1 		mov	r3, r1
 6716 3a50 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6717              	.LVL792:
 6718 3a54 99FFFFEA 		b	.L548
 6719              	.LVL793:
 6720              	.L622:
4477:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6721              		.loc 1 4477 0
 6722 3a58 C8049FE5 		ldr	r0, .L633+96
 6723 3a5c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6724              	.LVL794:
4478:../uvc.c      ****                     {
 6725              		.loc 1 4478 0
 6726 3a60 000050E3 		cmp	r0, #0
 6727 3a64 4000001A 		bne	.L601
4484:../uvc.c      ****                 }
 6728              		.loc 1 4484 0
 6729 3a68 8300A0E3 		mov	r0, #131
 6730              	.LVL795:
 6731 3a6c FEFFFFEB 		bl	CyU3PUsbFlushEp
 6732              	.LVL796:
 6733 3a70 B1FFFFEA 		b	.L571
 6734              	.L627:
4387:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6735              		.loc 1 4387 0
 6736 3a74 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6737 3a78 020053E3 		cmp	r3, #2
 6738 3a7c 013083E2 		add	r3, r3, #1
 6739 3a80 E030C4E5 		strb	r3, [r4, #224]
 6740 3a84 DFFFFF9A 		bls	.L550
4388:../uvc.c      ****                 		stiflag = 0x0F;
 6741              		.loc 1 4388 0
 6742 3a88 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
4389:../uvc.c      ****                 		IMcount = 0;
 6743              		.loc 1 4389 0
 6744 3a8c 0F30A0E3 		mov	r3, #15
4388:../uvc.c      ****                 		stiflag = 0x0F;
 6745              		.loc 1 4388 0
 6746 3a90 201081E3 		orr	r1, r1, #32
4390:../uvc.c      ****                 		}
 6747              		.loc 1 4390 0
 6748 3a94 0020A0E3 		mov	r2, #0
4388:../uvc.c      ****                 		stiflag = 0x0F;
 6749              		.loc 1 4388 0
 6750 3a98 ED14C5E5 		strb	r1, [r5, #1261]
4390:../uvc.c      ****                 		}
 6751              		.loc 1 4390 0
 6752 3a9c E020C4E5 		strb	r2, [r4, #224]
4389:../uvc.c      ****                 		IMcount = 0;
 6753              		.loc 1 4389 0
 6754 3aa0 7230C4E5 		strb	r3, [r4, #114]
 6755 3aa4 D7FFFFEA 		b	.L550
 6756              	.L628:
4403:../uvc.c      ****                 	{
 6757              		.loc 1 4403 0
 6758 3aa8 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6759 3aac 020053E3 		cmp	r3, #2
 6760 3ab0 013083E2 		add	r3, r3, #1
 6761 3ab4 E030C4E5 		strb	r3, [r4, #224]
 6762 3ab8 D2FFFF9A 		bls	.L550
4405:../uvc.c      ****                      {
 6763              		.loc 1 4405 0
 6764 3abc 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6765 3ac0 013043E2 		sub	r3, r3, #1
 6766 3ac4 030053E3 		cmp	r3, #3
 6767 3ac8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6768 3acc 3E0000EA 		b	.L554
 6769              	.L556:
 6770 3ad0 8C3B0000 		.word	.L555
 6771 3ad4 783C0000 		.word	.L557
 6772 3ad8 BC3C0000 		.word	.L558
 6773 3adc 243C0000 		.word	.L559
 6774              	.L626:
4377:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6775              		.loc 1 4377 0 discriminator 1
 6776 3ae0 00608DE5 		str	r6, [sp]
 6777 3ae4 E4039FE5 		ldr	r0, .L633+8
 6778 3ae8 8010A0E3 		mov	r1, #128
 6779 3aec 0320A0E3 		mov	r2, #3
 6780 3af0 60308DE2 		add	r3, sp, #96
 6781 3af4 FEFFFFEB 		bl	_txe_event_flags_get
 6782              	.LVL797:
 6783 3af8 000050E3 		cmp	r0, #0
 6784 3afc BBFFFF1A 		bne	.L549
4382:../uvc.c      ****                 		IMcount = 0;
 6785              		.loc 1 4382 0
 6786 3b00 0030E0E3 		mvn	r3, #0
4383:../uvc.c      ****                 	}
 6787              		.loc 1 4383 0
 6788 3b04 E000C4E5 		strb	r0, [r4, #224]
4382:../uvc.c      ****                 		IMcount = 0;
 6789              		.loc 1 4382 0
 6790 3b08 7230C4E5 		strb	r3, [r4, #114]
4383:../uvc.c      ****                 	}
 6791              		.loc 1 4383 0
 6792 3b0c BDFFFFEA 		b	.L550
 6793              	.LVL798:
 6794              	.L624:
 6795              	.LBB115:
 6796              	.LBB113:
4210:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6797              		.loc 1 4210 0
 6798 3b10 18149FE5 		ldr	r1, .L633+104
 6799 3b14 0100A0E3 		mov	r0, #1
 6800              	.LVL799:
 6801 3b18 FEFFFFEB 		bl	CyU3PDebugPrint
 6802              	.LVL800:
4211:../uvc.c      ****     }
 6803              		.loc 1 4211 0
 6804 3b1c 10049FE5 		ldr	r0, .L633+108
 6805 3b20 FEFFFFEB 		bl	CyU3PGpifLoad
 6806              	.LVL801:
 6807 3b24 0050A0E1 		mov	r5, r0
 6808              	.LVL802:
 6809              	.L575:
4218:../uvc.c      ****     {
 6810              		.loc 1 4218 0
 6811 3b28 000055E3 		cmp	r5, #0
 6812 3b2c 8800001A 		bne	.L631
 6813              	.LVL803:
4230:../uvc.c      ****     {
 6814              		.loc 1 4230 0
 6815 3b30 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6816 3b34 023043E2 		sub	r3, r3, #2
 6817 3b38 FF3003E2 		and	r3, r3, #255
 6818 3b3c 010053E3 		cmp	r3, #1
 6819 3b40 95FFFF8A 		bhi	.L576
4228:../uvc.c      ****     }
 6820              		.loc 1 4228 0
 6821 3b44 0500A0E1 		mov	r0, r5
 6822 3b48 0510A0E1 		mov	r1, r5
 6823 3b4c FEFFFFEB 		bl	CyU3PGpifSMStart
 6824              	.LVL804:
4234:../uvc.c      ****     {
 6825              		.loc 1 4234 0
 6826 3b50 005050E2 		subs	r5, r0, #0
 6827 3b54 90FFFF0A 		beq	.L576
4237:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6828              		.loc 1 4237 0
 6829 3b58 0400A0E3 		mov	r0, #4
 6830              	.LVL805:
 6831 3b5c D4139FE5 		ldr	r1, .L633+112
 6832 3b60 0520A0E1 		mov	r2, r5
 6833 3b64 FEFFFFEB 		bl	CyU3PDebugPrint
 6834              	.LVL806:
4238:../uvc.c      ****     }
 6835              		.loc 1 4238 0
 6836 3b68 0500A0E1 		mov	r0, r5
 6837              	.LVL807:
 6838              	.L601:
4222:../uvc.c      ****     }
 6839              		.loc 1 4222 0
 6840 3b6c FEFFFFEB 		bl	CyFxAppErrorHandler
 6841              	.LVL808:
 6842              	.L625:
4215:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6843              		.loc 1 4215 0
 6844 3b70 C4139FE5 		ldr	r1, .L633+116
 6845 3b74 0100A0E3 		mov	r0, #1
 6846              	.LVL809:
 6847 3b78 FEFFFFEB 		bl	CyU3PDebugPrint
 6848              	.LVL810:
4216:../uvc.c      ****     }
 6849              		.loc 1 4216 0
 6850 3b7c BC039FE5 		ldr	r0, .L633+120
 6851 3b80 FEFFFFEB 		bl	CyU3PGpifLoad
 6852              	.LVL811:
 6853 3b84 0050A0E1 		mov	r5, r0
 6854              	.LVL812:
 6855 3b88 E6FFFFEA 		b	.L575
 6856              	.LVL813:
 6857              	.L555:
 6858              	.LBE113:
 6859              	.LBE115:
4408:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6860              		.loc 1 4408 0
 6861 3b8c 6C2097E5 		ldr	r2, [r7, #108]
 6862 3b90 3010A0E3 		mov	r1, #48
 6863 3b94 000052E3 		cmp	r2, #0
 6864 3b98 E420A003 		moveq	r2, #228
 6865 3b9c 6420A013 		movne	r2, #100
 6866 3ba0 5230A0E3 		mov	r3, #82
 6867 3ba4 0100A0E3 		mov	r0, #1
 6868 3ba8 FEFFFFEB 		bl	SensorSetIrisControl
 6869              	.LVL814:
4410:../uvc.c      ****                  		break;
 6870              		.loc 1 4410 0
 6871 3bac 6C2097E5 		ldr	r2, [r7, #108]
 6872 3bb0 0400A0E3 		mov	r0, #4
 6873 3bb4 000052E3 		cmp	r2, #0
 6874 3bb8 6C3097E5 		ldr	r3, [r7, #108]
 6875 3bbc E420A003 		moveq	r2, #228
 6876 3bc0 6420A013 		movne	r2, #100
 6877 3bc4 78139FE5 		ldr	r1, .L633+124
 6878 3bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 6879              	.LVL815:
 6880              	.L554:
4430:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6881              		.loc 1 4430 0
 6882 3bcc 0030A0E3 		mov	r3, #0
 6883 3bd0 E030C7E5 		strb	r3, [r7, #224]
4432:../uvc.c      ****                 	}
 6884              		.loc 1 4432 0
 6885 3bd4 7230C7E5 		strb	r3, [r7, #114]
 6886 3bd8 8AFFFFEA 		b	.L550
 6887              	.LVL816:
 6888              	.L630:
4448:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6889              		.loc 1 4448 0
 6890 3bdc 0400A0E3 		mov	r0, #4
 6891              	.LVL817:
 6892 3be0 60139FE5 		ldr	r1, .L633+128
 6893 3be4 0520A0E1 		mov	r2, r5
 6894 3be8 FEFFFFEB 		bl	CyU3PDebugPrint
 6895              	.LVL818:
4449:../uvc.c      ****                 }
 6896              		.loc 1 4449 0
 6897 3bec 0500A0E1 		mov	r0, r5
 6898 3bf0 FEFFFFEB 		bl	CyFxAppErrorHandler
 6899              	.LVL819:
 6900              	.L623:
4500:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6901              		.loc 1 4500 0
 6902 3bf4 0400A0E3 		mov	r0, #4
 6903              	.LVL820:
 6904 3bf8 4C139FE5 		ldr	r1, .L633+132
 6905 3bfc 0520A0E1 		mov	r2, r5
 6906 3c00 FEFFFFEB 		bl	CyU3PDebugPrint
 6907              	.LVL821:
4501:../uvc.c      ****                 }
 6908              		.loc 1 4501 0
 6909 3c04 0500A0E1 		mov	r0, r5
 6910 3c08 FEFFFFEB 		bl	CyFxAppErrorHandler
 6911              	.LVL822:
 6912              	.L629:
4440:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6913              		.loc 1 4440 0
 6914 3c0c 0400A0E3 		mov	r0, #4
 6915              	.LVL823:
 6916 3c10 38139FE5 		ldr	r1, .L633+136
 6917 3c14 0520A0E1 		mov	r2, r5
 6918 3c18 FEFFFFEB 		bl	CyU3PDebugPrint
 6919              	.LVL824:
4441:../uvc.c      ****                 }
 6920              		.loc 1 4441 0
 6921 3c1c 0500A0E1 		mov	r0, r5
 6922 3c20 FEFFFFEB 		bl	CyFxAppErrorHandler
 6923              	.LVL825:
 6924              	.L559:
4423:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6925              		.loc 1 4423 0
 6926 3c24 6C2097E5 		ldr	r2, [r7, #108]
 6927 3c28 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6928 3c2c 000052E3 		cmp	r2, #0
 6929 3c30 F420A003 		moveq	r2, #244
 6930 3c34 7420A013 		movne	r2, #116
 6931 3c38 032082E1 		orr	r2, r2, r3
 6932 3c3c 3010A0E3 		mov	r1, #48
 6933 3c40 5230A0E3 		mov	r3, #82
 6934 3c44 0100A0E3 		mov	r0, #1
 6935 3c48 FEFFFFEB 		bl	SensorSetIrisControl
 6936              	.LVL826:
4425:../uvc.c      ****                  		break;
 6937              		.loc 1 4425 0
 6938 3c4c 6C1097E5 		ldr	r1, [r7, #108]
 6939 3c50 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6940 3c54 000051E3 		cmp	r1, #0
 6941 3c58 F410A003 		moveq	r1, #244
 6942 3c5c 7410A013 		movne	r1, #116
 6943 3c60 022081E1 		orr	r2, r1, r2
 6944 3c64 6C3097E5 		ldr	r3, [r7, #108]
 6945 3c68 D4129FE5 		ldr	r1, .L633+124
 6946 3c6c 0400A0E3 		mov	r0, #4
 6947 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
 6948              	.LVL827:
4426:../uvc.c      ****                  	default:
 6949              		.loc 1 4426 0
 6950 3c74 D4FFFFEA 		b	.L554
 6951              	.L557:
4413:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6952              		.loc 1 4413 0
 6953 3c78 6C2097E5 		ldr	r2, [r7, #108]
 6954 3c7c 3010A0E3 		mov	r1, #48
 6955 3c80 000052E3 		cmp	r2, #0
 6956 3c84 D420A003 		moveq	r2, #212
 6957 3c88 5420A013 		movne	r2, #84
 6958 3c8c 5230A0E3 		mov	r3, #82
 6959 3c90 0100A0E3 		mov	r0, #1
 6960 3c94 FEFFFFEB 		bl	SensorSetIrisControl
 6961              	.LVL828:
4415:../uvc.c      ****                  		break;
 6962              		.loc 1 4415 0
 6963 3c98 6C2097E5 		ldr	r2, [r7, #108]
 6964 3c9c A0129FE5 		ldr	r1, .L633+124
 6965 3ca0 000052E3 		cmp	r2, #0
 6966 3ca4 6C3097E5 		ldr	r3, [r7, #108]
 6967 3ca8 D420A003 		moveq	r2, #212
 6968 3cac 5420A013 		movne	r2, #84
 6969 3cb0 0400A0E3 		mov	r0, #4
 6970 3cb4 FEFFFFEB 		bl	CyU3PDebugPrint
 6971              	.LVL829:
4416:../uvc.c      ****                  	case 3: //720
 6972              		.loc 1 4416 0
 6973 3cb8 C3FFFFEA 		b	.L554
 6974              	.L558:
4418:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6975              		.loc 1 4418 0
 6976 3cbc 6C2097E5 		ldr	r2, [r7, #108]
 6977 3cc0 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6978 3cc4 000052E3 		cmp	r2, #0
 6979 3cc8 C420A003 		moveq	r2, #196
 6980 3ccc 4420A013 		movne	r2, #68
 6981 3cd0 032082E1 		orr	r2, r2, r3
 6982 3cd4 3010A0E3 		mov	r1, #48
 6983 3cd8 5230A0E3 		mov	r3, #82
 6984 3cdc 0100A0E3 		mov	r0, #1
 6985 3ce0 FEFFFFEB 		bl	SensorSetIrisControl
 6986              	.LVL830:
4420:../uvc.c      ****                  		break;
 6987              		.loc 1 4420 0
 6988 3ce4 6C1097E5 		ldr	r1, [r7, #108]
 6989 3ce8 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6990 3cec 000051E3 		cmp	r1, #0
 6991 3cf0 C410A003 		moveq	r1, #196
 6992 3cf4 4410A013 		movne	r1, #68
 6993 3cf8 022081E1 		orr	r2, r1, r2
 6994 3cfc 6C3097E5 		ldr	r3, [r7, #108]
 6995 3d00 3C129FE5 		ldr	r1, .L633+124
 6996 3d04 0400A0E3 		mov	r0, #4
 6997 3d08 FEFFFFEB 		bl	CyU3PDebugPrint
 6998              	.LVL831:
4421:../uvc.c      ****                  	case 4: //VGA
 6999              		.loc 1 4421 0
 7000 3d0c AEFFFFEA 		b	.L554
 7001              	.LVL832:
 7002              	.L602:
 7003              	.LBB116:
 7004              	.LBB100:
3717:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7005              		.loc 1 3717 0
 7006 3d10 0400A0E3 		mov	r0, #4
 7007              	.LVL833:
 7008 3d14 38129FE5 		ldr	r1, .L633+140
 7009 3d18 FEFFFFEB 		bl	CyU3PDebugPrint
 7010              	.LVL834:
3718:../uvc.c      ****     }
 7011              		.loc 1 3718 0
 7012 3d1c 0400A0E1 		mov	r0, r4
 7013 3d20 FEFFFFEB 		bl	CyFxAppErrorHandler
 7014              	.LVL835:
 7015              	.L632:
 7016              	.LBE100:
 7017              	.LBE116:
 7018              	.LBB117:
 7019              	.LBB107:
4183:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7020              		.loc 1 4183 0
 7021 3d24 0800A0E1 		mov	r0, r8
 7022              	.LVL836:
 7023              	.L599:
 7024 3d28 28129FE5 		ldr	r1, .L633+144
 7025 3d2c 0420A0E1 		mov	r2, r4
 7026 3d30 FEFFFFEB 		bl	CyU3PDebugPrint
 7027              	.LVL837:
4184:../uvc.c      ****     }
 7028              		.loc 1 4184 0
 7029 3d34 0400A0E1 		mov	r0, r4
 7030 3d38 8BFFFFEA 		b	.L601
 7031              	.LVL838:
 7032              	.L618:
4158:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7033              		.loc 1 4158 0
 7034 3d3c 0800A0E1 		mov	r0, r8
 7035              	.LVL839:
 7036 3d40 14129FE5 		ldr	r1, .L633+148
 7037 3d44 0420A0E1 		mov	r2, r4
 7038 3d48 FEFFFFEB 		bl	CyU3PDebugPrint
 7039              	.LVL840:
4159:../uvc.c      ****     }
 7040              		.loc 1 4159 0
 7041 3d4c 0400A0E1 		mov	r0, r4
 7042 3d50 FEFFFFEB 		bl	CyFxAppErrorHandler
 7043              	.LVL841:
 7044              	.L631:
 7045              	.LBE107:
 7046              	.LBE117:
 7047              	.LBB118:
 7048              	.LBB114:
4221:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7049              		.loc 1 4221 0
 7050 3d54 0400A0E3 		mov	r0, #4
 7051              	.LVL842:
 7052 3d58 00129FE5 		ldr	r1, .L633+152
 7053 3d5c 0520A0E1 		mov	r2, r5
 7054 3d60 FEFFFFEB 		bl	CyU3PDebugPrint
 7055              	.LVL843:
4222:../uvc.c      ****     }
 7056              		.loc 1 4222 0
 7057 3d64 0500A0E1 		mov	r0, r5
 7058 3d68 7FFFFFEA 		b	.L601
 7059              	.LVL844:
 7060              	.L606:
 7061              	.LBE114:
 7062              	.LBE118:
 7063              	.LBB119:
 7064              	.LBB108:
3874:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7065              		.loc 1 3874 0
 7066 3d6c 0400A0E3 		mov	r0, #4
 7067              	.LVL845:
 7068 3d70 EC119FE5 		ldr	r1, .L633+156
 7069 3d74 0520A0E1 		mov	r2, r5
 7070 3d78 FEFFFFEB 		bl	CyU3PDebugPrint
 7071              	.LVL846:
3875:../uvc.c      ****     }
 7072              		.loc 1 3875 0
 7073 3d7c 0500A0E1 		mov	r0, r5
 7074 3d80 FEFFFFEB 		bl	CyFxAppErrorHandler
 7075              	.LVL847:
 7076              	.L605:
3852:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7077              		.loc 1 3852 0
 7078 3d84 0400A0E3 		mov	r0, #4
 7079              	.LVL848:
 7080 3d88 D8119FE5 		ldr	r1, .L633+160
 7081 3d8c 0520A0E1 		mov	r2, r5
 7082 3d90 FEFFFFEB 		bl	CyU3PDebugPrint
 7083              	.LVL849:
3853:../uvc.c      ****     }
 7084              		.loc 1 3853 0
 7085 3d94 0500A0E1 		mov	r0, r5
 7086 3d98 FEFFFFEB 		bl	CyFxAppErrorHandler
 7087              	.LVL850:
 7088              	.L604:
 7089              	.LBE108:
 7090              	.LBE119:
 7091              	.LBB120:
 7092              	.LBB103:
3778:../uvc.c      ****         CyFxAppErrorHandler (status);
 7093              		.loc 1 3778 0
 7094 3d9c 0400A0E3 		mov	r0, #4
 7095              	.LVL851:
 7096 3da0 C4119FE5 		ldr	r1, .L633+164
 7097 3da4 FEFFFFEB 		bl	CyU3PDebugPrint
 7098              	.LVL852:
3779:../uvc.c      ****     }
 7099              		.loc 1 3779 0
 7100 3da8 0500A0E1 		mov	r0, r5
 7101 3dac FEFFFFEB 		bl	CyFxAppErrorHandler
 7102              	.LVL853:
 7103              	.L603:
3765:../uvc.c      ****         CyFxAppErrorHandler (status);
 7104              		.loc 1 3765 0
 7105 3db0 0400A0E3 		mov	r0, #4
 7106              	.LVL854:
 7107 3db4 B4119FE5 		ldr	r1, .L633+168
 7108 3db8 FEFFFFEB 		bl	CyU3PDebugPrint
 7109              	.LVL855:
3766:../uvc.c      ****     }
 7110              		.loc 1 3766 0
 7111 3dbc 0500A0E1 		mov	r0, r5
 7112 3dc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7113              	.LVL856:
 7114              	.L614:
 7115              	.LBE103:
 7116              	.LBE120:
 7117              	.LBB121:
 7118              	.LBB109:
3970:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7119              		.loc 1 3970 0
 7120 3dc4 0400A0E3 		mov	r0, #4
 7121              	.LVL857:
 7122 3dc8 A4119FE5 		ldr	r1, .L633+172
 7123 3dcc 0420A0E1 		mov	r2, r4
 7124 3dd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7125              	.LVL858:
3971:../uvc.c      ****     }
 7126              		.loc 1 3971 0
 7127 3dd4 0400A0E1 		mov	r0, r4
 7128 3dd8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7129              	.LVL859:
 7130              	.L613:
3949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7131              		.loc 1 3949 0
 7132 3ddc 0400A0E3 		mov	r0, #4
 7133              	.LVL860:
 7134 3de0 90119FE5 		ldr	r1, .L633+176
 7135 3de4 0420A0E1 		mov	r2, r4
 7136 3de8 FEFFFFEB 		bl	CyU3PDebugPrint
 7137              	.LVL861:
3950:../uvc.c      ****     }
 7138              		.loc 1 3950 0
 7139 3dec 0400A0E1 		mov	r0, r4
 7140 3df0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7141              	.LVL862:
 7142              	.L612:
3936:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7143              		.loc 1 3936 0
 7144 3df4 0400A0E3 		mov	r0, #4
 7145              	.LVL863:
 7146 3df8 7C119FE5 		ldr	r1, .L633+180
 7147 3dfc 0420A0E1 		mov	r2, r4
 7148 3e00 FEFFFFEB 		bl	CyU3PDebugPrint
 7149              	.LVL864:
3937:../uvc.c      ****     }
 7150              		.loc 1 3937 0
 7151 3e04 0400A0E1 		mov	r0, r4
 7152 3e08 FEFFFFEB 		bl	CyFxAppErrorHandler
 7153              	.LVL865:
 7154              	.L611:
3922:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7155              		.loc 1 3922 0
 7156 3e0c 0400A0E3 		mov	r0, #4
 7157              	.LVL866:
 7158 3e10 68119FE5 		ldr	r1, .L633+184
 7159 3e14 0420A0E1 		mov	r2, r4
 7160 3e18 FEFFFFEB 		bl	CyU3PDebugPrint
 7161              	.LVL867:
3923:../uvc.c      ****     }
 7162              		.loc 1 3923 0
 7163 3e1c 0400A0E1 		mov	r0, r4
 7164 3e20 FEFFFFEB 		bl	CyFxAppErrorHandler
 7165              	.LVL868:
 7166              	.L610:
3908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7167              		.loc 1 3908 0
 7168 3e24 0400A0E3 		mov	r0, #4
 7169              	.LVL869:
 7170 3e28 54119FE5 		ldr	r1, .L633+188
 7171 3e2c 0620A0E1 		mov	r2, r6
 7172 3e30 FEFFFFEB 		bl	CyU3PDebugPrint
 7173              	.LVL870:
3909:../uvc.c      ****     }
 7174              		.loc 1 3909 0
 7175 3e34 0600A0E1 		mov	r0, r6
 7176 3e38 FEFFFFEB 		bl	CyFxAppErrorHandler
 7177              	.LVL871:
 7178              	.L609:
3895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7179              		.loc 1 3895 0
 7180 3e3c 0400A0E3 		mov	r0, #4
 7181              	.LVL872:
 7182 3e40 40119FE5 		ldr	r1, .L633+192
 7183 3e44 0520A0E1 		mov	r2, r5
 7184 3e48 FEFFFFEB 		bl	CyU3PDebugPrint
 7185              	.LVL873:
3896:../uvc.c      ****     }
 7186              		.loc 1 3896 0
 7187 3e4c 0500A0E1 		mov	r0, r5
 7188 3e50 FEFFFFEB 		bl	CyFxAppErrorHandler
 7189              	.LVL874:
 7190              	.L608:
3889:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7191              		.loc 1 3889 0
 7192 3e54 0400A0E3 		mov	r0, #4
 7193              	.LVL875:
 7194 3e58 2C119FE5 		ldr	r1, .L633+196
 7195 3e5c 0520A0E1 		mov	r2, r5
 7196 3e60 FEFFFFEB 		bl	CyU3PDebugPrint
 7197              	.LVL876:
3890:../uvc.c      ****     }
 7198              		.loc 1 3890 0
 7199 3e64 0500A0E1 		mov	r0, r5
 7200 3e68 FEFFFFEB 		bl	CyFxAppErrorHandler
 7201              	.LVL877:
 7202              	.L607:
3883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7203              		.loc 1 3883 0
 7204 3e6c 0400A0E3 		mov	r0, #4
 7205              	.LVL878:
 7206 3e70 18119FE5 		ldr	r1, .L633+200
 7207 3e74 0520A0E1 		mov	r2, r5
 7208 3e78 FEFFFFEB 		bl	CyU3PDebugPrint
 7209              	.LVL879:
3884:../uvc.c      ****     }
 7210              		.loc 1 3884 0
 7211 3e7c 0500A0E1 		mov	r0, r5
 7212 3e80 FEFFFFEB 		bl	CyFxAppErrorHandler
 7213              	.LVL880:
 7214              	.L617:
4067:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7215              		.loc 1 4067 0
 7216 3e84 0800A0E1 		mov	r0, r8
 7217              	.LVL881:
 7218 3e88 04119FE5 		ldr	r1, .L633+204
 7219 3e8c 0420A0E1 		mov	r2, r4
 7220 3e90 FEFFFFEB 		bl	CyU3PDebugPrint
 7221              	.LVL882:
4068:../uvc.c      ****     }
 7222              		.loc 1 4068 0
 7223 3e94 0400A0E1 		mov	r0, r4
 7224 3e98 FEFFFFEB 		bl	CyFxAppErrorHandler
 7225              	.LVL883:
 7226              	.L615:
4036:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7227              		.loc 1 4036 0
 7228 3e9c 0400A0E3 		mov	r0, #4
 7229              	.LVL884:
 7230 3ea0 F0109FE5 		ldr	r1, .L633+208
 7231 3ea4 0420A0E1 		mov	r2, r4
 7232 3ea8 FEFFFFEB 		bl	CyU3PDebugPrint
 7233              	.LVL885:
4037:../uvc.c      ****     }
 7234              		.loc 1 4037 0
 7235 3eac 0400A0E1 		mov	r0, r4
 7236 3eb0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7237              	.LVL886:
 7238              	.L616:
4043:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7239              		.loc 1 4043 0
 7240 3eb4 0400A0E3 		mov	r0, #4
 7241 3eb8 DC109FE5 		ldr	r1, .L633+212
 7242 3ebc FEFFFFEB 		bl	CyU3PDebugPrint
 7243              	.LVL887:
4044:../uvc.c      ****     }
 7244              		.loc 1 4044 0
 7245 3ec0 0800A0E1 		mov	r0, r8
 7246 3ec4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7247              	.LVL888:
 7248              	.L634:
 7249              		.align	2
 7250              	.L633:
 7251 3ec8 00C20100 		.word	115200
 7252 3ecc A0860100 		.word	100000
 7253 3ed0 00000000 		.word	.LANCHOR0
 7254 3ed4 00000000 		.word	CyFxGpifCB
 7255 3ed8 88130000 		.word	5000
 7256 3edc 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7257 3ee0 00000000 		.word	CyFxUVCApplnUSBEventCB
 7258 3ee4 00000000 		.word	CyFxUSBDeviceDscr
 7259 3ee8 00000000 		.word	CyFxUSBDeviceDscrSS
 7260 3eec 00000000 		.word	CyFxUSBDeviceQualDscr
 7261 3ef0 00000000 		.word	CyFxUSBBOSDscr
 7262 3ef4 00000000 		.word	CyFxUSBHSConfigDscr
 7263 3ef8 00000000 		.word	CyFxUSBFSConfigDscr
 7264 3efc 00000000 		.word	CyFxUSBSSConfigDscr
 7265 3f00 00000000 		.word	CyFxUSBStringLangIDDscr
 7266 3f04 00000000 		.word	CyFxUSBManufactureDscr
 7267 3f08 00000000 		.word	CyFxUSBProductDscr
 7268 3f0c 013F0203 		.word	50478849
 7269 3f10 00000000 		.word	glChHandleInterStat
 7270 3f14 00000000 		.word	glInterStaBuffer
 7271 3f18 00000000 		.word	imgHdMux
 7272 3f1c 01010000 		.word	257
 7273 3f20 03030000 		.word	771
 7274 3f24 00000000 		.word	CyFxUvcApplnDmaCallback
 7275 3f28 00000000 		.word	glChHandleUVCStream
 7276 3f2c 00000000 		.word	.LANCHOR1
 7277 3f30 500B0000 		.word	.LC64
 7278 3f34 60010000 		.word	.LANCHOR2+352
 7279 3f38 A80B0000 		.word	.LC67
 7280 3f3c 600B0000 		.word	.LC65
 7281 3f40 7C010000 		.word	.LANCHOR2+380
 7282 3f44 980A0000 		.word	.LC60
 7283 3f48 E80A0000 		.word	.LC62
 7284 3f4c 1C0B0000 		.word	.LC63
 7285 3f50 BC0A0000 		.word	.LC61
 7286 3f54 6C070000 		.word	.LC42
 7287 3f58 94090000 		.word	.LC55
 7288 3f5c 700A0000 		.word	.LC59
 7289 3f60 700B0000 		.word	.LC66
 7290 3f64 F0070000 		.word	.LC46
 7291 3f68 C4070000 		.word	.LC45
 7292 3f6c A8070000 		.word	.LC44
 7293 3f70 8C070000 		.word	.LC43
 7294 3f74 64090000 		.word	.LC54
 7295 3f78 34090000 		.word	.LC53
 7296 3f7c FC080000 		.word	.LC52
 7297 3f80 C8080000 		.word	.LC51
 7298 3f84 94080000 		.word	.LC50
 7299 3f88 68080000 		.word	.LC49
 7300 3f8c 3C080000 		.word	.LC48
 7301 3f90 14080000 		.word	.LC47
 7302 3f94 400A0000 		.word	.LC58
 7303 3f98 C8090000 		.word	.LC56
 7304 3f9c 080A0000 		.word	.LC57
 7305              	.LBE109:
 7306              	.LBE121:
 7307              		.cfi_endproc
 7308              	.LFE19:
 7310              		.align	2
 7311              		.global	UVCAppEP0Thread_Entry
 7313              	UVCAppEP0Thread_Entry:
 7314              	.LFB25:
5360:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7315              		.loc 1 5360 0
 7316              		.cfi_startproc
 7317              		@ args = 0, pretend = 0, frame = 64
 7318              		@ frame_needed = 0, uses_anonymous_args = 0
 7319              	.LVL889:
 7320 3fa0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7321              	.LCFI27:
 7322              		.cfi_def_cfa_offset 36
 7323              		.cfi_offset 4, -36
 7324              		.cfi_offset 5, -32
 7325              		.cfi_offset 6, -28
 7326              		.cfi_offset 7, -24
 7327              		.cfi_offset 8, -20
 7328              		.cfi_offset 9, -16
 7329              		.cfi_offset 10, -12
 7330              		.cfi_offset 11, -8
 7331              		.cfi_offset 14, -4
 7332 3fa4 A47F9FE5 		ldr	r7, .L1034
 7333 3fa8 A49F9FE5 		ldr	r9, .L1034+4
 7334 3fac A48F9FE5 		ldr	r8, .L1034+8
5434:../uvc.c      ****                 {
 7335              		.loc 1 5434 0
 7336 3fb0 A4AF9FE5 		ldr	r10, .L1034+12
5360:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7337              		.loc 1 5360 0
 7338 3fb4 5CD04DE2 		sub	sp, sp, #92
 7339              	.LCFI28:
 7340              		.cfi_def_cfa_offset 128
 7341              	.LVL890:
5382:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7342              		.loc 1 5382 0
 7343 3fb8 07B0A0E1 		mov	fp, r7
 7344              	.LVL891:
 7345              	.L920:
 7346 3fbc 0030E0E3 		mvn	r3, #0
 7347 3fc0 00308DE5 		str	r3, [sp]
 7348 3fc4 840F9FE5 		ldr	r0, .L1034
 7349 3fc8 4C10A0E3 		mov	r1, #76
 7350 3fcc 0120A0E3 		mov	r2, #1
 7351 3fd0 44308DE2 		add	r3, sp, #68
 7352 3fd4 FEFFFFEB 		bl	_txe_event_flags_get
 7353              	.LVL892:
 7354 3fd8 000050E3 		cmp	r0, #0
 7355 3fdc 3C00001A 		bne	.L637
5386:../uvc.c      ****             {
 7356              		.loc 1 5386 0
 7357 3fe0 8C309BE5 		ldr	r3, [fp, #140]
 7358 3fe4 000053E3 		cmp	r3, #0
 7359 3fe8 7700000A 		beq	.L988
 7360              	.L639:
5395:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7361              		.loc 1 5395 0
 7362 3fec 44309DE5 		ldr	r3, [sp, #68]
 7363 3ff0 0C0013E3 		tst	r3, #12
 7364 3ff4 5E00001A 		bne	.L989
 7365              	.L641:
5402:../uvc.c      ****             {
 7366              		.loc 1 5402 0
 7367 3ff8 040013E3 		tst	r3, #4
 7368 3ffc 2000000A 		beq	.L642
5404:../uvc.c      ****                 {
 7369              		.loc 1 5404 0
 7370 4000 B020DAE1 		ldrh	r2, [r10]
 7371 4004 2224A0E1 		mov	r2, r2, lsr #8
 7372 4008 030052E3 		cmp	r2, #3
 7373 400c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7374 4010 160000EA 		b	.L643
 7375              	.L645:
 7376 4014 70400000 		.word	.L643
 7377 4018 24400000 		.word	.L646
 7378 401c DC400000 		.word	.L647
 7379 4020 1C410000 		.word	.L648
 7380              	.L646:
 7381              	.LBB168:
 7382              	.LBB169:
4647:../uvc.c      ****     {
 7383              		.loc 1 4647 0
 7384 4024 844F9FE5 		ldr	r4, .L1034+96
 7385 4028 B020D4E1 		ldrh	r2, [r4]
 7386 402c 060C52E3 		cmp	r2, #1536
 7387 4030 1E02000A 		beq	.L691
 7388 4034 D000009A 		bls	.L990
 7389 4038 090C52E3 		cmp	r2, #2304
 7390 403c 0802000A 		beq	.L699
 7391 4040 FE00009A 		bls	.L991
 7392 4044 0B0C52E3 		cmp	r2, #2816
 7393 4048 3202000A 		beq	.L702
 7394 404c 030B52E3 		cmp	r2, #3072
 7395 4050 6402000A 		beq	.L703
 7396 4054 0A0C52E3 		cmp	r2, #2560
 7397 4058 4802000A 		beq	.L992
 7398              	.L690:
4704:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7399              		.loc 1 4704 0
 7400 405c 343F9FE5 		ldr	r3, .L1034+72
 7401 4060 0400A0E3 		mov	r0, #4
 7402 4064 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7403 4068 F01E9FE5 		ldr	r1, .L1034+16
 7404 406c FEFFFFEB 		bl	CyU3PDebugPrint
 7405              	.LVL893:
 7406              	.L643:
 7407              	.LBE169:
 7408              	.LBE168:
5425:../uvc.c      ****                         break;
 7409              		.loc 1 5425 0
 7410 4070 0000A0E3 		mov	r0, #0
 7411 4074 0020A0E1 		mov	r2, r0
 7412 4078 0110A0E3 		mov	r1, #1
 7413 407c FEFFFFEB 		bl	CyU3PUsbStall
 7414              	.LVL894:
 7415 4080 44309DE5 		ldr	r3, [sp, #68]
 7416              	.L642:
5430:../uvc.c      ****             {
 7417              		.loc 1 5430 0
 7418 4084 080013E3 		tst	r3, #8
 7419 4088 0700000A 		beq	.L914
5434:../uvc.c      ****                 {
 7420              		.loc 1 5434 0
 7421 408c B030DAE1 		ldrh	r3, [r10]
 7422 4090 010053E3 		cmp	r3, #1
 7423 4094 5200000A 		beq	.L915
5436:../uvc.c      ****                 }
 7424              		.loc 1 5436 0
 7425 4098 0000A0E3 		mov	r0, #0
 7426 409c 0020A0E1 		mov	r2, r0
 7427 40a0 0110A0E3 		mov	r1, #1
 7428 40a4 FEFFFFEB 		bl	CyU3PUsbStall
 7429              	.LVL895:
 7430 40a8 44309DE5 		ldr	r3, [sp, #68]
 7431              	.L914:
5445:../uvc.c      ****             {
 7432              		.loc 1 5445 0
 7433 40ac 400013E3 		tst	r3, #64
 7434 40b0 0700000A 		beq	.L637
5450:../uvc.c      **** 
 7435              		.loc 1 5450 0
 7436 40b4 1800A0E3 		mov	r0, #24
 7437 40b8 48108DE2 		add	r1, sp, #72
 7438              	.LVL896:
 7439 40bc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7440              	.LVL897:
5507:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7441              		.loc 1 5507 0
 7442 40c0 5637D9E5 		ldrb	r3, [r9, #1878]	@ zero_extendqisi2
 7443 40c4 0F0053E3 		cmp	r3, #15
 7444 40c8 6800000A 		beq	.L993
5534:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7445              		.loc 1 5534 0
 7446 40cc 000053E3 		cmp	r3, #0
 7447 40d0 4600000A 		beq	.L994
 7448              	.L637:
5658:../uvc.c      ****     }
 7449              		.loc 1 5658 0
 7450 40d4 FEFFFFEB 		bl	_txe_thread_relinquish
 7451              	.LVL898:
5659:../uvc.c      **** }
 7452              		.loc 1 5659 0
 7453 40d8 B7FFFFEA 		b	.L920
 7454              	.L647:
 7455              	.LBB344:
 7456              	.LBB345:
4572:../uvc.c      ****     {
 7457              		.loc 1 4572 0
 7458 40dc CCCE9FE5 		ldr	ip, .L1034+96
 7459 40e0 B020DCE1 		ldrh	r2, [ip]
 7460 40e4 060C52E3 		cmp	r2, #1536
 7461 40e8 3601000A 		beq	.L650
 7462 40ec 9500008A 		bhi	.L651
 7463 40f0 030C52E3 		cmp	r2, #768
 7464 40f4 2F01000A 		beq	.L652
 7465 40f8 C000008A 		bhi	.L653
 7466 40fc 010C52E3 		cmp	r2, #256
 7467 4100 1C01000A 		beq	.L654
 7468 4104 020C52E3 		cmp	r2, #512
 7469 4108 D3FFFF1A 		bne	.L690
 7470              	.LVL899:
4580:../uvc.c      ****     		break;
 7471              		.loc 1 4580 0
 7472 410c 0100A0E3 		mov	r0, #1
 7473 4110 FEFFFFEB 		bl	ControlHandle
 7474              	.LVL900:
 7475 4114 44309DE5 		ldr	r3, [sp, #68]
 7476 4118 D9FFFFEA 		b	.L642
 7477              	.L648:
 7478              	.LBE345:
 7479              	.LBE344:
 7480              	.LBB376:
 7481              	.LBB377:
4872:../uvc.c      ****     {
 7482              		.loc 1 4872 0
 7483 411c 8C1E9FE5 		ldr	r1, .L1034+96
 7484 4120 B030D1E1 		ldrh	r3, [r1]
 7485 4124 0140A0E1 		mov	r4, r1
 7486 4128 0D0C53E3 		cmp	r3, #3328
 7487 412c 4704000A 		beq	.L828
 7488 4130 6E00008A 		bhi	.L829
 7489 4134 060C53E3 		cmp	r3, #1536
 7490 4138 4004000A 		beq	.L830
 7491 413c 9900009A 		bls	.L995
 7492 4140 090C53E3 		cmp	r3, #2304
 7493 4144 3904000A 		beq	.L838
 7494 4148 5A01009A 		bls	.L996
 7495 414c 0B0C53E3 		cmp	r3, #2816
 7496 4150 3204000A 		beq	.L842
 7497 4154 030B53E3 		cmp	r3, #3072
 7498 4158 ED03000A 		beq	.L843
 7499 415c 0A0C53E3 		cmp	r3, #2560
 7500 4160 C2FFFF1A 		bne	.L643
 7501              	.LVL901:
4913:../uvc.c      ****     		}else/* no support for 1080p camera */
 7502              		.loc 1 4913 0
 7503 4164 1900A0E3 		mov	r0, #25
 7504 4168 FEFFFFEB 		bl	ControlHandle
 7505              	.LVL902:
 7506 416c 44309DE5 		ldr	r3, [sp, #68]
 7507 4170 C3FFFFEA 		b	.L642
 7508              	.L989:
 7509              	.LBE377:
 7510              	.LBE376:
5396:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7511              		.loc 1 5396 0
 7512 4174 E80D9FE5 		ldr	r0, .L1034+20
 7513 4178 181E9FE5 		ldr	r1, .L1034+72
 7514 417c E42D9FE5 		ldr	r2, .L1034+24
 7515 4180 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7516 4184 244E9FE5 		ldr	r4, .L1034+96
 7517 4188 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7518 418c B010D2E1 		ldrh	r1, [r2]
 7519 4190 B0C0D4E1 		ldrh	ip, [r4]
 7520 4194 00008DE5 		str	r0, [sp]
 7521 4198 B000DAE1 		ldrh	r0, [r10]
 7522 419c 10108DE5 		str	r1, [sp, #16]
 7523 41a0 0010A0E3 		mov	r1, #0
 7524 41a4 0C008DE5 		str	r0, [sp, #12]
 7525 41a8 14108DE5 		str	r1, [sp, #20]
 7526 41ac 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 7527 41b0 04E08DE5 		str	lr, [sp, #4]
 7528 41b4 08C08DE5 		str	ip, [sp, #8]
 7529 41b8 0400A0E3 		mov	r0, #4
 7530 41bc A81D9FE5 		ldr	r1, .L1034+28
 7531 41c0 FEFFFFEB 		bl	CyU3PDebugPrint
 7532              	.LVL903:
 7533 41c4 44309DE5 		ldr	r3, [sp, #68]
 7534 41c8 8AFFFFEA 		b	.L641
 7535              	.L988:
5388:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7536              		.loc 1 5388 0
 7537 41cc FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7538              	.LVL904:
5389:../uvc.c      ****                 {
 7539              		.loc 1 5389 0
 7540 41d0 000050E3 		cmp	r0, #0
5391:../uvc.c      ****                 }
 7541              		.loc 1 5391 0
 7542 41d4 0130A013 		movne	r3, #1
5388:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7543              		.loc 1 5388 0
 7544 41d8 4800CBE5 		strb	r0, [fp, #72]
5391:../uvc.c      ****                 }
 7545              		.loc 1 5391 0
 7546 41dc 8C308B15 		strne	r3, [fp, #140]
 7547 41e0 81FFFFEA 		b	.L639
 7548              	.L915:
5440:../uvc.c      ****                 }
 7549              		.loc 1 5440 0
 7550 41e4 94EFFFEB 		bl	UVCHandleVideoStreamingRqts
 7551              	.LVL905:
 7552 41e8 44309DE5 		ldr	r3, [sp, #68]
 7553 41ec AEFFFFEA 		b	.L914
 7554              	.L994:
5536:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7555              		.loc 1 5536 0
 7556 41f0 002098E5 		ldr	r2, [r8]
 7557 41f4 0210A0E3 		mov	r1, #2
 7558 41f8 0010C2E5 		strb	r1, [r2]
5537:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7559              		.loc 1 5537 0
 7560 41fc 002098E5 		ldr	r2, [r8]
 7561 4200 0140A0E3 		mov	r4, #1
 7562 4204 0140C2E5 		strb	r4, [r2, #1]
5538:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7563              		.loc 1 5538 0
 7564 4208 001098E5 		ldr	r1, [r8]
5542:../uvc.c      **** 					interStabuf.status = 0;
 7565              		.loc 1 5542 0
 7566 420c 012BA0E3 		mov	r2, #1024
5538:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7567              		.loc 1 5538 0
 7568 4210 0230C1E5 		strb	r3, [r1, #2]
5539:../uvc.c      **** 
 7569              		.loc 1 5539 0
 7570 4214 001098E5 		ldr	r1, [r8]
5545:../uvc.c      **** 
 7571              		.loc 1 5545 0
 7572 4218 0450A0E3 		mov	r5, #4
5539:../uvc.c      **** 
 7573              		.loc 1 5539 0
 7574 421c 0340C1E5 		strb	r4, [r1, #3]
5541:../uvc.c      **** 					interStabuf.size   = 1024;
 7575              		.loc 1 5541 0
 7576 4220 001098E5 		ldr	r1, [r8]
5548:../uvc.c      **** 
 7577              		.loc 1 5548 0
 7578 4224 440D9FE5 		ldr	r0, .L1034+32
5541:../uvc.c      **** 					interStabuf.size   = 1024;
 7579              		.loc 1 5541 0
 7580 4228 4C108DE5 		str	r1, [sp, #76]
5548:../uvc.c      **** 
 7581              		.loc 1 5548 0
 7582 422c 0010E0E3 		mvn	r1, #0
5543:../uvc.c      **** 
 7583              		.loc 1 5543 0
 7584 4230 B435CDE1 		strh	r3, [sp, #84]	@ movhi
5542:../uvc.c      **** 					interStabuf.status = 0;
 7585              		.loc 1 5542 0
 7586 4234 B225CDE1 		strh	r2, [sp, #82]	@ movhi
5545:../uvc.c      **** 
 7587              		.loc 1 5545 0
 7588 4238 B055CDE1 		strh	r5, [sp, #80]	@ movhi
5548:../uvc.c      **** 
 7589              		.loc 1 5548 0
 7590 423c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7591              	.LVL906:
5551:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7592              		.loc 1 5551 0
 7593 4240 280D9FE5 		ldr	r0, .L1034+32
 7594 4244 4C108DE2 		add	r1, sp, #76
 7595 4248 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7596              	.LVL907:
5553:../uvc.c      **** 					{
 7597              		.loc 1 5553 0
 7598 424c 000050E3 		cmp	r0, #0
 7599 4250 0902001A 		bne	.L997
5559:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7600              		.loc 1 5559 0
 7601 4254 0500A0E3 		mov	r0, #5
 7602              	.LVL908:
 7603 4258 3010A0E3 		mov	r1, #48
 7604 425c 0420A0E1 		mov	r2, r4
 7605 4260 FEFFFFEB 		bl	SensorSetControl
 7606              	.LVL909:
5560:../uvc.c      **** 				}
 7607              		.loc 1 5560 0
 7608 4264 E8EC9FE5 		ldr	lr, .L1034+4
 7609 4268 5647CEE5 		strb	r4, [lr, #1878]
 7610 426c 98FFFFEA 		b	.L637
 7611              	.L993:
5509:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7612              		.loc 1 5509 0
 7613 4270 003098E5 		ldr	r3, [r8]
 7614 4274 0220A0E3 		mov	r2, #2
 7615 4278 0020C3E5 		strb	r2, [r3]
5510:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7616              		.loc 1 5510 0
 7617 427c 003098E5 		ldr	r3, [r8]
 7618 4280 0140A0E3 		mov	r4, #1
 7619 4284 0140C3E5 		strb	r4, [r3, #1]
5511:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7620              		.loc 1 5511 0
 7621 4288 002098E5 		ldr	r2, [r8]
 7622 428c 0030A0E3 		mov	r3, #0
 7623 4290 0230C2E5 		strb	r3, [r2, #2]
5512:../uvc.c      **** 
 7624              		.loc 1 5512 0
 7625 4294 001098E5 		ldr	r1, [r8]
5515:../uvc.c      **** 					interStabuf.status = 0;
 7626              		.loc 1 5515 0
 7627 4298 012BA0E3 		mov	r2, #1024
5512:../uvc.c      **** 
 7628              		.loc 1 5512 0
 7629 429c 0330C1E5 		strb	r3, [r1, #3]
5514:../uvc.c      **** 					interStabuf.size   = 1024;
 7630              		.loc 1 5514 0
 7631 42a0 001098E5 		ldr	r1, [r8]
5518:../uvc.c      **** 
 7632              		.loc 1 5518 0
 7633 42a4 0460A0E3 		mov	r6, #4
5514:../uvc.c      **** 					interStabuf.size   = 1024;
 7634              		.loc 1 5514 0
 7635 42a8 4C108DE5 		str	r1, [sp, #76]
5521:../uvc.c      **** 
 7636              		.loc 1 5521 0
 7637 42ac BC0C9FE5 		ldr	r0, .L1034+32
 7638 42b0 0010E0E3 		mvn	r1, #0
5515:../uvc.c      **** 					interStabuf.status = 0;
 7639              		.loc 1 5515 0
 7640 42b4 B225CDE1 		strh	r2, [sp, #82]	@ movhi
5516:../uvc.c      **** 
 7641              		.loc 1 5516 0
 7642 42b8 B435CDE1 		strh	r3, [sp, #84]	@ movhi
5518:../uvc.c      **** 
 7643              		.loc 1 5518 0
 7644 42bc B065CDE1 		strh	r6, [sp, #80]	@ movhi
5521:../uvc.c      **** 
 7645              		.loc 1 5521 0
 7646 42c0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7647              	.LVL910:
5524:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7648              		.loc 1 5524 0
 7649 42c4 A40C9FE5 		ldr	r0, .L1034+32
 7650 42c8 4C108DE2 		add	r1, sp, #76
 7651 42cc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7652              	.LVL911:
5526:../uvc.c      **** 					{
 7653              		.loc 1 5526 0
 7654 42d0 002050E2 		subs	r2, r0, #0
 7655 42d4 0704001A 		bne	.L998
5531:../uvc.c      **** 
 7656              		.loc 1 5531 0
 7657 42d8 0500A0E3 		mov	r0, #5
 7658              	.LVL912:
 7659 42dc 3010A0E3 		mov	r1, #48
 7660 42e0 FEFFFFEB 		bl	SensorSetControl
 7661              	.LVL913:
5533:../uvc.c      **** 				}else if(!snapButFlag){
 7662              		.loc 1 5533 0
 7663 42e4 68CC9FE5 		ldr	ip, .L1034+4
 7664 42e8 5647CCE5 		strb	r4, [ip, #1878]
 7665 42ec 78FFFFEA 		b	.L637
 7666              	.L829:
 7667              	.LBB431:
 7668              	.LBB418:
4872:../uvc.c      ****     {
 7669              		.loc 1 4872 0
 7670 42f0 050B53E3 		cmp	r3, #5120
 7671 42f4 7C03000A 		beq	.L845
 7672 42f8 3500009A 		bls	.L999
 7673 42fc 170C53E3 		cmp	r3, #5888
 7674 4300 9B03000A 		beq	.L853
 7675 4304 B300009A 		bls	.L1000
 7676 4308 1A0C53E3 		cmp	r3, #6656
 7677 430c 8E03000A 		beq	.L857
 7678 4310 1B0C53E3 		cmp	r3, #6912
 7679 4314 8203000A 		beq	.L858
 7680 4318 060B53E3 		cmp	r3, #6144
 7681 431c 53FFFF1A 		bne	.L643
4977:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7682              		.loc 1 4977 0
 7683 4320 2B00A0E3 		mov	r0, #43
 7684 4324 FEFFFFEB 		bl	ControlHandle
 7685              	.LVL914:
4978:../uvc.c      ****     		break;
 7686              		.loc 1 4978 0
 7687 4328 683C9FE5 		ldr	r3, .L1034+72
 7688 432c B020D4E1 		ldrh	r2, [r4]
 7689 4330 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7690 4334 0400A0E3 		mov	r0, #4
 7691 4338 341C9FE5 		ldr	r1, .L1034+36
 7692 433c FEFFFFEB 		bl	CyU3PDebugPrint
 7693              	.LVL915:
 7694 4340 44309DE5 		ldr	r3, [sp, #68]
 7695 4344 4EFFFFEA 		b	.L642
 7696              	.L651:
 7697              	.LBE418:
 7698              	.LBE431:
 7699              	.LBB432:
 7700              	.LBB364:
4572:../uvc.c      ****     {
 7701              		.loc 1 4572 0
 7702 4348 0A0C52E3 		cmp	r2, #2560
 7703 434c 5E00000A 		beq	.L657
 7704 4350 3200009A 		bls	.L1001
 7705 4354 0D0C52E3 		cmp	r2, #3328
 7706 4358 5B00000A 		beq	.L657
 7707 435c 0E0C52E3 		cmp	r2, #3584
 7708 4360 5D00000A 		beq	.L661
 7709 4364 030B52E3 		cmp	r2, #3072
 7710 4368 3BFFFF1A 		bne	.L690
 7711              	.LVL916:
4613:../uvc.c      ****     		break;
 7712              		.loc 1 4613 0
 7713 436c 0B00A0E3 		mov	r0, #11
 7714 4370 FEFFFFEB 		bl	ControlHandle
 7715              	.LVL917:
 7716 4374 44309DE5 		ldr	r3, [sp, #68]
 7717 4378 41FFFFEA 		b	.L642
 7718              	.L990:
 7719              	.LBE364:
 7720              	.LBE432:
 7721              	.LBB433:
 7722              	.LBB334:
4647:../uvc.c      ****     {
 7723              		.loc 1 4647 0
 7724 437c 030C52E3 		cmp	r2, #768
 7725 4380 D400000A 		beq	.L693
 7726 4384 3200008A 		bhi	.L694
 7727 4388 010C52E3 		cmp	r2, #256
 7728 438c FC00000A 		beq	.L695
 7729 4390 020C52E3 		cmp	r2, #512
 7730 4394 30FFFF1A 		bne	.L690
 7731              	.LVL918:
4655:../uvc.c      ****     		break;
 7732              		.loc 1 4655 0
 7733 4398 0100A0E3 		mov	r0, #1
 7734 439c FEFFFFEB 		bl	CTControlHandle
 7735              	.LVL919:
 7736 43a0 44309DE5 		ldr	r3, [sp, #68]
 7737 43a4 36FFFFEA 		b	.L642
 7738              	.L995:
 7739              	.LBE334:
 7740              	.LBE433:
 7741              	.LBB434:
 7742              	.LBB419:
4872:../uvc.c      ****     {
 7743              		.loc 1 4872 0
 7744 43a8 030C53E3 		cmp	r3, #768
 7745 43ac AF03000A 		beq	.L832
 7746 43b0 7800008A 		bhi	.L833
 7747 43b4 010C53E3 		cmp	r3, #256
 7748 43b8 A803000A 		beq	.L834
 7749 43bc 020C53E3 		cmp	r3, #512
 7750 43c0 2AFFFF1A 		bne	.L643
 7751              	.LVL920:
4880:../uvc.c      ****     		break;
 7752              		.loc 1 4880 0
 7753 43c4 1100A0E3 		mov	r0, #17
 7754 43c8 FEFFFFEB 		bl	ControlHandle
 7755              	.LVL921:
 7756 43cc 44309DE5 		ldr	r3, [sp, #68]
 7757 43d0 2BFFFFEA 		b	.L642
 7758              	.L999:
4872:../uvc.c      ****     {
 7759              		.loc 1 4872 0
 7760 43d4 110C53E3 		cmp	r3, #4352
 7761 43d8 A803000A 		beq	.L847
 7762 43dc AD00008A 		bhi	.L848
 7763 43e0 0F0C53E3 		cmp	r3, #3840
 7764 43e4 AD03000A 		beq	.L849
 7765 43e8 010A53E3 		cmp	r3, #4096
 7766 43ec 1FFFFF1A 		bne	.L643
 7767              	.LVL922:
4941:../uvc.c      ****     		break;
 7768              		.loc 1 4941 0
 7769 43f0 1F00A0E3 		mov	r0, #31
 7770 43f4 FEFFFFEB 		bl	ControlHandle
 7771              	.LVL923:
 7772 43f8 44309DE5 		ldr	r3, [sp, #68]
 7773 43fc 20FFFFEA 		b	.L642
 7774              	.L653:
 7775              	.LBE419:
 7776              	.LBE434:
 7777              	.LBB435:
 7778              	.LBB365:
4572:../uvc.c      ****     {
 7779              		.loc 1 4572 0
 7780 4400 010B52E3 		cmp	r2, #1024
 7781 4404 1EFFFF0A 		beq	.L642
 7782 4408 050C52E3 		cmp	r2, #1280
 7783 440c 12FFFF1A 		bne	.L690
 7784              	.LVL924:
4591:../uvc.c      ****       		break;
 7785              		.loc 1 4591 0
 7786 4410 0400A0E3 		mov	r0, #4
 7787 4414 FEFFFFEB 		bl	ControlHandle
 7788              	.LVL925:
 7789 4418 44309DE5 		ldr	r3, [sp, #68]
 7790 441c 18FFFFEA 		b	.L642
 7791              	.L1001:
4572:../uvc.c      ****     {
 7792              		.loc 1 4572 0
 7793 4420 070C52E3 		cmp	r2, #1792
 7794 4424 5700000A 		beq	.L659
 7795 4428 020B52E3 		cmp	r2, #2048
 7796 442c 0AFFFF1A 		bne	.L690
 7797              	.LVL926:
4603:../uvc.c      ****           		break;
 7798              		.loc 1 4603 0
 7799 4430 0700A0E3 		mov	r0, #7
 7800 4434 FEFFFFEB 		bl	ControlHandle
 7801              	.LVL927:
 7802 4438 44309DE5 		ldr	r3, [sp, #68]
 7803 443c 10FFFFEA 		b	.L642
 7804              	.L991:
 7805              	.LBE365:
 7806              	.LBE435:
 7807              	.LBB436:
 7808              	.LBB335:
4647:../uvc.c      ****     {
 7809              		.loc 1 4647 0
 7810 4440 070C52E3 		cmp	r2, #1792
 7811 4444 B400000A 		beq	.L701
 7812 4448 020B52E3 		cmp	r2, #2048
 7813 444c 0CFFFF0A 		beq	.L642
 7814 4450 01FFFFEA 		b	.L690
 7815              	.L694:
 7816 4454 010B52E3 		cmp	r2, #1024
 7817 4458 E300000A 		beq	.L697
 7818 445c 050C52E3 		cmp	r2, #1280
 7819 4460 FDFEFF1A 		bne	.L690
 7820              	.LVL928:
 7821              	.LBB170:
 7822              	.LBB171:
2954:../uvc.c      **** 
 7823              		.loc 1 2954 0
 7824 4464 2C4B9FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 7825              		.loc 1 2949 0
 7826 4468 FE65D9E5 		ldrb	r6, [r9, #1534]	@ zero_extendqisi2
 7827              	.LVL929:
2954:../uvc.c      **** 
 7828              		.loc 1 2954 0
 7829 446c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 7830              	.LVL930:
2956:../uvc.c      **** 		 {
 7831              		.loc 1 2956 0
 7832 4470 830055E3 		cmp	r5, #131
 7833 4474 B405000A 		beq	.L743
 7834 4478 2802009A 		bls	.L1002
 7835 447c 850055E3 		cmp	r5, #133
 7836 4480 0403000A 		beq	.L805
 7837 4484 6905003A 		bcc	.L749
 7838 4488 860055E3 		cmp	r5, #134
 7839 448c 1E04000A 		beq	.L750
 7840 4490 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 7841              		.loc 1 3018 0
 7842 4494 0716D905 		ldreqb	r1, [r9, #1543]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7843              		.loc 1 3019 0
 7844 4498 0826D905 		ldreqb	r2, [r9, #1544]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 7845              		.loc 1 2956 0
 7846 449c 1301000A 		beq	.L972
 7847              	.L742:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7848              		.loc 1 3163 0
 7849 44a0 0000A0E3 		mov	r0, #0
 7850 44a4 0020A0E1 		mov	r2, r0
 7851 44a8 0110A0E3 		mov	r1, #1
 7852 44ac FEFFFFEB 		bl	CyU3PUsbStall
 7853              	.LVL931:
3164:../uvc.c      **** 			  break;
 7854              		.loc 1 3164 0
 7855 44b0 0400A0E3 		mov	r0, #4
 7856 44b4 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 7857 44b8 0020A0E1 		mov	r2, r0
 7858 44bc FC1A9FE5 		ldr	r1, .L1034+112
 7859 44c0 FEFFFFEB 		bl	CyU3PDebugPrint
 7860              	.LVL932:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7861              		.loc 1 2950 0
 7862 44c4 FF40A0E3 		mov	r4, #255
 7863              	.LVL933:
 7864 44c8 F90200EA 		b	.L809
 7865              	.LVL934:
 7866              	.L657:
 7867              	.LBE171:
 7868              	.LBE170:
 7869              	.LBE335:
 7870              	.LBE436:
 7871              	.LBB437:
 7872              	.LBB366:
4609:../uvc.c      ****     		break;
 7873              		.loc 1 4609 0
 7874 44cc 0900A0E3 		mov	r0, #9
 7875 44d0 FEFFFFEB 		bl	ControlHandle
 7876              	.LVL935:
 7877 44d4 44309DE5 		ldr	r3, [sp, #68]
 7878 44d8 E9FEFFEA 		b	.L642
 7879              	.L661:
 7880              	.LVL936:
 7881              	.LBB346:
 7882              	.LBB347:
1317:../uvc.c      ****     /*
 7883              		.loc 1 1317 0
 7884 44dc B43A9FE5 		ldr	r3, .L1034+72
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7885              		.loc 1 1306 0
 7886 44e0 1C27D9E5 		ldrb	r2, [r9, #1820]	@ zero_extendqisi2
1317:../uvc.c      ****     /*
 7887              		.loc 1 1317 0
 7888 44e4 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1307:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7889              		.loc 1 1307 0
 7890 44e8 1D47D9E5 		ldrb	r4, [r9, #1821]	@ zero_extendqisi2
1308:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7891              		.loc 1 1308 0
 7892 44ec 2B37D9E5 		ldrb	r3, [r9, #1835]	@ zero_extendqisi2
1309:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7893              		.loc 1 1309 0
 7894 44f0 1E57D9E5 		ldrb	r5, [r9, #1822]	@ zero_extendqisi2
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7895              		.loc 1 1306 0
 7896 44f4 FF2002E2 		and	r2, r2, #255
1308:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7897              		.loc 1 1308 0
 7898 44f8 FF3003E2 		and	r3, r3, #255
1325:../uvc.c      **** 		 {
 7899              		.loc 1 1325 0
 7900 44fc 830056E3 		cmp	r6, #131
1306:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7901              		.loc 1 1306 0
 7902 4500 2C208DE5 		str	r2, [sp, #44]
 7903              	.LVL937:
1307:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7904              		.loc 1 1307 0
 7905 4504 FF4004E2 		and	r4, r4, #255
 7906              	.LVL938:
1308:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7907              		.loc 1 1308 0
 7908 4508 28308DE5 		str	r3, [sp, #40]
 7909              	.LVL939:
1309:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7910              		.loc 1 1309 0
 7911 450c FF5005E2 		and	r5, r5, #255
 7912              	.LVL940:
1325:../uvc.c      **** 		 {
 7913              		.loc 1 1325 0
 7914 4510 BA04000A 		beq	.L664
 7915 4514 5F01009A 		bls	.L1003
 7916 4518 850056E3 		cmp	r6, #133
 7917 451c 9F04000A 		beq	.L669
 7918 4520 C404003A 		bcc	.L670
 7919 4524 860056E3 		cmp	r6, #134
 7920 4528 8F03000A 		beq	.L671
 7921 452c 870056E3 		cmp	r6, #135
 7922 4530 A704001A 		bne	.L663
1976:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7923              		.loc 1 1976 0
 7924 4534 020055E3 		cmp	r5, #2
1981:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7925              		.loc 1 1981 0
 7926 4538 27C7D915 		ldrneb	ip, [r9, #1831]	@ zero_extendqisi2
1983:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7927              		.loc 1 1983 0
 7928 453c 2827D915 		ldrneb	r2, [r9, #1832]	@ zero_extendqisi2
1976:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7929              		.loc 1 1976 0
 7930 4540 A206000A 		beq	.L1004
 7931              	.L983:
1988:../uvc.c      **** 		 	 if(Len == 2){
 7932              		.loc 1 1988 0
 7933 4544 7C1A9FE5 		ldr	r1, .L1034+120
1984:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7934              		.loc 1 1984 0
 7935 4548 0030A0E3 		mov	r3, #0
1988:../uvc.c      **** 		 	 if(Len == 2){
 7936              		.loc 1 1988 0
 7937 454c 0500A0E1 		mov	r0, r5
1981:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7938              		.loc 1 1981 0
 7939 4550 28C0C7E5 		strb	ip, [r7, #40]
1983:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7940              		.loc 1 1983 0
 7941 4554 2920C7E5 		strb	r2, [r7, #41]
1984:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7942              		.loc 1 1984 0
 7943 4558 2B30C7E5 		strb	r3, [r7, #43]
1994:../uvc.c      **** 		 	 }
 7944              		.loc 1 1994 0
 7945 455c 24308DE5 		str	r3, [sp, #36]
 7946              	.LVL941:
 7947              	.L961:
1879:../uvc.c      **** 		 	 if(Len == 2){
 7948              		.loc 1 1879 0
 7949 4560 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7950              	.LVL942:
1885:../uvc.c      **** 			  }
 7951              		.loc 1 1885 0
 7952 4564 0050A0E3 		mov	r5, #0
 7953              	.LVL943:
1884:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
 7954              		.loc 1 1884 0
 7955 4568 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 7956              	.LVL944:
1885:../uvc.c      **** 			  }
 7957              		.loc 1 1885 0
 7958 456c 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 7959              	.LVL945:
 7960 4570 24209DE5 		ldr	r2, [sp, #36]
 7961 4574 710100EA 		b	.L673
 7962              	.LVL946:
 7963              	.L654:
 7964              	.LBE347:
 7965              	.LBE346:
4576:../uvc.c      ****     		break;
 7966              		.loc 1 4576 0
 7967 4578 0000A0E3 		mov	r0, #0
 7968 457c FEFFFFEB 		bl	ControlHandle
 7969              	.LVL947:
 7970 4580 44309DE5 		ldr	r3, [sp, #68]
 7971 4584 BEFEFFEA 		b	.L642
 7972              	.L659:
 7973              	.LVL948:
4599:../uvc.c      ****           		break;
 7974              		.loc 1 4599 0
 7975 4588 0600A0E3 		mov	r0, #6
 7976 458c FEFFFFEB 		bl	ControlHandle
 7977              	.LVL949:
 7978 4590 44309DE5 		ldr	r3, [sp, #68]
 7979 4594 BAFEFFEA 		b	.L642
 7980              	.L833:
 7981              	.LBE366:
 7982              	.LBE437:
 7983              	.LBB438:
 7984              	.LBB420:
4872:../uvc.c      ****     {
 7985              		.loc 1 4872 0
 7986 4598 010B53E3 		cmp	r3, #1024
 7987 459c 4303000A 		beq	.L836
 7988 45a0 050C53E3 		cmp	r3, #1280
 7989 45a4 B1FEFF1A 		bne	.L643
 7990              	.LVL950:
4892:../uvc.c      ****     		break;
 7991              		.loc 1 4892 0
 7992 45a8 1400A0E3 		mov	r0, #20
 7993 45ac FEFFFFEB 		bl	ControlHandle
 7994              	.LVL951:
 7995 45b0 44309DE5 		ldr	r3, [sp, #68]
 7996 45b4 B2FEFFEA 		b	.L642
 7997              	.L652:
 7998              	.LVL952:
 7999              	.LBE420:
 8000              	.LBE438:
 8001              	.LBB439:
 8002              	.LBB367:
4584:../uvc.c      **** 			break;
 8003              		.loc 1 4584 0
 8004 45b8 0200A0E3 		mov	r0, #2
 8005 45bc FEFFFFEB 		bl	ControlHandle
 8006              	.LVL953:
 8007 45c0 44309DE5 		ldr	r3, [sp, #68]
 8008 45c4 AEFEFFEA 		b	.L642
 8009              	.L650:
 8010              	.LVL954:
4595:../uvc.c      ****      		break;
 8011              		.loc 1 4595 0
 8012 45c8 0500A0E3 		mov	r0, #5
 8013 45cc FEFFFFEB 		bl	ControlHandle
 8014              	.LVL955:
 8015 45d0 44309DE5 		ldr	r3, [sp, #68]
 8016 45d4 AAFEFFEA 		b	.L642
 8017              	.L1000:
 8018              	.LBE367:
 8019              	.LBE439:
 8020              	.LBB440:
 8021              	.LBB421:
4872:../uvc.c      ****     {
 8022              		.loc 1 4872 0
 8023 45d8 150C53E3 		cmp	r3, #5376
 8024 45dc 3B03000A 		beq	.L855
 8025 45e0 160C53E3 		cmp	r3, #5632
 8026 45e4 A1FEFF1A 		bne	.L643
 8027              	.LVL956:
 8028              	.LBB378:
 8029              	.LBB379:
1317:../uvc.c      ****     /*
 8030              		.loc 1 1317 0
 8031 45e8 A8499FE5 		ldr	r4, .L1034+72
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8032              		.loc 1 1299 0
 8033 45ec 3027D9E5 		ldrb	r2, [r9, #1840]	@ zero_extendqisi2
1317:../uvc.c      ****     /*
 8034              		.loc 1 1317 0
 8035 45f0 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
1300:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8036              		.loc 1 1300 0
 8037 45f4 3157D9E5 		ldrb	r5, [r9, #1841]	@ zero_extendqisi2
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8038              		.loc 1 1301 0
 8039 45f8 3F37D9E5 		ldrb	r3, [r9, #1855]	@ zero_extendqisi2
1302:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8040              		.loc 1 1302 0
 8041 45fc 3267D9E5 		ldrb	r6, [r9, #1842]	@ zero_extendqisi2
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8042              		.loc 1 1299 0
 8043 4600 FF2002E2 		and	r2, r2, #255
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8044              		.loc 1 1301 0
 8045 4604 FF3003E2 		and	r3, r3, #255
1325:../uvc.c      **** 		 {
 8046              		.loc 1 1325 0
 8047 4608 83005CE3 		cmp	ip, #131
1317:../uvc.c      ****     /*
 8048              		.loc 1 1317 0
 8049 460c 28C08DE5 		str	ip, [sp, #40]
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8050              		.loc 1 1299 0
 8051 4610 34208DE5 		str	r2, [sp, #52]
 8052              	.LVL957:
1300:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8053              		.loc 1 1300 0
 8054 4614 FF5005E2 		and	r5, r5, #255
 8055              	.LVL958:
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8056              		.loc 1 1301 0
 8057 4618 2C308DE5 		str	r3, [sp, #44]
 8058              	.LVL959:
1302:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8059              		.loc 1 1302 0
 8060 461c FF6006E2 		and	r6, r6, #255
 8061              	.LVL960:
1325:../uvc.c      **** 		 {
 8062              		.loc 1 1325 0
 8063 4620 F903000A 		beq	.L861
 8064 4624 3304009A 		bls	.L1005
 8065 4628 28C09DE5 		ldr	ip, [sp, #40]
 8066 462c 85005CE3 		cmp	ip, #133
 8067 4630 BC03000A 		beq	.L866
 8068 4634 BA05003A 		bcc	.L867
 8069 4638 86005CE3 		cmp	ip, #134
 8070 463c AF05000A 		beq	.L868
 8071 4640 87005CE3 		cmp	ip, #135
 8072 4644 DE05001A 		bne	.L860
1963:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8073              		.loc 1 1963 0
 8074 4648 020056E3 		cmp	r6, #2
1964:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8075              		.loc 1 1964 0
 8076 464c 3B27D905 		ldreqb	r2, [r9, #1851]	@ zero_extendqisi2
1988:../uvc.c      **** 		 	 if(Len == 2){
 8077              		.loc 1 1988 0
 8078 4650 0600A001 		moveq	r0, r6
1965:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8079              		.loc 1 1965 0
 8080 4654 3C37D905 		ldreqb	r3, [r9, #1852]	@ zero_extendqisi2
1963:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8081              		.loc 1 1963 0
 8082 4658 F203000A 		beq	.L975
1969:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8083              		.loc 1 1969 0
 8084 465c 3BC7D9E5 		ldrb	ip, [r9, #1851]	@ zero_extendqisi2
1971:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8085              		.loc 1 1971 0
 8086 4660 3C27D9E5 		ldrb	r2, [r9, #1852]	@ zero_extendqisi2
 8087              	.L976:
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 8088              		.loc 1 1897 0
 8089 4664 0030A0E3 		mov	r3, #0
1915:../uvc.c      **** 				  if(Len == 2){
 8090              		.loc 1 1915 0
 8091 4668 0600A0E1 		mov	r0, r6
 8092 466c 54199FE5 		ldr	r1, .L1034+120
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8093              		.loc 1 1896 0
 8094 4670 28C0C7E5 		strb	ip, [r7, #40]
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8095              		.loc 1 1898 0
 8096 4674 2A20C7E5 		strb	r2, [r7, #42]
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 8097              		.loc 1 1897 0
 8098 4678 2930C7E5 		strb	r3, [r7, #41]
1899:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 8099              		.loc 1 1899 0
 8100 467c 2B30C7E5 		strb	r3, [r7, #43]
1921:../uvc.c      **** 				  }
 8101              		.loc 1 1921 0
 8102 4680 24308DE5 		str	r3, [sp, #36]
 8103 4684 0060A0E3 		mov	r6, #0
 8104              	.LVL961:
1915:../uvc.c      **** 				  if(Len == 2){
 8105              		.loc 1 1915 0
 8106 4688 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8107              	.LVL962:
1920:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 8108              		.loc 1 1920 0
 8109 468c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8110              	.LVL963:
1921:../uvc.c      **** 				  }
 8111              		.loc 1 1921 0
 8112 4690 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 8113              	.LVL964:
 8114 4694 AD0300EA 		b	.L870
 8115              	.LVL965:
 8116              	.L848:
 8117              	.LBE379:
 8118              	.LBE378:
4872:../uvc.c      ****     {
 8119              		.loc 1 4872 0
 8120 4698 120C53E3 		cmp	r3, #4608
 8121 469c 0703000A 		beq	.L851
 8122 46a0 130C53E3 		cmp	r3, #4864
 8123 46a4 71FEFF1A 		bne	.L643
 8124              	.LVL966:
4953:../uvc.c      ****     		break;
 8125              		.loc 1 4953 0
 8126 46a8 2600A0E3 		mov	r0, #38
 8127 46ac FEFFFFEB 		bl	ControlHandle
 8128              	.LVL967:
 8129 46b0 44309DE5 		ldr	r3, [sp, #68]
 8130 46b4 72FEFFEA 		b	.L642
 8131              	.L996:
4872:../uvc.c      ****     {
 8132              		.loc 1 4872 0
 8133 46b8 070C53E3 		cmp	r3, #1792
 8134 46bc F302000A 		beq	.L840
 8135 46c0 020B53E3 		cmp	r3, #2048
 8136 46c4 69FEFF1A 		bne	.L643
 8137              	.LVL968:
4904:../uvc.c      ****     		break;
 8138              		.loc 1 4904 0
 8139 46c8 1700A0E3 		mov	r0, #23
 8140 46cc FEFFFFEB 		bl	ControlHandle
 8141              	.LVL969:
 8142 46d0 44309DE5 		ldr	r3, [sp, #68]
 8143 46d4 6AFEFFEA 		b	.L642
 8144              	.L693:
 8145              	.LVL970:
 8146              	.LBE421:
 8147              	.LBE440:
 8148              	.LBB441:
 8149              	.LBB336:
 8150              	.LBB178:
 8151              	.LBB179:
2954:../uvc.c      **** 
 8152              		.loc 1 2954 0
 8153 46d8 B8489FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8154              		.loc 1 2949 0
 8155 46dc CE65D9E5 		ldrb	r6, [r9, #1486]	@ zero_extendqisi2
 8156              	.LVL971:
2954:../uvc.c      **** 
 8157              		.loc 1 2954 0
 8158 46e0 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8159              	.LVL972:
2956:../uvc.c      **** 		 {
 8160              		.loc 1 2956 0
 8161 46e4 830055E3 		cmp	r5, #131
 8162 46e8 2705000A 		beq	.L717
 8163 46ec 1C01009A 		bls	.L1006
 8164 46f0 850055E3 		cmp	r5, #133
 8165 46f4 6702000A 		beq	.L805
 8166 46f8 0005003A 		bcc	.L723
 8167 46fc 860055E3 		cmp	r5, #134
 8168 4700 4803000A 		beq	.L724
 8169 4704 870055E3 		cmp	r5, #135
 8170 4708 2F05001A 		bne	.L716
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8171              		.loc 1 3018 0
 8172 470c 40C89FE5 		ldr	ip, .L1034+4
 8173 4710 D715DCE5 		ldrb	r1, [ip, #1495]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8174              		.loc 1 3019 0
 8175 4714 D825DCE5 		ldrb	r2, [ip, #1496]	@ zero_extendqisi2
 8176 4718 740000EA 		b	.L972
 8177              	.LVL973:
 8178              	.L701:
 8179              	.LBE179:
 8180              	.LBE178:
 8181              	.LBB187:
 8182              	.LBB188:
2954:../uvc.c      **** 
 8183              		.loc 1 2954 0
 8184 471c 74489FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8185              		.loc 1 2949 0
 8186 4720 2E66D9E5 		ldrb	r6, [r9, #1582]	@ zero_extendqisi2
 8187              	.LVL974:
2954:../uvc.c      **** 
 8188              		.loc 1 2954 0
 8189 4724 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8190              	.LVL975:
2956:../uvc.c      **** 		 {
 8191              		.loc 1 2956 0
 8192 4728 830055E3 		cmp	r5, #131
 8193 472c C904000A 		beq	.L765
 8194 4730 E201009A 		bls	.L1007
 8195 4734 850055E3 		cmp	r5, #133
 8196 4738 5602000A 		beq	.L805
 8197 473c 2D05003A 		bcc	.L771
 8198 4740 860055E3 		cmp	r5, #134
 8199 4744 6203000A 		beq	.L772
 8200 4748 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8201              		.loc 1 3018 0
 8202 474c 3716D905 		ldreqb	r1, [r9, #1591]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8203              		.loc 1 3019 0
 8204 4750 3826D905 		ldreqb	r2, [r9, #1592]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8205              		.loc 1 2956 0
 8206 4754 6500000A 		beq	.L972
 8207              	.L764:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8208              		.loc 1 3163 0
 8209 4758 0000A0E3 		mov	r0, #0
 8210 475c 0020A0E1 		mov	r2, r0
 8211 4760 0110A0E3 		mov	r1, #1
 8212 4764 FEFFFFEB 		bl	CyU3PUsbStall
 8213              	.LVL976:
3164:../uvc.c      **** 			  break;
 8214              		.loc 1 3164 0
 8215 4768 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8216 476c 0400A0E3 		mov	r0, #4
 8217 4770 48189FE5 		ldr	r1, .L1034+112
 8218 4774 0620A0E3 		mov	r2, #6
 8219 4778 FEFFFFEB 		bl	CyU3PDebugPrint
 8220              	.LVL977:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8221              		.loc 1 2950 0
 8222 477c FF40A0E3 		mov	r4, #255
 8223              	.LVL978:
 8224 4780 4B0200EA 		b	.L809
 8225              	.LVL979:
 8226              	.L695:
 8227              	.LBE188:
 8228              	.LBE187:
 8229              	.LBB195:
 8230              	.LBB196:
2954:../uvc.c      **** 
 8231              		.loc 1 2954 0
 8232 4784 0C489FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8233              		.loc 1 2949 0
 8234 4788 9E65D9E5 		ldrb	r6, [r9, #1438]	@ zero_extendqisi2
 8235              	.LVL980:
2954:../uvc.c      **** 
 8236              		.loc 1 2954 0
 8237 478c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8238              	.LVL981:
2956:../uvc.c      **** 		 {
 8239              		.loc 1 2956 0
 8240 4790 830055E3 		cmp	r5, #131
 8241 4794 AB04000A 		beq	.L706
 8242 4798 0401009A 		bls	.L1008
 8243 479c 850055E3 		cmp	r5, #133
 8244 47a0 3C02000A 		beq	.L805
 8245 47a4 1705003A 		bcc	.L712
 8246 47a8 860055E3 		cmp	r5, #134
 8247 47ac 2603000A 		beq	.L713
 8248 47b0 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8249              		.loc 1 3018 0
 8250 47b4 A715D905 		ldreqb	r1, [r9, #1447]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8251              		.loc 1 3019 0
 8252 47b8 A825D905 		ldreqb	r2, [r9, #1448]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8253              		.loc 1 2956 0
 8254 47bc 4B00000A 		beq	.L972
 8255              	.L705:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8256              		.loc 1 3163 0
 8257 47c0 0000A0E3 		mov	r0, #0
 8258 47c4 0020A0E1 		mov	r2, r0
 8259 47c8 0110A0E3 		mov	r1, #1
 8260 47cc FEFFFFEB 		bl	CyU3PUsbStall
 8261              	.LVL982:
3164:../uvc.c      **** 			  break;
 8262              		.loc 1 3164 0
 8263 47d0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8264 47d4 0400A0E3 		mov	r0, #4
 8265 47d8 E0179FE5 		ldr	r1, .L1034+112
 8266 47dc 0020A0E3 		mov	r2, #0
 8267 47e0 FEFFFFEB 		bl	CyU3PDebugPrint
 8268              	.LVL983:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8269              		.loc 1 2950 0
 8270 47e4 FF40A0E3 		mov	r4, #255
 8271              	.LVL984:
 8272 47e8 310200EA 		b	.L809
 8273              	.LVL985:
 8274              	.L697:
 8275              	.LBE196:
 8276              	.LBE195:
 8277              	.LBB203:
 8278              	.LBB204:
2954:../uvc.c      **** 
 8279              		.loc 1 2954 0
 8280 47ec A4479FE5 		ldr	r4, .L1034+72
2947:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8281              		.loc 1 2947 0
 8282 47f0 E4C5D9E5 		ldrb	ip, [r9, #1508]	@ zero_extendqisi2
2954:../uvc.c      **** 
 8283              		.loc 1 2954 0
 8284 47f4 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8285              		.loc 1 2946 0
 8286 47f8 F335D9E5 		ldrb	r3, [r9, #1523]	@ zero_extendqisi2
 8287              	.LVL986:
2956:../uvc.c      **** 		 {
 8288              		.loc 1 2956 0
 8289 47fc 830055E3 		cmp	r5, #131
2947:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8290              		.loc 1 2947 0
 8291 4800 24C08DE5 		str	ip, [sp, #36]
 8292              	.LVL987:
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8293              		.loc 1 2949 0
 8294 4804 E665D9E5 		ldrb	r6, [r9, #1510]	@ zero_extendqisi2
 8295              	.LVL988:
2956:../uvc.c      **** 		 {
 8296              		.loc 1 2956 0
 8297 4808 D304000A 		beq	.L728
 8298 480c F900009A 		bls	.L1009
 8299 4810 850055E3 		cmp	r5, #133
 8300 4814 BD02000A 		beq	.L781
 8301 4818 E704003A 		bcc	.L734
 8302 481c 860055E3 		cmp	r5, #134
 8303 4820 0B03000A 		beq	.L735
 8304 4824 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8305              		.loc 1 3018 0
 8306 4828 EF15D905 		ldreqb	r1, [r9, #1519]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8307              		.loc 1 3019 0
 8308 482c F025D905 		ldreqb	r2, [r9, #1520]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8309              		.loc 1 2956 0
 8310 4830 6E04001A 		bne	.L727
 8311              	.LVL989:
 8312              	.L970:
 8313              	.LBE204:
 8314              	.LBE203:
 8315              	.LBB213:
 8316              	.LBB214:
2997:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8317              		.loc 1 2997 0
 8318 4834 0030A0E3 		mov	r3, #0
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8319              		.loc 1 2994 0
 8320 4838 2810C7E5 		strb	r1, [r7, #40]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8321              		.loc 1 2999 0
 8322 483c 0600A0E1 		mov	r0, r6
 8323 4840 80179FE5 		ldr	r1, .L1034+120
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8324              		.loc 1 2995 0
 8325 4844 2920C7E5 		strb	r2, [r7, #41]
2997:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8326              		.loc 1 2997 0
 8327 4848 2A30C7E5 		strb	r3, [r7, #42]
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8328              		.loc 1 2998 0
 8329 484c 2B30C7E5 		strb	r3, [r7, #43]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8330              		.loc 1 2999 0
 8331 4850 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8332              	.LVL990:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8333              		.loc 1 2950 0
 8334 4854 FF20A0E3 		mov	r2, #255
 8335 4858 0230A0E1 		mov	r3, r2
3000:../uvc.c      **** 			  break;
 8336              		.loc 1 3000 0
 8337 485c 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 8338              	.LVL991:
 8339 4860 B30200EA 		b	.L785
 8340              	.LVL992:
 8341              	.L699:
2954:../uvc.c      **** 
 8342              		.loc 1 2954 0
 8343 4864 2C479FE5 		ldr	r4, .L1034+72
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8344              		.loc 1 2946 0
 8345 4868 53C6D9E5 		ldrb	ip, [r9, #1619]	@ zero_extendqisi2
 8346              	.LVL993:
2954:../uvc.c      **** 
 8347              		.loc 1 2954 0
 8348 486c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2947:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8349              		.loc 1 2947 0
 8350 4870 4436D9E5 		ldrb	r3, [r9, #1604]	@ zero_extendqisi2
 8351              	.LVL994:
2956:../uvc.c      **** 		 {
 8352              		.loc 1 2956 0
 8353 4874 830055E3 		cmp	r5, #131
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8354              		.loc 1 2949 0
 8355 4878 4666D9E5 		ldrb	r6, [r9, #1606]	@ zero_extendqisi2
 8356              	.LVL995:
2956:../uvc.c      **** 		 {
 8357              		.loc 1 2956 0
 8358 487c C604000A 		beq	.L776
 8359 4880 5D01009A 		bls	.L1010
 8360 4884 850055E3 		cmp	r5, #133
 8361 4888 A002000A 		beq	.L781
 8362 488c AA04003A 		bcc	.L782
 8363 4890 860055E3 		cmp	r5, #134
 8364 4894 F802000A 		beq	.L783
 8365 4898 870055E3 		cmp	r5, #135
 8366 489c 4604001A 		bne	.L775
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8367              		.loc 1 3018 0
 8368 48a0 ACC69FE5 		ldr	ip, .L1034+4
 8369 48a4 4F16DCE5 		ldrb	r1, [ip, #1615]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8370              		.loc 1 3019 0
 8371 48a8 5026DCE5 		ldrb	r2, [ip, #1616]	@ zero_extendqisi2
 8372 48ac E0FFFFEA 		b	.L970
 8373              	.LVL996:
 8374              	.L691:
 8375              	.LBE214:
 8376              	.LBE213:
 8377              	.LBB225:
 8378              	.LBB226:
2954:../uvc.c      **** 
 8379              		.loc 1 2954 0
 8380 48b0 E0469FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8381              		.loc 1 2949 0
 8382 48b4 1666D9E5 		ldrb	r6, [r9, #1558]	@ zero_extendqisi2
 8383              	.LVL997:
2954:../uvc.c      **** 
 8384              		.loc 1 2954 0
 8385 48b8 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8386              	.LVL998:
2956:../uvc.c      **** 		 {
 8387              		.loc 1 2956 0
 8388 48bc 830055E3 		cmp	r5, #131
 8389 48c0 B904000A 		beq	.L754
 8390 48c4 3901009A 		bls	.L1011
 8391 48c8 850055E3 		cmp	r5, #133
 8392 48cc F101000A 		beq	.L805
 8393 48d0 2404003A 		bcc	.L760
 8394 48d4 860055E3 		cmp	r5, #134
 8395 48d8 0D03000A 		beq	.L761
 8396 48dc 870055E3 		cmp	r5, #135
 8397 48e0 8A04001A 		bne	.L753
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8398              		.loc 1 3018 0
 8399 48e4 68E69FE5 		ldr	lr, .L1034+4
 8400 48e8 1F16DEE5 		ldrb	r1, [lr, #1567]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8401              		.loc 1 3019 0
 8402 48ec 2026DEE5 		ldrb	r2, [lr, #1568]	@ zero_extendqisi2
 8403              	.LVL999:
 8404              	.L972:
 8405              	.LBE226:
 8406              	.LBE225:
 8407              	.LBB234:
 8408              	.LBB235:
2997:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8409              		.loc 1 2997 0
 8410 48f0 0030A0E3 		mov	r3, #0
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8411              		.loc 1 2994 0
 8412 48f4 2810C7E5 		strb	r1, [r7, #40]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8413              		.loc 1 2999 0
 8414 48f8 0600A0E1 		mov	r0, r6
 8415 48fc C4169FE5 		ldr	r1, .L1034+120
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8416              		.loc 1 2995 0
 8417 4900 2920C7E5 		strb	r2, [r7, #41]
2997:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8418              		.loc 1 2997 0
 8419 4904 2A30C7E5 		strb	r3, [r7, #42]
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8420              		.loc 1 2998 0
 8421 4908 2B30C7E5 		strb	r3, [r7, #43]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8422              		.loc 1 2999 0
 8423 490c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8424              	.LVL1000:
3000:../uvc.c      **** 			  break;
 8425              		.loc 1 3000 0
 8426 4910 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 8427              	.LVL1001:
 8428 4914 E60100EA 		b	.L809
 8429              	.LVL1002:
 8430              	.L702:
2954:../uvc.c      **** 
 8431              		.loc 1 2954 0
 8432 4918 78469FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8433              		.loc 1 2949 0
 8434 491c 7666D9E5 		ldrb	r6, [r9, #1654]	@ zero_extendqisi2
 8435              	.LVL1003:
2954:../uvc.c      **** 
 8436              		.loc 1 2954 0
 8437 4920 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8438              	.LVL1004:
2956:../uvc.c      **** 		 {
 8439              		.loc 1 2956 0
 8440 4924 830055E3 		cmp	r5, #131
 8441 4928 9304000A 		beq	.L800
 8442 492c 0D01009A 		bls	.L1012
 8443 4930 850055E3 		cmp	r5, #133
 8444 4934 D701000A 		beq	.L805
 8445 4938 1B04003A 		bcc	.L806
 8446 493c 860055E3 		cmp	r5, #134
 8447 4940 F602000A 		beq	.L807
 8448 4944 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8449              		.loc 1 3018 0
 8450 4948 7F16D905 		ldreqb	r1, [r9, #1663]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8451              		.loc 1 3019 0
 8452 494c 8026D905 		ldreqb	r2, [r9, #1664]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8453              		.loc 1 2956 0
 8454 4950 E6FFFF0A 		beq	.L972
 8455              	.L799:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8456              		.loc 1 3163 0
 8457 4954 0000A0E3 		mov	r0, #0
 8458 4958 0020A0E1 		mov	r2, r0
 8459 495c 0110A0E3 		mov	r1, #1
 8460 4960 FEFFFFEB 		bl	CyU3PUsbStall
 8461              	.LVL1005:
3164:../uvc.c      **** 			  break;
 8462              		.loc 1 3164 0
 8463 4964 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8464 4968 0400A0E3 		mov	r0, #4
 8465 496c 4C169FE5 		ldr	r1, .L1034+112
 8466 4970 0920A0E3 		mov	r2, #9
 8467 4974 FEFFFFEB 		bl	CyU3PDebugPrint
 8468              	.LVL1006:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8469              		.loc 1 2950 0
 8470 4978 FF40A0E3 		mov	r4, #255
 8471 497c CC0100EA 		b	.L809
 8472              	.LVL1007:
 8473              	.L992:
 8474              	.LBE235:
 8475              	.LBE234:
 8476              	.LBB244:
 8477              	.LBB245:
2954:../uvc.c      **** 
 8478              		.loc 1 2954 0
 8479 4980 10469FE5 		ldr	r4, .L1034+72
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8480              		.loc 1 2949 0
 8481 4984 5E66D9E5 		ldrb	r6, [r9, #1630]	@ zero_extendqisi2
 8482              	.LVL1008:
2954:../uvc.c      **** 
 8483              		.loc 1 2954 0
 8484 4988 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8485              	.LVL1009:
2956:../uvc.c      **** 		 {
 8486              		.loc 1 2956 0
 8487 498c 830055E3 		cmp	r5, #131
 8488 4990 7504000A 		beq	.L789
 8489 4994 5B01009A 		bls	.L1013
 8490 4998 850055E3 		cmp	r5, #133
 8491 499c BD01000A 		beq	.L805
 8492 49a0 2504003A 		bcc	.L795
 8493 49a4 860055E3 		cmp	r5, #134
 8494 49a8 D502000A 		beq	.L796
 8495 49ac 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8496              		.loc 1 3018 0
 8497 49b0 6716D905 		ldreqb	r1, [r9, #1639]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8498              		.loc 1 3019 0
 8499 49b4 6826D905 		ldreqb	r2, [r9, #1640]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8500              		.loc 1 2956 0
 8501 49b8 CCFFFF0A 		beq	.L972
 8502              	.L788:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8503              		.loc 1 3163 0
 8504 49bc 0000A0E3 		mov	r0, #0
 8505 49c0 0020A0E1 		mov	r2, r0
 8506 49c4 0110A0E3 		mov	r1, #1
 8507 49c8 FEFFFFEB 		bl	CyU3PUsbStall
 8508              	.LVL1010:
3164:../uvc.c      **** 			  break;
 8509              		.loc 1 3164 0
 8510 49cc 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8511 49d0 0400A0E3 		mov	r0, #4
 8512 49d4 E4159FE5 		ldr	r1, .L1034+112
 8513 49d8 0820A0E3 		mov	r2, #8
 8514 49dc FEFFFFEB 		bl	CyU3PDebugPrint
 8515              	.LVL1011:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8516              		.loc 1 2950 0
 8517 49e0 FF40A0E3 		mov	r4, #255
 8518              	.LVL1012:
 8519 49e4 B20100EA 		b	.L809
 8520              	.LVL1013:
 8521              	.L703:
 8522              	.LBE245:
 8523              	.LBE244:
 8524              	.LBB252:
 8525              	.LBB253:
2954:../uvc.c      **** 
 8526              		.loc 1 2954 0
 8527 49e8 A8459FE5 		ldr	r4, .L1034+72
2946:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8528              		.loc 1 2946 0
 8529 49ec 9BC6D9E5 		ldrb	ip, [r9, #1691]	@ zero_extendqisi2
 8530              	.LVL1014:
2954:../uvc.c      **** 
 8531              		.loc 1 2954 0
 8532 49f0 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2947:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8533              		.loc 1 2947 0
 8534 49f4 8C36D9E5 		ldrb	r3, [r9, #1676]	@ zero_extendqisi2
 8535              	.LVL1015:
2956:../uvc.c      **** 		 {
 8536              		.loc 1 2956 0
 8537 49f8 830055E3 		cmp	r5, #131
2949:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8538              		.loc 1 2949 0
 8539 49fc 8E66D9E5 		ldrb	r6, [r9, #1678]	@ zero_extendqisi2
 8540              	.LVL1016:
2956:../uvc.c      **** 		 {
 8541              		.loc 1 2956 0
 8542 4a00 C703000A 		beq	.L811
 8543 4a04 7201009A 		bls	.L1014
 8544 4a08 850055E3 		cmp	r5, #133
 8545 4a0c DC03000A 		beq	.L816
 8546 4a10 D803003A 		bcc	.L817
 8547 4a14 860055E3 		cmp	r5, #134
 8548 4a18 AF02000A 		beq	.L818
 8549 4a1c 870055E3 		cmp	r5, #135
3018:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8550              		.loc 1 3018 0
 8551 4a20 9706D905 		ldreqb	r0, [r9, #1687]	@ zero_extendqisi2
3019:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8552              		.loc 1 3019 0
 8553 4a24 9816D905 		ldreqb	r1, [r9, #1688]	@ zero_extendqisi2
2956:../uvc.c      **** 		 {
 8554              		.loc 1 2956 0
 8555 4a28 C103001A 		bne	.L810
 8556              	.L974:
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8557              		.loc 1 2998 0
 8558 4a2c 0030A0E3 		mov	r3, #0
2996:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 8559              		.loc 1 2996 0
 8560 4a30 0120A0E3 		mov	r2, #1
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8561              		.loc 1 2994 0
 8562 4a34 2800C7E5 		strb	r0, [r7, #40]
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8563              		.loc 1 2995 0
 8564 4a38 2910C7E5 		strb	r1, [r7, #41]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8565              		.loc 1 2999 0
 8566 4a3c 0600A0E1 		mov	r0, r6
 8567 4a40 80159FE5 		ldr	r1, .L1034+120
2998:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8568              		.loc 1 2998 0
 8569 4a44 2B30C7E5 		strb	r3, [r7, #43]
2996:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 8570              		.loc 1 2996 0
 8571 4a48 2A20C7E5 		strb	r2, [r7, #42]
2999:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8572              		.loc 1 2999 0
 8573 4a4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8574              	.LVL1017:
3000:../uvc.c      **** 			  break;
 8575              		.loc 1 3000 0
 8576 4a50 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 8577              	.LVL1018:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8578              		.loc 1 2950 0
 8579 4a54 FF40A0E3 		mov	r4, #255
 8580 4a58 24408DE5 		str	r4, [sp, #36]
 8581              	.LVL1019:
 8582              	.L820:
3169:../uvc.c      **** }
 8583              		.loc 1 3169 0
 8584 4a5c 08308DE5 		str	r3, [sp, #8]
 8585 4a60 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 8586 4a64 00408DE5 		str	r4, [sp]
 8587 4a68 FF00A0E3 		mov	r0, #255
 8588 4a6c 14608DE5 		str	r6, [sp, #20]
 8589 4a70 0520A0E1 		mov	r2, r5
 8590 4a74 24309DE5 		ldr	r3, [sp, #36]
 8591              	.LVL1020:
 8592 4a78 330200EA 		b	.L982
 8593              	.LVL1021:
 8594              	.L997:
 8595 4a7c 0060A0E1 		mov	r6, r0
 8596              	.LBE253:
 8597              	.LBE252:
 8598              	.LBE336:
 8599              	.LBE441:
5555:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8600              		.loc 1 5555 0
 8601 4a80 18159FE5 		ldr	r1, .L1034+80
 8602 4a84 0500A0E1 		mov	r0, r5
 8603              	.LVL1022:
 8604 4a88 0620A0E1 		mov	r2, r6
 8605 4a8c FEFFFFEB 		bl	CyU3PDebugPrint
 8606              	.LVL1023:
5556:../uvc.c      **** 					}
 8607              		.loc 1 5556 0
 8608 4a90 0600A0E1 		mov	r0, r6
 8609 4a94 FEFFFFEB 		bl	CyFxAppErrorHandler
 8610              	.LVL1024:
 8611              	.L1003:
 8612              	.LBB442:
 8613              	.LBB368:
 8614              	.LBB356:
 8615              	.LBB348:
1325:../uvc.c      **** 		 {
 8616              		.loc 1 1325 0
 8617 4a98 810056E3 		cmp	r6, #129
 8618 4a9c 7103000A 		beq	.L666
 8619 4aa0 4002008A 		bhi	.L667
 8620 4aa4 010056E3 		cmp	r6, #1
 8621 4aa8 4903001A 		bne	.L663
2515:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8622              		.loc 1 2515 0
 8623 4aac 2000A0E3 		mov	r0, #32
 8624 4ab0 10159FE5 		ldr	r1, .L1034+120
 8625 4ab4 42208DE2 		add	r2, sp, #66
 8626 4ab8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8627              	.LVL1025:
2517:../uvc.c      **** 			   {
 8628              		.loc 1 2517 0
 8629 4abc 000050E3 		cmp	r0, #0
 8630 4ac0 34008DE5 		str	r0, [sp, #52]
 8631 4ac4 EC05001A 		bne	.L682
2519:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8632              		.loc 1 2519 0
 8633 4ac8 020055E3 		cmp	r5, #2
 8634 4acc C405000A 		beq	.L1015
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8635              		.loc 1 2527 0
 8636 4ad0 28C09DE5 		ldr	ip, [sp, #40]
 8637 4ad4 08508DE5 		str	r5, [sp, #8]
 8638 4ad8 00408DE5 		str	r4, [sp]
 8639 4adc 04C08DE5 		str	ip, [sp, #4]
2524:../uvc.c      **** 				 }
 8640              		.loc 1 2524 0
 8641 4ae0 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8642              		.loc 1 2527 0
 8643 4ae4 0400A0E3 		mov	r0, #4
 8644              	.LVL1026:
 8645 4ae8 C8149FE5 		ldr	r1, .L1034+104
 8646 4aec 0E20A0E3 		mov	r2, #14
 8647 4af0 2C309DE5 		ldr	r3, [sp, #44]
 8648 4af4 38508DE5 		str	r5, [sp, #56]
2524:../uvc.c      **** 				 }
 8649              		.loc 1 2524 0
 8650 4af8 24C08DE5 		str	ip, [sp, #36]
2523:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8651              		.loc 1 2523 0
 8652 4afc 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 8653              	.LVL1027:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8654              		.loc 1 2527 0
 8655 4b00 FEFFFFEB 		bl	CyU3PDebugPrint
 8656              	.LVL1028:
2897:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 8657              		.loc 1 2897 0
 8658 4b04 38C09DE5 		ldr	ip, [sp, #56]
 8659 4b08 04005CE3 		cmp	ip, #4
 8660 4b0c 4105000A 		beq	.L1016
 8661              	.LVL1029:
 8662              	.L687:
2914:../uvc.c      **** 			 	 			 break;
 8663              		.loc 1 2914 0
 8664 4b10 2A27D9E5 		ldrb	r2, [r9, #1834]	@ zero_extendqisi2
2913:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8665              		.loc 1 2913 0
 8666 4b14 38C09DE5 		ldr	ip, [sp, #56]
2914:../uvc.c      **** 			 	 			 break;
 8667              		.loc 1 2914 0
 8668 4b18 2937D9E5 		ldrb	r3, [r9, #1833]	@ zero_extendqisi2
2913:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8669              		.loc 1 2913 0
 8670 4b1c 0400A0E3 		mov	r0, #4
 8671 4b20 0C108DE8 		stmia	sp, {r2, r3, ip}
 8672 4b24 90149FE5 		ldr	r1, .L1034+108
 8673 4b28 0520A0E1 		mov	r2, r5
 8674 4b2c 24309DE5 		ldr	r3, [sp, #36]
 8675 4b30 FEFFFFEB 		bl	CyU3PDebugPrint
 8676              	.LVL1030:
 8677 4b34 24209DE5 		ldr	r2, [sp, #36]
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8678              		.loc 1 1313 0
 8679 4b38 FF40A0E3 		mov	r4, #255
 8680 4b3c 04C0A0E1 		mov	ip, r4
 8681              	.LVL1031:
 8682              	.L673:
2930:../uvc.c      **** }
 8683              		.loc 1 2930 0
 8684 4b40 04108DE8 		stmia	sp, {r2, ip}
 8685 4b44 60149FE5 		ldr	r1, .L1034+92
 8686 4b48 0530A0E1 		mov	r3, r5
 8687 4b4c 08408DE5 		str	r4, [sp, #8]
 8688 4b50 0620A0E1 		mov	r2, r6
 8689 4b54 0400A0E3 		mov	r0, #4
 8690 4b58 FEFFFFEB 		bl	CyU3PDebugPrint
 8691              	.LVL1032:
 8692 4b5c 44309DE5 		ldr	r3, [sp, #68]
 8693 4b60 47FDFFEA 		b	.L642
 8694              	.LVL1033:
 8695              	.L1006:
 8696              	.LBE348:
 8697              	.LBE356:
 8698              	.LBE368:
 8699              	.LBE442:
 8700              	.LBB443:
 8701              	.LBB337:
 8702              	.LBB262:
 8703              	.LBB180:
2956:../uvc.c      **** 		 {
 8704              		.loc 1 2956 0
 8705 4b64 810055E3 		cmp	r5, #129
 8706 4b68 BE03000A 		beq	.L719
 8707 4b6c 1B02008A 		bhi	.L720
 8708 4b70 010055E3 		cmp	r5, #1
 8709 4b74 1404001A 		bne	.L716
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8710              		.loc 1 3027 0
 8711 4b78 48149FE5 		ldr	r1, .L1034+120
 8712 4b7c 42208DE2 		add	r2, sp, #66
 8713 4b80 2000A0E3 		mov	r0, #32
 8714 4b84 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8715              	.LVL1034:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8716              		.loc 1 3157 0
 8717 4b88 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8718 4b8c C0E39FE5 		ldr	lr, .L1034+4
3158:../uvc.c      **** 			  		 break;
 8719              		.loc 1 3158 0
 8720 4b90 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8721 4b94 0400A0E3 		mov	r0, #4
 8722 4b98 D8139FE5 		ldr	r1, .L1034+40
 8723 4b9c 0220A0E3 		mov	r2, #2
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8724              		.loc 1 3157 0
 8725 4ba0 D9C5CEE5 		strb	ip, [lr, #1497]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8726              		.loc 1 2950 0
 8727 4ba4 FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 8728              		.loc 1 3158 0
 8729 4ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 8730              	.LVL1035:
 8731 4bac 400100EA 		b	.L809
 8732              	.LVL1036:
 8733              	.L1008:
 8734              	.LBE180:
 8735              	.LBE262:
 8736              	.LBB263:
 8737              	.LBB197:
2956:../uvc.c      **** 		 {
 8738              		.loc 1 2956 0
 8739 4bb0 810055E3 		cmp	r5, #129
 8740 4bb4 C103000A 		beq	.L708
 8741 4bb8 1602008A 		bhi	.L709
 8742 4bbc 010055E3 		cmp	r5, #1
 8743 4bc0 FEFEFF1A 		bne	.L705
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8744              		.loc 1 3027 0
 8745 4bc4 FC139FE5 		ldr	r1, .L1034+120
 8746 4bc8 42208DE2 		add	r2, sp, #66
 8747 4bcc 2000A0E3 		mov	r0, #32
 8748 4bd0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8749              	.LVL1037:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8750              		.loc 1 3157 0
 8751 4bd4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 8752              		.loc 1 3158 0
 8753 4bd8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8754 4bdc 0400A0E3 		mov	r0, #4
 8755 4be0 90139FE5 		ldr	r1, .L1034+40
 8756 4be4 0020A0E3 		mov	r2, #0
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8757              		.loc 1 3157 0
 8758 4be8 A9C5C9E5 		strb	ip, [r9, #1449]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8759              		.loc 1 2950 0
 8760 4bec FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 8761              		.loc 1 3158 0
 8762 4bf0 FEFFFFEB 		bl	CyU3PDebugPrint
 8763              	.LVL1038:
 8764 4bf4 2E0100EA 		b	.L809
 8765              	.LVL1039:
 8766              	.L1009:
 8767              	.LBE197:
 8768              	.LBE263:
 8769              	.LBB264:
 8770              	.LBB205:
2956:../uvc.c      **** 		 {
 8771              		.loc 1 2956 0
 8772 4bf8 810055E3 		cmp	r5, #129
 8773 4bfc 9D03000A 		beq	.L730
 8774 4c00 FD01008A 		bhi	.L731
 8775 4c04 010055E3 		cmp	r5, #1
 8776 4c08 7803001A 		bne	.L727
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8777              		.loc 1 3027 0
 8778 4c0c 42208DE2 		add	r2, sp, #66
 8779 4c10 2000A0E3 		mov	r0, #32
 8780 4c14 AC139FE5 		ldr	r1, .L1034+120
 8781 4c18 1C308DE5 		str	r3, [sp, #28]
 8782 4c1c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8783              	.LVL1040:
3085:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8784              		.loc 1 3085 0
 8785 4c20 C125D9E5 		ldrb	r2, [r9, #1473]	@ zero_extendqisi2
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 8786              		.loc 1 3029 0
 8787 4c24 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3030:../uvc.c      **** 			  value = Data1;
 8788              		.loc 1 3030 0
 8789 4c28 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
3085:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8790              		.loc 1 3085 0
 8791 4c2c 010052E3 		cmp	r2, #1
 8792 4c30 04005213 		cmpne	r2, #4
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 8793              		.loc 1 3029 0
 8794 4c34 30C08DE5 		str	ip, [sp, #48]
 8795              	.LVL1041:
3030:../uvc.c      **** 			  value = Data1;
 8796              		.loc 1 3030 0
 8797 4c38 28408DE5 		str	r4, [sp, #40]
 8798              	.LVL1042:
3085:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8799              		.loc 1 3085 0
 8800 4c3c 1C309DE5 		ldr	r3, [sp, #28]
 8801 4c40 6C02001A 		bne	.L738
3084:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 8802              		.loc 1 3084 0
 8803 4c44 04E48CE1 		orr	lr, ip, r4, asl #8
3086:../uvc.c      **** 					  {
 8804              		.loc 1 3086 0
 8805 4c48 F9005EE3 		cmp	lr, #249
 8806 4c4c 6902008A 		bhi	.L738
 8807 4c50 24C39FE5 		ldr	ip, .L1034+44
 8808 4c54 0020A0E3 		mov	r2, #0
 8809 4c58 0100A0E3 		mov	r0, #1
 8810 4c5c 38308DE5 		str	r3, [sp, #56]
 8811              	.LVL1043:
 8812              	.L740:
3090:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 8813              		.loc 1 3090 0
 8814 4c60 18139FE5 		ldr	r1, .L1034+48
 8815 4c64 8230A0E1 		mov	r3, r2, asl #1
 8816 4c68 B33091E1 		ldrh	r3, [r1, r3]
 8817 4c6c FF4002E2 		and	r4, r2, #255
 8818 4c70 03005EE1 		cmp	lr, r3
3093:../uvc.c      **** 							}
 8819              		.loc 1 3093 0
 8820 4c74 03106EE0 		rsb	r1, lr, r3
 8821 4c78 2C408DE5 		str	r4, [sp, #44]
3091:../uvc.c      **** 							}else{
 8822              		.loc 1 3091 0
 8823 4c7c 0E4063E0 		rsb	r4, r3, lr
 8824 4c80 0438A081 		movhi	r3, r4, asl #16
 8825 4c84 0138A091 		movls	r3, r1, asl #16
 8826 4c88 2C409DE5 		ldr	r4, [sp, #44]
 8827 4c8c 2338A0E1 		mov	r3, r3, lsr #16
 8828 4c90 0C0053E1 		cmp	r3, ip
 8829 4c94 012082E2 		add	r2, r2, #1
 8830 4c98 0400A031 		movcc	r0, r4
 8831              	.LVL1044:
 8832 4c9c 0C0053E1 		cmp	r3, ip
 8833 4ca0 03C0A031 		movcc	ip, r3
 8834              	.LVL1045:
3088:../uvc.c      **** 						  {
 8835              		.loc 1 3088 0
 8836 4ca4 080052E3 		cmp	r2, #8
 8837 4ca8 ECFFFF1A 		bne	.L740
3103:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8838              		.loc 1 3103 0
 8839 4cac D0429FE5 		ldr	r4, .L1034+52
 8840 4cb0 38309DE5 		ldr	r3, [sp, #56]
3100:../uvc.c      **** 
 8841              		.loc 1 3100 0
 8842 4cb4 012080E2 		add	r2, r0, #1
 8843 4cb8 FF2002E2 		and	r2, r2, #255
3103:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8844              		.loc 1 3103 0
 8845 4cbc 1C0094E5 		ldr	r0, [r4, #28]
 8846              	.LVL1046:
 8847 4cc0 0010E0E3 		mvn	r1, #0
3100:../uvc.c      **** 
 8848              		.loc 1 3100 0
 8849 4cc4 2C208DE5 		str	r2, [sp, #44]
 8850              	.LVL1047:
3103:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8851              		.loc 1 3103 0
 8852 4cc8 1C308DE5 		str	r3, [sp, #28]
 8853 4ccc FEFFFFEB 		bl	_txe_mutex_get
 8854              	.LVL1048:
3104:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8855              		.loc 1 3104 0
 8856 4cd0 2CC09DE5 		ldr	ip, [sp, #44]
 8857 4cd4 0010A0E3 		mov	r1, #0
 8858 4cd8 00C08DE5 		str	ip, [sp]
 8859 4cdc 1C309DE5 		ldr	r3, [sp, #28]
 8860 4ce0 24209DE5 		ldr	r2, [sp, #36]
 8861 4ce4 0400A0E1 		mov	r0, r4
 8862 4ce8 04108DE5 		str	r1, [sp, #4]
 8863 4cec 0310A0E3 		mov	r1, #3
 8864 4cf0 FEFFFFEB 		bl	cmdSet
 8865              	.LVL1049:
3105:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 8866              		.loc 1 3105 0
 8867 4cf4 1C0094E5 		ldr	r0, [r4, #28]
 8868 4cf8 FEFFFFEB 		bl	_txe_mutex_put
 8869              	.LVL1050:
3111:../uvc.c      **** 					  }else{
 8870              		.loc 1 3111 0
 8871 4cfc 2C409DE5 		ldr	r4, [sp, #44]
3108:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 8872              		.loc 1 3108 0
 8873 4d00 30C09DE5 		ldr	ip, [sp, #48]
3111:../uvc.c      **** 					  }else{
 8874              		.loc 1 3111 0
 8875 4d04 7943C9E5 		strb	r4, [r9, #889]
3109:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 8876              		.loc 1 3109 0
 8877 4d08 28409DE5 		ldr	r4, [sp, #40]
3110:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 8878              		.loc 1 3110 0
 8879 4d0c 0130A0E3 		mov	r3, #1
3108:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 8880              		.loc 1 3108 0
 8881 4d10 F1C5C9E5 		strb	ip, [r9, #1521]
3109:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 8882              		.loc 1 3109 0
 8883 4d14 F245C9E5 		strb	r4, [r9, #1522]
3110:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 8884              		.loc 1 3110 0
 8885 4d18 F435C9E5 		strb	r3, [r9, #1524]
 8886 4d1c 630000EA 		b	.L787
 8887              	.LVL1051:
 8888              	.L1002:
 8889              	.LBE205:
 8890              	.LBE264:
 8891              	.LBB265:
 8892              	.LBB172:
2956:../uvc.c      **** 		 {
 8893              		.loc 1 2956 0
 8894 4d20 810055E3 		cmp	r5, #129
 8895 4d24 6103000A 		beq	.L745
 8896 4d28 B701008A 		bhi	.L746
 8897 4d2c 010055E3 		cmp	r5, #1
 8898 4d30 DAFDFF1A 		bne	.L742
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8899              		.loc 1 3027 0
 8900 4d34 8C129FE5 		ldr	r1, .L1034+120
 8901 4d38 42208DE2 		add	r2, sp, #66
 8902 4d3c 2000A0E3 		mov	r0, #32
 8903 4d40 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8904              	.LVL1052:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8905              		.loc 1 3157 0
 8906 4d44 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 8907              		.loc 1 3158 0
 8908 4d48 0400A0E3 		mov	r0, #4
 8909 4d4c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8910 4d50 0020A0E1 		mov	r2, r0
 8911 4d54 1C129FE5 		ldr	r1, .L1034+40
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8912              		.loc 1 3157 0
 8913 4d58 09C6C9E5 		strb	ip, [r9, #1545]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8914              		.loc 1 2950 0
 8915 4d5c FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 8916              		.loc 1 3158 0
 8917 4d60 FEFFFFEB 		bl	CyU3PDebugPrint
 8918              	.LVL1053:
 8919 4d64 D20000EA 		b	.L809
 8920              	.LVL1054:
 8921              	.L1012:
 8922              	.LBE172:
 8923              	.LBE265:
 8924              	.LBB266:
 8925              	.LBB236:
2956:../uvc.c      **** 		 {
 8926              		.loc 1 2956 0
 8927 4d68 810055E3 		cmp	r5, #129
 8928 4d6c E002000A 		beq	.L802
 8929 4d70 CC01008A 		bhi	.L803
 8930 4d74 010055E3 		cmp	r5, #1
 8931 4d78 F5FEFF1A 		bne	.L799
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8932              		.loc 1 3027 0
 8933 4d7c 44129FE5 		ldr	r1, .L1034+120
 8934 4d80 42208DE2 		add	r2, sp, #66
 8935 4d84 2000A0E3 		mov	r0, #32
 8936 4d88 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8937              	.LVL1055:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8938              		.loc 1 3157 0
 8939 4d8c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 8940              		.loc 1 3158 0
 8941 4d90 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8942 4d94 0400A0E3 		mov	r0, #4
 8943 4d98 D8119FE5 		ldr	r1, .L1034+40
 8944 4d9c 0920A0E3 		mov	r2, #9
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8945              		.loc 1 3157 0
 8946 4da0 81C6C9E5 		strb	ip, [r9, #1665]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8947              		.loc 1 2950 0
 8948 4da4 FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 8949              		.loc 1 3158 0
 8950 4da8 FEFFFFEB 		bl	CyU3PDebugPrint
 8951              	.LVL1056:
 8952 4dac C00000EA 		b	.L809
 8953              	.LVL1057:
 8954              	.L1011:
 8955              	.LBE236:
 8956              	.LBE266:
 8957              	.LBB267:
 8958              	.LBB227:
2956:../uvc.c      **** 		 {
 8959              		.loc 1 2956 0
 8960 4db0 810055E3 		cmp	r5, #129
 8961 4db4 4903000A 		beq	.L756
 8962 4db8 BE01008A 		bhi	.L757
 8963 4dbc 010055E3 		cmp	r5, #1
 8964 4dc0 5203001A 		bne	.L753
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8965              		.loc 1 3027 0
 8966 4dc4 FC119FE5 		ldr	r1, .L1034+120
 8967 4dc8 42208DE2 		add	r2, sp, #66
 8968 4dcc 2000A0E3 		mov	r0, #32
 8969 4dd0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8970              	.LVL1058:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8971              		.loc 1 3157 0
 8972 4dd4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 8973              		.loc 1 3158 0
 8974 4dd8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8975              		.loc 1 3157 0
 8976 4ddc 70419FE5 		ldr	r4, .L1034+4
3158:../uvc.c      **** 			  		 break;
 8977              		.loc 1 3158 0
 8978 4de0 0400A0E3 		mov	r0, #4
 8979 4de4 8C119FE5 		ldr	r1, .L1034+40
 8980 4de8 0520A0E3 		mov	r2, #5
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8981              		.loc 1 3157 0
 8982 4dec 21C6C4E5 		strb	ip, [r4, #1569]
3158:../uvc.c      **** 			  		 break;
 8983              		.loc 1 3158 0
 8984 4df0 FEFFFFEB 		bl	CyU3PDebugPrint
 8985              	.LVL1059:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8986              		.loc 1 2950 0
 8987 4df4 FF40A0E3 		mov	r4, #255
 8988 4df8 AD0000EA 		b	.L809
 8989              	.LVL1060:
 8990              	.L1010:
 8991              	.LBE227:
 8992              	.LBE267:
 8993              	.LBB268:
 8994              	.LBB215:
2956:../uvc.c      **** 		 {
 8995              		.loc 1 2956 0
 8996 4dfc 810055E3 		cmp	r5, #129
 8997 4e00 3A03000A 		beq	.L778
 8998 4e04 A301008A 		bhi	.L779
 8999 4e08 010055E3 		cmp	r5, #1
 9000 4e0c EA02001A 		bne	.L775
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9001              		.loc 1 3027 0
 9002 4e10 2000A0E3 		mov	r0, #32
 9003 4e14 AC119FE5 		ldr	r1, .L1034+120
 9004 4e18 42208DE2 		add	r2, sp, #66
 9005 4e1c 1C308DE5 		str	r3, [sp, #28]
 9006 4e20 20C08DE5 		str	ip, [sp, #32]
 9007 4e24 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9008              	.LVL1061:
3119:../uvc.c      **** 					  {
 9009              		.loc 1 3119 0
 9010 4e28 24E19FE5 		ldr	lr, .L1034+4
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9011              		.loc 1 3029 0
 9012 4e2c 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
3119:../uvc.c      **** 					  {
 9013              		.loc 1 3119 0
 9014 4e30 C105DEE5 		ldrb	r0, [lr, #1473]	@ zero_extendqisi2
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9015              		.loc 1 3029 0
 9016 4e34 24408DE5 		str	r4, [sp, #36]
 9017              	.LVL1062:
3030:../uvc.c      **** 			  value = Data1;
 9018              		.loc 1 3030 0
 9019 4e38 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
3119:../uvc.c      **** 					  {
 9020              		.loc 1 3119 0
 9021 4e3c 010050E3 		cmp	r0, #1
 9022 4e40 08005013 		cmpne	r0, #8
 9023 4e44 0000A013 		movne	r0, #0
 9024 4e48 0100A003 		moveq	r0, #1
3030:../uvc.c      **** 			  value = Data1;
 9025              		.loc 1 3030 0
 9026 4e4c 30408DE5 		str	r4, [sp, #48]
 9027              	.LVL1063:
3119:../uvc.c      **** 					  {
 9028              		.loc 1 3119 0
 9029 4e50 A603001A 		bne	.L786
 9030              	.LVL1064:
3122:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9031              		.loc 1 3122 0
 9032 4e54 28419FE5 		ldr	r4, .L1034+52
 9033 4e58 0010E0E3 		mvn	r1, #0
 9034 4e5c 1C0094E5 		ldr	r0, [r4, #28]
 9035 4e60 FEFFFFEB 		bl	_txe_mutex_get
 9036              	.LVL1065:
3123:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9037              		.loc 1 3123 0
 9038 4e64 20C09DE5 		ldr	ip, [sp, #32]
 9039 4e68 24E09DE5 		ldr	lr, [sp, #36]
 9040 4e6c 1C309DE5 		ldr	r3, [sp, #28]
 9041 4e70 0010A0E3 		mov	r1, #0
 9042 4e74 0320A0E1 		mov	r2, r3
 9043 4e78 00E08DE5 		str	lr, [sp]
 9044 4e7c 0C30A0E1 		mov	r3, ip
 9045 4e80 0400A0E1 		mov	r0, r4
 9046 4e84 04108DE5 		str	r1, [sp, #4]
 9047 4e88 2210A0E3 		mov	r1, #34
 9048 4e8c FEFFFFEB 		bl	cmdSet
 9049              	.LVL1066:
3124:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9050              		.loc 1 3124 0
 9051 4e90 1C0094E5 		ldr	r0, [r4, #28]
 9052 4e94 FEFFFFEB 		bl	_txe_mutex_put
 9053              	.LVL1067:
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9054              		.loc 1 3127 0
 9055 4e98 B4C09FE5 		ldr	ip, .L1034+4
 9056 4e9c 24409DE5 		ldr	r4, [sp, #36]
3129:../uvc.c      **** 					  }else{
 9057              		.loc 1 3129 0
 9058 4ea0 5456CCE5 		strb	r5, [ip, #1620]
3127:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9059              		.loc 1 3127 0
 9060 4ea4 5146CCE5 		strb	r4, [ip, #1617]
3128:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9061              		.loc 1 3128 0
 9062 4ea8 30409DE5 		ldr	r4, [sp, #48]
 9063 4eac 5246CCE5 		strb	r4, [ip, #1618]
 9064              	.LVL1068:
 9065              	.L787:
3133:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9066              		.loc 1 3133 0
 9067 4eb0 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9068              	.LVL1069:
3134:../uvc.c      **** 
 9069              		.loc 1 3134 0
 9070 4eb4 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 9071              	.LVL1070:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9072              		.loc 1 2950 0
 9073 4eb8 FF40A0E3 		mov	r4, #255
 9074 4ebc 1C0100EA 		b	.L785
 9075              	.LVL1071:
 9076              	.L1007:
 9077              	.LBE215:
 9078              	.LBE268:
 9079              	.LBB269:
 9080              	.LBB189:
2956:../uvc.c      **** 		 {
 9081              		.loc 1 2956 0
 9082 4ec0 810055E3 		cmp	r5, #129
 9083 4ec4 0103000A 		beq	.L767
 9084 4ec8 6E01008A 		bhi	.L768
 9085 4ecc 010055E3 		cmp	r5, #1
 9086 4ed0 20FEFF1A 		bne	.L764
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9087              		.loc 1 3027 0
 9088 4ed4 EC109FE5 		ldr	r1, .L1034+120
 9089 4ed8 42208DE2 		add	r2, sp, #66
 9090 4edc 2000A0E3 		mov	r0, #32
 9091 4ee0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9092              	.LVL1072:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9093              		.loc 1 3157 0
 9094 4ee4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 9095              		.loc 1 3158 0
 9096 4ee8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9097 4eec 0400A0E3 		mov	r0, #4
 9098 4ef0 80109FE5 		ldr	r1, .L1034+40
 9099 4ef4 0620A0E3 		mov	r2, #6
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9100              		.loc 1 3157 0
 9101 4ef8 39C6C9E5 		strb	ip, [r9, #1593]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9102              		.loc 1 2950 0
 9103 4efc FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 9104              		.loc 1 3158 0
 9105 4f00 FEFFFFEB 		bl	CyU3PDebugPrint
 9106              	.LVL1073:
 9107 4f04 6A0000EA 		b	.L809
 9108              	.LVL1074:
 9109              	.L1013:
 9110              	.LBE189:
 9111              	.LBE269:
 9112              	.LBB270:
 9113              	.LBB246:
2956:../uvc.c      **** 		 {
 9114              		.loc 1 2956 0
 9115 4f08 810055E3 		cmp	r5, #129
 9116 4f0c C402000A 		beq	.L791
 9117 4f10 6C01008A 		bhi	.L792
 9118 4f14 010055E3 		cmp	r5, #1
 9119 4f18 A7FEFF1A 		bne	.L788
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9120              		.loc 1 3027 0
 9121 4f1c A4109FE5 		ldr	r1, .L1034+120
 9122 4f20 42208DE2 		add	r2, sp, #66
 9123 4f24 2000A0E3 		mov	r0, #32
 9124 4f28 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9125              	.LVL1075:
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9126              		.loc 1 3157 0
 9127 4f2c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3158:../uvc.c      **** 			  		 break;
 9128              		.loc 1 3158 0
 9129 4f30 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9130 4f34 0400A0E3 		mov	r0, #4
 9131 4f38 38109FE5 		ldr	r1, .L1034+40
 9132 4f3c 0820A0E3 		mov	r2, #8
3157:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9133              		.loc 1 3157 0
 9134 4f40 69C6C9E5 		strb	ip, [r9, #1641]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9135              		.loc 1 2950 0
 9136 4f44 FF40A0E3 		mov	r4, #255
3158:../uvc.c      **** 			  		 break;
 9137              		.loc 1 3158 0
 9138 4f48 FEFFFFEB 		bl	CyU3PDebugPrint
 9139              	.LVL1076:
 9140 4f4c 580000EA 		b	.L809
 9141              	.L1035:
 9142              		.align	2
 9143              	.L1034:
 9144 4f50 00000000 		.word	.LANCHOR0
 9145 4f54 00000000 		.word	.LANCHOR1
 9146 4f58 00000000 		.word	glInterStaBuffer
 9147 4f5c 00000000 		.word	wIndex
 9148 4f60 5C0C0000 		.word	.LC69
 9149 4f64 00000000 		.word	bmReqType
 9150 4f68 00000000 		.word	wLength
 9151 4f6c E00B0000 		.word	.LC68
 9152 4f70 00000000 		.word	glChHandleInterStat
 9153 4f74 100D0000 		.word	.LC74
 9154 4f78 54060000 		.word	.LC36
 9155 4f7c FFFF0000 		.word	65535
 9156 4f80 98010000 		.word	.LANCHOR2+408
 9157 4f84 00000000 		.word	cmdQu
 9158 4f88 2C060000 		.word	.LC35
 9159 4f8c 880C0000 		.word	.LC70
 9160 4f90 600D0000 		.word	.LC76
 9161 4f94 380D0000 		.word	.LC75
 9162 4f98 00000000 		.word	bRequest
 9163 4f9c A80C0000 		.word	.LC71
 9164 4fa0 800D0000 		.word	.LC77
 9165 4fa4 9C060000 		.word	.LC38
 9166 4fa8 C80C0000 		.word	.LC72
 9167 4fac DC050000 		.word	.LC34
 9168 4fb0 00000000 		.word	wValue
 9169 4fb4 EC0C0000 		.word	.LC73
 9170 4fb8 68040000 		.word	.LC27
 9171 4fbc 14050000 		.word	.LC30
 9172 4fc0 78060000 		.word	.LC37
 9173 4fc4 00000000 		.word	.LANCHOR1
 9174 4fc8 28000000 		.word	.LANCHOR0+40
 9175 4fcc 38040000 		.word	.LC26
 9176 4fd0 AC050000 		.word	.LC33
 9177              	.LVL1077:
 9178              	.L1014:
 9179              	.LBE246:
 9180              	.LBE270:
 9181              	.LBB271:
 9182              	.LBB254:
2956:../uvc.c      **** 		 {
 9183              		.loc 1 2956 0
 9184 4fd4 810055E3 		cmp	r5, #129
 9185 4fd8 3502000A 		beq	.L813
 9186 4fdc 0301008A 		bhi	.L814
 9187 4fe0 010055E3 		cmp	r5, #1
 9188 4fe4 5202001A 		bne	.L810
3142:../uvc.c      **** 					  if(getData == 1)
 9189              		.loc 1 3142 0
 9190 4fe8 6C401FE5 		ldr	r4, .L1034+52
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9191              		.loc 1 3027 0
 9192 4fec 2C101FE5 		ldr	r1, .L1034+120
 9193 4ff0 42208DE2 		add	r2, sp, #66
 9194 4ff4 2000A0E3 		mov	r0, #32
 9195 4ff8 1C308DE5 		str	r3, [sp, #28]
 9196 4ffc 20C08DE5 		str	ip, [sp, #32]
3142:../uvc.c      **** 					  if(getData == 1)
 9197              		.loc 1 3142 0
 9198 5000 30408DE5 		str	r4, [sp, #48]
3027:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9199              		.loc 1 3027 0
 9200 5004 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9201              	.LVL1078:
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9202              		.loc 1 3029 0
 9203 5008 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
3142:../uvc.c      **** 					  if(getData == 1)
 9204              		.loc 1 3142 0
 9205 500c 0010E0E3 		mvn	r1, #0
3029:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9206              		.loc 1 3029 0
 9207 5010 24408DE5 		str	r4, [sp, #36]
 9208              	.LVL1079:
3142:../uvc.c      **** 					  if(getData == 1)
 9209              		.loc 1 3142 0
 9210 5014 30409DE5 		ldr	r4, [sp, #48]
 9211 5018 1C0094E5 		ldr	r0, [r4, #28]
3030:../uvc.c      **** 			  value = Data1;
 9212              		.loc 1 3030 0
 9213 501c 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 9214              	.LVL1080:
3142:../uvc.c      **** 					  if(getData == 1)
 9215              		.loc 1 3142 0
 9216 5020 FEFFFFEB 		bl	_txe_mutex_get
 9217              	.LVL1081:
3143:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 9218              		.loc 1 3143 0
 9219 5024 24E09DE5 		ldr	lr, [sp, #36]
 9220 5028 1C309DE5 		ldr	r3, [sp, #28]
 9221 502c 01005EE3 		cmp	lr, #1
 9222 5030 20C09DE5 		ldr	ip, [sp, #32]
3144:../uvc.c      **** 					  else if(getData == 0xff)
 9223              		.loc 1 3144 0
 9224 5034 0410A003 		moveq	r1, #4
3143:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 9225              		.loc 1 3143 0
 9226 5038 ED03000A 		beq	.L973
3145:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 9227              		.loc 1 3145 0
 9228 503c 24109DE5 		ldr	r1, [sp, #36]
 9229 5040 FF0051E3 		cmp	r1, #255
 9230 5044 E903000A 		beq	.L1017
3148:../uvc.c      **** 					  //dataIdx++;
 9231              		.loc 1 3148 0
 9232 5048 0010A0E3 		mov	r1, #0
 9233 504c 0320A0E1 		mov	r2, r3
 9234 5050 00108DE5 		str	r1, [sp]
 9235 5054 04108DE5 		str	r1, [sp, #4]
 9236 5058 0C30A0E1 		mov	r3, ip
 9237 505c 30009DE5 		ldr	r0, [sp, #48]
 9238 5060 2310A0E3 		mov	r1, #35
 9239 5064 FEFFFFEB 		bl	cmdSet
 9240              	.LVL1082:
 9241              	.L822:
3151:../uvc.c      **** #endif
 9242              		.loc 1 3151 0
 9243 5068 30C09DE5 		ldr	ip, [sp, #48]
 9244 506c 1C009CE5 		ldr	r0, [ip, #28]
 9245 5070 FEFFFFEB 		bl	_txe_mutex_put
 9246              	.LVL1083:
3153:../uvc.c      **** 					  break;
 9247              		.loc 1 3153 0
 9248 5074 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 9249 5078 0400A0E3 		mov	r0, #4
 9250 507c 00308DE5 		str	r3, [sp]
 9251 5080 00111FE5 		ldr	r1, .L1034+56
 9252 5084 0430A0E1 		mov	r3, r4
 9253 5088 24209DE5 		ldr	r2, [sp, #36]
 9254 508c FEFFFFEB 		bl	CyU3PDebugPrint
 9255              	.LVL1084:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9256              		.loc 1 2950 0
 9257 5090 FF30A0E3 		mov	r3, #255
 9258 5094 70FEFFEA 		b	.L820
 9259              	.LVL1085:
 9260              	.L805:
 9261              	.LBE254:
 9262              	.LBE271:
 9263              	.LBB272:
 9264              	.LBB237:
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9265              		.loc 1 2961 0
 9266 5098 0030A0E3 		mov	r3, #0
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9267              		.loc 1 2962 0
 9268 509c 0200A0E3 		mov	r0, #2
 9269 50a0 E0101FE5 		ldr	r1, .L1034+120
2960:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9270              		.loc 1 2960 0
 9271 50a4 2860C7E5 		strb	r6, [r7, #40]
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9272              		.loc 1 2961 0
 9273 50a8 2930C7E5 		strb	r3, [r7, #41]
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9274              		.loc 1 2962 0
 9275 50ac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9276              	.LVL1086:
2963:../uvc.c      **** 			  break;
 9277              		.loc 1 2963 0
 9278 50b0 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9279              	.LVL1087:
 9280              	.L809:
3169:../uvc.c      **** }
 9281              		.loc 1 3169 0
 9282 50b4 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9283 50b8 FF30A0E3 		mov	r3, #255
 9284 50bc 04108DE5 		str	r1, [sp, #4]
 9285 50c0 10108DE5 		str	r1, [sp, #16]
 9286 50c4 00308DE5 		str	r3, [sp]
 9287 50c8 0C308DE5 		str	r3, [sp, #12]
 9288 50cc 08408DE5 		str	r4, [sp, #8]
 9289 50d0 14608DE5 		str	r6, [sp, #20]
 9290 50d4 0520A0E1 		mov	r2, r5
 9291 50d8 0400A0E3 		mov	r0, #4
 9292 50dc 40111FE5 		ldr	r1, .L1034+84
 9293 50e0 FEFFFFEB 		bl	CyU3PDebugPrint
 9294              	.LVL1088:
 9295 50e4 44309DE5 		ldr	r3, [sp, #68]
 9296 50e8 E5FBFFEA 		b	.L642
 9297              	.LVL1089:
 9298              	.L845:
 9299              	.LBE237:
 9300              	.LBE272:
 9301              	.LBE337:
 9302              	.LBE443:
 9303              	.LBB444:
 9304              	.LBB422:
4957:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
 9305              		.loc 1 4957 0
 9306 50ec 2700A0E3 		mov	r0, #39
 9307 50f0 FEFFFFEB 		bl	ControlHandle
 9308              	.LVL1090:
4958:../uvc.c      ****     		break;
 9309              		.loc 1 4958 0
 9310 50f4 64311FE5 		ldr	r3, .L1034+72
 9311 50f8 B020D4E1 		ldrh	r2, [r4]
 9312 50fc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9313 5100 0400A0E3 		mov	r0, #4
 9314 5104 80111FE5 		ldr	r1, .L1034+60
 9315 5108 FEFFFFEB 		bl	CyU3PDebugPrint
 9316              	.LVL1091:
 9317 510c 44309DE5 		ldr	r3, [sp, #68]
 9318 5110 DBFBFFEA 		b	.L642
 9319              	.L843:
 9320              	.LVL1092:
4923:../uvc.c      ****     		break;
 9321              		.loc 1 4923 0
 9322 5114 1B00A0E3 		mov	r0, #27
 9323 5118 FEFFFFEB 		bl	ControlHandle
 9324              	.LVL1093:
 9325 511c 44309DE5 		ldr	r3, [sp, #68]
 9326 5120 D7FBFFEA 		b	.L642
 9327              	.L858:
4987:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9328              		.loc 1 4987 0
 9329 5124 2E00A0E3 		mov	r0, #46
 9330 5128 FEFFFFEB 		bl	ControlHandle
 9331              	.LVL1094:
4988:../uvc.c      ****     		break;
 9332              		.loc 1 4988 0
 9333 512c 9C311FE5 		ldr	r3, .L1034+72
 9334 5130 B020D4E1 		ldrh	r2, [r4]
 9335 5134 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9336 5138 0400A0E3 		mov	r0, #4
 9337 513c B4111FE5 		ldr	r1, .L1034+64
 9338 5140 FEFFFFEB 		bl	CyU3PDebugPrint
 9339              	.LVL1095:
 9340 5144 44309DE5 		ldr	r3, [sp, #68]
 9341 5148 CDFBFFEA 		b	.L642
 9342              	.L857:
4982:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 9343              		.loc 1 4982 0
 9344 514c 2D00A0E3 		mov	r0, #45
 9345 5150 FEFFFFEB 		bl	ControlHandle
 9346              	.LVL1096:
4983:../uvc.c      ****     		break;
 9347              		.loc 1 4983 0
 9348 5154 C4311FE5 		ldr	r3, .L1034+72
 9349 5158 B020D4E1 		ldrh	r2, [r4]
 9350 515c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9351 5160 0400A0E3 		mov	r0, #4
 9352 5164 D8111FE5 		ldr	r1, .L1034+68
 9353 5168 FEFFFFEB 		bl	CyU3PDebugPrint
 9354              	.LVL1097:
 9355 516c 44309DE5 		ldr	r3, [sp, #68]
 9356 5170 C3FBFFEA 		b	.L642
 9357              	.L853:
 9358              	.LVL1098:
 9359              	.LBB390:
 9360              	.LBB391:
1317:../uvc.c      ****     /*
 9361              		.loc 1 1317 0
 9362 5174 E4411FE5 		ldr	r4, .L1034+72
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9363              		.loc 1 1299 0
 9364 5178 4427D9E5 		ldrb	r2, [r9, #1860]	@ zero_extendqisi2
1317:../uvc.c      ****     /*
 9365              		.loc 1 1317 0
 9366 517c 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
1300:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9367              		.loc 1 1300 0
 9368 5180 4557D9E5 		ldrb	r5, [r9, #1861]	@ zero_extendqisi2
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9369              		.loc 1 1301 0
 9370 5184 5337D9E5 		ldrb	r3, [r9, #1875]	@ zero_extendqisi2
1302:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9371              		.loc 1 1302 0
 9372 5188 4667D9E5 		ldrb	r6, [r9, #1862]	@ zero_extendqisi2
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9373              		.loc 1 1299 0
 9374 518c FF2002E2 		and	r2, r2, #255
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9375              		.loc 1 1301 0
 9376 5190 FF3003E2 		and	r3, r3, #255
1325:../uvc.c      **** 		 {
 9377              		.loc 1 1325 0
 9378 5194 83005CE3 		cmp	ip, #131
1317:../uvc.c      ****     /*
 9379              		.loc 1 1317 0
 9380 5198 28C08DE5 		str	ip, [sp, #40]
1299:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9381              		.loc 1 1299 0
 9382 519c 34208DE5 		str	r2, [sp, #52]
 9383              	.LVL1099:
1300:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9384              		.loc 1 1300 0
 9385 51a0 FF5005E2 		and	r5, r5, #255
 9386              	.LVL1100:
1301:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9387              		.loc 1 1301 0
 9388 51a4 2C308DE5 		str	r3, [sp, #44]
 9389              	.LVL1101:
1302:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9390              		.loc 1 1302 0
 9391 51a8 FF6006E2 		and	r6, r6, #255
 9392              	.LVL1102:
1325:../uvc.c      **** 		 {
 9393              		.loc 1 1325 0
 9394 51ac A102000A 		beq	.L888
 9395 51b0 2601009A 		bls	.L1018
 9396 51b4 28C09DE5 		ldr	ip, [sp, #40]
 9397 51b8 85005CE3 		cmp	ip, #133
 9398 51bc F300000A 		beq	.L893
 9399 51c0 EA02003A 		bcc	.L894
 9400 51c4 86005CE3 		cmp	ip, #134
 9401 51c8 DF02000A 		beq	.L895
 9402 51cc 87005CE3 		cmp	ip, #135
 9403 51d0 F102001A 		bne	.L887
1963:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9404              		.loc 1 1963 0
 9405 51d4 020056E3 		cmp	r6, #2
1964:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9406              		.loc 1 1964 0
 9407 51d8 4F27D905 		ldreqb	r2, [r9, #1871]	@ zero_extendqisi2
1965:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9408              		.loc 1 1965 0
 9409 51dc 5037D905 		ldreqb	r3, [r9, #1872]	@ zero_extendqisi2
1963:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9410              		.loc 1 1963 0
 9411 51e0 9B02000A 		beq	.L981
1969:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9412              		.loc 1 1969 0
 9413 51e4 4FC7D9E5 		ldrb	ip, [r9, #1871]	@ zero_extendqisi2
1971:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9414              		.loc 1 1971 0
 9415 51e8 5027D9E5 		ldrb	r2, [r9, #1872]	@ zero_extendqisi2
 9416              	.L979:
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9417              		.loc 1 1897 0
 9418 51ec 0030A0E3 		mov	r3, #0
1915:../uvc.c      **** 				  if(Len == 2){
 9419              		.loc 1 1915 0
 9420 51f0 0600A0E1 		mov	r0, r6
 9421 51f4 34121FE5 		ldr	r1, .L1034+120
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9422              		.loc 1 1896 0
 9423 51f8 28C0C7E5 		strb	ip, [r7, #40]
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9424              		.loc 1 1898 0
 9425 51fc 2A20C7E5 		strb	r2, [r7, #42]
1897:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9426              		.loc 1 1897 0
 9427 5200 2930C7E5 		strb	r3, [r7, #41]
1899:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 9428              		.loc 1 1899 0
 9429 5204 2B30C7E5 		strb	r3, [r7, #43]
1921:../uvc.c      **** 				  }
 9430              		.loc 1 1921 0
 9431 5208 24308DE5 		str	r3, [sp, #36]
 9432 520c 0060A0E3 		mov	r6, #0
 9433              	.LVL1103:
1915:../uvc.c      **** 				  if(Len == 2){
 9434              		.loc 1 1915 0
 9435 5210 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9436              	.LVL1104:
1920:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 9437              		.loc 1 1920 0
 9438 5214 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9439              	.LVL1105:
1921:../uvc.c      **** 				  }
 9440              		.loc 1 1921 0
 9441 5218 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 9442              	.LVL1106:
 9443 521c E50000EA 		b	.L897
 9444              	.LVL1107:
 9445              	.L842:
 9446              	.LBE391:
 9447              	.LBE390:
4919:../uvc.c      ****     		break;
 9448              		.loc 1 4919 0
 9449 5220 1A00A0E3 		mov	r0, #26
 9450 5224 FEFFFFEB 		bl	ControlHandle
 9451              	.LVL1108:
 9452 5228 44309DE5 		ldr	r3, [sp, #68]
 9453 522c 94FBFFEA 		b	.L642
 9454              	.L838:
 9455              	.LVL1109:
4908:../uvc.c      ****      		break;
 9456              		.loc 1 4908 0
 9457 5230 1800A0E3 		mov	r0, #24
 9458 5234 FEFFFFEB 		bl	ControlHandle
 9459              	.LVL1110:
 9460 5238 44309DE5 		ldr	r3, [sp, #68]
 9461 523c 90FBFFEA 		b	.L642
 9462              	.L830:
 9463              	.LVL1111:
4896:../uvc.c      ****      		break;
 9464              		.loc 1 4896 0
 9465 5240 1500A0E3 		mov	r0, #21
 9466 5244 FEFFFFEB 		bl	ControlHandle
 9467              	.LVL1112:
 9468 5248 44309DE5 		ldr	r3, [sp, #68]
 9469 524c 8CFBFFEA 		b	.L642
 9470              	.L828:
 9471              	.LVL1113:
4929:../uvc.c      ****     		break;
 9472              		.loc 1 4929 0
 9473 5250 1C00A0E3 		mov	r0, #28
 9474 5254 FEFFFFEB 		bl	ControlHandle
 9475              	.LVL1114:
 9476 5258 44309DE5 		ldr	r3, [sp, #68]
 9477 525c 88FBFFEA 		b	.L642
 9478              	.L834:
 9479              	.LVL1115:
4876:../uvc.c      ****     		break;
 9480              		.loc 1 4876 0
 9481 5260 1000A0E3 		mov	r0, #16
 9482 5264 FEFFFFEB 		bl	ControlHandle
 9483              	.LVL1116:
 9484 5268 44309DE5 		ldr	r3, [sp, #68]
 9485 526c 84FBFFEA 		b	.L642
 9486              	.L832:
 9487              	.LVL1117:
4884:../uvc.c      ****      		break;
 9488              		.loc 1 4884 0
 9489 5270 1200A0E3 		mov	r0, #18
 9490 5274 FEFFFFEB 		bl	ControlHandle
 9491              	.LVL1118:
 9492 5278 44309DE5 		ldr	r3, [sp, #68]
 9493 527c 80FBFFEA 		b	.L642
 9494              	.L847:
 9495              	.LVL1119:
4945:../uvc.c      ****     		break;
 9496              		.loc 1 4945 0
 9497 5280 2400A0E3 		mov	r0, #36
 9498 5284 FEFFFFEB 		bl	ControlHandle
 9499              	.LVL1120:
 9500 5288 44309DE5 		ldr	r3, [sp, #68]
 9501 528c 7CFBFFEA 		b	.L642
 9502              	.L840:
 9503              	.LVL1121:
4900:../uvc.c      ****     		break;
 9504              		.loc 1 4900 0
 9505 5290 1600A0E3 		mov	r0, #22
 9506 5294 FEFFFFEB 		bl	ControlHandle
 9507              	.LVL1122:
 9508 5298 44309DE5 		ldr	r3, [sp, #68]
 9509 529c 78FBFFEA 		b	.L642
 9510              	.L849:
 9511              	.LVL1123:
4937:../uvc.c      ****     		break;
 9512              		.loc 1 4937 0
 9513 52a0 1E00A0E3 		mov	r0, #30
 9514 52a4 FEFFFFEB 		bl	ControlHandle
 9515              	.LVL1124:
 9516 52a8 44309DE5 		ldr	r3, [sp, #68]
 9517 52ac 74FBFFEA 		b	.L642
 9518              	.L836:
 9519              	.LVL1125:
4888:../uvc.c      ****     		break;
 9520              		.loc 1 4888 0
 9521 52b0 1300A0E3 		mov	r0, #19
 9522 52b4 FEFFFFEB 		bl	ControlHandle
 9523              	.LVL1126:
 9524 52b8 44309DE5 		ldr	r3, [sp, #68]
 9525 52bc 70FBFFEA 		b	.L642
 9526              	.L851:
 9527              	.LVL1127:
4949:../uvc.c      ****     		break;
 9528              		.loc 1 4949 0
 9529 52c0 2500A0E3 		mov	r0, #37
 9530 52c4 FEFFFFEB 		bl	ControlHandle
 9531              	.LVL1128:
 9532 52c8 44309DE5 		ldr	r3, [sp, #68]
 9533 52cc 6CFBFFEA 		b	.L642
 9534              	.L855:
4962:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9535              		.loc 1 4962 0
 9536 52d0 2800A0E3 		mov	r0, #40
 9537 52d4 FEFFFFEB 		bl	ControlHandle
 9538              	.LVL1129:
4963:../uvc.c      ****     		break;
 9539              		.loc 1 4963 0
 9540 52d8 48331FE5 		ldr	r3, .L1034+72
 9541 52dc B020D4E1 		ldrh	r2, [r4]
 9542 52e0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9543 52e4 0400A0E3 		mov	r0, #4
 9544 52e8 54131FE5 		ldr	r1, .L1034+76
 9545 52ec FEFFFFEB 		bl	CyU3PDebugPrint
 9546              	.LVL1130:
 9547 52f0 44309DE5 		ldr	r3, [sp, #68]
 9548 52f4 62FBFFEA 		b	.L642
 9549              	.LVL1131:
 9550              	.L998:
 9551 52f8 0250A0E1 		mov	r5, r2
 9552              	.LBE422:
 9553              	.LBE444:
5528:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9554              		.loc 1 5528 0
 9555 52fc 0600A0E1 		mov	r0, r6
 9556              	.LVL1132:
 9557 5300 68131FE5 		ldr	r1, .L1034+80
 9558 5304 FEFFFFEB 		bl	CyU3PDebugPrint
 9559              	.LVL1133:
5529:../uvc.c      **** 					}
 9560              		.loc 1 5529 0
 9561 5308 0500A0E1 		mov	r0, r5
 9562 530c FEFFFFEB 		bl	CyFxAppErrorHandler
 9563              	.LVL1134:
 9564              	.L781:
 9565              	.LBB445:
 9566              	.LBB338:
 9567              	.LBB273:
 9568              	.LBB216:
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9569              		.loc 1 2961 0
 9570 5310 0030A0E3 		mov	r3, #0
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9571              		.loc 1 2962 0
 9572 5314 0200A0E3 		mov	r0, #2
 9573 5318 58131FE5 		ldr	r1, .L1034+120
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9574              		.loc 1 2961 0
 9575 531c 2930C7E5 		strb	r3, [r7, #41]
2960:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9576              		.loc 1 2960 0
 9577 5320 2860C7E5 		strb	r6, [r7, #40]
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9578              		.loc 1 2962 0
 9579 5324 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9580              	.LVL1135:
2963:../uvc.c      **** 			  break;
 9581              		.loc 1 2963 0
 9582 5328 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9583              	.LVL1136:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9584              		.loc 1 2950 0
 9585 532c FF20A0E3 		mov	r2, #255
 9586 5330 0230A0E1 		mov	r3, r2
 9587              	.LVL1137:
 9588              	.L785:
3169:../uvc.c      **** }
 9589              		.loc 1 3169 0
 9590 5334 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9591 5338 00208DE5 		str	r2, [sp]
 9592 533c FF00A0E3 		mov	r0, #255
 9593 5340 0520A0E1 		mov	r2, r5
 9594              	.LVL1138:
 9595 5344 08408DE5 		str	r4, [sp, #8]
 9596 5348 14608DE5 		str	r6, [sp, #20]
 9597              	.LVL1139:
 9598              	.L982:
 9599              	.LBE216:
 9600              	.LBE273:
 9601              	.LBB274:
 9602              	.LBB255:
 9603 534c 04108DE5 		str	r1, [sp, #4]
 9604 5350 10108DE5 		str	r1, [sp, #16]
 9605 5354 0C008DE5 		str	r0, [sp, #12]
 9606 5358 BC131FE5 		ldr	r1, .L1034+84
 9607 535c 0400A0E3 		mov	r0, #4
 9608 5360 FEFFFFEB 		bl	CyU3PDebugPrint
 9609              	.LVL1140:
 9610 5364 44309DE5 		ldr	r3, [sp, #68]
 9611 5368 45FBFFEA 		b	.L642
 9612              	.LVL1141:
 9613              	.L671:
 9614              	.LBE255:
 9615              	.LBE274:
 9616              	.LBE338:
 9617              	.LBE445:
 9618              	.LBB446:
 9619              	.LBB369:
 9620              	.LBB357:
 9621              	.LBB349:
1950:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9622              		.loc 1 1950 0
 9623 536c 2527D9E5 		ldrb	r2, [r9, #1829]	@ zero_extendqisi2
1956:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9624              		.loc 1 1956 0
 9625 5370 B0131FE5 		ldr	r1, .L1034+120
1951:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9626              		.loc 1 1951 0
 9627 5374 0030A0E3 		mov	r3, #0
1956:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9628              		.loc 1 1956 0
 9629 5378 0100A0E3 		mov	r0, #1
1950:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9630              		.loc 1 1950 0
 9631 537c 2820C7E5 		strb	r2, [r7, #40]
1951:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9632              		.loc 1 1951 0
 9633 5380 2930C7E5 		strb	r3, [r7, #41]
1952:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9634              		.loc 1 1952 0
 9635 5384 2A30C7E5 		strb	r3, [r7, #42]
1953:../uvc.c      **** 		 	 }
 9636              		.loc 1 1953 0
 9637 5388 2B30C7E5 		strb	r3, [r7, #43]
 9638              	.LVL1142:
1958:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 9639              		.loc 1 1958 0
 9640 538c 24308DE5 		str	r3, [sp, #36]
 9641              	.LVL1143:
 9642              	.L962:
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9643              		.loc 1 1937 0
 9644 5390 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9645              	.LVL1144:
1939:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9646              		.loc 1 1939 0
 9647 5394 0050A0E3 		mov	r5, #0
1938:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
 9648              		.loc 1 1938 0
 9649 5398 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9650              	.LVL1145:
1939:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9651              		.loc 1 1939 0
 9652 539c 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 9653              	.LVL1146:
 9654 53a0 24209DE5 		ldr	r2, [sp, #36]
 9655 53a4 E5FDFFEA 		b	.L673
 9656              	.LVL1147:
 9657              	.L667:
1867:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9658              		.loc 1 1867 0
 9659 53a8 020055E3 		cmp	r5, #2
1868:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9660              		.loc 1 1868 0
 9661 53ac 1F27D905 		ldreqb	r2, [r9, #1823]	@ zero_extendqisi2
1869:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9662              		.loc 1 1869 0
 9663 53b0 2037D905 		ldreqb	r3, [r9, #1824]	@ zero_extendqisi2
1867:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9664              		.loc 1 1867 0
 9665 53b4 1801000A 		beq	.L960
1872:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9666              		.loc 1 1872 0
 9667 53b8 1FC7D9E5 		ldrb	ip, [r9, #1823]	@ zero_extendqisi2
1874:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9668              		.loc 1 1874 0
 9669 53bc 2027D9E5 		ldrb	r2, [r9, #1824]	@ zero_extendqisi2
1875:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9670              		.loc 1 1875 0
 9671 53c0 0030A0E3 		mov	r3, #0
1879:../uvc.c      **** 		 	 if(Len == 2){
 9672              		.loc 1 1879 0
 9673 53c4 0500A0E1 		mov	r0, r5
 9674 53c8 08141FE5 		ldr	r1, .L1034+120
1872:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9675              		.loc 1 1872 0
 9676 53cc 28C0C7E5 		strb	ip, [r7, #40]
1874:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9677              		.loc 1 1874 0
 9678 53d0 2920C7E5 		strb	r2, [r7, #41]
1875:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9679              		.loc 1 1875 0
 9680 53d4 2B30C7E5 		strb	r3, [r7, #43]
1885:../uvc.c      **** 			  }
 9681              		.loc 1 1885 0
 9682 53d8 24308DE5 		str	r3, [sp, #36]
 9683 53dc 5FFCFFEA 		b	.L961
 9684              	.LVL1148:
 9685              	.L720:
 9686              	.LBE349:
 9687              	.LBE357:
 9688              	.LBE369:
 9689              	.LBE446:
 9690              	.LBB447:
 9691              	.LBB339:
 9692              	.LBB275:
 9693              	.LBB181:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9694              		.loc 1 2985 0
 9695 53e0 24E41FE5 		ldr	lr, .L1034+116
 9696 53e4 CF15DEE5 		ldrb	r1, [lr, #1487]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9697              		.loc 1 2986 0
 9698 53e8 D025DEE5 		ldrb	r2, [lr, #1488]	@ zero_extendqisi2
 9699 53ec 3FFDFFEA 		b	.L972
 9700              	.LVL1149:
 9701              	.L814:
 9702              	.LBE181:
 9703              	.LBE275:
 9704              	.LBB276:
 9705              	.LBB256:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9706              		.loc 1 2985 0
 9707 53f0 8F06D9E5 		ldrb	r0, [r9, #1679]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9708              		.loc 1 2986 0
 9709 53f4 9016D9E5 		ldrb	r1, [r9, #1680]	@ zero_extendqisi2
 9710 53f8 8BFDFFEA 		b	.L974
 9711              	.LVL1150:
 9712              	.L731:
 9713              	.LBE256:
 9714              	.LBE276:
 9715              	.LBB277:
 9716              	.LBB206:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9717              		.loc 1 2985 0
 9718 53fc 40241FE5 		ldr	r2, .L1034+116
 9719 5400 E715D2E5 		ldrb	r1, [r2, #1511]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9720              		.loc 1 2986 0
 9721 5404 E825D2E5 		ldrb	r2, [r2, #1512]	@ zero_extendqisi2
 9722 5408 09FDFFEA 		b	.L970
 9723              	.LVL1151:
 9724              	.L746:
 9725              	.LBE206:
 9726              	.LBE277:
 9727              	.LBB278:
 9728              	.LBB173:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9729              		.loc 1 2985 0
 9730 540c FF15D9E5 		ldrb	r1, [r9, #1535]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9731              		.loc 1 2986 0
 9732 5410 0026D9E5 		ldrb	r2, [r9, #1536]	@ zero_extendqisi2
 9733 5414 35FDFFEA 		b	.L972
 9734              	.LVL1152:
 9735              	.L709:
 9736              	.LBE173:
 9737              	.LBE278:
 9738              	.LBB279:
 9739              	.LBB198:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9740              		.loc 1 2985 0
 9741 5418 5CE41FE5 		ldr	lr, .L1034+116
 9742 541c 9F15DEE5 		ldrb	r1, [lr, #1439]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9743              		.loc 1 2986 0
 9744 5420 A025DEE5 		ldrb	r2, [lr, #1440]	@ zero_extendqisi2
 9745 5424 31FDFFEA 		b	.L972
 9746              	.LVL1153:
 9747              	.L724:
 9748              	.LBE198:
 9749              	.LBE279:
 9750              	.LBB280:
 9751              	.LBB182:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9752              		.loc 1 3012 0
 9753 5428 6C441FE5 		ldr	r4, .L1034+116
 9754 542c D535D4E5 		ldrb	r3, [r4, #1493]	@ zero_extendqisi2
 9755              	.LVL1154:
 9756              	.L985:
 9757              	.LBE182:
 9758              	.LBE280:
 9759              	.LBB281:
 9760              	.LBB238:
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9761              		.loc 1 3013 0
 9762 5430 0100A0E3 		mov	r0, #1
 9763 5434 74141FE5 		ldr	r1, .L1034+120
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9764              		.loc 1 3012 0
 9765 5438 2830C7E5 		strb	r3, [r7, #40]
3015:../uvc.c      **** 			  break;
 9766              		.loc 1 3015 0
 9767 543c 0160A0E3 		mov	r6, #1
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9768              		.loc 1 3013 0
 9769 5440 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9770              	.LVL1155:
3014:../uvc.c      **** 			  Len = 1;
 9771              		.loc 1 3014 0
 9772 5444 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9773              	.LVL1156:
 9774 5448 19FFFFEA 		b	.L809
 9775              	.LVL1157:
 9776              	.L713:
 9777              	.LBE238:
 9778              	.LBE281:
 9779              	.LBB282:
 9780              	.LBB199:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9781              		.loc 1 3012 0
 9782 544c A535D9E5 		ldrb	r3, [r9, #1445]	@ zero_extendqisi2
 9783 5450 F6FFFFEA 		b	.L985
 9784              	.LVL1158:
 9785              	.L735:
 9786              	.LBE199:
 9787              	.LBE282:
 9788              	.LBB283:
 9789              	.LBB207:
 9790 5454 ED35D9E5 		ldrb	r3, [r9, #1517]	@ zero_extendqisi2
 9791              	.LVL1159:
 9792              	.L986:
 9793              	.LBE207:
 9794              	.LBE283:
 9795              	.LBB284:
 9796              	.LBB217:
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9797              		.loc 1 3013 0
 9798 5458 0100A0E3 		mov	r0, #1
 9799 545c 9C141FE5 		ldr	r1, .L1034+120
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9800              		.loc 1 3012 0
 9801 5460 2830C7E5 		strb	r3, [r7, #40]
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9802              		.loc 1 3013 0
 9803 5464 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9804              	.LVL1160:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9805              		.loc 1 2950 0
 9806 5468 FF20A0E3 		mov	r2, #255
 9807 546c 0230A0E1 		mov	r3, r2
3014:../uvc.c      **** 			  Len = 1;
 9808              		.loc 1 3014 0
 9809 5470 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9810              	.LVL1161:
3015:../uvc.c      **** 			  break;
 9811              		.loc 1 3015 0
 9812 5474 0160A0E3 		mov	r6, #1
 9813 5478 ADFFFFEA 		b	.L785
 9814              	.LVL1162:
 9815              	.L783:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9816              		.loc 1 3012 0
 9817 547c C0441FE5 		ldr	r4, .L1034+116
 9818 5480 4D36D4E5 		ldrb	r3, [r4, #1613]	@ zero_extendqisi2
 9819 5484 F3FFFFEA 		b	.L986
 9820              	.LVL1163:
 9821              	.L768:
 9822              	.LBE217:
 9823              	.LBE284:
 9824              	.LBB285:
 9825              	.LBB190:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9826              		.loc 1 2985 0
 9827 5488 CCE41FE5 		ldr	lr, .L1034+116
 9828 548c 2F16DEE5 		ldrb	r1, [lr, #1583]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9829              		.loc 1 2986 0
 9830 5490 3026DEE5 		ldrb	r2, [lr, #1584]	@ zero_extendqisi2
 9831 5494 15FDFFEA 		b	.L972
 9832              	.LVL1164:
 9833              	.L779:
 9834              	.LBE190:
 9835              	.LBE285:
 9836              	.LBB286:
 9837              	.LBB218:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9838              		.loc 1 2985 0
 9839 5498 DCE41FE5 		ldr	lr, .L1034+116
 9840 549c 4716DEE5 		ldrb	r1, [lr, #1607]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9841              		.loc 1 2986 0
 9842 54a0 4826DEE5 		ldrb	r2, [lr, #1608]	@ zero_extendqisi2
 9843 54a4 E2FCFFEA 		b	.L970
 9844              	.LVL1165:
 9845              	.L803:
 9846              	.LBE218:
 9847              	.LBE286:
 9848              	.LBB287:
 9849              	.LBB239:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9850              		.loc 1 2985 0
 9851 54a8 EC241FE5 		ldr	r2, .L1034+116
 9852 54ac 7716D2E5 		ldrb	r1, [r2, #1655]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9853              		.loc 1 2986 0
 9854 54b0 7826D2E5 		ldrb	r2, [r2, #1656]	@ zero_extendqisi2
 9855 54b4 0DFDFFEA 		b	.L972
 9856              	.LVL1166:
 9857              	.L757:
 9858              	.LBE239:
 9859              	.LBE287:
 9860              	.LBB288:
 9861              	.LBB228:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9862              		.loc 1 2985 0
 9863 54b8 FC241FE5 		ldr	r2, .L1034+116
 9864 54bc 1716D2E5 		ldrb	r1, [r2, #1559]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9865              		.loc 1 2986 0
 9866 54c0 1826D2E5 		ldrb	r2, [r2, #1560]	@ zero_extendqisi2
 9867 54c4 09FDFFEA 		b	.L972
 9868              	.LVL1167:
 9869              	.L792:
 9870              	.LBE228:
 9871              	.LBE288:
 9872              	.LBB289:
 9873              	.LBB247:
2985:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9874              		.loc 1 2985 0
 9875 54c8 5F16D9E5 		ldrb	r1, [r9, #1631]	@ zero_extendqisi2
2986:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9876              		.loc 1 2986 0
 9877 54cc 6026D9E5 		ldrb	r2, [r9, #1632]	@ zero_extendqisi2
 9878 54d0 06FDFFEA 		b	.L972
 9879              	.LVL1168:
 9880              	.L772:
 9881              	.LBE247:
 9882              	.LBE289:
 9883              	.LBB290:
 9884              	.LBB191:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9885              		.loc 1 3012 0
 9886 54d4 3536D9E5 		ldrb	r3, [r9, #1589]	@ zero_extendqisi2
 9887 54d8 D4FFFFEA 		b	.L985
 9888              	.LVL1169:
 9889              	.L818:
 9890              	.LBE191:
 9891              	.LBE290:
 9892              	.LBB291:
 9893              	.LBB257:
 9894 54dc 9536D9E5 		ldrb	r3, [r9, #1685]	@ zero_extendqisi2
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9895              		.loc 1 3013 0
 9896 54e0 0100A0E3 		mov	r0, #1
 9897 54e4 24151FE5 		ldr	r1, .L1034+120
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9898              		.loc 1 2950 0
 9899 54e8 FF40A0E3 		mov	r4, #255
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9900              		.loc 1 3012 0
 9901 54ec 2830C7E5 		strb	r3, [r7, #40]
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9902              		.loc 1 2950 0
 9903 54f0 24408DE5 		str	r4, [sp, #36]
3015:../uvc.c      **** 			  break;
 9904              		.loc 1 3015 0
 9905 54f4 0160A0E3 		mov	r6, #1
3013:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9906              		.loc 1 3013 0
 9907 54f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9908              	.LVL1170:
3014:../uvc.c      **** 			  Len = 1;
 9909              		.loc 1 3014 0
 9910 54fc 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9911              	.LVL1171:
 9912 5500 55FDFFEA 		b	.L820
 9913              	.LVL1172:
 9914              	.L796:
 9915              	.LBE257:
 9916              	.LBE291:
 9917              	.LBB292:
 9918              	.LBB248:
3012:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9919              		.loc 1 3012 0
 9920 5504 6536D9E5 		ldrb	r3, [r9, #1637]	@ zero_extendqisi2
 9921 5508 C8FFFFEA 		b	.L985
 9922              	.LVL1173:
 9923              	.L750:
 9924              	.LBE248:
 9925              	.LBE292:
 9926              	.LBB293:
 9927              	.LBB174:
 9928 550c 0536D9E5 		ldrb	r3, [r9, #1541]	@ zero_extendqisi2
 9929 5510 C6FFFFEA 		b	.L985
 9930              	.LVL1174:
 9931              	.L761:
 9932              	.LBE174:
 9933              	.LBE293:
 9934              	.LBB294:
 9935              	.LBB229:
 9936 5514 58C51FE5 		ldr	ip, .L1034+116
 9937 5518 1D36DCE5 		ldrb	r3, [ip, #1565]	@ zero_extendqisi2
 9938 551c C3FFFFEA 		b	.L985
 9939              	.LVL1175:
 9940              	.L807:
 9941              	.LBE229:
 9942              	.LBE294:
 9943              	.LBB295:
 9944              	.LBB240:
 9945 5520 7D36D9E5 		ldrb	r3, [r9, #1661]	@ zero_extendqisi2
 9946 5524 C1FFFFEA 		b	.L985
 9947              	.LVL1176:
 9948              	.L866:
 9949              	.LBE240:
 9950              	.LBE295:
 9951              	.LBE339:
 9952              	.LBE447:
 9953              	.LBB448:
 9954              	.LBB423:
 9955              	.LBB400:
 9956              	.LBB380:
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9957              		.loc 1 1330 0
 9958 5528 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9959              		.loc 1 1331 0
 9960 552c 0200A0E3 		mov	r0, #2
 9961 5530 70151FE5 		ldr	r1, .L1034+120
1329:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9962              		.loc 1 1329 0
 9963 5534 2860C7E5 		strb	r6, [r7, #40]
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9964              		.loc 1 1330 0
 9965 5538 2930C7E5 		strb	r3, [r7, #41]
1332:../uvc.c      **** 			  break;
 9966              		.loc 1 1332 0
 9967 553c 24308DE5 		str	r3, [sp, #36]
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9968              		.loc 1 1331 0
 9969 5540 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9970              	.LVL1177:
1332:../uvc.c      **** 			  break;
 9971              		.loc 1 1332 0
 9972 5544 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9973              	.LVL1178:
 9974 5548 0060A0E3 		mov	r6, #0
 9975              	.LVL1179:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9976              		.loc 1 1313 0
 9977 554c FF50A0E3 		mov	r5, #255
 9978              	.LVL1180:
 9979              	.L870:
2930:../uvc.c      **** }
 9980              		.loc 1 2930 0
 9981 5550 24209DE5 		ldr	r2, [sp, #36]
 9982 5554 0630A0E1 		mov	r3, r6
 9983 5558 04108DE8 		stmia	sp, {r2, ip}
 9984 555c B8151FE5 		ldr	r1, .L1034+92
 9985 5560 28209DE5 		ldr	r2, [sp, #40]
 9986 5564 08508DE5 		str	r5, [sp, #8]
 9987 5568 0400A0E3 		mov	r0, #4
 9988 556c FEFFFFEB 		bl	CyU3PDebugPrint
 9989              	.LVL1181:
 9990              	.LBE380:
 9991              	.LBE400:
4968:../uvc.c      ****     		break;
 9992              		.loc 1 4968 0
 9993 5570 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9994 5574 CC451FE5 		ldr	r4, .L1034+96
 9995 5578 0400A0E3 		mov	r0, #4
 9996 557c DC151FE5 		ldr	r1, .L1034+88
 9997 5580 B020D4E1 		ldrh	r2, [r4]
 9998 5584 FEFFFFEB 		bl	CyU3PDebugPrint
 9999              	.LVL1182:
 10000 5588 44309DE5 		ldr	r3, [sp, #68]
 10001 558c BCFAFFEA 		b	.L642
 10002              	.LVL1183:
 10003              	.L893:
 10004              	.LBB401:
 10005              	.LBB392:
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10006              		.loc 1 1330 0
 10007 5590 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10008              		.loc 1 1331 0
 10009 5594 0200A0E3 		mov	r0, #2
 10010 5598 D8151FE5 		ldr	r1, .L1034+120
1329:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10011              		.loc 1 1329 0
 10012 559c 2860C7E5 		strb	r6, [r7, #40]
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10013              		.loc 1 1330 0
 10014 55a0 2930C7E5 		strb	r3, [r7, #41]
1332:../uvc.c      **** 			  break;
 10015              		.loc 1 1332 0
 10016 55a4 24308DE5 		str	r3, [sp, #36]
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10017              		.loc 1 1331 0
 10018 55a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10019              	.LVL1184:
1332:../uvc.c      **** 			  break;
 10020              		.loc 1 1332 0
 10021 55ac 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10022              	.LVL1185:
 10023 55b0 0060A0E3 		mov	r6, #0
 10024              	.LVL1186:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10025              		.loc 1 1313 0
 10026 55b4 FF50A0E3 		mov	r5, #255
 10027              	.LVL1187:
 10028              	.L897:
2930:../uvc.c      **** }
 10029              		.loc 1 2930 0
 10030 55b8 24209DE5 		ldr	r2, [sp, #36]
 10031 55bc 0630A0E1 		mov	r3, r6
 10032 55c0 04108DE8 		stmia	sp, {r2, ip}
 10033 55c4 20161FE5 		ldr	r1, .L1034+92
 10034 55c8 28209DE5 		ldr	r2, [sp, #40]
 10035 55cc 08508DE5 		str	r5, [sp, #8]
 10036 55d0 0400A0E3 		mov	r0, #4
 10037 55d4 FEFFFFEB 		bl	CyU3PDebugPrint
 10038              	.LVL1188:
 10039              	.LBE392:
 10040              	.LBE401:
4973:../uvc.c      ****    		break;
 10041              		.loc 1 4973 0
 10042 55d8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10043 55dc 34461FE5 		ldr	r4, .L1034+96
 10044 55e0 0400A0E3 		mov	r0, #4
 10045 55e4 38161FE5 		ldr	r1, .L1034+100
 10046 55e8 B020D4E1 		ldrh	r2, [r4]
 10047 55ec FEFFFFEB 		bl	CyU3PDebugPrint
 10048              	.LVL1189:
 10049 55f0 44309DE5 		ldr	r3, [sp, #68]
 10050 55f4 A2FAFFEA 		b	.L642
 10051              	.LVL1190:
 10052              	.L738:
 10053              	.LBE423:
 10054              	.LBE448:
 10055              	.LBB449:
 10056              	.LBB340:
 10057              	.LBB296:
 10058              	.LBB208:
3113:../uvc.c      **** 					  }
 10059              		.loc 1 3113 0
 10060 55f8 0000A0E3 		mov	r0, #0
 10061 55fc 0020A0E1 		mov	r2, r0
 10062 5600 0110A0E3 		mov	r1, #1
 10063 5604 FEFFFFEB 		bl	CyU3PUsbStall
 10064              	.LVL1191:
 10065 5608 28FEFFEA 		b	.L787
 10066              	.LVL1192:
 10067              	.L861:
 10068              	.LBE208:
 10069              	.LBE296:
 10070              	.LBE340:
 10071              	.LBE449:
 10072              	.LBB450:
 10073              	.LBB424:
 10074              	.LBB402:
 10075              	.LBB381:
1890:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10076              		.loc 1 1890 0
 10077 560c 020056E3 		cmp	r6, #2
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10078              		.loc 1 1896 0
 10079 5610 35C7D915 		ldrneb	ip, [r9, #1845]	@ zero_extendqisi2
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10080              		.loc 1 1898 0
 10081 5614 3627D915 		ldrneb	r2, [r9, #1846]	@ zero_extendqisi2
1890:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10082              		.loc 1 1890 0
 10083 5618 11FCFF1A 		bne	.L976
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10084              		.loc 1 1891 0
 10085 561c 3527D9E5 		ldrb	r2, [r9, #1845]	@ zero_extendqisi2
1892:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10086              		.loc 1 1892 0
 10087 5620 3637D9E5 		ldrb	r3, [r9, #1846]	@ zero_extendqisi2
1915:../uvc.c      **** 				  if(Len == 2){
 10088              		.loc 1 1915 0
 10089 5624 0200A0E3 		mov	r0, #2
 10090              	.L975:
 10091 5628 68161FE5 		ldr	r1, .L1034+120
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10092              		.loc 1 1891 0
 10093 562c 2820C7E5 		strb	r2, [r7, #40]
1892:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10094              		.loc 1 1892 0
 10095 5630 2930C7E5 		strb	r3, [r7, #41]
 10096              	.LVL1193:
 10097              	.L977:
1918:../uvc.c      **** 				  }else{
 10098              		.loc 1 1918 0
 10099 5634 00C0A0E3 		mov	ip, #0
 10100 5638 24C08DE5 		str	ip, [sp, #36]
 10101 563c 0060A0E3 		mov	r6, #0
1915:../uvc.c      **** 				  if(Len == 2){
 10102              		.loc 1 1915 0
 10103 5640 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10104              	.LVL1194:
1917:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10105              		.loc 1 1917 0
 10106 5644 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10107              	.LVL1195:
1918:../uvc.c      **** 				  }else{
 10108              		.loc 1 1918 0
 10109 5648 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 10110              	.LVL1196:
 10111 564c BFFFFFEA 		b	.L870
 10112              	.LVL1197:
 10113              	.L1018:
 10114              	.LBE381:
 10115              	.LBE402:
 10116              	.LBB403:
 10117              	.LBB393:
1325:../uvc.c      **** 		 {
 10118              		.loc 1 1325 0
 10119 5650 81005CE3 		cmp	ip, #129
 10120 5654 8901000A 		beq	.L890
 10121 5658 6E01008A 		bhi	.L891
 10122 565c 01005CE3 		cmp	ip, #1
 10123 5660 CD01001A 		bne	.L887
2515:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10124              		.loc 1 2515 0
 10125 5664 2000A0E3 		mov	r0, #32
 10126 5668 A8161FE5 		ldr	r1, .L1034+120
 10127 566c 42208DE2 		add	r2, sp, #66
 10128 5670 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10129              	.LVL1198:
2517:../uvc.c      **** 			   {
 10130              		.loc 1 2517 0
 10131 5674 000050E3 		cmp	r0, #0
 10132 5678 38008DE5 		str	r0, [sp, #56]
 10133 567c 3802001A 		bne	.L906
2519:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10134              		.loc 1 2519 0
 10135 5680 020056E3 		cmp	r6, #2
 10136 5684 B002000A 		beq	.L1019
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10137              		.loc 1 2527 0
 10138 5688 2CC09DE5 		ldr	ip, [sp, #44]
 10139 568c 08608DE5 		str	r6, [sp, #8]
 10140 5690 00508DE5 		str	r5, [sp]
 10141 5694 04C08DE5 		str	ip, [sp, #4]
2524:../uvc.c      **** 				 }
 10142              		.loc 1 2524 0
 10143 5698 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10144              		.loc 1 2527 0
 10145 569c 0400A0E3 		mov	r0, #4
 10146              	.LVL1199:
 10147 56a0 F0161FE5 		ldr	r1, .L1034+104
 10148 56a4 2A20A0E3 		mov	r2, #42
 10149 56a8 34309DE5 		ldr	r3, [sp, #52]
 10150 56ac 3C608DE5 		str	r6, [sp, #60]
2524:../uvc.c      **** 				 }
 10151              		.loc 1 2524 0
 10152 56b0 24C08DE5 		str	ip, [sp, #36]
2523:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10153              		.loc 1 2523 0
 10154 56b4 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 10155              	.LVL1200:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10156              		.loc 1 2527 0
 10157 56b8 FEFFFFEB 		bl	CyU3PDebugPrint
 10158              	.LVL1201:
2711:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10159              		.loc 1 2711 0
 10160 56bc 3CC09DE5 		ldr	ip, [sp, #60]
 10161 56c0 04005CE3 		cmp	ip, #4
 10162 56c4 3903000A 		beq	.L1020
 10163              	.LVL1202:
 10164              	.L911:
2728:../uvc.c      **** 				 	 			 break;
 10165              		.loc 1 2728 0
 10166 56c8 5227D9E5 		ldrb	r2, [r9, #1874]	@ zero_extendqisi2
2727:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10167              		.loc 1 2727 0
 10168 56cc 3CC09DE5 		ldr	ip, [sp, #60]
2728:../uvc.c      **** 				 	 			 break;
 10169              		.loc 1 2728 0
 10170 56d0 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
2727:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10171              		.loc 1 2727 0
 10172 56d4 0400A0E3 		mov	r0, #4
 10173 56d8 0C108DE8 		stmia	sp, {r2, r3, ip}
 10174 56dc 28171FE5 		ldr	r1, .L1034+108
 10175 56e0 0620A0E1 		mov	r2, r6
 10176 56e4 24309DE5 		ldr	r3, [sp, #36]
 10177 56e8 FEFFFFEB 		bl	CyU3PDebugPrint
 10178              	.LVL1203:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10179              		.loc 1 1313 0
 10180 56ec FF50A0E3 		mov	r5, #255
 10181 56f0 05C0A0E1 		mov	ip, r5
 10182 56f4 AFFFFFEA 		b	.L897
 10183              	.LVL1204:
 10184              	.L1005:
 10185              	.LBE393:
 10186              	.LBE403:
 10187              	.LBB404:
 10188              	.LBB382:
1325:../uvc.c      **** 		 {
 10189              		.loc 1 1325 0
 10190 56f8 81005CE3 		cmp	ip, #129
 10191 56fc DC01000A 		beq	.L863
 10192 5700 D301008A 		bhi	.L864
 10193 5704 01005CE3 		cmp	ip, #1
 10194 5708 AD01001A 		bne	.L860
2515:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10195              		.loc 1 2515 0
 10196 570c 2000A0E3 		mov	r0, #32
 10197 5710 50171FE5 		ldr	r1, .L1034+120
 10198 5714 42208DE2 		add	r2, sp, #66
 10199 5718 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10200              	.LVL1205:
2517:../uvc.c      **** 			   {
 10201              		.loc 1 2517 0
 10202 571c 000050E3 		cmp	r0, #0
 10203 5720 38008DE5 		str	r0, [sp, #56]
 10204 5724 1F02001A 		bne	.L879
2519:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10205              		.loc 1 2519 0
 10206 5728 020056E3 		cmp	r6, #2
 10207 572c 6002000A 		beq	.L1021
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10208              		.loc 1 2527 0
 10209 5730 2CC09DE5 		ldr	ip, [sp, #44]
 10210 5734 08608DE5 		str	r6, [sp, #8]
 10211 5738 00508DE5 		str	r5, [sp]
 10212 573c 04C08DE5 		str	ip, [sp, #4]
2524:../uvc.c      **** 				 }
 10213              		.loc 1 2524 0
 10214 5740 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10215              		.loc 1 2527 0
 10216 5744 0400A0E3 		mov	r0, #4
 10217              	.LVL1206:
 10218 5748 98171FE5 		ldr	r1, .L1034+104
 10219 574c 2920A0E3 		mov	r2, #41
 10220 5750 34309DE5 		ldr	r3, [sp, #52]
 10221 5754 3C608DE5 		str	r6, [sp, #60]
2524:../uvc.c      **** 				 }
 10222              		.loc 1 2524 0
 10223 5758 24C08DE5 		str	ip, [sp, #36]
2523:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10224              		.loc 1 2523 0
 10225 575c 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 10226              	.LVL1207:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10227              		.loc 1 2527 0
 10228 5760 FEFFFFEB 		bl	CyU3PDebugPrint
 10229              	.LVL1208:
2711:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10230              		.loc 1 2711 0
 10231 5764 3CC09DE5 		ldr	ip, [sp, #60]
 10232 5768 04005CE3 		cmp	ip, #4
 10233 576c E802000A 		beq	.L1022
 10234              	.LVL1209:
 10235              	.L884:
2728:../uvc.c      **** 				 	 			 break;
 10236              		.loc 1 2728 0
 10237 5770 3E27D9E5 		ldrb	r2, [r9, #1854]	@ zero_extendqisi2
2727:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10238              		.loc 1 2727 0
 10239 5774 3CC09DE5 		ldr	ip, [sp, #60]
2728:../uvc.c      **** 				 	 			 break;
 10240              		.loc 1 2728 0
 10241 5778 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
2727:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10242              		.loc 1 2727 0
 10243 577c 0400A0E3 		mov	r0, #4
 10244 5780 0C108DE8 		stmia	sp, {r2, r3, ip}
 10245 5784 D0171FE5 		ldr	r1, .L1034+108
 10246 5788 0620A0E1 		mov	r2, r6
 10247 578c 24309DE5 		ldr	r3, [sp, #36]
 10248 5790 FEFFFFEB 		bl	CyU3PDebugPrint
 10249              	.LVL1210:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10250              		.loc 1 1313 0
 10251 5794 FF50A0E3 		mov	r5, #255
 10252 5798 05C0A0E1 		mov	ip, r5
 10253 579c 6BFFFFEA 		b	.L870
 10254              	.LVL1211:
 10255              	.L669:
 10256              	.LBE382:
 10257              	.LBE404:
 10258              	.LBE424:
 10259              	.LBE450:
 10260              	.LBB451:
 10261              	.LBB370:
 10262              	.LBB358:
 10263              	.LBB350:
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10264              		.loc 1 1330 0
 10265 57a0 0030A0E3 		mov	r3, #0
1332:../uvc.c      **** 			  break;
 10266              		.loc 1 1332 0
 10267 57a4 0340A0E1 		mov	r4, r3
 10268              	.LVL1212:
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10269              		.loc 1 1331 0
 10270 57a8 0200A0E3 		mov	r0, #2
 10271 57ac EC171FE5 		ldr	r1, .L1034+120
1329:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10272              		.loc 1 1329 0
 10273 57b0 2850C7E5 		strb	r5, [r7, #40]
1330:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10274              		.loc 1 1330 0
 10275 57b4 2930C7E5 		strb	r3, [r7, #41]
1332:../uvc.c      **** 			  break;
 10276              		.loc 1 1332 0
 10277 57b8 24308DE5 		str	r3, [sp, #36]
 10278 57bc 0450A0E1 		mov	r5, r4
 10279              	.LVL1213:
1331:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10280              		.loc 1 1331 0
 10281 57c0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10282              	.LVL1214:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10283              		.loc 1 1313 0
 10284 57c4 FF40A0E3 		mov	r4, #255
1332:../uvc.c      **** 			  break;
 10285              		.loc 1 1332 0
 10286 57c8 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10287              	.LVL1215:
 10288 57cc 24209DE5 		ldr	r2, [sp, #36]
 10289 57d0 DAFCFFEA 		b	.L673
 10290              	.LVL1216:
 10291              	.L663:
2927:../uvc.c      **** 			  break;
 10292              		.loc 1 2927 0
 10293 57d4 0000A0E3 		mov	r0, #0
 10294 57d8 0020A0E1 		mov	r2, r0
 10295 57dc 0110A0E3 		mov	r1, #1
 10296 57e0 FEFFFFEB 		bl	CyU3PUsbStall
 10297              	.LVL1217:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10298              		.loc 1 1313 0
 10299 57e4 FF40A0E3 		mov	r4, #255
 10300              	.LVL1218:
2927:../uvc.c      **** 			  break;
 10301              		.loc 1 2927 0
 10302 57e8 0010A0E3 		mov	r1, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10303              		.loc 1 1313 0
 10304 57ec 04C0A0E1 		mov	ip, r4
2927:../uvc.c      **** 			  break;
 10305              		.loc 1 2927 0
 10306 57f0 24108DE5 		str	r1, [sp, #36]
 10307 57f4 0150A0E1 		mov	r5, r1
 10308              	.LVL1219:
 10309 57f8 0120A0E1 		mov	r2, r1
 10310 57fc CFFCFFEA 		b	.L673
 10311              	.LVL1220:
 10312              	.L664:
1904:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10313              		.loc 1 1904 0
 10314 5800 44E81FE5 		ldr	lr, .L1034+116
1903:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10315              		.loc 1 1903 0
 10316 5804 020055E3 		cmp	r5, #2
1908:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10317              		.loc 1 1908 0
 10318 5808 21C7DE15 		ldrneb	ip, [lr, #1825]	@ zero_extendqisi2
1910:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10319              		.loc 1 1910 0
 10320 580c 2227DE15 		ldrneb	r2, [lr, #1826]	@ zero_extendqisi2
1903:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10321              		.loc 1 1903 0
 10322 5810 4BFBFF1A 		bne	.L983
1904:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10323              		.loc 1 1904 0
 10324 5814 2127DEE5 		ldrb	r2, [lr, #1825]	@ zero_extendqisi2
1905:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10325              		.loc 1 1905 0
 10326 5818 2237DEE5 		ldrb	r3, [lr, #1826]	@ zero_extendqisi2
 10327              	.L960:
1918:../uvc.c      **** 				  }else{
 10328              		.loc 1 1918 0
 10329 581c 0040A0E3 		mov	r4, #0
 10330              	.LVL1221:
1915:../uvc.c      **** 				  if(Len == 2){
 10331              		.loc 1 1915 0
 10332 5820 0500A0E1 		mov	r0, r5
 10333 5824 64181FE5 		ldr	r1, .L1034+120
1904:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10334              		.loc 1 1904 0
 10335 5828 2820C7E5 		strb	r2, [r7, #40]
1905:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10336              		.loc 1 1905 0
 10337 582c 2930C7E5 		strb	r3, [r7, #41]
1918:../uvc.c      **** 				  }else{
 10338              		.loc 1 1918 0
 10339 5830 24408DE5 		str	r4, [sp, #36]
 10340 5834 D5FEFFEA 		b	.L962
 10341              	.LVL1222:
 10342              	.L670:
1932:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10343              		.loc 1 1932 0
 10344 5838 23C7D9E5 		ldrb	ip, [r9, #1827]	@ zero_extendqisi2
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10345              		.loc 1 1937 0
 10346 583c 7C181FE5 		ldr	r1, .L1034+120
1933:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10347              		.loc 1 1933 0
 10348 5840 2427D9E5 		ldrb	r2, [r9, #1828]	@ zero_extendqisi2
1934:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10349              		.loc 1 1934 0
 10350 5844 0030A0E3 		mov	r3, #0
1932:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10351              		.loc 1 1932 0
 10352 5848 28C0C7E5 		strb	ip, [r7, #40]
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10353              		.loc 1 1937 0
 10354 584c 0500A0E1 		mov	r0, r5
1939:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 10355              		.loc 1 1939 0
 10356 5850 03C0A0E1 		mov	ip, r3
1933:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10357              		.loc 1 1933 0
 10358 5854 2920C7E5 		strb	r2, [r7, #41]
1934:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10359              		.loc 1 1934 0
 10360 5858 2A30C7E5 		strb	r3, [r7, #42]
1935:../uvc.c      **** 		 	 }
 10361              		.loc 1 1935 0
 10362 585c 2B30C7E5 		strb	r3, [r7, #43]
 10363              	.LVL1223:
 10364              	.L963:
1939:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 10365              		.loc 1 1939 0
 10366 5860 24C08DE5 		str	ip, [sp, #36]
 10367 5864 C9FEFFEA 		b	.L962
 10368              	.LVL1224:
 10369              	.L666:
1806:../uvc.c      **** 			 	 			 if(Len == 2)
 10370              		.loc 1 1806 0
 10371 5868 AE30D7E5 		ldrb	r3, [r7, #174]	@ zero_extendqisi2
 10372 586c 000053E3 		cmp	r3, #0
 10373 5870 5D01000A 		beq	.L674
1807:../uvc.c      **** 			 	 			 {
 10374              		.loc 1 1807 0
 10375 5874 020055E3 		cmp	r5, #2
 10376 5878 C301000A 		beq	.L1023
1813:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10377              		.loc 1 1813 0
 10378 587c 040055E3 		cmp	r5, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10379              		.loc 1 1313 0
 10380 5880 FF40A013 		movne	r4, #255
 10381              	.LVL1225:
 10382 5884 04C0A011 		movne	ip, r4
1813:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10383              		.loc 1 1813 0
 10384 5888 5F01001A 		bne	.L676
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10385              		.loc 1 1814 0
 10386 588c 2927D9E5 		ldrb	r2, [r9, #1833]	@ zero_extendqisi2
1816:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10387              		.loc 1 1816 0
 10388 5890 2A47D9E5 		ldrb	r4, [r9, #1834]	@ zero_extendqisi2
1815:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10389              		.loc 1 1815 0
 10390 5894 0030A0E3 		mov	r3, #0
1816:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10391              		.loc 1 1816 0
 10392 5898 FF4004E2 		and	r4, r4, #255
1814:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10393              		.loc 1 1814 0
 10394 589c 2820C7E5 		strb	r2, [r7, #40]
1816:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10395              		.loc 1 1816 0
 10396 58a0 2A40C7E5 		strb	r4, [r7, #42]
1818:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10397              		.loc 1 1818 0
 10398 58a4 FFC002E2 		and	ip, r2, #255
 10399              	.LVL1226:
1815:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10400              		.loc 1 1815 0
 10401 58a8 2930C7E5 		strb	r3, [r7, #41]
1817:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10402              		.loc 1 1817 0
 10403 58ac 2B30C7E5 		strb	r3, [r7, #43]
 10404 58b0 550100EA 		b	.L676
 10405              	.LVL1227:
 10406              	.L813:
 10407              	.LBE350:
 10408              	.LBE358:
 10409              	.LBE370:
 10410              	.LBE451:
 10411              	.LBB452:
 10412              	.LBB341:
 10413              	.LBB297:
 10414              	.LBB258:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10415              		.loc 1 2970 0
 10416 58b4 F8C81FE5 		ldr	ip, .L1034+116
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10417              		.loc 1 2972 0
 10418 58b8 0020A0E3 		mov	r2, #0
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10419              		.loc 1 2971 0
 10420 58bc 9A16DCE5 		ldrb	r1, [ip, #1690]	@ zero_extendqisi2
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10421              		.loc 1 2970 0
 10422 58c0 9936DCE5 		ldrb	r3, [ip, #1689]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10423              		.loc 1 2971 0
 10424 58c4 2910C7E5 		strb	r1, [r7, #41]
2978:../uvc.c      **** 
 10425              		.loc 1 2978 0
 10426 58c8 0600A0E1 		mov	r0, r6
 10427 58cc 0C191FE5 		ldr	r1, .L1034+120
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10428              		.loc 1 2950 0
 10429 58d0 FF40A0E3 		mov	r4, #255
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10430              		.loc 1 2970 0
 10431 58d4 2830C7E5 		strb	r3, [r7, #40]
2978:../uvc.c      **** 
 10432              		.loc 1 2978 0
 10433 58d8 1C308DE5 		str	r3, [sp, #28]
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10434              		.loc 1 2972 0
 10435 58dc 2A20C7E5 		strb	r2, [r7, #42]
2973:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10436              		.loc 1 2973 0
 10437 58e0 2B20C7E5 		strb	r2, [r7, #43]
 10438              	.LVL1228:
2978:../uvc.c      **** 
 10439              		.loc 1 2978 0
 10440 58e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10441              	.LVL1229:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10442              		.loc 1 2950 0
 10443 58e8 24408DE5 		str	r4, [sp, #36]
 10444 58ec 1C309DE5 		ldr	r3, [sp, #28]
 10445 58f0 59FCFFEA 		b	.L820
 10446              	.LVL1230:
 10447              	.L802:
 10448              	.LBE258:
 10449              	.LBE297:
 10450              	.LBB298:
 10451              	.LBB241:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10452              		.loc 1 2970 0
 10453 58f4 38E91FE5 		ldr	lr, .L1034+116
 10454 58f8 8146DEE5 		ldrb	r4, [lr, #1665]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10455              		.loc 1 2971 0
 10456 58fc 8226DEE5 		ldrb	r2, [lr, #1666]	@ zero_extendqisi2
 10457              	.LVL1231:
 10458              	.L984:
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10459              		.loc 1 2972 0
 10460 5900 0030A0E3 		mov	r3, #0
2978:../uvc.c      **** 
 10461              		.loc 1 2978 0
 10462 5904 0600A0E1 		mov	r0, r6
 10463 5908 48191FE5 		ldr	r1, .L1034+120
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10464              		.loc 1 2970 0
 10465 590c 2840C7E5 		strb	r4, [r7, #40]
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10466              		.loc 1 2971 0
 10467 5910 2920C7E5 		strb	r2, [r7, #41]
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10468              		.loc 1 2972 0
 10469 5914 2A30C7E5 		strb	r3, [r7, #42]
2973:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10470              		.loc 1 2973 0
 10471 5918 2B30C7E5 		strb	r3, [r7, #43]
 10472              	.LVL1232:
2978:../uvc.c      **** 
 10473              		.loc 1 2978 0
 10474 591c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10475              	.LVL1233:
 10476 5920 E3FDFFEA 		b	.L809
 10477              	.LVL1234:
 10478              	.L811:
 10479              	.LBE241:
 10480              	.LBE298:
 10481              	.LBB299:
 10482              	.LBB259:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10483              		.loc 1 2994 0
 10484 5924 68E91FE5 		ldr	lr, .L1034+116
 10485 5928 9106DEE5 		ldrb	r0, [lr, #1681]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10486              		.loc 1 2995 0
 10487 592c 9216DEE5 		ldrb	r1, [lr, #1682]	@ zero_extendqisi2
 10488 5930 3DFCFFEA 		b	.L974
 10489              	.L810:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10490              		.loc 1 3163 0
 10491 5934 0000A0E3 		mov	r0, #0
 10492 5938 0020A0E1 		mov	r2, r0
 10493 593c 0110A0E3 		mov	r1, #1
 10494 5940 FEFFFFEB 		bl	CyU3PUsbStall
 10495              	.LVL1235:
3164:../uvc.c      **** 			  break;
 10496              		.loc 1 3164 0
 10497 5944 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10498 5948 0400A0E3 		mov	r0, #4
 10499 594c 94191FE5 		ldr	r1, .L1034+112
 10500 5950 0A20A0E3 		mov	r2, #10
 10501 5954 FEFFFFEB 		bl	CyU3PDebugPrint
 10502              	.LVL1236:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10503              		.loc 1 2950 0
 10504 5958 FF30A0E3 		mov	r3, #255
 10505 595c 0340A0E1 		mov	r4, r3
 10506 5960 24308DE5 		str	r3, [sp, #36]
 10507 5964 3CFCFFEA 		b	.L820
 10508              	.LVL1237:
 10509              	.L760:
 10510              	.LBE259:
 10511              	.LBE299:
 10512              	.LBB300:
 10513              	.LBB230:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10514              		.loc 1 3003 0
 10515 5968 AC491FE5 		ldr	r4, .L1034+116
 10516 596c 1B16D4E5 		ldrb	r1, [r4, #1563]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10517              		.loc 1 3004 0
 10518 5970 1C26D4E5 		ldrb	r2, [r4, #1564]	@ zero_extendqisi2
 10519 5974 DDFBFFEA 		b	.L972
 10520              	.LVL1238:
 10521              	.L817:
 10522              	.LBE230:
 10523              	.LBE300:
 10524              	.LBB301:
 10525              	.LBB260:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10526              		.loc 1 3003 0
 10527 5978 9306D9E5 		ldrb	r0, [r9, #1683]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10528              		.loc 1 3004 0
 10529 597c 9416D9E5 		ldrb	r1, [r9, #1684]	@ zero_extendqisi2
 10530 5980 29FCFFEA 		b	.L974
 10531              	.L816:
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10532              		.loc 1 2961 0
 10533 5984 0030A0E3 		mov	r3, #0
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10534              		.loc 1 2962 0
 10535 5988 0200A0E3 		mov	r0, #2
 10536 598c CC191FE5 		ldr	r1, .L1034+120
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10537              		.loc 1 2950 0
 10538 5990 FF40A0E3 		mov	r4, #255
2961:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10539              		.loc 1 2961 0
 10540 5994 2930C7E5 		strb	r3, [r7, #41]
2960:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10541              		.loc 1 2960 0
 10542 5998 2860C7E5 		strb	r6, [r7, #40]
2962:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10543              		.loc 1 2962 0
 10544 599c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10545              	.LVL1239:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10546              		.loc 1 2950 0
 10547 59a0 24408DE5 		str	r4, [sp, #36]
2963:../uvc.c      **** 			  break;
 10548              		.loc 1 2963 0
 10549 59a4 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 10550              	.LVL1240:
 10551 59a8 2BFCFFEA 		b	.L820
 10552              	.LVL1241:
 10553              	.L806:
 10554              	.LBE260:
 10555              	.LBE301:
 10556              	.LBB302:
 10557              	.LBB242:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10558              		.loc 1 3003 0
 10559 59ac F0491FE5 		ldr	r4, .L1034+116
 10560 59b0 7B16D4E5 		ldrb	r1, [r4, #1659]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10561              		.loc 1 3004 0
 10562 59b4 7C26D4E5 		ldrb	r2, [r4, #1660]	@ zero_extendqisi2
 10563 59b8 CCFBFFEA 		b	.L972
 10564              	.LVL1242:
 10565              	.L775:
 10566              	.LBE242:
 10567              	.LBE302:
 10568              	.LBB303:
 10569              	.LBB219:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10570              		.loc 1 3163 0
 10571 59bc 0000A0E3 		mov	r0, #0
 10572 59c0 0020A0E1 		mov	r2, r0
 10573 59c4 0110A0E3 		mov	r1, #1
 10574 59c8 FEFFFFEB 		bl	CyU3PUsbStall
 10575              	.LVL1243:
3164:../uvc.c      **** 			  break;
 10576              		.loc 1 3164 0
 10577 59cc 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10578 59d0 0720A0E3 		mov	r2, #7
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10579              		.loc 1 2950 0
 10580 59d4 FF40A0E3 		mov	r4, #255
3164:../uvc.c      **** 			  break;
 10581              		.loc 1 3164 0
 10582 59d8 0400A0E3 		mov	r0, #4
 10583 59dc 241A1FE5 		ldr	r1, .L1034+112
 10584 59e0 FEFFFFEB 		bl	CyU3PDebugPrint
 10585              	.LVL1244:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10586              		.loc 1 2950 0
 10587 59e4 0420A0E1 		mov	r2, r4
 10588 59e8 0430A0E1 		mov	r3, r4
 10589 59ec 50FEFFEA 		b	.L785
 10590              	.LVL1245:
 10591              	.L727:
 10592              	.LBE219:
 10593              	.LBE303:
 10594              	.LBB304:
 10595              	.LBB209:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10596              		.loc 1 3163 0
 10597 59f0 0000A0E3 		mov	r0, #0
 10598 59f4 0020A0E1 		mov	r2, r0
 10599 59f8 0110A0E3 		mov	r1, #1
 10600 59fc FEFFFFEB 		bl	CyU3PUsbStall
 10601              	.LVL1246:
3164:../uvc.c      **** 			  break;
 10602              		.loc 1 3164 0
 10603 5a00 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10604 5a04 0320A0E3 		mov	r2, #3
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10605              		.loc 1 2950 0
 10606 5a08 FF40A0E3 		mov	r4, #255
3164:../uvc.c      **** 			  break;
 10607              		.loc 1 3164 0
 10608 5a0c 0400A0E3 		mov	r0, #4
 10609 5a10 581A1FE5 		ldr	r1, .L1034+112
 10610 5a14 FEFFFFEB 		bl	CyU3PDebugPrint
 10611              	.LVL1247:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10612              		.loc 1 2950 0
 10613 5a18 0420A0E1 		mov	r2, r4
 10614 5a1c 0430A0E1 		mov	r3, r4
 10615              	.LVL1248:
 10616 5a20 43FEFFEA 		b	.L785
 10617              	.LVL1249:
 10618              	.L791:
 10619              	.LBE209:
 10620              	.LBE304:
 10621              	.LBB305:
 10622              	.LBB249:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10623              		.loc 1 2970 0
 10624 5a24 6946D9E5 		ldrb	r4, [r9, #1641]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10625              		.loc 1 2971 0
 10626 5a28 6A26D9E5 		ldrb	r2, [r9, #1642]	@ zero_extendqisi2
 10627 5a2c B3FFFFEA 		b	.L984
 10628              	.LVL1250:
 10629              	.L749:
 10630              	.LBE249:
 10631              	.LBE305:
 10632              	.LBB306:
 10633              	.LBB175:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10634              		.loc 1 3003 0
 10635 5a30 0316D9E5 		ldrb	r1, [r9, #1539]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10636              		.loc 1 3004 0
 10637 5a34 0426D9E5 		ldrb	r2, [r9, #1540]	@ zero_extendqisi2
 10638 5a38 ACFBFFEA 		b	.L972
 10639              	.LVL1251:
 10640              	.L795:
 10641              	.LBE175:
 10642              	.LBE306:
 10643              	.LBB307:
 10644              	.LBB250:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10645              		.loc 1 3003 0
 10646 5a3c 6316D9E5 		ldrb	r1, [r9, #1635]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10647              		.loc 1 3004 0
 10648 5a40 6426D9E5 		ldrb	r2, [r9, #1636]	@ zero_extendqisi2
 10649 5a44 A9FBFFEA 		b	.L972
 10650              	.LVL1252:
 10651              	.L706:
 10652              	.LBE250:
 10653              	.LBE307:
 10654              	.LBB308:
 10655              	.LBB200:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10656              		.loc 1 2994 0
 10657 5a48 8C2A1FE5 		ldr	r2, .L1034+116
 10658 5a4c A115D2E5 		ldrb	r1, [r2, #1441]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10659              		.loc 1 2995 0
 10660 5a50 A225D2E5 		ldrb	r2, [r2, #1442]	@ zero_extendqisi2
 10661 5a54 A5FBFFEA 		b	.L972
 10662              	.LVL1253:
 10663              	.L765:
 10664              	.LBE200:
 10665              	.LBE308:
 10666              	.LBB309:
 10667              	.LBB192:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10668              		.loc 1 2994 0
 10669 5a58 9C2A1FE5 		ldr	r2, .L1034+116
 10670 5a5c 3116D2E5 		ldrb	r1, [r2, #1585]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10671              		.loc 1 2995 0
 10672 5a60 3226D2E5 		ldrb	r2, [r2, #1586]	@ zero_extendqisi2
 10673 5a64 A1FBFFEA 		b	.L972
 10674              	.LVL1254:
 10675              	.L719:
 10676              	.LBE192:
 10677              	.LBE309:
 10678              	.LBB310:
 10679              	.LBB183:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10680              		.loc 1 2970 0
 10681 5a68 ACCA1FE5 		ldr	ip, .L1034+116
 10682 5a6c D945DCE5 		ldrb	r4, [ip, #1497]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10683              		.loc 1 2971 0
 10684 5a70 DA25DCE5 		ldrb	r2, [ip, #1498]	@ zero_extendqisi2
 10685 5a74 A1FFFFEA 		b	.L984
 10686              	.LVL1255:
 10687              	.L730:
 10688              	.LBE183:
 10689              	.LBE310:
 10690              	.LBB311:
 10691              	.LBB210:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10692              		.loc 1 2970 0
 10693 5a78 BCEA1FE5 		ldr	lr, .L1034+116
 10694 5a7c F145DEE5 		ldrb	r4, [lr, #1521]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10695              		.loc 1 2971 0
 10696 5a80 F225DEE5 		ldrb	r2, [lr, #1522]	@ zero_extendqisi2
 10697              	.LVL1256:
 10698              	.L987:
 10699              	.LBE210:
 10700              	.LBE311:
 10701              	.LBB312:
 10702              	.LBB220:
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10703              		.loc 1 2972 0
 10704 5a84 0030A0E3 		mov	r3, #0
2978:../uvc.c      **** 
 10705              		.loc 1 2978 0
 10706 5a88 0600A0E1 		mov	r0, r6
 10707 5a8c CC1A1FE5 		ldr	r1, .L1034+120
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10708              		.loc 1 2971 0
 10709 5a90 2920C7E5 		strb	r2, [r7, #41]
2972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10710              		.loc 1 2972 0
 10711 5a94 2A30C7E5 		strb	r3, [r7, #42]
2973:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10712              		.loc 1 2973 0
 10713 5a98 2B30C7E5 		strb	r3, [r7, #43]
 10714              	.LVL1257:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10715              		.loc 1 2970 0
 10716 5a9c 2840C7E5 		strb	r4, [r7, #40]
2978:../uvc.c      **** 
 10717              		.loc 1 2978 0
 10718 5aa0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10719              	.LVL1258:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10720              		.loc 1 2950 0
 10721 5aa4 FF20A0E3 		mov	r2, #255
 10722 5aa8 0230A0E1 		mov	r3, r2
 10723 5aac 20FEFFEA 		b	.L785
 10724              	.LVL1259:
 10725              	.L745:
 10726              	.LBE220:
 10727              	.LBE312:
 10728              	.LBB313:
 10729              	.LBB176:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10730              		.loc 1 2970 0
 10731 5ab0 F4CA1FE5 		ldr	ip, .L1034+116
 10732 5ab4 0946DCE5 		ldrb	r4, [ip, #1545]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10733              		.loc 1 2971 0
 10734 5ab8 0A26DCE5 		ldrb	r2, [ip, #1546]	@ zero_extendqisi2
 10735 5abc 8FFFFFEA 		b	.L984
 10736              	.LVL1260:
 10737              	.L708:
 10738              	.LBE176:
 10739              	.LBE313:
 10740              	.LBB314:
 10741              	.LBB201:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10742              		.loc 1 2970 0
 10743 5ac0 04CB1FE5 		ldr	ip, .L1034+116
 10744 5ac4 A945DCE5 		ldrb	r4, [ip, #1449]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10745              		.loc 1 2971 0
 10746 5ac8 AA25DCE5 		ldrb	r2, [ip, #1450]	@ zero_extendqisi2
 10747 5acc 8BFFFFEA 		b	.L984
 10748              	.LVL1261:
 10749              	.L767:
 10750              	.LBE201:
 10751              	.LBE314:
 10752              	.LBB315:
 10753              	.LBB193:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10754              		.loc 1 2970 0
 10755 5ad0 14CB1FE5 		ldr	ip, .L1034+116
 10756 5ad4 3946DCE5 		ldrb	r4, [ip, #1593]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10757              		.loc 1 2971 0
 10758 5ad8 3A26DCE5 		ldrb	r2, [ip, #1594]	@ zero_extendqisi2
 10759 5adc 87FFFFEA 		b	.L984
 10760              	.LVL1262:
 10761              	.L756:
 10762              	.LBE193:
 10763              	.LBE315:
 10764              	.LBB316:
 10765              	.LBB231:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10766              		.loc 1 2970 0
 10767 5ae0 241B1FE5 		ldr	r1, .L1034+116
 10768 5ae4 2146D1E5 		ldrb	r4, [r1, #1569]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10769              		.loc 1 2971 0
 10770 5ae8 2226D1E5 		ldrb	r2, [r1, #1570]	@ zero_extendqisi2
 10771 5aec 83FFFFEA 		b	.L984
 10772              	.LVL1263:
 10773              	.L778:
 10774              	.LBE231:
 10775              	.LBE316:
 10776              	.LBB317:
 10777              	.LBB221:
2970:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10778              		.loc 1 2970 0
 10779 5af0 34CB1FE5 		ldr	ip, .L1034+116
 10780 5af4 5146DCE5 		ldrb	r4, [ip, #1617]	@ zero_extendqisi2
2971:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10781              		.loc 1 2971 0
 10782 5af8 5226DCE5 		ldrb	r2, [ip, #1618]	@ zero_extendqisi2
 10783 5afc E0FFFFEA 		b	.L987
 10784              	.LVL1264:
 10785              	.L723:
 10786              	.LBE221:
 10787              	.LBE317:
 10788              	.LBB318:
 10789              	.LBB184:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10790              		.loc 1 3003 0
 10791 5b00 443B1FE5 		ldr	r3, .L1034+116
 10792 5b04 D315D3E5 		ldrb	r1, [r3, #1491]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10793              		.loc 1 3004 0
 10794 5b08 D425D3E5 		ldrb	r2, [r3, #1492]	@ zero_extendqisi2
 10795 5b0c 77FBFFEA 		b	.L972
 10796              	.LVL1265:
 10797              	.L753:
 10798              	.LBE184:
 10799              	.LBE318:
 10800              	.LBB319:
 10801              	.LBB232:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10802              		.loc 1 3163 0
 10803 5b10 0000A0E3 		mov	r0, #0
 10804 5b14 0020A0E1 		mov	r2, r0
 10805 5b18 0110A0E3 		mov	r1, #1
 10806 5b1c FEFFFFEB 		bl	CyU3PUsbStall
 10807              	.LVL1266:
3164:../uvc.c      **** 			  break;
 10808              		.loc 1 3164 0
 10809 5b20 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10810 5b24 0400A0E3 		mov	r0, #4
 10811 5b28 701B1FE5 		ldr	r1, .L1034+112
 10812 5b2c 0520A0E3 		mov	r2, #5
 10813 5b30 FEFFFFEB 		bl	CyU3PDebugPrint
 10814              	.LVL1267:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10815              		.loc 1 2950 0
 10816 5b34 FF40A0E3 		mov	r4, #255
 10817              	.LVL1268:
 10818 5b38 5DFDFFEA 		b	.L809
 10819              	.LVL1269:
 10820              	.L782:
 10821              	.LBE232:
 10822              	.LBE319:
 10823              	.LBB320:
 10824              	.LBB222:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10825              		.loc 1 3003 0
 10826 5b3c 803B1FE5 		ldr	r3, .L1034+116
 10827 5b40 4B16D3E5 		ldrb	r1, [r3, #1611]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10828              		.loc 1 3004 0
 10829 5b44 4C26D3E5 		ldrb	r2, [r3, #1612]	@ zero_extendqisi2
 10830 5b48 39FBFFEA 		b	.L970
 10831              	.LVL1270:
 10832              	.L743:
 10833              	.LBE222:
 10834              	.LBE320:
 10835              	.LBB321:
 10836              	.LBB177:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10837              		.loc 1 2994 0
 10838 5b4c 90EB1FE5 		ldr	lr, .L1034+116
 10839 5b50 0116DEE5 		ldrb	r1, [lr, #1537]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10840              		.loc 1 2995 0
 10841 5b54 0226DEE5 		ldrb	r2, [lr, #1538]	@ zero_extendqisi2
 10842 5b58 64FBFFEA 		b	.L972
 10843              	.LVL1271:
 10844              	.L728:
 10845              	.LBE177:
 10846              	.LBE321:
 10847              	.LBB322:
 10848              	.LBB211:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10849              		.loc 1 2994 0
 10850 5b5c A03B1FE5 		ldr	r3, .L1034+116
 10851 5b60 E915D3E5 		ldrb	r1, [r3, #1513]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10852              		.loc 1 2995 0
 10853 5b64 EA25D3E5 		ldrb	r2, [r3, #1514]	@ zero_extendqisi2
 10854 5b68 31FBFFEA 		b	.L970
 10855              	.LVL1272:
 10856              	.L789:
 10857              	.LBE211:
 10858              	.LBE322:
 10859              	.LBB323:
 10860              	.LBB251:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10861              		.loc 1 2994 0
 10862 5b6c B0CB1FE5 		ldr	ip, .L1034+116
 10863 5b70 6116DCE5 		ldrb	r1, [ip, #1633]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10864              		.loc 1 2995 0
 10865 5b74 6226DCE5 		ldrb	r2, [ip, #1634]	@ zero_extendqisi2
 10866 5b78 5CFBFFEA 		b	.L972
 10867              	.LVL1273:
 10868              	.L800:
 10869              	.LBE251:
 10870              	.LBE323:
 10871              	.LBB324:
 10872              	.LBB243:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10873              		.loc 1 2994 0
 10874 5b7c C03B1FE5 		ldr	r3, .L1034+116
 10875 5b80 7916D3E5 		ldrb	r1, [r3, #1657]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10876              		.loc 1 2995 0
 10877 5b84 7A26D3E5 		ldrb	r2, [r3, #1658]	@ zero_extendqisi2
 10878 5b88 58FBFFEA 		b	.L972
 10879              	.LVL1274:
 10880              	.L717:
 10881              	.LBE243:
 10882              	.LBE324:
 10883              	.LBB325:
 10884              	.LBB185:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10885              		.loc 1 2994 0
 10886 5b8c D02B1FE5 		ldr	r2, .L1034+116
 10887 5b90 D115D2E5 		ldrb	r1, [r2, #1489]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10888              		.loc 1 2995 0
 10889 5b94 D225D2E5 		ldrb	r2, [r2, #1490]	@ zero_extendqisi2
 10890 5b98 54FBFFEA 		b	.L972
 10891              	.LVL1275:
 10892              	.L776:
 10893              	.LBE185:
 10894              	.LBE325:
 10895              	.LBB326:
 10896              	.LBB223:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10897              		.loc 1 2994 0
 10898 5b9c E02B1FE5 		ldr	r2, .L1034+116
 10899 5ba0 4916D2E5 		ldrb	r1, [r2, #1609]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10900              		.loc 1 2995 0
 10901 5ba4 4A26D2E5 		ldrb	r2, [r2, #1610]	@ zero_extendqisi2
 10902 5ba8 21FBFFEA 		b	.L970
 10903              	.LVL1276:
 10904              	.L754:
 10905              	.LBE223:
 10906              	.LBE326:
 10907              	.LBB327:
 10908              	.LBB233:
2994:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10909              		.loc 1 2994 0
 10910 5bac F03B1FE5 		ldr	r3, .L1034+116
 10911 5bb0 1916D3E5 		ldrb	r1, [r3, #1561]	@ zero_extendqisi2
2995:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10912              		.loc 1 2995 0
 10913 5bb4 1A26D3E5 		ldrb	r2, [r3, #1562]	@ zero_extendqisi2
 10914 5bb8 4CFBFFEA 		b	.L972
 10915              	.LVL1277:
 10916              	.L734:
 10917              	.LBE233:
 10918              	.LBE327:
 10919              	.LBB328:
 10920              	.LBB212:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10921              		.loc 1 3003 0
 10922 5bbc 004C1FE5 		ldr	r4, .L1034+116
 10923 5bc0 EB15D4E5 		ldrb	r1, [r4, #1515]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10924              		.loc 1 3004 0
 10925 5bc4 EC25D4E5 		ldrb	r2, [r4, #1516]	@ zero_extendqisi2
 10926 5bc8 19FBFFEA 		b	.L970
 10927              	.LVL1278:
 10928              	.L716:
 10929              	.LBE212:
 10930              	.LBE328:
 10931              	.LBB329:
 10932              	.LBB186:
3163:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10933              		.loc 1 3163 0
 10934 5bcc 0000A0E3 		mov	r0, #0
 10935 5bd0 0020A0E1 		mov	r2, r0
 10936 5bd4 0110A0E3 		mov	r1, #1
 10937 5bd8 FEFFFFEB 		bl	CyU3PUsbStall
 10938              	.LVL1279:
3164:../uvc.c      **** 			  break;
 10939              		.loc 1 3164 0
 10940 5bdc 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10941 5be0 0400A0E3 		mov	r0, #4
 10942 5be4 2C1C1FE5 		ldr	r1, .L1034+112
 10943 5be8 0220A0E3 		mov	r2, #2
 10944 5bec FEFFFFEB 		bl	CyU3PDebugPrint
 10945              	.LVL1280:
2950:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10946              		.loc 1 2950 0
 10947 5bf0 FF40A0E3 		mov	r4, #255
 10948              	.LVL1281:
 10949 5bf4 2EFDFFEA 		b	.L809
 10950              	.LVL1282:
 10951              	.L771:
 10952              	.LBE186:
 10953              	.LBE329:
 10954              	.LBB330:
 10955              	.LBB194:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10956              		.loc 1 3003 0
 10957 5bf8 3C3C1FE5 		ldr	r3, .L1034+116
 10958 5bfc 3316D3E5 		ldrb	r1, [r3, #1587]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10959              		.loc 1 3004 0
 10960 5c00 3426D3E5 		ldrb	r2, [r3, #1588]	@ zero_extendqisi2
 10961 5c04 39FBFFEA 		b	.L972
 10962              	.LVL1283:
 10963              	.L712:
 10964              	.LBE194:
 10965              	.LBE330:
 10966              	.LBB331:
 10967              	.LBB202:
3003:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10968              		.loc 1 3003 0
 10969 5c08 4C3C1FE5 		ldr	r3, .L1034+116
 10970 5c0c A315D3E5 		ldrb	r1, [r3, #1443]	@ zero_extendqisi2
3004:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10971              		.loc 1 3004 0
 10972 5c10 A425D3E5 		ldrb	r2, [r3, #1444]	@ zero_extendqisi2
 10973 5c14 35FBFFEA 		b	.L972
 10974              	.LVL1284:
 10975              	.L891:
 10976              	.LBE202:
 10977              	.LBE331:
 10978              	.LBE341:
 10979              	.LBE452:
 10980              	.LBB453:
 10981              	.LBB425:
 10982              	.LBB405:
 10983              	.LBB394:
1854:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10984              		.loc 1 1854 0
 10985 5c18 020056E3 		cmp	r6, #2
1855:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10986              		.loc 1 1855 0
 10987 5c1c 4727D905 		ldreqb	r2, [r9, #1863]	@ zero_extendqisi2
1879:../uvc.c      **** 		 	 if(Len == 2){
 10988              		.loc 1 1879 0
 10989 5c20 0200A003 		moveq	r0, #2
1856:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10990              		.loc 1 1856 0
 10991 5c24 4837D905 		ldreqb	r3, [r9, #1864]	@ zero_extendqisi2
1854:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10992              		.loc 1 1854 0
 10993 5c28 0A00000A 		beq	.L978
1860:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10994              		.loc 1 1860 0
 10995 5c2c 47C7D9E5 		ldrb	ip, [r9, #1863]	@ zero_extendqisi2
1862:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10996              		.loc 1 1862 0
 10997 5c30 4827D9E5 		ldrb	r2, [r9, #1864]	@ zero_extendqisi2
 10998 5c34 6CFDFFEA 		b	.L979
 10999              	.L888:
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11000              		.loc 1 1891 0
 11001 5c38 7CEC1FE5 		ldr	lr, .L1034+116
1890:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11002              		.loc 1 1890 0
 11003 5c3c 020056E3 		cmp	r6, #2
1896:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11004              		.loc 1 1896 0
 11005 5c40 49C7DE15 		ldrneb	ip, [lr, #1865]	@ zero_extendqisi2
1898:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11006              		.loc 1 1898 0
 11007 5c44 4A27DE15 		ldrneb	r2, [lr, #1866]	@ zero_extendqisi2
1890:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11008              		.loc 1 1890 0
 11009 5c48 67FDFF1A 		bne	.L979
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11010              		.loc 1 1891 0
 11011 5c4c 4927DEE5 		ldrb	r2, [lr, #1865]	@ zero_extendqisi2
1892:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11012              		.loc 1 1892 0
 11013 5c50 4A37DEE5 		ldrb	r3, [lr, #1866]	@ zero_extendqisi2
 11014              	.L981:
1915:../uvc.c      **** 				  if(Len == 2){
 11015              		.loc 1 1915 0
 11016 5c54 0600A0E1 		mov	r0, r6
 11017              	.L978:
 11018 5c58 981C1FE5 		ldr	r1, .L1034+120
1891:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11019              		.loc 1 1891 0
 11020 5c5c 2820C7E5 		strb	r2, [r7, #40]
1892:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11021              		.loc 1 1892 0
 11022 5c60 2930C7E5 		strb	r3, [r7, #41]
 11023              	.LVL1285:
 11024              	.L980:
1918:../uvc.c      **** 				  }else{
 11025              		.loc 1 1918 0
 11026 5c64 00C0A0E3 		mov	ip, #0
 11027 5c68 24C08DE5 		str	ip, [sp, #36]
 11028 5c6c 0060A0E3 		mov	r6, #0
1915:../uvc.c      **** 				  if(Len == 2){
 11029              		.loc 1 1915 0
 11030 5c70 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11031              	.LVL1286:
1917:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11032              		.loc 1 1917 0
 11033 5c74 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11034              	.LVL1287:
1918:../uvc.c      **** 				  }else{
 11035              		.loc 1 1918 0
 11036 5c78 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11037              	.LVL1288:
 11038 5c7c 4DFEFFEA 		b	.L897
 11039              	.LVL1289:
 11040              	.L890:
1615:../uvc.c      **** 			 	 			 if(Len == 2)
 11041              		.loc 1 1615 0
 11042 5c80 CA30D7E5 		ldrb	r3, [r7, #202]	@ zero_extendqisi2
 11043 5c84 000053E3 		cmp	r3, #0
 11044 5c88 A500001A 		bne	.L1024
1631:../uvc.c      **** 			 	 			 {
 11045              		.loc 1 1631 0
 11046 5c8c 020056E3 		cmp	r6, #2
 11047 5c90 2A02000A 		beq	.L1025
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11048              		.loc 1 1639 0
 11049 5c94 040056E3 		cmp	r6, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11050              		.loc 1 1313 0
 11051 5c98 FF50A013 		movne	r5, #255
 11052              	.LVL1290:
 11053 5c9c 05C0A011 		movne	ip, r5
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11054              		.loc 1 1639 0
 11055 5ca0 1502000A 		beq	.L1026
 11056              	.LVL1291:
 11057              	.L902:
1649:../uvc.c      **** 			 	 		 }
 11058              		.loc 1 1649 0
 11059 5ca4 0130A0E3 		mov	r3, #1
 11060 5ca8 CA30C7E5 		strb	r3, [r7, #202]
 11061              	.LVL1292:
 11062              	.L900:
1846:../uvc.c      **** 
 11063              		.loc 1 1846 0
 11064 5cac 0600A0E1 		mov	r0, r6
 11065 5cb0 F01C1FE5 		ldr	r1, .L1034+120
 11066 5cb4 20C08DE5 		str	ip, [sp, #32]
 11067 5cb8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11068              	.LVL1293:
1849:../uvc.c      **** //#endif
 11069              		.loc 1 1849 0
 11070 5cbc 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11071 5cc0 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11072 5cc4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11073 5cc8 43008DE8 		stmia	sp, {r0, r1, r6}
 11074 5ccc 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11075 5cd0 0400A0E3 		mov	r0, #4
 11076 5cd4 101D1FE5 		ldr	r1, .L1034+124
 11077 5cd8 FEFFFFEB 		bl	CyU3PDebugPrint
 11078              	.LVL1294:
 11079 5cdc 00E0A0E3 		mov	lr, #0
 11080 5ce0 24E08DE5 		str	lr, [sp, #36]
 11081 5ce4 0E60A0E1 		mov	r6, lr
 11082              	.LVL1295:
 11083 5ce8 20C09DE5 		ldr	ip, [sp, #32]
 11084 5cec 31FEFFEA 		b	.L897
 11085              	.LVL1296:
 11086              	.L786:
 11087              	.LBE394:
 11088              	.LBE405:
 11089              	.LBE425:
 11090              	.LBE453:
 11091              	.LBB454:
 11092              	.LBB342:
 11093              	.LBB332:
 11094              	.LBB224:
3131:../uvc.c      **** 					  }
 11095              		.loc 1 3131 0
 11096 5cf0 0020A0E1 		mov	r2, r0
 11097 5cf4 0510A0E1 		mov	r1, r5
 11098 5cf8 FEFFFFEB 		bl	CyU3PUsbStall
 11099              	.LVL1297:
 11100 5cfc 6BFCFFEA 		b	.L787
 11101              	.LVL1298:
 11102              	.L868:
 11103              	.LBE224:
 11104              	.LBE332:
 11105              	.LBE342:
 11106              	.LBE454:
 11107              	.LBB455:
 11108              	.LBB426:
 11109              	.LBB406:
 11110              	.LBB383:
1944:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11111              		.loc 1 1944 0
 11112 5d00 3927D9E5 		ldrb	r2, [r9, #1849]	@ zero_extendqisi2
1945:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11113              		.loc 1 1945 0
 11114 5d04 0030A0E3 		mov	r3, #0
1956:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11115              		.loc 1 1956 0
 11116 5d08 0100A0E3 		mov	r0, #1
 11117 5d0c 4C1D1FE5 		ldr	r1, .L1034+120
1944:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11118              		.loc 1 1944 0
 11119 5d10 2820C7E5 		strb	r2, [r7, #40]
1945:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11120              		.loc 1 1945 0
 11121 5d14 2930C7E5 		strb	r3, [r7, #41]
1946:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11122              		.loc 1 1946 0
 11123 5d18 2A30C7E5 		strb	r3, [r7, #42]
1947:../uvc.c      **** 		 	 }
 11124              		.loc 1 1947 0
 11125 5d1c 2B30C7E5 		strb	r3, [r7, #43]
 11126              	.LVL1299:
 11127 5d20 43FEFFEA 		b	.L977
 11128              	.LVL1300:
 11129              	.L867:
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11130              		.loc 1 1926 0
 11131 5d24 37C7D9E5 		ldrb	ip, [r9, #1847]	@ zero_extendqisi2
1927:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11132              		.loc 1 1927 0
 11133 5d28 3827D9E5 		ldrb	r2, [r9, #1848]	@ zero_extendqisi2
1928:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11134              		.loc 1 1928 0
 11135 5d2c 0030A0E3 		mov	r3, #0
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11136              		.loc 1 1937 0
 11137 5d30 0600A0E1 		mov	r0, r6
 11138 5d34 741D1FE5 		ldr	r1, .L1034+120
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11139              		.loc 1 1926 0
 11140 5d38 28C0C7E5 		strb	ip, [r7, #40]
1927:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11141              		.loc 1 1927 0
 11142 5d3c 2920C7E5 		strb	r2, [r7, #41]
1928:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11143              		.loc 1 1928 0
 11144 5d40 2A30C7E5 		strb	r3, [r7, #42]
1929:../uvc.c      **** 		 	 }
 11145              		.loc 1 1929 0
 11146 5d44 2B30C7E5 		strb	r3, [r7, #43]
 11147 5d48 39FEFFEA 		b	.L977
 11148              	.LVL1301:
 11149              	.L895:
 11150              	.LBE383:
 11151              	.LBE406:
 11152              	.LBB407:
 11153              	.LBB395:
1944:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11154              		.loc 1 1944 0
 11155 5d4c 4D27D9E5 		ldrb	r2, [r9, #1869]	@ zero_extendqisi2
1945:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11156              		.loc 1 1945 0
 11157 5d50 0030A0E3 		mov	r3, #0
1956:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11158              		.loc 1 1956 0
 11159 5d54 0100A0E3 		mov	r0, #1
 11160 5d58 981D1FE5 		ldr	r1, .L1034+120
1944:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11161              		.loc 1 1944 0
 11162 5d5c 2820C7E5 		strb	r2, [r7, #40]
1945:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11163              		.loc 1 1945 0
 11164 5d60 2930C7E5 		strb	r3, [r7, #41]
1946:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11165              		.loc 1 1946 0
 11166 5d64 2A30C7E5 		strb	r3, [r7, #42]
1947:../uvc.c      **** 		 	 }
 11167              		.loc 1 1947 0
 11168 5d68 2B30C7E5 		strb	r3, [r7, #43]
 11169              	.LVL1302:
 11170 5d6c BCFFFFEA 		b	.L980
 11171              	.LVL1303:
 11172              	.L894:
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11173              		.loc 1 1926 0
 11174 5d70 B4ED1FE5 		ldr	lr, .L1034+116
1928:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11175              		.loc 1 1928 0
 11176 5d74 0030A0E3 		mov	r3, #0
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11177              		.loc 1 1926 0
 11178 5d78 4BC7DEE5 		ldrb	ip, [lr, #1867]	@ zero_extendqisi2
1927:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11179              		.loc 1 1927 0
 11180 5d7c 4C27DEE5 		ldrb	r2, [lr, #1868]	@ zero_extendqisi2
1937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11181              		.loc 1 1937 0
 11182 5d80 0600A0E1 		mov	r0, r6
 11183 5d84 C41D1FE5 		ldr	r1, .L1034+120
1926:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11184              		.loc 1 1926 0
 11185 5d88 28C0C7E5 		strb	ip, [r7, #40]
1927:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11186              		.loc 1 1927 0
 11187 5d8c 2920C7E5 		strb	r2, [r7, #41]
1928:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11188              		.loc 1 1928 0
 11189 5d90 2A30C7E5 		strb	r3, [r7, #42]
1929:../uvc.c      **** 		 	 }
 11190              		.loc 1 1929 0
 11191 5d94 2B30C7E5 		strb	r3, [r7, #43]
 11192 5d98 B1FFFFEA 		b	.L980
 11193              	.L887:
2927:../uvc.c      **** 			  break;
 11194              		.loc 1 2927 0
 11195 5d9c 0000A0E3 		mov	r0, #0
 11196 5da0 0110A0E3 		mov	r1, #1
 11197 5da4 0020A0E1 		mov	r2, r0
 11198 5da8 FEFFFFEB 		bl	CyU3PUsbStall
 11199              	.LVL1304:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11200              		.loc 1 1313 0
 11201 5dac FF50A0E3 		mov	r5, #255
 11202              	.LVL1305:
2927:../uvc.c      **** 			  break;
 11203              		.loc 1 2927 0
 11204 5db0 0010A0E3 		mov	r1, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11205              		.loc 1 1313 0
 11206 5db4 05C0A0E1 		mov	ip, r5
2927:../uvc.c      **** 			  break;
 11207              		.loc 1 2927 0
 11208 5db8 24108DE5 		str	r1, [sp, #36]
 11209 5dbc 0160A0E1 		mov	r6, r1
 11210              	.LVL1306:
 11211 5dc0 FCFDFFEA 		b	.L897
 11212              	.LVL1307:
 11213              	.L860:
 11214              	.LBE395:
 11215              	.LBE407:
 11216              	.LBB408:
 11217              	.LBB384:
 11218 5dc4 0000A0E3 		mov	r0, #0
 11219 5dc8 0110A0E3 		mov	r1, #1
 11220 5dcc 0020A0E1 		mov	r2, r0
 11221 5dd0 FEFFFFEB 		bl	CyU3PUsbStall
 11222              	.LVL1308:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11223              		.loc 1 1313 0
 11224 5dd4 FF50A0E3 		mov	r5, #255
 11225              	.LVL1309:
2927:../uvc.c      **** 			  break;
 11226              		.loc 1 2927 0
 11227 5dd8 0010A0E3 		mov	r1, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11228              		.loc 1 1313 0
 11229 5ddc 05C0A0E1 		mov	ip, r5
2927:../uvc.c      **** 			  break;
 11230              		.loc 1 2927 0
 11231 5de0 24108DE5 		str	r1, [sp, #36]
 11232 5de4 0160A0E1 		mov	r6, r1
 11233              	.LVL1310:
 11234 5de8 D8FDFFEA 		b	.L870
 11235              	.LVL1311:
 11236              	.L674:
 11237              	.LBE384:
 11238              	.LBE408:
 11239              	.LBE426:
 11240              	.LBE455:
 11241              	.LBB456:
 11242              	.LBB371:
 11243              	.LBB359:
 11244              	.LBB351:
1822:../uvc.c      **** 			 	 			 {
 11245              		.loc 1 1822 0
 11246 5dec 020055E3 		cmp	r5, #2
 11247 5df0 3D01000A 		beq	.L1027
1830:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11248              		.loc 1 1830 0
 11249 5df4 040055E3 		cmp	r5, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11250              		.loc 1 1313 0
 11251 5df8 FF40A013 		movne	r4, #255
 11252              	.LVL1312:
 11253 5dfc 04C0A011 		movne	ip, r4
1830:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11254              		.loc 1 1830 0
 11255 5e00 2801000A 		beq	.L1028
 11256              	.LVL1313:
 11257              	.L678:
1840:../uvc.c      **** 			 	 		 }
 11258              		.loc 1 1840 0
 11259 5e04 0130A0E3 		mov	r3, #1
 11260 5e08 AE30C7E5 		strb	r3, [r7, #174]
 11261              	.LVL1314:
 11262              	.L676:
1846:../uvc.c      **** 
 11263              		.loc 1 1846 0
 11264 5e0c 0500A0E1 		mov	r0, r5
 11265 5e10 501E1FE5 		ldr	r1, .L1034+120
 11266 5e14 20C08DE5 		str	ip, [sp, #32]
 11267 5e18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11268              	.LVL1315:
1849:../uvc.c      **** //#endif
 11269              		.loc 1 1849 0
 11270 5e1c 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11271 5e20 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11272 5e24 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11273 5e28 23008DE8 		stmia	sp, {r0, r1, r5}
 11274 5e2c 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11275 5e30 0400A0E3 		mov	r0, #4
 11276 5e34 701E1FE5 		ldr	r1, .L1034+124
 11277 5e38 FEFFFFEB 		bl	CyU3PDebugPrint
 11278              	.LVL1316:
 11279 5e3c 00E0A0E3 		mov	lr, #0
 11280 5e40 24E08DE5 		str	lr, [sp, #36]
 11281 5e44 0E50A0E1 		mov	r5, lr
 11282              	.LVL1317:
 11283 5e48 20C09DE5 		ldr	ip, [sp, #32]
 11284 5e4c 0E20A0E1 		mov	r2, lr
 11285 5e50 3AFBFFEA 		b	.L673
 11286              	.LVL1318:
 11287              	.L864:
 11288              	.LBE351:
 11289              	.LBE359:
 11290              	.LBE371:
 11291              	.LBE456:
 11292              	.LBB457:
 11293              	.LBB427:
 11294              	.LBB409:
 11295              	.LBB385:
1854:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11296              		.loc 1 1854 0
 11297 5e54 020056E3 		cmp	r6, #2
1855:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11298              		.loc 1 1855 0
 11299 5e58 3327D905 		ldreqb	r2, [r9, #1843]	@ zero_extendqisi2
1879:../uvc.c      **** 		 	 if(Len == 2){
 11300              		.loc 1 1879 0
 11301 5e5c 0600A001 		moveq	r0, r6
1856:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11302              		.loc 1 1856 0
 11303 5e60 3437D905 		ldreqb	r3, [r9, #1844]	@ zero_extendqisi2
1854:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11304              		.loc 1 1854 0
 11305 5e64 EFFDFF0A 		beq	.L975
1860:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11306              		.loc 1 1860 0
 11307 5e68 33C7D9E5 		ldrb	ip, [r9, #1843]	@ zero_extendqisi2
1862:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11308              		.loc 1 1862 0
 11309 5e6c 3427D9E5 		ldrb	r2, [r9, #1844]	@ zero_extendqisi2
 11310 5e70 FBF9FFEA 		b	.L976
 11311              	.L863:
1615:../uvc.c      **** 			 	 			 if(Len == 2)
 11312              		.loc 1 1615 0
 11313 5e74 C930D7E5 		ldrb	r3, [r7, #201]	@ zero_extendqisi2
 11314 5e78 000053E3 		cmp	r3, #0
 11315 5e7c 1800001A 		bne	.L1029
1631:../uvc.c      **** 			 	 			 {
 11316              		.loc 1 1631 0
 11317 5e80 020056E3 		cmp	r6, #2
 11318 5e84 8201000A 		beq	.L1030
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11319              		.loc 1 1639 0
 11320 5e88 040056E3 		cmp	r6, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11321              		.loc 1 1313 0
 11322 5e8c FF50A013 		movne	r5, #255
 11323              	.LVL1319:
 11324 5e90 05C0A011 		movne	ip, r5
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11325              		.loc 1 1639 0
 11326 5e94 6C01000A 		beq	.L1031
 11327              	.LVL1320:
 11328              	.L875:
1649:../uvc.c      **** 			 	 		 }
 11329              		.loc 1 1649 0
 11330 5e98 0130A0E3 		mov	r3, #1
 11331 5e9c C930C7E5 		strb	r3, [r7, #201]
 11332              	.LVL1321:
 11333              	.L873:
1846:../uvc.c      **** 
 11334              		.loc 1 1846 0
 11335 5ea0 0600A0E1 		mov	r0, r6
 11336 5ea4 E41E1FE5 		ldr	r1, .L1034+120
 11337 5ea8 20C08DE5 		str	ip, [sp, #32]
 11338 5eac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11339              	.LVL1322:
1849:../uvc.c      **** //#endif
 11340              		.loc 1 1849 0
 11341 5eb0 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11342 5eb4 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11343 5eb8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11344 5ebc 43008DE8 		stmia	sp, {r0, r1, r6}
 11345 5ec0 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11346 5ec4 0400A0E3 		mov	r0, #4
 11347 5ec8 041F1FE5 		ldr	r1, .L1034+124
 11348 5ecc FEFFFFEB 		bl	CyU3PDebugPrint
 11349              	.LVL1323:
 11350 5ed0 00E0A0E3 		mov	lr, #0
 11351 5ed4 24E08DE5 		str	lr, [sp, #36]
 11352 5ed8 0E60A0E1 		mov	r6, lr
 11353              	.LVL1324:
 11354 5edc 20C09DE5 		ldr	ip, [sp, #32]
 11355 5ee0 9AFDFFEA 		b	.L870
 11356              	.LVL1325:
 11357              	.L1029:
1616:../uvc.c      **** 			 	 			 {
 11358              		.loc 1 1616 0
 11359 5ee4 020056E3 		cmp	r6, #2
 11360 5ee8 7501000A 		beq	.L1032
1622:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11361              		.loc 1 1622 0
 11362 5eec 040056E3 		cmp	r6, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11363              		.loc 1 1313 0
 11364 5ef0 FF50A013 		movne	r5, #255
 11365              	.LVL1326:
 11366 5ef4 05C0A011 		movne	ip, r5
1622:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11367              		.loc 1 1622 0
 11368 5ef8 E8FFFF1A 		bne	.L873
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11369              		.loc 1 1623 0
 11370 5efc 3D27D9E5 		ldrb	r2, [r9, #1853]	@ zero_extendqisi2
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11371              		.loc 1 1625 0
 11372 5f00 3E57D9E5 		ldrb	r5, [r9, #1854]	@ zero_extendqisi2
1624:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11373              		.loc 1 1624 0
 11374 5f04 0030A0E3 		mov	r3, #0
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11375              		.loc 1 1625 0
 11376 5f08 FF5005E2 		and	r5, r5, #255
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11377              		.loc 1 1623 0
 11378 5f0c 2820CBE5 		strb	r2, [fp, #40]
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11379              		.loc 1 1625 0
 11380 5f10 2A50CBE5 		strb	r5, [fp, #42]
1627:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11381              		.loc 1 1627 0
 11382 5f14 FFC002E2 		and	ip, r2, #255
 11383              	.LVL1327:
1624:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11384              		.loc 1 1624 0
 11385 5f18 2930CBE5 		strb	r3, [fp, #41]
1626:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11386              		.loc 1 1626 0
 11387 5f1c 2B30CBE5 		strb	r3, [fp, #43]
 11388 5f20 DEFFFFEA 		b	.L873
 11389              	.LVL1328:
 11390              	.L1024:
 11391              	.LBE385:
 11392              	.LBE409:
 11393              	.LBB410:
 11394              	.LBB396:
1616:../uvc.c      **** 			 	 			 {
 11395              		.loc 1 1616 0
 11396 5f24 020056E3 		cmp	r6, #2
 11397 5f28 6C01000A 		beq	.L1033
1622:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11398              		.loc 1 1622 0
 11399 5f2c 040056E3 		cmp	r6, #4
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11400              		.loc 1 1313 0
 11401 5f30 FF50A013 		movne	r5, #255
 11402              	.LVL1329:
 11403 5f34 05C0A011 		movne	ip, r5
1622:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11404              		.loc 1 1622 0
 11405 5f38 5BFFFF1A 		bne	.L900
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11406              		.loc 1 1623 0
 11407 5f3c 5127D9E5 		ldrb	r2, [r9, #1873]	@ zero_extendqisi2
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11408              		.loc 1 1625 0
 11409 5f40 5257D9E5 		ldrb	r5, [r9, #1874]	@ zero_extendqisi2
1624:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11410              		.loc 1 1624 0
 11411 5f44 0030A0E3 		mov	r3, #0
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11412              		.loc 1 1625 0
 11413 5f48 FF5005E2 		and	r5, r5, #255
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11414              		.loc 1 1623 0
 11415 5f4c 2820C7E5 		strb	r2, [r7, #40]
1625:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11416              		.loc 1 1625 0
 11417 5f50 2A50C7E5 		strb	r5, [r7, #42]
1627:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11418              		.loc 1 1627 0
 11419 5f54 FFC002E2 		and	ip, r2, #255
 11420              	.LVL1330:
1624:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11421              		.loc 1 1624 0
 11422 5f58 2930C7E5 		strb	r3, [r7, #41]
1626:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11423              		.loc 1 1626 0
 11424 5f5c 2B30C7E5 		strb	r3, [r7, #43]
 11425 5f60 51FFFFEA 		b	.L900
 11426              	.LVL1331:
 11427              	.L906:
2919:../uvc.c      **** 			   }
 11428              		.loc 1 2919 0
 11429 5f64 38209DE5 		ldr	r2, [sp, #56]
 11430 5f68 0400A0E3 		mov	r0, #4
 11431              	.LVL1332:
 11432 5f6c A41F1FE5 		ldr	r1, .L1034+128
 11433 5f70 FEFFFFEB 		bl	CyU3PDebugPrint
 11434              	.LVL1333:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11435              		.loc 1 1313 0
 11436 5f74 FF50A0E3 		mov	r5, #255
 11437              	.LVL1334:
2919:../uvc.c      **** 			   }
 11438              		.loc 1 2919 0
 11439 5f78 00E0A0E3 		mov	lr, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11440              		.loc 1 1313 0
 11441 5f7c 05C0A0E1 		mov	ip, r5
2919:../uvc.c      **** 			   }
 11442              		.loc 1 2919 0
 11443 5f80 24E08DE5 		str	lr, [sp, #36]
 11444 5f84 0E60A0E1 		mov	r6, lr
 11445              	.LVL1335:
 11446 5f88 8AFDFFEA 		b	.L897
 11447              	.LVL1336:
 11448              	.L1023:
 11449              	.LBE396:
 11450              	.LBE410:
 11451              	.LBE427:
 11452              	.LBE457:
 11453              	.LBB458:
 11454              	.LBB372:
 11455              	.LBB360:
 11456              	.LBB352:
1809:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 11457              		.loc 1 1809 0
 11458 5f8c 2937D9E5 		ldrb	r3, [r9, #1833]	@ zero_extendqisi2
1810:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11459              		.loc 1 1810 0
 11460 5f90 2A47D9E5 		ldrb	r4, [r9, #1834]	@ zero_extendqisi2
 11461              	.LVL1337:
1809:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 11462              		.loc 1 1809 0
 11463 5f94 2830C7E5 		strb	r3, [r7, #40]
1810:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11464              		.loc 1 1810 0
 11465 5f98 FF4004E2 		and	r4, r4, #255
1811:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 11466              		.loc 1 1811 0
 11467 5f9c FFC003E2 		and	ip, r3, #255
 11468              	.LVL1338:
1810:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11469              		.loc 1 1810 0
 11470 5fa0 2940C7E5 		strb	r4, [r7, #41]
 11471 5fa4 98FFFFEA 		b	.L676
 11472              	.LVL1339:
 11473              	.L879:
 11474              	.LBE352:
 11475              	.LBE360:
 11476              	.LBE372:
 11477              	.LBE458:
 11478              	.LBB459:
 11479              	.LBB428:
 11480              	.LBB411:
 11481              	.LBB386:
2919:../uvc.c      **** 			   }
 11482              		.loc 1 2919 0
 11483 5fa8 38209DE5 		ldr	r2, [sp, #56]
 11484 5fac 0400A0E3 		mov	r0, #4
 11485              	.LVL1340:
 11486 5fb0 E81F1FE5 		ldr	r1, .L1034+128
 11487 5fb4 FEFFFFEB 		bl	CyU3PDebugPrint
 11488              	.LVL1341:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11489              		.loc 1 1313 0
 11490 5fb8 FF50A0E3 		mov	r5, #255
 11491              	.LVL1342:
2919:../uvc.c      **** 			   }
 11492              		.loc 1 2919 0
 11493 5fbc 00E0A0E3 		mov	lr, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11494              		.loc 1 1313 0
 11495 5fc0 05C0A0E1 		mov	ip, r5
2919:../uvc.c      **** 			   }
 11496              		.loc 1 2919 0
 11497 5fc4 24E08DE5 		str	lr, [sp, #36]
 11498 5fc8 0E60A0E1 		mov	r6, lr
 11499              	.LVL1343:
 11500 5fcc 5FFDFFEA 		b	.L870
 11501              	.LVL1344:
 11502              	.L1004:
 11503              	.LBE386:
 11504              	.LBE411:
 11505              	.LBE428:
 11506              	.LBE459:
 11507              	.LBB460:
 11508              	.LBB373:
 11509              	.LBB361:
 11510              	.LBB353:
1977:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11511              		.loc 1 1977 0
 11512 5fd0 2727D9E5 		ldrb	r2, [r9, #1831]	@ zero_extendqisi2
1978:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11513              		.loc 1 1978 0
 11514 5fd4 2837D9E5 		ldrb	r3, [r9, #1832]	@ zero_extendqisi2
1988:../uvc.c      **** 		 	 if(Len == 2){
 11515              		.loc 1 1988 0
 11516 5fd8 0500A0E1 		mov	r0, r5
 11517 5fdc 84159FE5 		ldr	r1, .L1036
1977:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11518              		.loc 1 1977 0
 11519 5fe0 2820C7E5 		strb	r2, [r7, #40]
1978:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11520              		.loc 1 1978 0
 11521 5fe4 2930C7E5 		strb	r3, [r7, #41]
1991:../uvc.c      **** 		 	 }else{
 11522              		.loc 1 1991 0
 11523 5fe8 00C0A0E3 		mov	ip, #0
 11524 5fec 1BFEFFEA 		b	.L963
 11525              	.LVL1345:
 11526              	.L1017:
 11527              	.LBE353:
 11528              	.LBE361:
 11529              	.LBE373:
 11530              	.LBE460:
 11531              	.LBB461:
 11532              	.LBB343:
 11533              	.LBB333:
 11534              	.LBB261:
3146:../uvc.c      **** 					  else
 11535              		.loc 1 3146 0
 11536 5ff0 0810A0E3 		mov	r1, #8
 11537              	.L973:
 11538 5ff4 0000A0E3 		mov	r0, #0
 11539 5ff8 0320A0E1 		mov	r2, r3
 11540 5ffc 00108DE5 		str	r1, [sp]
 11541 6000 04008DE5 		str	r0, [sp, #4]
 11542 6004 0C30A0E1 		mov	r3, ip
 11543 6008 30009DE5 		ldr	r0, [sp, #48]
 11544 600c 2310A0E3 		mov	r1, #35
 11545 6010 FEFFFFEB 		bl	cmdSet
 11546              	.LVL1346:
 11547 6014 13FCFFEA 		b	.L822
 11548              	.LVL1347:
 11549              	.L1016:
 11550              	.LBE261:
 11551              	.LBE333:
 11552              	.LBE343:
 11553              	.LBE461:
 11554              	.LBB462:
 11555              	.LBB374:
 11556              	.LBB362:
 11557              	.LBB354:
2898:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 11558              		.loc 1 2898 0
 11559 6018 4CC59FE5 		ldr	ip, .L1036+4
 11560 601c 0010E0E3 		mvn	r1, #0
 11561 6020 1C009CE5 		ldr	r0, [ip, #28]
 11562 6024 30C08DE5 		str	ip, [sp, #48]
 11563 6028 FEFFFFEB 		bl	_txe_mutex_get
 11564              	.LVL1348:
2899:../uvc.c      **** 								 {
 11565              		.loc 1 2899 0
 11566 602c 2937D9E5 		ldrb	r3, [r9, #1833]	@ zero_extendqisi2
 11567 6030 030055E1 		cmp	r5, r3
2526:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 11568              		.loc 1 2526 0
 11569 6034 34309D05 		ldreq	r3, [sp, #52]
2899:../uvc.c      **** 								 {
 11570              		.loc 1 2899 0
 11571 6038 0A00000A 		beq	.L688
2902:../uvc.c      **** 									 dataIdx++;
 11572              		.loc 1 2902 0
 11573 603c 34C09DE5 		ldr	ip, [sp, #52]
2901:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11574              		.loc 1 2901 0
 11575 6040 28E59FE5 		ldr	lr, .L1036+8
2902:../uvc.c      **** 									 dataIdx++;
 11576              		.loc 1 2902 0
 11577 6044 00508DE5 		str	r5, [sp]
 11578 6048 04C08DE5 		str	ip, [sp, #4]
 11579 604c 28309DE5 		ldr	r3, [sp, #40]
 11580 6050 2C209DE5 		ldr	r2, [sp, #44]
 11581 6054 30009DE5 		ldr	r0, [sp, #48]
 11582 6058 0E10A0E3 		mov	r1, #14
2901:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11583              		.loc 1 2901 0
 11584 605c 2957CEE5 		strb	r5, [lr, #1833]
2902:../uvc.c      **** 									 dataIdx++;
 11585              		.loc 1 2902 0
 11586 6060 FEFFFFEB 		bl	cmdSet
 11587              	.LVL1349:
2903:../uvc.c      **** 								 }
 11588              		.loc 1 2903 0
 11589 6064 0630A0E1 		mov	r3, r6
 11590              	.LVL1350:
 11591              	.L688:
2905:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11592              		.loc 1 2905 0
 11593 6068 2A27D9E5 		ldrb	r2, [r9, #1834]	@ zero_extendqisi2
 11594 606c 24C09DE5 		ldr	ip, [sp, #36]
 11595 6070 02005CE1 		cmp	ip, r2
 11596 6074 0800000A 		beq	.L689
2906:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11597              		.loc 1 2906 0
 11598 6078 F0E49FE5 		ldr	lr, .L1036+8
2907:../uvc.c      **** 								 }
 11599              		.loc 1 2907 0
 11600 607c 04308DE5 		str	r3, [sp, #4]
 11601 6080 00C08DE5 		str	ip, [sp]
 11602 6084 0420A0E1 		mov	r2, r4
 11603 6088 28309DE5 		ldr	r3, [sp, #40]
 11604              	.LVL1351:
 11605 608c D8049FE5 		ldr	r0, .L1036+4
 11606 6090 0E10A0E3 		mov	r1, #14
2906:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11607              		.loc 1 2906 0
 11608 6094 2AC7CEE5 		strb	ip, [lr, #1834]
2907:../uvc.c      **** 								 }
 11609              		.loc 1 2907 0
 11610 6098 FEFFFFEB 		bl	cmdSet
 11611              	.LVL1352:
 11612              	.L689:
2910:../uvc.c      **** 
 11613              		.loc 1 2910 0
 11614 609c 30409DE5 		ldr	r4, [sp, #48]
 11615              	.LVL1353:
2909:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11616              		.loc 1 2909 0
 11617 60a0 0130A0E3 		mov	r3, #1
2910:../uvc.c      **** 
 11618              		.loc 1 2910 0
 11619 60a4 1C0094E5 		ldr	r0, [r4, #28]
2909:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11620              		.loc 1 2909 0
 11621 60a8 2D37C9E5 		strb	r3, [r9, #1837]
2910:../uvc.c      **** 
 11622              		.loc 1 2910 0
 11623 60ac FEFFFFEB 		bl	_txe_mutex_put
 11624              	.LVL1354:
 11625 60b0 96FAFFEA 		b	.L687
 11626              	.LVL1355:
 11627              	.L1021:
 11628              	.LBE354:
 11629              	.LBE362:
 11630              	.LBE374:
 11631              	.LBE462:
 11632              	.LBB463:
 11633              	.LBB429:
 11634              	.LBB412:
 11635              	.LBB387:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11636              		.loc 1 2527 0
 11637 60b4 2CC09DE5 		ldr	ip, [sp, #44]
 11638 60b8 00508DE5 		str	r5, [sp]
 11639 60bc 04C08DE5 		str	ip, [sp, #4]
 11640 60c0 08608DE5 		str	r6, [sp, #8]
2521:../uvc.c      **** 				 }else{
 11641              		.loc 1 2521 0
 11642 60c4 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11643              		.loc 1 2527 0
 11644 60c8 34309DE5 		ldr	r3, [sp, #52]
 11645 60cc 0400A0E3 		mov	r0, #4
 11646              	.LVL1356:
 11647 60d0 9C149FE5 		ldr	r1, .L1036+12
 11648 60d4 2920A0E3 		mov	r2, #41
2520:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11649              		.loc 1 2520 0
 11650 60d8 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 11651              	.LVL1357:
2521:../uvc.c      **** 				 }else{
 11652              		.loc 1 2521 0
 11653 60dc 24C08DE5 		str	ip, [sp, #36]
 11654              	.LVL1358:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11655              		.loc 1 2527 0
 11656 60e0 FEFFFFEB 		bl	CyU3PDebugPrint
 11657              	.LVL1359:
2703:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11658              		.loc 1 2703 0
 11659 60e4 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
 11660 60e8 030056E1 		cmp	r6, r3
 11661 60ec 1100000A 		beq	.L882
2704:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11662              		.loc 1 2704 0
 11663 60f0 74549FE5 		ldr	r5, .L1036+4
 11664              	.LVL1360:
 11665 60f4 0010E0E3 		mvn	r1, #0
 11666 60f8 1C0095E5 		ldr	r0, [r5, #28]
 11667 60fc FEFFFFEB 		bl	_txe_mutex_get
 11668              	.LVL1361:
2705:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11669              		.loc 1 2705 0
 11670 6100 38C09DE5 		ldr	ip, [sp, #56]
 11671 6104 34209DE5 		ldr	r2, [sp, #52]
 11672 6108 04C08DE5 		str	ip, [sp, #4]
 11673 610c 2C309DE5 		ldr	r3, [sp, #44]
 11674 6110 2910A0E3 		mov	r1, #41
 11675 6114 00608DE5 		str	r6, [sp]
 11676 6118 0500A0E1 		mov	r0, r5
 11677 611c FEFFFFEB 		bl	cmdSet
 11678              	.LVL1362:
2706:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11679              		.loc 1 2706 0
 11680 6120 1C0095E5 		ldr	r0, [r5, #28]
 11681 6124 FEFFFFEB 		bl	_txe_mutex_put
 11682              	.LVL1363:
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11683              		.loc 1 2707 0
 11684 6128 40E49FE5 		ldr	lr, .L1036+8
2708:../uvc.c      **** 									 }
 11685              		.loc 1 2708 0
 11686 612c 38C09DE5 		ldr	ip, [sp, #56]
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11687              		.loc 1 2707 0
 11688 6130 3D67CEE5 		strb	r6, [lr, #1853]
2708:../uvc.c      **** 									 }
 11689              		.loc 1 2708 0
 11690 6134 3EC7CEE5 		strb	ip, [lr, #1854]
 11691              	.L882:
2710:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11692              		.loc 1 2710 0
 11693 6138 0130A0E3 		mov	r3, #1
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11694              		.loc 1 2527 0
 11695 613c 02C0A0E3 		mov	ip, #2
2710:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11696              		.loc 1 2710 0
 11697 6140 4137C9E5 		strb	r3, [r9, #1857]
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11698              		.loc 1 2527 0
 11699 6144 3CC08DE5 		str	ip, [sp, #60]
 11700 6148 88FDFFEA 		b	.L884
 11701              	.LVL1364:
 11702              	.L1019:
 11703              	.LBE387:
 11704              	.LBE412:
 11705              	.LBB413:
 11706              	.LBB397:
 11707 614c 2CC09DE5 		ldr	ip, [sp, #44]
 11708 6150 00508DE5 		str	r5, [sp]
 11709 6154 04C08DE5 		str	ip, [sp, #4]
 11710 6158 08608DE5 		str	r6, [sp, #8]
2521:../uvc.c      **** 				 }else{
 11711              		.loc 1 2521 0
 11712 615c 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11713              		.loc 1 2527 0
 11714 6160 34309DE5 		ldr	r3, [sp, #52]
 11715 6164 0400A0E3 		mov	r0, #4
 11716              	.LVL1365:
 11717 6168 04149FE5 		ldr	r1, .L1036+12
 11718 616c 2A20A0E3 		mov	r2, #42
2520:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11719              		.loc 1 2520 0
 11720 6170 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 11721              	.LVL1366:
2521:../uvc.c      **** 				 }else{
 11722              		.loc 1 2521 0
 11723 6174 24C08DE5 		str	ip, [sp, #36]
 11724              	.LVL1367:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11725              		.loc 1 2527 0
 11726 6178 FEFFFFEB 		bl	CyU3PDebugPrint
 11727              	.LVL1368:
2703:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11728              		.loc 1 2703 0
 11729 617c 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
 11730 6180 030056E1 		cmp	r6, r3
 11731 6184 1100000A 		beq	.L909
2704:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11732              		.loc 1 2704 0
 11733 6188 DC539FE5 		ldr	r5, .L1036+4
 11734              	.LVL1369:
 11735 618c 0010E0E3 		mvn	r1, #0
 11736 6190 1C0095E5 		ldr	r0, [r5, #28]
 11737 6194 FEFFFFEB 		bl	_txe_mutex_get
 11738              	.LVL1370:
2705:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11739              		.loc 1 2705 0
 11740 6198 38C09DE5 		ldr	ip, [sp, #56]
 11741 619c 34209DE5 		ldr	r2, [sp, #52]
 11742 61a0 04C08DE5 		str	ip, [sp, #4]
 11743 61a4 2C309DE5 		ldr	r3, [sp, #44]
 11744 61a8 2A10A0E3 		mov	r1, #42
 11745 61ac 00608DE5 		str	r6, [sp]
 11746 61b0 0500A0E1 		mov	r0, r5
 11747 61b4 FEFFFFEB 		bl	cmdSet
 11748              	.LVL1371:
2706:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11749              		.loc 1 2706 0
 11750 61b8 1C0095E5 		ldr	r0, [r5, #28]
 11751 61bc FEFFFFEB 		bl	_txe_mutex_put
 11752              	.LVL1372:
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11753              		.loc 1 2707 0
 11754 61c0 A8E39FE5 		ldr	lr, .L1036+8
2708:../uvc.c      **** 									 }
 11755              		.loc 1 2708 0
 11756 61c4 38C09DE5 		ldr	ip, [sp, #56]
2707:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11757              		.loc 1 2707 0
 11758 61c8 5167CEE5 		strb	r6, [lr, #1873]
2708:../uvc.c      **** 									 }
 11759              		.loc 1 2708 0
 11760 61cc 52C7CEE5 		strb	ip, [lr, #1874]
 11761              	.L909:
2710:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11762              		.loc 1 2710 0
 11763 61d0 0130A0E3 		mov	r3, #1
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11764              		.loc 1 2527 0
 11765 61d4 02C0A0E3 		mov	ip, #2
2710:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11766              		.loc 1 2710 0
 11767 61d8 5537C9E5 		strb	r3, [r9, #1877]
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11768              		.loc 1 2527 0
 11769 61dc 3CC08DE5 		str	ip, [sp, #60]
 11770 61e0 38FDFFEA 		b	.L911
 11771              	.LVL1373:
 11772              	.L1015:
 11773              	.LBE397:
 11774              	.LBE413:
 11775              	.LBE429:
 11776              	.LBE463:
 11777              	.LBB464:
 11778              	.LBB375:
 11779              	.LBB363:
 11780              	.LBB355:
 11781 61e4 28C09DE5 		ldr	ip, [sp, #40]
 11782 61e8 00408DE5 		str	r4, [sp]
 11783 61ec 04C08DE5 		str	ip, [sp, #4]
 11784 61f0 08508DE5 		str	r5, [sp, #8]
2521:../uvc.c      **** 				 }else{
 11785              		.loc 1 2521 0
 11786 61f4 2940DBE5 		ldrb	r4, [fp, #41]	@ zero_extendqisi2
 11787              	.LVL1374:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11788              		.loc 1 2527 0
 11789 61f8 2C309DE5 		ldr	r3, [sp, #44]
 11790 61fc 0400A0E3 		mov	r0, #4
 11791              	.LVL1375:
 11792 6200 6C139FE5 		ldr	r1, .L1036+12
 11793 6204 0E20A0E3 		mov	r2, #14
2520:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11794              		.loc 1 2520 0
 11795 6208 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 11796              	.LVL1376:
2521:../uvc.c      **** 				 }else{
 11797              		.loc 1 2521 0
 11798 620c 24408DE5 		str	r4, [sp, #36]
 11799              	.LVL1377:
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11800              		.loc 1 2527 0
 11801 6210 FEFFFFEB 		bl	CyU3PDebugPrint
 11802              	.LVL1378:
2889:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11803              		.loc 1 2889 0
 11804 6214 2937D9E5 		ldrb	r3, [r9, #1833]	@ zero_extendqisi2
 11805 6218 030055E1 		cmp	r5, r3
 11806 621c 1100000A 		beq	.L685
2890:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11807              		.loc 1 2890 0
 11808 6220 44439FE5 		ldr	r4, .L1036+4
 11809 6224 0010E0E3 		mvn	r1, #0
 11810 6228 1C0094E5 		ldr	r0, [r4, #28]
 11811 622c FEFFFFEB 		bl	_txe_mutex_get
 11812              	.LVL1379:
2891:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11813              		.loc 1 2891 0
 11814 6230 34C09DE5 		ldr	ip, [sp, #52]
 11815 6234 2C209DE5 		ldr	r2, [sp, #44]
 11816 6238 04C08DE5 		str	ip, [sp, #4]
 11817 623c 28309DE5 		ldr	r3, [sp, #40]
 11818 6240 0400A0E1 		mov	r0, r4
 11819 6244 0E10A0E3 		mov	r1, #14
 11820 6248 00508DE5 		str	r5, [sp]
 11821 624c FEFFFFEB 		bl	cmdSet
 11822              	.LVL1380:
2892:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11823              		.loc 1 2892 0
 11824 6250 1C0094E5 		ldr	r0, [r4, #28]
 11825 6254 FEFFFFEB 		bl	_txe_mutex_put
 11826              	.LVL1381:
2893:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11827              		.loc 1 2893 0
 11828 6258 10E39FE5 		ldr	lr, .L1036+8
2894:../uvc.c      **** 								 }
 11829              		.loc 1 2894 0
 11830 625c 34409DE5 		ldr	r4, [sp, #52]
2893:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11831              		.loc 1 2893 0
 11832 6260 2957CEE5 		strb	r5, [lr, #1833]
2894:../uvc.c      **** 								 }
 11833              		.loc 1 2894 0
 11834 6264 2A47CEE5 		strb	r4, [lr, #1834]
 11835              	.L685:
2896:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11836              		.loc 1 2896 0
 11837 6268 0130A0E3 		mov	r3, #1
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11838              		.loc 1 2527 0
 11839 626c 02C0A0E3 		mov	ip, #2
2896:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11840              		.loc 1 2896 0
 11841 6270 2D37C9E5 		strb	r3, [r9, #1837]
2527:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11842              		.loc 1 2527 0
 11843 6274 38C08DE5 		str	ip, [sp, #56]
 11844 6278 24FAFFEA 		b	.L687
 11845              	.LVL1382:
 11846              	.L682:
2919:../uvc.c      **** 			   }
 11847              		.loc 1 2919 0
 11848 627c 34209DE5 		ldr	r2, [sp, #52]
 11849 6280 0400A0E3 		mov	r0, #4
 11850              	.LVL1383:
 11851 6284 EC129FE5 		ldr	r1, .L1036+16
 11852 6288 FEFFFFEB 		bl	CyU3PDebugPrint
 11853              	.LVL1384:
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11854              		.loc 1 1313 0
 11855 628c FF40A0E3 		mov	r4, #255
 11856              	.LVL1385:
2919:../uvc.c      **** 			   }
 11857              		.loc 1 2919 0
 11858 6290 00E0A0E3 		mov	lr, #0
1313:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11859              		.loc 1 1313 0
 11860 6294 04C0A0E1 		mov	ip, r4
2919:../uvc.c      **** 			   }
 11861              		.loc 1 2919 0
 11862 6298 24E08DE5 		str	lr, [sp, #36]
 11863 629c 0E50A0E1 		mov	r5, lr
 11864              	.LVL1386:
 11865 62a0 0E20A0E1 		mov	r2, lr
 11866 62a4 25FAFFEA 		b	.L673
 11867              	.LVL1387:
 11868              	.L1028:
1831:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11869              		.loc 1 1831 0
 11870 62a8 0400A0E1 		mov	r0, r4
 11871 62ac 28109DE5 		ldr	r1, [sp, #40]
 11872 62b0 FEFFFFEB 		bl	SensorGetControl
 11873              	.LVL1388:
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11874              		.loc 1 1833 0
 11875 62b4 28109DE5 		ldr	r1, [sp, #40]
1831:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11876              		.loc 1 1831 0
 11877 62b8 0030A0E1 		mov	r3, r0
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11878              		.loc 1 1833 0
 11879 62bc 2C009DE5 		ldr	r0, [sp, #44]
1831:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11880              		.loc 1 1831 0
 11881 62c0 2830C7E5 		strb	r3, [r7, #40]
1832:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11882              		.loc 1 1832 0
 11883 62c4 2937C9E5 		strb	r3, [r9, #1833]
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11884              		.loc 1 1833 0
 11885 62c8 FEFFFFEB 		bl	SensorGetControl
 11886              	.LVL1389:
1835:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11887              		.loc 1 1835 0
 11888 62cc 0030A0E3 		mov	r3, #0
 11889 62d0 2930C7E5 		strb	r3, [r7, #41]
1836:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11890              		.loc 1 1836 0
 11891 62d4 2B30C7E5 		strb	r3, [r7, #43]
1837:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11892              		.loc 1 1837 0
 11893 62d8 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11894              	.LVL1390:
1833:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11895              		.loc 1 1833 0
 11896 62dc 0040A0E1 		mov	r4, r0
 11897              	.LVL1391:
 11898 62e0 2A00C7E5 		strb	r0, [r7, #42]
1834:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11899              		.loc 1 1834 0
 11900 62e4 2A07C9E5 		strb	r0, [r9, #1834]
 11901 62e8 C5FEFFEA 		b	.L678
 11902              	.LVL1392:
 11903              	.L1027:
1824:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11904              		.loc 1 1824 0
 11905 62ec 0400A0E1 		mov	r0, r4
 11906 62f0 28109DE5 		ldr	r1, [sp, #40]
 11907 62f4 FEFFFFEB 		bl	SensorGetControl
 11908              	.LVL1393:
1826:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11909              		.loc 1 1826 0
 11910 62f8 0040A0E3 		mov	r4, #0
 11911              	.LVL1394:
 11912 62fc 2940C7E5 		strb	r4, [r7, #41]
1825:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11913              		.loc 1 1825 0
 11914 6300 2907C9E5 		strb	r0, [r9, #1833]
1824:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11915              		.loc 1 1824 0
 11916 6304 00C0A0E1 		mov	ip, r0
 11917 6308 2800C7E5 		strb	r0, [r7, #40]
1827:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11918              		.loc 1 1827 0
 11919 630c 2A47C9E5 		strb	r4, [r9, #1834]
 11920              	.LVL1395:
 11921 6310 BBFEFFEA 		b	.L678
 11922              	.LVL1396:
 11923              	.L1022:
 11924              	.LBE355:
 11925              	.LBE363:
 11926              	.LBE375:
 11927              	.LBE464:
 11928              	.LBB465:
 11929              	.LBB430:
 11930              	.LBB414:
 11931              	.LBB388:
2712:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11932              		.loc 1 2712 0
 11933 6314 50C29FE5 		ldr	ip, .L1036+4
 11934 6318 0010E0E3 		mvn	r1, #0
 11935 631c 1C009CE5 		ldr	r0, [ip, #28]
 11936 6320 30C08DE5 		str	ip, [sp, #48]
 11937 6324 FEFFFFEB 		bl	_txe_mutex_get
 11938              	.LVL1397:
2713:../uvc.c      **** 									 {
 11939              		.loc 1 2713 0
 11940 6328 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
 11941 632c 030056E1 		cmp	r6, r3
2526:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 11942              		.loc 1 2526 0
 11943 6330 38309D05 		ldreq	r3, [sp, #56]
2713:../uvc.c      **** 									 {
 11944              		.loc 1 2713 0
 11945 6334 0A00000A 		beq	.L885
2716:../uvc.c      **** 										 dataIdx++;
 11946              		.loc 1 2716 0
 11947 6338 38C09DE5 		ldr	ip, [sp, #56]
2715:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11948              		.loc 1 2715 0
 11949 633c 2CE29FE5 		ldr	lr, .L1036+8
2716:../uvc.c      **** 										 dataIdx++;
 11950              		.loc 1 2716 0
 11951 6340 00608DE5 		str	r6, [sp]
 11952 6344 04C08DE5 		str	ip, [sp, #4]
 11953 6348 2C309DE5 		ldr	r3, [sp, #44]
 11954 634c 34209DE5 		ldr	r2, [sp, #52]
 11955 6350 30009DE5 		ldr	r0, [sp, #48]
 11956 6354 2910A0E3 		mov	r1, #41
2715:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11957              		.loc 1 2715 0
 11958 6358 3D67CEE5 		strb	r6, [lr, #1853]
2716:../uvc.c      **** 										 dataIdx++;
 11959              		.loc 1 2716 0
 11960 635c FEFFFFEB 		bl	cmdSet
 11961              	.LVL1398:
2717:../uvc.c      **** 									 }
 11962              		.loc 1 2717 0
 11963 6360 28309DE5 		ldr	r3, [sp, #40]
 11964              	.LVL1399:
 11965              	.L885:
2719:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11966              		.loc 1 2719 0
 11967 6364 3E27D9E5 		ldrb	r2, [r9, #1854]	@ zero_extendqisi2
 11968 6368 24C09DE5 		ldr	ip, [sp, #36]
 11969 636c 02005CE1 		cmp	ip, r2
 11970 6370 0800000A 		beq	.L886
2720:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11971              		.loc 1 2720 0
 11972 6374 F4E19FE5 		ldr	lr, .L1036+8
2721:../uvc.c      **** 									 }
 11973              		.loc 1 2721 0
 11974 6378 04308DE5 		str	r3, [sp, #4]
 11975 637c 00C08DE5 		str	ip, [sp]
 11976 6380 0520A0E1 		mov	r2, r5
 11977 6384 2C309DE5 		ldr	r3, [sp, #44]
 11978              	.LVL1400:
 11979 6388 DC019FE5 		ldr	r0, .L1036+4
 11980 638c 2910A0E3 		mov	r1, #41
2720:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11981              		.loc 1 2720 0
 11982 6390 3EC7CEE5 		strb	ip, [lr, #1854]
2721:../uvc.c      **** 									 }
 11983              		.loc 1 2721 0
 11984 6394 FEFFFFEB 		bl	cmdSet
 11985              	.LVL1401:
 11986              	.L886:
2724:../uvc.c      **** 
 11987              		.loc 1 2724 0
 11988 6398 30C09DE5 		ldr	ip, [sp, #48]
2723:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11989              		.loc 1 2723 0
 11990 639c 0130A0E3 		mov	r3, #1
2724:../uvc.c      **** 
 11991              		.loc 1 2724 0
 11992 63a0 1C009CE5 		ldr	r0, [ip, #28]
2723:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11993              		.loc 1 2723 0
 11994 63a4 4137C9E5 		strb	r3, [r9, #1857]
2724:../uvc.c      **** 
 11995              		.loc 1 2724 0
 11996 63a8 FEFFFFEB 		bl	_txe_mutex_put
 11997              	.LVL1402:
 11998 63ac EFFCFFEA 		b	.L884
 11999              	.LVL1403:
 12000              	.L1020:
 12001              	.LBE388:
 12002              	.LBE414:
 12003              	.LBB415:
 12004              	.LBB398:
2712:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 12005              		.loc 1 2712 0
 12006 63b0 B4C19FE5 		ldr	ip, .L1036+4
 12007 63b4 0010E0E3 		mvn	r1, #0
 12008 63b8 1C009CE5 		ldr	r0, [ip, #28]
 12009 63bc 30C08DE5 		str	ip, [sp, #48]
 12010 63c0 FEFFFFEB 		bl	_txe_mutex_get
 12011              	.LVL1404:
2713:../uvc.c      **** 									 {
 12012              		.loc 1 2713 0
 12013 63c4 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
 12014 63c8 030056E1 		cmp	r6, r3
2526:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 12015              		.loc 1 2526 0
 12016 63cc 38309D05 		ldreq	r3, [sp, #56]
2713:../uvc.c      **** 									 {
 12017              		.loc 1 2713 0
 12018 63d0 0A00000A 		beq	.L912
2716:../uvc.c      **** 										 dataIdx++;
 12019              		.loc 1 2716 0
 12020 63d4 38C09DE5 		ldr	ip, [sp, #56]
2715:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12021              		.loc 1 2715 0
 12022 63d8 90E19FE5 		ldr	lr, .L1036+8
2716:../uvc.c      **** 										 dataIdx++;
 12023              		.loc 1 2716 0
 12024 63dc 00608DE5 		str	r6, [sp]
 12025 63e0 04C08DE5 		str	ip, [sp, #4]
 12026 63e4 2C309DE5 		ldr	r3, [sp, #44]
 12027 63e8 34209DE5 		ldr	r2, [sp, #52]
 12028 63ec 30009DE5 		ldr	r0, [sp, #48]
 12029 63f0 2A10A0E3 		mov	r1, #42
2715:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12030              		.loc 1 2715 0
 12031 63f4 5167CEE5 		strb	r6, [lr, #1873]
2716:../uvc.c      **** 										 dataIdx++;
 12032              		.loc 1 2716 0
 12033 63f8 FEFFFFEB 		bl	cmdSet
 12034              	.LVL1405:
2717:../uvc.c      **** 									 }
 12035              		.loc 1 2717 0
 12036 63fc 0130A0E3 		mov	r3, #1
 12037              	.LVL1406:
 12038              	.L912:
2719:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 12039              		.loc 1 2719 0
 12040 6400 5227D9E5 		ldrb	r2, [r9, #1874]	@ zero_extendqisi2
 12041 6404 24C09DE5 		ldr	ip, [sp, #36]
 12042 6408 02005CE1 		cmp	ip, r2
 12043 640c 0800000A 		beq	.L913
2720:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12044              		.loc 1 2720 0
 12045 6410 58E19FE5 		ldr	lr, .L1036+8
2721:../uvc.c      **** 									 }
 12046              		.loc 1 2721 0
 12047 6414 04308DE5 		str	r3, [sp, #4]
 12048 6418 00C08DE5 		str	ip, [sp]
 12049 641c 0520A0E1 		mov	r2, r5
 12050 6420 2C309DE5 		ldr	r3, [sp, #44]
 12051              	.LVL1407:
 12052 6424 40019FE5 		ldr	r0, .L1036+4
 12053 6428 2A10A0E3 		mov	r1, #42
2720:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12054              		.loc 1 2720 0
 12055 642c 52C7CEE5 		strb	ip, [lr, #1874]
2721:../uvc.c      **** 									 }
 12056              		.loc 1 2721 0
 12057 6430 FEFFFFEB 		bl	cmdSet
 12058              	.LVL1408:
 12059              	.L913:
2724:../uvc.c      **** 
 12060              		.loc 1 2724 0
 12061 6434 30C09DE5 		ldr	ip, [sp, #48]
2723:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12062              		.loc 1 2723 0
 12063 6438 0130A0E3 		mov	r3, #1
2724:../uvc.c      **** 
 12064              		.loc 1 2724 0
 12065 643c 1C009CE5 		ldr	r0, [ip, #28]
2723:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12066              		.loc 1 2723 0
 12067 6440 5537C9E5 		strb	r3, [r9, #1877]
2724:../uvc.c      **** 
 12068              		.loc 1 2724 0
 12069 6444 FEFFFFEB 		bl	_txe_mutex_put
 12070              	.LVL1409:
 12071 6448 9EFCFFEA 		b	.L911
 12072              	.LVL1410:
 12073              	.L1031:
 12074              	.LBE398:
 12075              	.LBE415:
 12076              	.LBB416:
 12077              	.LBB389:
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12078              		.loc 1 1640 0
 12079 644c 0500A0E1 		mov	r0, r5
 12080 6450 2C109DE5 		ldr	r1, [sp, #44]
 12081 6454 1C308DE5 		str	r3, [sp, #28]
 12082 6458 FEFFFFEB 		bl	SensorGetControl
 12083              	.LVL1411:
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12084              		.loc 1 1642 0
 12085 645c 2C109DE5 		ldr	r1, [sp, #44]
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12086              		.loc 1 1640 0
 12087 6460 0020A0E1 		mov	r2, r0
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12088              		.loc 1 1642 0
 12089 6464 34009DE5 		ldr	r0, [sp, #52]
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12090              		.loc 1 1640 0
 12091 6468 2820CBE5 		strb	r2, [fp, #40]
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12092              		.loc 1 1641 0
 12093 646c 3D27C9E5 		strb	r2, [r9, #1853]
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12094              		.loc 1 1642 0
 12095 6470 FEFFFFEB 		bl	SensorGetControl
 12096              	.LVL1412:
1646:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12097              		.loc 1 1646 0
 12098 6474 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 12099              	.LVL1413:
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12100              		.loc 1 1642 0
 12101 6478 2A00CBE5 		strb	r0, [fp, #42]
1644:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12102              		.loc 1 1644 0
 12103 647c 1C309DE5 		ldr	r3, [sp, #28]
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12104              		.loc 1 1642 0
 12105 6480 0050A0E1 		mov	r5, r0
 12106              	.LVL1414:
1643:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12107              		.loc 1 1643 0
 12108 6484 3E07C9E5 		strb	r0, [r9, #1854]
1644:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12109              		.loc 1 1644 0
 12110 6488 2930CBE5 		strb	r3, [fp, #41]
1645:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12111              		.loc 1 1645 0
 12112 648c 2B30CBE5 		strb	r3, [fp, #43]
 12113 6490 80FEFFEA 		b	.L875
 12114              	.LVL1415:
 12115              	.L1030:
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12116              		.loc 1 1633 0
 12117 6494 0500A0E1 		mov	r0, r5
 12118 6498 2C109DE5 		ldr	r1, [sp, #44]
 12119 649c 1C308DE5 		str	r3, [sp, #28]
 12120 64a0 FEFFFFEB 		bl	SensorGetControl
 12121              	.LVL1416:
 12122 64a4 2800CBE5 		strb	r0, [fp, #40]
1635:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12123              		.loc 1 1635 0
 12124 64a8 1C309DE5 		ldr	r3, [sp, #28]
1634:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12125              		.loc 1 1634 0
 12126 64ac 3D07C9E5 		strb	r0, [r9, #1853]
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12127              		.loc 1 1633 0
 12128 64b0 00C0A0E1 		mov	ip, r0
1635:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12129              		.loc 1 1635 0
 12130 64b4 2930CBE5 		strb	r3, [fp, #41]
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12131              		.loc 1 1636 0
 12132 64b8 3E37C9E5 		strb	r3, [r9, #1854]
 12133              	.LVL1417:
1638:../uvc.c      **** 			 	 			 }else if(Len == 4){
 12134              		.loc 1 1638 0
 12135 64bc 0350A0E1 		mov	r5, r3
 12136              	.LVL1418:
 12137 64c0 74FEFFEA 		b	.L875
 12138              	.LVL1419:
 12139              	.L1032:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12140              		.loc 1 1618 0
 12141 64c4 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12142              		.loc 1 1619 0
 12143 64c8 3E57D9E5 		ldrb	r5, [r9, #1854]	@ zero_extendqisi2
 12144              	.LVL1420:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12145              		.loc 1 1618 0
 12146 64cc 2830CBE5 		strb	r3, [fp, #40]
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12147              		.loc 1 1619 0
 12148 64d0 FF5005E2 		and	r5, r5, #255
1620:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12149              		.loc 1 1620 0
 12150 64d4 FFC003E2 		and	ip, r3, #255
 12151              	.LVL1421:
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12152              		.loc 1 1619 0
 12153 64d8 2950CBE5 		strb	r5, [fp, #41]
 12154 64dc 6FFEFFEA 		b	.L873
 12155              	.LVL1422:
 12156              	.L1033:
 12157              	.LBE389:
 12158              	.LBE416:
 12159              	.LBB417:
 12160              	.LBB399:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12161              		.loc 1 1618 0
 12162 64e0 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12163              		.loc 1 1619 0
 12164 64e4 5257D9E5 		ldrb	r5, [r9, #1874]	@ zero_extendqisi2
 12165              	.LVL1423:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12166              		.loc 1 1618 0
 12167 64e8 2830C7E5 		strb	r3, [r7, #40]
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12168              		.loc 1 1619 0
 12169 64ec FF5005E2 		and	r5, r5, #255
1620:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12170              		.loc 1 1620 0
 12171 64f0 FFC003E2 		and	ip, r3, #255
 12172              	.LVL1424:
1619:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12173              		.loc 1 1619 0
 12174 64f4 2950C7E5 		strb	r5, [r7, #41]
 12175 64f8 EBFDFFEA 		b	.L900
 12176              	.LVL1425:
 12177              	.L1026:
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12178              		.loc 1 1640 0
 12179 64fc 0500A0E1 		mov	r0, r5
 12180 6500 2C109DE5 		ldr	r1, [sp, #44]
 12181 6504 FEFFFFEB 		bl	SensorGetControl
 12182              	.LVL1426:
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12183              		.loc 1 1642 0
 12184 6508 2C109DE5 		ldr	r1, [sp, #44]
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12185              		.loc 1 1640 0
 12186 650c 0030A0E1 		mov	r3, r0
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12187              		.loc 1 1642 0
 12188 6510 34009DE5 		ldr	r0, [sp, #52]
1640:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12189              		.loc 1 1640 0
 12190 6514 2830C7E5 		strb	r3, [r7, #40]
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12191              		.loc 1 1641 0
 12192 6518 5137C9E5 		strb	r3, [r9, #1873]
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12193              		.loc 1 1642 0
 12194 651c FEFFFFEB 		bl	SensorGetControl
 12195              	.LVL1427:
1644:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12196              		.loc 1 1644 0
 12197 6520 0030A0E3 		mov	r3, #0
 12198 6524 2930C7E5 		strb	r3, [r7, #41]
1645:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12199              		.loc 1 1645 0
 12200 6528 2B30C7E5 		strb	r3, [r7, #43]
1646:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12201              		.loc 1 1646 0
 12202 652c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 12203              	.LVL1428:
1642:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12204              		.loc 1 1642 0
 12205 6530 0050A0E1 		mov	r5, r0
 12206              	.LVL1429:
 12207 6534 2A00C7E5 		strb	r0, [r7, #42]
1643:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12208              		.loc 1 1643 0
 12209 6538 5207C9E5 		strb	r0, [r9, #1874]
 12210 653c D8FDFFEA 		b	.L902
 12211              	.LVL1430:
 12212              	.L1025:
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12213              		.loc 1 1633 0
 12214 6540 0500A0E1 		mov	r0, r5
 12215 6544 2C109DE5 		ldr	r1, [sp, #44]
 12216 6548 FEFFFFEB 		bl	SensorGetControl
 12217              	.LVL1431:
1635:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12218              		.loc 1 1635 0
 12219 654c 0050A0E3 		mov	r5, #0
 12220              	.LVL1432:
 12221 6550 2950C7E5 		strb	r5, [r7, #41]
1634:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12222              		.loc 1 1634 0
 12223 6554 5107C9E5 		strb	r0, [r9, #1873]
1633:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12224              		.loc 1 1633 0
 12225 6558 00C0A0E1 		mov	ip, r0
 12226 655c 2800C7E5 		strb	r0, [r7, #40]
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12227              		.loc 1 1636 0
 12228 6560 5257C9E5 		strb	r5, [r9, #1874]
 12229              	.LVL1433:
 12230 6564 CEFDFFEA 		b	.L902
 12231              	.L1037:
 12232              		.align	2
 12233              	.L1036:
 12234 6568 28000000 		.word	.LANCHOR0+40
 12235 656c 00000000 		.word	cmdQu
 12236 6570 00000000 		.word	.LANCHOR1
 12237 6574 68040000 		.word	.LC27
 12238 6578 AC050000 		.word	.LC33
 12239              	.LBE399:
 12240              	.LBE417:
 12241              	.LBE430:
 12242              	.LBE465:
 12243              		.cfi_endproc
 12244              	.LFE25:
 12246              		.align	2
 12247              		.global	CyFxGpifCB
 12249              	CyFxGpifCB:
 12250              	.LFB13:
3693:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12251              		.loc 1 3693 0
 12252              		.cfi_startproc
 12253              		@ args = 0, pretend = 0, frame = 0
 12254              		@ frame_needed = 0, uses_anonymous_args = 0
3694:../uvc.c      ****     {
 12255              		.loc 1 3694 0
 12256 657c 010050E3 		cmp	r0, #1
3693:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12257              		.loc 1 3693 0
 12258 6580 10402DE9 		stmfd	sp!, {r4, lr}
 12259              	.LCFI29:
 12260              		.cfi_def_cfa_offset 8
 12261              		.cfi_offset 4, -8
 12262              		.cfi_offset 14, -4
3694:../uvc.c      ****     {
 12263              		.loc 1 3694 0
 12264 6584 1080BD18 		ldmnefd	sp!, {r4, pc}
 12265              	.LBB470:
 12266              	.LBB471:
3591:../uvc.c      ****     {
 12267              		.loc 1 3591 0
 12268 6588 C4309FE5 		ldr	r3, .L1055
 12269 658c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12270 6590 030053E3 		cmp	r3, #3
 12271 6594 1000000A 		beq	.L1054
3617:../uvc.c      ****     {
 12272              		.loc 1 3617 0
 12273 6598 020053E3 		cmp	r3, #2
 12274 659c 1080BD18 		ldmnefd	sp!, {r4, pc}
3619:../uvc.c      ****         {
 12275              		.loc 1 3619 0
 12276 65a0 083041E2 		sub	r3, r1, #8
 12277 65a4 0A0053E3 		cmp	r3, #10
 12278 65a8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12279 65ac 200000EA 		b	.L1047
 12280              	.L1049:
 12281 65b0 2C660000 		.word	.L1042
 12282 65b4 34660000 		.word	.L1047
 12283 65b8 34660000 		.word	.L1047
 12284 65bc FC650000 		.word	.L1038
 12285 65c0 34660000 		.word	.L1047
 12286 65c4 34660000 		.word	.L1047
 12287 65c8 34660000 		.word	.L1047
 12288 65cc 00660000 		.word	.L1053
 12289 65d0 34660000 		.word	.L1047
 12290 65d4 34660000 		.word	.L1047
 12291 65d8 FC650000 		.word	.L1038
 12292              	.L1054:
3593:../uvc.c      ****         {
 12293              		.loc 1 3593 0
 12294 65dc 0B1041E2 		sub	r1, r1, #11
 12295 65e0 030051E3 		cmp	r1, #3
 12296 65e4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12297 65e8 150000EA 		b	.L1041
 12298              	.L1043:
 12299 65ec 2C660000 		.word	.L1042
 12300 65f0 00660000 		.word	.L1053
 12301 65f4 FC650000 		.word	.L1038
 12302 65f8 FC650000 		.word	.L1038
 12303              	.L1038:
 12304 65fc 1080BDE8 		ldmfd	sp!, {r4, pc}
 12305              	.L1053:
3619:../uvc.c      ****         {
 12306              		.loc 1 3619 0
 12307 6600 0110A0E3 		mov	r1, #1
 12308              	.L1044:
3676:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12309              		.loc 1 3676 0
 12310 6604 4C009FE5 		ldr	r0, .L1055+4
 12311 6608 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3677:../uvc.c      ****         {
 12312              		.loc 1 3677 0
 12313 660c 004050E2 		subs	r4, r0, #0
 12314 6610 1080BD08 		ldmeqfd	sp!, {r4, pc}
3679:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12315              		.loc 1 3679 0
 12316 6614 0400A0E3 		mov	r0, #4
 12317 6618 3C109FE5 		ldr	r1, .L1055+8
 12318 661c 0420A0E1 		mov	r2, r4
 12319 6620 FEFFFFEB 		bl	CyU3PDebugPrint
3680:../uvc.c      ****         }
 12320              		.loc 1 3680 0
 12321 6624 0400A0E1 		mov	r0, r4
 12322 6628 FEFFFFEB 		bl	CyFxAppErrorHandler
 12323              	.L1042:
3593:../uvc.c      ****         {
 12324              		.loc 1 3593 0
 12325 662c 0010A0E3 		mov	r1, #0
 12326 6630 F3FFFFEA 		b	.L1044
 12327              	.L1047:
3665:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12328              		.loc 1 3665 0
 12329 6634 0120A0E1 		mov	r2, r1
 12330 6638 0100A0E3 		mov	r0, #1
 12331 663c 1C109FE5 		ldr	r1, .L1055+12
 12332 6640 FEFFFFEB 		bl	CyU3PDebugPrint
 12333              	.L1041:
 12334              	.LBE471:
 12335              	.LBE470:
 12336              	.LBB472:
 12337              	.LBB473:
3700:../uvc.c      ****     }
 12338              		.loc 1 3700 0
 12339 6644 0400A0E3 		mov	r0, #4
 12340 6648 14109FE5 		ldr	r1, .L1055+16
 12341              	.LBE473:
 12342              	.LBE472:
3703:../uvc.c      **** 
 12343              		.loc 1 3703 0
 12344 664c 1040BDE8 		ldmfd	sp!, {r4, lr}
 12345              	.LBB475:
 12346              	.LBB474:
3700:../uvc.c      ****     }
 12347              		.loc 1 3700 0
 12348 6650 FEFFFFEA 		b	CyU3PDebugPrint
 12349              	.L1056:
 12350              		.align	2
 12351              	.L1055:
 12352 6654 00000000 		.word	.LANCHOR0
 12353 6658 00000000 		.word	glChHandleUVCStream
 12354 665c CC0D0000 		.word	.LC79
 12355 6660 B40D0000 		.word	.LC78
 12356 6664 FC0D0000 		.word	.LC80
 12357              	.LBE474:
 12358              	.LBE475:
 12359              		.cfi_endproc
 12360              	.LFE13:
 12362              		.align	2
 12363              		.global	CyFxApplicationDefine
 12365              	CyFxApplicationDefine:
 12366              	.LFB27:
5925:../uvc.c      **** }
5926:../uvc.c      **** 
5927:../uvc.c      **** 
5928:../uvc.c      **** /*
5929:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5930:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5931:../uvc.c      ****  */
5932:../uvc.c      **** void
5933:../uvc.c      **** CyFxApplicationDefine (
5934:../uvc.c      ****         void)
5935:../uvc.c      **** {
 12367              		.loc 1 5935 0
 12368              		.cfi_startproc
 12369              		@ args = 0, pretend = 0, frame = 32
 12370              		@ frame_needed = 0, uses_anonymous_args = 0
 12371              	.LVL1434:
 12372 6668 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12373              	.LCFI30:
 12374              		.cfi_def_cfa_offset 32
 12375              		.cfi_offset 4, -32
 12376              		.cfi_offset 5, -28
 12377              		.cfi_offset 6, -24
 12378              		.cfi_offset 7, -20
 12379              		.cfi_offset 8, -16
 12380              		.cfi_offset 9, -12
 12381              		.cfi_offset 10, -8
 12382              		.cfi_offset 14, -4
5936:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5937:../uvc.c      ****     uint32_t retThrdCreate;
5938:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5939:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5940:../uvc.c      **** 
5941:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5942:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12383              		.loc 1 5942 0
 12384 666c 010AA0E3 		mov	r0, #4096
5935:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12385              		.loc 1 5935 0
 12386 6670 40D04DE2 		sub	sp, sp, #64
 12387              	.LCFI31:
 12388              		.cfi_def_cfa_offset 96
 12389              		.loc 1 5942 0
 12390 6674 FEFFFFEB 		bl	CyU3PMemAlloc
 12391              	.LVL1435:
 12392 6678 0070A0E1 		mov	r7, r0
 12393              	.LVL1436:
5943:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12394              		.loc 1 5943 0
 12395 667c 010AA0E3 		mov	r0, #4096
 12396              	.LVL1437:
 12397 6680 FEFFFFEB 		bl	CyU3PMemAlloc
 12398              	.LVL1438:
 12399 6684 0060A0E1 		mov	r6, r0
 12400              	.LVL1439:
5944:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12401              		.loc 1 5944 0
 12402 6688 010AA0E3 		mov	r0, #4096
 12403              	.LVL1440:
 12404 668c FEFFFFEB 		bl	CyU3PMemAlloc
 12405              	.LVL1441:
5945:../uvc.c      **** 
5946:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12406              		.loc 1 5946 0
 12407 6690 000056E3 		cmp	r6, #0
 12408 6694 00005713 		cmpne	r7, #0
 12409 6698 00A0A013 		movne	r10, #0
 12410 669c 01A0A003 		moveq	r10, #1
5944:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12411              		.loc 1 5944 0
 12412 66a0 0090A0E1 		mov	r9, r0
 12413              	.LVL1442:
 12414              		.loc 1 5946 0
 12415 66a4 0000001A 		bne	.L1068
 12416              	.LVL1443:
 12417              	.L1058:
 12418              	.L1060:
 12419 66a8 FEFFFFEA 		b	.L1060
 12420              	.LVL1444:
 12421              	.L1068:
 12422              		.loc 1 5946 0 is_stmt 0 discriminator 1
 12423 66ac 000050E3 		cmp	r0, #0
 12424 66b0 FCFFFF0A 		beq	.L1058
 12425              	.LVL1445:
5947:../uvc.c      ****         goto fatalErrorHandler;
5948:../uvc.c      **** 
5949:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5950:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5951:../uvc.c      ****     char *staName = "I2CstaQue";
5952:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12426              		.loc 1 5952 0 is_stmt 1
 12427 66b4 F4309FE5 		ldr	r3, .L1069
 12428 66b8 20008DE2 		add	r0, sp, #32
 12429              	.LVL1446:
 12430 66bc 00308DE5 		str	r3, [sp]
 12431 66c0 4010A0E3 		mov	r1, #64
 12432 66c4 E8209FE5 		ldr	r2, .L1069+4
 12433 66c8 0A30A0E1 		mov	r3, r10
 12434 66cc FEFFFFEB 		bl	cmdbufCreate
 12435              	.LVL1447:
 12436 66d0 20E08DE2 		add	lr, sp, #32
 12437 66d4 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12438 66d8 D8C09FE5 		ldr	ip, .L1069+8
5953:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5954:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5955:../uvc.c      **** 
5956:../uvc.c      **** 	/****** initialize command descriptor ***********/
5957:../uvc.c      **** 	cmdquInit(cmdQuptr);
5958:../uvc.c      **** 	cmdquInit(statQuptr);
5959:../uvc.c      **** 
5960:../uvc.c      ****     /* Create the UVC application thread. */
5961:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12439              		.loc 1 5961 0
 12440 66dc 0840A0E3 		mov	r4, #8
5952:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12441              		.loc 1 5952 0
 12442 66e0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12443 66e4 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12444              		.loc 1 5961 0
 12445 66e8 0150A0E3 		mov	r5, #1
5952:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12446              		.loc 1 5952 0
 12447 66ec 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5957:../uvc.c      **** 	cmdquInit(statQuptr);
 12448              		.loc 1 5957 0
 12449 66f0 10004CE2 		sub	r0, ip, #16
 12450 66f4 FEFFFFEB 		bl	cmdquInit
 12451              	.LVL1448:
5958:../uvc.c      **** 
 12452              		.loc 1 5958 0
 12453 66f8 BC009FE5 		ldr	r0, .L1069+12
 12454 66fc FEFFFFEB 		bl	cmdquInit
 12455              	.LVL1449:
 12456              		.loc 1 5961 0
 12457 6700 A880A0E3 		mov	r8, #168
 12458 6704 012AA0E3 		mov	r2, #4096
 12459 6708 0A30A0E1 		mov	r3, r10
 12460 670c 14008DE9 		stmib	sp, {r2, r4}
 12461 6710 A8009FE5 		ldr	r0, .L1069+16
 12462 6714 00708DE5 		str	r7, [sp]
 12463 6718 10A08DE5 		str	r10, [sp, #16]
 12464 671c 0C408DE5 		str	r4, [sp, #12]
 12465 6720 14508DE5 		str	r5, [sp, #20]
 12466 6724 18808DE5 		str	r8, [sp, #24]
 12467 6728 94109FE5 		ldr	r1, .L1069+20
 12468 672c 94209FE5 		ldr	r2, .L1069+24
 12469 6730 FEFFFFEB 		bl	_txe_thread_create
 12470              	.LVL1450:
5962:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5963:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5964:../uvc.c      ****             0,                                          /* No input parameter to thread */
5965:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5966:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5967:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5968:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5969:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5970:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5971:../uvc.c      ****             );
5972:../uvc.c      ****     if (retThrdCreate != 0)
 12471              		.loc 1 5972 0
 12472 6734 003050E2 		subs	r3, r0, #0
 12473 6738 DAFFFF1A 		bne	.L1058
5973:../uvc.c      ****     {
5974:../uvc.c      ****         goto fatalErrorHandler;
5975:../uvc.c      ****     }
5976:../uvc.c      **** 
5977:../uvc.c      ****     /* Create the control request handling thread. */
5978:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12474              		.loc 1 5978 0
 12475 673c 027BA0E3 		mov	r7, #2048
 12476              	.LVL1451:
 12477 6740 10308DE5 		str	r3, [sp, #16]
 12478 6744 00608DE5 		str	r6, [sp]
 12479 6748 08408DE5 		str	r4, [sp, #8]
 12480 674c 0C408DE5 		str	r4, [sp, #12]
 12481 6750 14508DE5 		str	r5, [sp, #20]
 12482 6754 18808DE5 		str	r8, [sp, #24]
 12483 6758 04708DE5 		str	r7, [sp, #4]
 12484 675c 68009FE5 		ldr	r0, .L1069+28
 12485              	.LVL1452:
 12486 6760 68109FE5 		ldr	r1, .L1069+32
 12487 6764 68209FE5 		ldr	r2, .L1069+36
 12488 6768 FEFFFFEB 		bl	_txe_thread_create
 12489              	.LVL1453:
5979:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5980:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5981:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5982:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5983:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5984:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5985:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5986:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5987:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5988:../uvc.c      ****             );
5989:../uvc.c      ****     if (retThrdCreate != 0)
 12490              		.loc 1 5989 0
 12491 676c 003050E2 		subs	r3, r0, #0
 12492 6770 CCFFFF1A 		bne	.L1058
5990:../uvc.c      ****     {
5991:../uvc.c      ****         goto fatalErrorHandler;
5992:../uvc.c      ****     }
5993:../uvc.c      **** #if 1
5994:../uvc.c      ****     /* Create the I2C control command handling thread. */
5995:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12493              		.loc 1 5995 0
 12494 6774 00908DE5 		str	r9, [sp]
 12495 6778 04708DE5 		str	r7, [sp, #4]
 12496 677c 08408DE5 		str	r4, [sp, #8]
 12497 6780 0C408DE5 		str	r4, [sp, #12]
 12498 6784 10308DE5 		str	r3, [sp, #16]
 12499 6788 14508DE5 		str	r5, [sp, #20]
 12500 678c 18808DE5 		str	r8, [sp, #24]
 12501 6790 40009FE5 		ldr	r0, .L1069+40
 12502              	.LVL1454:
 12503 6794 40109FE5 		ldr	r1, .L1069+44
 12504 6798 40209FE5 		ldr	r2, .L1069+48
 12505 679c FEFFFFEB 		bl	_txe_thread_create
 12506              	.LVL1455:
5996:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5997:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5998:../uvc.c      ****             0,                                          /* No input parameter to thread */
5999:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
6000:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
6001:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
6002:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
6003:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
6004:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
6005:../uvc.c      ****             );
6006:../uvc.c      ****     if (retThrdCreate != 0)
 12507              		.loc 1 6006 0
 12508 67a0 000050E3 		cmp	r0, #0
 12509 67a4 BFFFFF1A 		bne	.L1058
6007:../uvc.c      ****     {
6008:../uvc.c      ****         goto fatalErrorHandler;
6009:../uvc.c      ****     }
6010:../uvc.c      **** #endif
6011:../uvc.c      **** 
6012:../uvc.c      ****     return;
6013:../uvc.c      **** 
6014:../uvc.c      **** fatalErrorHandler:
6015:../uvc.c      ****     /* Add custom recovery or debug actions here */
6016:../uvc.c      ****     /* Loop indefinitely */
6017:../uvc.c      ****     while (1);
6018:../uvc.c      **** }
 12510              		.loc 1 6018 0
 12511 67a8 40D08DE2 		add	sp, sp, #64
 12512              		@ sp needed
 12513 67ac F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12514              	.LVL1456:
 12515              	.L1070:
 12516              		.align	2
 12517              	.L1069:
 12518 67b0 00000000 		.word	cmdQuMux
 12519 67b4 140E0000 		.word	.LC81
 12520 67b8 00000000 		.word	cmdQu
 12521 67bc 00000000 		.word	statQu
 12522 67c0 E4000000 		.word	.LANCHOR0+228
 12523 67c4 200E0000 		.word	.LC82
 12524 67c8 00000000 		.word	UVCAppThread_Entry
 12525 67cc 8C010000 		.word	.LANCHOR0+396
 12526 67d0 340E0000 		.word	.LC83
 12527 67d4 00000000 		.word	UVCAppEP0Thread_Entry
 12528 67d8 34020000 		.word	.LANCHOR0+564
 12529 67dc 4C0E0000 		.word	.LC84
 12530 67e0 00000000 		.word	I2cAppThread_Entry
 12531              		.cfi_endproc
 12532              	.LFE27:
 12534              		.section	.text.startup,"ax",%progbits
 12535              		.align	2
 12536              		.global	main
 12538              	main:
 12539              	.LFB28:
6019:../uvc.c      **** 
6020:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
6021:../uvc.c      ****  * the ThreadX RTOS here.
6022:../uvc.c      ****  */
6023:../uvc.c      **** int
6024:../uvc.c      **** main (
6025:../uvc.c      ****         void)
6026:../uvc.c      **** {
 12540              		.loc 1 6026 0
 12541              		.cfi_startproc
 12542              		@ args = 0, pretend = 0, frame = 56
 12543              		@ frame_needed = 0, uses_anonymous_args = 0
 12544 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12545              	.LCFI32:
 12546              		.cfi_def_cfa_offset 12
 12547              		.cfi_offset 4, -12
 12548              		.cfi_offset 5, -8
 12549              		.cfi_offset 14, -4
 12550 0004 3CD04DE2 		sub	sp, sp, #60
 12551              	.LCFI33:
 12552              		.cfi_def_cfa_offset 72
6027:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
6028:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
6029:../uvc.c      **** 
6030:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
6031:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
6032:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12553              		.loc 1 6032 0
 12554 0008 0230A0E3 		mov	r3, #2
6033:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
6034:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
6035:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12555              		.loc 1 6035 0
 12556 000c 0010A0E3 		mov	r1, #0
6036:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12557              		.loc 1 6036 0
 12558 0010 0320A0E3 		mov	r2, #3
6031:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12559              		.loc 1 6031 0
 12560 0014 0150A0E3 		mov	r5, #1
6037:../uvc.c      **** 
6038:../uvc.c      ****     /* Initialize the device */
6039:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12561              		.loc 1 6039 0
 12562 0018 0D00A0E1 		mov	r0, sp
6031:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12563              		.loc 1 6031 0
 12564 001c 00508DE5 		str	r5, [sp]
6032:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12565              		.loc 1 6032 0
 12566 0020 0430CDE5 		strb	r3, [sp, #4]
6033:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12567              		.loc 1 6033 0
 12568 0024 0530CDE5 		strb	r3, [sp, #5]
6034:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12569              		.loc 1 6034 0
 12570 0028 0630CDE5 		strb	r3, [sp, #6]
6035:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12571              		.loc 1 6035 0
 12572 002c 08108DE5 		str	r1, [sp, #8]
6036:../uvc.c      **** 
 12573              		.loc 1 6036 0
 12574 0030 0C20CDE5 		strb	r2, [sp, #12]
 12575              		.loc 1 6039 0
 12576 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12577              	.LVL1457:
6040:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12578              		.loc 1 6040 0
 12579 0038 004050E2 		subs	r4, r0, #0
 12580 003c 0000000A 		beq	.L1076
 12581              	.L1072:
 12582              	.L1073:
 12583 0040 FEFFFFEA 		b	.L1073
 12584              	.L1076:
6041:../uvc.c      ****     {
6042:../uvc.c      ****         goto handle_fatal_error;
6043:../uvc.c      ****     }
6044:../uvc.c      **** 
6045:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
6046:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12585              		.loc 1 6046 0
 12586 0044 0410A0E1 		mov	r1, r4
 12587 0048 0420A0E1 		mov	r2, r4
 12588 004c 0500A0E1 		mov	r0, r5
 12589              	.LVL1458:
 12590 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12591              	.LVL1459:
6047:../uvc.c      **** 
6048:../uvc.c      ****     /* Configure the IO matrix for the device. */
6049:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
6050:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
6051:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
6052:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
6053:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
6054:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
6055:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
6056:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
6057:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
6058:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
6059:../uvc.c      **** 
6060:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12592              		.loc 1 6060 0
 12593 0054 10008DE2 		add	r0, sp, #16
6050:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12594              		.loc 1 6050 0
 12595 0058 2640CDE5 		strb	r4, [sp, #38]
6051:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12596              		.loc 1 6051 0
 12597 005c 28408DE5 		str	r4, [sp, #40]
6052:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12598              		.loc 1 6052 0
 12599 0060 2C408DE5 		str	r4, [sp, #44]
6053:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12600              		.loc 1 6053 0
 12601 0064 30408DE5 		str	r4, [sp, #48]
6054:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12602              		.loc 1 6054 0
 12603 0068 34408DE5 		str	r4, [sp, #52]
6057:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12604              		.loc 1 6057 0
 12605 006c 1C408DE5 		str	r4, [sp, #28]
6058:../uvc.c      **** 
 12606              		.loc 1 6058 0
 12607 0070 20408DE5 		str	r4, [sp, #32]
6049:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12608              		.loc 1 6049 0
 12609 0074 10508DE5 		str	r5, [sp, #16]
6055:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12610              		.loc 1 6055 0
 12611 0078 14508DE5 		str	r5, [sp, #20]
6056:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12612              		.loc 1 6056 0
 12613 007c 18508DE5 		str	r5, [sp, #24]
 12614              		.loc 1 6060 0
 12615 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12616              	.LVL1460:
6061:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12617              		.loc 1 6061 0
 12618 0084 004050E2 		subs	r4, r0, #0
 12619 0088 ECFFFF1A 		bne	.L1072
6062:../uvc.c      ****     {
6063:../uvc.c      ****         goto handle_fatal_error;
6064:../uvc.c      ****     }
6065:../uvc.c      **** 
6066:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
6067:../uvc.c      ****     CyU3PKernelEntry ();
 12620              		.loc 1 6067 0
 12621 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12622              	.LVL1461:
6068:../uvc.c      **** 
6069:../uvc.c      ****     /* Dummy return to make the compiler happy */
6070:../uvc.c      ****     return 0;
6071:../uvc.c      **** 
6072:../uvc.c      **** handle_fatal_error:
6073:../uvc.c      ****     /* Cannot recover from this error. */
6074:../uvc.c      ****     while (1);
6075:../uvc.c      **** }
 12623              		.loc 1 6075 0
 12624 0090 0400A0E1 		mov	r0, r4
 12625 0094 3CD08DE2 		add	sp, sp, #60
 12626              		@ sp needed
 12627 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12628              		.cfi_endproc
 12629              	.LFE28:
 12631              		.comm	I2CCmdTimer,44,4
 12632              		.comm	posTick,4,4
 12633              		.global	glUVCHeader
 12634              		.global	glProbeStilCtrl20
 12635              		.global	glProbeCtrl20
 12636              		.global	glProbeStilCtrl
 12637              		.global	glProbeCtrlFull
 12638              		.global	glProbeCtrl
 12639              		.global	streamingStarted
 12640              		.global	clearFeatureRqtReceived
 12641              		.global	usbSpeed
 12642              		.global	isUsbConnected
 12643              		.global	pbcpbak
 12644              		.global	pbcbak
 12645              		.global	pbbak
 12646              		.global	fbbak
 12647              		.global	pbc
 12648              		.global	pb
 12649              		.global	fb
 12650              		.comm	wLength,2,2
 12651              		.comm	wIndex,2,2
 12652              		.comm	wValue,2,2
 12653              		.comm	bRequest,1,1
 12654              		.comm	bmReqType,1,1
 12655              		.comm	imgHdMux,56,4
 12656              		.comm	timMux,56,4
 12657              		.comm	staQuMux,56,4
 12658              		.comm	cmdQuMux,56,4
 12659              		.comm	statQu,32,4
 12660              		.comm	cmdQu,32,4
 12661              		.global	testSnap
 12662              		.global	snapButFlag
 12663              		.comm	glInterStaBuffer,4,4
 12664              		.comm	glChHandleInterStat,172,4
 12665              		.comm	glChHandleStillStream,232,4
 12666              		.comm	glChHandleUVCStream,232,4
 12667              		.global	CyFxGpifConfig_usb2
 12668              		.global	CyFxGpifRegValue_usb2
 12669              		.global	CyFxGpifWavedataPosition_usb2
 12670              		.global	CyFxGpifWavedata_usb2
 12671              		.global	CyFxGpifTransition_usb2
 12672              		.global	CyFxGpifConfig
 12673              		.global	CyFxGpifRegValue
 12674              		.global	CyFxGpifWavedataPosition
 12675              		.global	CyFxGpifWavedata
 12676              		.global	CyFxGpifTransition
 12677              		.section	.rodata
 12678              		.align	2
 12679              		.set	.LANCHOR2,. + 0
 12682              	ShutSp:
 12683 0000 3582     		.short	-32203
 12684 0002 1B41     		.short	16667
 12685 0004 8D20     		.short	8333
 12686 0006 A00F     		.short	4000
 12687 0008 D007     		.short	2000
 12688 000a E803     		.short	1000
 12689 000c F401     		.short	500
 12690 000e C800     		.short	200
 12691 0010 6400     		.short	100
 12692 0012 0A00     		.short	10
 12693 0014 0000     		.short	0
 12694 0016 00000000 		.space	10
 12694      00000000 
 12694      0000
 12697              	pEXTSenCtrl:
 12698 0020 74050000 		.word	EXTShutter
 12699 0024 C0080000 		.word	EXTSensUp
 12700 0028 AC080000 		.word	EXTMirror
 12701 002c 98080000 		.word	EXT3DnoiseReduceMode
 12702 0030 84080000 		.word	EXT3DNoiseLev
 12703 0034 70080000 		.word	EXTDayNightMode
 12704 0038 5C080000 		.word	EXTDayNightdely
 12705 003c 48080000 		.word	EXTDayNightlev
 12706 0040 34080000 		.word	EXTNightDaylev
 12707 0044 0C050000 		.word	EXTAexModGainlev
 12708 0048 20080000 		.word	EXTExpReflev
 12709 004c D0070000 		.word	EXTShutlev
 12710 0050 0C080000 		.word	EXTCamMode
 12711 0054 00000000 		.word	0
 12712 0058 F8070000 		.word	EXTSensorPare
 12713 005c 00000000 		.word	0
 12714 0060 00000000 		.word	0
 12715 0064 00000000 		.word	0
 12716 0068 00000000 		.word	0
 12717 006c 00000000 		.word	0
 12718 0070 88050000 		.word	EXTBLCWinPos
 12719 0074 E4070000 		.word	EXTBLCWeight
 12720 0078 F8040000 		.word	EXTBLCGrid
 12721 007c BC070000 		.word	EXTExHyster
 12722 0080 A8070000 		.word	EXTExCtrlSped
 12723 0084 30070000 		.word	EXTEnhanceMode
 12724 0088 44070000 		.word	EXTEnhanceGain
 12725 008c 94070000 		.word	EXTEnhanceSTED
 12726 0090 80070000 		.word	EXT2DNRGain
 12727 0094 6C070000 		.word	EXT2DNRSTED
 12728 0098 58070000 		.word	EXTGammaCor
 12729 009c 00000000 		.word	0
 12730 00a0 00000000 		.word	0
 12731 00a4 00000000 		.space	124
 12731      00000000 
 12731      00000000 
 12731      00000000 
 12731      00000000 
 12734              	pPUCSenCtrl:
 12735 0120 60050000 		.word	PUCBLC
 12736 0124 20050000 		.word	PUCBright
 12737 0128 24090000 		.word	PUCContrast
 12738 012c 00000000 		.word	0
 12739 0130 48050000 		.word	PUCPLFreq
 12740 0134 34050000 		.word	PUCHueC
 12741 0138 10090000 		.word	PUCSaturation
 12742 013c FC080000 		.word	PUCSharp
 12743 0140 00000000 		.word	0
 12744 0144 E8080000 		.word	PUCWBMd
 12745 0148 00000000 		.word	0
 12746 014c D4080000 		.word	PUCWBLC
 12747 0150 00000000 		.word	0
 12748 0154 00000000 		.word	0
 12749 0158 1C070000 		.word	PUCDZoom
 12750 015c 00000000 		.word	0
 12753              	CyFxGpifConfig:
 12754 0160 0F00     		.short	15
 12755 0162 0000     		.space	2
 12756 0164 00000000 		.word	CyFxGpifWavedata
 12757 0168 00000000 		.word	CyFxGpifWavedataPosition
 12758 016c 0500     		.short	5
 12759 016e 0000     		.space	2
 12760 0170 00000000 		.word	CyFxGpifTransition
 12761 0174 4C00     		.short	76
 12762 0176 0000     		.space	2
 12763 0178 00000000 		.word	CyFxGpifRegValue
 12766              	CyFxGpifConfig_usb2:
 12767 017c 9300     		.short	147
 12768 017e 0000     		.space	2
 12769 0180 00000000 		.word	CyFxGpifWavedata_usb2
 12770 0184 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12771 0188 0800     		.short	8
 12772 018a 0000     		.space	2
 12773 018c 00000000 		.word	CyFxGpifTransition_usb2
 12774 0190 4C00     		.short	76
 12775 0192 0000     		.space	2
 12776 0194 00000000 		.word	CyFxGpifRegValue_usb2
 12779              	ShutValueArry:
 12780 0198 C800     		.short	200
 12781 019a 6400     		.short	100
 12782 019c 2700     		.short	39
 12783 019e 1400     		.short	20
 12784 01a0 0A00     		.short	10
 12785 01a2 0500     		.short	5
 12786 01a4 0200     		.short	2
 12787 01a6 0100     		.short	1
 12788              		.data
 12789              		.align	2
 12790              		.set	.LANCHOR1,. + 0
 12793              	glProbeCtrlFull:
 12794 0000 00       		.byte	0
 12795 0001 00       		.byte	0
 12796 0002 01       		.byte	1
 12797 0003 01       		.byte	1
 12798 0004 15       		.byte	21
 12799 0005 16       		.byte	22
 12800 0006 05       		.byte	5
 12801 0007 00       		.byte	0
 12802 0008 00       		.byte	0
 12803 0009 00       		.byte	0
 12804 000a 00       		.byte	0
 12805 000b 00       		.byte	0
 12806 000c 00       		.byte	0
 12807 000d 00       		.byte	0
 12808 000e 00       		.byte	0
 12809 000f 00       		.byte	0
 12810 0010 00       		.byte	0
 12811 0011 00       		.byte	0
 12812 0012 00       		.byte	0
 12813 0013 C6       		.byte	-58
 12814 0014 99       		.byte	-103
 12815 0015 00       		.byte	0
 12816 0016 00       		.byte	0
 12817 0017 40       		.byte	64
 12818 0018 00       		.byte	0
 12819 0019 00       		.byte	0
 12820 001a 0000     		.space	2
 12823              	glProbeCtrl20:
 12824 001c 00       		.byte	0
 12825 001d 00       		.byte	0
 12826 001e 01       		.byte	1
 12827 001f 01       		.byte	1
 12828 0020 80       		.byte	-128
 12829 0021 1A       		.byte	26
 12830 0022 06       		.byte	6
 12831 0023 00       		.byte	0
 12832 0024 00       		.byte	0
 12833 0025 00       		.byte	0
 12834 0026 00       		.byte	0
 12835 0027 00       		.byte	0
 12836 0028 00       		.byte	0
 12837 0029 00       		.byte	0
 12838 002a 00       		.byte	0
 12839 002b 00       		.byte	0
 12840 002c 00       		.byte	0
 12841 002d 00       		.byte	0
 12842 002e 00       		.byte	0
 12843 002f D2       		.byte	-46
 12844 0030 0F       		.byte	15
 12845 0031 00       		.byte	0
 12846 0032 00       		.byte	0
 12847 0033 40       		.byte	64
 12848 0034 00       		.byte	0
 12849 0035 00       		.byte	0
 12850 0036 0000     		.space	2
 12853              	glProbeCtrl:
 12854 0038 00       		.byte	0
 12855 0039 00       		.byte	0
 12856 003a 01       		.byte	1
 12857 003b 01       		.byte	1
 12858 003c 15       		.byte	21
 12859 003d 16       		.byte	22
 12860 003e 05       		.byte	5
 12861 003f 00       		.byte	0
 12862 0040 00       		.byte	0
 12863 0041 00       		.byte	0
 12864 0042 00       		.byte	0
 12865 0043 00       		.byte	0
 12866 0044 00       		.byte	0
 12867 0045 00       		.byte	0
 12868 0046 00       		.byte	0
 12869 0047 00       		.byte	0
 12870 0048 00       		.byte	0
 12871 0049 00       		.byte	0
 12872 004a 00       		.byte	0
 12873 004b 48       		.byte	72
 12874 004c 3F       		.byte	63
 12875 004d 00       		.byte	0
 12876 004e 00       		.byte	0
 12877 004f 40       		.byte	64
 12878 0050 00       		.byte	0
 12879 0051 00       		.byte	0
 12882              	ROIMode:
 12883 0052 01       		.byte	1
 12884 0053 00       		.space	1
 12887              	glProbeStilCtrl:
 12888 0054 01       		.byte	1
 12889 0055 02       		.byte	2
 12890 0056 00       		.byte	0
 12891 0057 00       		.byte	0
 12892 0058 C6       		.byte	-58
 12893 0059 99       		.byte	-103
 12894 005a 00       		.byte	0
 12895 005b 00       		.byte	0
 12896 005c 40       		.byte	64
 12897 005d 00       		.byte	0
 12898 005e 00       		.byte	0
 12899 005f 00       		.space	1
 12902              	glProbeStilCtrl20:
 12903 0060 01       		.byte	1
 12904 0061 01       		.byte	1
 12905 0062 00       		.byte	0
 12906 0063 00       		.byte	0
 12907 0064 D2       		.byte	-46
 12908 0065 0F       		.byte	15
 12909 0066 00       		.byte	0
 12910 0067 00       		.byte	0
 12911 0068 40       		.byte	64
 12912 0069 00       		.byte	0
 12913 006a 00       		.byte	0
 12914 006b 00       		.space	1
 12917              	ExUCtrlParArry:
 12918 006c 00       		.byte	0
 12919 006d 00       		.byte	0
 12920 006e 04       		.byte	4
 12921 006f 01       		.byte	1
 12922 0070 00       		.byte	0
 12923 0071 38       		.byte	56
 12924 0072 01       		.byte	1
 12925 0073 01       		.byte	1
 12926 0074 00       		.byte	0
 12927 0075 03       		.byte	3
 12928 0076 00       		.byte	0
 12929 0077 4E       		.byte	78
 12930 0078 00       		.byte	0
 12931 0079 4E       		.byte	78
 12932 007a 00       		.byte	0
 12933 007b 30       		.byte	48
 12934 007c 01       		.byte	1
 12935 007d 00       		.byte	0
 12936 007e 00       		.byte	0
 12937 007f 00000000 		.space	5
 12937      00
 12938 0084 00       		.byte	0
 12939 0085 00       		.byte	0
 12940 0086 01       		.byte	1
 12941 0087 00       		.byte	0
 12942 0088 00       		.byte	0
 12943 0089 00       		.byte	0
 12944 008a 00       		.byte	0
 12945 008b 01       		.byte	1
 12946 008c 00       		.byte	0
 12947 008d 03       		.byte	3
 12948 008e 00       		.byte	0
 12949 008f 00       		.byte	0
 12950 0090 00       		.byte	0
 12951 0091 00       		.byte	0
 12952 0092 00       		.byte	0
 12953 0093 30       		.byte	48
 12954 0094 01       		.byte	1
 12955 0095 00       		.byte	0
 12956 0096 00       		.byte	0
 12957 0097 00000000 		.space	5
 12957      00
 12958 009c 00       		.byte	0
 12959 009d 00       		.byte	0
 12960 009e 02       		.byte	2
 12961 009f 00       		.byte	0
 12962 00a0 00       		.byte	0
 12963 00a1 FF       		.byte	-1
 12964 00a2 00       		.byte	0
 12965 00a3 01       		.byte	1
 12966 00a4 00       		.byte	0
 12967 00a5 03       		.byte	3
 12968 00a6 00       		.byte	0
 12969 00a7 01       		.byte	1
 12970 00a8 00       		.byte	0
 12971 00a9 00       		.byte	0
 12972 00aa 00       		.byte	0
 12973 00ab 30       		.byte	48
 12974 00ac 01       		.byte	1
 12975 00ad 01       		.byte	1
 12976 00ae 00       		.byte	0
 12977 00af 00000000 		.space	5
 12977      00
 12978 00b4 00       		.byte	0
 12979 00b5 00       		.byte	0
 12980 00b6 02       		.byte	2
 12981 00b7 00       		.byte	0
 12982 00b8 00       		.byte	0
 12983 00b9 00       		.byte	0
 12984 00ba 00       		.byte	0
 12985 00bb 00       		.byte	0
 12986 00bc 00       		.byte	0
 12987 00bd 03       		.byte	3
 12988 00be 00       		.byte	0
 12989 00bf 00       		.byte	0
 12990 00c0 00       		.byte	0
 12991 00c1 00       		.byte	0
 12992 00c2 00       		.byte	0
 12993 00c3 30       		.byte	48
 12994 00c4 01       		.byte	1
 12995 00c5 01       		.byte	1
 12996 00c6 00       		.byte	0
 12997 00c7 00000000 		.space	5
 12997      00
 12998 00cc 13       		.byte	19
 12999 00cd 14       		.byte	20
 13000 00ce 02       		.byte	2
 13001 00cf 00       		.byte	0
 13002 00d0 00       		.byte	0
 13003 00d1 FF       		.byte	-1
 13004 00d2 FF       		.byte	-1
 13005 00d3 01       		.byte	1
 13006 00d4 00       		.byte	0
 13007 00d5 03       		.byte	3
 13008 00d6 00       		.byte	0
 13009 00d7 66       		.byte	102
 13010 00d8 66       		.byte	102
 13011 00d9 66       		.byte	102
 13012 00da 66       		.byte	102
 13013 00db 30       		.byte	48
 13014 00dc 01       		.byte	1
 13015 00dd 00       		.byte	0
 13016 00de 00       		.byte	0
 13017 00df 00000000 		.space	5
 13017      00
 13018 00e4 11       		.byte	17
 13019 00e5 00       		.byte	0
 13020 00e6 02       		.byte	2
 13021 00e7 01       		.byte	1
 13022 00e8 00       		.byte	0
 13023 00e9 03       		.byte	3
 13024 00ea 00       		.byte	0
 13025 00eb 01       		.byte	1
 13026 00ec 00       		.byte	0
 13027 00ed 03       		.byte	3
 13028 00ee 00       		.byte	0
 13029 00ef 80       		.byte	-128
 13030 00f0 00       		.byte	0
 13031 00f1 80       		.byte	-128
 13032 00f2 00       		.byte	0
 13033 00f3 30       		.byte	48
 13034 00f4 01       		.byte	1
 13035 00f5 01       		.byte	1
 13036 00f6 00       		.byte	0
 13037 00f7 00000000 		.space	5
 13037      00
 13038 00fc 10       		.byte	16
 13039 00fd 00       		.byte	0
 13040 00fe 01       		.byte	1
 13041 00ff 01       		.byte	1
 13042 0100 00       		.byte	0
 13043 0101 02       		.byte	2
 13044 0102 00       		.byte	0
 13045 0103 01       		.byte	1
 13046 0104 00       		.byte	0
 13047 0105 03       		.byte	3
 13048 0106 00       		.byte	0
 13049 0107 00       		.byte	0
 13050 0108 00       		.byte	0
 13051 0109 00       		.byte	0
 13052 010a 00       		.byte	0
 13053 010b 30       		.byte	48
 13054 010c 01       		.byte	1
 13055 010d 01       		.byte	1
 13056 010e 00       		.byte	0
 13057 010f 00000000 		.space	5
 13057      00
 13058 0114 00       		.byte	0
 13059 0115 00       		.byte	0
 13060 0116 04       		.byte	4
 13061 0117 01       		.byte	1
 13062 0118 00       		.byte	0
 13063 0119 38       		.byte	56
 13064 011a 01       		.byte	1
 13065 011b 01       		.byte	1
 13066 011c 00       		.byte	0
 13067 011d 03       		.byte	3
 13068 011e 00       		.byte	0
 13069 011f 4E       		.byte	78
 13070 0120 00       		.byte	0
 13071 0121 4E       		.byte	78
 13072 0122 00       		.byte	0
 13073 0123 30       		.byte	48
 13074 0124 01       		.byte	1
 13075 0125 00       		.byte	0
 13076 0126 00       		.byte	0
 13077 0127 00000000 		.space	5
 13077      00
 13078 012c 00       		.byte	0
 13079 012d 00       		.byte	0
 13080 012e 01       		.byte	1
 13081 012f 00       		.byte	0
 13082 0130 00       		.byte	0
 13083 0131 00       		.byte	0
 13084 0132 00       		.byte	0
 13085 0133 01       		.byte	1
 13086 0134 00       		.byte	0
 13087 0135 03       		.byte	3
 13088 0136 00       		.byte	0
 13089 0137 00       		.byte	0
 13090 0138 00       		.byte	0
 13091 0139 00       		.byte	0
 13092 013a 00       		.byte	0
 13093 013b 30       		.byte	48
 13094 013c 01       		.byte	1
 13095 013d 00       		.byte	0
 13096 013e 00       		.byte	0
 13097 013f 00000000 		.space	5
 13097      00
 13098 0144 00       		.byte	0
 13099 0145 00       		.byte	0
 13100 0146 02       		.byte	2
 13101 0147 00       		.byte	0
 13102 0148 00       		.byte	0
 13103 0149 05       		.byte	5
 13104 014a 00       		.byte	0
 13105 014b 01       		.byte	1
 13106 014c 00       		.byte	0
 13107 014d 03       		.byte	3
 13108 014e 00       		.byte	0
 13109 014f 00       		.byte	0
 13110 0150 00       		.byte	0
 13111 0151 00       		.byte	0
 13112 0152 00       		.byte	0
 13113 0153 30       		.byte	48
 13114 0154 01       		.byte	1
 13115 0155 00       		.byte	0
 13116 0156 00       		.byte	0
 13117 0157 00000000 		.space	5
 13117      00
 13118 015c 00       		.byte	0
 13119 015d 00       		.byte	0
 13120 015e 03       		.byte	3
 13121 015f 00       		.byte	0
 13122 0160 00       		.byte	0
 13123 0161 0A       		.byte	10
 13124 0162 00       		.byte	0
 13125 0163 01       		.byte	1
 13126 0164 00       		.byte	0
 13127 0165 03       		.byte	3
 13128 0166 00       		.byte	0
 13129 0167 00       		.byte	0
 13130 0168 00       		.byte	0
 13131 0169 00       		.byte	0
 13132 016a 00       		.byte	0
 13133 016b 30       		.byte	48
 13134 016c 01       		.byte	1
 13135 016d 00       		.byte	0
 13136 016e 00       		.byte	0
 13137 016f 00000000 		.space	5
 13137      00
 13138 0174 00       		.byte	0
 13139 0175 00       		.byte	0
 13140 0176 02       		.byte	2
 13141 0177 00       		.byte	0
 13142 0178 00       		.byte	0
 13143 0179 40       		.byte	64
 13144 017a 00       		.byte	0
 13145 017b 01       		.byte	1
 13146 017c 00       		.byte	0
 13147 017d 03       		.byte	3
 13148 017e 00       		.byte	0
 13149 017f 0F       		.byte	15
 13150 0180 11       		.byte	17
 13151 0181 00       		.byte	0
 13152 0182 00       		.byte	0
 13153 0183 30       		.byte	48
 13154 0184 01       		.byte	1
 13155 0185 00       		.byte	0
 13156 0186 00       		.byte	0
 13157 0187 00000000 		.space	5
 13157      00
 13158 018c 00       		.byte	0
 13159 018d 00       		.byte	0
 13160 018e 02       		.byte	2
 13161 018f 00       		.byte	0
 13162 0190 00       		.byte	0
 13163 0191 64       		.byte	100
 13164 0192 00       		.byte	0
 13165 0193 01       		.byte	1
 13166 0194 00       		.byte	0
 13167 0195 03       		.byte	3
 13168 0196 00       		.byte	0
 13169 0197 00       		.byte	0
 13170 0198 00       		.byte	0
 13171 0199 00       		.byte	0
 13172 019a 00       		.byte	0
 13173 019b 30       		.byte	48
 13174 019c 01       		.byte	1
 13175 019d 00       		.byte	0
 13176 019e 00       		.byte	0
 13177 019f 00000000 		.space	5
 13177      00
 13178 01a4 00       		.byte	0
 13179 01a5 00       		.byte	0
 13180 01a6 02       		.byte	2
 13181 01a7 00       		.byte	0
 13182 01a8 00       		.byte	0
 13183 01a9 64       		.byte	100
 13184 01aa 00       		.byte	0
 13185 01ab 01       		.byte	1
 13186 01ac 00       		.byte	0
 13187 01ad 03       		.byte	3
 13188 01ae 00       		.byte	0
 13189 01af 00       		.byte	0
 13190 01b0 00       		.byte	0
 13191 01b1 00       		.byte	0
 13192 01b2 00       		.byte	0
 13193 01b3 30       		.byte	48
 13194 01b4 01       		.byte	1
 13195 01b5 00       		.byte	0
 13196 01b6 00       		.byte	0
 13197 01b7 00000000 		.space	5
 13197      00
 13198 01bc 00       		.byte	0
 13199 01bd 00       		.byte	0
 13200 01be 02       		.byte	2
 13201 01bf 00       		.byte	0
 13202 01c0 00       		.byte	0
 13203 01c1 64       		.byte	100
 13204 01c2 00       		.byte	0
 13205 01c3 01       		.byte	1
 13206 01c4 00       		.byte	0
 13207 01c5 03       		.byte	3
 13208 01c6 00       		.byte	0
 13209 01c7 00       		.byte	0
 13210 01c8 00       		.byte	0
 13211 01c9 00       		.byte	0
 13212 01ca 00       		.byte	0
 13213 01cb 30       		.byte	48
 13214 01cc 01       		.byte	1
 13215 01cd 00       		.byte	0
 13216 01ce 00       		.byte	0
 13217 01cf 00000000 		.space	5
 13217      00
 13218 01d4 00       		.byte	0
 13219 01d5 00       		.byte	0
 13220 01d6 02       		.byte	2
 13221 01d7 00       		.byte	0
 13222 01d8 00       		.byte	0
 13223 01d9 64       		.byte	100
 13224 01da 00       		.byte	0
 13225 01db 01       		.byte	1
 13226 01dc 00       		.byte	0
 13227 01dd 03       		.byte	3
 13228 01de 00       		.byte	0
 13229 01df 00       		.byte	0
 13230 01e0 00       		.byte	0
 13231 01e1 00       		.byte	0
 13232 01e2 00       		.byte	0
 13233 01e3 30       		.byte	48
 13234 01e4 01       		.byte	1
 13235 01e5 00       		.byte	0
 13236 01e6 00       		.byte	0
 13237 01e7 00000000 		.space	5
 13237      00
 13240              	CtrlParArry:
 13241 01ec 10       		.byte	16
 13242 01ed 10       		.byte	16
 13243 01ee 02       		.byte	2
 13244 01ef 00       		.byte	0
 13245 01f0 00       		.byte	0
 13246 01f1 03       		.byte	3
 13247 01f2 00       		.byte	0
 13248 01f3 01       		.byte	1
 13249 01f4 00       		.byte	0
 13250 01f5 03       		.byte	3
 13251 01f6 00       		.byte	0
 13252 01f7 03       		.byte	3
 13253 01f8 00       		.byte	0
 13254 01f9 03       		.byte	3
 13255 01fa 00       		.byte	0
 13256 01fb 30       		.byte	48
 13257 01fc 01       		.byte	1
 13258 01fd 00       		.byte	0
 13259 01fe 00       		.byte	0
 13260 01ff 00000000 		.space	5
 13260      00
 13261 0204 15       		.byte	21
 13262 0205 15       		.byte	21
 13263 0206 02       		.byte	2
 13264 0207 00       		.byte	0
 13265 0208 00       		.byte	0
 13266 0209 FF       		.byte	-1
 13267 020a 00       		.byte	0
 13268 020b 01       		.byte	1
 13269 020c 00       		.byte	0
 13270 020d 03       		.byte	3
 13271 020e 00       		.byte	0
 13272 020f 76       		.byte	118
 13273 0210 00       		.byte	0
 13274 0211 76       		.byte	118
 13275 0212 C7       		.byte	-57
 13276 0213 30       		.byte	48
 13277 0214 01       		.byte	1
 13278 0215 01       		.byte	1
 13279 0216 00       		.byte	0
 13280 0217 00000000 		.space	5
 13280      00
 13281 021c 04       		.byte	4
 13282 021d 04       		.byte	4
 13283 021e 02       		.byte	2
 13284 021f 00       		.byte	0
 13285 0220 00       		.byte	0
 13286 0221 FF       		.byte	-1
 13287 0222 00       		.byte	0
 13288 0223 01       		.byte	1
 13289 0224 00       		.byte	0
 13290 0225 03       		.byte	3
 13291 0226 00       		.byte	0
 13292 0227 70       		.byte	112
 13293 0228 00       		.byte	0
 13294 0229 70       		.byte	112
 13295 022a 00       		.byte	0
 13296 022b 30       		.byte	48
 13297 022c 01       		.byte	1
 13298 022d 01       		.byte	1
 13299 022e 00       		.byte	0
 13300 022f 00000000 		.space	5
 13300      00
 13301 0234 00       		.byte	0
 13302 0235 00       		.byte	0
 13303 0236 02       		.byte	2
 13304 0237 00       		.byte	0
 13305 0238 00       		.byte	0
 13306 0239 64       		.byte	100
 13307 023a 00       		.byte	0
 13308 023b 01       		.byte	1
 13309 023c 00       		.byte	0
 13310 023d 03       		.byte	3
 13311 023e 00       		.byte	0
 13312 023f 00       		.byte	0
 13313 0240 00       		.byte	0
 13314 0241 00       		.byte	0
 13315 0242 00       		.byte	0
 13316 0243 30       		.byte	48
 13317 0244 01       		.byte	1
 13318 0245 00       		.byte	0
 13319 0246 00       		.byte	0
 13320 0247 00000000 		.space	5
 13320      00
 13321 024c 07       		.byte	7
 13322 024d 07       		.byte	7
 13323 024e 02       		.byte	2
 13324 024f 00       		.byte	0
 13325 0250 00       		.byte	0
 13326 0251 01       		.byte	1
 13327 0252 00       		.byte	0
 13328 0253 01       		.byte	1
 13329 0254 00       		.byte	0
 13330 0255 03       		.byte	3
 13331 0256 00       		.byte	0
 13332 0257 01       		.byte	1
 13333 0258 00       		.byte	0
 13334 0259 01       		.byte	1
 13335 025a 00       		.byte	0
 13336 025b 30       		.byte	48
 13337 025c 01       		.byte	1
 13338 025d 00       		.byte	0
 13339 025e 00       		.byte	0
 13340 025f 00000000 		.space	5
 13340      00
 13341 0264 DF       		.byte	-33
 13342 0265 E1       		.byte	-31
 13343 0266 02       		.byte	2
 13344 0267 00       		.byte	0
 13345 0268 00       		.byte	0
 13346 0269 FF       		.byte	-1
 13347 026a 00       		.byte	0
 13348 026b 01       		.byte	1
 13349 026c 00       		.byte	0
 13350 026d 03       		.byte	3
 13351 026e 00       		.byte	0
 13352 026f 80       		.byte	-128
 13353 0270 00       		.byte	0
 13354 0271 00       		.byte	0
 13355 0272 00       		.byte	0
 13356 0273 C6       		.byte	-58
 13357 0274 01       		.byte	1
 13358 0275 01       		.byte	1
 13359 0276 00       		.byte	0
 13360 0277 00000000 		.space	5
 13360      00
 13361 027c 85       		.byte	-123
 13362 027d 86       		.byte	-122
 13363 027e 02       		.byte	2
 13364 027f 00       		.byte	0
 13365 0280 00       		.byte	0
 13366 0281 64       		.byte	100
 13367 0282 00       		.byte	0
 13368 0283 01       		.byte	1
 13369 0284 00       		.byte	0
 13370 0285 03       		.byte	3
 13371 0286 00       		.byte	0
 13372 0287 32       		.byte	50
 13373 0288 00       		.byte	0
 13374 0289 32       		.byte	50
 13375 028a 00       		.byte	0
 13376 028b F2       		.byte	-14
 13377 028c 01       		.byte	1
 13378 028d 01       		.byte	1
 13379 028e 00       		.byte	0
 13380 028f 00000000 		.space	5
 13380      00
 13381 0294 06       		.byte	6
 13382 0295 07       		.byte	7
 13383 0296 02       		.byte	2
 13384 0297 00       		.byte	0
 13385 0298 00       		.byte	0
 13386 0299 FF       		.byte	-1
 13387 029a 00       		.byte	0
 13388 029b 01       		.byte	1
 13389 029c 00       		.byte	0
 13390 029d 03       		.byte	3
 13391 029e 00       		.byte	0
 13392 029f 20       		.byte	32
 13393 02a0 00       		.byte	0
 13394 02a1 20       		.byte	32
 13395 02a2 00       		.byte	0
 13396 02a3 30       		.byte	48
 13397 02a4 01       		.byte	1
 13398 02a5 01       		.byte	1
 13399 02a6 00       		.byte	0
 13400 02a7 00000000 		.space	5
 13400      00
 13401 02ac 00       		.byte	0
 13402 02ad 00       		.byte	0
 13403 02ae 02       		.byte	2
 13404 02af 00       		.byte	0
 13405 02b0 00       		.byte	0
 13406 02b1 64       		.byte	100
 13407 02b2 00       		.byte	0
 13408 02b3 01       		.byte	1
 13409 02b4 00       		.byte	0
 13410 02b5 03       		.byte	3
 13411 02b6 00       		.byte	0
 13412 02b7 00       		.byte	0
 13413 02b8 00       		.byte	0
 13414 02b9 00       		.byte	0
 13415 02ba 00       		.byte	0
 13416 02bb 30       		.byte	48
 13417 02bc 01       		.byte	1
 13418 02bd 00       		.byte	0
 13419 02be 00       		.byte	0
 13420 02bf 00000000 		.space	5
 13420      00
 13421 02c4 08       		.byte	8
 13422 02c5 08       		.byte	8
 13423 02c6 02       		.byte	2
 13424 02c7 00       		.byte	0
 13425 02c8 00       		.byte	0
 13426 02c9 05       		.byte	5
 13427 02ca 00       		.byte	0
 13428 02cb 01       		.byte	1
 13429 02cc 00       		.byte	0
 13430 02cd 03       		.byte	3
 13431 02ce 00       		.byte	0
 13432 02cf 00       		.byte	0
 13433 02d0 00       		.byte	0
 13434 02d1 00       		.byte	0
 13435 02d2 00       		.byte	0
 13436 02d3 30       		.byte	48
 13437 02d4 01       		.byte	1
 13438 02d5 00       		.byte	0
 13439 02d6 00       		.byte	0
 13440 02d7 00000000 		.space	5
 13440      00
 13441 02dc 00       		.byte	0
 13442 02dd 00       		.byte	0
 13443 02de 02       		.byte	2
 13444 02df 00       		.byte	0
 13445 02e0 00       		.byte	0
 13446 02e1 40       		.byte	64
 13447 02e2 00       		.byte	0
 13448 02e3 01       		.byte	1
 13449 02e4 00       		.byte	0
 13450 02e5 03       		.byte	3
 13451 02e6 00       		.byte	0
 13452 02e7 00       		.byte	0
 13453 02e8 00       		.byte	0
 13454 02e9 00       		.byte	0
 13455 02ea 00       		.byte	0
 13456 02eb 30       		.byte	48
 13457 02ec 01       		.byte	1
 13458 02ed 00       		.byte	0
 13459 02ee 00       		.byte	0
 13460 02ef 00000000 		.space	5
 13460      00
 13461 02f4 09       		.byte	9
 13462 02f5 0A       		.byte	10
 13463 02f6 04       		.byte	4
 13464 02f7 00       		.byte	0
 13465 02f8 00       		.byte	0
 13466 02f9 40       		.byte	64
 13467 02fa 00       		.byte	0
 13468 02fb 01       		.byte	1
 13469 02fc 00       		.byte	0
 13470 02fd 03       		.byte	3
 13471 02fe 00       		.byte	0
 13472 02ff 20       		.byte	32
 13473 0300 38       		.byte	56
 13474 0301 20       		.byte	32
 13475 0302 38       		.byte	56
 13476 0303 30       		.byte	48
 13477 0304 01       		.byte	1
 13478 0305 00       		.byte	0
 13479 0306 00       		.byte	0
 13480 0307 00000000 		.space	5
 13480      00
 13481 030c 00       		.byte	0
 13482 030d 00       		.byte	0
 13483 030e 02       		.byte	2
 13484 030f 00       		.byte	0
 13485 0310 00       		.byte	0
 13486 0311 64       		.byte	100
 13487 0312 00       		.byte	0
 13488 0313 01       		.byte	1
 13489 0314 00       		.byte	0
 13490 0315 03       		.byte	3
 13491 0316 00       		.byte	0
 13492 0317 00       		.byte	0
 13493 0318 00       		.byte	0
 13494 0319 00       		.byte	0
 13495 031a 00       		.byte	0
 13496 031b 30       		.byte	48
 13497 031c 01       		.byte	1
 13498 031d 00       		.byte	0
 13499 031e 00       		.byte	0
 13500 031f 00000000 		.space	5
 13500      00
 13501 0324 00       		.byte	0
 13502 0325 00       		.byte	0
 13503 0326 02       		.byte	2
 13504 0327 00       		.byte	0
 13505 0328 00       		.byte	0
 13506 0329 64       		.byte	100
 13507 032a 00       		.byte	0
 13508 032b 01       		.byte	1
 13509 032c 00       		.byte	0
 13510 032d 03       		.byte	3
 13511 032e 00       		.byte	0
 13512 032f 00       		.byte	0
 13513 0330 00       		.byte	0
 13514 0331 00       		.byte	0
 13515 0332 00       		.byte	0
 13516 0333 30       		.byte	48
 13517 0334 01       		.byte	1
 13518 0335 00       		.byte	0
 13519 0336 00       		.byte	0
 13520 0337 00000000 		.space	5
 13520      00
 13521 033c 2A       		.byte	42
 13522 033d 2A       		.byte	42
 13523 033e 02       		.byte	2
 13524 033f 00       		.byte	0
 13525 0340 00       		.byte	0
 13526 0341 1B       		.byte	27
 13527 0342 00       		.byte	0
 13528 0343 01       		.byte	1
 13529 0344 00       		.byte	0
 13530 0345 03       		.byte	3
 13531 0346 00       		.byte	0
 13532 0347 00       		.byte	0
 13533 0348 00       		.byte	0
 13534 0349 00       		.byte	0
 13535 034a 00       		.byte	0
 13536 034b 30       		.byte	48
 13537 034c 01       		.byte	1
 13538 034d 00       		.byte	0
 13539 034e 00       		.byte	0
 13540 034f 00000000 		.space	5
 13540      00
 13541 0354 00       		.byte	0
 13542 0355 00       		.byte	0
 13543 0356 02       		.byte	2
 13544 0357 00       		.byte	0
 13545 0358 00       		.byte	0
 13546 0359 64       		.byte	100
 13547 035a 00       		.byte	0
 13548 035b 01       		.byte	1
 13549 035c 00       		.byte	0
 13550 035d 03       		.byte	3
 13551 035e 00       		.byte	0
 13552 035f 00       		.byte	0
 13553 0360 00       		.byte	0
 13554 0361 00       		.byte	0
 13555 0362 00       		.byte	0
 13556 0363 30       		.byte	48
 13557 0364 01       		.byte	1
 13558 0365 00       		.byte	0
 13559 0366 00       		.byte	0
 13560 0367 00000000 		.space	5
 13560      00
 13561 036c 00       		.byte	0
 13562 036d 00       		.byte	0
 13563 036e 02       		.byte	2
 13564 036f 00       		.byte	0
 13565 0370 00       		.byte	0
 13566 0371 12       		.byte	18
 13567 0372 00       		.byte	0
 13568 0373 01       		.byte	1
 13569 0374 00       		.byte	0
 13570 0375 03       		.byte	3
 13571 0376 00       		.byte	0
 13572 0377 00       		.byte	0
 13573 0378 00       		.byte	0
 13574 0379 00       		.byte	0
 13575 037a 00       		.byte	0
 13576 037b 30       		.byte	48
 13577 037c 01       		.byte	1
 13578 037d 00       		.byte	0
 13579 037e 00       		.byte	0
 13580 037f 00000000 		.space	5
 13580      00
 13581 0384 01       		.byte	1
 13582 0385 01       		.byte	1
 13583 0386 02       		.byte	2
 13584 0387 00       		.byte	0
 13585 0388 00       		.byte	0
 13586 0389 09       		.byte	9
 13587 038a 00       		.byte	0
 13588 038b 01       		.byte	1
 13589 038c 00       		.byte	0
 13590 038d 03       		.byte	3
 13591 038e 00       		.byte	0
 13592 038f 00       		.byte	0
 13593 0390 00       		.byte	0
 13594 0391 01       		.byte	1
 13595 0392 00       		.byte	0
 13596 0393 30       		.byte	48
 13597 0394 01       		.byte	1
 13598 0395 00       		.byte	0
 13599 0396 00       		.byte	0
 13600 0397 00000000 		.space	5
 13600      00
 13601 039c 05       		.byte	5
 13602 039d 05       		.byte	5
 13603 039e 02       		.byte	2
 13604 039f 00       		.byte	0
 13605 03a0 00       		.byte	0
 13606 03a1 03       		.byte	3
 13607 03a2 00       		.byte	0
 13608 03a3 01       		.byte	1
 13609 03a4 00       		.byte	0
 13610 03a5 03       		.byte	3
 13611 03a6 00       		.byte	0
 13612 03a7 00       		.byte	0
 13613 03a8 00       		.byte	0
 13614 03a9 00       		.byte	0
 13615 03aa 00       		.byte	0
 13616 03ab 30       		.byte	48
 13617 03ac 01       		.byte	1
 13618 03ad 00       		.byte	0
 13619 03ae 00       		.byte	0
 13620 03af 00000000 		.space	5
 13620      00
 13621 03b4 18       		.byte	24
 13622 03b5 18       		.byte	24
 13623 03b6 02       		.byte	2
 13624 03b7 00       		.byte	0
 13625 03b8 00       		.byte	0
 13626 03b9 01       		.byte	1
 13627 03ba 00       		.byte	0
 13628 03bb 01       		.byte	1
 13629 03bc 00       		.byte	0
 13630 03bd 03       		.byte	3
 13631 03be 00       		.byte	0
 13632 03bf 00       		.byte	0
 13633 03c0 00       		.byte	0
 13634 03c1 00       		.byte	0
 13635 03c2 00       		.byte	0
 13636 03c3 30       		.byte	48
 13637 03c4 01       		.byte	1
 13638 03c5 00       		.byte	0
 13639 03c6 00       		.byte	0
 13640 03c7 00000000 		.space	5
 13640      00
 13641 03cc 19       		.byte	25
 13642 03cd 19       		.byte	25
 13643 03ce 01       		.byte	1
 13644 03cf 00       		.byte	0
 13645 03d0 00       		.byte	0
 13646 03d1 40       		.byte	64
 13647 03d2 00       		.byte	0
 13648 03d3 01       		.byte	1
 13649 03d4 00       		.byte	0
 13650 03d5 03       		.byte	3
 13651 03d6 00       		.byte	0
 13652 03d7 20       		.byte	32
 13653 03d8 00       		.byte	0
 13654 03d9 20       		.byte	32
 13655 03da 00       		.byte	0
 13656 03db 30       		.byte	48
 13657 03dc 01       		.byte	1
 13658 03dd 00       		.byte	0
 13659 03de 00       		.byte	0
 13660 03df 00000000 		.space	5
 13660      00
 13661 03e4 20       		.byte	32
 13662 03e5 20       		.byte	32
 13663 03e6 02       		.byte	2
 13664 03e7 00       		.byte	0
 13665 03e8 00       		.byte	0
 13666 03e9 02       		.byte	2
 13667 03ea 00       		.byte	0
 13668 03eb 01       		.byte	1
 13669 03ec 00       		.byte	0
 13670 03ed 03       		.byte	3
 13671 03ee 00       		.byte	0
 13672 03ef 00       		.byte	0
 13673 03f0 00       		.byte	0
 13674 03f1 00       		.byte	0
 13675 03f2 00       		.byte	0
 13676 03f3 30       		.byte	48
 13677 03f4 01       		.byte	1
 13678 03f5 00       		.byte	0
 13679 03f6 00       		.byte	0
 13680 03f7 00000000 		.space	5
 13680      00
 13681 03fc 22       		.byte	34
 13682 03fd 22       		.byte	34
 13683 03fe 02       		.byte	2
 13684 03ff 00       		.byte	0
 13685 0400 00       		.byte	0
 13686 0401 3F       		.byte	63
 13687 0402 00       		.byte	0
 13688 0403 01       		.byte	1
 13689 0404 00       		.byte	0
 13690 0405 03       		.byte	3
 13691 0406 00       		.byte	0
 13692 0407 00       		.byte	0
 13693 0408 00       		.byte	0
 13694 0409 00       		.byte	0
 13695 040a 00       		.byte	0
 13696 040b 30       		.byte	48
 13697 040c 01       		.byte	1
 13698 040d 00       		.byte	0
 13699 040e 00       		.byte	0
 13700 040f 00000000 		.space	5
 13700      00
 13701 0414 23       		.byte	35
 13702 0415 23       		.byte	35
 13703 0416 02       		.byte	2
 13704 0417 00       		.byte	0
 13705 0418 00       		.byte	0
 13706 0419 64       		.byte	100
 13707 041a 00       		.byte	0
 13708 041b 01       		.byte	1
 13709 041c 00       		.byte	0
 13710 041d 03       		.byte	3
 13711 041e 00       		.byte	0
 13712 041f 10       		.byte	16
 13713 0420 00       		.byte	0
 13714 0421 10       		.byte	16
 13715 0422 00       		.byte	0
 13716 0423 30       		.byte	48
 13717 0424 01       		.byte	1
 13718 0425 00       		.byte	0
 13719 0426 00       		.byte	0
 13720 0427 00000000 		.space	5
 13720      00
 13721 042c 24       		.byte	36
 13722 042d 24       		.byte	36
 13723 042e 02       		.byte	2
 13724 042f 00       		.byte	0
 13725 0430 00       		.byte	0
 13726 0431 64       		.byte	100
 13727 0432 00       		.byte	0
 13728 0433 01       		.byte	1
 13729 0434 00       		.byte	0
 13730 0435 03       		.byte	3
 13731 0436 00       		.byte	0
 13732 0437 10       		.byte	16
 13733 0438 00       		.byte	0
 13734 0439 10       		.byte	16
 13735 043a 00       		.byte	0
 13736 043b 30       		.byte	48
 13737 043c 01       		.byte	1
 13738 043d 00       		.byte	0
 13739 043e 00       		.byte	0
 13740 043f 00000000 		.space	5
 13740      00
 13741 0444 00       		.byte	0
 13742 0445 03       		.byte	3
 13743 0446 04       		.byte	4
 13744 0447 00       		.byte	0
 13745 0448 00       		.byte	0
 13746 0449 7F       		.byte	127
 13747 044a 00       		.byte	0
 13748 044b 01       		.byte	1
 13749 044c 00       		.byte	0
 13750 044d 03       		.byte	3
 13751 044e 00       		.byte	0
 13752 044f 00       		.byte	0
 13753 0450 20       		.byte	32
 13754 0451 00       		.byte	0
 13755 0452 20       		.byte	32
 13756 0453 30       		.byte	48
 13757 0454 01       		.byte	1
 13758 0455 00       		.byte	0
 13759 0456 00       		.byte	0
 13760 0457 00000000 		.space	5
 13760      00
 13761 045c 04       		.byte	4
 13762 045d 04       		.byte	4
 13763 045e 02       		.byte	2
 13764 045f 00       		.byte	0
 13765 0460 00       		.byte	0
 13766 0461 FF       		.byte	-1
 13767 0462 00       		.byte	0
 13768 0463 01       		.byte	1
 13769 0464 00       		.byte	0
 13770 0465 03       		.byte	3
 13771 0466 00       		.byte	0
 13772 0467 60       		.byte	96
 13773 0468 00       		.byte	0
 13774 0469 60       		.byte	96
 13775 046a 00       		.byte	0
 13776 046b 30       		.byte	48
 13777 046c 01       		.byte	1
 13778 046d 00       		.byte	0
 13779 046e 00       		.byte	0
 13780 046f 00000000 		.space	5
 13780      00
 13781 0474 00       		.byte	0
 13782 0475 00       		.byte	0
 13783 0476 02       		.byte	2
 13784 0477 00       		.byte	0
 13785 0478 00       		.byte	0
 13786 0479 19       		.byte	25
 13787 047a 00       		.byte	0
 13788 047b 01       		.byte	1
 13789 047c 00       		.byte	0
 13790 047d 03       		.byte	3
 13791 047e 00       		.byte	0
 13792 047f 00       		.byte	0
 13793 0480 00       		.byte	0
 13794 0481 00       		.byte	0
 13795 0482 00       		.byte	0
 13796 0483 30       		.byte	48
 13797 0484 01       		.byte	1
 13798 0485 00       		.byte	0
 13799 0486 00       		.byte	0
 13800 0487 00000000 		.space	5
 13800      00
 13801 048c 10       		.byte	16
 13802 048d 10       		.byte	16
 13803 048e 02       		.byte	2
 13804 048f 00       		.byte	0
 13805 0490 00       		.byte	0
 13806 0491 06       		.byte	6
 13807 0492 00       		.byte	0
 13808 0493 01       		.byte	1
 13809 0494 00       		.byte	0
 13810 0495 03       		.byte	3
 13811 0496 00       		.byte	0
 13812 0497 03       		.byte	3
 13813 0498 00       		.byte	0
 13814 0499 03       		.byte	3
 13815 049a 00       		.byte	0
 13816 049b 30       		.byte	48
 13817 049c 01       		.byte	1
 13818 049d 00       		.byte	0
 13819 049e 00       		.byte	0
 13820 049f 00000000 		.space	5
 13820      00
 13821 04a4 00       		.byte	0
 13822 04a5 00       		.byte	0
 13823 04a6 02       		.byte	2
 13824 04a7 00       		.byte	0
 13825 04a8 00       		.byte	0
 13826 04a9 03       		.byte	3
 13827 04aa 00       		.byte	0
 13828 04ab 01       		.byte	1
 13829 04ac 00       		.byte	0
 13830 04ad 03       		.byte	3
 13831 04ae 00       		.byte	0
 13832 04af 00       		.byte	0
 13833 04b0 00       		.byte	0
 13834 04b1 00       		.byte	0
 13835 04b2 00       		.byte	0
 13836 04b3 30       		.byte	48
 13837 04b4 01       		.byte	1
 13838 04b5 00       		.byte	0
 13839 04b6 00       		.byte	0
 13840 04b7 00000000 		.space	5
 13840      00
 13841 04bc 50       		.byte	80
 13842 04bd 50       		.byte	80
 13843 04be 01       		.byte	1
 13844 04bf 00       		.byte	0
 13845 04c0 00       		.byte	0
 13846 04c1 03       		.byte	3
 13847 04c2 00       		.byte	0
 13848 04c3 01       		.byte	1
 13849 04c4 00       		.byte	0
 13850 04c5 03       		.byte	3
 13851 04c6 00       		.byte	0
 13852 04c7 00       		.byte	0
 13853 04c8 00       		.byte	0
 13854 04c9 00       		.byte	0
 13855 04ca 00       		.byte	0
 13856 04cb 30       		.byte	48
 13857 04cc 01       		.byte	1
 13858 04cd 00       		.byte	0
 13859 04ce 00       		.byte	0
 13860 04cf 00000000 		.space	5
 13860      00
 13861 04d4 00       		.byte	0
 13862 04d5 00       		.byte	0
 13863 04d6 0B       		.byte	11
 13864 04d7 00       		.byte	0
 13865 04d8 00       		.byte	0
 13866 04d9 FF       		.byte	-1
 13867 04da FF       		.byte	-1
 13868 04db 01       		.byte	1
 13869 04dc 00       		.byte	0
 13870 04dd 03       		.byte	3
 13871 04de 00       		.byte	0
 13872 04df 00       		.byte	0
 13873 04e0 00       		.byte	0
 13874 04e1 00       		.byte	0
 13875 04e2 00       		.byte	0
 13876 04e3 00       		.byte	0
 13877 04e4 01       		.byte	1
 13878 04e5 00       		.byte	0
 13879 04e6 00       		.byte	0
 13880 04e7 00000000 		.space	5
 13880      00
 13883              	glUVCHeader:
 13884 04ec 0C       		.byte	12
 13885 04ed 8C       		.byte	-116
 13886 04ee 00       		.byte	0
 13887 04ef 00       		.byte	0
 13888 04f0 00       		.byte	0
 13889 04f1 00       		.byte	0
 13890 04f2 00       		.byte	0
 13891 04f3 00       		.byte	0
 13892 04f4 00       		.byte	0
 13893 04f5 00       		.byte	0
 13894 04f6 00       		.byte	0
 13895 04f7 00       		.byte	0
 13898              	EXTBLCGrid:
 13899 04f8 10       		.byte	16
 13900 04f9 10       		.byte	16
 13901 04fa 02       		.byte	2
 13902 04fb 01       		.byte	1
 13903 04fc 00       		.byte	0
 13904 04fd 02       		.byte	2
 13905 04fe 00       		.byte	0
 13906 04ff 01       		.byte	1
 13907 0500 00       		.byte	0
 13908 0501 03       		.byte	3
 13909 0502 00       		.byte	0
 13910 0503 00       		.byte	0
 13911 0504 00       		.byte	0
 13912 0505 00       		.byte	0
 13913 0506 00       		.byte	0
 13914 0507 30       		.byte	48
 13915 0508 01       		.byte	1
 13916 0509 00       		.byte	0
 13917 050a 0000     		.space	2
 13920              	EXTAexModGainlev:
 13921 050c 00       		.byte	0
 13922 050d 03       		.byte	3
 13923 050e 04       		.byte	4
 13924 050f 00       		.byte	0
 13925 0510 00       		.byte	0
 13926 0511 7F       		.byte	127
 13927 0512 00       		.byte	0
 13928 0513 01       		.byte	1
 13929 0514 00       		.byte	0
 13930 0515 03       		.byte	3
 13931 0516 00       		.byte	0
 13932 0517 00       		.byte	0
 13933 0518 3F       		.byte	63
 13934 0519 00       		.byte	0
 13935 051a 3F       		.byte	63
 13936 051b 30       		.byte	48
 13937 051c 01       		.byte	1
 13938 051d 00       		.byte	0
 13939 051e 0000     		.space	2
 13942              	PUCBright:
 13943 0520 15       		.byte	21
 13944 0521 15       		.byte	21
 13945 0522 02       		.byte	2
 13946 0523 00       		.byte	0
 13947 0524 00       		.byte	0
 13948 0525 FF       		.byte	-1
 13949 0526 00       		.byte	0
 13950 0527 01       		.byte	1
 13951 0528 00       		.byte	0
 13952 0529 03       		.byte	3
 13953 052a 00       		.byte	0
 13954 052b 76       		.byte	118
 13955 052c 00       		.byte	0
 13956 052d 76       		.byte	118
 13957 052e 77       		.byte	119
 13958 052f 30       		.byte	48
 13959 0530 01       		.byte	1
 13960 0531 00       		.byte	0
 13961 0532 0000     		.space	2
 13964              	PUCHueC:
 13965 0534 DF       		.byte	-33
 13966 0535 E1       		.byte	-31
 13967 0536 02       		.byte	2
 13968 0537 00       		.byte	0
 13969 0538 00       		.byte	0
 13970 0539 FF       		.byte	-1
 13971 053a 00       		.byte	0
 13972 053b 01       		.byte	1
 13973 053c 00       		.byte	0
 13974 053d 03       		.byte	3
 13975 053e 00       		.byte	0
 13976 053f 80       		.byte	-128
 13977 0540 00       		.byte	0
 13978 0541 00       		.byte	0
 13979 0542 00       		.byte	0
 13980 0543 30       		.byte	48
 13981 0544 01       		.byte	1
 13982 0545 00       		.byte	0
 13983 0546 0000     		.space	2
 13986              	PUCPLFreq:
 13987 0548 07       		.byte	7
 13988 0549 07       		.byte	7
 13989 054a 02       		.byte	2
 13990 054b 00       		.byte	0
 13991 054c 00       		.byte	0
 13992 054d 01       		.byte	1
 13993 054e 00       		.byte	0
 13994 054f 01       		.byte	1
 13995 0550 00       		.byte	0
 13996 0551 03       		.byte	3
 13997 0552 00       		.byte	0
 13998 0553 01       		.byte	1
 13999 0554 00       		.byte	0
 14000 0555 01       		.byte	1
 14001 0556 00       		.byte	0
 14002 0557 30       		.byte	48
 14003 0558 01       		.byte	1
 14004 0559 00       		.byte	0
 14005 055a 0000     		.space	2
 14008              	WBMenuCmpArry:
 14009 055c 20       		.byte	32
 14010 055d 0F       		.byte	15
 14011 055e 38       		.byte	56
 14012 055f F0       		.byte	-16
 14015              	PUCBLC:
 14016 0560 10       		.byte	16
 14017 0561 11       		.byte	17
 14018 0562 02       		.byte	2
 14019 0563 00       		.byte	0
 14020 0564 00       		.byte	0
 14021 0565 03       		.byte	3
 14022 0566 00       		.byte	0
 14023 0567 01       		.byte	1
 14024 0568 00       		.byte	0
 14025 0569 03       		.byte	3
 14026 056a 00       		.byte	0
 14027 056b 03       		.byte	3
 14028 056c 00       		.byte	0
 14029 056d 03       		.byte	3
 14030 056e 00       		.byte	0
 14031 056f 30       		.byte	48
 14032 0570 01       		.byte	1
 14033 0571 00       		.byte	0
 14034 0572 0000     		.space	2
 14037              	EXTShutter:
 14038 0574 00       		.byte	0
 14039 0575 02       		.byte	2
 14040 0576 02       		.byte	2
 14041 0577 00       		.byte	0
 14042 0578 00       		.byte	0
 14043 0579 08       		.byte	8
 14044 057a 00       		.byte	0
 14045 057b 01       		.byte	1
 14046 057c 00       		.byte	0
 14047 057d 03       		.byte	3
 14048 057e 00       		.byte	0
 14049 057f 00       		.byte	0
 14050 0580 00       		.byte	0
 14051 0581 00       		.byte	0
 14052 0582 00       		.byte	0
 14053 0583 30       		.byte	48
 14054 0584 01       		.byte	1
 14055 0585 00       		.byte	0
 14056 0586 0000     		.space	2
 14059              	EXTBLCWinPos:
 14060 0588 14       		.byte	20
 14061 0589 13       		.byte	19
 14062 058a 02       		.byte	2
 14063 058b 00       		.byte	0
 14064 058c 00       		.byte	0
 14065 058d FF       		.byte	-1
 14066 058e FF       		.byte	-1
 14067 058f 01       		.byte	1
 14068 0590 00       		.byte	0
 14069 0591 03       		.byte	3
 14070 0592 00       		.byte	0
 14071 0593 66       		.byte	102
 14072 0594 66       		.byte	102
 14073 0595 66       		.byte	102
 14074 0596 66       		.byte	102
 14075 0597 30       		.byte	48
 14076 0598 01       		.byte	1
 14077 0599 00       		.byte	0
 14078 059a 0000     		.space	2
 14081              	CTCtrlParArry:
 14082 059c 00       		.byte	0
 14083 059d 00       		.byte	0
 14084 059e 01       		.byte	1
 14085 059f 00       		.byte	0
 14086 05a0 00       		.byte	0
 14087 05a1 03       		.byte	3
 14088 05a2 00       		.byte	0
 14089 05a3 01       		.byte	1
 14090 05a4 00       		.byte	0
 14091 05a5 03       		.byte	3
 14092 05a6 00       		.byte	0
 14093 05a7 03       		.byte	3
 14094 05a8 00       		.byte	0
 14095 05a9 03       		.byte	3
 14096 05aa 00       		.byte	0
 14097 05ab 30       		.byte	48
 14098 05ac 01       		.byte	1
 14099 05ad 00       		.byte	0
 14100 05ae 00       		.byte	0
 14101 05af 00000000 		.space	5
 14101      00
 14102 05b4 00       		.byte	0
 14103 05b5 00       		.byte	0
 14104 05b6 01       		.byte	1
 14105 05b7 01       		.byte	1
 14106 05b8 00       		.byte	0
 14107 05b9 0F       		.byte	15
 14108 05ba 00       		.byte	0
 14109 05bb 0F       		.byte	15
 14110 05bc 00       		.byte	0
 14111 05bd 03       		.byte	3
 14112 05be 00       		.byte	0
 14113 05bf 02       		.byte	2
 14114 05c0 00       		.byte	0
 14115 05c1 02       		.byte	2
 14116 05c2 00       		.byte	0
 14117 05c3 30       		.byte	48
 14118 05c4 01       		.byte	1
 14119 05c5 01       		.byte	1
 14120 05c6 00       		.byte	0
 14121 05c7 00000000 		.space	5
 14121      00
 14122 05cc 02       		.byte	2
 14123 05cd 00       		.byte	0
 14124 05ce 01       		.byte	1
 14125 05cf 00       		.byte	0
 14126 05d0 00       		.byte	0
 14127 05d1 01       		.byte	1
 14128 05d2 00       		.byte	0
 14129 05d3 01       		.byte	1
 14130 05d4 00       		.byte	0
 14131 05d5 03       		.byte	3
 14132 05d6 00       		.byte	0
 14133 05d7 00       		.byte	0
 14134 05d8 00       		.byte	0
 14135 05d9 00       		.byte	0
 14136 05da 00       		.byte	0
 14137 05db 30       		.byte	48
 14138 05dc 01       		.byte	1
 14139 05dd 01       		.byte	1
 14140 05de 00       		.byte	0
 14141 05df 00000000 		.space	5
 14141      00
 14142 05e4 00       		.byte	0
 14143 05e5 00       		.byte	0
 14144 05e6 04       		.byte	4
 14145 05e7 01       		.byte	1
 14146 05e8 00       		.byte	0
 14147 05e9 38       		.byte	56
 14148 05ea 01       		.byte	1
 14149 05eb 01       		.byte	1
 14150 05ec 00       		.byte	0
 14151 05ed 03       		.byte	3
 14152 05ee 00       		.byte	0
 14153 05ef 4E       		.byte	78
 14154 05f0 00       		.byte	0
 14155 05f1 4E       		.byte	78
 14156 05f2 00       		.byte	0
 14157 05f3 30       		.byte	48
 14158 05f4 01       		.byte	1
 14159 05f5 00       		.byte	0
 14160 05f6 00       		.byte	0
 14161 05f7 00000000 		.space	5
 14161      00
 14162 05fc 04       		.byte	4
 14163 05fd 00       		.byte	0
 14164 05fe 01       		.byte	1
 14165 05ff 00       		.byte	0
 14166 0600 00       		.byte	0
 14167 0601 00       		.byte	0
 14168 0602 00       		.byte	0
 14169 0603 01       		.byte	1
 14170 0604 00       		.byte	0
 14171 0605 03       		.byte	3
 14172 0606 00       		.byte	0
 14173 0607 00       		.byte	0
 14174 0608 00       		.byte	0
 14175 0609 00       		.byte	0
 14176 060a 00       		.byte	0
 14177 060b 30       		.byte	48
 14178 060c 01       		.byte	1
 14179 060d 00       		.byte	0
 14180 060e 00       		.byte	0
 14181 060f 00000000 		.space	5
 14181      00
 14182 0614 05       		.byte	5
 14183 0615 00       		.byte	0
 14184 0616 02       		.byte	2
 14185 0617 00       		.byte	0
 14186 0618 00       		.byte	0
 14187 0619 FF       		.byte	-1
 14188 061a 00       		.byte	0
 14189 061b 01       		.byte	1
 14190 061c 00       		.byte	0
 14191 061d 03       		.byte	3
 14192 061e 00       		.byte	0
 14193 061f 01       		.byte	1
 14194 0620 00       		.byte	0
 14195 0621 00       		.byte	0
 14196 0622 00       		.byte	0
 14197 0623 30       		.byte	48
 14198 0624 01       		.byte	1
 14199 0625 01       		.byte	1
 14200 0626 00       		.byte	0
 14201 0627 00000000 		.space	5
 14201      00
 14202 062c 06       		.byte	6
 14203 062d 00       		.byte	0
 14204 062e 02       		.byte	2
 14205 062f 00       		.byte	0
 14206 0630 00       		.byte	0
 14207 0631 00       		.byte	0
 14208 0632 00       		.byte	0
 14209 0633 00       		.byte	0
 14210 0634 00       		.byte	0
 14211 0635 03       		.byte	3
 14212 0636 00       		.byte	0
 14213 0637 00       		.byte	0
 14214 0638 00       		.byte	0
 14215 0639 00       		.byte	0
 14216 063a 00       		.byte	0
 14217 063b 30       		.byte	48
 14218 063c 01       		.byte	1
 14219 063d 01       		.byte	1
 14220 063e 00       		.byte	0
 14221 063f 00000000 		.space	5
 14221      00
 14222 0644 23       		.byte	35
 14223 0645 00       		.byte	0
 14224 0646 02       		.byte	2
 14225 0647 00       		.byte	0
 14226 0648 00       		.byte	0
 14227 0649 30       		.byte	48
 14228 064a 00       		.byte	0
 14229 064b 01       		.byte	1
 14230 064c 00       		.byte	0
 14231 064d 03       		.byte	3
 14232 064e 0A       		.byte	10
 14233 064f 00       		.byte	0
 14234 0650 00       		.byte	0
 14235 0651 0A       		.byte	10
 14236 0652 00       		.byte	0
 14237 0653 30       		.byte	48
 14238 0654 01       		.byte	1
 14239 0655 01       		.byte	1
 14240 0656 00       		.byte	0
 14241 0657 00000000 		.space	5
 14241      00
 14242 065c 08       		.byte	8
 14243 065d 00       		.byte	0
 14244 065e 01       		.byte	1
 14245 065f 00       		.byte	0
 14246 0660 00       		.byte	0
 14247 0661 7F       		.byte	127
 14248 0662 00       		.byte	0
 14249 0663 01       		.byte	1
 14250 0664 00       		.byte	0
 14251 0665 03       		.byte	3
 14252 0666 00       		.byte	0
 14253 0667 00       		.byte	0
 14254 0668 00       		.byte	0
 14255 0669 00       		.byte	0
 14256 066a 00       		.byte	0
 14257 066b 30       		.byte	48
 14258 066c 01       		.byte	1
 14259 066d 00       		.byte	0
 14260 066e 00       		.byte	0
 14261 066f 00000000 		.space	5
 14261      00
 14262 0674 09       		.byte	9
 14263 0675 00       		.byte	0
 14264 0676 02       		.byte	2
 14265 0677 00       		.byte	0
 14266 0678 00       		.byte	0
 14267 0679 05       		.byte	5
 14268 067a 00       		.byte	0
 14269 067b 01       		.byte	1
 14270 067c 00       		.byte	0
 14271 067d 03       		.byte	3
 14272 067e 00       		.byte	0
 14273 067f 00       		.byte	0
 14274 0680 00       		.byte	0
 14275 0681 00       		.byte	0
 14276 0682 00       		.byte	0
 14277 0683 30       		.byte	48
 14278 0684 01       		.byte	1
 14279 0685 00       		.byte	0
 14280 0686 00       		.byte	0
 14281 0687 00000000 		.space	5
 14281      00
 14282 068c 10       		.byte	16
 14283 068d 00       		.byte	0
 14284 068e 03       		.byte	3
 14285 068f 00       		.byte	0
 14286 0690 00       		.byte	0
 14287 0691 00       		.byte	0
 14288 0692 00       		.byte	0
 14289 0693 00       		.byte	0
 14290 0694 00       		.byte	0
 14291 0695 03       		.byte	3
 14292 0696 00       		.byte	0
 14293 0697 00       		.byte	0
 14294 0698 00       		.byte	0
 14295 0699 00       		.byte	0
 14296 069a 00       		.byte	0
 14297 069b 30       		.byte	48
 14298 069c 01       		.byte	1
 14299 069d 00       		.byte	0
 14300 069e 00       		.byte	0
 14301 069f 00000000 		.space	5
 14301      00
 14302 06a4 00       		.byte	0
 14303 06a5 00       		.byte	0
 14304 06a6 02       		.byte	2
 14305 06a7 00       		.byte	0
 14306 06a8 00       		.byte	0
 14307 06a9 40       		.byte	64
 14308 06aa 00       		.byte	0
 14309 06ab 01       		.byte	1
 14310 06ac 00       		.byte	0
 14311 06ad 03       		.byte	3
 14312 06ae 00       		.byte	0
 14313 06af 0F       		.byte	15
 14314 06b0 11       		.byte	17
 14315 06b1 00       		.byte	0
 14316 06b2 00       		.byte	0
 14317 06b3 30       		.byte	48
 14318 06b4 01       		.byte	1
 14319 06b5 00       		.byte	0
 14320 06b6 00       		.byte	0
 14321 06b7 00000000 		.space	5
 14321      00
 14322 06bc 00       		.byte	0
 14323 06bd 00       		.byte	0
 14324 06be 02       		.byte	2
 14325 06bf 00       		.byte	0
 14326 06c0 00       		.byte	0
 14327 06c1 64       		.byte	100
 14328 06c2 00       		.byte	0
 14329 06c3 01       		.byte	1
 14330 06c4 00       		.byte	0
 14331 06c5 03       		.byte	3
 14332 06c6 00       		.byte	0
 14333 06c7 00       		.byte	0
 14334 06c8 00       		.byte	0
 14335 06c9 00       		.byte	0
 14336 06ca 00       		.byte	0
 14337 06cb 30       		.byte	48
 14338 06cc 01       		.byte	1
 14339 06cd 00       		.byte	0
 14340 06ce 00       		.byte	0
 14341 06cf 00000000 		.space	5
 14341      00
 14342 06d4 00       		.byte	0
 14343 06d5 00       		.byte	0
 14344 06d6 02       		.byte	2
 14345 06d7 00       		.byte	0
 14346 06d8 00       		.byte	0
 14347 06d9 64       		.byte	100
 14348 06da 00       		.byte	0
 14349 06db 01       		.byte	1
 14350 06dc 00       		.byte	0
 14351 06dd 03       		.byte	3
 14352 06de 00       		.byte	0
 14353 06df 00       		.byte	0
 14354 06e0 00       		.byte	0
 14355 06e1 00       		.byte	0
 14356 06e2 00       		.byte	0
 14357 06e3 30       		.byte	48
 14358 06e4 01       		.byte	1
 14359 06e5 00       		.byte	0
 14360 06e6 00       		.byte	0
 14361 06e7 00000000 		.space	5
 14361      00
 14362 06ec 00       		.byte	0
 14363 06ed 00       		.byte	0
 14364 06ee 02       		.byte	2
 14365 06ef 00       		.byte	0
 14366 06f0 00       		.byte	0
 14367 06f1 64       		.byte	100
 14368 06f2 00       		.byte	0
 14369 06f3 01       		.byte	1
 14370 06f4 00       		.byte	0
 14371 06f5 03       		.byte	3
 14372 06f6 00       		.byte	0
 14373 06f7 00       		.byte	0
 14374 06f8 00       		.byte	0
 14375 06f9 00       		.byte	0
 14376 06fa 00       		.byte	0
 14377 06fb 30       		.byte	48
 14378 06fc 01       		.byte	1
 14379 06fd 00       		.byte	0
 14380 06fe 00       		.byte	0
 14381 06ff 00000000 		.space	5
 14381      00
 14382 0704 00       		.byte	0
 14383 0705 00       		.byte	0
 14384 0706 02       		.byte	2
 14385 0707 00       		.byte	0
 14386 0708 00       		.byte	0
 14387 0709 64       		.byte	100
 14388 070a 00       		.byte	0
 14389 070b 01       		.byte	1
 14390 070c 00       		.byte	0
 14391 070d 03       		.byte	3
 14392 070e 00       		.byte	0
 14393 070f 00       		.byte	0
 14394 0710 00       		.byte	0
 14395 0711 00       		.byte	0
 14396 0712 00       		.byte	0
 14397 0713 30       		.byte	48
 14398 0714 01       		.byte	1
 14399 0715 00       		.byte	0
 14400 0716 00       		.byte	0
 14401 0717 00000000 		.space	5
 14401      00
 14404              	PUCDZoom:
 14405 071c 2A       		.byte	42
 14406 071d 2A       		.byte	42
 14407 071e 02       		.byte	2
 14408 071f 00       		.byte	0
 14409 0720 00       		.byte	0
 14410 0721 1B       		.byte	27
 14411 0722 00       		.byte	0
 14412 0723 01       		.byte	1
 14413 0724 00       		.byte	0
 14414 0725 03       		.byte	3
 14415 0726 00       		.byte	0
 14416 0727 00       		.byte	0
 14417 0728 00       		.byte	0
 14418 0729 00       		.byte	0
 14419 072a 00       		.byte	0
 14420 072b 30       		.byte	48
 14421 072c 01       		.byte	1
 14422 072d 00       		.byte	0
 14423 072e 0000     		.space	2
 14426              	EXTEnhanceMode:
 14427 0730 06       		.byte	6
 14428 0731 06       		.byte	6
 14429 0732 02       		.byte	2
 14430 0733 00       		.byte	0
 14431 0734 00       		.byte	0
 14432 0735 FF       		.byte	-1
 14433 0736 00       		.byte	0
 14434 0737 01       		.byte	1
 14435 0738 00       		.byte	0
 14436 0739 03       		.byte	3
 14437 073a 00       		.byte	0
 14438 073b 80       		.byte	-128
 14439 073c 00       		.byte	0
 14440 073d 80       		.byte	-128
 14441 073e 00       		.byte	0
 14442 073f 30       		.byte	48
 14443 0740 01       		.byte	1
 14444 0741 00       		.byte	0
 14445 0742 0000     		.space	2
 14448              	EXTEnhanceGain:
 14449 0744 07       		.byte	7
 14450 0745 07       		.byte	7
 14451 0746 02       		.byte	2
 14452 0747 00       		.byte	0
 14453 0748 00       		.byte	0
 14454 0749 FF       		.byte	-1
 14455 074a 00       		.byte	0
 14456 074b 01       		.byte	1
 14457 074c 00       		.byte	0
 14458 074d 03       		.byte	3
 14459 074e 00       		.byte	0
 14460 074f 80       		.byte	-128
 14461 0750 00       		.byte	0
 14462 0751 80       		.byte	-128
 14463 0752 00       		.byte	0
 14464 0753 30       		.byte	48
 14465 0754 01       		.byte	1
 14466 0755 00       		.byte	0
 14469              	snapButFlag:
 14470 0756 01       		.byte	1
 14471 0757 00       		.space	1
 14474              	EXTGammaCor:
 14475 0758 17       		.byte	23
 14476 0759 17       		.byte	23
 14477 075a 02       		.byte	2
 14478 075b 00       		.byte	0
 14479 075c 00       		.byte	0
 14480 075d 10       		.byte	16
 14481 075e 00       		.byte	0
 14482 075f 01       		.byte	1
 14483 0760 00       		.byte	0
 14484 0761 03       		.byte	3
 14485 0762 00       		.byte	0
 14486 0763 00       		.byte	0
 14487 0764 00       		.byte	0
 14488 0765 00       		.byte	0
 14489 0766 00       		.byte	0
 14490 0767 30       		.byte	48
 14491 0768 01       		.byte	1
 14492 0769 00       		.byte	0
 14493 076a 0000     		.space	2
 14496              	EXT2DNRSTED:
 14497 076c 1A       		.byte	26
 14498 076d 1B       		.byte	27
 14499 076e 04       		.byte	4
 14500 076f 00       		.byte	0
 14501 0770 00       		.byte	0
 14502 0771 FF       		.byte	-1
 14503 0772 00       		.byte	0
 14504 0773 01       		.byte	1
 14505 0774 00       		.byte	0
 14506 0775 03       		.byte	3
 14507 0776 00       		.byte	0
 14508 0777 80       		.byte	-128
 14509 0778 00       		.byte	0
 14510 0779 80       		.byte	-128
 14511 077a 00       		.byte	0
 14512 077b 30       		.byte	48
 14513 077c 01       		.byte	1
 14514 077d 00       		.byte	0
 14515 077e 0000     		.space	2
 14518              	EXT2DNRGain:
 14519 0780 18       		.byte	24
 14520 0781 19       		.byte	25
 14521 0782 02       		.byte	2
 14522 0783 00       		.byte	0
 14523 0784 00       		.byte	0
 14524 0785 FF       		.byte	-1
 14525 0786 00       		.byte	0
 14526 0787 01       		.byte	1
 14527 0788 00       		.byte	0
 14528 0789 03       		.byte	3
 14529 078a 00       		.byte	0
 14530 078b 80       		.byte	-128
 14531 078c 00       		.byte	0
 14532 078d 80       		.byte	-128
 14533 078e 00       		.byte	0
 14534 078f 30       		.byte	48
 14535 0790 01       		.byte	1
 14536 0791 00       		.byte	0
 14537 0792 0000     		.space	2
 14540              	EXTEnhanceSTED:
 14541 0794 08       		.byte	8
 14542 0795 09       		.byte	9
 14543 0796 04       		.byte	4
 14544 0797 00       		.byte	0
 14545 0798 00       		.byte	0
 14546 0799 FF       		.byte	-1
 14547 079a 00       		.byte	0
 14548 079b 01       		.byte	1
 14549 079c 00       		.byte	0
 14550 079d 03       		.byte	3
 14551 079e 00       		.byte	0
 14552 079f 80       		.byte	-128
 14553 07a0 00       		.byte	0
 14554 07a1 80       		.byte	-128
 14555 07a2 00       		.byte	0
 14556 07a3 30       		.byte	48
 14557 07a4 01       		.byte	1
 14558 07a5 00       		.byte	0
 14559 07a6 0000     		.space	2
 14562              	EXTExCtrlSped:
 14563 07a8 F8       		.byte	-8
 14564 07a9 F8       		.byte	-8
 14565 07aa 02       		.byte	2
 14566 07ab 00       		.byte	0
 14567 07ac 00       		.byte	0
 14568 07ad FF       		.byte	-1
 14569 07ae 00       		.byte	0
 14570 07af 01       		.byte	1
 14571 07b0 00       		.byte	0
 14572 07b1 03       		.byte	3
 14573 07b2 00       		.byte	0
 14574 07b3 80       		.byte	-128
 14575 07b4 00       		.byte	0
 14576 07b5 80       		.byte	-128
 14577 07b6 00       		.byte	0
 14578 07b7 30       		.byte	48
 14579 07b8 01       		.byte	1
 14580 07b9 00       		.byte	0
 14581 07ba 0000     		.space	2
 14584              	EXTExHyster:
 14585 07bc 0B       		.byte	11
 14586 07bd 0B       		.byte	11
 14587 07be 02       		.byte	2
 14588 07bf 00       		.byte	0
 14589 07c0 00       		.byte	0
 14590 07c1 FF       		.byte	-1
 14591 07c2 00       		.byte	0
 14592 07c3 01       		.byte	1
 14593 07c4 00       		.byte	0
 14594 07c5 03       		.byte	3
 14595 07c6 00       		.byte	0
 14596 07c7 80       		.byte	-128
 14597 07c8 00       		.byte	0
 14598 07c9 80       		.byte	-128
 14599 07ca 00       		.byte	0
 14600 07cb 30       		.byte	48
 14601 07cc 01       		.byte	1
 14602 07cd 00       		.byte	0
 14603 07ce 0000     		.space	2
 14606              	EXTShutlev:
 14607 07d0 02       		.byte	2
 14608 07d1 12       		.byte	18
 14609 07d2 02       		.byte	2
 14610 07d3 00       		.byte	0
 14611 07d4 00       		.byte	0
 14612 07d5 FF       		.byte	-1
 14613 07d6 7F       		.byte	127
 14614 07d7 01       		.byte	1
 14615 07d8 00       		.byte	0
 14616 07d9 03       		.byte	3
 14617 07da 00       		.byte	0
 14618 07db 3F       		.byte	63
 14619 07dc 00       		.byte	0
 14620 07dd 3F       		.byte	63
 14621 07de 00       		.byte	0
 14622 07df 30       		.byte	48
 14623 07e0 01       		.byte	1
 14624 07e1 00       		.byte	0
 14625 07e2 0000     		.space	2
 14628              	EXTBLCWeight:
 14629 07e4 11       		.byte	17
 14630 07e5 11       		.byte	17
 14631 07e6 02       		.byte	2
 14632 07e7 00       		.byte	0
 14633 07e8 00       		.byte	0
 14634 07e9 FF       		.byte	-1
 14635 07ea 00       		.byte	0
 14636 07eb 01       		.byte	1
 14637 07ec 00       		.byte	0
 14638 07ed 03       		.byte	3
 14639 07ee 00       		.byte	0
 14640 07ef 80       		.byte	-128
 14641 07f0 00       		.byte	0
 14642 07f1 80       		.byte	-128
 14643 07f2 00       		.byte	0
 14644 07f3 30       		.byte	48
 14645 07f4 01       		.byte	1
 14646 07f5 00       		.byte	0
 14647 07f6 0000     		.space	2
 14650              	EXTSensorPare:
 14651 07f8 50       		.byte	80
 14652 07f9 50       		.byte	80
 14653 07fa 02       		.byte	2
 14654 07fb 00       		.byte	0
 14655 07fc 00       		.byte	0
 14656 07fd 03       		.byte	3
 14657 07fe 00       		.byte	0
 14658 07ff 01       		.byte	1
 14659 0800 00       		.byte	0
 14660 0801 03       		.byte	3
 14661 0802 00       		.byte	0
 14662 0803 00       		.byte	0
 14663 0804 00       		.byte	0
 14664 0805 00       		.byte	0
 14665 0806 00       		.byte	0
 14666 0807 30       		.byte	48
 14667 0808 01       		.byte	1
 14668 0809 00       		.byte	0
 14669 080a 0000     		.space	2
 14672              	EXTCamMode:
 14673 080c 10       		.byte	16
 14674 080d 10       		.byte	16
 14675 080e 02       		.byte	2
 14676 080f 00       		.byte	0
 14677 0810 00       		.byte	0
 14678 0811 06       		.byte	6
 14679 0812 00       		.byte	0
 14680 0813 01       		.byte	1
 14681 0814 00       		.byte	0
 14682 0815 03       		.byte	3
 14683 0816 00       		.byte	0
 14684 0817 03       		.byte	3
 14685 0818 00       		.byte	0
 14686 0819 03       		.byte	3
 14687 081a 00       		.byte	0
 14688 081b 30       		.byte	48
 14689 081c 01       		.byte	1
 14690 081d 00       		.byte	0
 14691 081e 0000     		.space	2
 14694              	EXTExpReflev:
 14695 0820 04       		.byte	4
 14696 0821 04       		.byte	4
 14697 0822 02       		.byte	2
 14698 0823 00       		.byte	0
 14699 0824 00       		.byte	0
 14700 0825 FF       		.byte	-1
 14701 0826 00       		.byte	0
 14702 0827 01       		.byte	1
 14703 0828 00       		.byte	0
 14704 0829 03       		.byte	3
 14705 082a 00       		.byte	0
 14706 082b 3C       		.byte	60
 14707 082c 00       		.byte	0
 14708 082d 3C       		.byte	60
 14709 082e 00       		.byte	0
 14710 082f 30       		.byte	48
 14711 0830 01       		.byte	1
 14712 0831 00       		.byte	0
 14713 0832 0000     		.space	2
 14716              	EXTNightDaylev:
 14717 0834 24       		.byte	36
 14718 0835 24       		.byte	36
 14719 0836 02       		.byte	2
 14720 0837 00       		.byte	0
 14721 0838 00       		.byte	0
 14722 0839 64       		.byte	100
 14723 083a 00       		.byte	0
 14724 083b 01       		.byte	1
 14725 083c 00       		.byte	0
 14726 083d 03       		.byte	3
 14727 083e 00       		.byte	0
 14728 083f 10       		.byte	16
 14729 0840 00       		.byte	0
 14730 0841 10       		.byte	16
 14731 0842 00       		.byte	0
 14732 0843 30       		.byte	48
 14733 0844 01       		.byte	1
 14734 0845 00       		.byte	0
 14735 0846 0000     		.space	2
 14738              	EXTDayNightlev:
 14739 0848 23       		.byte	35
 14740 0849 23       		.byte	35
 14741 084a 02       		.byte	2
 14742 084b 00       		.byte	0
 14743 084c 00       		.byte	0
 14744 084d 64       		.byte	100
 14745 084e 00       		.byte	0
 14746 084f 01       		.byte	1
 14747 0850 00       		.byte	0
 14748 0851 03       		.byte	3
 14749 0852 00       		.byte	0
 14750 0853 10       		.byte	16
 14751 0854 00       		.byte	0
 14752 0855 10       		.byte	16
 14753 0856 00       		.byte	0
 14754 0857 30       		.byte	48
 14755 0858 01       		.byte	1
 14756 0859 00       		.byte	0
 14757 085a 0000     		.space	2
 14760              	EXTDayNightdely:
 14761 085c 22       		.byte	34
 14762 085d 22       		.byte	34
 14763 085e 02       		.byte	2
 14764 085f 00       		.byte	0
 14765 0860 00       		.byte	0
 14766 0861 3F       		.byte	63
 14767 0862 00       		.byte	0
 14768 0863 01       		.byte	1
 14769 0864 00       		.byte	0
 14770 0865 03       		.byte	3
 14771 0866 00       		.byte	0
 14772 0867 00       		.byte	0
 14773 0868 00       		.byte	0
 14774 0869 00       		.byte	0
 14775 086a 00       		.byte	0
 14776 086b 30       		.byte	48
 14777 086c 01       		.byte	1
 14778 086d 00       		.byte	0
 14779 086e 0000     		.space	2
 14782              	EXTDayNightMode:
 14783 0870 20       		.byte	32
 14784 0871 20       		.byte	32
 14785 0872 02       		.byte	2
 14786 0873 00       		.byte	0
 14787 0874 00       		.byte	0
 14788 0875 02       		.byte	2
 14789 0876 00       		.byte	0
 14790 0877 01       		.byte	1
 14791 0878 00       		.byte	0
 14792 0879 03       		.byte	3
 14793 087a 00       		.byte	0
 14794 087b 00       		.byte	0
 14795 087c 00       		.byte	0
 14796 087d 00       		.byte	0
 14797 087e 00       		.byte	0
 14798 087f 30       		.byte	48
 14799 0880 01       		.byte	1
 14800 0881 00       		.byte	0
 14801 0882 0000     		.space	2
 14804              	EXT3DNoiseLev:
 14805 0884 19       		.byte	25
 14806 0885 19       		.byte	25
 14807 0886 02       		.byte	2
 14808 0887 00       		.byte	0
 14809 0888 00       		.byte	0
 14810 0889 40       		.byte	64
 14811 088a 00       		.byte	0
 14812 088b 01       		.byte	1
 14813 088c 00       		.byte	0
 14814 088d 03       		.byte	3
 14815 088e 00       		.byte	0
 14816 088f 20       		.byte	32
 14817 0890 00       		.byte	0
 14818 0891 20       		.byte	32
 14819 0892 00       		.byte	0
 14820 0893 30       		.byte	48
 14821 0894 01       		.byte	1
 14822 0895 00       		.byte	0
 14823 0896 0000     		.space	2
 14826              	EXT3DnoiseReduceMode:
 14827 0898 18       		.byte	24
 14828 0899 18       		.byte	24
 14829 089a 02       		.byte	2
 14830 089b 00       		.byte	0
 14831 089c 00       		.byte	0
 14832 089d 01       		.byte	1
 14833 089e 00       		.byte	0
 14834 089f 01       		.byte	1
 14835 08a0 00       		.byte	0
 14836 08a1 03       		.byte	3
 14837 08a2 00       		.byte	0
 14838 08a3 00       		.byte	0
 14839 08a4 00       		.byte	0
 14840 08a5 00       		.byte	0
 14841 08a6 00       		.byte	0
 14842 08a7 30       		.byte	48
 14843 08a8 01       		.byte	1
 14844 08a9 00       		.byte	0
 14845 08aa 0000     		.space	2
 14848              	EXTMirror:
 14849 08ac 05       		.byte	5
 14850 08ad 05       		.byte	5
 14851 08ae 02       		.byte	2
 14852 08af 00       		.byte	0
 14853 08b0 00       		.byte	0
 14854 08b1 03       		.byte	3
 14855 08b2 00       		.byte	0
 14856 08b3 01       		.byte	1
 14857 08b4 00       		.byte	0
 14858 08b5 03       		.byte	3
 14859 08b6 00       		.byte	0
 14860 08b7 00       		.byte	0
 14861 08b8 00       		.byte	0
 14862 08b9 00       		.byte	0
 14863 08ba 00       		.byte	0
 14864 08bb 30       		.byte	48
 14865 08bc 01       		.byte	1
 14866 08bd 00       		.byte	0
 14867 08be 0000     		.space	2
 14870              	EXTSensUp:
 14871 08c0 01       		.byte	1
 14872 08c1 01       		.byte	1
 14873 08c2 02       		.byte	2
 14874 08c3 00       		.byte	0
 14875 08c4 00       		.byte	0
 14876 08c5 09       		.byte	9
 14877 08c6 00       		.byte	0
 14878 08c7 01       		.byte	1
 14879 08c8 00       		.byte	0
 14880 08c9 03       		.byte	3
 14881 08ca 00       		.byte	0
 14882 08cb 00       		.byte	0
 14883 08cc 00       		.byte	0
 14884 08cd 01       		.byte	1
 14885 08ce 00       		.byte	0
 14886 08cf 30       		.byte	48
 14887 08d0 01       		.byte	1
 14888 08d1 00       		.byte	0
 14889 08d2 0000     		.space	2
 14892              	PUCWBLC:
 14893 08d4 09       		.byte	9
 14894 08d5 0A       		.byte	10
 14895 08d6 04       		.byte	4
 14896 08d7 00       		.byte	0
 14897 08d8 00       		.byte	0
 14898 08d9 40       		.byte	64
 14899 08da 00       		.byte	0
 14900 08db 01       		.byte	1
 14901 08dc 00       		.byte	0
 14902 08dd 03       		.byte	3
 14903 08de 00       		.byte	0
 14904 08df 20       		.byte	32
 14905 08e0 00       		.byte	0
 14906 08e1 38       		.byte	56
 14907 08e2 00       		.byte	0
 14908 08e3 30       		.byte	48
 14909 08e4 01       		.byte	1
 14910 08e5 00       		.byte	0
 14911 08e6 0000     		.space	2
 14914              	PUCWBMd:
 14915 08e8 08       		.byte	8
 14916 08e9 08       		.byte	8
 14917 08ea 02       		.byte	2
 14918 08eb 00       		.byte	0
 14919 08ec 00       		.byte	0
 14920 08ed 05       		.byte	5
 14921 08ee 00       		.byte	0
 14922 08ef 01       		.byte	1
 14923 08f0 00       		.byte	0
 14924 08f1 03       		.byte	3
 14925 08f2 00       		.byte	0
 14926 08f3 00       		.byte	0
 14927 08f4 00       		.byte	0
 14928 08f5 00       		.byte	0
 14929 08f6 00       		.byte	0
 14930 08f7 30       		.byte	48
 14931 08f8 01       		.byte	1
 14932 08f9 00       		.byte	0
 14933 08fa 0000     		.space	2
 14936              	PUCSharp:
 14937 08fc 06       		.byte	6
 14938 08fd 07       		.byte	7
 14939 08fe 02       		.byte	2
 14940 08ff 00       		.byte	0
 14941 0900 00       		.byte	0
 14942 0901 08       		.byte	8
 14943 0902 00       		.byte	0
 14944 0903 01       		.byte	1
 14945 0904 00       		.byte	0
 14946 0905 03       		.byte	3
 14947 0906 00       		.byte	0
 14948 0907 00       		.byte	0
 14949 0908 00       		.byte	0
 14950 0909 00       		.byte	0
 14951 090a 00       		.byte	0
 14952 090b 30       		.byte	48
 14953 090c 01       		.byte	1
 14954 090d 00       		.byte	0
 14955 090e 0000     		.space	2
 14958              	PUCSaturation:
 14959 0910 85       		.byte	-123
 14960 0911 86       		.byte	-122
 14961 0912 02       		.byte	2
 14962 0913 00       		.byte	0
 14963 0914 00       		.byte	0
 14964 0915 64       		.byte	100
 14965 0916 00       		.byte	0
 14966 0917 01       		.byte	1
 14967 0918 00       		.byte	0
 14968 0919 03       		.byte	3
 14969 091a 00       		.byte	0
 14970 091b 32       		.byte	50
 14971 091c 00       		.byte	0
 14972 091d 32       		.byte	50
 14973 091e 00       		.byte	0
 14974 091f 30       		.byte	48
 14975 0920 01       		.byte	1
 14976 0921 00       		.byte	0
 14977 0922 0000     		.space	2
 14980              	PUCContrast:
 14981 0924 0D       		.byte	13
 14982 0925 0D       		.byte	13
 14983 0926 02       		.byte	2
 14984 0927 00       		.byte	0
 14985 0928 00       		.byte	0
 14986 0929 FF       		.byte	-1
 14987 092a 00       		.byte	0
 14988 092b 01       		.byte	1
 14989 092c 00       		.byte	0
 14990 092d 03       		.byte	3
 14991 092e 00       		.byte	0
 14992 092f 70       		.byte	112
 14993 0930 00       		.byte	0
 14994 0931 70       		.byte	112
 14995 0932 00       		.byte	0
 14996 0933 30       		.byte	48
 14997 0934 01       		.byte	1
 14998 0935 00       		.byte	0
 14999 0936 0000     		.space	2
 15002              	CyFxGpifRegValue_usb2:
 15003 0938 08830080 		.word	-2147450104
 15004 093c 67000000 		.word	103
 15005 0940 01000000 		.word	1
 15006 0944 46000000 		.word	70
 15007 0948 00000000 		.word	0
 15008 094c 00000000 		.word	0
 15009 0950 02000000 		.word	2
 15010 0954 82000000 		.word	130
 15011 0958 82070000 		.word	1922
 15012 095c 40040000 		.word	1088
 15013 0960 FCFF0000 		.word	65532
 15014 0964 28000000 		.word	40
 15015 0968 00000000 		.word	0
 15016 096c 00000000 		.word	0
 15017 0970 00000000 		.word	0
 15018 0974 00000000 		.word	0
 15019 0978 01000000 		.word	1
 15020 097c 00000000 		.word	0
 15021 0980 00000000 		.word	0
 15022 0984 00000000 		.word	0
 15023 0988 00000000 		.word	0
 15024 098c 00000000 		.word	0
 15025 0990 00000000 		.word	0
 15026 0994 00000000 		.word	0
 15027 0998 00000000 		.word	0
 15028 099c 00000000 		.word	0
 15029 09a0 00000000 		.word	0
 15030 09a4 00000000 		.word	0
 15031 09a8 00000000 		.word	0
 15032 09ac 06000000 		.word	6
 15033 09b0 00000000 		.word	0
 15034 09b4 FFFF0000 		.word	65535
 15035 09b8 09010000 		.word	265
 15036 09bc 00000000 		.word	0
 15037 09c0 F71F0000 		.word	8183
 15038 09c4 00000000 		.word	0
 15039 09c8 FFFF0000 		.word	65535
 15040 09cc 09010000 		.word	265
 15041 09d0 00000000 		.word	0
 15042 09d4 F71F0000 		.word	8183
 15043 09d8 00000000 		.word	0
 15044 09dc 00000000 		.word	0
 15045 09e0 00000000 		.word	0
 15046 09e4 00000000 		.word	0
 15047 09e8 00000000 		.word	0
 15048 09ec 00000000 		.word	0
 15049 09f0 00000000 		.word	0
 15050 09f4 00000000 		.word	0
 15051 09f8 00000000 		.word	0
 15052 09fc 00000000 		.word	0
 15053 0a00 00000000 		.word	0
 15054 0a04 00000000 		.word	0
 15055 0a08 00000000 		.word	0
 15056 0a0c 00000000 		.word	0
 15057 0a10 00000000 		.word	0
 15058 0a14 00000000 		.word	0
 15059 0a18 00000000 		.word	0
 15060 0a1c 00000000 		.word	0
 15061 0a20 00000000 		.word	0
 15062 0a24 00000000 		.word	0
 15063 0a28 00000000 		.word	0
 15064 0a2c 00000000 		.word	0
 15065 0a30 00000000 		.word	0
 15066 0a34 00040180 		.word	-2147417088
 15067 0a38 01040180 		.word	-2147417087
 15068 0a3c 02040180 		.word	-2147417086
 15069 0a40 03040180 		.word	-2147417085
 15070 0a44 00000000 		.word	0
 15071 0a48 00000000 		.word	0
 15072 0a4c 00000000 		.word	0
 15073 0a50 00000000 		.word	0
 15074 0a54 00000000 		.word	0
 15075 0a58 00000000 		.word	0
 15076 0a5c 00000000 		.word	0
 15077 0a60 00000000 		.word	0
 15078 0a64 C1FFFFFF 		.word	-63
 15081              	CyFxGpifWavedataPosition_usb2:
 15082 0a68 00       		.byte	0
 15083 0a69 01       		.byte	1
 15084 0a6a 02       		.byte	2
 15085 0a6b 03       		.byte	3
 15086 0a6c 04       		.byte	4
 15087 0a6d 05       		.byte	5
 15088 0a6e 06       		.byte	6
 15089 0a6f 07       		.byte	7
 15090 0a70 08       		.byte	8
 15091 0a71 09       		.byte	9
 15092 0a72 0A       		.byte	10
 15093 0a73 08       		.byte	8
 15094 0a74 0B       		.byte	11
 15095 0a75 0C       		.byte	12
 15096 0a76 0D       		.byte	13
 15097 0a77 08       		.byte	8
 15098 0a78 0E       		.byte	14
 15099 0a79 0F       		.byte	15
 15100 0a7a 08       		.byte	8
 15101 0a7b 08       		.byte	8
 15102 0a7c 08       		.byte	8
 15103 0a7d 08       		.byte	8
 15104 0a7e 08       		.byte	8
 15105 0a7f 08       		.byte	8
 15106 0a80 08       		.byte	8
 15107 0a81 08       		.byte	8
 15108 0a82 08       		.byte	8
 15109 0a83 08       		.byte	8
 15110 0a84 08       		.byte	8
 15111 0a85 08       		.byte	8
 15112 0a86 08       		.byte	8
 15113 0a87 08       		.byte	8
 15114 0a88 08       		.byte	8
 15115 0a89 08       		.byte	8
 15116 0a8a 08       		.byte	8
 15117 0a8b 08       		.byte	8
 15118 0a8c 08       		.byte	8
 15119 0a8d 08       		.byte	8
 15120 0a8e 08       		.byte	8
 15121 0a8f 08       		.byte	8
 15122 0a90 08       		.byte	8
 15123 0a91 08       		.byte	8
 15124 0a92 08       		.byte	8
 15125 0a93 08       		.byte	8
 15126 0a94 08       		.byte	8
 15127 0a95 08       		.byte	8
 15128 0a96 08       		.byte	8
 15129 0a97 08       		.byte	8
 15130 0a98 08       		.byte	8
 15131 0a99 08       		.byte	8
 15132 0a9a 08       		.byte	8
 15133 0a9b 08       		.byte	8
 15134 0a9c 08       		.byte	8
 15135 0a9d 08       		.byte	8
 15136 0a9e 08       		.byte	8
 15137 0a9f 08       		.byte	8
 15138 0aa0 08       		.byte	8
 15139 0aa1 08       		.byte	8
 15140 0aa2 08       		.byte	8
 15141 0aa3 08       		.byte	8
 15142 0aa4 08       		.byte	8
 15143 0aa5 08       		.byte	8
 15144 0aa6 08       		.byte	8
 15145 0aa7 08       		.byte	8
 15146 0aa8 08       		.byte	8
 15147 0aa9 08       		.byte	8
 15148 0aaa 08       		.byte	8
 15149 0aab 08       		.byte	8
 15150 0aac 08       		.byte	8
 15151 0aad 08       		.byte	8
 15152 0aae 08       		.byte	8
 15153 0aaf 08       		.byte	8
 15154 0ab0 08       		.byte	8
 15155 0ab1 08       		.byte	8
 15156 0ab2 08       		.byte	8
 15157 0ab3 08       		.byte	8
 15158 0ab4 08       		.byte	8
 15159 0ab5 08       		.byte	8
 15160 0ab6 08       		.byte	8
 15161 0ab7 08       		.byte	8
 15162 0ab8 08       		.byte	8
 15163 0ab9 08       		.byte	8
 15164 0aba 08       		.byte	8
 15165 0abb 08       		.byte	8
 15166 0abc 08       		.byte	8
 15167 0abd 08       		.byte	8
 15168 0abe 08       		.byte	8
 15169 0abf 08       		.byte	8
 15170 0ac0 08       		.byte	8
 15171 0ac1 08       		.byte	8
 15172 0ac2 08       		.byte	8
 15173 0ac3 08       		.byte	8
 15174 0ac4 08       		.byte	8
 15175 0ac5 08       		.byte	8
 15176 0ac6 08       		.byte	8
 15177 0ac7 08       		.byte	8
 15178 0ac8 08       		.byte	8
 15179 0ac9 08       		.byte	8
 15180 0aca 08       		.byte	8
 15181 0acb 08       		.byte	8
 15182 0acc 08       		.byte	8
 15183 0acd 08       		.byte	8
 15184 0ace 08       		.byte	8
 15185 0acf 08       		.byte	8
 15186 0ad0 08       		.byte	8
 15187 0ad1 08       		.byte	8
 15188 0ad2 08       		.byte	8
 15189 0ad3 08       		.byte	8
 15190 0ad4 08       		.byte	8
 15191 0ad5 08       		.byte	8
 15192 0ad6 08       		.byte	8
 15193 0ad7 08       		.byte	8
 15194 0ad8 08       		.byte	8
 15195 0ad9 08       		.byte	8
 15196 0ada 08       		.byte	8
 15197 0adb 08       		.byte	8
 15198 0adc 08       		.byte	8
 15199 0add 08       		.byte	8
 15200 0ade 08       		.byte	8
 15201 0adf 08       		.byte	8
 15202 0ae0 08       		.byte	8
 15203 0ae1 08       		.byte	8
 15204 0ae2 08       		.byte	8
 15205 0ae3 08       		.byte	8
 15206 0ae4 08       		.byte	8
 15207 0ae5 08       		.byte	8
 15208 0ae6 08       		.byte	8
 15209 0ae7 08       		.byte	8
 15210 0ae8 00       		.byte	0
 15211 0ae9 01       		.byte	1
 15212 0aea 02       		.byte	2
 15213 0aeb 10       		.byte	16
 15214 0aec 04       		.byte	4
 15215 0aed 05       		.byte	5
 15216 0aee 06       		.byte	6
 15217 0aef 07       		.byte	7
 15218 0af0 08       		.byte	8
 15219 0af1 09       		.byte	9
 15220 0af2 0A       		.byte	10
 15221 0af3 08       		.byte	8
 15222 0af4 11       		.byte	17
 15223 0af5 0C       		.byte	12
 15224 0af6 0D       		.byte	13
 15225 0af7 08       		.byte	8
 15226 0af8 0E       		.byte	14
 15227 0af9 0F       		.byte	15
 15228 0afa 08       		.byte	8
 15229 0afb 00       		.space	1
 15232              	CyFxGpifWavedata_usb2:
 15233 0afc 0181731E 		.word	510886145
 15234 0b00 00000000 		.word	0
 15235 0b04 00000080 		.word	-2147483648
 15236 0b08 00000000 		.word	0
 15237 0b0c 00000000 		.word	0
 15238 0b10 00000000 		.word	0
 15239 0b14 0201703E 		.word	1047527682
 15240 0b18 00010000 		.word	256
 15241 0b1c A00000C0 		.word	-1073741664
 15242 0b20 00000000 		.word	0
 15243 0b24 00000000 		.word	0
 15244 0b28 00000000 		.word	0
 15245 0b2c 0394731E 		.word	510891011
 15246 0b30 04000020 		.word	536870916
 15247 0b34 60004080 		.word	-2143289248
 15248 0b38 00000000 		.word	0
 15249 0b3c 00000000 		.word	0
 15250 0b40 00000000 		.word	0
 15251 0b44 0620702E 		.word	779100166
 15252 0b48 0C000000 		.word	12
 15253 0b4c 00000080 		.word	-2147483648
 15254 0b50 0620702E 		.word	779100166
 15255 0b54 0C000000 		.word	12
 15256 0b58 00000080 		.word	-2147483648
 15257 0b5c 0394731E 		.word	510891011
 15258 0b60 04000020 		.word	536870916
 15259 0b64 60004080 		.word	-2143289248
 15260 0b68 0620702E 		.word	779100166
 15261 0b6c 0C000000 		.word	12
 15262 0b70 00000080 		.word	-2147483648
 15263 0b74 0C93731E 		.word	510890764
 15264 0b78 04000024 		.word	603979780
 15265 0b7c 90004080 		.word	-2143289200
 15266 0b80 0D20702E 		.word	779100173
 15267 0b84 0C000000 		.word	12
 15268 0b88 00000080 		.word	-2147483648
 15269 0b8c 0780724E 		.word	1316126727
 15270 0b90 0A000000 		.word	10
 15271 0b94 00000080 		.word	-2147483648
 15272 0b98 08000000 		.word	8
 15273 0b9c 00000000 		.word	0
 15274 0ba0 00010080 		.word	-2147483392
 15275 0ba4 0920702E 		.word	779100169
 15276 0ba8 0C010000 		.word	268
 15277 0bac 00000080 		.word	-2147483648
 15278 0bb0 0A01701E 		.word	510656778
 15279 0bb4 0E000100 		.word	65550
 15280 0bb8 00000080 		.word	-2147483648
 15281 0bbc 00000000 		.word	0
 15282 0bc0 00000000 		.word	0
 15283 0bc4 00000000 		.word	0
 15284 0bc8 00000000 		.word	0
 15285 0bcc 00000000 		.word	0
 15286 0bd0 00000000 		.word	0
 15287 0bd4 0394731E 		.word	510891011
 15288 0bd8 04000020 		.word	536870916
 15289 0bdc 60004080 		.word	-2143289248
 15290 0be0 08000000 		.word	8
 15291 0be4 00000000 		.word	0
 15292 0be8 00010080 		.word	-2147483392
 15293 0bec 0B000000 		.word	11
 15294 0bf0 00000000 		.word	0
 15295 0bf4 00010080 		.word	-2147483392
 15296 0bf8 0C93731E 		.word	510890764
 15297 0bfc 04000024 		.word	603979780
 15298 0c00 90004080 		.word	-2143289200
 15299 0c04 0D20702E 		.word	779100173
 15300 0c08 0C000000 		.word	12
 15301 0c0c 00000080 		.word	-2147483648
 15302 0c10 0D20702E 		.word	779100173
 15303 0c14 0C000000 		.word	12
 15304 0c18 00000080 		.word	-2147483648
 15305 0c1c 0E60724E 		.word	1316118542
 15306 0c20 0A000000 		.word	10
 15307 0c24 00000080 		.word	-2147483648
 15308 0c28 0F000000 		.word	15
 15309 0c2c 00000000 		.word	0
 15310 0c30 00010080 		.word	-2147483392
 15311 0c34 1020702E 		.word	779100176
 15312 0c38 0C010000 		.word	268
 15313 0c3c 00000080 		.word	-2147483648
 15314 0c40 1101701E 		.word	510656785
 15315 0c44 0E000100 		.word	65550
 15316 0c48 00000080 		.word	-2147483648
 15317 0c4c 0C93731E 		.word	510890764
 15318 0c50 04000024 		.word	603979780
 15319 0c54 90004080 		.word	-2143289200
 15320 0c58 0F000000 		.word	15
 15321 0c5c 00000000 		.word	0
 15322 0c60 00010080 		.word	-2147483392
 15323 0c64 12000000 		.word	18
 15324 0c68 00000000 		.word	0
 15325 0c6c 00010080 		.word	-2147483392
 15326 0c70 0394731E 		.word	510891011
 15327 0c74 04000020 		.word	536870916
 15328 0c78 60004080 		.word	-2143289248
 15329 0c7c 0480732E 		.word	779321348
 15330 0c80 02010000 		.word	258
 15331 0c84 0000C0C0 		.word	-1061158912
 15332 0c88 0580732E 		.word	779321349
 15333 0c8c 02010000 		.word	258
 15334 0c90 0000C0C0 		.word	-1061158912
 15335 0c94 0580732E 		.word	779321349
 15336 0c98 02010000 		.word	258
 15337 0c9c 0000C0C0 		.word	-1061158912
 15338 0ca0 0480732E 		.word	779321348
 15339 0ca4 02010000 		.word	258
 15340 0ca8 0000C0C0 		.word	-1061158912
 15343              	CyFxGpifTransition_usb2:
 15344 0cac 0000     		.short	0
 15345 0cae 5555     		.short	21845
 15346 0cb0 AAAA     		.short	-21846
 15347 0cb2 8888     		.short	-30584
 15348 0cb4 1111     		.short	4369
 15349 0cb6 4444     		.short	17476
 15350 0cb8 3333     		.short	13107
 15351 0cba CCCC     		.short	-13108
 15354              	CyFxGpifRegValue:
 15355 0cbc 08830080 		.word	-2147450104
 15356 0cc0 67000000 		.word	103
 15357 0cc4 00000000 		.word	0
 15358 0cc8 46000000 		.word	70
 15359 0ccc 00000000 		.word	0
 15360 0cd0 00000000 		.word	0
 15361 0cd4 02000000 		.word	2
 15362 0cd8 82000000 		.word	130
 15363 0cdc 82070000 		.word	1922
 15364 0ce0 40040000 		.word	1088
 15365 0ce4 FCFF0000 		.word	65532
 15366 0ce8 28000000 		.word	40
 15367 0cec 00000000 		.word	0
 15368 0cf0 00000000 		.word	0
 15369 0cf4 00000000 		.word	0
 15370 0cf8 00000000 		.word	0
 15371 0cfc 01000000 		.word	1
 15372 0d00 00000000 		.word	0
 15373 0d04 00000000 		.word	0
 15374 0d08 00000000 		.word	0
 15375 0d0c 00000000 		.word	0
 15376 0d10 00000000 		.word	0
 15377 0d14 00000000 		.word	0
 15378 0d18 00000000 		.word	0
 15379 0d1c 00000000 		.word	0
 15380 0d20 00000000 		.word	0
 15381 0d24 00000000 		.word	0
 15382 0d28 00000000 		.word	0
 15383 0d2c 00000000 		.word	0
 15384 0d30 06000000 		.word	6
 15385 0d34 00000000 		.word	0
 15386 0d38 FFFF0000 		.word	65535
 15387 0d3c 09010000 		.word	265
 15388 0d40 00000000 		.word	0
 15389 0d44 F71F0000 		.word	8183
 15390 0d48 00000000 		.word	0
 15391 0d4c FFFF0000 		.word	65535
 15392 0d50 09010000 		.word	265
 15393 0d54 00000000 		.word	0
 15394 0d58 F71F0000 		.word	8183
 15395 0d5c 00000000 		.word	0
 15396 0d60 00000000 		.word	0
 15397 0d64 00000000 		.word	0
 15398 0d68 00000000 		.word	0
 15399 0d6c 00000000 		.word	0
 15400 0d70 00000000 		.word	0
 15401 0d74 00000000 		.word	0
 15402 0d78 00000000 		.word	0
 15403 0d7c 00000000 		.word	0
 15404 0d80 00000000 		.word	0
 15405 0d84 00000000 		.word	0
 15406 0d88 00000000 		.word	0
 15407 0d8c 00000000 		.word	0
 15408 0d90 00000000 		.word	0
 15409 0d94 00000000 		.word	0
 15410 0d98 00000000 		.word	0
 15411 0d9c 00000000 		.word	0
 15412 0da0 00000000 		.word	0
 15413 0da4 00000000 		.word	0
 15414 0da8 00000000 		.word	0
 15415 0dac 00000000 		.word	0
 15416 0db0 00000000 		.word	0
 15417 0db4 00000000 		.word	0
 15418 0db8 00040180 		.word	-2147417088
 15419 0dbc 01040180 		.word	-2147417087
 15420 0dc0 02040180 		.word	-2147417086
 15421 0dc4 03040180 		.word	-2147417085
 15422 0dc8 00000000 		.word	0
 15423 0dcc 00000000 		.word	0
 15424 0dd0 00000000 		.word	0
 15425 0dd4 00000000 		.word	0
 15426 0dd8 00000000 		.word	0
 15427 0ddc 00000000 		.word	0
 15428 0de0 00000000 		.word	0
 15429 0de4 00000000 		.word	0
 15430 0de8 C1FFFFFF 		.word	-63
 15433              	CyFxGpifWavedataPosition:
 15434 0dec 00       		.byte	0
 15435 0ded 01       		.byte	1
 15436 0dee 02       		.byte	2
 15437 0def 03       		.byte	3
 15438 0df0 04       		.byte	4
 15439 0df1 05       		.byte	5
 15440 0df2 06       		.byte	6
 15441 0df3 07       		.byte	7
 15442 0df4 08       		.byte	8
 15443 0df5 09       		.byte	9
 15444 0df6 0A       		.byte	10
 15445 0df7 0B       		.byte	11
 15446 0df8 0B       		.byte	11
 15447 0df9 0B       		.byte	11
 15448 0dfa 0B       		.byte	11
 15449 0dfb 00       		.space	1
 15452              	CyFxGpifWavedata:
 15453 0dfc 0181731E 		.word	510886145
 15454 0e00 00000000 		.word	0
 15455 0e04 00000080 		.word	-2147483648
 15456 0e08 00000000 		.word	0
 15457 0e0c 00000000 		.word	0
 15458 0e10 00000000 		.word	0
 15459 0e14 0201702E 		.word	779092226
 15460 0e18 00010000 		.word	256
 15461 0e1c A0000080 		.word	-2147483488
 15462 0e20 00000000 		.word	0
 15463 0e24 00000000 		.word	0
 15464 0e28 00000000 		.word	0
 15465 0e2c 0380722E 		.word	779255811
 15466 0e30 02010020 		.word	536871170
 15467 0e34 60000080 		.word	-2147483552
 15468 0e38 00000000 		.word	0
 15469 0e3c 00000000 		.word	0
 15470 0e40 00000000 		.word	0
 15471 0e44 0460722E 		.word	779247620
 15472 0e48 02010024 		.word	603980034
 15473 0e4c 90000080 		.word	-2147483504
 15474 0e50 0594731E 		.word	510891013
 15475 0e54 06000000 		.word	6
 15476 0e58 00000080 		.word	-2147483648
 15477 0e5c 0380722E 		.word	779255811
 15478 0e60 02010020 		.word	536871170
 15479 0e64 60000080 		.word	-2147483552
 15480 0e68 0693731E 		.word	510890758
 15481 0e6c 06000000 		.word	6
 15482 0e70 00000080 		.word	-2147483648
 15483 0e74 0720703E 		.word	1047535623
 15484 0e78 08010000 		.word	264
 15485 0e7c 00000080 		.word	-2147483648
 15486 0e80 0820703E 		.word	1047535624
 15487 0e84 08010000 		.word	264
 15488 0e88 00000080 		.word	-2147483648
 15489 0e8c 0920703E 		.word	1047535625
 15490 0e90 08010000 		.word	264
 15491 0e94 00000080 		.word	-2147483648
 15492 0e98 0A20703E 		.word	1047535626
 15493 0e9c 08010000 		.word	264
 15494 0ea0 00000080 		.word	-2147483648
 15495 0ea4 0380722E 		.word	779255811
 15496 0ea8 02010020 		.word	536871170
 15497 0eac 60000080 		.word	-2147483552
 15498 0eb0 0B000000 		.word	11
 15499 0eb4 00000000 		.word	0
 15500 0eb8 00010080 		.word	-2147483392
 15501 0ebc 0460722E 		.word	779247620
 15502 0ec0 02010024 		.word	603980034
 15503 0ec4 90000080 		.word	-2147483504
 15504 0ec8 0D000000 		.word	13
 15505 0ecc 00000000 		.word	0
 15506 0ed0 00010080 		.word	-2147483392
 15507 0ed4 0460722E 		.word	779247620
 15508 0ed8 02010024 		.word	603980034
 15509 0edc 90000080 		.word	-2147483504
 15510 0ee0 0C000000 		.word	12
 15511 0ee4 00000000 		.word	0
 15512 0ee8 00010080 		.word	-2147483392
 15513 0eec 0380722E 		.word	779255811
 15514 0ef0 02010020 		.word	536871170
 15515 0ef4 60000080 		.word	-2147483552
 15516 0ef8 0E000000 		.word	14
 15517 0efc 00000000 		.word	0
 15518 0f00 00010080 		.word	-2147483392
 15519 0f04 00000000 		.word	0
 15520 0f08 00000000 		.word	0
 15521 0f0c 00000000 		.word	0
 15522 0f10 00000000 		.word	0
 15523 0f14 00000000 		.word	0
 15524 0f18 00000000 		.word	0
 15527              	CyFxGpifTransition:
 15528 0f1c 0000     		.short	0
 15529 0f1e 5555     		.short	21845
 15530 0f20 8888     		.short	-30584
 15531 0f22 AAAA     		.short	-21846
 15532 0f24 3333     		.short	13107
 15533 0f26 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15534              		.align	2
 15535              	.LC0:
 15536 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15536      706F732D 
 15536      74696D65 
 15536      72202564 
 15536      2025640D 
 15537 0016 0000     		.space	2
 15538              	.LC1:
 15539 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15539      6F207374 
 15539      7265616D 
 15539      20474554 
 15539      20726571 
 15540 003d 000000   		.space	3
 15541              	.LC2:
 15542 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15542      74686520 
 15542      76696465 
 15542      6F206D6F 
 15542      64652066 
 15543 0061 000000   		.space	3
 15544              	.LC3:
 15545 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15545      74686520 
 15545      76696465 
 15545      6F206D6F 
 15545      64652066 
 15546 0089 000000   		.space	3
 15547              	.LC4:
 15548 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15548      43595F46 
 15548      585F5556 
 15548      435F5354 
 15548      5245414D 
 15549 00b2 0000     		.space	2
 15550              	.LC5:
 15551 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15551      55564320 
 15551      7374696C 
 15551      6C205072 
 15551      6F622873 
 15552 00df 00       		.space	1
 15553              	.LC6:
 15554 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15554      74686520 
 15554      7374696C 
 15554      6C206D6F 
 15554      64652066 
 15555 0101 000000   		.space	3
 15556              	.LC7:
 15557 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15557      7374696C 
 15557      6C20636F 
 15557      6D6D6974 
 15557      20636F6E 
 15558              	.LC8:
 15559 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15559      43595F46 
 15559      585F5556 
 15559      435F5354 
 15559      494C5F45 
 15560              	.LC9:
 15561 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15561      55564320 
 15561      7374696C 
 15561      6C207472 
 15561      69676765 
 15562 0179 000000   		.space	3
 15563              	.LC10:
 15564 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15564      7374696C 
 15564      6C207472 
 15564      69676765 
 15564      7220636F 
 15565 01a3 00       		.space	1
 15566              	.LC11:
 15567 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15567      7065722D 
 15567      74696D65 
 15567      72202564 
 15567      0D0A00
 15568 01b7 00       		.space	1
 15569              	.LC12:
 15570 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15570      636F6D6D 
 15570      616E6420 
 15570      71756575 
 15570      65206973 
 15571 01db 00       		.space	1
 15572              	.LC13:
 15573 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15573      7220696E 
 15573      206D756C 
 15573      74696368 
 15573      616E6E65 
 15574 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15574      2025782C 
 15574      20646D61 
 15574      446F6E65 
 15574      20256420 
 15575              	.LC14:
 15576 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15576      5420656E 
 15576      636F756E 
 15576      74657265 
 15576      642E2E2E 
 15577              	.LC15:
 15578 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15578      454E4420 
 15578      656E636F 
 15578      756E7465 
 15578      7265642E 
 15579 026a 0000     		.space	2
 15580              	.LC16:
 15581 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15581      64697363 
 15581      6F6E6E65 
 15581      63746564 
 15581      2E2E2E30 
 15582 028b 00       		.space	1
 15583              	.LC17:
 15584 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15584      43595F46 
 15584      585F5556 
 15584      435F5649 
 15584      44454F5F 
 15585 02bf 0A00     		.ascii	"\012\000"
 15586 02c1 000000   		.space	3
 15587              	.LC18:
 15588 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15588      43595F46 
 15588      585F5556 
 15588      435F5649 
 15588      44454F5F 
 15589 02f7 00       		.ascii	"\000"
 15590              	.LC19:
 15591 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15591      726E6174 
 15591      65207365 
 15591      7474696E 
 15591      6720302E 
 15592              	.LC20:
 15593 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15593      72206665 
 15593      61747572 
 15593      65207265 
 15593      71756573 
 15594 0333 00       		.space	1
 15595              	.LC21:
 15596 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15596      49324320 
 15596      636F6D6D 
 15596      616E6420 
 15596      69732030 
 15597 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15597      78257820 
 15597      30782578 
 15597      20307825 
 15597      78203078 
 15598              	.LC22:
 15599 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15599      49324320 
 15599      636F6D6D 
 15599      616E6420 
 15599      73657474 
 15600 03a6 0000     		.space	2
 15601              	.LC23:
 15602 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15602      73687574 
 15602      74657220 
 15602      73657420 
 15602      76616C75 
 15603 03d2 0000     		.space	2
 15604              	.LC24:
 15605 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15605      26414743 
 15605      2073656E 
 15605      7420746F 
 15605      20686F73 
 15606 03fa 0000     		.space	2
 15607              	.LC25:
 15608 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15608      49324320 
 15608      63757272 
 15608      656E7420 
 15608      64617461 
 15609 042f 64202564 		.ascii	"d %d\015\012\000"
 15609      0D0A00
 15610 0436 0000     		.space	2
 15611              	.LC26:
 15612 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 15612      63757272 
 15612      656E7420 
 15612      76616C75 
 15612      65203078 
 15613 0465 000000   		.space	3
 15614              	.LC27:
 15615 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 15615      73657420 
 15615      636F6E74 
 15615      726F6C20 
 15615      6374726C 
 15616 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x\015\012\000"
 15616      443A2030 
 15616      78257820 
 15616      4C656E3A 
 15616      20307825 
 15617 04b3 00       		.space	1
 15618              	.LC28:
 15619 04b4 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15619      26414743 
 15619      20676F74 
 15619      74656E20 
 15619      66726F6D 
 15620 04e5 0A00     		.ascii	"\012\000"
 15621 04e7 00       		.space	1
 15622              	.LC29:
 15623 04e8 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15623      73687574 
 15623      74657226 
 15623      6578706F 
 15623      73757265 
 15624 0513 00       		.space	1
 15625              	.LC30:
 15626 0514 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 15626      64617461 
 15626      20676574 
 15626      73206672 
 15626      6F6D2068 
 15627 0547 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 15627      78206375 
 15627      7248693A 
 15627      20307825 
 15627      78204C65 
 15628 0565 000000   		.space	3
 15629              	.LC31:
 15630 0568 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15630      75656E63 
 15630      79207365 
 15630      7474696E 
 15630      67206973 
 15631 0586 0000     		.space	2
 15632              	.LC32:
 15633 0588 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15633      20746865 
 15633      20766964 
 15633      656F206D 
 15633      6F646520 
 15634 05aa 0000     		.space	2
 15635              	.LC33:
 15636 05ac 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15636      67657420 
 15636      64617461 
 15636      2066726F 
 15636      6D20686F 
 15637 05d9 000000   		.space	3
 15638              	.LC34:
 15639 05dc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15639      52657175 
 15639      65737420 
 15639      30782578 
 15639      20706172 
 15640 060f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15640      6E642074 
 15640      6F20686F 
 15640      73742030 
 15640      78257820 
 15641 062a 0000     		.space	2
 15642              	.LC35:
 15643 062c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15643      204F7020 
 15643      72656365 
 15643      69766573 
 15643      20284354 
 15644 0653 00       		.space	1
 15645              	.LC36:
 15646 0654 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15646      756C7420 
 15646      73656C65 
 15646      63746F72 
 15646      20284354 
 15647 0676 0000     		.space	2
 15648              	.LC37:
 15649 0678 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15649      756C7420 
 15649      72657175 
 15649      65737420 
 15649      28435429 
 15650 0699 000000   		.space	3
 15651              	.LC38:
 15652 069c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15652      52657175 
 15652      65737420 
 15652      30782578 
 15652      20706172 
 15653 06cf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15653      20307825 
 15653      78202F20 
 15653      73656E64 
 15653      20746F20 
 15654 06fc 00       		.ascii	"\000"
 15655 06fd 000000   		.space	3
 15656              	.LC39:
 15657 0700 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15657      73657420 
 15657      64656620 
 15657      64617461 
 15657      20307825 
 15658 071f 00       		.space	1
 15659              	.LC40:
 15660 0720 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15660      73657420 
 15660      64656620 
 15660      64617461 
 15660      20307825 
 15661 0753 2E0D0A00 		.ascii	".\015\012\000"
 15662 0757 00       		.space	1
 15663              	.LC41:
 15664 0758 4572726F 		.ascii	"Error handler...\015\012\000"
 15664      72206861 
 15664      6E646C65 
 15664      722E2E2E 
 15664      0D0A00
 15665 076b 00       		.space	1
 15666              	.LC42:
 15667 076c 55415254 		.ascii	"UART initialization failed!\012\000"
 15667      20696E69 
 15667      7469616C 
 15667      697A6174 
 15667      696F6E20 
 15668 0789 000000   		.space	3
 15669              	.LC43:
 15670 078c 49324320 		.ascii	"I2C initialization failed!\012\000"
 15670      696E6974 
 15670      69616C69 
 15670      7A617469 
 15670      6F6E2066 
 15671              	.LC44:
 15672 07a8 49324320 		.ascii	"I2C configuration failed!\012\000"
 15672      636F6E66 
 15672      69677572 
 15672      6174696F 
 15672      6E206661 
 15673 07c3 00       		.space	1
 15674              	.LC45:
 15675 07c4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15675      43726561 
 15675      74652045 
 15675      76656E74 
 15675      20666169 
 15676 07ee 0000     		.space	2
 15677              	.LC46:
 15678 07f0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15678      20496E69 
 15678      74206661 
 15678      696C6564 
 15678      2C204572 
 15679 0813 00       		.space	1
 15680              	.LC47:
 15681 0814 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15681      204F7665 
 15681      72726964 
 15681      65206661 
 15681      696C6564 
 15682 083b 00       		.space	1
 15683              	.LC48:
 15684 083c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15684      28323029 
 15684      204F7665 
 15684      72726964 
 15684      65206661 
 15685 0867 00       		.space	1
 15686              	.LC49:
 15687 0868 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15687      28323429 
 15687      204F7665 
 15687      72726964 
 15687      65206661 
 15688 0893 00       		.space	1
 15689              	.LC50:
 15690 0894 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15690      20536574 
 15690      20287265 
 15690      73657420 
 15690      32322920 
 15691 08c6 00       		.ascii	"\000"
 15692 08c7 00       		.space	1
 15693              	.LC51:
 15694 08c8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15694      20536574 
 15694      2028706F 
 15694      77657220 
 15694      32302920 
 15695 08fa 00       		.ascii	"\000"
 15696 08fb 00       		.space	1
 15697              	.LC52:
 15698 08fc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15698      20536574 
 15698      2028736E 
 15698      61702073 
 15698      686F7420 
 15699 092f 25640A00 		.ascii	"%d\012\000"
 15700 0933 00       		.space	1
 15701              	.LC53:
 15702 0934 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15702      46756E63 
 15702      74696F6E 
 15702      20466169 
 15702      6C656420 
 15703 0963 00       		.space	1
 15704              	.LC54:
 15705 0964 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15705      46756E63 
 15705      74696F6E 
 15705      20466169 
 15705      6C656420 
 15706 0993 00       		.space	1
 15707              	.LC55:
 15708 0994 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15708      53657420 
 15708      456E6470 
 15708      6F696E74 
 15708      20636F6E 
 15709 09c4 00       		.ascii	"\000"
 15710 09c5 000000   		.space	3
 15711              	.LC56:
 15712 09c8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15712      496E7465 
 15712      72727570 
 15712      74205374 
 15712      61747573 
 15713 09fb 20436F64 		.ascii	" Code = %d\012\000"
 15713      65203D20 
 15713      25640A00 
 15714 0a07 00       		.space	1
 15715              	.LC57:
 15716 0a08 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15716      65642074 
 15716      6F20616C 
 15716      6C6F6361 
 15716      7465206D 
 15717 0a3b 65720D0A 		.ascii	"er\015\012\000"
 15717      00
 15718              	.LC58:
 15719 0a40 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15719      4368616E 
 15719      6E656C20 
 15719      43726561 
 15719      74696F6E 
 15720 0a6e 0000     		.space	2
 15721              	.LC59:
 15722 0a70 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15722      436F6E6E 
 15722      65637420 
 15722      6661696C 
 15722      65642C20 
 15723 0a95 000000   		.space	3
 15724              	.LC60:
 15725 0a98 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15725      74686520 
 15725      76696465 
 15725      6F206D6F 
 15725      64652066 
 15726 0aba 0000     		.space	2
 15727              	.LC61:
 15728 0abc 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15728      4368616E 
 15728      6E656C20 
 15728      52657365 
 15728      74204661 
 15729 0ae7 00       		.space	1
 15730              	.LC62:
 15731 0ae8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15731      4368616E 
 15731      6E656C20 
 15731      53657420 
 15731      5472616E 
 15732 0b19 00       		.ascii	"\000"
 15733 0b1a 0000     		.space	2
 15734              	.LC63:
 15735 0b1c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15735      4368616E 
 15735      6E656C20 
 15735      53657420 
 15735      5472616E 
 15736 0b4d 0A00     		.ascii	"\012\000"
 15737 0b4f 00       		.space	1
 15738              	.LC64:
 15739 0b50 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15739      75706572 
 15739      20677069 
 15739      6600
 15740 0b5e 0000     		.space	2
 15741              	.LC65:
 15742 0b60 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15742      69676820 
 15742      67706966 
 15742      00
 15743 0b6d 000000   		.space	3
 15744              	.LC66:
 15745 0b70 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15745      696E6720 
 15745      47504946 
 15745      20436F6E 
 15745      66696775 
 15746 0ba3 0A00     		.ascii	"\012\000"
 15747 0ba5 000000   		.space	3
 15748              	.LC67:
 15749 0ba8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15749      74696E67 
 15749      20475049 
 15749      46207374 
 15749      61746520 
 15750 0bdb 0D0A00   		.ascii	"\015\012\000"
 15751 0bde 0000     		.space	2
 15752              	.LC68:
 15753 0be0 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15753      73706565 
 15753      64203D20 
 15753      25642065 
 15753      76656E66 
 15754 0c10 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15754      71756573 
 15754      74203D20 
 15754      30782578 
 15754      20775661 
 15755 0c40 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15755      203D2030 
 15755      78257820 
 15755      6973666C 
 15755      61672030 
 15756 0c5a 0000     		.space	2
 15757              	.LC69:
 15758 0c5c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15758      64656661 
 15758      756C7420 
 15758      73657475 
 15758      70207265 
 15759              	.LC70:
 15760 0c88 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 15760      68797374 
 15760      65722063 
 15760      6F6D6D61 
 15760      6E642030 
 15761 0ca7 00       		.space	1
 15762              	.LC71:
 15763 0ca8 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 15763      6374726C 
 15763      73706420 
 15763      636F6D6D 
 15763      616E6420 
 15764              	.LC72:
 15765 0cc8 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 15765      65646765 
 15765      4D6F6465 
 15765      20636F6D 
 15765      6D616E64 
 15766 0ce9 000000   		.space	3
 15767              	.LC73:
 15768 0cec 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 15768      65646765 
 15768      6761696E 
 15768      20636F6D 
 15768      6D616E64 
 15769 0d0d 000000   		.space	3
 15770              	.LC74:
 15771 0d10 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 15771      65646765 
 15771      20737461 
 15771      72742F65 
 15771      6E642063 
 15772 0d37 00       		.space	1
 15773              	.LC75:
 15774 0d38 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 15774      32444E52 
 15774      20737461 
 15774      72742F65 
 15774      6E642063 
 15775 0d5f 00       		.space	1
 15776              	.LC76:
 15777 0d60 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 15777      67616D6D 
 15777      6120636F 
 15777      6D6D616E 
 15777      64203078 
 15778 0d7e 0000     		.space	2
 15779              	.LC77:
 15780 0d80 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15780      65642074 
 15780      6F207365 
 15780      6E642069 
 15780      6E746572 
 15781 0db1 0A00     		.ascii	"\012\000"
 15782 0db3 00       		.space	1
 15783              	.LC78:
 15784 0db4 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15784      6F6D6D69 
 15784      74656F66 
 15784      20737461 
 15784      7465203D 
 15785              	.LC79:
 15786 0dcc 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15786      6E656C20 
 15786      53657420 
 15786      57726170 
 15786      55702066 
 15787 0df9 000000   		.space	3
 15788              	.LC80:
 15789 0dfc 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15789      69742045 
 15789      4F462066 
 15789      61696C65 
 15789      64210D0A 
 15790 0e11 000000   		.space	3
 15791              	.LC81:
 15792 0e14 49324363 		.ascii	"I2CcmdQue\000"
 15792      6D645175 
 15792      6500
 15793 0e1e 0000     		.space	2
 15794              	.LC82:
 15795 0e20 33303A55 		.ascii	"30:UVC App Thread\000"
 15795      56432041 
 15795      70702054 
 15795      68726561 
 15795      6400
 15796 0e32 0000     		.space	2
 15797              	.LC83:
 15798 0e34 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15798      56432041 
 15798      70702045 
 15798      50302054 
 15798      68726561 
 15799 0e4a 0000     		.space	2
 15800              	.LC84:
 15801 0e4c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15801      32432041 
 15801      70702043 
 15801      54524C20 
 15801      54687265 
 15802 0e63 00       		.bss
 15803              		.align	2
 15804              		.set	.LANCHOR0,. + 0
 15807              	glFxUVCEvent:
 15808 0000 00000000 		.space	40
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15811              	glEp0Buffer:
 15812 0028 00000000 		.space	32
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15815              	usbSpeed:
 15816 0048 00       		.space	1
 15817 0049 000000   		.space	3
 15820              	glCommitCtrl:
 15821 004c 00000000 		.space	32
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15824              	is60Hz:
 15825 006c 00000000 		.space	4
 15828              	setRes:
 15829 0070 00       		.space	1
 15832              	setstilRes:
 15833 0071 00       		.space	1
 15836              	stiflag:
 15837 0072 00       		.space	1
 15838 0073 00       		.space	1
 15841              	fb:
 15842 0074 0000     		.space	2
 15845              	pb:
 15846 0076 0000     		.space	2
 15849              	pbc:
 15850 0078 0000     		.space	2
 15851 007a 0000     		.space	2
 15854              	hitFV:
 15855 007c 00000000 		.space	4
 15858              	prodCount:
 15859 0080 0000     		.space	2
 15862              	consCount:
 15863 0082 0000     		.space	2
 15866              	streamingStarted:
 15867 0084 00000000 		.space	4
 15870              	gpif_initialized:
 15871 0088 00000000 		.space	4
 15874              	isUsbConnected:
 15875 008c 00000000 		.space	4
 15878              	clearFeatureRqtReceived:
 15879 0090 00000000 		.space	4
 15882              	I2CCMDArry:
 15883 0094 00000000 		.space	12
 15883      00000000 
 15883      00000000 
 15886              	curFlag:
 15887 00a0 00000000 		.space	64
 15887      00000000 
 15887      00000000 
 15887      00000000 
 15887      00000000 
 15890              	IMcount.8238:
 15891 00e0 00       		.space	1
 15892 00e1 000000   		.space	3
 15895              	uvcAppThread:
 15896 00e4 00000000 		.space	168
 15896      00000000 
 15896      00000000 
 15896      00000000 
 15896      00000000 
 15899              	uvcAppEP0Thread:
 15900 018c 00000000 		.space	168
 15900      00000000 
 15900      00000000 
 15900      00000000 
 15900      00000000 
 15903              	i2cAppThread:
 15904 0234 00000000 		.space	168
 15904      00000000 
 15904      00000000 
 15904      00000000 
 15904      00000000 
 15907              	pbcpbak:
 15908 02dc 0000     		.space	2
 15911              	pbcbak:
 15912 02de 0000     		.space	2
 15915              	pbbak:
 15916 02e0 0000     		.space	2
 15919              	fbbak:
 15920 02e2 0000     		.space	2
 15923              	testSnap:
 15924 02e4 00       		.space	1
 15925 02e5 000000   		.text
 15926              	.Letext0:
 15927              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15928              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15929              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15930              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15931              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15932              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15933              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15934              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15935              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15936              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15937              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15938              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15939              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15940              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15941              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15942              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15943              		.file 18 "../sensor.h"
 15944              		.file 19 "../cmdqu.h"
 15945              		.file 20 "../uvc.h"
 15946              		.file 21 "../cyfxgpif2config.h"
 15947              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15948              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2536   .text:000014b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2562   .text:0000150c $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2649   .text:000015cc $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2665   .text:00001604 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2792   .text:0000170c $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2805   .text:00001738 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2865   .text:000017b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:2880   .text:000017e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4160   .text:00002368 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4180   .text:000023ac $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4268   .text:00002464 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4274   .text:00002474 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4715   .text:000028c4 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4862   .text:000029ec $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:4875   .text:00002a14 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5291   .text:00002e44 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5302   .text:00002e64 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5572   .text:000030f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5584   .text:0000311c $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5587   .text:0000311c CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5888   .text:000033d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5895   .text:000033e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5898   .text:000033e8 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5942   .text:0000342c $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5947   .text:00003434 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5950   .text:00003434 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5978   .text:00003450 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5982   .text:00003454 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:5985   .text:00003454 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:6770   .text:00003ad0 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:6776   .text:00003ae0 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:7251   .text:00003ec8 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12249  .text:0000657c CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:7310   .text:00003fa0 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:7313   .text:00003fa0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:7376   .text:00004014 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:7384   .text:00004024 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:9144   .text:00004f50 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:9184   .text:00004fd4 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12234  .text:00006568 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12246  .text:0000657c $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12281  .text:000065b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12294  .text:000065dc $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12299  .text:000065ec $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12304  .text:000065fc $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12352  .text:00006654 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12362  .text:00006668 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12365  .text:00006668 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12518  .text:000067b0 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12535  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12538  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13883  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12902  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12823  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12887  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12793  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12853  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15866  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15878  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15815  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15874  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15907  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15911  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15915  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15919  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15849  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15845  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15841  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15923  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14469  .data:00000756 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12766  .rodata:0000017c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15002  .data:00000938 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15081  .data:00000a68 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15232  .data:00000afc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15343  .data:00000cac CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12753  .rodata:00000160 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15354  .data:00000cbc CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15433  .data:00000dec CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15452  .data:00000dfc CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15527  .data:00000f1c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12678  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12682  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12697  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14037  .data:00000574 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14870  .data:000008c0 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14848  .data:000008ac EXTMirror
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14826  .data:00000898 EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14804  .data:00000884 EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14782  .data:00000870 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14760  .data:0000085c EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14738  .data:00000848 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14716  .data:00000834 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13920  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14694  .data:00000820 EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14606  .data:000007d0 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14672  .data:0000080c EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14650  .data:000007f8 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14059  .data:00000588 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14628  .data:000007e4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13898  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14584  .data:000007bc EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14562  .data:000007a8 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14426  .data:00000730 EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14448  .data:00000744 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14540  .data:00000794 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14518  .data:00000780 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14496  .data:0000076c EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14474  .data:00000758 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12734  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14015  .data:00000560 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13942  .data:00000520 PUCBright
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14980  .data:00000924 PUCContrast
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13986  .data:00000548 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13964  .data:00000534 PUCHueC
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14958  .data:00000910 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14936  .data:000008fc PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14914  .data:000008e8 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14892  .data:000008d4 PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14404  .data:0000071c PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12779  .rodata:00000198 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12789  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12882  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:12917  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:13240  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14008  .data:0000055c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:14081  .data:0000059c CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15534  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15803  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15807  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15811  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15820  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15824  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15828  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15832  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15836  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15854  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15858  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15862  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15870  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15882  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15886  .bss:000000a0 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15890  .bss:000000e0 IMcount.8238
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15895  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15899  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccfpB05R.s:15903  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
