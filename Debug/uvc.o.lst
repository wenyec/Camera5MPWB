   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 233:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 234:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 237:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 238:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 239:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 250:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 251:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 253:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 254:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 255:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 256:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 257:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 258:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 259:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 261:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 273:../uvc.c      **** };
 274:../uvc.c      **** 
 275:../uvc.c      **** #ifndef CAM720
 276:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 277:../uvc.c      **** #else
 278:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 279:../uvc.c      **** #endif
 280:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 281:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 282:../uvc.c      **** 
 283:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 284:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 285:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 286:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 287:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 288:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 289:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 290:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 291:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 292:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 295:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 296:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 297:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 298:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 299:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 300:../uvc.c      **** };
 301:../uvc.c      **** 
 302:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 303:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 304:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 305:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 306:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 307:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 308:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 309:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 310:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 311:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 312:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 313:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 314:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 315:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 316:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 317:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 318:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 319:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 320:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 321:../uvc.c      **** };
 322:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 323:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 324:../uvc.c      **** /*
 325:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 326:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 327:../uvc.c      ****  */
 328:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 329:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 330:../uvc.c      **** };
 331:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 332:../uvc.c      **** 		0
 333:../uvc.c      **** };
 334:../uvc.c      **** 
 335:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 336:../uvc.c      **** 
 337:../uvc.c      **** void I2CCmdHandler(){
 338:../uvc.c      **** 	uint8_t buf[2];
 339:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 340:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 341:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 342:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 343:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 344:../uvc.c      **** 	uint8_t i;
 345:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 346:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 347:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 348:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 349:../uvc.c      **** 	{
 350:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 351:../uvc.c      **** 		if(is60Hz==CyFalse)
 352:../uvc.c      **** 			{
 353:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 354:../uvc.c      **** 			}
 355:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 356:../uvc.c      **** 
 357:../uvc.c      **** 	}
 358:../uvc.c      **** 	if(CmdType == 0)//I2C read
 359:../uvc.c      **** 	{
 360:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 361:../uvc.c      **** #if 0 //for debugging
 362:../uvc.c      **** 		/* test still image operation */
 363:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 364:../uvc.c      **** 			snapButFlag = 0; //press
 365:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 366:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 367:../uvc.c      **** 			snapButFlag = 0xf; //release
 368:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 369:../uvc.c      **** 		}
 370:../uvc.c      **** 
 371:../uvc.c      **** 		/* end of the test */
 372:../uvc.c      **** #endif
 373:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 374:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 375:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 376:../uvc.c      **** 				if(CmdDataLen == 2){
 377:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 378:../uvc.c      **** 				}
 379:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 380:../uvc.c      **** 		}else{//not support currently
 381:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 382:../uvc.c      **** 		}
 383:../uvc.c      **** 	}else if(CmdType == 1){
 384:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 385:../uvc.c      **** 			if(CmdRegLen == 2){
 386:../uvc.c      **** 				for(i = 0; i<4; i++)
 387:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 388:../uvc.c      **** 			}
 389:../uvc.c      **** 			else{
 390:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 391:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 392:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 393:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 394:../uvc.c      **** 				}
 395:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 396:../uvc.c      **** 			}
 397:../uvc.c      **** 		}else{//not support currently
 398:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 399:../uvc.c      **** 		}
 400:../uvc.c      **** 
 401:../uvc.c      **** 	}
 402:../uvc.c      **** }
 403:../uvc.c      **** 
 404:../uvc.c      **** /************************************
 405:../uvc.c      ****  * set Iris mode
 406:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 407:../uvc.c      ****  */
 408:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 409:../uvc.c      **** 	uint8_t dataIdx;
 410:../uvc.c      **** 	  dataIdx = 0;
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 415:../uvc.c      **** }
 416:../uvc.c      **** 
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 418:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 419:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 420:../uvc.c      ****     uint16_t readCount;
 421:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 422:../uvc.c      ****     uint8_t devAdd;
 423:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 424:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 425:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 426:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 427:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 428:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 429:../uvc.c      ****     }else{
 430:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 431:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 432:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 433:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 434:../uvc.c      ****     }
 435:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 436:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 437:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 438:../uvc.c      **** #endif
 439:../uvc.c      ****     reqData = bRequest;
 440:../uvc.c      ****     /*
 441:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 442:../uvc.c      ****      */
 443:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 444:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 445:../uvc.c      ****     	goto EndofSet;
 446:../uvc.c      ****     }
 447:../uvc.c      ****     switch (bRequest)
 448:../uvc.c      **** 		 {
 449:../uvc.c      **** 
 450:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 451:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 452:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 453:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 454:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 455:../uvc.c      **** 			  break;
 456:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 457:../uvc.c      **** 
 458:../uvc.c      **** 			 switch(CtrlID)
 459:../uvc.c      **** 			 {
 460:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 461:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 462:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 463:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 464:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 465:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 466:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 467:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 468:../uvc.c      **** 			 	 		 break;
 469:../uvc.c      **** 			 	 }
 470:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 471:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 472:../uvc.c      **** 					 if(CamMode == 1){//720p
 473:../uvc.c      **** 						if(sendData >= 3){
 474:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 475:../uvc.c      **** 							sendData = 0; //set back to default
 476:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 477:../uvc.c      **** 						}
 478:../uvc.c      **** 						sendData += 4;
 479:../uvc.c      **** 					 }
 480:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 481:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 482:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 483:../uvc.c      **** 					 break;
 484:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 485:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 486:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 487:../uvc.c      **** 			 		 }
 488:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 489:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 490:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 491:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 492:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 493:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 494:../uvc.c      **** #endif
 495:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 496:../uvc.c      **** 			 		 {
 497:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 498:../uvc.c      **** 			 		 }
 499:../uvc.c      **** 			 		 break;
 500:../uvc.c      **** 				 case ExtAexModCtlID9:
 501:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 502:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 503:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 504:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 505:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 506:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 507:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 508:../uvc.c      **** 					 break;
 509:../uvc.c      **** 
 510:../uvc.c      **** 			 	 case BrgtCtlID1:
 511:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 512:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 513:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 514:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 515:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 516:../uvc.c      **** 					 }else{
 517:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 518:../uvc.c      **** 					 }
 519:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 520:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 521:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 522:../uvc.c      **** 					 */
 523:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 524:../uvc.c      **** 					  if(Data0&0x80){
 525:../uvc.c      **** 						  Data0 = ~Data0;
 526:../uvc.c      **** 					  }else{
 527:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 528:../uvc.c      **** 					  }
 529:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 531:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 532:../uvc.c      **** 			 		 break;
 533:../uvc.c      **** 				 case HueCtlID5:
 534:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 535:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 536:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 537:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 538:../uvc.c      **** 					 break;
 539:../uvc.c      **** 				 case WBTLevCtlID11:
 540:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 542:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 543:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 544:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 545:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 546:../uvc.c      **** 					 break;
 547:../uvc.c      **** 				 case SaturCtlID6:
 548:../uvc.c      **** 				 default:
 549:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 550:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 551:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 552:../uvc.c      **** 					 break;
 553:../uvc.c      **** 			 }
 554:../uvc.c      **** 
 555:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 556:../uvc.c      **** 
 557:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 558:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 559:../uvc.c      **** #endif
 560:../uvc.c      **** 			  break;
 561:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 562:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 564:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 565:../uvc.c      **** 		 	 }
 566:../uvc.c      **** 
 567:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 568:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 569:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 570:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 571:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 572:../uvc.c      **** 			 }else
 573:../uvc.c      **** 			 {
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 575:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 576:../uvc.c      **** 			 }
 577:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 578:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 579:../uvc.c      **** 			  break;
 580:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 581:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 584:../uvc.c      **** 		 	 }
 585:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 586:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 587:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 588:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 589:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 590:../uvc.c      **** 			 }else
 591:../uvc.c      **** 			 {
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 593:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 594:../uvc.c      **** 			 }
 595:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 596:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 597:../uvc.c      **** 			  break;
 598:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 599:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 601:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 602:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 603:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 604:../uvc.c      **** 		 	 }
 605:../uvc.c      **** 		 	 else{
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 607:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 608:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 609:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 610:../uvc.c      **** 		 	 }
 611:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 612:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 613:../uvc.c      **** 			  break;
 614:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 615:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 616:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 617:../uvc.c      **** 		 	 }
 618:../uvc.c      **** 		 	 else{
 619:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 620:../uvc.c      **** 		 	 }
 621:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 622:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 623:../uvc.c      **** 			  Len = 1;
 624:../uvc.c      **** 			  break;
 625:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 626:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 627:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 628:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 629:../uvc.c      **** 		 	 }
 630:../uvc.c      **** 
 631:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 632:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 633:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 634:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 635:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 636:../uvc.c      **** 			 }else{
 637:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 638:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 639:../uvc.c      **** 			 }
 640:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 641:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 642:../uvc.c      **** 			  break;
 643:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 644:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 645:../uvc.c      **** 				  glEp0Buffer, &readCount);
 646:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 647:../uvc.c      **** 			   {
 648:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 649:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 650:../uvc.c      **** 				  getData = glEp0Buffer[0];
 651:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 652:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 653:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 654:../uvc.c      **** #endif
 655:../uvc.c      **** 				  switch(CtrlID)
 656:../uvc.c      **** 					 {
 657:../uvc.c      **** 						 case ExtShutCtlID0:
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 659:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 661:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 662:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 663:../uvc.c      **** 									 }else{
 664:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 665:../uvc.c      **** 									 }
 666:../uvc.c      **** 								 }
 667:../uvc.c      **** 							 }else{
 668:../uvc.c      **** 								 Data1 = Data0 - 1;
 669:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 670:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 671:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 672:../uvc.c      **** 									 }else{
 673:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 674:../uvc.c      **** 									 }
 675:../uvc.c      **** 								 }
 676:../uvc.c      **** 								 if(Data1 < 8){
 677:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 678:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 679:../uvc.c      **** 								 }else{
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 682:../uvc.c      **** 								 }
 683:../uvc.c      **** 							 }
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 685:../uvc.c      **** 							 dataIdx = 0;
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 687:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 688:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 689:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 690:../uvc.c      **** 							 break;
 691:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 692:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 693:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 694:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 695:../uvc.c      **** 							 dataIdx = 0;
 696:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 697:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 698:../uvc.c      **** 							 if(getData != 0){
 699:../uvc.c      **** 								 dataIdx++;
 700:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 701:../uvc.c      **** 							 }
 702:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 703:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 704:../uvc.c      **** 							 break;
 705:../uvc.c      **** 						 case ExtCamMCtlID12:
 706:../uvc.c      **** 							 dataIdx = 0;
 707:../uvc.c      **** 							 if(Data0 <= 3){
 708:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 709:../uvc.c      **** 								 Data1 = Data0;
 710:../uvc.c      **** 							 }else{
 711:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 712:../uvc.c      **** 								 Data1 = Data0-4;
 713:../uvc.c      **** 							 }
 714:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 715:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 716:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 718:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 719:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 720:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 721:../uvc.c      **** 							 break;
 722:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 723:../uvc.c      **** 							 dataIdx = 0;
 724:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 725:../uvc.c      **** 								 Data0 = 1;
 726:../uvc.c      **** 							 }else{ //save current sensor parameters.
 727:../uvc.c      **** 								 Data0 = 0;
 728:../uvc.c      **** 							 }
 729:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 730:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 731:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 732:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 733:../uvc.c      **** 							 break;
 734:../uvc.c      **** 						 case ExtI2CCtlID15:
 735:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 736:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 737:../uvc.c      **** 					 		 }
 738:../uvc.c      **** 					 		I2CCmdHandler();
 739:../uvc.c      **** 							 break;
 740:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 741:../uvc.c      **** 							 dataIdx = 0;
 742:../uvc.c      **** #if 0 //seperate version
 743:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 744:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 745:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 746:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 747:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 748:../uvc.c      **** 							 }else{ //disable BLD window
 749:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 750:../uvc.c      **** 							 }
 751:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 752:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 753:../uvc.c      **** 							 dataIdx++;
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 755:../uvc.c      **** 							 dataIdx++;
 756:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 757:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 758:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 759:../uvc.c      **** 							 dataIdx++;
 760:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 761:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 762:../uvc.c      **** #else //combination version
 763:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 765:../uvc.c      **** 						     /* end test */
 766:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 767:../uvc.c      **** 							 dataIdx++;
 768:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 769:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 770:../uvc.c      **** 							 getData1 = Data1;
 771:../uvc.c      **** #endif
 772:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 773:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 774:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 775:../uvc.c      **** 							 break;
 776:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 777:../uvc.c      **** 							 dataIdx = 0;
 778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 779:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 780:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 781:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 782:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 783:../uvc.c      **** 							 break;
 784:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 785:../uvc.c      **** 							 dataIdx = 0;
 786:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 788:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 789:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 790:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 791:../uvc.c      **** 							 break;
 792:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 793:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
 794:../uvc.c      **** 							 dataIdx = 0;
 795:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 796:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 797:../uvc.c      **** 							  if(Data0&0x80){
 798:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 799:../uvc.c      **** 							  }else{
 800:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 801:../uvc.c      **** 							  }
 802:../uvc.c      **** 							 Data1 |= ~0x03;
 803:../uvc.c      **** 							 Data1 &= 0xC7;
 804:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 805:../uvc.c      **** 						  	 dataIdx++;
 806:../uvc.c      **** 
 807:../uvc.c      **** 							 Data0 = (Data0 << 2);
 808:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 809:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 810:../uvc.c      **** 
 811:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 812:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 813:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 814:../uvc.c      **** #endif
 815:../uvc.c      **** 							 dataIdx = 0;
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 817:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 818:../uvc.c      **** 							  if(Data0&0x80){
 819:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 820:../uvc.c      **** 							  }else{
 821:../uvc.c      **** 								  Data0 = ~Data0;
 822:../uvc.c      **** 							  }
 823:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 824:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 825:../uvc.c      **** 
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 828:../uvc.c      **** 
 829:../uvc.c      **** 
 830:../uvc.c      **** 							 break;
 831:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 832:../uvc.c      **** 							 dataIdx = 0;
 833:../uvc.c      **** 
 834:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 835:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 836:../uvc.c      **** 							 dataIdx++;
 837:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 838:../uvc.c      **** 							 dataIdx++;
 839:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 840:../uvc.c      **** 							 dataIdx++;
 841:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 842:../uvc.c      **** 							 dataIdx++;
 843:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 844:../uvc.c      **** 							 dataIdx++;
 845:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 846:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 847:../uvc.c      **** 
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 850:../uvc.c      **** 							 break;
 851:../uvc.c      **** 						 case SaturCtlID6:
 852:../uvc.c      **** 							 dataIdx = 0;
 853:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 854:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 855:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 856:../uvc.c      **** 							 dataIdx++;
 857:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 858:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 860:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 861:../uvc.c      **** 							 break;
 862:../uvc.c      **** 
 863:../uvc.c      **** 						 case WBTLevCtlID11:
 864:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 865:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 866:../uvc.c      **** 							 dataIdx = 0;
 867:../uvc.c      **** 
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 870:../uvc.c      **** 							 dataIdx++;
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 873:../uvc.c      **** 
 874:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 875:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 876:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 877:../uvc.c      **** 							 break;
 878:../uvc.c      **** 						 case MFreqCtlID4:
 879:../uvc.c      **** 							 dataIdx = 0;
 880:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 881:../uvc.c      **** 							 Data0 = Data0 - 1;
 882:../uvc.c      **** 							 is60Hz = Data0;
 883:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 884:../uvc.c      **** 							 {
 885:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
 886:../uvc.c      **** 								 is60Hz = CyFalse;
 887:../uvc.c      **** 							 }
 888:../uvc.c      **** 							 else if(Data0 >2)
 889:../uvc.c      **** 							 {
 890:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
 891:../uvc.c      **** 								 is60Hz = CyTrue;
 892:../uvc.c      **** 							 }
 893:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 894:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 895:../uvc.c      **** 							 {
 896:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 897:../uvc.c      **** 			                       switch (setRes)
 898:../uvc.c      **** 			                         {
 899:../uvc.c      **** 			                         	case 1: //1944
 900:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 901:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 902:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 903:../uvc.c      **** 			                         		break;
 904:../uvc.c      **** 			                         	case 2: //1080
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 907:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 908:../uvc.c      **** 			                         		break;
 909:../uvc.c      **** 			                         	case 3: //720
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 912:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is
 913:../uvc.c      **** 			                         		break;
 914:../uvc.c      **** 			                         	default:
 915:../uvc.c      **** 			                         		break;
 916:../uvc.c      **** 			                         }
 917:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 918:../uvc.c      **** 							 }
 919:../uvc.c      **** 
 920:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 921:../uvc.c      **** 							 break;
 922:../uvc.c      **** 					 	 case BLCCtlID0:
 923:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 924:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 925:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 926:../uvc.c      **** 							 {
 927:../uvc.c      **** 								 if(Data0 < 3){
 928:../uvc.c      **** 					 				 Data0 += 4;
 929:../uvc.c      **** 					 			 }else{
 930:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 931:../uvc.c      **** 									Data0 = 4; //set to default.
 932:../uvc.c      **** 					 			 }
 933:../uvc.c      **** 					 		 }
 934:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 935:../uvc.c      **** 							 dataIdx = 0;
 936:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 937:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 938:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 939:../uvc.c      **** 
 940:../uvc.c      **** 					 		 break;
 941:../uvc.c      **** 						 default:
 942:../uvc.c      **** 							 dataIdx = 0;
 943:../uvc.c      **** 
 944:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 945:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 946:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 947:../uvc.c      **** 
 948:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 950:../uvc.c      **** 							 break;
 951:../uvc.c      **** 					 }
 952:../uvc.c      **** 			   }else{
 953:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 954:../uvc.c      **** 			   }
 955:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 956:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 957:../uvc.c      **** #endif
 958:../uvc.c      **** 
 959:../uvc.c      **** 			  break;
 960:../uvc.c      **** 		  default:
 961:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 962:../uvc.c      **** 			  break;
 963:../uvc.c      **** 		 }
 964:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 965:../uvc.c      **** }
 966:../uvc.c      **** /************** CT control requests handler *************************/
 967:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 968:../uvc.c      **** 
 969:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 970:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 971:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 972:../uvc.c      ****     uint16_t readCount;
 973:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 974:../uvc.c      ****     uint16_t diff, value, diffRd;
 975:../uvc.c      ****     uint8_t i, shutter, index;
 976:../uvc.c      ****     diff = 0xffff;
 977:../uvc.c      ****     shutter = 1;
 978:../uvc.c      ****     index = 1;
 979:../uvc.c      **** 
 980:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 981:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 982:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 983:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 984:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 985:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 986:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 987:../uvc.c      **** #endif
 988:../uvc.c      ****     reqData = bRequest;
 989:../uvc.c      **** 
 990:../uvc.c      ****     switch (bRequest)
 991:../uvc.c      **** 		 {
 992:../uvc.c      **** 
 993:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 994:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 995:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 996:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 997:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 998:../uvc.c      **** 			  break;
 999:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1000:../uvc.c      **** 
1001:../uvc.c      **** 			 switch(CtrlID)
1002:../uvc.c      **** 			 {
1003:../uvc.c      **** 				 default:
1004:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1005:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1006:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1007:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1008:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1009:../uvc.c      **** 					 break;
1010:../uvc.c      **** 			 }
1011:../uvc.c      **** 
1012:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1013:../uvc.c      **** 
1014:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1015:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1016:../uvc.c      **** #endif
1017:../uvc.c      **** 			  break;
1018:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1019:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1022:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1023:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1026:../uvc.c      **** 			  break;
1027:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1028:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1031:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1032:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1033:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1034:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1035:../uvc.c      **** 			  break;
1036:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1037:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1038:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1039:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1040:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1041:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1042:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1043:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1044:../uvc.c      **** 			  break;
1045:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1046:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1047:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1048:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1049:../uvc.c      **** 			  Len = 1;
1050:../uvc.c      **** 			  break;
1051:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1052:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1053:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1054:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1055:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1056:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1057:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1058:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1059:../uvc.c      **** 			  break;
1060:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1061:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1062:../uvc.c      **** 			  glEp0Buffer, &readCount);
1063:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1064:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1065:../uvc.c      **** 			  value = Data1;
1066:../uvc.c      **** 
1067:../uvc.c      **** 			  switch(CtrlID)
1068:../uvc.c      **** 			  {
1069:../uvc.c      **** 		  	      case AutoExMCtlID1:
1070:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1071:../uvc.c      **** 
1072:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1073:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1074:../uvc.c      **** 				    getData = glEp0Buffer[0];
1075:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1076:../uvc.c      **** 		  		    switch (getData){
1077:../uvc.c      **** 						case 1:
1078:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1079:../uvc.c      **** 							break;
1080:../uvc.c      **** 						case 2:
1081:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1082:../uvc.c      **** 							dataIdx = 0;
1083:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1084:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1085:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1086:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1087:../uvc.c      **** 
1088:../uvc.c      **** 							break;
1089:../uvc.c      **** 						case 4:
1090:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1091:../uvc.c      **** 							break;
1092:../uvc.c      **** 						case 8:
1093:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1094:../uvc.c      **** 			  		    	dataIdx = 0;
1095:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1096:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1097:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1098:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1099:../uvc.c      **** 							break;
1100:../uvc.c      **** 		  		    }
1101:../uvc.c      **** #if 0
1102:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1103:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1104:../uvc.c      **** 						  dataIdx = 0;
1105:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1106:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1107:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1108:../uvc.c      **** 		  		    }
1109:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1110:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1111:../uvc.c      **** 		  		    }
1112:../uvc.c      **** #endif
1113:../uvc.c      **** 				    break;
1114:../uvc.c      **** 
1115:../uvc.c      **** 			  	  case ExTmACtlID3:
1116:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1117:../uvc.c      **** 
1118:../uvc.c      **** 					  value = (value << 8)|Data0;
1119:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1120:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1121:../uvc.c      **** 					  {
1122:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1123:../uvc.c      **** 						  {
1124:../uvc.c      **** 							if(value > ShutValueArry[i]){
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1126:../uvc.c      **** 							}else{
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1128:../uvc.c      **** 							}
1129:../uvc.c      **** 							  if(diff > diffRd){
1130:../uvc.c      **** 								  diff = diffRd;
1131:../uvc.c      **** 								  index = i;
1132:../uvc.c      **** 							  }
1133:../uvc.c      **** 						  }
1134:../uvc.c      **** 						  shutter = shutter+index;
1135:../uvc.c      **** 
1136:../uvc.c      **** 						  dataIdx = 0;
1137:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1138:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1139:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1140:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1141:../uvc.c      **** 
1142:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1143:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1144:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1145:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1146:../uvc.c      **** 					  }else{
1147:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1148:../uvc.c      **** 					  }
1149:../uvc.c      **** 					  getData = glEp0Buffer[0];
1150:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1151:../uvc.c      **** 					  break;
1152:../uvc.c      **** 			  	  case IriACtlID7:
1153:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1154:../uvc.c      **** 					  {
1155:../uvc.c      **** 							 dataIdx = 0;
1156:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1157:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1158:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1159:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1160:../uvc.c      **** 
1161:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1162:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1163:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1164:../uvc.c      **** 					  }else{
1165:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1166:../uvc.c      **** 					  }
1167:../uvc.c      **** 					  getData = glEp0Buffer[0];
1168:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1169:../uvc.c      **** 
1170:../uvc.c      **** 					  break;
1171:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1172:../uvc.c      **** 					  getData = glEp0Buffer[0];
1173:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1174:../uvc.c      **** #if 1
1175:../uvc.c      **** 					  dataIdx = 0;
1176:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1177:../uvc.c      **** 					  if(getData == 1)
1178:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1179:../uvc.c      **** 					  else if(getData == 0xff)
1180:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1181:../uvc.c      **** 					  else
1182:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1183:../uvc.c      **** 					  //dataIdx++;
1184:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1185:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1186:../uvc.c      **** #endif
1187:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1188:../uvc.c      **** 					  break;
1189:../uvc.c      **** 
1190:../uvc.c      **** 			  	  default:
1191:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1192:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1193:../uvc.c      **** 			  		 break;
1194:../uvc.c      **** 			  }
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		  default:
1197:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1198:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1199:../uvc.c      **** 			  break;
1200:../uvc.c      **** 		 }
1201:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1202:../uvc.c      **** 
1203:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1204:../uvc.c      **** }
1205:../uvc.c      **** 
1206:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1207:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1208:../uvc.c      **** {
1209:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1210:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1211:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1212:../uvc.c      **** 
1213:../uvc.c      ****     CtrlID = BrgtCtlID1;
1214:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1215:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1216:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1217:../uvc.c      ****     Data1 = Data0;
1218:../uvc.c      **** 
1219:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1220:../uvc.c      ****     if(Data1&0x80){
1221:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1222:../uvc.c      ****     }else{
1223:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1224:../uvc.c      ****     }
1225:../uvc.c      ****     Data0 = (Data0 << 2);
1226:../uvc.c      **** 
1227:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1228:../uvc.c      **** 
1229:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1231:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1232:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1234:../uvc.c      **** 
1235:../uvc.c      ****     CtrlID = ConsCtlID2;
1236:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1237:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1238:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1239:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1240:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1241:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1242:../uvc.c      **** 
1243:../uvc.c      ****     CtrlID = HueCtlID5;
1244:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1245:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1246:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1253:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1254:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1255:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1256:../uvc.c      **** 
1257:../uvc.c      ****     CtrlID = SaturCtlID6;
1258:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1259:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1260:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1261:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1262:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1263:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1264:../uvc.c      **** 
1265:../uvc.c      ****     CtrlID = ShapCtlID7;
1266:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1267:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1268:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1269:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1270:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1271:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1272:../uvc.c      **** 
1273:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1274:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1275:../uvc.c      **** 	return;
1276:../uvc.c      **** }
1277:../uvc.c      **** 
1278:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1279:../uvc.c      **** void
1280:../uvc.c      **** CyFxUVCAddHeader (
1281:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1282:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1283:../uvc.c      ****         )
1284:../uvc.c      **** {
1285:../uvc.c      ****     /* Copy header to buffer */
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1287:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1288:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1289:../uvc.c      **** 
1290:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1291:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1292:../uvc.c      ****     {
1293:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1294:../uvc.c      ****     }
1295:../uvc.c      **** }
1296:../uvc.c      **** 
1297:../uvc.c      **** 
1298:../uvc.c      **** /* Application Error Handler */
1299:../uvc.c      **** void
1300:../uvc.c      **** CyFxAppErrorHandler (
1301:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1302:../uvc.c      ****         )
1303:../uvc.c      **** {
1304:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1305:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1306:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1307:../uvc.c      **** 
1308:../uvc.c      ****        This function can be modified to take additional error handling actions such
1309:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1310:../uvc.c      ****      */
1311:../uvc.c      ****     for (;;)
1312:../uvc.c      ****     {
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
1315:../uvc.c      ****     }
1316:../uvc.c      **** }
1317:../uvc.c      **** 
1318:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1319:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1320:../uvc.c      ****  */
1321:../uvc.c      **** static void
1322:../uvc.c      **** CyFxUVCApplnAbortHandler (
1323:../uvc.c      ****         void)
1324:../uvc.c      **** {
1325:../uvc.c      **** 	uint32_t flag;
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1327:../uvc.c      **** 	{
1328:../uvc.c      ****         /* Clear the Video Stream Request Event */
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1330:../uvc.c      **** 
1331:../uvc.c      ****         /* Set Video Stream Abort Event */
1332:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1333:../uvc.c      **** 	}
1334:../uvc.c      **** }
1335:../uvc.c      **** 
1336:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1337:../uvc.c      **** static void
1338:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1339:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1340:../uvc.c      ****         uint16_t             evdata  /* Event data */
1341:../uvc.c      ****         )
1342:../uvc.c      **** {
1343:../uvc.c      ****     switch (evtype)
1344:../uvc.c      ****     {
1345:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1346:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1347:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1348:../uvc.c      ****             gpif_initialized = 0;
1349:../uvc.c      ****             streamingStarted = CyFalse;
1350:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1351:../uvc.c      ****             break;
1352:../uvc.c      **** 
1353:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1354:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1355:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1356:../uvc.c      ****             gpif_initialized = 0;
1357:../uvc.c      ****             streamingStarted = CyFalse;
1358:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1359:../uvc.c      ****             break;
1360:../uvc.c      **** 
1361:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1362:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1363:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1364:../uvc.c      ****             gpif_initialized = 0;
1365:../uvc.c      ****             isUsbConnected = CyFalse;
1366:../uvc.c      ****             streamingStarted = CyFalse;
1367:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1368:../uvc.c      ****             break;
1369:../uvc.c      **** 
1370:../uvc.c      **** #ifdef BACKFLOW_DETECT
1371:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1372:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1373:../uvc.c      ****             break;
1374:../uvc.c      **** #endif
1375:../uvc.c      **** 
1376:../uvc.c      ****         default:
1377:../uvc.c      ****             break;
1378:../uvc.c      ****     }
1379:../uvc.c      **** }
1380:../uvc.c      **** 
1381:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1382:../uvc.c      **** static CyBool_t
1383:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1384:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1385:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1386:../uvc.c      ****         )
1387:../uvc.c      **** {
1388:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1389:../uvc.c      ****     uint32_t status;
1390:../uvc.c      **** 
1391:../uvc.c      ****     /* Obtain Request Type and Request */
1392:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1393:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1394:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1395:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1396:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1397:../uvc.c      **** 
1398:../uvc.c      ****     /* Check for UVC Class Requests */
1399:../uvc.c      ****     switch (bmReqType)
1400:../uvc.c      ****     {
1401:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1402:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1403:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1404:../uvc.c      ****             switch (wIndex & 0xFF)
1405:../uvc.c      ****             {
1406:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1407:../uvc.c      ****                     {
1408:../uvc.c      ****                         uvcHandleReq = CyTrue;
1409:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1410:../uvc.c      ****                                 CYU3P_EVENT_OR);
1411:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1412:../uvc.c      ****                         {
1413:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1414:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1415:../uvc.c      ****                         }
1416:../uvc.c      ****                     }
1417:../uvc.c      ****                     break;
1418:../uvc.c      **** 
1419:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1420:../uvc.c      ****                     {
1421:../uvc.c      ****                         uvcHandleReq = CyTrue;
1422:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1423:../uvc.c      ****                                 CYU3P_EVENT_OR);
1424:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1425:../uvc.c      ****                         {
1426:../uvc.c      ****                             /* Error handling */
1427:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1428:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1429:../uvc.c      ****                         }
1430:../uvc.c      ****                     }
1431:../uvc.c      ****                     break;
1432:../uvc.c      **** 
1433:../uvc.c      ****                 default:
1434:../uvc.c      ****                     break;
1435:../uvc.c      ****             }
1436:../uvc.c      ****             break;
1437:../uvc.c      **** 
1438:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1439:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1440:../uvc.c      ****             {
1441:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1442:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1443:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1444:../uvc.c      ****                 {
1445:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1446:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1447:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1448:../uvc.c      ****                     gpif_initialized = 0;
1449:../uvc.c      ****                     streamingStarted = CyFalse;
1450:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1452:../uvc.c      ****                     CyU3PBusyWait (100);
1453:../uvc.c      **** 
1454:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1455:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1456:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1457:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1458:../uvc.c      ****                     CyU3PBusyWait (100);
1459:../uvc.c      **** 
1460:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1461:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1462:../uvc.c      ****                     uvcHandleReq = CyTrue;
1463:../uvc.c      ****                     /* Complete Control request handshake */
1464:../uvc.c      ****                     CyU3PUsbAckSetup ();
1465:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1466:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1467:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1468:../uvc.c      **** 
1469:../uvc.c      ****                 }
1470:../uvc.c      ****             }
1471:../uvc.c      ****             break;
1472:../uvc.c      **** 
1473:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1474:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1475:../uvc.c      ****             {
1476:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1477:../uvc.c      ****                 {
1478:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1479:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1480:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1481:../uvc.c      ****                 	 * has started. */
1482:../uvc.c      ****                     if (streamingStarted == CyTrue)
1483:../uvc.c      ****                     {
1484:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1485:../uvc.c      **** 
1486:../uvc.c      ****                         /* Disable the GPIF state machine. */
1487:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1488:../uvc.c      ****                         gpif_initialized = 0;
1489:../uvc.c      ****                         streamingStarted = CyFalse;
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1493:../uvc.c      ****                         CyU3PBusyWait (100);
1494:../uvc.c      **** 
1495:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1496:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1497:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1498:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1499:../uvc.c      ****                         CyU3PBusyWait (100);
1500:../uvc.c      **** 
1501:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1502:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1503:../uvc.c      **** 
1504:../uvc.c      ****                         uvcHandleReq = CyTrue;
1505:../uvc.c      ****                         /* Complete Control request handshake */
1506:../uvc.c      ****                         CyU3PUsbAckSetup ();
1507:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1508:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1509:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1510:../uvc.c      ****                     }
1511:../uvc.c      ****                     else
1512:../uvc.c      ****                     {
1513:../uvc.c      ****                         uvcHandleReq = CyTrue;
1514:../uvc.c      ****                         CyU3PUsbAckSetup ();
1515:../uvc.c      ****                     }
1516:../uvc.c      ****                 }
1517:../uvc.c      ****             }
1518:../uvc.c      ****             break;
1519:../uvc.c      **** 
1520:../uvc.c      ****         default:
1521:../uvc.c      ****             break;
1522:../uvc.c      ****     }
1523:../uvc.c      **** 
1524:../uvc.c      ****     /* Return status of request handling to the USB driver */
1525:../uvc.c      ****     return uvcHandleReq;
1526:../uvc.c      **** }
1527:../uvc.c      **** 
1528:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1529:../uvc.c      **** 
1530:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1531:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1532:../uvc.c      ****  */
1533:../uvc.c      **** void
1534:../uvc.c      **** CyFxUvcApplnDmaCallback (
1535:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1536:../uvc.c      ****         CyU3PDmaCbType_t      type,
1537:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1538:../uvc.c      ****         )
1539:../uvc.c      **** {
1540:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1541:../uvc.c      **** #if 1
1542:../uvc.c      ****     CyU3PReturnStatus_t status;
1543:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1544:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1545:../uvc.c      **** 
1546:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1547:../uvc.c      ****     {
1548:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1549:../uvc.c      ****             {
1550:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
1551:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
1552:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1553:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
1554:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1555:../uvc.c      ****                 	stiflag = 0x03;
1556:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
1557:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1558:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1559:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1560:../uvc.c      ****                 }
1561:../uvc.c      **** #endif
1562:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
1563:../uvc.c      ****                 fb++;
1564:../uvc.c      ****             }
1565:../uvc.c      ****             else
1566:../uvc.c      ****             {
1567:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1568:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1569:../uvc.c      ****                 pb++;
1570:../uvc.c      ****                 pbc = input->buffer_p.count;
1571:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1572:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1573:../uvc.c      ****                 //lineCount = 0; //res test
1574:../uvc.c      **** #if 1   //remove the still flag clearing here
1575:../uvc.c      ****                 if(stiflag == 0x0F){
1576:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1577:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1578:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1579:../uvc.c      ****                 	stiflag = 0xAA;
1580:../uvc.c      ****                 }
1581:../uvc.c      **** #endif
1582:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1583:../uvc.c      ****             }
1584:../uvc.c      **** 
1585:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1586:../uvc.c      ****             prodCount++;
1587:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1588:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1589:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1590:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1591:../uvc.c      ****             {
1592:../uvc.c      ****                 prodCount--;
1593:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1594:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1595:../uvc.c      ****             }
1596:../uvc.c      ****     }
1597:../uvc.c      **** #endif
1598:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1599:../uvc.c      ****     {
1600:../uvc.c      ****         consCount++;
1601:../uvc.c      ****         streamingStarted = CyTrue;
1602:../uvc.c      ****     }
1603:../uvc.c      **** }
1604:../uvc.c      **** 
1605:../uvc.c      **** /*
1606:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1607:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1608:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1609:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1610:../uvc.c      ****  * to commit the buffer.
1611:../uvc.c      ****  */
1612:../uvc.c      **** static uint8_t
1613:../uvc.c      **** CyFxUvcAppCommitEOF (
1614:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1615:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1616:../uvc.c      ****         )
1617:../uvc.c      **** {
1618:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1619:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1620:../uvc.c      **** 
1621:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1622:../uvc.c      **** 
1623:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1624:../uvc.c      ****     {
1625:../uvc.c      ****         switch (stateId)
1626:../uvc.c      ****         {
1627:../uvc.c      **** 
1628:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1629:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1630:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1631:../uvc.c      ****                 break;
1632:../uvc.c      **** 
1633:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1634:../uvc.c      ****                 socket = 0;
1635:../uvc.c      ****                 break;
1636:../uvc.c      **** 
1637:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1638:../uvc.c      ****                 socket = 1;
1639:../uvc.c      ****                 break;
1640:../uvc.c      **** 
1641:../uvc.c      ****             default:
1642:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1643:../uvc.c      ****                 /* Unexpected current state. Return error. */
1644:../uvc.c      ****             	//lineCount++;
1645:../uvc.c      ****             	return 1;
1646:../uvc.c      ****         }
1647:../uvc.c      ****     }
1648:../uvc.c      **** 
1649:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1650:../uvc.c      ****     {
1651:../uvc.c      ****         switch (stateId)
1652:../uvc.c      ****         {
1653:../uvc.c      **** #ifndef CAM720
1654:../uvc.c      **** #ifdef GPIFIIM
1655:../uvc.c      ****             case 13:
1656:../uvc.c      ****             case 24:
1657:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1658:../uvc.c      ****                 break;
1659:../uvc.c      **** 
1660:../uvc.c      ****             case 8:
1661:../uvc.c      ****                 socket = 0;
1662:../uvc.c      ****                 break;
1663:../uvc.c      **** 
1664:../uvc.c      ****             case 20:
1665:../uvc.c      ****                 socket = 1;
1666:../uvc.c      ****                 break;
1667:../uvc.c      **** #else
1668:../uvc.c      ****             case 11:
1669:../uvc.c      ****             case 18:
1670:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** 
1673:../uvc.c      ****             case 8:
1674:../uvc.c      ****                 socket = 0;
1675:../uvc.c      ****                 break;
1676:../uvc.c      **** 
1677:../uvc.c      ****             case 15:
1678:../uvc.c      ****                 socket = 1;
1679:../uvc.c      ****                 break;
1680:../uvc.c      **** #endif
1681:../uvc.c      **** #else
1682:../uvc.c      ****             case 11:
1683:../uvc.c      ****             case 18:
1684:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1685:../uvc.c      ****                 break;
1686:../uvc.c      **** 
1687:../uvc.c      ****             case 8:
1688:../uvc.c      ****                 socket = 0;
1689:../uvc.c      ****                 break;
1690:../uvc.c      **** 
1691:../uvc.c      ****             case 15:
1692:../uvc.c      ****                 socket = 1;
1693:../uvc.c      ****                 break;
1694:../uvc.c      **** 
1695:../uvc.c      **** #endif
1696:../uvc.c      ****              default:
1697:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1698:../uvc.c      ****                 /* Unexpected current state. Return error. */
1699:../uvc.c      ****                return 1;
1700:../uvc.c      ****         }
1701:../uvc.c      ****     }
1702:../uvc.c      **** 
1703:../uvc.c      ****     if (socket != 0xFF)
1704:../uvc.c      ****     {
1705:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1706:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1707:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1708:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1709:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1710:../uvc.c      ****         {
1711:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1712:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1713:../uvc.c      ****         }
1714:../uvc.c      ****     }
1715:../uvc.c      **** 
1716:../uvc.c      ****     return 0;
1717:../uvc.c      **** }
1718:../uvc.c      **** 
1719:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1720:../uvc.c      **** void
1721:../uvc.c      **** CyFxGpifCB (
1722:../uvc.c      ****         CyU3PGpifEventType event,
1723:../uvc.c      ****         uint8_t currentState
1724:../uvc.c      ****         )
1725:../uvc.c      **** {
1726:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1727:../uvc.c      ****     {
1728:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1729:../uvc.c      ****     	           in the UVC implementation. */
1730:../uvc.c      ****     	//hitFV = CyTrue;
1731:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1732:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1733:../uvc.c      ****     }
1734:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1735:../uvc.c      **** }
1736:../uvc.c      **** 
1737:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1738:../uvc.c      **** static void
1739:../uvc.c      **** CyFxUVCApplnDebugInit (
1740:../uvc.c      ****         void)
1741:../uvc.c      **** {
1742:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1743:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1744:../uvc.c      **** 
1745:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1746:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1747:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1748:../uvc.c      ****     {
1749:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1750:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1751:../uvc.c      ****     }
1752:../uvc.c      **** 
1753:../uvc.c      ****     /* Set UART Configuration */
1754:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1755:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1756:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1757:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1758:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1759:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1760:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1761:../uvc.c      **** 
1762:../uvc.c      ****     /* Set the UART configuration */
1763:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1764:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1765:../uvc.c      ****     {
1766:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1767:../uvc.c      ****     }
1768:../uvc.c      **** 
1769:../uvc.c      ****     /* Set the UART transfer */
1770:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1771:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1772:../uvc.c      ****     {
1773:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1774:../uvc.c      ****     }
1775:../uvc.c      **** 
1776:../uvc.c      ****     /* Initialize the Debug logger module. */
1777:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1778:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1779:../uvc.c      ****     {
1780:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1781:../uvc.c      ****     }
1782:../uvc.c      **** 
1783:../uvc.c      ****     /* Disable log message headers. */
1784:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1785:../uvc.c      **** }
1786:../uvc.c      **** 
1787:../uvc.c      **** /* I2C initialization. */
1788:../uvc.c      **** static void
1789:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1790:../uvc.c      **** {
1791:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1792:../uvc.c      ****     CyU3PReturnStatus_t status;
1793:../uvc.c      **** 
1794:../uvc.c      ****     status = CyU3PI2cInit ();
1795:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1796:../uvc.c      ****     {
1797:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1798:../uvc.c      ****         CyFxAppErrorHandler (status);
1799:../uvc.c      ****     }
1800:../uvc.c      **** 
1801:../uvc.c      ****     /*  Set I2C Configuration */
1802:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1803:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1804:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1805:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1806:../uvc.c      **** 
1807:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1808:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1809:../uvc.c      ****     {
1810:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1811:../uvc.c      ****         CyFxAppErrorHandler (status);
1812:../uvc.c      ****     }
1813:../uvc.c      **** }
1814:../uvc.c      **** 
1815:../uvc.c      **** #ifdef BACKFLOW_DETECT
1816:../uvc.c      **** static void CyFxUvcAppPibCallback (
1817:../uvc.c      ****         CyU3PPibIntrType cbType,
1818:../uvc.c      ****         uint16_t cbArg)
1819:../uvc.c      **** {
1820:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1821:../uvc.c      ****     {
1822:../uvc.c      ****         if (!back_flow_detected)
1823:../uvc.c      ****         {
1824:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1825:../uvc.c      ****             back_flow_detected = 1;
1826:../uvc.c      ****         }
1827:../uvc.c      ****     }
1828:../uvc.c      **** }
1829:../uvc.c      **** #endif
1830:../uvc.c      **** 
1831:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1832:../uvc.c      **** static void
1833:../uvc.c      **** CyFxUvcAppDebugCallback (
1834:../uvc.c      ****         CyU3PDmaChannel   *handle,
1835:../uvc.c      ****         CyU3PDmaCbType_t   type,
1836:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1837:../uvc.c      **** {
1838:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1839:../uvc.c      ****     {
1840:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1841:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1842:../uvc.c      ****     }
1843:../uvc.c      **** }
1844:../uvc.c      **** #endif
1845:../uvc.c      **** 
1846:../uvc.c      **** #if 0
1847:../uvc.c      **** static void CyFxAppIntEpCb(
1848:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1849:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1850:../uvc.c      **** 		uint8_t  ebNum)
1851:../uvc.c      **** 		{
1852:../uvc.c      **** 			//CyBool_t value;
1853:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1854:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1855:../uvc.c      **** 
1856:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1857:../uvc.c      **** 		}
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 
1860:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1861:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1862:../uvc.c      ****    configures the DMA module for the UVC Application */
1863:../uvc.c      **** static void
1864:../uvc.c      **** CyFxUVCApplnInit (void)
1865:../uvc.c      **** {
1866:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1867:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1868:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1869:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1870:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1871:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1872:../uvc.c      **** 
1873:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1874:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1875:../uvc.c      **** 
1876:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1877:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1878:../uvc.c      **** #endif
1879:../uvc.c      **** 
1880:../uvc.c      ****     /* Create UVC event group */
1881:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1882:../uvc.c      ****     if (apiRetStatus != 0)
1883:../uvc.c      ****     {
1884:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1885:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1886:../uvc.c      ****     }
1887:../uvc.c      **** 
1888:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1889:../uvc.c      ****     CyFxUvcAppPTZInit ();
1890:../uvc.c      **** #endif
1891:../uvc.c      **** 
1892:../uvc.c      ****     isUsbConnected = CyFalse;
1893:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1894:../uvc.c      **** 
1895:../uvc.c      ****     /* Init the GPIO module */
1896:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1897:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1898:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1899:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1900:../uvc.c      ****     gpioClock.halfDiv    = 0;
1901:../uvc.c      **** 
1902:../uvc.c      ****     /* Initialize Gpio interface */
1903:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1904:../uvc.c      ****     if (apiRetStatus != 0)
1905:../uvc.c      ****     {
1906:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1907:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1908:../uvc.c      ****     }
1909:../uvc.c      **** 
1910:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1911:../uvc.c      ****      * must use GpioOverride to configure it */
1912:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1913:../uvc.c      ****     if (apiRetStatus != 0)
1914:../uvc.c      ****     {
1915:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1917:../uvc.c      ****     }
1918:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1919:../uvc.c      ****     if (apiRetStatus != 0)
1920:../uvc.c      ****     {
1921:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1922:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1923:../uvc.c      ****     }
1924:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1925:../uvc.c      ****     if (apiRetStatus != 0)
1926:../uvc.c      ****     {
1927:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1928:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1929:../uvc.c      ****     }
1930:../uvc.c      **** 
1931:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1932:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1933:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1934:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1935:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1936:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1937:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1938:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1939:../uvc.c      ****     {
1940:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1941:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1942:../uvc.c      ****     }
1943:../uvc.c      **** 
1944:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1945:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1946:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1947:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1948:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1949:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1950:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1951:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1952:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1953:../uvc.c      ****     {
1954:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1955:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1956:../uvc.c      ****     }
1957:../uvc.c      **** 
1958:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1959:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1960:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1961:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1962:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1963:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1964:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1965:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1966:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1967:../uvc.c      ****     {
1968:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1969:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1970:../uvc.c      ****     }
1971:../uvc.c      **** 
1972:../uvc.c      ****     /* Initialize the P-port. */
1973:../uvc.c      ****     pibclock.clkDiv      = 2;
1974:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1975:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1976:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1977:../uvc.c      **** 
1978:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1979:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1980:../uvc.c      ****     {
1981:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1982:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1983:../uvc.c      ****     }
1984:../uvc.c      **** 
1985:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1986:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1987:../uvc.c      **** 
1988:../uvc.c      **** #ifdef BACKFLOW_DETECT
1989:../uvc.c      ****     back_flow_detected = 0;
1990:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1991:../uvc.c      **** #endif
1992:../uvc.c      **** 
1993:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1994:../uvc.c      ****     SensorReset ();
1995:../uvc.c      ****     CyU3PThreadSleep(5000);
1996:../uvc.c      ****     //SensorInit ();
1997:../uvc.c      **** 
1998:../uvc.c      ****     /* USB initialization. */
1999:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2000:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2001:../uvc.c      ****     {
2002:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2003:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2004:../uvc.c      ****     }
2005:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2006:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2007:../uvc.c      **** 
2008:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2009:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2010:../uvc.c      **** 
2011:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2012:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2013:../uvc.c      **** 
2014:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2015:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2016:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2017:../uvc.c      **** 
2018:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2019:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2021:../uvc.c      **** 
2022:../uvc.c      ****     /* Configuration descriptors. */
2023:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2026:../uvc.c      **** 
2027:../uvc.c      ****     /* String Descriptors */
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2031:../uvc.c      **** 
2032:../uvc.c      ****     /* Configure the status interrupt endpoint.
2033:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2034:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2035:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2036:../uvc.c      ****      */
2037:../uvc.c      ****     endPointConfig.enable   = 1;
2038:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2039:../uvc.c      ****     endPointConfig.pcktSize = 64;
2040:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2041:../uvc.c      ****     endPointConfig.streams  = 0;
2042:../uvc.c      ****     endPointConfig.burstLen = 1;
2043:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2044:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2045:../uvc.c      ****     {
2046:../uvc.c      ****         /* Error Handling */
2047:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2048:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2049:../uvc.c      ****     }
2050:../uvc.c      **** 
2051:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2052:../uvc.c      ****     dmaInterConfig.size           = 1024;
2053:../uvc.c      ****     dmaInterConfig.count          = 1;
2054:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2055:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2056:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2057:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2058:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2059:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2060:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2061:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2062:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2063:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2064:../uvc.c      ****             &dmaInterConfig);
2065:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2066:../uvc.c      ****     {
2067:../uvc.c      ****         /* Error handling */
2068:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2069:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2070:../uvc.c      ****     }
2071:../uvc.c      **** 
2072:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2073:../uvc.c      ****     if (glInterStaBuffer == 0)
2074:../uvc.c      ****     {
2075:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2076:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2077:../uvc.c      ****     }
2078:../uvc.c      **** 
2079:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2080:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2081:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2082:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2083:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2084:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2085:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2086:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2087:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2088:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2089:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2090:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2091:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2092:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2093:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2094:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2095:../uvc.c      ****             &dmaMultiConfig);
2096:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2097:../uvc.c      ****     {
2098:../uvc.c      ****         /* Error handling */
2099:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2100:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2101:../uvc.c      ****     }
2102:../uvc.c      **** 
2103:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2104:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2105:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2106:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2107:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2108:../uvc.c      ****      */
2109:../uvc.c      **** 
2110:../uvc.c      ****     endPointConfig.enable   = 1;
2111:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2112:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2113:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2114:../uvc.c      ****     endPointConfig.streams  = 0;
2115:../uvc.c      ****     endPointConfig.burstLen = 1;
2116:../uvc.c      **** 
2117:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2118:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2119:../uvc.c      ****     {
2120:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2121:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2122:../uvc.c      ****     }
2123:../uvc.c      **** 
2124:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2125:../uvc.c      **** 
2126:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2127:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2128:../uvc.c      ****     {
2129:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2130:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2131:../uvc.c      ****     }
2132:../uvc.c      **** 
2133:../uvc.c      ****     channelConfig.size           = 1024;
2134:../uvc.c      ****     channelConfig.count          = 1;
2135:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2136:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2137:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2138:../uvc.c      ****     channelConfig.prodHeader     = 0;
2139:../uvc.c      ****     channelConfig.prodFooter     = 0;
2140:../uvc.c      ****     channelConfig.consHeader     = 0;
2141:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2142:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2143:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2144:../uvc.c      **** 
2145:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2146:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2147:../uvc.c      ****     {
2148:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2149:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2150:../uvc.c      ****     }
2151:../uvc.c      **** 
2152:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2153:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2154:../uvc.c      ****     {
2155:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2156:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2157:../uvc.c      ****     }
2158:../uvc.c      **** 
2159:../uvc.c      ****     channelConfig.size           = 1024;
2160:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2161:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2162:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2163:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2164:../uvc.c      ****     channelConfig.prodHeader     = 0;
2165:../uvc.c      ****     channelConfig.prodFooter     = 0;
2166:../uvc.c      ****     channelConfig.consHeader     = 0;
2167:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2168:../uvc.c      ****     channelConfig.notification   = 0;
2169:../uvc.c      ****     channelConfig.cb             = 0;
2170:../uvc.c      **** 
2171:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2172:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2173:../uvc.c      ****     {
2174:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2175:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2176:../uvc.c      ****     }
2177:../uvc.c      **** 
2178:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2179:../uvc.c      ****     if (glDebugRspBuffer == 0)
2180:../uvc.c      ****     {
2181:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2182:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2183:../uvc.c      ****     }
2184:../uvc.c      **** #endif
2185:../uvc.c      **** 
2186:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2187:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2188:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2189:../uvc.c      ****     {
2190:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2191:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2192:../uvc.c      ****     }
2193:../uvc.c      **** 
2194:../uvc.c      ****     CyU3PBusyWait(100);
2195:../uvc.c      **** 
2196:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2197:../uvc.c      **** 
2198:../uvc.c      ****     endPointConfig.enable   = 1;
2199:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2200:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2201:../uvc.c      ****     {
2202:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2203:../uvc.c      ****     	endPointConfig.burstLen = 16;
2204:../uvc.c      ****     }
2205:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2206:../uvc.c      ****     {
2207:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2208:../uvc.c      ****     	endPointConfig.burstLen = 1;
2209:../uvc.c      ****     }
2210:../uvc.c      ****     endPointConfig.streams  = 0;
2211:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2213:../uvc.c      ****     {
2214:../uvc.c      ****         /* Error Handling */
2215:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2216:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2217:../uvc.c      ****     }
2218:../uvc.c      **** #if 0    //for still image method 3 using
2219:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2220:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2221:../uvc.c      ****     {
2222:../uvc.c      ****         /* Error Handling */
2223:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2224:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2225:../uvc.c      ****     }
2226:../uvc.c      **** #endif
2227:../uvc.c      **** 
2228:../uvc.c      **** }
2229:../uvc.c      **** 
2230:../uvc.c      **** /*
2231:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2232:../uvc.c      ****  * streaming session is started.
2233:../uvc.c      ****  */
2234:../uvc.c      **** static void
2235:../uvc.c      **** CyFxUvcAppGpifInit (
2236:../uvc.c      ****         void)
2237:../uvc.c      **** {
2238:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2239:../uvc.c      **** 
2240:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2241:../uvc.c      ****     {
2242:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2243:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2244:../uvc.c      ****     }
2245:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2246:../uvc.c      ****     {
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2249:../uvc.c      ****     }
2250:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2251:../uvc.c      ****     {
2252:../uvc.c      ****         /* Error Handling */
2253:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2254:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2255:../uvc.c      ****     }
2256:../uvc.c      **** 
2257:../uvc.c      ****     /* Start the state machine from the designated start state. */
2258:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2259:../uvc.c      ****     {
2260:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2261:../uvc.c      ****     }
2262:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2263:../uvc.c      ****     {
2264:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2265:../uvc.c      ****     }
2266:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2267:../uvc.c      ****     {
2268:../uvc.c      ****         /* Error Handling */
2269:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2270:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2271:../uvc.c      ****     }
2272:../uvc.c      **** }
2273:../uvc.c      **** 
2274:../uvc.c      **** /*
2275:../uvc.c      ****  * Entry function for the UVC Application Thread
2276:../uvc.c      ****  */
2277:../uvc.c      **** 
2278:../uvc.c      **** uint32_t posTick;
2279:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2280:../uvc.c      **** 
2281:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2282:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2283:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2284:../uvc.c      **** }
2285:../uvc.c      **** 
2286:../uvc.c      **** 
2287:../uvc.c      **** void
2288:../uvc.c      **** UVCAppThread_Entry (
2289:../uvc.c      ****         uint32_t input)
2290:../uvc.c      **** {
2291:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2292:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2293:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2294:../uvc.c      ****     uint8_t i = 0;
2295:../uvc.c      ****     uint32_t flag;
2296:../uvc.c      ****     uint32_t prinflag = 0;
2297:../uvc.c      **** static uint8_t IMcount = 0;
2298:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2299:../uvc.c      ****     uint32_t frameCnt = 0;
2300:../uvc.c      **** #endif
2301:../uvc.c      ****     /* Initialize the Uart Debug Module */
2302:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2303:../uvc.c      **** 
2304:../uvc.c      ****     /* Initialize the I2C interface */
2305:../uvc.c      **** 	while (i++ < 6){
2306:../uvc.c      **** 		CyU3PThreadSleep(500);
2307:../uvc.c      **** 	}
2308:../uvc.c      **** 
2309:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2310:../uvc.c      **** 
2311:../uvc.c      ****     /* Initialize the UVC Application */
2312:../uvc.c      ****     CyFxUVCApplnInit ();
2313:../uvc.c      ****     /*
2314:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2315:../uvc.c      **** 
2316:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2317:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2318:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2319:../uvc.c      **** 
2320:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2321:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2322:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2323:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2324:../uvc.c      **** 
2325:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2326:../uvc.c      ****        of handling the abort request.
2327:../uvc.c      ****      */
2328:../uvc.c      **** 
2329:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2330:../uvc.c      ****     //CyU3PThreadSleep(1000);
2331:../uvc.c      **** 
2332:../uvc.c      ****     for (;;)
2333:../uvc.c      ****     {
2334:../uvc.c      ****         /* Waiting for the Video Stream Event */
2335:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2336:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2337:../uvc.c      ****         {
2338:../uvc.c      **** #if 0 //test for new firmware no video bring up
2339:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2340:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2341:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2342:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2343:../uvc.c      ****             {
2344:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2345:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2346:../uvc.c      ****                 {
2347:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2348:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2349:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2350:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2351:../uvc.c      **** #endif
2352:../uvc.c      **** #endif
2353:../uvc.c      ****                     }
2354:../uvc.c      ****                 else
2355:../uvc.c      ****                 {
2356:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2357:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2358:../uvc.c      **** #ifdef USB_LOWRES_IMG
2359:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2360:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2361:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2362:../uvc.c      **** #endif
2363:../uvc.c      **** #endif
2364:../uvc.c      ****                 }
2365:../uvc.c      **** 
2366:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2367:../uvc.c      ****                 prodCount++;
2368:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2369:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2370:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2371:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2372:../uvc.c      ****                 {
2373:../uvc.c      ****                     prodCount--;
2374:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2375:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2376:../uvc.c      ****                 }
2377:../uvc.c      ****             }
2378:../uvc.c      **** #endif
2379:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2380:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2381:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2382:../uvc.c      ****             {
2383:../uvc.c      ****             	if(0&&(prinflag == 0)){
2384:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2385:../uvc.c      ****             		prinflag = 1;
2386:../uvc.c      ****             	}
2387:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2388:../uvc.c      ****             	fb=0;
2389:../uvc.c      ****             	pb=0;
2390:../uvc.c      ****             	pbc=0;
2391:../uvc.c      ****                 prodCount = 0;
2392:../uvc.c      ****                 consCount = 0;
2393:../uvc.c      ****                 hitFV     = CyFalse;
2394:../uvc.c      **** 
2395:../uvc.c      **** #ifdef BACKFLOW_DETECT
2396:../uvc.c      ****                 back_flow_detected = 0;
2397:../uvc.c      **** #endif
2398:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2399:../uvc.c      ****                 frameCnt++;
2400:../uvc.c      **** #endif
2401:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2402:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2403:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2404:../uvc.c      ****                 //}
2405:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2406:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2407:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2408:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2409:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2410:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2411:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2412:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2413:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2414:../uvc.c      ****                 		stiflag = 0xFF;
2415:../uvc.c      ****                 		IMcount = 0;
2416:../uvc.c      ****                 	}
2417:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2418:../uvc.c      **** 
2419:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2420:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2421:../uvc.c      ****                 		stiflag = 0x0F;
2422:../uvc.c      ****                 		IMcount = 0;
2423:../uvc.c      ****                 		}
2424:../uvc.c      ****                  		/*if(IMcount > 0x4){
2425:../uvc.c      ****                 			stiflag = 0x0F;
2426:../uvc.c      ****                 			IMcount = 0;
2427:../uvc.c      ****                 		}*/
2428:../uvc.c      **** 
2429:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2430:../uvc.c      ****                     //CyU3PThreadSleep(400);
2431:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2432:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2433:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2434:../uvc.c      **** 
2435:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2436:../uvc.c      ****                 	{
2437:../uvc.c      ****                     switch (setRes)
2438:../uvc.c      ****                      {
2439:../uvc.c      ****                  	case 1: //1944
2440:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2441:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2442:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x64:0xE
2443:../uvc.c      ****                  		break;
2444:../uvc.c      ****                  	case 2: //1080
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2446:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2447:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x54:0xD
2448:../uvc.c      ****                  		break;
2449:../uvc.c      ****                  	case 3: //720
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2451:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2452:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 0x45:0
2453:../uvc.c      ****                  		break;
2454:../uvc.c      ****                  	default:
2455:../uvc.c      ****                  		break;
2456:../uvc.c      ****                      }
2457:../uvc.c      ****                     IMcount = 0;
2458:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2459:../uvc.c      ****                 	stiflag = 0x0;
2460:../uvc.c      ****                 	}
2461:../uvc.c      ****                 }
2462:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2463:../uvc.c      ****                 /* Reset the DMA channel. */
2464:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2465:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2466:../uvc.c      ****                 {
2467:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2468:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2469:../uvc.c      ****                 }
2470:../uvc.c      **** 
2471:../uvc.c      ****                 /* Start Channel Immediately */
2472:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2473:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2474:../uvc.c      ****                 {
2475:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2476:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2477:../uvc.c      ****                 }
2478:../uvc.c      **** 
2479:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2480:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2481:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2482:../uvc.c      ****                 }
2483:../uvc.c      ****         }
2484:../uvc.c      ****         else
2485:../uvc.c      ****         {
2486:../uvc.c      ****             /* If we have a stream abort request pending. */
2487:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2488:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2489:../uvc.c      ****             {
2490:../uvc.c      ****                 hitFV     = CyFalse;
2491:../uvc.c      ****                 prodCount = 0;
2492:../uvc.c      ****                 consCount = 0;
2493:../uvc.c      ****                 if(0&&(prinflag == 0)){
2494:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2495:../uvc.c      ****                 	prinflag = 1;
2496:../uvc.c      ****                 }
2497:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2498:../uvc.c      ****                 fb=0;
2499:../uvc.c      ****                 pb=0;
2500:../uvc.c      ****                 pbc=0;
2501:../uvc.c      **** 
2502:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2503:../uvc.c      ****                 {
2504:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2505:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2506:../uvc.c      ****                     {
2507:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2508:../uvc.c      ****                     }
2509:../uvc.c      **** 
2510:../uvc.c      ****                     /* Flush the Endpoint memory */
2511:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2512:../uvc.c      ****                 }
2513:../uvc.c      **** 
2514:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2515:../uvc.c      ****             }
2516:../uvc.c      ****             else
2517:../uvc.c      ****             {
2518:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2519:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2520:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2521:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2522:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2523:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2524:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2525:../uvc.c      ****                 {
2526:../uvc.c      ****                     /* Error handling */
2527:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2528:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2529:../uvc.c      ****                 }
2530:../uvc.c      **** 
2531:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2532:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2533:../uvc.c      ****                 {
2534:../uvc.c      **** #if 0
2535:../uvc.c      ****                 	//for start up of the AF Lens
2536:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2537:../uvc.c      ****                     CyU3PThreadSleep(500);
2538:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2539:../uvc.c      ****                     CyU3PThreadSleep(500);
2540:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2541:../uvc.c      ****                    	CyU3PThreadSleep(300);
2542:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2543:../uvc.c      ****                     CyU3PThreadSleep(500);
2544:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2545:../uvc.c      ****                     CyU3PThreadSleep(500);
2546:../uvc.c      **** #endif
2547:../uvc.c      **** #if 0
2548:../uvc.c      ****                     switch (setRes)
2549:../uvc.c      ****                     {
2550:../uvc.c      ****                     	case 1: //1944
2551:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2552:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2553:../uvc.c      ****                     		break;
2554:../uvc.c      ****                     	case 2: //1080
2555:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2556:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2557:../uvc.c      ****                     		break;
2558:../uvc.c      ****                     	case 3: //720
2559:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2560:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2561:../uvc.c      ****                     		break;
2562:../uvc.c      ****                     	default:
2563:../uvc.c      ****                     		break;
2564:../uvc.c      ****                     }
2565:../uvc.c      **** #endif
2566:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2567:../uvc.c      **** 
2568:../uvc.c      ****                     gpif_initialized = CyTrue;
2569:../uvc.c      ****                     CyU3PThreadSleep(200);
2570:../uvc.c      ****                     
2571:../uvc.c      ****                 }
2572:../uvc.c      ****                 else
2573:../uvc.c      ****                 {
2574:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2575:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2576:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2577:../uvc.c      ****                 }
2578:../uvc.c      ****             }
2579:../uvc.c      ****         }
2580:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2581:../uvc.c      **** 
2582:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2583:../uvc.c      ****         CyU3PThreadRelinquish ();
2584:../uvc.c      ****     }
2585:../uvc.c      **** }
2586:../uvc.c      **** 
2587:../uvc.c      **** /*
2588:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2589:../uvc.c      ****  */
2590:../uvc.c      **** 
2591:../uvc.c      **** static void
2592:../uvc.c      **** UVCHandleProcessingUnitRqts (
2593:../uvc.c      ****         void)
2594:../uvc.c      **** {
2595:../uvc.c      ****     uint8_t CtrlAdd;
2596:../uvc.c      **** #ifdef DbgInfo
2597:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2598:../uvc.c      **** #endif
2599:../uvc.c      ****     switch (wValue)
2600:../uvc.c      ****     {
2601:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2602:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2603:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2604:../uvc.c      ****     		break;
2605:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2606:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2607:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2608:../uvc.c      ****     		break;
2609:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2610:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2611:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2612:../uvc.c      **** 			break;
2613:../uvc.c      **** 
2614:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2615:../uvc.c      **** 
2616:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2617:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2618:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2619:../uvc.c      ****       		break;
2620:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2621:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2622:../uvc.c      ****      		ControlHandle(HueCtlID5);
2623:../uvc.c      ****      		break;
2624:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2625:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2626:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2627:../uvc.c      ****           		break;
2628:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2629:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2630:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2631:../uvc.c      ****           		break;
2632:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2633:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2634:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2635:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2636:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2637:../uvc.c      ****     		break;
2638:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2639:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2640:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2641:../uvc.c      ****     		break;
2642:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2643:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2644:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2645:../uvc.c      ****     		break;
2646:../uvc.c      **** 
2647:../uvc.c      ****         default:
2648:../uvc.c      ****             /*
2649:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2650:../uvc.c      ****              * other controls.
2651:../uvc.c      ****              */
2652:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2653:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2654:../uvc.c      ****             break;
2655:../uvc.c      ****     }
2656:../uvc.c      **** }
2657:../uvc.c      **** 
2658:../uvc.c      **** /*
2659:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2660:../uvc.c      ****  */
2661:../uvc.c      **** static void
2662:../uvc.c      **** UVCHandleCameraTerminalRqts (
2663:../uvc.c      ****         void)
2664:../uvc.c      **** {
2665:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2666:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2667:../uvc.c      ****     uint16_t readCount;
2668:../uvc.c      ****     uint16_t zoomVal;
2669:../uvc.c      ****     int32_t  panVal, tiltVal;
2670:../uvc.c      ****     CyBool_t sendData = CyFalse;
2671:../uvc.c      **** #endif
2672:../uvc.c      ****     uint8_t CtrlAdd;
2673:../uvc.c      **** 
2674:../uvc.c      ****     switch (wValue)
2675:../uvc.c      ****     {
2676:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2677:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2678:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2679:../uvc.c      ****     		break;
2680:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2681:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2682:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2683:../uvc.c      ****     		break;
2684:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2685:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2686:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2687:../uvc.c      **** 			break;
2688:../uvc.c      **** 
2689:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2690:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2691:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2692:../uvc.c      **** 			break;
2693:../uvc.c      **** 
2694:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2695:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2696:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2697:../uvc.c      ****       		break;
2698:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2699:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2700:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2701:../uvc.c      ****      		break;
2702:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2703:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2704:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2705:../uvc.c      ****           		break;
2706:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2707:../uvc.c      ****           		break;
2708:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2709:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2710:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2711:../uvc.c      ****      		break;
2712:../uvc.c      **** 
2713:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2714:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2715:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2716:../uvc.c      ****     		break;
2717:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2718:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2719:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2720:../uvc.c      ****     		break;
2721:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2722:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2723:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2724:../uvc.c      ****     		break;
2725:../uvc.c      **** 
2726:../uvc.c      ****         default:
2727:../uvc.c      ****             /*
2728:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2729:../uvc.c      ****              * other controls.
2730:../uvc.c      ****              */
2731:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2732:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2733:../uvc.c      ****             break;
2734:../uvc.c      ****     }
2735:../uvc.c      **** 
2736:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2737:../uvc.c      ****     switch (wValue)
2738:../uvc.c      ****     {
2739:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2740:../uvc.c      ****             switch (bRequest)
2741:../uvc.c      ****             {
2742:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2743:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2744:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2745:../uvc.c      ****                     break;
2746:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2747:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2748:../uvc.c      ****                     sendData = CyTrue;
2749:../uvc.c      ****                     break;
2750:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2751:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2752:../uvc.c      ****                     sendData = CyTrue;
2753:../uvc.c      ****                     break;
2754:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2755:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2756:../uvc.c      ****                     sendData = CyTrue;
2757:../uvc.c      ****                     break;
2758:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2759:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2760:../uvc.c      ****                     sendData = CyTrue;
2761:../uvc.c      ****                     break;
2762:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2763:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2764:../uvc.c      ****                     sendData = CyTrue;
2765:../uvc.c      ****                     break;
2766:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2767:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2768:../uvc.c      ****                             glEp0Buffer, &readCount);
2769:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2770:../uvc.c      ****                     {
2771:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2772:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2773:../uvc.c      ****                     }
2774:../uvc.c      ****                     break;
2775:../uvc.c      ****                 default:
2776:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2777:../uvc.c      ****                     break;
2778:../uvc.c      ****             }
2779:../uvc.c      **** 
2780:../uvc.c      ****             if (sendData)
2781:../uvc.c      ****             {
2782:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2783:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2784:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2785:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2786:../uvc.c      ****             }
2787:../uvc.c      ****             break;
2788:../uvc.c      **** 
2789:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2790:../uvc.c      ****             switch (bRequest)
2791:../uvc.c      ****             {
2792:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2793:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2794:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2795:../uvc.c      ****                     break;
2796:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2797:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2798:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2799:../uvc.c      ****                     sendData = CyTrue;
2800:../uvc.c      ****                     break;
2801:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2802:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2803:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2804:../uvc.c      ****                     sendData = CyTrue;
2805:../uvc.c      ****                     break;
2806:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2807:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2808:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2809:../uvc.c      ****                     sendData = CyTrue;
2810:../uvc.c      ****                     break;
2811:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2812:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2813:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2814:../uvc.c      ****                     sendData = CyTrue;
2815:../uvc.c      ****                     break;
2816:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2817:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2818:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2819:../uvc.c      ****                     sendData = CyTrue;
2820:../uvc.c      ****                     break;
2821:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2822:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2823:../uvc.c      ****                             glEp0Buffer, &readCount);
2824:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2825:../uvc.c      ****                     {
2826:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2827:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2828:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2829:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2830:../uvc.c      **** 
2831:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2832:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2833:../uvc.c      ****                     }
2834:../uvc.c      ****                     break;
2835:../uvc.c      ****                 default:
2836:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2837:../uvc.c      ****                     break;
2838:../uvc.c      ****             }
2839:../uvc.c      **** 
2840:../uvc.c      ****             if (sendData)
2841:../uvc.c      ****             {
2842:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2843:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2844:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2845:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2846:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2847:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2848:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2849:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2850:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2851:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2852:../uvc.c      ****             }
2853:../uvc.c      ****             break;
2854:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2855:../uvc.c      ****         default:
2856:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2857:../uvc.c      ****             break;
2858:../uvc.c      ****     }
2859:../uvc.c      **** #endif
2860:../uvc.c      **** }
2861:../uvc.c      **** 
2862:../uvc.c      **** /*
2863:../uvc.c      ****  * Handler for UVC Interface control requests.
2864:../uvc.c      ****  */
2865:../uvc.c      **** static void
2866:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2867:../uvc.c      ****         void)
2868:../uvc.c      **** {
2869:../uvc.c      **** 
2870:../uvc.c      ****     switch (wValue)
2871:../uvc.c      ****     {
2872:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2873:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2874:../uvc.c      ****     		break;
2875:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2876:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2877:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2878:../uvc.c      ****     		break;
2879:../uvc.c      ****     	default:
2880:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2881:../uvc.c      ****      		break;
2882:../uvc.c      ****     }
2883:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2884:../uvc.c      **** 
2885:../uvc.c      **** }
2886:../uvc.c      **** 
2887:../uvc.c      **** /*
2888:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2889:../uvc.c      ****  */
2890:../uvc.c      **** static void
2891:../uvc.c      **** UVCHandleExtensionUnitRqts (
2892:../uvc.c      ****         void)
2893:../uvc.c      **** {
2894:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2895:../uvc.c      **** 
2896:../uvc.c      **** #ifdef DbgInfo
2897:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2898:../uvc.c      **** #endif
2899:../uvc.c      ****     switch (wValue)
2900:../uvc.c      ****     {
2901:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2902:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2903:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2904:../uvc.c      ****     		break;
2905:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2906:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2907:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2908:../uvc.c      ****     		break;
2909:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2910:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2911:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2912:../uvc.c      ****      		break;
2913:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2914:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2915:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2916:../uvc.c      ****     		break;
2917:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2918:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2919:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2920:../uvc.c      ****     		break;
2921:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2922:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2923:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2924:../uvc.c      ****      		break;
2925:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2926:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2927:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2928:../uvc.c      ****     		break;
2929:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2930:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2931:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2932:../uvc.c      ****     		break;
2933:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2934:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2935:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2936:../uvc.c      ****      		break;
2937:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2938:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2939:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2940:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2941:../uvc.c      ****     		}else/* no support for 1080p camera */
2942:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2943:../uvc.c      ****     		break;
2944:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2945:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2946:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2947:../uvc.c      ****     		break;
2948:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2949:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2950:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2951:../uvc.c      ****     		break;
2952:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2953:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2954:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2955:../uvc.c      ****     		//break;
2956:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2957:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2958:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2959:../uvc.c      ****     		break;
2960:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2961:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2962:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2963:../uvc.c      ****     		break;
2964:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2965:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2966:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2967:../uvc.c      ****     		break;
2968:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2969:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2970:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2971:../uvc.c      ****     		break;
2972:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2973:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2974:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2975:../uvc.c      ****     		break;
2976:../uvc.c      ****    	default:
2977:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2978:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2979:../uvc.c      ****     		break;
2980:../uvc.c      ****     }
2981:../uvc.c      **** 
2982:../uvc.c      **** }
2983:../uvc.c      **** 
2984:../uvc.c      **** /*
2985:../uvc.c      ****  * Handler for the video streaming control requests.
2986:../uvc.c      ****  */
2987:../uvc.c      **** static void
2988:../uvc.c      **** UVCHandleVideoStreamingRqts (
2989:../uvc.c      ****         void)
2990:../uvc.c      **** {
2991:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2992:../uvc.c      ****     uint16_t readCount;
2993:../uvc.c      **** 
2994:../uvc.c      ****     switch (wValue)
2995:../uvc.c      ****     {
2996:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2997:../uvc.c      ****             switch (bRequest)
2998:../uvc.c      ****             {
2999:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3000:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3001:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3002:../uvc.c      ****                     break;
3003:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3004:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3005:../uvc.c      ****                     glEp0Buffer[1] = 0;
3006:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3007:../uvc.c      ****                     break;
3008:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3009:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3010:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3011:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3012:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3013:../uvc.c      ****                     {
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3015:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3016:../uvc.c      **** 
3017:../uvc.c      ****                     }
3018:../uvc.c      ****                     else
3019:../uvc.c      ****                     {
3020:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3021:../uvc.c      ****                     }
3022:../uvc.c      ****                     break;
3023:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3024:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3025:../uvc.c      ****                             glCommitCtrl, &readCount);
3026:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3027:../uvc.c      ****                     {
3028:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3029:../uvc.c      ****                         {
3030:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3031:../uvc.c      ****                                active data structure. */
3032:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3033:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3034:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3035:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3036:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3037:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3038:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3039:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3040:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3041:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3042:../uvc.c      **** #if 0
3043:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3044:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3045:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3046:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3047:../uvc.c      **** #endif
3048:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3049:../uvc.c      ****                        }
3050:../uvc.c      ****                     }
3051:../uvc.c      ****                     break;
3052:../uvc.c      ****                 default:
3053:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3054:../uvc.c      ****                     break;
3055:../uvc.c      ****             }
3056:../uvc.c      ****             break;
3057:../uvc.c      **** 
3058:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3059:../uvc.c      ****             switch (bRequest)
3060:../uvc.c      ****             {
3061:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3062:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3063:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3064:../uvc.c      ****                     break;
3065:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3066:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3067:../uvc.c      ****                     glEp0Buffer[1] = 0;
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3069:../uvc.c      ****                     break;
3070:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3071:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3072:../uvc.c      ****                     {
3073:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3074:../uvc.c      ****                     }
3075:../uvc.c      ****                     else
3076:../uvc.c      ****                     {
3077:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3078:../uvc.c      ****                     }
3079:../uvc.c      ****                     break;
3080:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3081:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3082:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3083:../uvc.c      ****                        */
3084:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3085:../uvc.c      ****                             glCommitCtrl, &readCount);
3086:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3087:../uvc.c      ****                     {
3088:../uvc.c      ****                         switch (glCommitCtrl[3])
3089:../uvc.c      ****                          {
3090:../uvc.c      ****                          	case 1: //1944
3091:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3092:../uvc.c      ****                          		CyU3PThreadSleep(500);
3093:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3094:../uvc.c      ****                          		break;
3095:../uvc.c      ****                          	case 2: //1080
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
3098:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3099:../uvc.c      ****                          		break;
3100:../uvc.c      ****                          	case 3: //720
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
3103:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz
3104:../uvc.c      ****                          		break;
3105:../uvc.c      ****                          	default:
3106:../uvc.c      ****                          		break;
3107:../uvc.c      ****                          }
3108:../uvc.c      ****                         setRes = glCommitCtrl[3];
3109:../uvc.c      **** #if 0
3110:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3111:../uvc.c      ****                         {
3112:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3113:../uvc.c      ****                         }
3114:../uvc.c      ****                         else
3115:../uvc.c      ****                         {
3116:../uvc.c      ****                             SensorScaling_VGA ();
3117:../uvc.c      ****                         }
3118:../uvc.c      **** #endif
3119:../uvc.c      ****                         /* We can start streaming video now. */
3120:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3121:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3122:../uvc.c      ****                         {
3123:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3124:../uvc.c      ****                         }
3125:../uvc.c      ****                     }
3126:../uvc.c      ****                     break;
3127:../uvc.c      **** 
3128:../uvc.c      ****                 default:
3129:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3130:../uvc.c      ****                     break;
3131:../uvc.c      ****             }
3132:../uvc.c      ****             break;
3133:../uvc.c      **** 
3134:../uvc.c      **** /* still image streaming handler */
3135:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3136:../uvc.c      ****                 switch (bRequest)
3137:../uvc.c      ****                 {
3138:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3139:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3140:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3141:../uvc.c      ****                         break;
3142:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3143:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3144:../uvc.c      ****                         glEp0Buffer[1] = 0;
3145:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3146:../uvc.c      ****                         break;
3147:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3148:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3149:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3150:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3151:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3152:../uvc.c      ****                         {
3153:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3154:../uvc.c      ****                         }
3155:../uvc.c      ****                         else
3156:../uvc.c      ****                         {
3157:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3158:../uvc.c      ****                         }
3159:../uvc.c      ****                         break;
3160:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3161:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3162:../uvc.c      ****                                 glCommitCtrl, &readCount);
3163:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3164:../uvc.c      ****                         {
3165:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3166:../uvc.c      ****                             {
3167:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3168:../uvc.c      ****                                    active data structure. */
3169:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3170:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3171:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3172:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3173:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3174:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3175:../uvc.c      ****                             }
3176:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3177:../uvc.c      ****                         }
3178:../uvc.c      ****                         break;
3179:../uvc.c      ****                     default:
3180:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3181:../uvc.c      ****                         break;
3182:../uvc.c      ****                 }
3183:../uvc.c      ****                 break;
3184:../uvc.c      **** 
3185:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3186:../uvc.c      ****                 switch (bRequest)
3187:../uvc.c      ****                 {
3188:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3189:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3190:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3191:../uvc.c      ****                         break;
3192:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3193:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3194:../uvc.c      ****                         glEp0Buffer[1] = 0;
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3196:../uvc.c      ****                         break;
3197:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3198:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3199:../uvc.c      ****                         {
3200:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3201:../uvc.c      ****                         }
3202:../uvc.c      ****                         else
3203:../uvc.c      ****                         {
3204:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3205:../uvc.c      ****                         }
3206:../uvc.c      ****                         break;
3207:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3208:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3209:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3210:../uvc.c      ****                            */
3211:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3212:../uvc.c      ****                                 glCommitCtrl, &readCount);
3213:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3214:../uvc.c      ****                         {
3215:../uvc.c      **** 	#if 0
3216:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3217:../uvc.c      ****                             {
3218:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3219:../uvc.c      ****                             }
3220:../uvc.c      ****                             else
3221:../uvc.c      ****                             {
3222:../uvc.c      ****                                 SensorScaling_VGA ();
3223:../uvc.c      ****                             }
3224:../uvc.c      ****                             /* We can start streaming video now. */
3225:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3226:../uvc.c      **** 
3227:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3228:../uvc.c      ****                             {
3229:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3230:../uvc.c      ****                             }
3231:../uvc.c      **** 	#endif
3232:../uvc.c      ****                            switch (glCommitCtrl[1])
3233:../uvc.c      ****                              {
3234:../uvc.c      ****                              	case 3: //1944
3235:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3236:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3237:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3238:../uvc.c      ****                              		break;
3239:../uvc.c      ****                              	case 2: //1080
3240:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3241:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3242:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3243:../uvc.c      ****                              		break;
3244:../uvc.c      ****                              	case 1: //720
3245:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3246:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3247:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is
3248:../uvc.c      ****                              		break;
3249:../uvc.c      ****                              	default:
3250:../uvc.c      ****                              		break;
3251:../uvc.c      ****                              }
3252:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3253:../uvc.c      **** 
3254:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3255:../uvc.c      **** 
3256:../uvc.c      ****                         }
3257:../uvc.c      ****                         break;
3258:../uvc.c      **** 
3259:../uvc.c      ****                     default:
3260:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3261:../uvc.c      ****                         break;
3262:../uvc.c      ****                 }
3263:../uvc.c      ****                 break;
3264:../uvc.c      **** 
3265:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3266:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3267:../uvc.c      ****             	switch (bRequest)
3268:../uvc.c      ****                 {
3269:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3270:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3271:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3272:../uvc.c      ****                         break;
3273:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3274:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3275:../uvc.c      ****                         glEp0Buffer[1] = 0;
3276:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3277:../uvc.c      ****                         break;
3278:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3279:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3280:../uvc.c      ****                         {
3281:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3282:../uvc.c      ****                         }
3283:../uvc.c      ****                         else
3284:../uvc.c      ****                         {
3285:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3286:../uvc.c      ****                         }
3287:../uvc.c      ****                         break;
3288:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3289:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3290:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3291:../uvc.c      ****                            */
3292:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3293:../uvc.c      ****                                 glCommitCtrl, &readCount);
3294:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3295:../uvc.c      ****                         {
3296:../uvc.c      ****     #if 1
3297:../uvc.c      ****                             /* We can start still streaming video now. */
3298:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3299:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3300:../uvc.c      ****                             {
3301:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3302:../uvc.c      ****                             }
3303:../uvc.c      ****     #endif
3304:../uvc.c      ****                             else{
3305:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3306:../uvc.c      ****                             //stillcont = 0;
3307:../uvc.c      ****                             }
3308:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3309:../uvc.c      ****                         }else{
3310:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3311:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3312:../uvc.c      ****                         }
3313:../uvc.c      ****                         break;
3314:../uvc.c      **** 
3315:../uvc.c      ****                     default:
3316:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3317:../uvc.c      ****                         break;
3318:../uvc.c      ****                 }
3319:../uvc.c      ****                 break;
3320:../uvc.c      **** 
3321:../uvc.c      ****         default:
3322:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3323:../uvc.c      ****             break;
3324:../uvc.c      ****     }
3325:../uvc.c      **** }
3326:../uvc.c      **** 
3327:../uvc.c      **** /*
3328:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3329:../uvc.c      ****  */
3330:../uvc.c      **** void
3331:../uvc.c      **** UVCAppEP0Thread_Entry (
3332:../uvc.c      ****         uint32_t input)
3333:../uvc.c      **** {
3334:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3335:../uvc.c      ****     uint32_t eventFlag;
3336:../uvc.c      **** 	CyBool_t value;
3337:../uvc.c      **** 	CyBool_t *valueptr = &value;
3338:../uvc.c      **** 
3339:../uvc.c      **** 
3340:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3341:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3342:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3343:../uvc.c      **** 
3344:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3345:../uvc.c      **** #endif
3346:../uvc.c      **** 
3347:../uvc.c      ****     /* for interrupt status test */
3348:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3349:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3350:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3351:../uvc.c      **** 
3352:../uvc.c      ****     for (;;)
3353:../uvc.c      ****     {
3354:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3355:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3356:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3357:../uvc.c      ****         {
3358:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3359:../uvc.c      ****             if (!isUsbConnected)
3360:../uvc.c      ****             {
3361:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3362:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3363:../uvc.c      ****                 {
3364:../uvc.c      ****                     isUsbConnected = CyTrue;
3365:../uvc.c      ****                 }
3366:../uvc.c      ****             }
3367:../uvc.c      **** //#ifdef DbgInfo
3368:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3369:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3370:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3371:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3372:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3373:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3374:../uvc.c      **** //#endif
3375:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3376:../uvc.c      ****             {
3377:../uvc.c      ****             	switch ((wIndex >> 8))
3378:../uvc.c      ****                 {
3379:../uvc.c      **** 
3380:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3381:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3382:../uvc.c      ****                         break;
3383:../uvc.c      **** 
3384:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3385:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3386:../uvc.c      ****                         break;
3387:../uvc.c      **** 
3388:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3389:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3390:../uvc.c      ****                         break;
3391:../uvc.c      **** 
3392:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3393:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3394:../uvc.c      ****                         break;
3395:../uvc.c      **** 
3396:../uvc.c      ****                     default:
3397:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3398:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3399:../uvc.c      ****                         break;
3400:../uvc.c      ****                 }
3401:../uvc.c      ****             }
3402:../uvc.c      **** 
3403:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3404:../uvc.c      ****             {
3405:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3406:../uvc.c      **** 
3407:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3408:../uvc.c      ****                 {
3409:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3410:../uvc.c      ****                 }
3411:../uvc.c      ****                 else
3412:../uvc.c      ****                 {
3413:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3414:../uvc.c      ****                 }
3415:../uvc.c      ****             }
3416:../uvc.c      **** 
3417:../uvc.c      ****             /* handle interrupt status event */
3418:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3419:../uvc.c      ****             {
3420:../uvc.c      **** 
3421:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3422:../uvc.c      ****             	/** preparing interrupt status data **/
3423:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3424:../uvc.c      **** 
3425:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3426:../uvc.c      **** 
3427:../uvc.c      **** #if 0 //for real button
3428:../uvc.c      **** 				if(value&&(!snapButFlag)){
3429:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3430:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3431:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3432:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3433:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3434:../uvc.c      **** 
3435:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3436:../uvc.c      **** 					interStabuf.size   = 1024;
3437:../uvc.c      **** 					interStabuf.status = 0;
3438:../uvc.c      **** 
3439:../uvc.c      **** 					interStabuf.count = 4;
3440:../uvc.c      **** 
3441:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3442:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3443:../uvc.c      **** 
3444:../uvc.c      **** 					/** send a interrupt status data **/
3445:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3446:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3447:../uvc.c      **** 					{
3448:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3449:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3450:../uvc.c      **** 					}
3451:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3452:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3453:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3454:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3455:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3456:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3457:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3458:../uvc.c      **** 
3459:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3460:../uvc.c      **** 					interStabuf.size   = 1024;
3461:../uvc.c      **** 					interStabuf.status = 0;
3462:../uvc.c      **** 
3463:../uvc.c      **** 					interStabuf.count = 4;
3464:../uvc.c      **** 
3465:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3466:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3467:../uvc.c      **** 
3468:../uvc.c      **** 					/** send a interrupt status data **/
3469:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3470:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3471:../uvc.c      **** 					{
3472:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3473:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3474:../uvc.c      **** 					}
3475:../uvc.c      **** 
3476:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3477:../uvc.c      **** 					stiflag = 0xFF;
3478:../uvc.c      **** 				}
3479:../uvc.c      **** #else			//for botton simulation
3480:../uvc.c      **** 				if(snapButFlag == 0x0f){
3481:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3482:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3483:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3484:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3485:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3486:../uvc.c      **** 
3487:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3488:../uvc.c      **** 					interStabuf.size   = 1024;
3489:../uvc.c      **** 					interStabuf.status = 0;
3490:../uvc.c      **** 
3491:../uvc.c      **** 					interStabuf.count = 4;
3492:../uvc.c      **** 
3493:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3494:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3495:../uvc.c      **** 
3496:../uvc.c      **** 					/** send a interrupt status data **/
3497:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3498:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3499:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3500:../uvc.c      **** 					{
3501:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3502:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3503:../uvc.c      **** 					}
3504:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3505:../uvc.c      **** 
3506:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3507:../uvc.c      **** 				}else if(!snapButFlag){
3508:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3509:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3510:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3511:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3512:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3513:../uvc.c      **** 
3514:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3515:../uvc.c      **** 					interStabuf.size   = 1024;
3516:../uvc.c      **** 					interStabuf.status = 0;
3517:../uvc.c      **** 
3518:../uvc.c      **** 					interStabuf.count = 4;
3519:../uvc.c      **** 
3520:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3521:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3522:../uvc.c      **** 
3523:../uvc.c      **** 					/** send a interrupt status data **/
3524:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3525:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3526:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3527:../uvc.c      **** 					{
3528:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3529:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3530:../uvc.c      **** 					}
3531:../uvc.c      **** 
3532:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3533:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3534:../uvc.c      **** 				}
3535:../uvc.c      **** #endif
3536:../uvc.c      **** 
3537:../uvc.c      ****             }
3538:../uvc.c      **** 
3539:../uvc.c      **** 
3540:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3541:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3542:../uvc.c      ****             {
3543:../uvc.c      ****                 /* Get the command buffer */
3544:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3545:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3546:../uvc.c      ****                 {
3547:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3548:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3549:../uvc.c      ****                 }
3550:../uvc.c      **** 
3551:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3552:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3553:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3554:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3555:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3556:../uvc.c      ****                  * register value high byte and register value low byte.
3557:../uvc.c      ****                  */
3558:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3559:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3560:../uvc.c      ****                 {
3561:../uvc.c      ****                     if (dmaInfo.count == 3)
3562:../uvc.c      ****                     {
3563:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3564:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3565:../uvc.c      ****                         dmaInfo.count = 3;
3566:../uvc.c      ****                     }
3567:../uvc.c      ****                     else if (dmaInfo.count == 4)
3568:../uvc.c      ****                     {
3569:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3570:../uvc.c      ****                         {
3571:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3572:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3573:../uvc.c      ****                         }
3574:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3575:../uvc.c      ****                     }
3576:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3577:../uvc.c      ****                 }
3578:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3579:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3580:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3581:../uvc.c      ****                  */
3582:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3583:../uvc.c      ****                 {
3584:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3585:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3586:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3587:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3588:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3589:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3590:../uvc.c      ****                         	break;
3591:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3592:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3593:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3594:../uvc.c      ****                         	break;*/
3595:../uvc.c      ****                     dmaInfo.count -= 2;
3596:../uvc.c      ****                 }
3597:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3598:../uvc.c      ****                 else
3599:../uvc.c      ****                 {
3600:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3601:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3602:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3603:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3604:../uvc.c      ****                 }
3605:../uvc.c      **** 
3606:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3607:../uvc.c      ****                 dmaInfo.size   = 1024;
3608:../uvc.c      ****                 dmaInfo.status = 0;
3609:../uvc.c      **** 
3610:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3611:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3612:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3613:../uvc.c      ****                 {
3614:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3615:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3616:../uvc.c      ****                 }
3617:../uvc.c      **** 
3618:../uvc.c      ****                 /* Wait until the response has gone out. */
3619:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3620:../uvc.c      **** 
3621:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3622:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3623:../uvc.c      ****                 {
3624:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3625:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3626:../uvc.c      ****                 }
3627:../uvc.c      ****             }
3628:../uvc.c      **** #endif
3629:../uvc.c      ****         }
3630:../uvc.c      ****         /* Allow other ready threads to run. */
3631:../uvc.c      ****         CyU3PThreadRelinquish ();
3632:../uvc.c      ****     }
3633:../uvc.c      **** }
3634:../uvc.c      **** 
3635:../uvc.c      **** /*
3636:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3637:../uvc.c      ****  * added 10/2013
3638:../uvc.c      ****  */
3639:../uvc.c      **** /*
3640:../uvc.c      **** static uint8_t timeDelay[64] = {
3641:../uvc.c      **** 
3642:../uvc.c      **** };
3643:../uvc.c      **** */
3644:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3644 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3645:../uvc.c      **** 
3646:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3647:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3648:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3649:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3650:../uvc.c      **** 	VdstateDes *lcStaDes;
3651:../uvc.c      **** 	uint32_t flag = 0;
3652:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3653:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3654:../uvc.c      **** 	uint8_t i;
3655:../uvc.c      **** 	uint16_t delaytime;
3656:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3657:../uvc.c      **** 
3658:../uvc.c      **** #if 0 //for test the command queue
3659:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3660:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3661:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3662:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3663:../uvc.c      **** 		lcCmdDes += 1;
3664:../uvc.c      **** 	}
3665:../uvc.c      **** #endif
3666:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3667:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3667 0
  36 0004 10229FE5 		ldr	r2, .L22
3651:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3651 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3644:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3644 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3667 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3651:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3651 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3667 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3668:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3668 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3669:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3669 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3670:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3670 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3671:../uvc.c      **** 
3672:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3672 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3673:../uvc.c      ****         /* Allow other ready threads to run. */
3674:../uvc.c      **** 
3675:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3675 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3672:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3672 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3676:../uvc.c      **** 	}
3677:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3677 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3678:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3679:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3680:../uvc.c      **** 	//CyU3PThreadSleep(100);
3681:../uvc.c      **** 	//SetCurCmd();
3682:../uvc.c      **** 	/*********** the loop of the thread ***********/
3683:../uvc.c      **** 	for(;;){
3684:../uvc.c      **** 
3685:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3685 0
 101 0098 0060E0E3 		mvn	r6, #0
3686:../uvc.c      **** /*  // for test GPIO output
3687:../uvc.c      **** 		if(trigger)
3688:../uvc.c      **** 		{
3689:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3690:../uvc.c      **** 			{
3691:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3692:../uvc.c      **** 			}
3693:../uvc.c      **** 
3694:../uvc.c      **** 		}else{
3695:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3696:../uvc.c      **** 			{
3697:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3698:../uvc.c      **** 			}
3699:../uvc.c      **** 
3700:../uvc.c      **** 		}
3701:../uvc.c      **** */
3702:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3703:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3704:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3705:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3706:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3707:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3708:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3709:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3710:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3711:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3712:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3713:../uvc.c      **** #endif
3714:../uvc.c      **** 				}
3715:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3716:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3717:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3718:../uvc.c      **** 			}
3719:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3720:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3721:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3722:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3723:../uvc.c      **** 
3724:../uvc.c      **** 				/*
3725:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3726:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3727:../uvc.c      **** 				*/
3728:../uvc.c      **** 
3729:../uvc.c      **** 				/* find a available command */
3730:../uvc.c      **** 				i = 0;
3731:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3731 0
 103 009c 0090A0E3 		mov	r9, #0
3732:../uvc.c      **** 					i++;
3733:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3734:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3735:../uvc.c      **** 				}
3736:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3737:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3738:../uvc.c      **** 					i = lcCmdDes->curNum;
3739:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3740:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3741:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3742:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3743:../uvc.c      **** #if 1
3744:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3745:../uvc.c      **** 						case 20:
3746:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3747:../uvc.c      **** 							delaytime = 500;
3748:../uvc.c      **** 							break;
3749:../uvc.c      **** 						case 21:
3750:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3751:../uvc.c      **** 							delaytime = 500;
3752:../uvc.c      **** 							break;
3753:../uvc.c      **** 						case 22:
3754:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3755:../uvc.c      **** 							delaytime = 300;
3756:../uvc.c      **** 							break;
3757:../uvc.c      **** 						case 23:
3758:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3759:../uvc.c      **** 							delaytime = 300;
3760:../uvc.c      **** 							break;
3761:../uvc.c      **** 						default:
3762:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3763:../uvc.c      **** 							break;
3764:../uvc.c      **** 					}
3765:../uvc.c      **** #endif
3766:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3767:../uvc.c      **** 					/** timer's ticket modify **/
3768:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3769:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3770:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3771:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3772:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3773:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3774:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3775:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3776:../uvc.c      **** #endif
3777:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3778:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3779:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3780:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3781:../uvc.c      **** 						}else{
3782:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3783:../uvc.c      **** 						}
3784:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3785:../uvc.c      **** 					}else{
3786:../uvc.c      **** 						lcCmdDes->curNum ++;
3787:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3787 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3685:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3685 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3702:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3702 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3719:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3719 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3721:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3721 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3722:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3722 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3731:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3731 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3733:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3733 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3732:../uvc.c      **** 					i++;
 140              		.loc 1 3732 0
 141 00f4 011083E2 		add	r1, r3, #1
3731:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3731 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3732:../uvc.c      **** 					i++;
 144              		.loc 1 3732 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3731:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3731 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3737:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3737 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3739:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3739 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3744:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3744 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3739:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3739 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3744:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3744 0
 166 0128 14C042E2 		sub	ip, r2, #20
3739:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3739 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3740:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3740 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3741:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3741 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3742:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3742 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3744:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3744 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3758:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3758 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3760:../uvc.c      **** 							break;
 193              		.loc 1 3760 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3769:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3769 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3770:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3770 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3777:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3777 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3786:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3786 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3787 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3777:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3777 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3788:../uvc.c      **** 					}
3789:../uvc.c      **** 				}else{
3790:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3791:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3792:../uvc.c      **** 				}
3793:../uvc.c      **** 			}
3794:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3794 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3795:../uvc.c      **** /*
3796:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3797:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3798:../uvc.c      **** */
3799:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3800:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3801:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3802:../uvc.c      **** #endif
3803:../uvc.c      **** 
3804:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3805:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3806:../uvc.c      **** #if 0
3807:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3808:../uvc.c      **** 
3809:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3810:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3811:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3812:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3813:../uvc.c      **** 			    i = 0;
3814:../uvc.c      **** 				 switch(cmdCopyIdx)
3815:../uvc.c      **** 				 {
3816:../uvc.c      **** 					 case BrgtCtlID1:
3817:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3819:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3820:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3821:../uvc.c      **** 							 i++;
3822:../uvc.c      **** 						 }
3823:../uvc.c      **** 						 else{
3824:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3825:../uvc.c      **** 						 }
3826:../uvc.c      **** 
3827:../uvc.c      **** 						 CyU3PBusyWait(500);
3828:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3829:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3830:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3831:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3832:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3833:../uvc.c      **** 						 }
3834:../uvc.c      **** 						 else{
3835:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3836:../uvc.c      **** 						 }
3837:../uvc.c      **** 						 break;
3838:../uvc.c      **** 					 case HueCtlID5:
3839:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3840:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3841:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3842:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3843:../uvc.c      **** 						 }
3844:../uvc.c      **** 						 else{
3845:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3846:../uvc.c      **** 						 }
3847:../uvc.c      **** 						 break;
3848:../uvc.c      **** 					 case SaturCtlID6:
3849:../uvc.c      **** 					 case WBTLevCtlID10:
3850:../uvc.c      **** 					 default:
3851:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3852:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3853:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3854:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3855:../uvc.c      **** 						 }
3856:../uvc.c      **** 						 else{
3857:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3858:../uvc.c      **** 						 }
3859:../uvc.c      **** 						 break;
3860:../uvc.c      **** 				 }
3861:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3862:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3863:../uvc.c      **** 			}
3864:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3865:../uvc.c      **** #endif
3866:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3867:../uvc.c      **** 		/* Allow other ready threads to run. */
3868:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3869:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3869 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3870:../uvc.c      **** 		}
 224              		.loc 1 3870 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3750:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3750 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3752:../uvc.c      **** 							break;
 232              		.loc 1 3752 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3762:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3762 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3763:../uvc.c      **** 							break;
 241              		.loc 1 3763 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3746:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3746 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3748:../uvc.c      **** 							break;
 249              		.loc 1 3748 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3790:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3790 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3791:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3791 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3779:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3779 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3778:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3778 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3779:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3779 0
 269 01f0 1F005CE3 		cmp	ip, #31
3780:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3780 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3782:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3782 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3780:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3780 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3782:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3782 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3780:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3780 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3782:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3782 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3784:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3784 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2281:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2281 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2283:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2283 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2284:../uvc.c      **** }
 318              		.loc 1 2284 0
2283:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2283 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB8:
1342:../uvc.c      **** {
 332              		.loc 1 1342 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1343:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1343 0
 338 0250 020050E3 		cmp	r0, #2
1342:../uvc.c      **** {
 339              		.loc 1 1342 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1342:../uvc.c      **** {
 347              		.loc 1 1342 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1343:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1343 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1379:../uvc.c      **** }
 361              		.loc 1 1379 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1364:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1364 0
 367 0280 28519FE5 		ldr	r5, .L34
1362:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1362 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1363:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1363 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1364:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1364 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1326 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1364:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1364 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1365:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1365 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1366:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1366 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1326 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1329 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1332:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1332 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1348:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1348 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1346:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1346 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1347:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1347 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1348:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1348 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1326 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1348:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1348 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1349:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1349 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1326 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1329 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1326 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1356:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1356 0
 462 0344 64509FE5 		ldr	r5, .L34
1354:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1354 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1355:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1355 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1356:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1356 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1326 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1356:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1356 0
 485 0374 286085E5 		str	r6, [r5, #40]
1357:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1357 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1326 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1329 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1332:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1332 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE8:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB10:
1539:../uvc.c      **** {
 523              		.loc 1 1539 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
1546:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 1546 0
 529 03c0 080051E3 		cmp	r1, #8
1539:../uvc.c      **** {
 530              		.loc 1 1539 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
1546:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 1546 0
 544 03d0 0B00000A 		beq	.L42
1598:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 1598 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
1600:../uvc.c      ****         consCount++;
 548              		.loc 1 1600 0
 549 03dc 7C319FE5 		ldr	r3, .L45
1601:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 1601 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
1600:../uvc.c      ****         consCount++;
 553              		.loc 1 1600 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
1601:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 1601 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
1600:../uvc.c      ****         consCount++;
 558              		.loc 1 1600 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
1603:../uvc.c      **** }
 565              		.loc 1 1603 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
1548:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 1548 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
1568:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 1568 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1287:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1287 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1286 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
1568:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 1568 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1286 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1287:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1287 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1288:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1288 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1293:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1293 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
1569:../uvc.c      ****                 pb++;
 607              		.loc 1 1569 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1293:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1293 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
1569:../uvc.c      ****                 pb++;
 617              		.loc 1 1569 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
1575:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 1575 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
1570:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 1570 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
1569:../uvc.c      ****                 pb++;
 623              		.loc 1 1569 0
 624 0460 013080E2 		add	r3, r0, #1
1575:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 1575 0
 626 0464 0F0052E3 		cmp	r2, #15
1569:../uvc.c      ****                 pb++;
 627              		.loc 1 1569 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1570:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 1570 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1575:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 1575 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
1582:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 1582 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
1586:../uvc.c      ****             prodCount++;
 639              		.loc 1 1586 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
1587:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 1587 0
 642 0480 0C1081E2 		add	r1, r1, #12
1586:../uvc.c      ****             prodCount++;
 643              		.loc 1 1586 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
1587:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 1587 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
1586:../uvc.c      ****             prodCount++;
 652              		.loc 1 1586 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
1587:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 1587 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
1586:../uvc.c      ****             prodCount++;
 657              		.loc 1 1586 0
 658 04a8 B0109FE5 		ldr	r1, .L45
1590:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 1590 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
1592:../uvc.c      ****                 prodCount--;
 662              		.loc 1 1592 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
1593:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 1593 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
1592:../uvc.c      ****                 prodCount--;
 667              		.loc 1 1592 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
1593:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 1593 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
1562:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 1562 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1286 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
1563:../uvc.c      ****                 fb++;
 693              		.loc 1 1563 0
 694 04f4 64409FE5 		ldr	r4, .L45
1562:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 1562 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1286 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1287:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1287 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1288:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1288 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
1563:../uvc.c      ****                 fb++;
 714              		.loc 1 1563 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
1576:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 1576 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
1577:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 1577 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1578:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 1578 0
 729 0540 24009FE5 		ldr	r0, .L45+12
1577:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 1577 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
1578:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 1578 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
1579:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 1579 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE10:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB9:
1387:../uvc.c      **** {
 757              		.loc 1 1387 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1392:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1392 0
 763 057c C0329FE5 		ldr	r3, .L72
1387:../uvc.c      **** {
 764              		.loc 1 1387 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1393:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1393 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1392:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1392 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1393:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1393 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1394:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1394 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1392:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1392 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1394:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1394 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1395:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1395 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1396:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1396 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1395:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1395 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1393:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1393 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1395:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1395 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1396:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1396 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1399:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1399 0
 801 05b4 020054E3 		cmp	r4, #2
1387:../uvc.c      **** {
 802              		.loc 1 1387 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1393:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1393 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1394:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1394 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1395:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1395 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1396:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1396 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1399:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1399 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1388:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1388 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1526:../uvc.c      **** }
 826              		.loc 1 1526 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1399:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1399 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1439:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1439 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1443:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1443 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1443:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1443 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1448:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1448 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1446:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1446 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1447:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1447 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1451 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1448:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1448 0
 856 0630 287084E5 		str	r7, [r4, #40]
1449:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1449 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1451 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1452:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1452 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1455:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1455 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1456:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1456 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1457:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1457 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1458:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1458 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1461:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1461 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1464:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1464 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1466:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1466 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1326 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1329 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1332:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1332 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1462:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1462 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1404:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1404 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1409:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1409 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1411:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1411 0
 926 06e0 002050E2 		subs	r2, r0, #0
1408:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1408 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1411:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1411 0
 931 06e8 BEFFFF0A 		beq	.L48
1413:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1413 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1414:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1414 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1408:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1408 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1474:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1474 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1476:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1476 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1482:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1482 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1514:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1514 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1513:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1513 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1404:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1404 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1422:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1422 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1424:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1424 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1462:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1462 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1427:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1427 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1428:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1428 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1421:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1421 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1484:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1484 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1488:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1488 0
 1011 0794 0080A0E3 		mov	r8, #0
1487:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1487 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1492 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1488:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1488 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1489:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1489 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1492 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1493:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1493 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1496:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1496 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1497:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1497 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1498:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1498 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1499:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1499 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1502:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1502 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1506:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1506 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1508:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1508 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1326 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1504:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1504 0
 1061 0814 0600A011 		movne	r0, r6
1326:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1326 0
 1063 0818 72FFFF1A 		bne	.L48
1329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1329 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1332:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1332 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1504:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1504 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE9:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB12:
1725:../uvc.c      **** {
 1101              		.loc 1 1725 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
1726:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 1726 0
 1107 0870 010050E3 		cmp	r0, #1
1725:../uvc.c      **** {
 1108              		.loc 1 1725 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
1725:../uvc.c      **** {
 1112              		.loc 1 1725 0
 1113 0878 0120A0E1 		mov	r2, r1
1726:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 1726 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
1623:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 1623 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
1649:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 1649 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
1651:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1651 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
1634:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 1634 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
1708:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 1708 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
1709:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 1709 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
1711:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 1711 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1313 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1314 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
1678:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 1678 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
1625:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 1625 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
1697:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 1697 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
1732:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 1732 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
1735:../uvc.c      **** }
 1214              		.loc 1 1735 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
1732:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 1732 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE12:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 337:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 337 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 340:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 340 0
 1243 0970 40429FE5 		ldr	r4, .L106
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 337:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 337 0
 1254 0974 3CD04DE2 		sub	sp, sp, #60
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 96
 345:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 345 0
 1258 0978 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 340:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 340 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 341:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 341 0
 1263 0980 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 342:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1265              		.loc 1 342 0
 1266 0984 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1267              	.LVL99:
 345:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1268              		.loc 1 345 0
 1269 0988 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1270 098c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1271 0990 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1272 0994 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1273 0998 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1274 099c 14208DE5 		str	r2, [sp, #20]
 1275 09a0 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1276 09a4 0730A0E1 		mov	r3, r7
 1277 09a8 1C108DE5 		str	r1, [sp, #28]
 1278 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1279 09b0 0400A0E3 		mov	r0, #4
 1280 09b4 00129FE5 		ldr	r1, .L106+4
 1281 09b8 0520A0E1 		mov	r2, r5
 1282 09bc 00E08DE5 		str	lr, [sp, #0]
 1283 09c0 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1284 09c4 0C908DE5 		str	r9, [sp, #12]
 1285 09c8 10B08DE5 		str	fp, [sp, #16]
 1286 09cc 18608DE5 		str	r6, [sp, #24]
 1287 09d0 20C08DE5 		str	ip, [sp, #32]
 1288 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 348:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1289              		.loc 1 348 0
 1290 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1291 09dc 520053E3 		cmp	r3, #82
 1292 09e0 2C00000A 		beq	.L102
 1293              	.L92:
 358:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1294              		.loc 1 358 0
 1295 09e4 000055E3 		cmp	r5, #0
 1296 09e8 1600000A 		beq	.L103
 383:../uvc.c      **** 	}else if(CmdType == 1){
 1297              		.loc 1 383 0
 1298 09ec 010055E3 		cmp	r5, #1
 1299 09f0 0100000A 		beq	.L104
 1300              	.LVL100:
 1301              	.L91:
 402:../uvc.c      **** }
 1302              		.loc 1 402 0
 1303 09f4 3CD08DE2 		add	sp, sp, #60
 1304 09f8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1305              	.LVL101:
 1306              	.L104:
 385:../uvc.c      **** 			if(CmdRegLen == 2){
 1307              		.loc 1 385 0
 1308 09fc 020057E3 		cmp	r7, #2
 1309 0a00 3700000A 		beq	.L105
 390:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1310              		.loc 1 390 0
 1311 0a04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1312 0a08 A8319FE5 		ldr	r3, .L106
 1313 0a0c FE1001E2 		and	r1, r1, #254
 1314 0a10 820051E3 		cmp	r1, #130
 393:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1315              		.loc 1 393 0
 1316 0a14 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1317              	.LVL102:
 390:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1318              		.loc 1 390 0
 1319 0a18 0200001A 		bne	.L101
 390:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1320              		.loc 1 390 0 is_stmt 0 discriminator 1
 1321 0a1c 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1322 0a20 300055E3 		cmp	r5, #48
 1323 0a24 4F00000A 		beq	.L99
 1324              	.L101:
 393:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1325              		.loc 1 393 0 is_stmt 1
 1326 0a28 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1327              	.L100:
 395:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1328              		.loc 1 395 0
 1329 0a2c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1330 0a30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1331 0a34 FE0002E2 		and	r0, r2, #254
 1332 0a38 0520A0E1 		mov	r2, r5
 1333 0a3c 00E08DE5 		str	lr, [sp, #0]
 1334 0a40 FEFFFFEB 		bl	SensorWrite2B
 1335 0a44 EAFFFFEA 		b	.L91
 1336              	.LVL103:
 1337              	.L103:
 374:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1338              		.loc 1 374 0
 1339 0a48 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1340 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 360:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1341              		.loc 1 360 0
 1342 0a50 0FE0A0E3 		mov	lr, #15
 374:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1343              		.loc 1 374 0
 1344 0a54 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1345 0a58 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 360:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1346              		.loc 1 360 0
 1347 0a5c 57E0C4E5 		strb	lr, [r4, #87]
 374:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1348              		.loc 1 374 0
 1349 0a60 34C08DE2 		add	ip, sp, #52
 1350 0a64 010080E3 		orr	r0, r0, #1
 1351 0a68 011081E3 		orr	r1, r1, #1
 1352 0a6c 00C08DE5 		str	ip, [sp, #0]
 1353 0a70 FEFFFFEB 		bl	SensorRead2B
 375:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1354              		.loc 1 375 0
 1355 0a74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 376:../uvc.c      **** 				if(CmdDataLen == 2){
 1356              		.loc 1 376 0
 1357 0a78 020056E3 		cmp	r6, #2
 375:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1358              		.loc 1 375 0
 1359 0a7c 5530C4E5 		strb	r3, [r4, #85]
 377:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1360              		.loc 1 377 0
 1361 0a80 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1362 0a84 2C319F05 		ldreq	r3, .L106
 379:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1363              		.loc 1 379 0
 1364 0a88 0020E0E3 		mvn	r2, #0
 1365 0a8c 5720C4E5 		strb	r2, [r4, #87]
 377:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1366              		.loc 1 377 0
 1367 0a90 5600C305 		streqb	r0, [r3, #86]
 1368 0a94 D6FFFFEA 		b	.L91
 1369              	.L102:
 348:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1370              		.loc 1 348 0 discriminator 1
 1371 0a98 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1372 0a9c 300050E3 		cmp	r0, #48
 1373 0aa0 CFFFFF1A 		bne	.L92
 1374 0aa4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1375 0aa8 010053E3 		cmp	r3, #1
 1376 0aac CCFFFF1A 		bne	.L92
 350:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1377              		.loc 1 350 0
 1378 0ab0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1379 0ab4 04C19FE5 		ldr	ip, .L106+8
 1380 0ab8 031002E2 		and	r1, r2, #3
 1381 0abc 8C14CCE5 		strb	r1, [ip, #1164]
 351:../uvc.c      **** 		if(is60Hz==CyFalse)
 1382              		.loc 1 351 0
 1383 0ac0 58E094E5 		ldr	lr, [r4, #88]
 355:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1384              		.loc 1 355 0
 1385 0ac4 F8109FE5 		ldr	r1, .L106+12
 351:../uvc.c      **** 		if(is60Hz==CyFalse)
 1386              		.loc 1 351 0
 1387 0ac8 00005EE3 		cmp	lr, #0
 353:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1388              		.loc 1 353 0
 1389 0acc 80208203 		orreq	r2, r2, #128
 1390 0ad0 5520C405 		streqb	r2, [r4, #85]
 355:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1391              		.loc 1 355 0
 1392 0ad4 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1393 0ad8 0400A0E3 		mov	r0, #4
 1394 0adc FEFFFFEB 		bl	CyU3PDebugPrint
 1395 0ae0 BFFFFFEA 		b	.L92
 1396              	.L105:
 387:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1397              		.loc 1 387 0
 1398 0ae4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1399 0ae8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1400 0aec 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1401 0af0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1402 0af4 0020A0E3 		mov	r2, #0
 1403 0af8 FE0000E2 		and	r0, r0, #254
 1404 0afc 00E08DE5 		str	lr, [sp, #0]
 1405 0b00 FEFFFFEB 		bl	SensorWrite2B2
 1406 0b04 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1407 0b08 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1408 0b0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1409 0b10 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1410 0b14 FE0002E2 		and	r0, r2, #254
 1411 0b18 0020A0E3 		mov	r2, #0
 1412 0b1c 00C08DE5 		str	ip, [sp, #0]
 1413 0b20 FEFFFFEB 		bl	SensorWrite2B2
 1414              	.LVL104:
 1415 0b24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1416 0b28 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1417 0b2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1418 0b30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1419 0b34 0020A0E3 		mov	r2, #0
 1420 0b38 FE0000E2 		and	r0, r0, #254
 1421 0b3c 00C08DE5 		str	ip, [sp, #0]
 1422 0b40 FEFFFFEB 		bl	SensorWrite2B2
 1423 0b44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1424 0b48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1425 0b4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1426 0b50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1427 0b54 FE0002E2 		and	r0, r2, #254
 1428 0b58 0020A0E3 		mov	r2, #0
 1429 0b5c 00C08DE5 		str	ip, [sp, #0]
 1430 0b60 FEFFFFEB 		bl	SensorWrite2B2
 1431 0b64 A2FFFFEA 		b	.L91
 1432              	.LVL105:
 1433              	.L99:
 390:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1434              		.loc 1 390 0 discriminator 1
 1435 0b68 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1436 0b6c 100053E3 		cmp	r3, #16
 1437 0b70 ADFFFF1A 		bne	.L100
 391:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1438              		.loc 1 391 0
 1439 0b74 4C409FE5 		ldr	r4, .L106+16
 1440 0b78 0010E0E3 		mvn	r1, #0
 1441 0b7c 1C0094E5 		ldr	r0, [r4, #28]
 1442 0b80 2C308DE5 		str	r3, [sp, #44]
 1443 0b84 FEFFFFEB 		bl	_txe_mutex_get
 392:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1444              		.loc 1 392 0
 1445 0b88 2C309DE5 		ldr	r3, [sp, #44]
 1446 0b8c 00C0A0E3 		mov	ip, #0
 1447 0b90 0320A0E1 		mov	r2, r3
 1448 0b94 0400A0E1 		mov	r0, r4
 1449 0b98 1710A0E3 		mov	r1, #23
 1450 0b9c 0530A0E1 		mov	r3, r5
 1451 0ba0 00C08DE5 		str	ip, [sp, #0]
 1452 0ba4 04C08DE5 		str	ip, [sp, #4]
 1453 0ba8 FEFFFFEB 		bl	cmdSet
 393:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1454              		.loc 1 393 0
 1455 0bac 1C0094E5 		ldr	r0, [r4, #28]
 1456 0bb0 FEFFFFEB 		bl	_txe_mutex_put
 1457 0bb4 8EFFFFEA 		b	.L91
 1458              	.L107:
 1459              		.align	2
 1460              	.L106:
 1461 0bb8 00000000 		.word	.LANCHOR0
 1462 0bbc 04020000 		.word	.LC14
 1463 0bc0 00000000 		.word	.LANCHOR1
 1464 0bc4 50020000 		.word	.LC15
 1465 0bc8 00000000 		.word	cmdQu
 1466              		.cfi_endproc
 1467              	.LFE0:
 1469              		.align	2
 1470              		.global	setIrisauto
 1472              	setIrisauto:
 1473              	.LFB1:
 408:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1474              		.loc 1 408 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 0
 1477              		@ frame_needed = 0, uses_anonymous_args = 0
 1478              	.LVL106:
 1479 0bcc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1480              	.LCFI11:
 1481              		.cfi_def_cfa_offset 16
 1482 0bd0 0160A0E1 		mov	r6, r1
 1483              		.cfi_offset 14, -4
 1484              		.cfi_offset 6, -8
 1485              		.cfi_offset 5, -12
 1486              		.cfi_offset 4, -16
 1487 0bd4 08D04DE2 		sub	sp, sp, #8
 1488              	.LCFI12:
 1489              		.cfi_def_cfa_offset 24
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1490              		.loc 1 412 0
 1491 0bd8 0050A0E3 		mov	r5, #0
 408:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1492              		.loc 1 408 0
 1493 0bdc 0040A0E1 		mov	r4, r0
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1494              		.loc 1 411 0
 1495 0be0 0010E0E3 		mvn	r1, #0
 1496              	.LVL107:
 1497 0be4 1C0090E5 		ldr	r0, [r0, #28]
 1498              	.LVL108:
 1499 0be8 FEFFFFEB 		bl	_txe_mutex_get
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1500              		.loc 1 412 0
 1501 0bec 060065E0 		rsb	r0, r5, r6
 1502 0bf0 00C070E2 		rsbs	ip, r0, #0
 1503 0bf4 00C0ACE0 		adc	ip, ip, r0
 1504 0bf8 1410A0E3 		mov	r1, #20
 1505 0bfc 2720A0E3 		mov	r2, #39
 1506 0c00 3030A0E3 		mov	r3, #48
 1507 0c04 0400A0E1 		mov	r0, r4
 1508 0c08 00C08DE5 		str	ip, [sp, #0]
 1509 0c0c 04508DE5 		str	r5, [sp, #4]
 1510 0c10 FEFFFFEB 		bl	cmdSet
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1511              		.loc 1 413 0
 1512 0c14 050056E1 		cmp	r6, r5
 1513 0c18 0260A003 		moveq	r6, #2
 1514 0c1c 0560A011 		movne	r6, r5
 1515 0c20 0400A0E1 		mov	r0, r4
 1516 0c24 1510A0E3 		mov	r1, #21
 1517 0c28 2520A0E3 		mov	r2, #37
 1518 0c2c 3030A0E3 		mov	r3, #48
 1519 0c30 00608DE5 		str	r6, [sp, #0]
 1520 0c34 04508DE5 		str	r5, [sp, #4]
 1521 0c38 FEFFFFEB 		bl	cmdSet
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1522              		.loc 1 414 0
 1523 0c3c 1C0094E5 		ldr	r0, [r4, #28]
 415:../uvc.c      **** }
 1524              		.loc 1 415 0
 1525 0c40 08D08DE2 		add	sp, sp, #8
 1526 0c44 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1527              		.loc 1 414 0
 1528 0c48 FEFFFFEA 		b	_txe_mutex_put
 1529              		.cfi_endproc
 1530              	.LFE1:
 1532              		.align	2
 1533              		.global	ControlHandle
 1535              	ControlHandle:
 1536              	.LFB2:
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1537              		.loc 1 417 0
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 24
 1540              		@ frame_needed = 0, uses_anonymous_args = 0
 1541              	.LVL109:
 1542 0c4c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1543              	.LCFI13:
 1544              		.cfi_def_cfa_offset 36
 424:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1545              		.loc 1 424 0
 1546 0c50 1F0050E3 		cmp	r0, #31
 423:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1547              		.loc 1 423 0
 1548 0c54 207040E2 		sub	r7, r0, #32
 1549              		.cfi_offset 14, -4
 1550              		.cfi_offset 11, -8
 1551              		.cfi_offset 10, -12
 1552              		.cfi_offset 9, -16
 1553              		.cfi_offset 8, -20
 1554              		.cfi_offset 7, -24
 1555              		.cfi_offset 6, -28
 1556              		.cfi_offset 5, -32
 1557              		.cfi_offset 4, -36
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1558              		.loc 1 417 0
 1559 0c58 2CD04DE2 		sub	sp, sp, #44
 1560              	.LCFI14:
 1561              		.cfi_def_cfa_offset 80
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1562              		.loc 1 417 0
 1563 0c5c 0040A0E1 		mov	r4, r0
 423:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1564              		.loc 1 423 0
 1565 0c60 FF7007E2 		and	r7, r7, #255
 1566              	.LVL110:
 424:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1567              		.loc 1 424 0
 1568 0c64 2300009A 		bls	.L112
 425:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1569              		.loc 1 425 0
 1570 0c68 E46E9FE5 		ldr	r6, .L230
 1571 0c6c 872087E0 		add	r2, r7, r7, asl #1
 1572 0c70 8221A0E1 		mov	r2, r2, asl #3
 1573 0c74 023086E0 		add	r3, r6, r2
 426:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1574              		.loc 1 426 0
 1575 0c78 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 427:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1576              		.loc 1 427 0
 1577 0c7c 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 428:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1578              		.loc 1 428 0
 1579 0c80 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 439:../uvc.c      ****     reqData = bRequest;
 1580              		.loc 1 439 0
 1581 0c84 CC3E9FE5 		ldr	r3, .L230+4
 425:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1582              		.loc 1 425 0
 1583 0c88 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1584              	.LVL111:
 439:../uvc.c      ****     reqData = bRequest;
 1585              		.loc 1 439 0
 1586 0c8c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1587              	.LVL112:
 447:../uvc.c      ****     switch (bRequest)
 1588              		.loc 1 447 0
 1589 0c90 830055E3 		cmp	r5, #131
 1590 0c94 2200000A 		beq	.L118
 1591              	.LVL113:
 1592              	.L224:
 1593 0c98 2B00009A 		bls	.L222
 1594 0c9c 850055E3 		cmp	r5, #133
 1595 0ca0 8400000A 		beq	.L120
 1596 0ca4 7200003A 		bcc	.L119
 1597 0ca8 860055E3 		cmp	r5, #134
 1598 0cac BD00000A 		beq	.L121
 1599 0cb0 870055E3 		cmp	r5, #135
 1600 0cb4 B100000A 		beq	.L223
 1601              	.L114:
 961:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1602              		.loc 1 961 0
 1603 0cb8 0000A0E3 		mov	r0, #0
 1604 0cbc 0110A0E3 		mov	r1, #1
 1605 0cc0 0020A0E1 		mov	r2, r0
 1606 0cc4 FEFFFFEB 		bl	CyU3PUsbStall
 962:../uvc.c      **** 			  break;
 1607              		.loc 1 962 0
 1608 0cc8 FFE0A0E3 		mov	lr, #255
 1609 0ccc 0E40A0E1 		mov	r4, lr
 1610 0cd0 0EC0A0E1 		mov	ip, lr
 1611 0cd4 0E30A0E1 		mov	r3, lr
 1612              	.LVL114:
 1613              	.L124:
 964:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1614              		.loc 1 964 0
 1615 0cd8 7C1E9FE5 		ldr	r1, .L230+8
 1616 0cdc 0520A0E1 		mov	r2, r5
 1617 0ce0 0400A0E3 		mov	r0, #4
 1618 0ce4 00C08DE5 		str	ip, [sp, #0]
 1619 0ce8 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1620 0cec FEFFFFEB 		bl	CyU3PDebugPrint
 965:../uvc.c      **** }
 1621              		.loc 1 965 0
 1622 0cf0 2CD08DE2 		add	sp, sp, #44
 1623 0cf4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1624              	.LVL115:
 1625              	.L112:
 430:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1626              		.loc 1 430 0
 1627 0cf8 546E9FE5 		ldr	r6, .L230
 439:../uvc.c      ****     reqData = bRequest;
 1628              		.loc 1 439 0
 1629 0cfc 543E9FE5 		ldr	r3, .L230+4
 430:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1630              		.loc 1 430 0
 1631 0d00 805080E0 		add	r5, r0, r0, asl #1
 1632 0d04 850186E0 		add	r0, r6, r5, asl #3
 1633              	.LVL116:
 439:../uvc.c      ****     reqData = bRequest;
 1634              		.loc 1 439 0
 1635 0d08 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 430:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1636              		.loc 1 430 0
 1637 0d0c 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1638              	.LVL117:
 447:../uvc.c      ****     switch (bRequest)
 1639              		.loc 1 447 0
 1640 0d10 830055E3 		cmp	r5, #131
 431:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1641              		.loc 1 431 0
 1642 0d14 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1643              	.LVL118:
 432:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1644              		.loc 1 432 0
 1645 0d18 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1646              	.LVL119:
 433:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1647              		.loc 1 433 0
 1648 0d1c 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1649              	.LVL120:
 447:../uvc.c      ****     switch (bRequest)
 1650              		.loc 1 447 0
 1651 0d20 DCFFFF1A 		bne	.L224
 1652              	.LVL121:
 1653              	.L118:
 581:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1654              		.loc 1 581 0
 1655 0d24 1F0054E3 		cmp	r4, #31
 1656 0d28 BC00009A 		bls	.L149
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1657              		.loc 1 582 0
 1658 0d2c 877087E0 		add	r7, r7, r7, asl #1
 1659              	.LVL122:
 1660 0d30 876186E0 		add	r6, r6, r7, asl #3
 1661 0d34 24AE9FE5 		ldr	sl, .L230+12
 1662 0d38 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1663              		.loc 1 583 0
 1664 0d3c 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 582:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1665              		.loc 1 582 0
 1666 0d40 5C00CAE5 		strb	r0, [sl, #92]
 583:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1667              		.loc 1 583 0
 1668 0d44 5DC0CAE5 		strb	ip, [sl, #93]
 1669 0d48 0B0000EA 		b	.L157
 1670              	.LVL123:
 1671              	.L222:
 447:../uvc.c      ****     switch (bRequest)
 1672              		.loc 1 447 0
 1673 0d4c 810055E3 		cmp	r5, #129
 1674 0d50 6400000A 		beq	.L116
 1675 0d54 1000009A 		bls	.L225
 562:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1676              		.loc 1 562 0
 1677 0d58 1F0054E3 		cmp	r4, #31
 1678 0d5c A300009A 		bls	.L146
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1679              		.loc 1 563 0
 1680 0d60 877087E0 		add	r7, r7, r7, asl #1
 1681              	.LVL124:
 1682 0d64 876186E0 		add	r6, r6, r7, asl #3
 1683 0d68 F0AD9FE5 		ldr	sl, .L230+12
 1684 0d6c 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 564:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1685              		.loc 1 564 0
 1686 0d70 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1687              		.loc 1 563 0
 1688 0d74 5C20CAE5 		strb	r2, [sl, #92]
 564:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1689              		.loc 1 564 0
 1690 0d78 5DE0CAE5 		strb	lr, [sl, #93]
 1691              	.L157:
 640:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1692              		.loc 1 640 0
 1693 0d7c 0800A0E1 		mov	r0, r8
 1694 0d80 DC1D9FE5 		ldr	r1, .L230+16
 1695 0d84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1696              	.LVL125:
 642:../uvc.c      **** 			  break;
 1697              		.loc 1 642 0
 1698 0d88 FFE0A0E3 		mov	lr, #255
 640:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1699              		.loc 1 640 0
 1700 0d8c 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 642:../uvc.c      **** 			  break;
 1701              		.loc 1 642 0
 1702 0d90 0EC0A0E1 		mov	ip, lr
 1703 0d94 0E30A0E1 		mov	r3, lr
 1704 0d98 CEFFFFEA 		b	.L124
 1705              	.LVL126:
 1706              	.L225:
 447:../uvc.c      ****     switch (bRequest)
 1707              		.loc 1 447 0
 1708 0d9c 010055E3 		cmp	r5, #1
 1709 0da0 C4FFFF1A 		bne	.L114
 644:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1710              		.loc 1 644 0
 1711 0da4 B41D9FE5 		ldr	r1, .L230+12
 1712 0da8 26208DE2 		add	r2, sp, #38
 1713 0dac 2000A0E3 		mov	r0, #32
 1714 0db0 5C1081E2 		add	r1, r1, #92
 1715 0db4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1716              	.LVL127:
 646:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1717              		.loc 1 646 0
 1718 0db8 002050E2 		subs	r2, r0, #0
 1719 0dbc 0103001A 		bne	.L159
 648:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1720              		.loc 1 648 0
 1721 0dc0 98ED9FE5 		ldr	lr, .L230+12
 1722 0dc4 5C30DEE5 		ldrb	r3, [lr, #92]	@ zero_extendqisi2
 649:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1723              		.loc 1 649 0
 1724 0dc8 90ED9FE5 		ldr	lr, .L230+12
 648:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1725              		.loc 1 648 0
 1726 0dcc 18308DE5 		str	r3, [sp, #24]
 1727              	.LVL128:
 651:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1728              		.loc 1 651 0
 1729 0dd0 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1730              	.LVL129:
 649:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1731              		.loc 1 649 0
 1732 0dd4 5DC0DEE5 		ldrb	ip, [lr, #93]	@ zero_extendqisi2
 1733              	.LVL130:
 651:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1734              		.loc 1 651 0
 1735 0dd8 1C008DE5 		str	r0, [sp, #28]
 1736              	.LVL131:
 655:../uvc.c      **** 				  switch(CtrlID)
 1737              		.loc 1 655 0
 1738 0ddc 220054E3 		cmp	r4, #34
 1739 0de0 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1740 0de4 C90200EA 		b	.L160
 1741              	.L175:
 1742 0de8 78190000 		.word	.L161
 1743 0dec A8180000 		.word	.L162
 1744 0df0 10190000 		.word	.L160
 1745 0df4 10190000 		.word	.L160
 1746 0df8 58180000 		.word	.L163
 1747 0dfc 14170000 		.word	.L164
 1748 0e00 98160000 		.word	.L165
 1749 0e04 10190000 		.word	.L160
 1750 0e08 10190000 		.word	.L160
 1751 0e0c 10190000 		.word	.L160
 1752 0e10 10190000 		.word	.L160
 1753 0e14 10160000 		.word	.L166
 1754 0e18 10190000 		.word	.L160
 1755 0e1c 10190000 		.word	.L160
 1756 0e20 10190000 		.word	.L160
 1757 0e24 10190000 		.word	.L160
 1758 0e28 18150000 		.word	.L167
 1759 0e2c 10190000 		.word	.L160
 1760 0e30 10190000 		.word	.L160
 1761 0e34 10190000 		.word	.L160
 1762 0e38 10190000 		.word	.L160
 1763 0e3c 10190000 		.word	.L160
 1764 0e40 10190000 		.word	.L160
 1765 0e44 10190000 		.word	.L160
 1766 0e48 10190000 		.word	.L160
 1767 0e4c 5C140000 		.word	.L168
 1768 0e50 10190000 		.word	.L160
 1769 0e54 10190000 		.word	.L160
 1770 0e58 A0150000 		.word	.L169
 1771 0e5c 10190000 		.word	.L160
 1772 0e60 00140000 		.word	.L170
 1773 0e64 7C130000 		.word	.L171
 1774 0e68 E4120000 		.word	.L172
 1775 0e6c CC120000 		.word	.L173
 1776 0e70 68120000 		.word	.L174
 1777              	.LVL132:
 1778              	.L119:
 599:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1779              		.loc 1 599 0
 1780 0e74 1F0054E3 		cmp	r4, #31
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1781              		.loc 1 600 0
 1782 0e78 87708780 		addhi	r7, r7, r7, asl #1
 1783              	.LVL133:
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1784              		.loc 1 606 0
 1785 0e7c 84408490 		addls	r4, r4, r4, asl #1
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1786              		.loc 1 600 0
 1787 0e80 87618680 		addhi	r6, r6, r7, asl #3
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1788              		.loc 1 606 0
 1789 0e84 84618690 		addls	r6, r6, r4, asl #3
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1790              		.loc 1 600 0
 1791 0e88 D0AC9F85 		ldrhi	sl, .L230+12
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1792              		.loc 1 606 0
 1793 0e8c CCAC9F95 		ldrls	sl, .L230+12
 600:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1794              		.loc 1 600 0
 1795 0e90 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 601:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1796              		.loc 1 601 0
 1797 0e94 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1798              		.loc 1 606 0
 1799 0e98 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 607:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1800              		.loc 1 607 0
 1801 0e9c 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 608:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1802              		.loc 1 608 0
 1803 0ea0 0030A0E3 		mov	r3, #0
 606:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1804              		.loc 1 606 0
 1805 0ea4 5C10CAE5 		strb	r1, [sl, #92]
 607:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1806              		.loc 1 607 0
 1807 0ea8 5D20CAE5 		strb	r2, [sl, #93]
 608:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1808              		.loc 1 608 0
 1809 0eac 5E30CAE5 		strb	r3, [sl, #94]
 609:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1810              		.loc 1 609 0
 1811 0eb0 5F30CAE5 		strb	r3, [sl, #95]
 1812 0eb4 B0FFFFEA 		b	.L157
 1813              	.LVL134:
 1814              	.L120:
 451:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1815              		.loc 1 451 0
 1816 0eb8 A04C9FE5 		ldr	r4, .L230+12
 452:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1817              		.loc 1 452 0
 1818 0ebc 00C0A0E3 		mov	ip, #0
 1819 0ec0 5DC0C4E5 		strb	ip, [r4, #93]
 453:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1820              		.loc 1 453 0
 1821 0ec4 5C1084E2 		add	r1, r4, #92
 451:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1822              		.loc 1 451 0
 1823 0ec8 5C80C4E5 		strb	r8, [r4, #92]
 453:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1824              		.loc 1 453 0
 1825 0ecc 0200A0E3 		mov	r0, #2
 1826 0ed0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1827              	.LVL135:
 455:../uvc.c      **** 			  break;
 1828              		.loc 1 455 0
 1829 0ed4 FFE0A0E3 		mov	lr, #255
 453:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1830              		.loc 1 453 0
 1831 0ed8 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 455:../uvc.c      **** 			  break;
 1832              		.loc 1 455 0
 1833 0edc 0EC0A0E1 		mov	ip, lr
 1834 0ee0 0E30A0E1 		mov	r3, lr
 1835 0ee4 7BFFFFEA 		b	.L124
 1836              	.LVL136:
 1837              	.L116:
 458:../uvc.c      **** 			 switch(CtrlID)
 1838              		.loc 1 458 0
 1839 0ee8 011044E2 		sub	r1, r4, #1
 1840 0eec 210051E3 		cmp	r1, #33
 1841 0ef0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1842 0ef4 D20000EA 		b	.L125
 1843              	.L133:
 1844 0ef8 18120000 		.word	.L126
 1845 0efc 44120000 		.word	.L125
 1846 0f00 44120000 		.word	.L125
 1847 0f04 44120000 		.word	.L125
 1848 0f08 F8110000 		.word	.L127
 1849 0f0c 44120000 		.word	.L125
 1850 0f10 44120000 		.word	.L125
 1851 0f14 44120000 		.word	.L125
 1852 0f18 44120000 		.word	.L125
 1853 0f1c 44120000 		.word	.L125
 1854 0f20 D4110000 		.word	.L128
 1855 0f24 44120000 		.word	.L125
 1856 0f28 44120000 		.word	.L125
 1857 0f2c 44120000 		.word	.L125
 1858 0f30 44120000 		.word	.L125
 1859 0f34 44120000 		.word	.L125
 1860 0f38 44120000 		.word	.L125
 1861 0f3c 44120000 		.word	.L125
 1862 0f40 44120000 		.word	.L125
 1863 0f44 44120000 		.word	.L125
 1864 0f48 44120000 		.word	.L125
 1865 0f4c 44120000 		.word	.L125
 1866 0f50 44120000 		.word	.L125
 1867 0f54 44120000 		.word	.L125
 1868 0f58 98110000 		.word	.L129
 1869 0f5c 44120000 		.word	.L125
 1870 0f60 44120000 		.word	.L125
 1871 0f64 70110000 		.word	.L130
 1872 0f68 44120000 		.word	.L125
 1873 0f6c 44120000 		.word	.L125
 1874 0f70 D4100000 		.word	.L131
 1875 0f74 9C100000 		.word	.L132
 1876 0f78 9C100000 		.word	.L132
 1877 0f7c 9C100000 		.word	.L132
 1878              	.L223:
 626:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1879              		.loc 1 626 0
 1880 0f80 1F0054E3 		cmp	r4, #31
 1881 0f84 3100009A 		bls	.L156
 627:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1882              		.loc 1 627 0
 1883 0f88 877087E0 		add	r7, r7, r7, asl #1
 1884              	.LVL137:
 1885 0f8c 876186E0 		add	r6, r6, r7, asl #3
 1886 0f90 C8AB9FE5 		ldr	sl, .L230+12
 1887 0f94 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 628:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1888              		.loc 1 628 0
 1889 0f98 0C40D6E5 		ldrb	r4, [r6, #12]	@ zero_extendqisi2
 627:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1890              		.loc 1 627 0
 1891 0f9c 5C10CAE5 		strb	r1, [sl, #92]
 628:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1892              		.loc 1 628 0
 1893 0fa0 5D40CAE5 		strb	r4, [sl, #93]
 1894 0fa4 74FFFFEA 		b	.L157
 1895              	.LVL138:
 1896              	.L121:
 615:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1897              		.loc 1 615 0
 1898 0fa8 1F0054E3 		cmp	r4, #31
 619:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1899              		.loc 1 619 0
 1900 0fac 84408490 		addls	r4, r4, r4, asl #1
 616:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1901              		.loc 1 616 0
 1902 0fb0 87708780 		addhi	r7, r7, r7, asl #1
 1903              	.LVL139:
 619:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1904              		.loc 1 619 0
 1905 0fb4 84618690 		addls	r6, r6, r4, asl #3
 616:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1906              		.loc 1 616 0
 1907 0fb8 87618680 		addhi	r6, r6, r7, asl #3
 1908 0fbc 9C8B9F85 		ldrhi	r8, .L230+12
 1909 0fc0 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 619:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1910              		.loc 1 619 0
 1911 0fc4 948B9F95 		ldrls	r8, .L230+12
 1912 0fc8 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 621:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1913              		.loc 1 621 0
 1914 0fcc 0100A0E3 		mov	r0, #1
 619:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1915              		.loc 1 619 0
 1916 0fd0 5C30C8E5 		strb	r3, [r8, #92]
 621:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1917              		.loc 1 621 0
 1918 0fd4 881B9FE5 		ldr	r1, .L230+16
 1919 0fd8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1920              	.LVL140:
 624:../uvc.c      **** 			  break;
 1921              		.loc 1 624 0
 1922 0fdc FFE0A0E3 		mov	lr, #255
 621:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1923              		.loc 1 621 0
 1924 0fe0 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 624:../uvc.c      **** 			  break;
 1925              		.loc 1 624 0
 1926 0fe4 0EC0A0E1 		mov	ip, lr
 1927 0fe8 0E30A0E1 		mov	r3, lr
 1928 0fec 39FFFFEA 		b	.L124
 1929              	.LVL141:
 1930              	.L146:
 567:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1931              		.loc 1 567 0
 1932 0ff0 0B0054E3 		cmp	r4, #11
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1933              		.loc 1 574 0
 1934 0ff4 84408410 		addne	r4, r4, r4, asl #1
 1935 0ff8 84618610 		addne	r6, r6, r4, asl #3
 1936 0ffc 5CAB9F15 		ldrne	sl, .L230+12
 568:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1937              		.loc 1 568 0
 1938 1000 58AB9F05 		ldreq	sl, .L230+12
 1939 1004 5C3B9F05 		ldreq	r3, .L230+20
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1940              		.loc 1 574 0
 1941 1008 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 575:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1942              		.loc 1 575 0
 1943 100c 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 568:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1944              		.loc 1 568 0
 1945 1010 5C308A05 		streq	r3, [sl, #92]
 574:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1946              		.loc 1 574 0
 1947 1014 5C20CA15 		strneb	r2, [sl, #92]
 575:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1948              		.loc 1 575 0
 1949 1018 5D30CA15 		strneb	r3, [sl, #93]
 1950 101c 56FFFFEA 		b	.L157
 1951              	.L149:
 585:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1952              		.loc 1 585 0
 1953 1020 0B0054E3 		cmp	r4, #11
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1954              		.loc 1 592 0
 1955 1024 84408410 		addne	r4, r4, r4, asl #1
 1956 1028 84618610 		addne	r6, r6, r4, asl #3
 1957 102c 2CAB9F15 		ldrne	sl, .L230+12
 586:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1958              		.loc 1 586 0
 1959 1030 28AB9F05 		ldreq	sl, .L230+12
 1960 1034 303B9F05 		ldreq	r3, .L230+24
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1961              		.loc 1 592 0
 1962 1038 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 593:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1963              		.loc 1 593 0
 1964 103c 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 586:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1965              		.loc 1 586 0
 1966 1040 5C308A05 		streq	r3, [sl, #92]
 592:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1967              		.loc 1 592 0
 1968 1044 5C20CA15 		strneb	r2, [sl, #92]
 593:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1969              		.loc 1 593 0
 1970 1048 5D30CA15 		strneb	r3, [sl, #93]
 1971 104c 4AFFFFEA 		b	.L157
 1972              	.L156:
 631:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1973              		.loc 1 631 0
 1974 1050 0B0054E3 		cmp	r4, #11
 1975 1054 0700000A 		beq	.L226
 637:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1976              		.loc 1 637 0
 1977 1058 84A084E0 		add	sl, r4, r4, asl #1
 1978 105c 8A6186E0 		add	r6, r6, sl, asl #3
 1979 1060 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1980 1064 F4AA9FE5 		ldr	sl, .L230+12
 638:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1981              		.loc 1 638 0
 1982 1068 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 637:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1983              		.loc 1 637 0
 1984 106c 5C30CAE5 		strb	r3, [sl, #92]
 638:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1985              		.loc 1 638 0
 1986 1070 5D00CAE5 		strb	r0, [sl, #93]
 1987 1074 40FFFFEA 		b	.L157
 1988              	.L226:
 632:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1989              		.loc 1 632 0
 1990 1078 E0AA9FE5 		ldr	sl, .L230+12
 1991 107c 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 634:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1992              		.loc 1 634 0
 1993 1080 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 633:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1994              		.loc 1 633 0
 1995 1084 00E0A0E3 		mov	lr, #0
 632:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1996              		.loc 1 632 0
 1997 1088 5CC0CAE5 		strb	ip, [sl, #92]
 633:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1998              		.loc 1 633 0
 1999 108c 5DE0CAE5 		strb	lr, [sl, #93]
 634:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2000              		.loc 1 634 0
 2001 1090 5E20CAE5 		strb	r2, [sl, #94]
 635:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2002              		.loc 1 635 0
 2003 1094 5FE0CAE5 		strb	lr, [sl, #95]
 2004 1098 37FFFFEA 		b	.L157
 2005              	.L132:
 464:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2006              		.loc 1 464 0
 2007 109c 877087E0 		add	r7, r7, r7, asl #1
 2008              	.LVL142:
 2009 10a0 876186E0 		add	r6, r6, r7, asl #3
 2010 10a4 B4EA9FE5 		ldr	lr, .L230+12
 2011 10a8 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 465:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2012              		.loc 1 465 0
 2013 10ac 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 464:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2014              		.loc 1 464 0
 2015 10b0 5C40CEE5 		strb	r4, [lr, #92]
 465:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2016              		.loc 1 465 0
 2017 10b4 5D60CEE5 		strb	r6, [lr, #93]
 2018              	.LVL143:
 2019              	.L136:
 555:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2020              		.loc 1 555 0
 2021 10b8 0800A0E1 		mov	r0, r8
 2022 10bc A01A9FE5 		ldr	r1, .L230+16
 2023 10c0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 560:../uvc.c      **** 			  break;
 2024              		.loc 1 560 0
 2025 10c4 FFC0A0E3 		mov	ip, #255
 555:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2026              		.loc 1 555 0
 2027 10c8 06E0A0E1 		mov	lr, r6
 560:../uvc.c      **** 			  break;
 2028              		.loc 1 560 0
 2029 10cc 0C30A0E1 		mov	r3, ip
 2030 10d0 00FFFFEA 		b	.L124
 2031              	.LVL144:
 2032              	.L131:
 485:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2033              		.loc 1 485 0 discriminator 1
 2034 10d4 000058E3 		cmp	r8, #0
 2035 10d8 8002000A 		beq	.L218
 483:../uvc.c      **** 					 break;
 2036              		.loc 1 483 0
 2037 10dc 28E1A0E1 		mov	lr, r8, lsr #2
 2038 10e0 00005EE3 		cmp	lr, #0
 2039 10e4 03005813 		cmpne	r8, #3
 2040 10e8 0020A083 		movhi	r2, #0
 2041 10ec 0120A093 		movls	r2, #1
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2042              		.loc 1 417 0
 2043 10f0 0E31A0E1 		mov	r3, lr, asl #2
 483:../uvc.c      **** 					 break;
 2044              		.loc 1 483 0
 2045 10f4 9302009A 		bls	.L203
 2046 10f8 641A9FE5 		ldr	r1, .L230+16
 2047 10fc 100041E2 		sub	r0, r1, #16
 2048              	.LVL145:
 2049              	.L141:
 486:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2050              		.loc 1 486 0 discriminator 2
 2051 1100 044090E4 		ldr	r4, [r0], #4
 2052 1104 01C082E2 		add	ip, r2, #1
 2053 1108 FF200CE2 		and	r2, ip, #255
 2054 110c 02005EE1 		cmp	lr, r2
 2055 1110 044081E4 		str	r4, [r1], #4
 2056 1114 F9FFFF8A 		bhi	.L141
 486:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2057              		.loc 1 486 0 is_stmt 0
 2058 1118 030058E1 		cmp	r8, r3
 2059 111c 3C0A9F15 		ldrne	r0, .L230+12
 2060 1120 6E02000A 		beq	.L218
 2061              	.L210:
 2062 1124 03E080E0 		add	lr, r0, r3
 2063 1128 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 485:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2064              		.loc 1 485 0 is_stmt 1
 2065 112c 016083E2 		add	r6, r3, #1
 2066 1130 FF3006E2 		and	r3, r6, #255
 2067              	.LVL146:
 2068 1134 030058E1 		cmp	r8, r3
 486:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2069              		.loc 1 486 0
 2070 1138 5C10CEE5 		strb	r1, [lr, #92]
 485:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2071              		.loc 1 485 0
 2072 113c F8FFFF8A 		bhi	.L210
 2073              	.LVL147:
 2074              	.L135:
 495:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2075              		.loc 1 495 0
 2076 1140 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 488:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2077              		.loc 1 488 0
 2078 1144 143A9FE5 		ldr	r3, .L230+12
 495:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2079              		.loc 1 495 0
 2080 1148 FF0052E3 		cmp	r2, #255
 488:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2081              		.loc 1 488 0
 2082 114c 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2083              	.LVL148:
 489:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2084              		.loc 1 489 0
 2085 1150 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2086              	.LVL149:
 495:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2087              		.loc 1 495 0
 2088 1154 D7FFFF0A 		beq	.L136
 497:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2089              		.loc 1 497 0
 2090 1158 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2091 115c 0C1A9FE5 		ldr	r1, .L230+28
 2092 1160 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2093 1164 0400A0E3 		mov	r0, #4
 2094 1168 FEFFFFEB 		bl	CyU3PDebugPrint
 2095 116c D1FFFFEA 		b	.L136
 2096              	.LVL150:
 2097              	.L130:
 472:../uvc.c      **** 					 if(CamMode == 1){//720p
 2098              		.loc 1 472 0
 2099 1170 E8799FE5 		ldr	r7, .L230+12
 2100              	.LVL151:
 471:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2101              		.loc 1 471 0
 2102 1174 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2103              	.LVL152:
 472:../uvc.c      **** 					 if(CamMode == 1){//720p
 2104              		.loc 1 472 0
 2105 1178 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2106 117c 010052E3 		cmp	r2, #1
 2107 1180 1802000A 		beq	.L227
 2108              	.LVL153:
 2109              	.L137:
 482:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2110              		.loc 1 482 0
 2111 1184 0000A0E3 		mov	r0, #0
 481:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2112              		.loc 1 481 0
 2113 1188 5C40C7E5 		strb	r4, [r7, #92]
 482:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2114              		.loc 1 482 0
 2115 118c 5D00C7E5 		strb	r0, [r7, #93]
 435:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2116              		.loc 1 435 0
 2117 1190 FF60A0E3 		mov	r6, #255
 483:../uvc.c      **** 					 break;
 2118              		.loc 1 483 0
 2119 1194 C7FFFFEA 		b	.L136
 2120              	.LVL154:
 2121              	.L129:
 501:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2122              		.loc 1 501 0
 2123 1198 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2124 119c BCC99FE5 		ldr	ip, .L230+12
 503:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2125              		.loc 1 503 0
 2126 11a0 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 502:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2127              		.loc 1 502 0
 2128 11a4 00E0A0E3 		mov	lr, #0
 501:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2129              		.loc 1 501 0
 2130 11a8 5C40CCE5 		strb	r4, [ip, #92]
 502:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2131              		.loc 1 502 0
 2132 11ac 5DE0CCE5 		strb	lr, [ip, #93]
 503:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2133              		.loc 1 503 0
 2134 11b0 5E60CCE5 		strb	r6, [ip, #94]
 504:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2135              		.loc 1 504 0
 2136 11b4 5FE0CCE5 		strb	lr, [ip, #95]
 2137              	.LVL155:
 507:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2138              		.loc 1 507 0
 2139 11b8 B4199FE5 		ldr	r1, .L230+32
 2140 11bc 0420A0E1 		mov	r2, r4
 2141 11c0 0E30A0E1 		mov	r3, lr
 2142 11c4 0400A0E3 		mov	r0, #4
 2143 11c8 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2144 11cc FEFFFFEB 		bl	CyU3PDebugPrint
 508:../uvc.c      **** 					 break;
 2145              		.loc 1 508 0
 2146 11d0 B8FFFFEA 		b	.L136
 2147              	.LVL156:
 2148              	.L128:
 540:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2149              		.loc 1 540 0
 2150 11d4 84C99FE5 		ldr	ip, .L230+12
 2151 11d8 9044D6E5 		ldrb	r4, [r6, #1168]	@ zero_extendqisi2
 542:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2152              		.loc 1 542 0
 2153 11dc 9264D6E5 		ldrb	r6, [r6, #1170]	@ zero_extendqisi2
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2154              		.loc 1 541 0
 2155 11e0 00E0A0E3 		mov	lr, #0
 540:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2156              		.loc 1 540 0
 2157 11e4 5C40CCE5 		strb	r4, [ip, #92]
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2158              		.loc 1 541 0
 2159 11e8 5DE0CCE5 		strb	lr, [ip, #93]
 542:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2160              		.loc 1 542 0
 2161 11ec 5E60CCE5 		strb	r6, [ip, #94]
 543:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2162              		.loc 1 543 0
 2163 11f0 5FE0CCE5 		strb	lr, [ip, #95]
 2164              	.LVL157:
 546:../uvc.c      **** 					 break;
 2165              		.loc 1 546 0
 2166 11f4 AFFFFFEA 		b	.L136
 2167              	.LVL158:
 2168              	.L127:
 535:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2169              		.loc 1 535 0
 2170 11f8 0522D6E5 		ldrb	r2, [r6, #517]	@ zero_extendqisi2
 2171 11fc 5C699FE5 		ldr	r6, .L230+12
 2172 1200 804022E2 		eor	r4, r2, #128
 536:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2173              		.loc 1 536 0
 2174 1204 0010A0E3 		mov	r1, #0
 535:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2175              		.loc 1 535 0
 2176 1208 5C40C6E5 		strb	r4, [r6, #92]
 536:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2177              		.loc 1 536 0
 2178 120c 5D10C6E5 		strb	r1, [r6, #93]
 2179              	.LVL159:
 435:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2180              		.loc 1 435 0
 2181 1210 FF60A0E3 		mov	r6, #255
 538:../uvc.c      **** 					 break;
 2182              		.loc 1 538 0
 2183 1214 A7FFFFEA 		b	.L136
 2184              	.LVL160:
 2185              	.L126:
 523:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2186              		.loc 1 523 0
 2187 1218 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2188              	.LVL161:
 529:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2189              		.loc 1 529 0
 2190 121c 3C399FE5 		ldr	r3, .L230+12
 524:../uvc.c      **** 					  if(Data0&0x80){
 2191              		.loc 1 524 0
 2192 1220 800014E3 		tst	r4, #128
 525:../uvc.c      **** 						  Data0 = ~Data0;
 2193              		.loc 1 525 0
 2194 1224 0440E011 		mvnne	r4, r4
 2195              	.LVL162:
 527:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2196              		.loc 1 527 0
 2197 1228 80404402 		subeq	r4, r4, #128
 2198 122c FF4004E2 		and	r4, r4, #255
 2199              	.LVL163:
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2200              		.loc 1 530 0
 2201 1230 0000A0E3 		mov	r0, #0
 529:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2202              		.loc 1 529 0
 2203 1234 5C40C3E5 		strb	r4, [r3, #92]
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2204              		.loc 1 530 0
 2205 1238 5D00C3E5 		strb	r0, [r3, #93]
 2206              	.LVL164:
 435:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2207              		.loc 1 435 0
 2208 123c FF60A0E3 		mov	r6, #255
 532:../uvc.c      **** 			 		 break;
 2209              		.loc 1 532 0
 2210 1240 9CFFFFEA 		b	.L136
 2211              	.LVL165:
 2212              	.L125:
 549:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2213              		.loc 1 549 0
 2214 1244 841084E0 		add	r1, r4, r4, asl #1
 2215 1248 814186E0 		add	r4, r6, r1, asl #3
 2216 124c 0C399FE5 		ldr	r3, .L230+12
 2217 1250 8D41D4E5 		ldrb	r4, [r4, #397]	@ zero_extendqisi2
 550:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2218              		.loc 1 550 0
 2219 1254 0000A0E3 		mov	r0, #0
 435:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2220              		.loc 1 435 0
 2221 1258 FF60A0E3 		mov	r6, #255
 549:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2222              		.loc 1 549 0
 2223 125c 5C40C3E5 		strb	r4, [r3, #92]
 550:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2224              		.loc 1 550 0
 2225 1260 5D00C3E5 		strb	r0, [r3, #93]
 2226              	.LVL166:
 552:../uvc.c      **** 					 break;
 2227              		.loc 1 552 0
 2228 1264 93FFFFEA 		b	.L136
 2229              	.LVL167:
 2230              	.L174:
 786:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2231              		.loc 1 786 0
 2232 1268 08499FE5 		ldr	r4, .L230+36
 2233 126c 0010E0E3 		mvn	r1, #0
 2234 1270 1C0094E5 		ldr	r0, [r4, #28]
 2235 1274 FEFFFFEB 		bl	_txe_mutex_get
 2236              	.LVL168:
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2237              		.loc 1 787 0
 2238 1278 2210A0E3 		mov	r1, #34
 2239              	.L221:
 2240 127c 18C09DE5 		ldr	ip, [sp, #24]
 2241 1280 00E0A0E3 		mov	lr, #0
 2242 1284 0A30A0E1 		mov	r3, sl
 2243 1288 0920A0E1 		mov	r2, r9
 2244 128c 0400A0E1 		mov	r0, r4
 2245 1290 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2246 1294 FEFFFFEB 		bl	cmdSet
 788:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2247              		.loc 1 788 0
 2248 1298 1C0094E5 		ldr	r0, [r4, #28]
 2249 129c FEFFFFEB 		bl	_txe_mutex_put
 789:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2250              		.loc 1 789 0
 2251 12a0 18109DE5 		ldr	r1, [sp, #24]
 2252 12a4 877087E0 		add	r7, r7, r7, asl #1
 2253              	.LVL169:
 2254 12a8 876186E0 		add	r6, r6, r7, asl #3
 790:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2255              		.loc 1 790 0
 2256 12ac 0130A0E3 		mov	r3, #1
 791:../uvc.c      **** 							 break;
 2257              		.loc 1 791 0
 2258 12b0 FFE0A0E3 		mov	lr, #255
 790:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2259              		.loc 1 790 0
 2260 12b4 1030C6E5 		strb	r3, [r6, #16]
 789:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2261              		.loc 1 789 0
 2262 12b8 0D10C6E5 		strb	r1, [r6, #13]
 790:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2263              		.loc 1 790 0
 2264 12bc 0130A0E1 		mov	r3, r1
 2265 12c0 1CC09DE5 		ldr	ip, [sp, #28]
 791:../uvc.c      **** 							 break;
 2266              		.loc 1 791 0
 2267 12c4 0E40A0E1 		mov	r4, lr
 2268 12c8 82FEFFEA 		b	.L124
 2269              	.LVL170:
 2270              	.L173:
 778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2271              		.loc 1 778 0
 2272 12cc A4489FE5 		ldr	r4, .L230+36
 2273 12d0 0010E0E3 		mvn	r1, #0
 2274 12d4 1C0094E5 		ldr	r0, [r4, #28]
 2275 12d8 FEFFFFEB 		bl	_txe_mutex_get
 2276              	.LVL171:
 779:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2277              		.loc 1 779 0
 2278 12dc 2110A0E3 		mov	r1, #33
 2279 12e0 E5FFFFEA 		b	.L221
 2280              	.LVL172:
 2281              	.L172:
 764:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2282              		.loc 1 764 0
 2283 12e4 8C489FE5 		ldr	r4, .L230+36
 2284 12e8 0010E0E3 		mvn	r1, #0
 2285 12ec 1C0094E5 		ldr	r0, [r4, #28]
 2286 12f0 14C08DE5 		str	ip, [sp, #20]
 2287 12f4 FEFFFFEB 		bl	_txe_mutex_get
 2288              	.LVL173:
 763:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2289              		.loc 1 763 0
 2290 12f8 18209DE5 		ldr	r2, [sp, #24]
 766:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2291              		.loc 1 766 0
 2292 12fc 00E0A0E3 		mov	lr, #0
 763:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2293              		.loc 1 763 0
 2294 1300 7F8002E2 		and	r8, r2, #127
 2295 1304 1C808DE5 		str	r8, [sp, #28]
 2296              	.LVL174:
 766:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2297              		.loc 1 766 0
 2298 1308 1CC09DE5 		ldr	ip, [sp, #28]
 2299 130c 2010A0E3 		mov	r1, #32
 2300 1310 0920A0E1 		mov	r2, r9
 2301 1314 0A30A0E1 		mov	r3, sl
 2302 1318 0400A0E1 		mov	r0, r4
 2303 131c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2304 1320 FEFFFFEB 		bl	cmdSet
 2305              	.LVL175:
 768:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2306              		.loc 1 768 0
 2307 1324 14C09DE5 		ldr	ip, [sp, #20]
 2308 1328 0A30A0E1 		mov	r3, sl
 2309 132c 0180A0E3 		mov	r8, #1
 2310 1330 2010A0E3 		mov	r1, #32
 2311 1334 0B20A0E1 		mov	r2, fp
 2312 1338 0400A0E1 		mov	r0, r4
 2313 133c 00C08DE5 		str	ip, [sp, #0]
 2314 1340 04808DE5 		str	r8, [sp, #4]
 2315 1344 FEFFFFEB 		bl	cmdSet
 769:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2316              		.loc 1 769 0
 2317 1348 1C0094E5 		ldr	r0, [r4, #28]
 2318 134c FEFFFFEB 		bl	_txe_mutex_put
 2319              	.LVL176:
 772:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2320              		.loc 1 772 0
 2321 1350 1C009DE5 		ldr	r0, [sp, #28]
 2322 1354 877087E0 		add	r7, r7, r7, asl #1
 2323              	.LVL177:
 2324 1358 876186E0 		add	r6, r6, r7, asl #3
 2325 135c 0D00C6E5 		strb	r0, [r6, #13]
 773:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2326              		.loc 1 773 0
 2327 1360 14C09DE5 		ldr	ip, [sp, #20]
 775:../uvc.c      **** 							 break;
 2328              		.loc 1 775 0
 2329 1364 FFE0A0E3 		mov	lr, #255
 773:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2330              		.loc 1 773 0
 2331 1368 0EC0C6E5 		strb	ip, [r6, #14]
 774:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2332              		.loc 1 774 0
 2333 136c 1080C6E5 		strb	r8, [r6, #16]
 2334 1370 18309DE5 		ldr	r3, [sp, #24]
 775:../uvc.c      **** 							 break;
 2335              		.loc 1 775 0
 2336 1374 0E40A0E1 		mov	r4, lr
 2337 1378 56FEFFEA 		b	.L124
 2338              	.LVL178:
 2339              	.L171:
 735:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2340              		.loc 1 735 0 discriminator 1
 2341 137c 000058E3 		cmp	r8, #0
 2342 1380 1800000A 		beq	.L177
 733:../uvc.c      **** 							 break;
 2343              		.loc 1 733 0
 2344 1384 28E1A0E1 		mov	lr, r8, lsr #2
 2345 1388 00005EE3 		cmp	lr, #0
 2346 138c 03005813 		cmpne	r8, #3
 2347 1390 0020A083 		movhi	r2, #0
 2348 1394 0120A093 		movls	r2, #1
 2349              	.LVL179:
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2350              		.loc 1 417 0
 2351 1398 0E31A0E1 		mov	r3, lr, asl #2
 733:../uvc.c      **** 							 break;
 2352              		.loc 1 733 0
 2353 139c E701009A 		bls	.L204
 2354 13a0 D4179FE5 		ldr	r1, .L230+40
 2355 13a4 100081E2 		add	r0, r1, #16
 2356              	.LVL180:
 2357              	.L188:
 736:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2358              		.loc 1 736 0 discriminator 2
 2359 13a8 044090E4 		ldr	r4, [r0], #4
 2360 13ac 012082E2 		add	r2, r2, #1
 2361 13b0 FF2002E2 		and	r2, r2, #255
 2362 13b4 02005EE1 		cmp	lr, r2
 2363 13b8 044081E4 		str	r4, [r1], #4
 2364 13bc F9FFFF8A 		bhi	.L188
 736:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2365              		.loc 1 736 0 is_stmt 0
 2366 13c0 030058E1 		cmp	r8, r3
 2367 13c4 0700000A 		beq	.L177
 2368              	.LVL181:
 2369              	.L211:
 2370 13c8 90C79FE5 		ldr	ip, .L230+12
 2371 13cc 03E08CE0 		add	lr, ip, r3
 2372 13d0 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
 735:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2373              		.loc 1 735 0 is_stmt 1
 2374 13d4 013083E2 		add	r3, r3, #1
 2375 13d8 FF3003E2 		and	r3, r3, #255
 2376              	.LVL182:
 2377 13dc 030058E1 		cmp	r8, r3
 736:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2378              		.loc 1 736 0
 2379 13e0 4C10CEE5 		strb	r1, [lr, #76]
 735:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2380              		.loc 1 735 0
 2381 13e4 F7FFFF8A 		bhi	.L211
 2382              	.LVL183:
 2383              	.L177:
 738:../uvc.c      **** 					 		I2CCmdHandler();
 2384              		.loc 1 738 0
 2385 13e8 FEFFFFEB 		bl	I2CCmdHandler
 739:../uvc.c      **** 							 break;
 2386              		.loc 1 739 0
 2387 13ec FFE0A0E3 		mov	lr, #255
 738:../uvc.c      **** 					 		I2CCmdHandler();
 2388              		.loc 1 738 0
 2389 13f0 18309DE5 		ldr	r3, [sp, #24]
 2390 13f4 1CC09DE5 		ldr	ip, [sp, #28]
 739:../uvc.c      **** 							 break;
 2391              		.loc 1 739 0
 2392 13f8 0E40A0E1 		mov	r4, lr
 2393 13fc 35FEFFEA 		b	.L124
 2394              	.LVL184:
 2395              	.L170:
 729:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2396              		.loc 1 729 0
 2397 1400 70479FE5 		ldr	r4, .L230+36
 2398 1404 0010E0E3 		mvn	r1, #0
 2399 1408 1C0094E5 		ldr	r0, [r4, #28]
 2400 140c FEFFFFEB 		bl	_txe_mutex_get
 2401              	.LVL185:
 730:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2402              		.loc 1 730 0
 2403 1410 18009DE5 		ldr	r0, [sp, #24]
 2404 1414 00E0A0E3 		mov	lr, #0
 2405 1418 01C070E2 		rsbs	ip, r0, #1
 2406 141c 00C0A033 		movcc	ip, #0
 2407 1420 0A30A0E1 		mov	r3, sl
 2408 1424 1E10A0E3 		mov	r1, #30
 2409 1428 0920A0E1 		mov	r2, r9
 2410 142c 0400A0E1 		mov	r0, r4
 2411 1430 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2412 1434 FEFFFFEB 		bl	cmdSet
 731:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2413              		.loc 1 731 0
 2414 1438 1C0094E5 		ldr	r0, [r4, #28]
 2415 143c FEFFFFEB 		bl	_txe_mutex_put
 732:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2416              		.loc 1 732 0
 2417 1440 0130A0E3 		mov	r3, #1
 733:../uvc.c      **** 							 break;
 2418              		.loc 1 733 0
 2419 1444 FFE0A0E3 		mov	lr, #255
 732:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2420              		.loc 1 732 0
 2421 1448 6034C6E5 		strb	r3, [r6, #1120]
 2422 144c 1CC09DE5 		ldr	ip, [sp, #28]
 2423 1450 18309DE5 		ldr	r3, [sp, #24]
 733:../uvc.c      **** 							 break;
 2424              		.loc 1 733 0
 2425 1454 0E40A0E1 		mov	r4, lr
 2426 1458 1EFEFFEA 		b	.L124
 2427              	.LVL186:
 2428              	.L168:
 696:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2429              		.loc 1 696 0
 2430 145c 14479FE5 		ldr	r4, .L230+36
 692:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2431              		.loc 1 692 0
 2432 1460 E533C6E5 		strb	r3, [r6, #997]
 693:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2433              		.loc 1 693 0
 2434 1464 1C309DE5 		ldr	r3, [sp, #28]
 694:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2435              		.loc 1 694 0
 2436 1468 0170A0E3 		mov	r7, #1
 2437              	.LVL187:
 696:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2438              		.loc 1 696 0
 2439 146c 0010E0E3 		mvn	r1, #0
 693:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2440              		.loc 1 693 0
 2441 1470 E633C6E5 		strb	r3, [r6, #998]
 696:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2442              		.loc 1 696 0
 2443 1474 1C0094E5 		ldr	r0, [r4, #28]
 694:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2444              		.loc 1 694 0
 2445 1478 E873C6E5 		strb	r7, [r6, #1000]
 2446              	.LVL188:
 696:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2447              		.loc 1 696 0
 2448 147c FEFFFFEB 		bl	_txe_mutex_get
 2449              	.LVL189:
 697:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2450              		.loc 1 697 0
 2451 1480 18C09DE5 		ldr	ip, [sp, #24]
 2452 1484 0400A0E1 		mov	r0, r4
 2453 1488 00C08DE5 		str	ip, [sp, #0]
 2454 148c 1910A0E3 		mov	r1, #25
 2455 1490 00C0A0E3 		mov	ip, #0
 2456 1494 0920A0E1 		mov	r2, r9
 2457 1498 0A30A0E1 		mov	r3, sl
 2458 149c 04C08DE5 		str	ip, [sp, #4]
 2459 14a0 FEFFFFEB 		bl	cmdSet
 698:../uvc.c      **** 							 if(getData != 0){
 2460              		.loc 1 698 0
 2461 14a4 18009DE5 		ldr	r0, [sp, #24]
 2462 14a8 000050E3 		cmp	r0, #0
 2463 14ac 0700000A 		beq	.L184
 2464              	.LVL190:
 700:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2465              		.loc 1 700 0
 2466 14b0 1CE09DE5 		ldr	lr, [sp, #28]
 2467 14b4 0400A0E1 		mov	r0, r4
 2468 14b8 1910A0E3 		mov	r1, #25
 2469 14bc 0B20A0E1 		mov	r2, fp
 2470 14c0 0A30A0E1 		mov	r3, sl
 2471 14c4 00E08DE5 		str	lr, [sp, #0]
 2472 14c8 04708DE5 		str	r7, [sp, #4]
 2473 14cc FEFFFFEB 		bl	cmdSet
 2474              	.LVL191:
 2475              	.L184:
 702:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2476              		.loc 1 702 0
 2477 14d0 1C0094E5 		ldr	r0, [r4, #28]
 2478 14d4 FEFFFFEB 		bl	_txe_mutex_put
 703:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2479              		.loc 1 703 0
 2480 14d8 80069FE5 		ldr	r0, .L230+12
 2481 14dc 7C169FE5 		ldr	r1, .L230+12
 2482 14e0 5EC0D0E5 		ldrb	ip, [r0, #94]	@ zero_extendqisi2
 2483 14e4 5F40D1E5 		ldrb	r4, [r1, #95]	@ zero_extendqisi2
 2484 14e8 5D30D0E5 		ldrb	r3, [r0, #93]	@ zero_extendqisi2
 2485 14ec 5C20D0E5 		ldrb	r2, [r0, #92]	@ zero_extendqisi2
 2486 14f0 88169FE5 		ldr	r1, .L230+44
 2487 14f4 0400A0E3 		mov	r0, #4
 2488 14f8 00C08DE5 		str	ip, [sp, #0]
 2489 14fc 04408DE5 		str	r4, [sp, #4]
 2490 1500 FEFFFFEB 		bl	CyU3PDebugPrint
 704:../uvc.c      **** 							 break;
 2491              		.loc 1 704 0
 2492 1504 FFE0A0E3 		mov	lr, #255
 703:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2493              		.loc 1 703 0
 2494 1508 18309DE5 		ldr	r3, [sp, #24]
 2495 150c 1CC09DE5 		ldr	ip, [sp, #28]
 704:../uvc.c      **** 							 break;
 2496              		.loc 1 704 0
 2497 1510 0E40A0E1 		mov	r4, lr
 2498 1514 EFFDFFEA 		b	.L124
 2499              	.LVL192:
 2500              	.L167:
 659:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2501              		.loc 1 659 0
 2502 1518 001053E2 		subs	r1, r3, #0
 658:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2503              		.loc 1 658 0
 2504 151c 0D13C6E5 		strb	r1, [r6, #781]
 2505 1520 2C369FE5 		ldr	r3, .L230
 659:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2506              		.loc 1 659 0
 2507 1524 3C01001A 		bne	.L178
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2508              		.loc 1 660 0
 2509 1528 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2510              	.LVL193:
 2511 152c 020052E3 		cmp	r2, #2
 2512 1530 08005213 		cmpne	r2, #8
 2513 1534 0300000A 		beq	.L179
 661:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2514              		.loc 1 661 0
 2515 1538 010052E3 		cmp	r2, #1
 662:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2516              		.loc 1 662 0
 2517 153c 07208202 		addeq	r2, r2, #7
 664:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2518              		.loc 1 664 0
 2519 1540 0220A013 		movne	r2, #2
 2520 1544 B924C3E5 		strb	r2, [r3, #1209]
 2521              	.LVL194:
 2522              	.L179:
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2523              		.loc 1 686 0
 2524 1548 28469FE5 		ldr	r4, .L230+36
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2525              		.loc 1 684 0
 2526 154c 0120A0E3 		mov	r2, #1
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2527              		.loc 1 686 0
 2528 1550 0010E0E3 		mvn	r1, #0
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2529              		.loc 1 684 0
 2530 1554 1023C6E5 		strb	r2, [r6, #784]
 2531              	.LVL195:
 686:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2532              		.loc 1 686 0
 2533 1558 1C0094E5 		ldr	r0, [r4, #28]
 2534 155c FEFFFFEB 		bl	_txe_mutex_get
 687:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2535              		.loc 1 687 0
 2536 1560 18C09DE5 		ldr	ip, [sp, #24]
 2537 1564 1010A0E3 		mov	r1, #16
 2538 1568 00C08DE5 		str	ip, [sp, #0]
 2539 156c 0920A0E1 		mov	r2, r9
 2540 1570 0A30A0E1 		mov	r3, sl
 2541 1574 0400A0E1 		mov	r0, r4
 2542 1578 00C0A0E3 		mov	ip, #0
 2543              	.LVL196:
 2544              	.L220:
 937:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2545              		.loc 1 937 0
 2546 157c 04C08DE5 		str	ip, [sp, #4]
 2547 1580 FEFFFFEB 		bl	cmdSet
 938:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2548              		.loc 1 938 0
 2549 1584 1C0094E5 		ldr	r0, [r4, #28]
 2550 1588 FEFFFFEB 		bl	_txe_mutex_put
 940:../uvc.c      **** 					 		 break;
 2551              		.loc 1 940 0
 2552 158c FFE0A0E3 		mov	lr, #255
 938:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2553              		.loc 1 938 0
 2554 1590 18309DE5 		ldr	r3, [sp, #24]
 2555 1594 1CC09DE5 		ldr	ip, [sp, #28]
 940:../uvc.c      **** 					 		 break;
 2556              		.loc 1 940 0
 2557 1598 0E40A0E1 		mov	r4, lr
 2558 159c CDFDFFEA 		b	.L124
 2559              	.LVL197:
 2560              	.L169:
 707:../uvc.c      **** 							 if(Data0 <= 3){
 2561              		.loc 1 707 0
 2562 15a0 030053E3 		cmp	r3, #3
 708:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2563              		.loc 1 708 0
 2564 15a4 B4259F95 		ldrls	r2, .L230+12
 2565              	.LVL198:
 711:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2566              		.loc 1 711 0
 2567 15a8 B0E59F85 		ldrhi	lr, .L230+12
 2568 15ac 0340A0E1 		mov	r4, r3
 2569              	.LVL199:
 708:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2570              		.loc 1 708 0
 2571 15b0 0030A093 		movls	r3, #0
 2572 15b4 7C30C295 		strlsb	r3, [r2, #124]
 2573              	.LVL200:
 711:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2574              		.loc 1 711 0
 2575 15b8 0120A083 		movhi	r2, #1
 2576 15bc 18209D95 		ldrls	r2, [sp, #24]
 708:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2577              		.loc 1 708 0
 2578 15c0 0430A091 		movls	r3, r4
 711:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2579              		.loc 1 711 0
 2580 15c4 7C20CE85 		strhib	r2, [lr, #124]
 2581 15c8 0420A081 		movhi	r2, r4
 717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2582              		.loc 1 717 0
 2583 15cc A4459FE5 		ldr	r4, .L230+36
 712:../uvc.c      **** 								 Data1 = Data0-4;
 2584              		.loc 1 712 0
 2585 15d0 04304382 		subhi	r3, r3, #4
 2586              	.LVL201:
 714:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2587              		.loc 1 714 0
 2588 15d4 2D24C6E5 		strb	r2, [r6, #1069]
 716:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2589              		.loc 1 716 0
 2590 15d8 0120A0E3 		mov	r2, #1
 717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2591              		.loc 1 717 0
 2592 15dc 0010E0E3 		mvn	r1, #0
 715:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2593              		.loc 1 715 0
 2594 15e0 8D31C6E5 		strb	r3, [r6, #397]
 716:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2595              		.loc 1 716 0
 2596 15e4 3024C6E5 		strb	r2, [r6, #1072]
 717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2597              		.loc 1 717 0
 2598 15e8 1C0094E5 		ldr	r0, [r4, #28]
 2599 15ec FEFFFFEB 		bl	_txe_mutex_get
 2600              	.LVL202:
 718:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2601              		.loc 1 718 0
 2602 15f0 18C09DE5 		ldr	ip, [sp, #24]
 2603 15f4 1C10A0E3 		mov	r1, #28
 2604 15f8 00C08DE5 		str	ip, [sp, #0]
 2605 15fc 0920A0E1 		mov	r2, r9
 2606 1600 0A30A0E1 		mov	r3, sl
 2607 1604 0400A0E1 		mov	r0, r4
 2608 1608 00C0A0E3 		mov	ip, #0
 2609 160c DAFFFFEA 		b	.L220
 2610              	.LVL203:
 2611              	.L166:
 868:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2612              		.loc 1 868 0
 2613 1610 60459FE5 		ldr	r4, .L230+36
 2614 1614 0010E0E3 		mvn	r1, #0
 2615 1618 1C0094E5 		ldr	r0, [r4, #28]
 2616 161c FEFFFFEB 		bl	_txe_mutex_get
 2617              	.LVL204:
 869:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2618              		.loc 1 869 0
 2619 1620 18C09DE5 		ldr	ip, [sp, #24]
 2620 1624 0B10A0E3 		mov	r1, #11
 2621 1628 0920A0E1 		mov	r2, r9
 2622 162c 0A30A0E1 		mov	r3, sl
 2623 1630 0400A0E1 		mov	r0, r4
 2624 1634 00C08DE5 		str	ip, [sp, #0]
 2625 1638 00C0A0E3 		mov	ip, #0
 2626 163c 04C08DE5 		str	ip, [sp, #4]
 2627 1640 FEFFFFEB 		bl	cmdSet
 2628              	.LVL205:
 871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2629              		.loc 1 871 0
 2630 1644 1CE09DE5 		ldr	lr, [sp, #28]
 2631 1648 0B10A0E3 		mov	r1, #11
 2632 164c 0B20A0E1 		mov	r2, fp
 2633 1650 0A30A0E1 		mov	r3, sl
 2634 1654 0170A0E3 		mov	r7, #1
 2635              	.LVL206:
 2636 1658 0400A0E1 		mov	r0, r4
 2637 165c 00E08DE5 		str	lr, [sp, #0]
 2638 1660 04708DE5 		str	r7, [sp, #4]
 2639 1664 FEFFFFEB 		bl	cmdSet
 872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2640              		.loc 1 872 0
 2641 1668 1C0094E5 		ldr	r0, [r4, #28]
 2642 166c FEFFFFEB 		bl	_txe_mutex_put
 874:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2643              		.loc 1 874 0
 2644 1670 18109DE5 		ldr	r1, [sp, #24]
 875:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2645              		.loc 1 875 0
 2646 1674 1C209DE5 		ldr	r2, [sp, #28]
 877:../uvc.c      **** 							 break;
 2647              		.loc 1 877 0
 2648 1678 FFE0A0E3 		mov	lr, #255
 874:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2649              		.loc 1 874 0
 2650 167c 9014C6E5 		strb	r1, [r6, #1168]
 875:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2651              		.loc 1 875 0
 2652 1680 9224C6E5 		strb	r2, [r6, #1170]
 876:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2653              		.loc 1 876 0
 2654 1684 9872C6E5 		strb	r7, [r6, #664]
 2655 1688 0130A0E1 		mov	r3, r1
 2656 168c 02C0A0E1 		mov	ip, r2
 877:../uvc.c      **** 							 break;
 2657              		.loc 1 877 0
 2658 1690 0E40A0E1 		mov	r4, lr
 2659 1694 8FFDFFEA 		b	.L124
 2660              	.LVL207:
 2661              	.L165:
 854:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2662              		.loc 1 854 0
 2663 1698 D8449FE5 		ldr	r4, .L230+36
 2664 169c 0010E0E3 		mvn	r1, #0
 2665 16a0 1C0094E5 		ldr	r0, [r4, #28]
 2666 16a4 FEFFFFEB 		bl	_txe_mutex_get
 2667              	.LVL208:
 855:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2668              		.loc 1 855 0
 2669 16a8 18C09DE5 		ldr	ip, [sp, #24]
 2670 16ac 00E0A0E3 		mov	lr, #0
 2671 16b0 0610A0E3 		mov	r1, #6
 2672 16b4 0920A0E1 		mov	r2, r9
 2673 16b8 0A30A0E1 		mov	r3, sl
 2674 16bc 0400A0E1 		mov	r0, r4
 2675 16c0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2676 16c4 FEFFFFEB 		bl	cmdSet
 2677              	.LVL209:
 857:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2678              		.loc 1 857 0
 2679 16c8 18C09DE5 		ldr	ip, [sp, #24]
 2680 16cc 0A30A0E1 		mov	r3, sl
 2681 16d0 0170A0E3 		mov	r7, #1
 2682              	.LVL210:
 2683 16d4 0610A0E3 		mov	r1, #6
 2684 16d8 0B20A0E1 		mov	r2, fp
 2685 16dc 0400A0E1 		mov	r0, r4
 2686 16e0 00C08DE5 		str	ip, [sp, #0]
 2687 16e4 04708DE5 		str	r7, [sp, #4]
 2688 16e8 FEFFFFEB 		bl	cmdSet
 858:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2689              		.loc 1 858 0
 2690 16ec 1C0094E5 		ldr	r0, [r4, #28]
 2691 16f0 FEFFFFEB 		bl	_txe_mutex_put
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2692              		.loc 1 859 0
 2693 16f4 18409DE5 		ldr	r4, [sp, #24]
 861:../uvc.c      **** 							 break;
 2694              		.loc 1 861 0
 2695 16f8 FFE0A0E3 		mov	lr, #255
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2696              		.loc 1 859 0
 2697 16fc 1D42C6E5 		strb	r4, [r6, #541]
 860:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2698              		.loc 1 860 0
 2699 1700 0430A0E1 		mov	r3, r4
 2700 1704 2072C6E5 		strb	r7, [r6, #544]
 2701 1708 1CC09DE5 		ldr	ip, [sp, #28]
 861:../uvc.c      **** 							 break;
 2702              		.loc 1 861 0
 2703 170c 0E40A0E1 		mov	r4, lr
 2704 1710 70FDFFEA 		b	.L124
 2705              	.LVL211:
 2706              	.L164:
 834:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2707              		.loc 1 834 0
 2708 1714 5C449FE5 		ldr	r4, .L230+36
 2709 1718 0010E0E3 		mvn	r1, #0
 2710 171c 1C0094E5 		ldr	r0, [r4, #28]
 2711 1720 FEFFFFEB 		bl	_txe_mutex_get
 2712              	.LVL212:
 835:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2713              		.loc 1 835 0
 2714 1724 18009DE5 		ldr	r0, [sp, #24]
 2715 1728 00C0A0E3 		mov	ip, #0
 2716 172c 803040E2 		sub	r3, r0, #128
 2717 1730 FF7003E2 		and	r7, r3, #255
 2718              	.LVL213:
 2719 1734 0510A0E3 		mov	r1, #5
 2720 1738 0920A0E1 		mov	r2, r9
 2721 173c 0A30A0E1 		mov	r3, sl
 2722 1740 0400A0E1 		mov	r0, r4
 2723 1744 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2724 1748 FEFFFFEB 		bl	cmdSet
 2725              	.LVL214:
 837:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2726              		.loc 1 837 0
 2727 174c 18109DE5 		ldr	r1, [sp, #24]
 2728 1750 DC20A0E3 		mov	r2, #220
 2729 1754 767041E2 		sub	r7, r1, #118
 2730 1758 FFE007E2 		and	lr, r7, #255
 2731 175c 0510A0E3 		mov	r1, #5
 2732 1760 0170A0E3 		mov	r7, #1
 2733 1764 0A30A0E1 		mov	r3, sl
 2734 1768 0400A0E1 		mov	r0, r4
 2735 176c 00E08DE5 		str	lr, [sp, #0]
 2736 1770 04708DE5 		str	r7, [sp, #4]
 2737 1774 FEFFFFEB 		bl	cmdSet
 2738              	.LVL215:
 839:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2739              		.loc 1 839 0
 2740 1778 18209DE5 		ldr	r2, [sp, #24]
 2741 177c 0510A0E3 		mov	r1, #5
 2742 1780 7E0082E2 		add	r0, r2, #126
 2743 1784 FFC000E2 		and	ip, r0, #255
 2744 1788 DE20A0E3 		mov	r2, #222
 2745 178c 0A30A0E1 		mov	r3, sl
 2746 1790 0400A0E1 		mov	r0, r4
 2747 1794 00C08DE5 		str	ip, [sp, #0]
 2748 1798 02C0A0E3 		mov	ip, #2
 2749 179c 04C08DE5 		str	ip, [sp, #4]
 2750 17a0 FEFFFFEB 		bl	cmdSet
 2751              	.LVL216:
 841:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2752              		.loc 1 841 0
 2753 17a4 18309DE5 		ldr	r3, [sp, #24]
 2754 17a8 E020A0E3 		mov	r2, #224
 2755 17ac 721083E2 		add	r1, r3, #114
 2756 17b0 FFC001E2 		and	ip, r1, #255
 2757 17b4 0A30A0E1 		mov	r3, sl
 2758 17b8 0510A0E3 		mov	r1, #5
 2759 17bc 0400A0E1 		mov	r0, r4
 2760 17c0 00C08DE5 		str	ip, [sp, #0]
 2761 17c4 03C0A0E3 		mov	ip, #3
 2762 17c8 04C08DE5 		str	ip, [sp, #4]
 2763 17cc FEFFFFEB 		bl	cmdSet
 2764              	.LVL217:
 843:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2765              		.loc 1 843 0
 2766 17d0 18209DE5 		ldr	r2, [sp, #24]
 2767 17d4 0510A0E3 		mov	r1, #5
 2768 17d8 6F0042E2 		sub	r0, r2, #111
 2769 17dc FFC000E2 		and	ip, r0, #255
 2770 17e0 DD20A0E3 		mov	r2, #221
 2771 17e4 0A30A0E1 		mov	r3, sl
 2772 17e8 0400A0E1 		mov	r0, r4
 2773 17ec 00C08DE5 		str	ip, [sp, #0]
 2774 17f0 04C0A0E3 		mov	ip, #4
 2775 17f4 04C08DE5 		str	ip, [sp, #4]
 2776 17f8 FEFFFFEB 		bl	cmdSet
 2777              	.LVL218:
 845:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2778              		.loc 1 845 0
 2779 17fc 5C339FE5 		ldr	r3, .L230+12
 2780 1800 05E0A0E3 		mov	lr, #5
 2781 1804 5C10D3E5 		ldrb	r1, [r3, #92]	@ zero_extendqisi2
 2782 1808 0400A0E1 		mov	r0, r4
 2783 180c 7F2081E2 		add	r2, r1, #127
 2784 1810 FFC002E2 		and	ip, r2, #255
 2785 1814 0E10A0E1 		mov	r1, lr
 2786 1818 0A30A0E1 		mov	r3, sl
 2787 181c 0B20A0E1 		mov	r2, fp
 2788 1820 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2789 1824 FEFFFFEB 		bl	cmdSet
 846:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2790              		.loc 1 846 0
 2791 1828 1C0094E5 		ldr	r0, [r4, #28]
 2792 182c FEFFFFEB 		bl	_txe_mutex_put
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2793              		.loc 1 848 0
 2794 1830 28039FE5 		ldr	r0, .L230+12
 850:../uvc.c      **** 							 break;
 2795              		.loc 1 850 0
 2796 1834 FFE0A0E3 		mov	lr, #255
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2797              		.loc 1 848 0
 2798 1838 5C30D0E5 		ldrb	r3, [r0, #92]	@ zero_extendqisi2
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2799              		.loc 1 849 0
 2800 183c 0872C6E5 		strb	r7, [r6, #520]
 848:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2801              		.loc 1 848 0
 2802 1840 801043E2 		sub	r1, r3, #128
 2803 1844 0512C6E5 		strb	r1, [r6, #517]
 849:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2804              		.loc 1 849 0
 2805 1848 18309DE5 		ldr	r3, [sp, #24]
 2806 184c 1CC09DE5 		ldr	ip, [sp, #28]
 850:../uvc.c      **** 							 break;
 2807              		.loc 1 850 0
 2808 1850 0E40A0E1 		mov	r4, lr
 2809 1854 1FFDFFEA 		b	.L124
 2810              	.LVL219:
 2811              	.L163:
 881:../uvc.c      **** 							 Data0 = Data0 - 1;
 2812              		.loc 1 881 0
 2813 1858 011043E2 		sub	r1, r3, #1
 2814 185c 0300A0E1 		mov	r0, r3
 2815              	.LVL220:
 882:../uvc.c      **** 							 is60Hz = Data0;
 2816              		.loc 1 882 0
 2817 1860 F8229FE5 		ldr	r2, .L230+12
 2818              	.LVL221:
 881:../uvc.c      **** 							 Data0 = Data0 - 1;
 2819              		.loc 1 881 0
 2820 1864 FF3001E2 		and	r3, r1, #255
 2821              	.LVL222:
 894:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2822              		.loc 1 894 0
 2823 1868 F0E29FE5 		ldr	lr, .L230+12
 888:../uvc.c      **** 							 else if(Data0 >2)
 2824              		.loc 1 888 0
 2825 186c 020053E3 		cmp	r3, #2
 880:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2826              		.loc 1 880 0
 2827 1870 ED01C6E5 		strb	r0, [r6, #493]
 891:../uvc.c      **** 								 is60Hz = CyTrue;
 2828              		.loc 1 891 0
 2829 1874 0100A083 		movhi	r0, #1
 882:../uvc.c      **** 							 is60Hz = Data0;
 2830              		.loc 1 882 0
 2831 1878 583082E5 		str	r3, [r2, #88]
 2832              	.LVL223:
 891:../uvc.c      **** 								 is60Hz = CyTrue;
 2833              		.loc 1 891 0
 2834 187c 58008285 		strhi	r0, [r2, #88]
 894:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2835              		.loc 1 894 0
 2836 1880 28009EE5 		ldr	r0, [lr, #40]
 2837 1884 010050E3 		cmp	r0, #1
 2838 1888 8200000A 		beq	.L228
 2839              	.LVL224:
 2840              	.L194:
 920:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2841              		.loc 1 920 0
 2842 188c 01C0A0E3 		mov	ip, #1
 921:../uvc.c      **** 							 break;
 2843              		.loc 1 921 0
 2844 1890 FFE0A0E3 		mov	lr, #255
 920:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2845              		.loc 1 920 0
 2846 1894 F0C1C6E5 		strb	ip, [r6, #496]
 2847 1898 18309DE5 		ldr	r3, [sp, #24]
 2848 189c 1CC09DE5 		ldr	ip, [sp, #28]
 921:../uvc.c      **** 							 break;
 2849              		.loc 1 921 0
 2850 18a0 0E40A0E1 		mov	r4, lr
 2851 18a4 0BFDFFEA 		b	.L124
 2852              	.LVL225:
 2853              	.L162:
 816:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2854              		.loc 1 816 0
 2855 18a8 C8429FE5 		ldr	r4, .L230+36
 2856 18ac 0010E0E3 		mvn	r1, #0
 2857 18b0 1C0094E5 		ldr	r0, [r4, #28]
 2858 18b4 FEFFFFEB 		bl	_txe_mutex_get
 2859              	.LVL226:
 818:../uvc.c      **** 							  if(Data0&0x80){
 2860              		.loc 1 818 0
 2861 18b8 18209DE5 		ldr	r2, [sp, #24]
 823:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2862              		.loc 1 823 0
 2863 18bc 00C0A0E3 		mov	ip, #0
 818:../uvc.c      **** 							  if(Data0&0x80){
 2864              		.loc 1 818 0
 2865 18c0 800012E3 		tst	r2, #128
 819:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2866              		.loc 1 819 0
 2867 18c4 80704212 		subne	r7, r2, #128
 2868              	.LVL227:
 821:../uvc.c      **** 								  Data0 = ~Data0;
 2869              		.loc 1 821 0
 2870 18c8 0270E001 		mvneq	r7, r2
 823:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2871              		.loc 1 823 0
 2872 18cc 0A30A0E1 		mov	r3, sl
 821:../uvc.c      **** 								  Data0 = ~Data0;
 2873              		.loc 1 821 0
 2874 18d0 FF7007E2 		and	r7, r7, #255
 2875              	.LVL228:
 823:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2876              		.loc 1 823 0
 2877 18d4 0110A0E3 		mov	r1, #1
 2878 18d8 0B20A0E1 		mov	r2, fp
 2879 18dc 94029FE5 		ldr	r0, .L230+36
 2880 18e0 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2881 18e4 FEFFFFEB 		bl	cmdSet
 824:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2882              		.loc 1 824 0
 2883 18e8 1C0094E5 		ldr	r0, [r4, #28]
 2884 18ec FEFFFFEB 		bl	_txe_mutex_put
 830:../uvc.c      **** 							 break;
 2885              		.loc 1 830 0
 2886 18f0 FFE0A0E3 		mov	lr, #255
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2887              		.loc 1 827 0
 2888 18f4 0100A0E3 		mov	r0, #1
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2889              		.loc 1 826 0
 2890 18f8 A571C6E5 		strb	r7, [r6, #421]
 827:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2891              		.loc 1 827 0
 2892 18fc A801C6E5 		strb	r0, [r6, #424]
 2893 1900 18309DE5 		ldr	r3, [sp, #24]
 2894 1904 1CC09DE5 		ldr	ip, [sp, #28]
 830:../uvc.c      **** 							 break;
 2895              		.loc 1 830 0
 2896 1908 0E40A0E1 		mov	r4, lr
 2897 190c F1FCFFEA 		b	.L124
 2898              	.LVL229:
 2899              	.L160:
 944:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2900              		.loc 1 944 0
 2901 1910 60729FE5 		ldr	r7, .L230+36
 2902              	.LVL230:
 2903 1914 0010E0E3 		mvn	r1, #0
 2904 1918 1C0097E5 		ldr	r0, [r7, #28]
 2905 191c FEFFFFEB 		bl	_txe_mutex_get
 2906              	.LVL231:
 945:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2907              		.loc 1 945 0
 2908 1920 18C09DE5 		ldr	ip, [sp, #24]
 2909 1924 0410A0E1 		mov	r1, r4
 2910 1928 0A30A0E1 		mov	r3, sl
 2911 192c 0920A0E1 		mov	r2, r9
 2912 1930 00C08DE5 		str	ip, [sp, #0]
 2913 1934 0700A0E1 		mov	r0, r7
 2914 1938 00C0A0E3 		mov	ip, #0
 2915 193c 04C08DE5 		str	ip, [sp, #4]
 2916 1940 FEFFFFEB 		bl	cmdSet
 946:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2917              		.loc 1 946 0
 2918 1944 1C0097E5 		ldr	r0, [r7, #28]
 2919 1948 FEFFFFEB 		bl	_txe_mutex_put
 948:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2920              		.loc 1 948 0
 2921 194c 18109DE5 		ldr	r1, [sp, #24]
 2922 1950 844084E0 		add	r4, r4, r4, asl #1
 2923 1954 846186E0 		add	r6, r6, r4, asl #3
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2924              		.loc 1 949 0
 2925 1958 0130A0E3 		mov	r3, #1
 950:../uvc.c      **** 							 break;
 2926              		.loc 1 950 0
 2927 195c FFE0A0E3 		mov	lr, #255
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2928              		.loc 1 949 0
 2929 1960 9031C6E5 		strb	r3, [r6, #400]
 948:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2930              		.loc 1 948 0
 2931 1964 8D11C6E5 		strb	r1, [r6, #397]
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2932              		.loc 1 949 0
 2933 1968 0130A0E1 		mov	r3, r1
 2934 196c 1CC09DE5 		ldr	ip, [sp, #28]
 950:../uvc.c      **** 							 break;
 2935              		.loc 1 950 0
 2936 1970 0E40A0E1 		mov	r4, lr
 2937 1974 D7FCFFEA 		b	.L124
 2938              	.LVL232:
 2939              	.L161:
 925:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2940              		.loc 1 925 0
 2941 1978 E0219FE5 		ldr	r2, .L230+12
 2942              	.LVL233:
 924:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2943              		.loc 1 924 0
 2944 197c 0100A0E3 		mov	r0, #1
 925:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2945              		.loc 1 925 0
 2946 1980 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 923:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2947              		.loc 1 923 0
 2948 1984 8D31C6E5 		strb	r3, [r6, #397]
 925:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2949              		.loc 1 925 0
 2950 1988 010052E3 		cmp	r2, #1
 924:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2951              		.loc 1 924 0
 2952 198c 9001C6E5 		strb	r0, [r6, #400]
 2953 1990 0370A011 		movne	r7, r3
 2954              	.LVL234:
 925:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2955              		.loc 1 925 0
 2956 1994 3500000A 		beq	.L229
 2957              	.LVL235:
 2958              	.L201:
 936:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2959              		.loc 1 936 0
 2960 1998 D8419FE5 		ldr	r4, .L230+36
 2961 199c 0010E0E3 		mvn	r1, #0
 2962 19a0 1C0094E5 		ldr	r0, [r4, #28]
 934:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2963              		.loc 1 934 0
 2964 19a4 2D74C6E5 		strb	r7, [r6, #1069]
 2965              	.LVL236:
 936:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2966              		.loc 1 936 0
 2967 19a8 FEFFFFEB 		bl	_txe_mutex_get
 937:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2968              		.loc 1 937 0
 2969 19ac 00C0A0E3 		mov	ip, #0
 2970 19b0 0C10A0E1 		mov	r1, ip
 2971 19b4 0920A0E1 		mov	r2, r9
 2972 19b8 0A30A0E1 		mov	r3, sl
 2973 19bc 0400A0E1 		mov	r0, r4
 2974 19c0 00708DE5 		str	r7, [sp, #0]
 2975 19c4 ECFEFFEA 		b	.L220
 2976              	.LVL237:
 2977              	.L159:
 953:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2978              		.loc 1 953 0
 2979 19c8 0400A0E3 		mov	r0, #4
 2980              	.LVL238:
 2981 19cc B0119FE5 		ldr	r1, .L230+48
 2982 19d0 FEFFFFEB 		bl	CyU3PDebugPrint
 2983              	.LVL239:
 2984 19d4 FFE0A0E3 		mov	lr, #255
 2985 19d8 0E40A0E1 		mov	r4, lr
 2986 19dc 0EC0A0E1 		mov	ip, lr
 2987 19e0 0E30A0E1 		mov	r3, lr
 2988 19e4 BBFCFFEA 		b	.L124
 2989              	.LVL240:
 2990              	.L227:
 473:../uvc.c      **** 						if(sendData >= 3){
 2991              		.loc 1 473 0
 2992 19e8 020054E3 		cmp	r4, #2
 2993 19ec 04408492 		addls	r4, r4, #4
 2994              	.LVL241:
 2995 19f0 FF400492 		andls	r4, r4, #255
 2996 19f4 E2FDFF9A 		bls	.L137
 474:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2997              		.loc 1 474 0
 2998 19f8 0430A0E1 		mov	r3, r4
 2999 19fc 0400A0E3 		mov	r0, #4
 3000 1a00 80119FE5 		ldr	r1, .L230+52
 3001 1a04 FEFFFFEB 		bl	CyU3PDebugPrint
 3002              	.LVL242:
 476:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3003              		.loc 1 476 0
 3004 1a08 44319FE5 		ldr	r3, .L230
 3005 1a0c 0020A0E3 		mov	r2, #0
 3006 1a10 0440A0E3 		mov	r4, #4
 3007 1a14 2D24C3E5 		strb	r2, [r3, #1069]
 3008              	.LVL243:
 3009 1a18 D9FDFFEA 		b	.L137
 3010              	.LVL244:
 3011              	.L178:
 669:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3012              		.loc 1 669 0
 3013 1a1c B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 3014              	.LVL245:
 668:../uvc.c      **** 								 Data1 = Data0 - 1;
 3015              		.loc 1 668 0
 3016 1a20 014041E2 		sub	r4, r1, #1
 669:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3017              		.loc 1 669 0
 3018 1a24 040052E3 		cmp	r2, #4
 3019 1a28 01005213 		cmpne	r2, #1
 668:../uvc.c      **** 								 Data1 = Data0 - 1;
 3020              		.loc 1 668 0
 3021 1a2c FF1004E2 		and	r1, r4, #255
 3022              	.LVL246:
 669:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3023              		.loc 1 669 0
 3024 1a30 0300000A 		beq	.L181
 670:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 3025              		.loc 1 670 0
 3026 1a34 080052E3 		cmp	r2, #8
 671:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 3027              		.loc 1 671 0
 3028 1a38 0120A003 		moveq	r2, #1
 673:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 3029              		.loc 1 673 0
 3030 1a3c 0420A013 		movne	r2, #4
 3031 1a40 B924C3E5 		strb	r2, [r3, #1209]
 3032              	.L181:
 676:../uvc.c      **** 								 if(Data1 < 8){
 3033              		.loc 1 676 0
 3034 1a44 070051E3 		cmp	r1, #7
 677:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3035              		.loc 1 677 0
 3036 1a48 3C319F95 		ldrls	r3, .L230+56
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3037              		.loc 1 680 0
 3038 1a4c 0130A083 		movhi	r3, #1
 678:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3039              		.loc 1 678 0
 3040 1a50 81008390 		addls	r0, r3, r1, asl #1
 677:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3041              		.loc 1 677 0
 3042 1a54 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 678:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3043              		.loc 1 678 0
 3044 1a58 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3045              		.loc 1 680 0
 3046 1a5c E934C685 		strhib	r3, [r6, #1257]
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3047              		.loc 1 681 0
 3048 1a60 0030A083 		movhi	r3, #0
 677:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3049              		.loc 1 677 0
 3050 1a64 E924C695 		strlsb	r2, [r6, #1257]
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3051              		.loc 1 681 0
 3052 1a68 EA34C6E5 		strb	r3, [r6, #1258]
 3053 1a6c B5FEFFEA 		b	.L179
 3054              	.LVL247:
 3055              	.L229:
 927:../uvc.c      **** 								 if(Data0 < 3){
 3056              		.loc 1 927 0
 3057 1a70 020053E3 		cmp	r3, #2
 928:../uvc.c      **** 					 				 Data0 += 4;
 3058              		.loc 1 928 0
 3059 1a74 04708392 		addls	r7, r3, #4
 3060 1a78 FF700792 		andls	r7, r7, #255
 927:../uvc.c      **** 								 if(Data0 < 3){
 3061              		.loc 1 927 0
 3062 1a7c C5FFFF9A 		bls	.L201
 930:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3063              		.loc 1 930 0
 3064 1a80 0400A0E3 		mov	r0, #4
 3065 1a84 FC109FE5 		ldr	r1, .L230+52
 3066 1a88 18309DE5 		ldr	r3, [sp, #24]
 3067 1a8c FEFFFFEB 		bl	CyU3PDebugPrint
 3068              	.LVL248:
 931:../uvc.c      **** 									Data0 = 4; //set to default.
 3069              		.loc 1 931 0
 3070 1a90 0470A0E3 		mov	r7, #4
 3071 1a94 BFFFFFEA 		b	.L201
 3072              	.LVL249:
 3073              	.L228:
 897:../uvc.c      **** 			                       switch (setRes)
 3074              		.loc 1 897 0
 3075 1a98 7D10DEE5 		ldrb	r1, [lr, #125]	@ zero_extendqisi2
 3076 1a9c 020051E3 		cmp	r1, #2
 3077 1aa0 1C00000A 		beq	.L196
 3078 1aa4 030051E3 		cmp	r1, #3
 3079 1aa8 0E00000A 		beq	.L197
 3080 1aac 010051E3 		cmp	r1, #1
 3081 1ab0 75FFFF1A 		bne	.L194
 900:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3082              		.loc 1 900 0
 3083 1ab4 58209EE5 		ldr	r2, [lr, #88]
 3084 1ab8 0100A0E1 		mov	r0, r1
 3085 1abc 000052E3 		cmp	r2, #0
 3086 1ac0 2F1081E2 		add	r1, r1, #47
 3087 1ac4 E420A003 		moveq	r2, #228
 3088 1ac8 6420A013 		movne	r2, #100
 3089 1acc 5230A0E3 		mov	r3, #82
 3090 1ad0 FEFFFFEB 		bl	SensorSetIrisControl
 3091              	.LVL250:
 901:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3092              		.loc 1 901 0
 3093 1ad4 7D0FA0E3 		mov	r0, #500
 3094 1ad8 FEFFFFEB 		bl	_tx_thread_sleep
 903:../uvc.c      **** 			                         		break;
 3095              		.loc 1 903 0
 3096 1adc 6AFFFFEA 		b	.L194
 3097              	.LVL251:
 3098              	.L218:
 3099 1ae0 78009FE5 		ldr	r0, .L230+12
 3100 1ae4 95FDFFEA 		b	.L135
 3101              	.LVL252:
 3102              	.L197:
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3103              		.loc 1 910 0
 3104 1ae8 58409EE5 		ldr	r4, [lr, #88]
 3105 1aec 8CE4D6E5 		ldrb	lr, [r6, #1164]	@ zero_extendqisi2
 3106 1af0 000054E3 		cmp	r4, #0
 3107 1af4 C440A003 		moveq	r4, #196
 3108 1af8 4440A013 		movne	r4, #68
 3109 1afc 3010A0E3 		mov	r1, #48
 3110 1b00 0E2084E1 		orr	r2, r4, lr
 3111 1b04 5230A0E3 		mov	r3, #82
 3112 1b08 FEFFFFEB 		bl	SensorSetIrisControl
 3113              	.LVL253:
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3114              		.loc 1 911 0
 3115 1b0c 7D0FA0E3 		mov	r0, #500
 3116 1b10 FEFFFFEB 		bl	_tx_thread_sleep
 913:../uvc.c      **** 			                         		break;
 3117              		.loc 1 913 0
 3118 1b14 5CFFFFEA 		b	.L194
 3119              	.LVL254:
 3120              	.L196:
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3121              		.loc 1 905 0
 3122 1b18 58209EE5 		ldr	r2, [lr, #88]
 3123 1b1c 3010A0E3 		mov	r1, #48
 3124 1b20 000052E3 		cmp	r2, #0
 3125 1b24 D420A003 		moveq	r2, #212
 3126 1b28 5420A013 		movne	r2, #84
 3127 1b2c 5230A0E3 		mov	r3, #82
 3128 1b30 FEFFFFEB 		bl	SensorSetIrisControl
 3129              	.LVL255:
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3130              		.loc 1 906 0
 3131 1b34 7D0FA0E3 		mov	r0, #500
 3132 1b38 FEFFFFEB 		bl	_tx_thread_sleep
 908:../uvc.c      **** 			                         		break;
 3133              		.loc 1 908 0
 3134 1b3c 52FFFFEA 		b	.L194
 3135              	.LVL256:
 3136              	.L204:
 417:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3137              		.loc 1 417 0
 3138 1b40 0030A0E3 		mov	r3, #0
 3139 1b44 1FFEFFEA 		b	.L211
 3140              	.LVL257:
 3141              	.L203:
 3142 1b48 10009FE5 		ldr	r0, .L230+12
 3143 1b4c 0030A0E3 		mov	r3, #0
 3144 1b50 73FDFFEA 		b	.L210
 3145              	.L231:
 3146              		.align	2
 3147              	.L230:
 3148 1b54 00000000 		.word	.LANCHOR1
 3149 1b58 00000000 		.word	bRequest
 3150 1b5c 70030000 		.word	.LC21
 3151 1b60 00000000 		.word	.LANCHOR0
 3152 1b64 5C000000 		.word	.LANCHOR0+92
 3153 1b68 01000100 		.word	65537
 3154 1b6c FF00FF00 		.word	16711935
 3155 1b70 B0020000 		.word	.LC17
 3156 1b74 EC020000 		.word	.LC18
 3157 1b78 00000000 		.word	cmdQu
 3158 1b7c 4C000000 		.word	.LANCHOR0+76
 3159 1b80 14030000 		.word	.LC19
 3160 1b84 40030000 		.word	.LC20
 3161 1b88 78020000 		.word	.LC16
 3162 1b8c 00000000 		.word	.LANCHOR2
 3163              		.cfi_endproc
 3164              	.LFE2:
 3166              		.align	2
 3167              		.global	CTControlHandle
 3169              	CTControlHandle:
 3170              	.LFB3:
 969:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3171              		.loc 1 969 0
 3172              		.cfi_startproc
 3173              		@ args = 0, pretend = 0, frame = 64
 3174              		@ frame_needed = 0, uses_anonymous_args = 0
 3175              	.LVL258:
 3176 1b90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3177              	.LCFI15:
 3178              		.cfi_def_cfa_offset 36
 988:../uvc.c      ****     reqData = bRequest;
 3179              		.loc 1 988 0
 3180 1b94 60A99FE5 		ldr	sl, .L317
 3181              		.cfi_offset 14, -4
 3182              		.cfi_offset 11, -8
 3183              		.cfi_offset 10, -12
 3184              		.cfi_offset 9, -16
 3185              		.cfi_offset 8, -20
 3186              		.cfi_offset 7, -24
 3187              		.cfi_offset 6, -28
 3188              		.cfi_offset 5, -32
 3189              		.cfi_offset 4, -36
 980:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3190              		.loc 1 980 0
 3191 1b98 60899FE5 		ldr	r8, .L317+4
 988:../uvc.c      ****     reqData = bRequest;
 3192              		.loc 1 988 0
 3193 1b9c 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 980:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3194              		.loc 1 980 0
 3195 1ba0 8090A0E1 		mov	r9, r0, asl #1
 3196 1ba4 002089E0 		add	r2, r9, r0
 3197 1ba8 822188E0 		add	r2, r8, r2, asl #3
 990:../uvc.c      ****     switch (bRequest)
 3198              		.loc 1 990 0
 3199 1bac 830055E3 		cmp	r5, #131
 969:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3200              		.loc 1 969 0
 3201 1bb0 5CD04DE2 		sub	sp, sp, #92
 3202              	.LCFI16:
 3203              		.cfi_def_cfa_offset 128
 969:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3204              		.loc 1 969 0
 3205 1bb4 0060A0E1 		mov	r6, r0
 980:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3206              		.loc 1 980 0
 3207 1bb8 A334D2E5 		ldrb	r3, [r2, #1187]	@ zero_extendqisi2
 3208              	.LVL259:
 981:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3209              		.loc 1 981 0
 3210 1bbc 94B4D2E5 		ldrb	fp, [r2, #1172]	@ zero_extendqisi2
 3211              	.LVL260:
 983:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3212              		.loc 1 983 0
 3213 1bc0 9674D2E5 		ldrb	r7, [r2, #1174]	@ zero_extendqisi2
 3214              	.LVL261:
 990:../uvc.c      ****     switch (bRequest)
 3215              		.loc 1 990 0
 3216 1bc4 7600000A 		beq	.L237
 3217 1bc8 2100009A 		bls	.L312
 3218 1bcc 850055E3 		cmp	r5, #133
 3219 1bd0 5900000A 		beq	.L239
 3220 1bd4 4E00003A 		bcc	.L238
 3221 1bd8 860055E3 		cmp	r5, #134
 3222 1bdc 8000000A 		beq	.L240
 3223 1be0 870055E3 		cmp	r5, #135
 3224 1be4 7600000A 		beq	.L313
 3225              	.L233:
1197:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3226              		.loc 1 1197 0
 3227 1be8 0000A0E3 		mov	r0, #0
 3228              	.LVL262:
 3229 1bec 0110A0E3 		mov	r1, #1
 3230 1bf0 0020A0E1 		mov	r2, r0
 3231 1bf4 FEFFFFEB 		bl	CyU3PUsbStall
 3232              	.LVL263:
 3233 1bf8 04499FE5 		ldr	r4, .L317+8
1198:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3234              		.loc 1 1198 0
 3235 1bfc 0620A0E1 		mov	r2, r6
 3236 1c00 0400A0E3 		mov	r0, #4
 3237 1c04 FC189FE5 		ldr	r1, .L317+12
 3238 1c08 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3239 1c0c FEFFFFEB 		bl	CyU3PDebugPrint
1199:../uvc.c      **** 			  break;
 3240              		.loc 1 1199 0
 3241 1c10 FFC0A0E3 		mov	ip, #255
 3242 1c14 0C60A0E1 		mov	r6, ip
 3243 1c18 0C80A0E1 		mov	r8, ip
 3244              	.LVL264:
 3245              	.L243:
1203:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3246              		.loc 1 1203 0
 3247 1c1c 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3248 1c20 08C08DE5 		str	ip, [sp, #8]
 3249 1c24 E0189FE5 		ldr	r1, .L317+16
 3250 1c28 FFC0A0E3 		mov	ip, #255
 3251 1c2c 0520A0E1 		mov	r2, r5
 3252 1c30 0830A0E1 		mov	r3, r8
 3253 1c34 0400A0E3 		mov	r0, #4
 3254 1c38 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3255 1c3c 0CC08DE5 		str	ip, [sp, #12]
 3256 1c40 10E08DE5 		str	lr, [sp, #16]
 3257 1c44 14708DE5 		str	r7, [sp, #20]
 3258 1c48 FEFFFFEB 		bl	CyU3PDebugPrint
1204:../uvc.c      **** }
 3259              		.loc 1 1204 0
 3260 1c4c 5CD08DE2 		add	sp, sp, #92
 3261 1c50 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3262              	.LVL265:
 3263              	.L312:
 990:../uvc.c      ****     switch (bRequest)
 3264              		.loc 1 990 0
 3265 1c54 810055E3 		cmp	r5, #129
 3266 1c58 4200000A 		beq	.L235
 3267 1c5c 1100009A 		bls	.L314
1019:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3268              		.loc 1 1019 0
 3269 1c60 9C489FE5 		ldr	r4, .L317+8
 3270 1c64 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3271              		.loc 1 1020 0
 3272 1c68 9864D2E5 		ldrb	r6, [r2, #1176]	@ zero_extendqisi2
1021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3273              		.loc 1 1021 0
 3274 1c6c 0A0050E3 		cmp	r0, #10
1019:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3275              		.loc 1 1019 0
 3276 1c70 5C10C4E5 		strb	r1, [r4, #92]
1020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3277              		.loc 1 1020 0
 3278 1c74 5D60C4E5 		strb	r6, [r4, #93]
1021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3279              		.loc 1 1021 0
 3280 1c78 2C00000A 		beq	.L311
 3281              	.LVL266:
 3282              	.L250:
1055:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3283              		.loc 1 1055 0
 3284 1c7c 00E0A0E3 		mov	lr, #0
 3285 1c80 5EE0C4E5 		strb	lr, [r4, #94]
 3286              	.L251:
1056:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3287              		.loc 1 1056 0
 3288 1c84 0030A0E3 		mov	r3, #0
1057:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3289              		.loc 1 1057 0
 3290 1c88 0700A0E1 		mov	r0, r7
 3291              	.LVL267:
 3292 1c8c 7C189FE5 		ldr	r1, .L317+20
1059:../uvc.c      **** 			  break;
 3293              		.loc 1 1059 0
 3294 1c90 FF60A0E3 		mov	r6, #255
1056:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3295              		.loc 1 1056 0
 3296 1c94 5F30C4E5 		strb	r3, [r4, #95]
1059:../uvc.c      **** 			  break;
 3297              		.loc 1 1059 0
 3298 1c98 0680A0E1 		mov	r8, r6
1057:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3299              		.loc 1 1057 0
 3300 1c9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3301              	.LVL268:
 3302 1ca0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1059:../uvc.c      **** 			  break;
 3303              		.loc 1 1059 0
 3304 1ca4 DCFFFFEA 		b	.L243
 3305              	.LVL269:
 3306              	.L314:
 990:../uvc.c      ****     switch (bRequest)
 3307              		.loc 1 990 0
 3308 1ca8 010055E3 		cmp	r5, #1
 3309 1cac CDFFFF1A 		bne	.L233
1061:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3310              		.loc 1 1061 0
 3311 1cb0 4C489FE5 		ldr	r4, .L317+8
 3312 1cb4 56208DE2 		add	r2, sp, #86
 3313 1cb8 2000A0E3 		mov	r0, #32
 3314              	.LVL270:
 3315 1cbc 5C1084E2 		add	r1, r4, #92
 3316 1cc0 2C308DE5 		str	r3, [sp, #44]
 3317 1cc4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3318              	.LVL271:
1063:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3319              		.loc 1 1063 0
 3320 1cc8 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1064:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3321              		.loc 1 1064 0
 3322 1ccc 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1067:../uvc.c      **** 			  switch(CtrlID)
 3323              		.loc 1 1067 0
 3324 1cd0 012046E2 		sub	r2, r6, #1
1063:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3325              		.loc 1 1063 0
 3326 1cd4 30008DE5 		str	r0, [sp, #48]
 3327              	.LVL272:
1064:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3328              		.loc 1 1064 0
 3329 1cd8 34C08DE5 		str	ip, [sp, #52]
 3330              	.LVL273:
1067:../uvc.c      **** 			  switch(CtrlID)
 3331              		.loc 1 1067 0
 3332 1cdc 2C309DE5 		ldr	r3, [sp, #44]
 3333 1ce0 090052E3 		cmp	r2, #9
 3334 1ce4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3335 1ce8 550100EA 		b	.L252
 3336              	.L257:
 3337 1cec 00220000 		.word	.L253
 3338 1cf0 44220000 		.word	.L252
 3339 1cf4 101F0000 		.word	.L254
 3340 1cf8 44220000 		.word	.L252
 3341 1cfc 44220000 		.word	.L252
 3342 1d00 44220000 		.word	.L252
 3343 1d04 8C1E0000 		.word	.L255
 3344 1d08 44220000 		.word	.L252
 3345 1d0c 44220000 		.word	.L252
 3346 1d10 101E0000 		.word	.L256
 3347              	.LVL274:
 3348              	.L238:
1037:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3349              		.loc 1 1037 0
 3350 1d14 E8479FE5 		ldr	r4, .L317+8
 3351 1d18 9B84D2E5 		ldrb	r8, [r2, #1179]	@ zero_extendqisi2
1038:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3352              		.loc 1 1038 0
 3353 1d1c 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
1039:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3354              		.loc 1 1039 0
 3355 1d20 0A0050E3 		cmp	r0, #10
1037:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3356              		.loc 1 1037 0
 3357 1d24 5C80C4E5 		strb	r8, [r4, #92]
1038:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3358              		.loc 1 1038 0
 3359 1d28 5D20C4E5 		strb	r2, [r4, #93]
1039:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3360              		.loc 1 1039 0
 3361 1d2c D2FFFF1A 		bne	.L250
 3362              	.LVL275:
 3363              	.L311:
1054:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3364              		.loc 1 1054 0 discriminator 1
 3365 1d30 0110A0E3 		mov	r1, #1
 3366 1d34 5E10C4E5 		strb	r1, [r4, #94]
 3367 1d38 D1FFFFEA 		b	.L251
 3368              	.LVL276:
 3369              	.L239:
 994:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3370              		.loc 1 994 0
 3371 1d3c C0479FE5 		ldr	r4, .L317+8
 995:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3372              		.loc 1 995 0
 3373 1d40 0030A0E3 		mov	r3, #0
 3374              	.LVL277:
 996:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3375              		.loc 1 996 0
 3376 1d44 0200A0E3 		mov	r0, #2
 3377              	.LVL278:
 3378 1d48 5C1084E2 		add	r1, r4, #92
 998:../uvc.c      **** 			  break;
 3379              		.loc 1 998 0
 3380 1d4c FF60A0E3 		mov	r6, #255
 994:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3381              		.loc 1 994 0
 3382 1d50 5C70C4E5 		strb	r7, [r4, #92]
 995:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3383              		.loc 1 995 0
 3384 1d54 5D30C4E5 		strb	r3, [r4, #93]
 998:../uvc.c      **** 			  break;
 3385              		.loc 1 998 0
 3386 1d58 0680A0E1 		mov	r8, r6
 996:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3387              		.loc 1 996 0
 3388 1d5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3389              	.LVL279:
 3390 1d60 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
 998:../uvc.c      **** 			  break;
 3391              		.loc 1 998 0
 3392 1d64 ACFFFFEA 		b	.L243
 3393              	.LVL280:
 3394              	.L235:
1004:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3395              		.loc 1 1004 0
 3396 1d68 94479FE5 		ldr	r4, .L317+8
 3397 1d6c A1A4D2E5 		ldrb	sl, [r2, #1185]	@ zero_extendqisi2
1005:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3398              		.loc 1 1005 0
 3399 1d70 A2C4D2E5 		ldrb	ip, [r2, #1186]	@ zero_extendqisi2
1006:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3400              		.loc 1 1006 0
 3401 1d74 0080A0E3 		mov	r8, #0
1012:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3402              		.loc 1 1012 0
 3403 1d78 0700A0E1 		mov	r0, r7
 3404              	.LVL281:
 3405 1d7c 5C1084E2 		add	r1, r4, #92
1017:../uvc.c      **** 			  break;
 3406              		.loc 1 1017 0
 3407 1d80 FF60A0E3 		mov	r6, #255
1005:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3408              		.loc 1 1005 0
 3409 1d84 5DC0C4E5 		strb	ip, [r4, #93]
1006:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3410              		.loc 1 1006 0
 3411 1d88 5E80C4E5 		strb	r8, [r4, #94]
1007:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3412              		.loc 1 1007 0
 3413 1d8c 5F80C4E5 		strb	r8, [r4, #95]
 3414              	.LVL282:
1004:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3415              		.loc 1 1004 0
 3416 1d90 5CA0C4E5 		strb	sl, [r4, #92]
1017:../uvc.c      **** 			  break;
 3417              		.loc 1 1017 0
 3418 1d94 0680A0E1 		mov	r8, r6
1012:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3419              		.loc 1 1012 0
 3420 1d98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3421              	.LVL283:
 3422 1d9c 0AC0A0E1 		mov	ip, sl
1017:../uvc.c      **** 			  break;
 3423              		.loc 1 1017 0
 3424 1da0 9DFFFFEA 		b	.L243
 3425              	.LVL284:
 3426              	.L237:
1028:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3427              		.loc 1 1028 0
 3428 1da4 58479FE5 		ldr	r4, .L317+8
 3429 1da8 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3430              	.LVL285:
1029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3431              		.loc 1 1029 0
 3432 1dac 9AE4D2E5 		ldrb	lr, [r2, #1178]	@ zero_extendqisi2
1030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3433              		.loc 1 1030 0
 3434 1db0 0A0050E3 		cmp	r0, #10
1028:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3435              		.loc 1 1028 0
 3436 1db4 5C30C4E5 		strb	r3, [r4, #92]
1029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3437              		.loc 1 1029 0
 3438 1db8 5DE0C4E5 		strb	lr, [r4, #93]
1030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3439              		.loc 1 1030 0
 3440 1dbc AEFFFF1A 		bne	.L250
 3441 1dc0 DAFFFFEA 		b	.L311
 3442              	.LVL286:
 3443              	.L313:
1052:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3444              		.loc 1 1052 0
 3445 1dc4 38479FE5 		ldr	r4, .L317+8
 3446 1dc8 9F64D2E5 		ldrb	r6, [r2, #1183]	@ zero_extendqisi2
1053:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3447              		.loc 1 1053 0
 3448 1dcc A0C4D2E5 		ldrb	ip, [r2, #1184]	@ zero_extendqisi2
1054:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3449              		.loc 1 1054 0
 3450 1dd0 0A0050E3 		cmp	r0, #10
1052:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3451              		.loc 1 1052 0
 3452 1dd4 5C60C4E5 		strb	r6, [r4, #92]
1053:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3453              		.loc 1 1053 0
 3454 1dd8 5DC0C4E5 		strb	ip, [r4, #93]
1054:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3455              		.loc 1 1054 0
 3456 1ddc A6FFFF1A 		bne	.L250
 3457 1de0 D2FFFFEA 		b	.L311
 3458              	.L240:
1046:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3459              		.loc 1 1046 0
 3460 1de4 18479FE5 		ldr	r4, .L317+8
 3461 1de8 9D04D2E5 		ldrb	r0, [r2, #1181]	@ zero_extendqisi2
 3462              	.LVL287:
 3463 1dec 0410A0E1 		mov	r1, r4
 3464 1df0 5C00E1E5 		strb	r0, [r1, #92]!
1050:../uvc.c      **** 			  break;
 3465              		.loc 1 1050 0
 3466 1df4 FF60A0E3 		mov	r6, #255
1047:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3467              		.loc 1 1047 0
 3468 1df8 0100A0E3 		mov	r0, #1
 3469 1dfc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3470              	.LVL288:
1050:../uvc.c      **** 			  break;
 3471              		.loc 1 1050 0
 3472 1e00 0680A0E1 		mov	r8, r6
1047:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3473              		.loc 1 1047 0
 3474 1e04 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1050:../uvc.c      **** 			  break;
 3475              		.loc 1 1050 0
 3476 1e08 0170A0E3 		mov	r7, #1
 3477 1e0c 82FFFFEA 		b	.L243
 3478              	.LVL289:
 3479              	.L256:
1176:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3480              		.loc 1 1176 0
 3481 1e10 FC669FE5 		ldr	r6, .L317+24
 3482 1e14 0010E0E3 		mvn	r1, #0
 3483 1e18 1C0096E5 		ldr	r0, [r6, #28]
 3484 1e1c 2C308DE5 		str	r3, [sp, #44]
 3485 1e20 FEFFFFEB 		bl	_txe_mutex_get
1177:../uvc.c      **** 					  if(getData == 1)
 3486              		.loc 1 1177 0
 3487 1e24 30E09DE5 		ldr	lr, [sp, #48]
 3488 1e28 2C309DE5 		ldr	r3, [sp, #44]
 3489 1e2c 01005EE3 		cmp	lr, #1
 3490 1e30 A901000A 		beq	.L315
1179:../uvc.c      **** 					  else if(getData == 0xff)
 3491              		.loc 1 1179 0
 3492 1e34 FF005EE3 		cmp	lr, #255
 3493 1e38 9E01000A 		beq	.L316
1182:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3494              		.loc 1 1182 0
 3495 1e3c 0080A0E3 		mov	r8, #0
 3496 1e40 0600A0E1 		mov	r0, r6
 3497 1e44 1710A0E3 		mov	r1, #23
 3498 1e48 0B20A0E1 		mov	r2, fp
 3499 1e4c 00808DE5 		str	r8, [sp, #0]
 3500 1e50 04808DE5 		str	r8, [sp, #4]
 3501 1e54 FEFFFFEB 		bl	cmdSet
 3502              	.L309:
1185:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3503              		.loc 1 1185 0
 3504 1e58 1C0096E5 		ldr	r0, [r6, #28]
 3505 1e5c FEFFFFEB 		bl	_txe_mutex_put
1187:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3506              		.loc 1 1187 0
 3507 1e60 30809DE5 		ldr	r8, [sp, #48]
 3508 1e64 34609DE5 		ldr	r6, [sp, #52]
 3509 1e68 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3510 1e6c 0400A0E3 		mov	r0, #4
 3511 1e70 A0169FE5 		ldr	r1, .L317+28
 3512 1e74 0820A0E1 		mov	r2, r8
 3513 1e78 0630A0E1 		mov	r3, r6
 3514 1e7c 00C08DE5 		str	ip, [sp, #0]
 3515 1e80 FEFFFFEB 		bl	CyU3PDebugPrint
1188:../uvc.c      **** 					  break;
 3516              		.loc 1 1188 0
 3517 1e84 FFC0A0E3 		mov	ip, #255
 3518 1e88 63FFFFEA 		b	.L243
 3519              	.LVL290:
 3520              	.L255:
1153:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3521              		.loc 1 1153 0
 3522 1e8c B984D8E5 		ldrb	r8, [r8, #1209]	@ zero_extendqisi2
 3523 1e90 010058E3 		cmp	r8, #1
 3524 1e94 08005813 		cmpne	r8, #8
 3525 1e98 0000A013 		movne	r0, #0
 3526 1e9c 0100A003 		moveq	r0, #1
 3527 1ea0 8001001A 		bne	.L306
 3528              	.LVL291:
1156:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3529              		.loc 1 1156 0
 3530 1ea4 68869FE5 		ldr	r8, .L317+24
 3531 1ea8 0010E0E3 		mvn	r1, #0
 3532 1eac 1C0098E5 		ldr	r0, [r8, #28]
 3533 1eb0 2C308DE5 		str	r3, [sp, #44]
 3534 1eb4 FEFFFFEB 		bl	_txe_mutex_get
1157:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3535              		.loc 1 1157 0
 3536 1eb8 30A09DE5 		ldr	sl, [sp, #48]
 3537 1ebc 1610A0E3 		mov	r1, #22
 3538 1ec0 0B20A0E1 		mov	r2, fp
 3539 1ec4 2C309DE5 		ldr	r3, [sp, #44]
 3540 1ec8 00C0A0E3 		mov	ip, #0
 3541 1ecc 0800A0E1 		mov	r0, r8
 3542 1ed0 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3543 1ed4 FEFFFFEB 		bl	cmdSet
1158:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3544              		.loc 1 1158 0
 3545 1ed8 1C0098E5 		ldr	r0, [r8, #28]
 3546 1edc FEFFFFEB 		bl	_txe_mutex_put
1161:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3547              		.loc 1 1161 0
 3548 1ee0 18069FE5 		ldr	r0, .L317+4
1162:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3549              		.loc 1 1162 0
 3550 1ee4 34209DE5 		ldr	r2, [sp, #52]
1161:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3551              		.loc 1 1161 0
 3552 1ee8 061089E0 		add	r1, r9, r6
 3553 1eec 813180E0 		add	r3, r0, r1, asl #3
1163:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3554              		.loc 1 1163 0
 3555 1ef0 0160A0E3 		mov	r6, #1
1161:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3556              		.loc 1 1161 0
 3557 1ef4 A1A4C3E5 		strb	sl, [r3, #1185]
1162:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3558              		.loc 1 1162 0
 3559 1ef8 A224C3E5 		strb	r2, [r3, #1186]
1163:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3560              		.loc 1 1163 0
 3561 1efc A464C3E5 		strb	r6, [r3, #1188]
 3562              	.LVL292:
 3563              	.L307:
1165:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3564              		.loc 1 1165 0
 3565 1f00 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3566 1f04 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1170:../uvc.c      **** 					  break;
 3567              		.loc 1 1170 0
 3568 1f08 FFC0A0E3 		mov	ip, #255
 3569 1f0c 42FFFFEA 		b	.L243
 3570              	.LVL293:
 3571              	.L254:
1119:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3572              		.loc 1 1119 0
 3573 1f10 B904D8E5 		ldrb	r0, [r8, #1209]	@ zero_extendqisi2
 3574 1f14 010050E3 		cmp	r0, #1
 3575 1f18 04005013 		cmpne	r0, #4
 3576 1f1c 5C01001A 		bne	.L264
1118:../uvc.c      **** 					  value = (value << 8)|Data0;
 3577              		.loc 1 1118 0
 3578 1f20 30109DE5 		ldr	r1, [sp, #48]
 3579 1f24 34E09DE5 		ldr	lr, [sp, #52]
 3580 1f28 0E2481E1 		orr	r2, r1, lr, asl #8
1120:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3581              		.loc 1 1120 0
 3582 1f2c F90052E3 		cmp	r2, #249
 3583 1f30 5701008A 		bhi	.L264
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3584              		.loc 1 1125 0
 3585 1f34 C8A042E2 		sub	sl, r2, #200
 3586 1f38 0AC8A0E1 		mov	ip, sl, asl #16
 3587 1f3c 3CC08DE5 		str	ip, [sp, #60]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3588              		.loc 1 1127 0
 3589 1f40 27A062E2 		rsb	sl, r2, #39
 3590 1f44 38A08DE5 		str	sl, [sp, #56]
 3591 1f48 3CA09DE5 		ldr	sl, [sp, #60]
 3592 1f4c C81062E2 		rsb	r1, r2, #200
 3593 1f50 C80052E3 		cmp	r2, #200
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3594              		.loc 1 1125 0
 3595 1f54 640042E2 		sub	r0, r2, #100
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3596              		.loc 1 1127 0
 3597 1f58 0118A0E1 		mov	r1, r1, asl #16
 3598 1f5c 64E062E2 		rsb	lr, r2, #100
 3599 1f60 2A18A081 		movhi	r1, sl, lsr #16
 3600 1f64 2118A091 		movls	r1, r1, lsr #16
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3601              		.loc 1 1125 0
 3602 1f68 00C8A0E1 		mov	ip, r0, asl #16
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3603              		.loc 1 1127 0
 3604 1f6c 640052E3 		cmp	r2, #100
 3605 1f70 0E08A0E1 		mov	r0, lr, asl #16
 3606 1f74 2C08A081 		movhi	r0, ip, lsr #16
 3607 1f78 38C09DE5 		ldr	ip, [sp, #56]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3608              		.loc 1 1125 0
 3609 1f7c 14A042E2 		sub	sl, r2, #20
 3610 1f80 38A08DE5 		str	sl, [sp, #56]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3611              		.loc 1 1127 0
 3612 1f84 2008A091 		movls	r0, r0, lsr #16
 3613 1f88 14A062E2 		rsb	sl, r2, #20
 3614 1f8c 3CA08DE5 		str	sl, [sp, #60]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3615              		.loc 1 1125 0
 3616 1f90 27E042E2 		sub	lr, r2, #39
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3617              		.loc 1 1127 0
 3618 1f94 000051E1 		cmp	r1, r0
 3619 1f98 01A0A031 		movcc	sl, r1
 3620 1f9c 00A0A021 		movcs	sl, r0
 3621 1fa0 0CC8A0E1 		mov	ip, ip, asl #16
 3622 1fa4 270052E3 		cmp	r2, #39
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3623              		.loc 1 1125 0
 3624 1fa8 0EE8A0E1 		mov	lr, lr, asl #16
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3625              		.loc 1 1127 0
 3626 1fac 2CE8A091 		movls	lr, ip, lsr #16
 3627 1fb0 64C59FE5 		ldr	ip, .L317+32
 3628 1fb4 20A08DE5 		str	sl, [sp, #32]
 3629 1fb8 01A06CE0 		rsb	sl, ip, r1
 3630 1fbc 2EE8A081 		movhi	lr, lr, lsr #16
 3631 1fc0 00C07AE2 		rsbs	ip, sl, #0
 3632 1fc4 0AC0ACE0 		adc	ip, ip, sl
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3633              		.loc 1 1125 0
 3634 1fc8 38A09DE5 		ldr	sl, [sp, #56]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3635              		.loc 1 1127 0
 3636 1fcc 44C08DE5 		str	ip, [sp, #68]
 3637              	.LVL294:
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3638              		.loc 1 1125 0
 3639 1fd0 0AC8A0E1 		mov	ip, sl, asl #16
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3640              		.loc 1 1127 0
 3641 1fd4 3CA09DE5 		ldr	sl, [sp, #60]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3642              		.loc 1 1125 0
 3643 1fd8 4CC08DE5 		str	ip, [sp, #76]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3644              		.loc 1 1127 0
 3645 1fdc 0AC8A0E1 		mov	ip, sl, asl #16
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3646              		.loc 1 1125 0
 3647 1fe0 0AA042E2 		sub	sl, r2, #10
 3648 1fe4 48A08DE5 		str	sl, [sp, #72]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3649              		.loc 1 1127 0
 3650 1fe8 20A09DE5 		ldr	sl, [sp, #32]
 3651 1fec 3CC08DE5 		str	ip, [sp, #60]
 3652 1ff0 0A005EE1 		cmp	lr, sl
 3653 1ff4 0EA0A031 		movcc	sl, lr
 3654 1ff8 0AC062E2 		rsb	ip, r2, #10
 3655 1ffc 40C08DE5 		str	ip, [sp, #64]
 3656 2000 38A08DE5 		str	sl, [sp, #56]
 3657 2004 3CC09DE5 		ldr	ip, [sp, #60]
 3658 2008 4CA09DE5 		ldr	sl, [sp, #76]
 3659 200c 140052E3 		cmp	r2, #20
 3660 2010 2CA8A091 		movls	sl, ip, lsr #16
 3661 2014 2AA8A081 		movhi	sl, sl, lsr #16
 3662 2018 44C09DE5 		ldr	ip, [sp, #68]
 3663 201c 010050E1 		cmp	r0, r1
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3664              		.loc 1 1125 0
 3665 2020 48109DE5 		ldr	r1, [sp, #72]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3666              		.loc 1 1127 0
 3667 2024 01C0A033 		movcc	ip, #1
 3668 2028 3CA08DE5 		str	sl, [sp, #60]
 3669 202c 24C08DE5 		str	ip, [sp, #36]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3670              		.loc 1 1125 0
 3671 2030 01A8A0E1 		mov	sl, r1, asl #16
 3672 2034 05C042E2 		sub	ip, r2, #5
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3673              		.loc 1 1127 0
 3674 2038 051062E2 		rsb	r1, r2, #5
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3675              		.loc 1 1125 0
 3676 203c 48A08DE5 		str	sl, [sp, #72]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3677              		.loc 1 1127 0
 3678 2040 40009DE5 		ldr	r0, [sp, #64]
 3679 2044 38A09DE5 		ldr	sl, [sp, #56]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3680              		.loc 1 1125 0
 3681 2048 40C08DE5 		str	ip, [sp, #64]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3682              		.loc 1 1127 0
 3683 204c 3CC09DE5 		ldr	ip, [sp, #60]
 3684 2050 4C108DE5 		str	r1, [sp, #76]
 3685 2054 48109DE5 		ldr	r1, [sp, #72]
 3686 2058 0008A0E1 		mov	r0, r0, asl #16
 3687 205c 0A005CE1 		cmp	ip, sl
 3688 2060 0AC0A021 		movcs	ip, sl
 3689 2064 0A0052E3 		cmp	r2, #10
 3690 2068 20A09DE5 		ldr	sl, [sp, #32]
 3691 206c 2108A081 		movhi	r0, r1, lsr #16
 3692 2070 2008A091 		movls	r0, r0, lsr #16
 3693 2074 48008DE5 		str	r0, [sp, #72]
 3694 2078 24009DE5 		ldr	r0, [sp, #36]
 3695 207c 0A005EE1 		cmp	lr, sl
 3696 2080 0200A033 		movcc	r0, #2
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3697              		.loc 1 1125 0
 3698 2084 02E042E2 		sub	lr, r2, #2
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3699              		.loc 1 1127 0
 3700 2088 44C08DE5 		str	ip, [sp, #68]
 3701 208c 24008DE5 		str	r0, [sp, #36]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3702              		.loc 1 1125 0
 3703 2090 40C09DE5 		ldr	ip, [sp, #64]
 3704 2094 1CE08DE5 		str	lr, [sp, #28]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3705              		.loc 1 1127 0
 3706 2098 44009DE5 		ldr	r0, [sp, #68]
 3707 209c 48E09DE5 		ldr	lr, [sp, #72]
 3708 20a0 4C109DE5 		ldr	r1, [sp, #76]
 3709 20a4 02A062E2 		rsb	sl, r2, #2
 3710 20a8 00005EE1 		cmp	lr, r0
 3711 20ac 00E0A021 		movcs	lr, r0
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3712              		.loc 1 1125 0
 3713 20b0 0CC8A0E1 		mov	ip, ip, asl #16
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3714              		.loc 1 1127 0
 3715 20b4 050052E3 		cmp	r2, #5
 3716 20b8 40A08DE5 		str	sl, [sp, #64]
 3717 20bc 0118A0E1 		mov	r1, r1, asl #16
 3718 20c0 3CA09DE5 		ldr	sl, [sp, #60]
 3719 20c4 2C18A081 		movhi	r1, ip, lsr #16
 3720 20c8 38C09DE5 		ldr	ip, [sp, #56]
 3721 20cc 4CE08DE5 		str	lr, [sp, #76]
 3722 20d0 24009DE5 		ldr	r0, [sp, #36]
 3723 20d4 40E09DE5 		ldr	lr, [sp, #64]
 3724 20d8 2118A091 		movls	r1, r1, lsr #16
 3725 20dc 0C005AE1 		cmp	sl, ip
 3726 20e0 20108DE5 		str	r1, [sp, #32]
 3727 20e4 0300A033 		movcc	r0, #3
 3728 20e8 38008DE5 		str	r0, [sp, #56]
 3729 20ec 4CA09DE5 		ldr	sl, [sp, #76]
 3730 20f0 0E08A0E1 		mov	r0, lr, asl #16
 3731 20f4 20E09DE5 		ldr	lr, [sp, #32]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3732              		.loc 1 1125 0
 3733 20f8 1C109DE5 		ldr	r1, [sp, #28]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3734              		.loc 1 1127 0
 3735 20fc 0A005EE1 		cmp	lr, sl
 3736 2100 0AE0A021 		movcs	lr, sl
 3737 2104 44C09DE5 		ldr	ip, [sp, #68]
 3738 2108 48A09DE5 		ldr	sl, [sp, #72]
 3739 210c 020052E3 		cmp	r2, #2
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3740              		.loc 1 1125 0
 3741 2110 0118A0E1 		mov	r1, r1, asl #16
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3742              		.loc 1 1127 0
 3743 2114 2018A091 		movls	r1, r0, lsr #16
 3744 2118 38009DE5 		ldr	r0, [sp, #56]
 3745 211c 2118A081 		movhi	r1, r1, lsr #16
 3746 2120 0C005AE1 		cmp	sl, ip
 3747 2124 0400A033 		movcc	r0, #4
 3748 2128 40008DE5 		str	r0, [sp, #64]
1125:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3749              		.loc 1 1125 0
 3750 212c 010042E2 		sub	r0, r2, #1
 3751 2130 38008DE5 		str	r0, [sp, #56]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3752              		.loc 1 1127 0
 3753 2134 4CA09DE5 		ldr	sl, [sp, #76]
 3754 2138 20009DE5 		ldr	r0, [sp, #32]
 3755 213c 01C062E2 		rsb	ip, r2, #1
 3756 2140 3CC08DE5 		str	ip, [sp, #60]
 3757 2144 0A0050E1 		cmp	r0, sl
1134:../uvc.c      **** 						  shutter = shutter+index;
 3758              		.loc 1 1134 0
 3759 2148 38A09DE5 		ldr	sl, [sp, #56]
 3760 214c 3C009DE5 		ldr	r0, [sp, #60]
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3761              		.loc 1 1127 0
 3762 2150 40C09DE5 		ldr	ip, [sp, #64]
 3763 2154 05C0A033 		movcc	ip, #5
1134:../uvc.c      **** 						  shutter = shutter+index;
 3764              		.loc 1 1134 0
 3765 2158 010052E3 		cmp	r2, #1
 3766 215c 0028A091 		movls	r2, r0, asl #16
 3767 2160 0A28A081 		movhi	r2, sl, asl #16
 3768 2164 0E0051E1 		cmp	r1, lr
 3769 2168 01A0A031 		movcc	sl, r1
 3770 216c 0EA0A021 		movcs	sl, lr
1127:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3771              		.loc 1 1127 0
 3772 2170 0E0051E1 		cmp	r1, lr
 3773 2174 0C10A021 		movcs	r1, ip
 3774 2178 0610A033 		movcc	r1, #6
1134:../uvc.c      **** 						  shutter = shutter+index;
 3775              		.loc 1 1134 0
 3776 217c 22085AE1 		cmp	sl, r2, lsr #16
1137:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3777              		.loc 1 1137 0
 3778 2180 8CA39FE5 		ldr	sl, .L317+24
1134:../uvc.c      **** 						  shutter = shutter+index;
 3779              		.loc 1 1134 0
 3780 2184 0120A091 		movls	r2, r1
 3781 2188 0720A083 		movhi	r2, #7
 3782 218c 012082E2 		add	r2, r2, #1
 3783 2190 FFE002E2 		and	lr, r2, #255
1137:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3784              		.loc 1 1137 0
 3785 2194 0010E0E3 		mvn	r1, #0
 3786 2198 1C009AE5 		ldr	r0, [sl, #28]
1134:../uvc.c      **** 						  shutter = shutter+index;
 3787              		.loc 1 1134 0
 3788 219c 38E08DE5 		str	lr, [sp, #56]
 3789              	.LVL295:
1137:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3790              		.loc 1 1137 0
 3791 21a0 2C308DE5 		str	r3, [sp, #44]
 3792 21a4 FEFFFFEB 		bl	_txe_mutex_get
1138:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3793              		.loc 1 1138 0
 3794 21a8 38C09DE5 		ldr	ip, [sp, #56]
 3795 21ac 0310A0E3 		mov	r1, #3
 3796 21b0 0B20A0E1 		mov	r2, fp
 3797 21b4 2C309DE5 		ldr	r3, [sp, #44]
 3798 21b8 00C08DE5 		str	ip, [sp, #0]
 3799 21bc 0A00A0E1 		mov	r0, sl
 3800 21c0 00C0A0E3 		mov	ip, #0
 3801 21c4 04C08DE5 		str	ip, [sp, #4]
 3802 21c8 FEFFFFEB 		bl	cmdSet
1139:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3803              		.loc 1 1139 0
 3804 21cc 1C009AE5 		ldr	r0, [sl, #28]
 3805 21d0 FEFFFFEB 		bl	_txe_mutex_put
1142:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3806              		.loc 1 1142 0
 3807 21d4 30009DE5 		ldr	r0, [sp, #48]
1143:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3808              		.loc 1 1143 0
 3809 21d8 34C09DE5 		ldr	ip, [sp, #52]
1145:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3810              		.loc 1 1145 0
 3811 21dc 38309DE5 		ldr	r3, [sp, #56]
1142:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3812              		.loc 1 1142 0
 3813 21e0 061089E0 		add	r1, r9, r6
 3814 21e4 816188E0 		add	r6, r8, r1, asl #3
1144:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3815              		.loc 1 1144 0
 3816 21e8 0120A0E3 		mov	r2, #1
1142:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3817              		.loc 1 1142 0
 3818 21ec A104C6E5 		strb	r0, [r6, #1185]
1143:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3819              		.loc 1 1143 0
 3820 21f0 A2C4C6E5 		strb	ip, [r6, #1186]
1144:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3821              		.loc 1 1144 0
 3822 21f4 A424C6E5 		strb	r2, [r6, #1188]
1145:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3823              		.loc 1 1145 0
 3824 21f8 0D33C8E5 		strb	r3, [r8, #781]
 3825 21fc 3FFFFFEA 		b	.L307
 3826              	.LVL296:
 3827              	.L253:
1072:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3828              		.loc 1 1072 0
 3829 2200 062089E0 		add	r2, r9, r6
 3830 2204 826188E0 		add	r6, r8, r2, asl #3
1073:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3831              		.loc 1 1073 0
 3832 2208 0110A0E3 		mov	r1, #1
1076:../uvc.c      **** 		  		    switch (getData){
 3833              		.loc 1 1076 0
 3834 220c 01E040E2 		sub	lr, r0, #1
1072:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3835              		.loc 1 1072 0
 3836 2210 A104C6E5 		strb	r0, [r6, #1185]
1073:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3837              		.loc 1 1073 0
 3838 2214 A414C6E5 		strb	r1, [r6, #1188]
 3839              	.LVL297:
1076:../uvc.c      **** 		  		    switch (getData){
 3840              		.loc 1 1076 0
 3841 2218 07005EE3 		cmp	lr, #7
 3842 221c 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3843 2220 970000EA 		b	.L258
 3844              	.L263:
 3845 2224 18240000 		.word	.L259
 3846 2228 7C230000 		.word	.L260
 3847 222c 84240000 		.word	.L258
 3848 2230 18230000 		.word	.L261
 3849 2234 84240000 		.word	.L258
 3850 2238 84240000 		.word	.L258
 3851 223c 84240000 		.word	.L258
 3852 2240 78220000 		.word	.L262
 3853              	.LVL298:
 3854              	.L252:
1192:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3855              		.loc 1 1192 0
 3856 2244 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1191:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3857              		.loc 1 1191 0
 3858 2248 30A09DE5 		ldr	sl, [sp, #48]
 3859 224c 069089E0 		add	r9, r9, r6
 3860 2250 89E188E0 		add	lr, r8, r9, asl #3
1192:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3861              		.loc 1 1192 0
 3862 2254 0620A0E1 		mov	r2, r6
 3863 2258 0400A0E3 		mov	r0, #4
 3864 225c BC129FE5 		ldr	r1, .L317+36
1191:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3865              		.loc 1 1191 0
 3866 2260 A1A4CEE5 		strb	sl, [lr, #1185]
1192:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3867              		.loc 1 1192 0
 3868 2264 FEFFFFEB 		bl	CyU3PDebugPrint
1193:../uvc.c      **** 			  		 break;
 3869              		.loc 1 1193 0
 3870 2268 FFC0A0E3 		mov	ip, #255
 3871 226c 0C60A0E1 		mov	r6, ip
 3872 2270 0C80A0E1 		mov	r8, ip
 3873 2274 68FEFFEA 		b	.L243
 3874              	.LVL299:
 3875              	.L262:
1095:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3876              		.loc 1 1095 0
 3877 2278 94629FE5 		ldr	r6, .L317+24
1093:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3878              		.loc 1 1093 0
 3879 227c 00A0A0E3 		mov	sl, #0
1095:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3880              		.loc 1 1095 0
 3881 2280 1C0096E5 		ldr	r0, [r6, #28]
1093:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3882              		.loc 1 1093 0
 3883 2284 0DA3C8E5 		strb	sl, [r8, #781]
 3884              	.LVL300:
1095:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3885              		.loc 1 1095 0
 3886 2288 0010E0E3 		mvn	r1, #0
 3887 228c 2C308DE5 		str	r3, [sp, #44]
 3888 2290 FEFFFFEB 		bl	_txe_mutex_get
1096:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3889              		.loc 1 1096 0
 3890 2294 0B20A0E1 		mov	r2, fp
 3891 2298 2C309DE5 		ldr	r3, [sp, #44]
 3892 229c 1010A0E3 		mov	r1, #16
 3893 22a0 0600A0E1 		mov	r0, r6
 3894 22a4 00A08DE5 		str	sl, [sp, #0]
 3895 22a8 04A08DE5 		str	sl, [sp, #4]
 3896 22ac FEFFFFEB 		bl	cmdSet
1097:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3897              		.loc 1 1097 0
 3898 22b0 1C0096E5 		ldr	r0, [r6, #28]
 3899 22b4 FEFFFFEB 		bl	_txe_mutex_put
 3900              	.LVL301:
 3901              	.LBB68:
 3902              	.LBB69:
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3903              		.loc 1 411 0
 3904 22b8 0010E0E3 		mvn	r1, #0
 3905 22bc 1C0096E5 		ldr	r0, [r6, #28]
 3906 22c0 FEFFFFEB 		bl	_txe_mutex_get
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3907              		.loc 1 412 0
 3908 22c4 0180A0E3 		mov	r8, #1
 3909 22c8 1410A0E3 		mov	r1, #20
 3910 22cc 2720A0E3 		mov	r2, #39
 3911 22d0 3030A0E3 		mov	r3, #48
 3912 22d4 0600A0E1 		mov	r0, r6
 3913 22d8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3914 22dc FEFFFFEB 		bl	cmdSet
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3915              		.loc 1 413 0
 3916 22e0 02C0A0E3 		mov	ip, #2
 3917 22e4 1510A0E3 		mov	r1, #21
 3918 22e8 2520A0E3 		mov	r2, #37
 3919 22ec 3030A0E3 		mov	r3, #48
 3920 22f0 0600A0E1 		mov	r0, r6
 3921 22f4 00C08DE5 		str	ip, [sp, #0]
 3922 22f8 04A08DE5 		str	sl, [sp, #4]
 3923 22fc FEFFFFEB 		bl	cmdSet
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3924              		.loc 1 414 0
 3925 2300 1C0096E5 		ldr	r0, [r6, #28]
 3926 2304 FEFFFFEB 		bl	_txe_mutex_put
 3927              	.LBE69:
 3928              	.LBE68:
1099:../uvc.c      **** 							break;
 3929              		.loc 1 1099 0
 3930 2308 FFC0A0E3 		mov	ip, #255
 3931 230c 0C60A0E1 		mov	r6, ip
 3932 2310 0880A0E3 		mov	r8, #8
 3933 2314 40FEFFEA 		b	.L243
 3934              	.LVL302:
 3935              	.L261:
 3936              	.LBB70:
 3937              	.LBB71:
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3938              		.loc 1 411 0
 3939 2318 F4819FE5 		ldr	r8, .L317+24
 3940 231c 0010E0E3 		mvn	r1, #0
 3941 2320 1C0098E5 		ldr	r0, [r8, #28]
 3942 2324 FEFFFFEB 		bl	_txe_mutex_get
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3943              		.loc 1 412 0
 3944 2328 0060A0E3 		mov	r6, #0
 3945 232c 1410A0E3 		mov	r1, #20
 3946 2330 2720A0E3 		mov	r2, #39
 3947 2334 3030A0E3 		mov	r3, #48
 3948 2338 0800A0E1 		mov	r0, r8
 3949 233c 00608DE5 		str	r6, [sp, #0]
 3950 2340 04608DE5 		str	r6, [sp, #4]
 3951 2344 FEFFFFEB 		bl	cmdSet
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3952              		.loc 1 413 0
 3953 2348 1510A0E3 		mov	r1, #21
 3954 234c 2520A0E3 		mov	r2, #37
 3955 2350 3030A0E3 		mov	r3, #48
 3956 2354 0800A0E1 		mov	r0, r8
 3957 2358 00608DE5 		str	r6, [sp, #0]
 3958 235c 04608DE5 		str	r6, [sp, #4]
 3959 2360 FEFFFFEB 		bl	cmdSet
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3960              		.loc 1 414 0
 3961 2364 1C0098E5 		ldr	r0, [r8, #28]
 3962 2368 FEFFFFEB 		bl	_txe_mutex_put
 3963 236c FFC0A0E3 		mov	ip, #255
 3964 2370 0C60A0E1 		mov	r6, ip
 3965 2374 0480A0E3 		mov	r8, #4
 3966 2378 27FEFFEA 		b	.L243
 3967              	.LVL303:
 3968              	.L260:
 3969              	.LBE71:
 3970              	.LBE70:
1083:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3971              		.loc 1 1083 0
 3972 237c 90A19FE5 		ldr	sl, .L317+24
1081:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3973              		.loc 1 1081 0
 3974 2380 0060A0E3 		mov	r6, #0
 3975 2384 0D63C8E5 		strb	r6, [r8, #781]
 3976              	.LVL304:
1083:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3977              		.loc 1 1083 0
 3978 2388 0010E0E3 		mvn	r1, #0
 3979 238c 1C009AE5 		ldr	r0, [sl, #28]
 3980 2390 2C308DE5 		str	r3, [sp, #44]
 3981 2394 FEFFFFEB 		bl	_txe_mutex_get
1084:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3982              		.loc 1 1084 0
 3983 2398 0B20A0E1 		mov	r2, fp
 3984 239c 2C309DE5 		ldr	r3, [sp, #44]
 3985 23a0 1010A0E3 		mov	r1, #16
 3986 23a4 0A00A0E1 		mov	r0, sl
 3987 23a8 00608DE5 		str	r6, [sp, #0]
 3988 23ac 04608DE5 		str	r6, [sp, #4]
 3989 23b0 FEFFFFEB 		bl	cmdSet
1085:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3990              		.loc 1 1085 0
 3991 23b4 1C009AE5 		ldr	r0, [sl, #28]
 3992 23b8 FEFFFFEB 		bl	_txe_mutex_put
 3993              	.LVL305:
 3994              	.LBB72:
 3995              	.LBB73:
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3996              		.loc 1 411 0
 3997 23bc 0010E0E3 		mvn	r1, #0
 3998 23c0 1C009AE5 		ldr	r0, [sl, #28]
 3999 23c4 FEFFFFEB 		bl	_txe_mutex_get
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4000              		.loc 1 412 0
 4001 23c8 1410A0E3 		mov	r1, #20
 4002 23cc 2720A0E3 		mov	r2, #39
 4003 23d0 3030A0E3 		mov	r3, #48
 4004 23d4 0A00A0E1 		mov	r0, sl
 4005 23d8 00608DE5 		str	r6, [sp, #0]
 4006 23dc 04608DE5 		str	r6, [sp, #4]
 4007 23e0 FEFFFFEB 		bl	cmdSet
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4008              		.loc 1 413 0
 4009 23e4 1510A0E3 		mov	r1, #21
 4010 23e8 2520A0E3 		mov	r2, #37
 4011 23ec 3030A0E3 		mov	r3, #48
 4012 23f0 0A00A0E1 		mov	r0, sl
 4013 23f4 00608DE5 		str	r6, [sp, #0]
 4014 23f8 04608DE5 		str	r6, [sp, #4]
 4015 23fc FEFFFFEB 		bl	cmdSet
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4016              		.loc 1 414 0
 4017 2400 1C009AE5 		ldr	r0, [sl, #28]
 4018 2404 FEFFFFEB 		bl	_txe_mutex_put
 4019 2408 FFC0A0E3 		mov	ip, #255
 4020 240c 0C60A0E1 		mov	r6, ip
 4021 2410 0280A0E3 		mov	r8, #2
 4022 2414 00FEFFEA 		b	.L243
 4023              	.LVL306:
 4024              	.L259:
 4025              	.LBE73:
 4026              	.LBE72:
 4027              	.LBB74:
 4028              	.LBB75:
 411:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4029              		.loc 1 411 0
 4030 2418 F4609FE5 		ldr	r6, .L317+24
 4031 241c 0010E0E3 		mvn	r1, #0
 4032 2420 1C0096E5 		ldr	r0, [r6, #28]
 4033 2424 FEFFFFEB 		bl	_txe_mutex_get
 412:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4034              		.loc 1 412 0
 4035 2428 0080A0E3 		mov	r8, #0
 4036 242c 01A0A0E3 		mov	sl, #1
 4037 2430 1410A0E3 		mov	r1, #20
 4038 2434 2720A0E3 		mov	r2, #39
 4039 2438 3030A0E3 		mov	r3, #48
 4040 243c 0600A0E1 		mov	r0, r6
 4041 2440 04808DE5 		str	r8, [sp, #4]
 4042 2444 00A08DE5 		str	sl, [sp, #0]
 4043 2448 FEFFFFEB 		bl	cmdSet
 413:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4044              		.loc 1 413 0
 4045 244c 02C0A0E3 		mov	ip, #2
 4046 2450 1510A0E3 		mov	r1, #21
 4047 2454 2520A0E3 		mov	r2, #37
 4048 2458 3030A0E3 		mov	r3, #48
 4049 245c 0600A0E1 		mov	r0, r6
 4050 2460 00C08DE5 		str	ip, [sp, #0]
 4051 2464 04808DE5 		str	r8, [sp, #4]
 4052 2468 FEFFFFEB 		bl	cmdSet
 414:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4053              		.loc 1 414 0
 4054 246c 1C0096E5 		ldr	r0, [r6, #28]
 4055 2470 FEFFFFEB 		bl	_txe_mutex_put
 4056              	.LBE75:
 4057              	.LBE74:
1079:../uvc.c      **** 							break;
 4058              		.loc 1 1079 0
 4059 2474 FFC0A0E3 		mov	ip, #255
 4060 2478 0C60A0E1 		mov	r6, ip
 4061 247c 0A80A0E1 		mov	r8, sl
 4062 2480 E5FDFFEA 		b	.L243
 4063              	.LVL307:
 4064              	.L258:
1076:../uvc.c      **** 		  		    switch (getData){
 4065              		.loc 1 1076 0
 4066 2484 FFC0A0E3 		mov	ip, #255
 4067 2488 0080A0E1 		mov	r8, r0
 4068 248c 0C60A0E1 		mov	r6, ip
 4069 2490 E1FDFFEA 		b	.L243
 4070              	.LVL308:
 4071              	.L264:
1147:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4072              		.loc 1 1147 0
 4073 2494 0000A0E3 		mov	r0, #0
 4074 2498 0110A0E3 		mov	r1, #1
 4075 249c 0020A0E1 		mov	r2, r0
 4076 24a0 FEFFFFEB 		bl	CyU3PUsbStall
 4077              	.LVL309:
 4078 24a4 95FEFFEA 		b	.L307
 4079              	.LVL310:
 4080              	.L306:
1165:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4081              		.loc 1 1165 0
 4082 24a8 0110A0E3 		mov	r1, #1
 4083 24ac 0020A0E1 		mov	r2, r0
 4084 24b0 FEFFFFEB 		bl	CyU3PUsbStall
 4085 24b4 91FEFFEA 		b	.L307
 4086              	.LVL311:
 4087              	.L316:
1180:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4088              		.loc 1 1180 0
 4089 24b8 08E0A0E3 		mov	lr, #8
 4090 24bc 00C0A0E3 		mov	ip, #0
 4091 24c0 0600A0E1 		mov	r0, r6
 4092 24c4 1710A0E3 		mov	r1, #23
 4093 24c8 0B20A0E1 		mov	r2, fp
 4094 24cc 00E08DE5 		str	lr, [sp, #0]
 4095 24d0 04C08DE5 		str	ip, [sp, #4]
 4096 24d4 FEFFFFEB 		bl	cmdSet
 4097 24d8 5EFEFFEA 		b	.L309
 4098              	.L315:
1178:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4099              		.loc 1 1178 0
 4100 24dc 0480A0E3 		mov	r8, #4
 4101 24e0 00E0A0E3 		mov	lr, #0
 4102 24e4 0600A0E1 		mov	r0, r6
 4103 24e8 1710A0E3 		mov	r1, #23
 4104 24ec 0B20A0E1 		mov	r2, fp
 4105 24f0 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4106 24f4 FEFFFFEB 		bl	cmdSet
 4107 24f8 56FEFFEA 		b	.L309
 4108              	.L318:
 4109              		.align	2
 4110              	.L317:
 4111 24fc 00000000 		.word	bRequest
 4112 2500 00000000 		.word	.LANCHOR1
 4113 2504 00000000 		.word	.LANCHOR0
 4114 2508 0C040000 		.word	.LC24
 4115 250c 30040000 		.word	.LC25
 4116 2510 5C000000 		.word	.LANCHOR0+92
 4117 2514 00000000 		.word	cmdQu
 4118 2518 C0030000 		.word	.LC22
 4119 251c FFFF0000 		.word	65535
 4120 2520 E8030000 		.word	.LC23
 4121              		.cfi_endproc
 4122              	.LFE3:
 4124              		.align	2
 4125              		.global	UVCAppEP0Thread_Entry
 4127              	UVCAppEP0Thread_Entry:
 4128              	.LFB24:
3333:../uvc.c      **** {
 4129              		.loc 1 3333 0
 4130              		.cfi_startproc
 4131              		@ args = 0, pretend = 0, frame = 24
 4132              		@ frame_needed = 0, uses_anonymous_args = 0
 4133              	.LVL312:
 4134 2524 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4135              	.LCFI17:
 4136              		.cfi_def_cfa_offset 36
 4137 2528 A04B9FE5 		ldr	r4, .L488
 4138              		.cfi_offset 14, -4
 4139              		.cfi_offset 11, -8
 4140              		.cfi_offset 10, -12
 4141              		.cfi_offset 9, -16
 4142              		.cfi_offset 8, -20
 4143              		.cfi_offset 7, -24
 4144              		.cfi_offset 6, -28
 4145              		.cfi_offset 5, -32
 4146              		.cfi_offset 4, -36
 4147 252c A06B9FE5 		ldr	r6, .L488+4
 4148 2530 A08B9FE5 		ldr	r8, .L488+8
 4149 2534 A0AB9FE5 		ldr	sl, .L488+12
 4150 2538 A0BB9FE5 		ldr	fp, .L488+16
 4151 253c A07B9FE5 		ldr	r7, .L488+20
 4152 2540 34D04DE2 		sub	sp, sp, #52
 4153              	.LCFI18:
 4154              		.cfi_def_cfa_offset 88
 4155              	.LVL313:
3355:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4156              		.loc 1 3355 0
 4157 2544 0450A0E1 		mov	r5, r4
 4158              	.LVL314:
 4159              	.L458:
 4160 2548 00C0E0E3 		mvn	ip, #0
 4161 254c 7C0B9FE5 		ldr	r0, .L488
 4162 2550 4C10A0E3 		mov	r1, #76
 4163 2554 0120A0E3 		mov	r2, #1
 4164 2558 28308DE2 		add	r3, sp, #40
 4165 255c 00C08DE5 		str	ip, [sp, #0]
 4166 2560 FEFFFFEB 		bl	_txe_event_flags_get
 4167 2564 000050E3 		cmp	r0, #0
 4168 2568 3000001A 		bne	.L320
3359:../uvc.c      ****             if (!isUsbConnected)
 4169              		.loc 1 3359 0
 4170 256c 303095E5 		ldr	r3, [r5, #48]
 4171 2570 000053E3 		cmp	r3, #0
 4172 2574 8C00000A 		beq	.L477
 4173              	.L321:
3368:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4174              		.loc 1 3368 0
 4175 2578 28309DE5 		ldr	r3, [sp, #40]
 4176 257c 0C0013E3 		tst	r3, #12
 4177 2580 7500001A 		bne	.L478
 4178              	.L322:
3375:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4179              		.loc 1 3375 0
 4180 2584 040013E3 		tst	r3, #4
 4181 2588 1C00000A 		beq	.L323
3377:../uvc.c      ****             	switch ((wIndex >> 8))
 4182              		.loc 1 3377 0
 4183 258c B0E0DBE1 		ldrh	lr, [fp, #0]
 4184 2590 2E24A0E1 		mov	r2, lr, lsr #8
 4185 2594 030052E3 		cmp	r2, #3
 4186 2598 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4187 259c 120000EA 		b	.L324
 4188              	.L329:
 4189 25a0 EC250000 		.word	.L324
 4190 25a4 DC260000 		.word	.L326
 4191 25a8 B0250000 		.word	.L327
 4192 25ac 18270000 		.word	.L328
 4193              	.L327:
 4194              	.LBB90:
 4195              	.LBB93:
2599:../uvc.c      ****     switch (wValue)
 4196              		.loc 1 2599 0
 4197 25b0 B020DAE1 		ldrh	r2, [sl, #0]
 4198 25b4 060C52E3 		cmp	r2, #1536
 4199 25b8 8F02000A 		beq	.L335
 4200 25bc D900008A 		bhi	.L341
 4201 25c0 030C52E3 		cmp	r2, #768
 4202 25c4 8802000A 		beq	.L333
 4203 25c8 C501008A 		bhi	.L342
 4204 25cc 010C52E3 		cmp	r2, #256
 4205 25d0 8102000A 		beq	.L331
 4206 25d4 020C52E3 		cmp	r2, #512
 4207 25d8 7B02000A 		beq	.L479
 4208              	.L344:
 4209              	.LBE93:
 4210              	.LBE90:
 4211              	.LBB97:
 4212              	.LBB102:
2731:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4213              		.loc 1 2731 0
 4214 25dc 041B9FE5 		ldr	r1, .L488+24
 4215 25e0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4216 25e4 0400A0E3 		mov	r0, #4
 4217 25e8 FEFFFFEB 		bl	CyU3PDebugPrint
 4218              	.L324:
 4219              	.LBE102:
 4220              	.LBE97:
3398:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4221              		.loc 1 3398 0
 4222 25ec 0000A0E3 		mov	r0, #0
 4223 25f0 0110A0E3 		mov	r1, #1
 4224 25f4 0020A0E1 		mov	r2, r0
 4225 25f8 FEFFFFEB 		bl	CyU3PUsbStall
 4226 25fc 28309DE5 		ldr	r3, [sp, #40]
 4227              	.L323:
3403:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4228              		.loc 1 3403 0
 4229 2600 080013E3 		tst	r3, #8
 4230 2604 0700000A 		beq	.L385
3407:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4231              		.loc 1 3407 0
 4232 2608 B030DBE1 		ldrh	r3, [fp, #0]
 4233 260c 010053E3 		cmp	r3, #1
 4234 2610 6B00000A 		beq	.L386
 4235              	.L387:
 4236              	.LBB107:
 4237              	.LBB112:
3322:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4238              		.loc 1 3322 0
 4239 2614 0000A0E3 		mov	r0, #0
 4240 2618 0110A0E3 		mov	r1, #1
 4241 261c 0020A0E1 		mov	r2, r0
 4242 2620 FEFFFFEB 		bl	CyU3PUsbStall
 4243              	.L467:
 4244 2624 28309DE5 		ldr	r3, [sp, #40]
 4245              	.L385:
 4246              	.LBE112:
 4247              	.LBE107:
3418:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4248              		.loc 1 3418 0
 4249 2628 400013E3 		tst	r3, #64
 4250 262c 0100001A 		bne	.L480
 4251              	.L320:
3631:../uvc.c      ****         CyU3PThreadRelinquish ();
 4252              		.loc 1 3631 0
 4253 2630 FEFFFFEB 		bl	_txe_thread_relinquish
3632:../uvc.c      ****     }
 4254              		.loc 1 3632 0
 4255 2634 C3FFFFEA 		b	.L458
 4256              	.L480:
3423:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4257              		.loc 1 3423 0
 4258 2638 1800A0E3 		mov	r0, #24
 4259 263c 24108DE2 		add	r1, sp, #36
 4260 2640 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3480:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4261              		.loc 1 3480 0
 4262 2644 7F36D6E5 		ldrb	r3, [r6, #1663]	@ zero_extendqisi2
 4263 2648 0F0053E3 		cmp	r3, #15
 4264 264c 9400000A 		beq	.L481
3507:../uvc.c      **** 				}else if(!snapButFlag){
 4265              		.loc 1 3507 0
 4266 2650 000053E3 		cmp	r3, #0
 4267 2654 F5FFFF1A 		bne	.L320
3509:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4268              		.loc 1 3509 0
 4269 2658 002097E5 		ldr	r2, [r7, #0]
 4270 265c 0290A0E3 		mov	r9, #2
 4271 2660 0090C2E5 		strb	r9, [r2, #0]
3510:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4272              		.loc 1 3510 0
 4273 2664 001097E5 		ldr	r1, [r7, #0]
 4274 2668 0190A0E3 		mov	r9, #1
 4275 266c 0190C1E5 		strb	r9, [r1, #1]
3511:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4276              		.loc 1 3511 0
 4277 2670 000097E5 		ldr	r0, [r7, #0]
3515:../uvc.c      **** 					interStabuf.size   = 1024;
 4278              		.loc 1 3515 0
 4279 2674 01CBA0E3 		mov	ip, #1024	@ movhi
3511:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4280              		.loc 1 3511 0
 4281 2678 0230C0E5 		strb	r3, [r0, #2]
3512:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4282              		.loc 1 3512 0
 4283 267c 00E097E5 		ldr	lr, [r7, #0]
3521:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4284              		.loc 1 3521 0
 4285 2680 0010E0E3 		mvn	r1, #0
3512:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4286              		.loc 1 3512 0
 4287 2684 0390CEE5 		strb	r9, [lr, #3]
3514:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4288              		.loc 1 3514 0
 4289 2688 002097E5 		ldr	r2, [r7, #0]
3518:../uvc.c      **** 					interStabuf.count = 4;
 4290              		.loc 1 3518 0
 4291 268c 04E0A0E3 		mov	lr, #4	@ movhi
3521:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4292              		.loc 1 3521 0
 4293 2690 540A9FE5 		ldr	r0, .L488+28
3514:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4294              		.loc 1 3514 0
 4295 2694 18208DE5 		str	r2, [sp, #24]
3515:../uvc.c      **** 					interStabuf.size   = 1024;
 4296              		.loc 1 3515 0
 4297 2698 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3516:../uvc.c      **** 					interStabuf.status = 0;
 4298              		.loc 1 3516 0
 4299 269c B032CDE1 		strh	r3, [sp, #32]	@ movhi
3518:../uvc.c      **** 					interStabuf.count = 4;
 4300              		.loc 1 3518 0
 4301 26a0 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3521:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4302              		.loc 1 3521 0
 4303 26a4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3524:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4304              		.loc 1 3524 0
 4305 26a8 3C0A9FE5 		ldr	r0, .L488+28
 4306 26ac 18108DE2 		add	r1, sp, #24
 4307 26b0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4308              	.LVL315:
3526:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4309              		.loc 1 3526 0
 4310 26b4 002050E2 		subs	r2, r0, #0
 4311 26b8 6901001A 		bne	.L482
3532:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4312              		.loc 1 3532 0
 4313 26bc 3010A0E3 		mov	r1, #48
 4314 26c0 0920A0E1 		mov	r2, r9
 4315 26c4 0500A0E3 		mov	r0, #5
 4316              	.LVL316:
 4317 26c8 FEFFFFEB 		bl	SensorSetControl
3533:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4318              		.loc 1 3533 0
 4319 26cc 003A9FE5 		ldr	r3, .L488+4
 4320 26d0 7F96C3E5 		strb	r9, [r3, #1663]
3631:../uvc.c      ****         CyU3PThreadRelinquish ();
 4321              		.loc 1 3631 0
 4322 26d4 FEFFFFEB 		bl	_txe_thread_relinquish
 4323 26d8 9AFFFFEA 		b	.L458
 4324              	.L326:
 4325              	.LBB118:
 4326              	.LBB101:
2674:../uvc.c      ****     switch (wValue)
 4327              		.loc 1 2674 0
 4328 26dc B020DAE1 		ldrh	r2, [sl, #0]
 4329 26e0 060C52E3 		cmp	r2, #1536
 4330 26e4 3402000A 		beq	.L350
 4331 26e8 9900008A 		bhi	.L356
 4332 26ec 030C52E3 		cmp	r2, #768
 4333 26f0 2D02000A 		beq	.L347
 4334 26f4 6801008A 		bhi	.L357
 4335 26f8 010C52E3 		cmp	r2, #256
 4336 26fc 2602000A 		beq	.L345
 4337 2700 020C52E3 		cmp	r2, #512
 4338 2704 B4FFFF1A 		bne	.L344
 4339              	.LVL317:
2682:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4340              		.loc 1 2682 0
 4341 2708 0100A0E3 		mov	r0, #1
 4342 270c FEFFFFEB 		bl	CTControlHandle
 4343              	.LVL318:
 4344 2710 28309DE5 		ldr	r3, [sp, #40]
 4345 2714 B9FFFFEA 		b	.L323
 4346              	.L328:
 4347              	.LBE101:
 4348              	.LBE118:
 4349              	.LBB119:
 4350              	.LBB125:
2899:../uvc.c      ****     switch (wValue)
 4351              		.loc 1 2899 0
 4352 2718 B030DAE1 		ldrh	r3, [sl, #0]
 4353 271c 090C53E3 		cmp	r3, #2304
 4354 2720 1902000A 		beq	.L371
 4355 2724 9200008A 		bhi	.L380
 4356 2728 010B53E3 		cmp	r3, #1024
 4357 272c 1202000A 		beq	.L366
 4358 2730 7C01008A 		bhi	.L381
 4359 2734 020C53E3 		cmp	r3, #512
 4360 2738 0B02000A 		beq	.L364
 4361 273c 030C53E3 		cmp	r3, #768
 4362 2740 0502000A 		beq	.L365
 4363 2744 010C53E3 		cmp	r3, #256
 4364 2748 A7FFFF1A 		bne	.L324
 4365              	.LVL319:
2903:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4366              		.loc 1 2903 0
 4367 274c 1000A0E3 		mov	r0, #16
 4368 2750 FEFFFFEB 		bl	ControlHandle
 4369              	.LVL320:
 4370 2754 28309DE5 		ldr	r3, [sp, #40]
 4371 2758 A8FFFFEA 		b	.L323
 4372              	.L478:
 4373              	.LBE125:
 4374              	.LBE119:
3369:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4375              		.loc 1 3369 0
 4376 275c B0C0DAE1 		ldrh	ip, [sl, #0]
 4377 2760 88999FE5 		ldr	r9, .L488+32
 4378 2764 88199FE5 		ldr	r1, .L488+36
 4379 2768 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4380 276c 08C08DE5 		str	ip, [sp, #8]
 4381 2770 B000DBE1 		ldrh	r0, [fp, #0]
 4382 2774 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4383 2778 0C008DE5 		str	r0, [sp, #12]
 4384 277c B0C0D1E1 		ldrh	ip, [r1, #0]
 4385 2780 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4386 2784 04908DE5 		str	r9, [sp, #4]
 4387 2788 0400A0E3 		mov	r0, #4
 4388 278c 64199FE5 		ldr	r1, .L488+40
 4389 2790 0090A0E3 		mov	r9, #0
 4390 2794 00E08DE5 		str	lr, [sp, #0]
 4391 2798 10C08DE5 		str	ip, [sp, #16]
 4392 279c 14908DE5 		str	r9, [sp, #20]
 4393 27a0 FEFFFFEB 		bl	CyU3PDebugPrint
 4394 27a4 28309DE5 		ldr	r3, [sp, #40]
 4395 27a8 75FFFFEA 		b	.L322
 4396              	.L477:
3361:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4397              		.loc 1 3361 0
 4398 27ac FEFFFFEB 		bl	CyU3PUsbGetSpeed
3362:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4399              		.loc 1 3362 0
 4400 27b0 000050E3 		cmp	r0, #0
3361:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4401              		.loc 1 3361 0
 4402 27b4 4800C5E5 		strb	r0, [r5, #72]
3364:../uvc.c      ****                     isUsbConnected = CyTrue;
 4403              		.loc 1 3364 0
 4404 27b8 0100A013 		movne	r0, #1
 4405 27bc 30008515 		strne	r0, [r5, #48]
 4406 27c0 6CFFFFEA 		b	.L321
 4407              	.L386:
 4408              	.LVL321:
 4409              	.LBB131:
 4410              	.LBB113:
2994:../uvc.c      ****     switch (wValue)
 4411              		.loc 1 2994 0
 4412 27c4 B020DAE1 		ldrh	r2, [sl, #0]
 4413 27c8 030C52E3 		cmp	r2, #768
 4414 27cc 9B00000A 		beq	.L390
 4415 27d0 0F00008A 		bhi	.L393
 4416 27d4 010C52E3 		cmp	r2, #256
 4417 27d8 A500000A 		beq	.L388
 4418 27dc 020C52E3 		cmp	r2, #512
 4419 27e0 8BFFFF1A 		bne	.L387
3059:../uvc.c      ****             switch (bRequest)
 4420              		.loc 1 3059 0
 4421 27e4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4422 27e8 810053E3 		cmp	r3, #129
 4423 27ec D201000A 		beq	.L445
 4424 27f0 E500008A 		bhi	.L408
 4425 27f4 010053E3 		cmp	r3, #1
 4426 27f8 9401000A 		beq	.L483
 4427              	.L428:
3260:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4428              		.loc 1 3260 0
 4429 27fc 0000A0E3 		mov	r0, #0
 4430 2800 0110A0E3 		mov	r1, #1
 4431 2804 0020A0E1 		mov	r2, r0
 4432 2808 FEFFFFEB 		bl	CyU3PUsbStall
 4433 280c 28309DE5 		ldr	r3, [sp, #40]
 4434 2810 84FFFFEA 		b	.L385
 4435              	.L393:
2994:../uvc.c      ****     switch (wValue)
 4436              		.loc 1 2994 0
 4437 2814 010B52E3 		cmp	r2, #1024
 4438 2818 6200000A 		beq	.L391
 4439 281c 050C52E3 		cmp	r2, #1280
 4440 2820 7BFFFF1A 		bne	.L387
3267:../uvc.c      ****             	switch (bRequest)
 4441              		.loc 1 3267 0
 4442 2824 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4443 2828 810052E3 		cmp	r2, #129
 4444 282c C201000A 		beq	.L445
 4445 2830 1401008A 		bhi	.L448
 4446 2834 010052E3 		cmp	r2, #1
 4447 2838 75FFFF1A 		bne	.L387
3292:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4448              		.loc 1 3292 0
 4449 283c 2000A0E3 		mov	r0, #32
 4450 2840 B4189FE5 		ldr	r1, .L488+44
 4451 2844 2E208DE2 		add	r2, sp, #46
 4452 2848 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4453              	.LVL322:
3294:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4454              		.loc 1 3294 0
 4455 284c 000050E3 		cmp	r0, #0
 4456 2850 7801001A 		bne	.L450
3298:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4457              		.loc 1 3298 0
 4458 2854 0020A0E3 		mov	r2, #0
 4459 2858 70089FE5 		ldr	r0, .L488
 4460              	.LVL323:
 4461 285c 8010A0E3 		mov	r1, #128
 4462 2860 FEFFFFEB 		bl	_txe_event_flags_set
 4463              	.LVL324:
3299:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4464              		.loc 1 3299 0
 4465 2864 002050E2 		subs	r2, r0, #0
3305:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4466              		.loc 1 3305 0
 4467 2868 0F00E003 		mvneq	r0, #15
 4468              	.LVL325:
 4469 286c 3A00C505 		streqb	r0, [r5, #58]
3299:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4470              		.loc 1 3299 0
 4471 2870 0200000A 		beq	.L452
3301:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4472              		.loc 1 3301 0
 4473 2874 84189FE5 		ldr	r1, .L488+48
 4474 2878 0400A0E3 		mov	r0, #4
 4475 287c FEFFFFEB 		bl	CyU3PDebugPrint
 4476              	.LVL326:
 4477              	.L452:
3308:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4478              		.loc 1 3308 0
 4479 2880 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 4480 2884 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4481 2888 BE22DDE1 		ldrh	r2, [sp, #46]
 4482              	.LVL327:
 4483 288c 0400A0E3 		mov	r0, #4
 4484 2890 6C189FE5 		ldr	r1, .L488+52
 4485 2894 00C08DE5 		str	ip, [sp, #0]
 4486 2898 FEFFFFEB 		bl	CyU3PDebugPrint
 4487 289c 28309DE5 		ldr	r3, [sp, #40]
 4488 28a0 60FFFFEA 		b	.L385
 4489              	.LVL328:
 4490              	.L481:
 4491              	.LBE113:
 4492              	.LBE131:
3482:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4493              		.loc 1 3482 0
 4494 28a4 003097E5 		ldr	r3, [r7, #0]
 4495 28a8 0290A0E3 		mov	r9, #2
 4496 28ac 0090C3E5 		strb	r9, [r3, #0]
3483:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4497              		.loc 1 3483 0
 4498 28b0 002097E5 		ldr	r2, [r7, #0]
 4499 28b4 0190A0E3 		mov	r9, #1
 4500 28b8 0190C2E5 		strb	r9, [r2, #1]
3484:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4501              		.loc 1 3484 0
 4502 28bc 001097E5 		ldr	r1, [r7, #0]
 4503 28c0 0030A0E3 		mov	r3, #0
 4504 28c4 0230C1E5 		strb	r3, [r1, #2]
3485:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4505              		.loc 1 3485 0
 4506 28c8 000097E5 		ldr	r0, [r7, #0]
3491:../uvc.c      **** 					interStabuf.count = 4;
 4507              		.loc 1 3491 0
 4508 28cc 0420A0E3 		mov	r2, #4	@ movhi
3485:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4509              		.loc 1 3485 0
 4510 28d0 0330C0E5 		strb	r3, [r0, #3]
3487:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4511              		.loc 1 3487 0
 4512 28d4 00C097E5 		ldr	ip, [r7, #0]
3488:../uvc.c      **** 					interStabuf.size   = 1024;
 4513              		.loc 1 3488 0
 4514 28d8 01EBA0E3 		mov	lr, #1024	@ movhi
3494:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4515              		.loc 1 3494 0
 4516 28dc 0010E0E3 		mvn	r1, #0
 4517 28e0 04089FE5 		ldr	r0, .L488+28
3491:../uvc.c      **** 					interStabuf.count = 4;
 4518              		.loc 1 3491 0
 4519 28e4 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3487:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4520              		.loc 1 3487 0
 4521 28e8 18C08DE5 		str	ip, [sp, #24]
3488:../uvc.c      **** 					interStabuf.size   = 1024;
 4522              		.loc 1 3488 0
 4523 28ec BEE1CDE1 		strh	lr, [sp, #30]	@ movhi
3489:../uvc.c      **** 					interStabuf.status = 0;
 4524              		.loc 1 3489 0
 4525 28f0 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3494:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4526              		.loc 1 3494 0
 4527 28f4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3497:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4528              		.loc 1 3497 0
 4529 28f8 EC079FE5 		ldr	r0, .L488+28
 4530 28fc 18108DE2 		add	r1, sp, #24
 4531 2900 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4532              	.LVL329:
3499:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4533              		.loc 1 3499 0
 4534 2904 002050E2 		subs	r2, r0, #0
 4535 2908 FD00001A 		bne	.L484
3504:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 4536              		.loc 1 3504 0
 4537 290c 3010A0E3 		mov	r1, #48
 4538 2910 0500A0E3 		mov	r0, #5
 4539              	.LVL330:
 4540 2914 FEFFFFEB 		bl	SensorSetControl
 4541              	.LVL331:
3506:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 4542              		.loc 1 3506 0
 4543 2918 B4C79FE5 		ldr	ip, .L488+4
 4544 291c 7F96CCE5 		strb	r9, [ip, #1663]
3631:../uvc.c      ****         CyU3PThreadRelinquish ();
 4545              		.loc 1 3631 0
 4546 2920 FEFFFFEB 		bl	_txe_thread_relinquish
 4547 2924 07FFFFEA 		b	.L458
 4548              	.L341:
 4549              	.LBB132:
 4550              	.LBB94:
2599:../uvc.c      ****     switch (wValue)
 4551              		.loc 1 2599 0
 4552 2928 0A0C52E3 		cmp	r2, #2560
 4553 292c 3D01000A 		beq	.L338
 4554 2930 E100008A 		bhi	.L343
 4555 2934 070C52E3 		cmp	r2, #1792
 4556 2938 3601000A 		beq	.L336
 4557 293c 020B52E3 		cmp	r2, #2048
 4558 2940 25FFFF1A 		bne	.L344
 4559              	.LVL332:
2630:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4560              		.loc 1 2630 0
 4561 2944 0700A0E3 		mov	r0, #7
 4562 2948 FEFFFFEB 		bl	ControlHandle
 4563              	.LVL333:
 4564 294c 28309DE5 		ldr	r3, [sp, #40]
 4565 2950 2AFFFFEA 		b	.L323
 4566              	.L356:
 4567              	.LBE94:
 4568              	.LBE132:
 4569              	.LBB133:
 4570              	.LBB103:
2674:../uvc.c      ****     switch (wValue)
 4571              		.loc 1 2674 0
 4572 2954 090C52E3 		cmp	r2, #2304
 4573 2958 2A01000A 		beq	.L352
 4574 295c FA00008A 		bhi	.L358
 4575 2960 070C52E3 		cmp	r2, #1792
 4576 2964 2301000A 		beq	.L351
 4577 2968 020B52E3 		cmp	r2, #2048
 4578 296c 1AFFFF1A 		bne	.L344
 4579 2970 22FFFFEA 		b	.L323
 4580              	.L380:
 4581              	.LBE103:
 4582              	.LBE133:
 4583              	.LBB134:
 4584              	.LBB124:
2899:../uvc.c      ****     switch (wValue)
 4585              		.loc 1 2899 0
 4586 2974 0F0C53E3 		cmp	r3, #3840
 4587 2978 1A01000A 		beq	.L375
 4588 297c 4900008A 		bhi	.L383
 4589 2980 0B0C53E3 		cmp	r3, #2816
 4590 2984 1301000A 		beq	.L373
 4591 2988 0D0C53E3 		cmp	r3, #3328
 4592 298c 0D01000A 		beq	.L374
 4593 2990 0A0C53E3 		cmp	r3, #2560
 4594 2994 14FFFF1A 		bne	.L324
 4595              	.LVL334:
2940:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4596              		.loc 1 2940 0
 4597 2998 1900A0E3 		mov	r0, #25
 4598 299c FEFFFFEB 		bl	ControlHandle
 4599              	.LVL335:
 4600 29a0 28309DE5 		ldr	r3, [sp, #40]
 4601 29a4 15FFFFEA 		b	.L323
 4602              	.LVL336:
 4603              	.L391:
 4604              	.LBE124:
 4605              	.LBE134:
 4606              	.LBB135:
 4607              	.LBB111:
3186:../uvc.c      ****                 switch (bRequest)
 4608              		.loc 1 3186 0
 4609 29a8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4610 29ac 810052E3 		cmp	r2, #129
 4611 29b0 2700000A 		beq	.L430
 4612 29b4 7A00008A 		bhi	.L433
 4613 29b8 010052E3 		cmp	r2, #1
 4614 29bc 8EFFFF1A 		bne	.L428
3211:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4615              		.loc 1 3211 0
 4616 29c0 2000A0E3 		mov	r0, #32
 4617 29c4 30179FE5 		ldr	r1, .L488+44
 4618 29c8 2E208DE2 		add	r2, sp, #46
 4619 29cc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4620              	.LVL337:
3213:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4621              		.loc 1 3213 0
 4622 29d0 000050E3 		cmp	r0, #0
 4623 29d4 12FFFF1A 		bne	.L467
3232:../uvc.c      ****                            switch (glCommitCtrl[1])
 4624              		.loc 1 3232 0
 4625 29d8 8100D5E5 		ldrb	r0, [r5, #129]	@ zero_extendqisi2
 4626              	.LVL338:
 4627 29dc 020050E3 		cmp	r0, #2
 4628 29e0 9201000A 		beq	.L438
 4629 29e4 030050E3 		cmp	r0, #3
 4630 29e8 8701000A 		beq	.L439
 4631 29ec 010050E3 		cmp	r0, #1
 4632 29f0 0800001A 		bne	.L436
3245:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 4633              		.loc 1 3245 0
 4634 29f4 58C094E5 		ldr	ip, [r4, #88]
 4635 29f8 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 4636 29fc 00005CE3 		cmp	ip, #0
 4637 2a00 C4C0A003 		moveq	ip, #196
 4638 2a04 44C0A013 		movne	ip, #68
 4639 2a08 03208CE1 		orr	r2, ip, r3
 4640 2a0c 3010A0E3 		mov	r1, #48
 4641 2a10 5230A0E3 		mov	r3, #82
 4642 2a14 FEFFFFEB 		bl	SensorSetIrisControl
 4643              	.L436:
3252:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4644              		.loc 1 3252 0
 4645 2a18 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3254:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4646              		.loc 1 3254 0
 4647 2a1c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4648 2a20 BE22DDE1 		ldrh	r2, [sp, #46]
 4649              	.LVL339:
 4650 2a24 0400A0E3 		mov	r0, #4
 4651 2a28 D8169FE5 		ldr	r1, .L488+56
3252:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4652              		.loc 1 3252 0
 4653 2a2c A0E0C4E5 		strb	lr, [r4, #160]
3254:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4654              		.loc 1 3254 0
 4655 2a30 00E08DE5 		str	lr, [sp, #0]
 4656 2a34 FEFFFFEB 		bl	CyU3PDebugPrint
 4657 2a38 28309DE5 		ldr	r3, [sp, #40]
 4658 2a3c F9FEFFEA 		b	.L385
 4659              	.LVL340:
 4660              	.L390:
3136:../uvc.c      ****                 switch (bRequest)
 4661              		.loc 1 3136 0
 4662 2a40 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4663 2a44 830052E3 		cmp	r2, #131
 4664 2a48 8000008A 		bhi	.L424
 4665 2a4c 810052E3 		cmp	r2, #129
 4666 2a50 5E00003A 		bcc	.L485
 4667              	.L430:
3198:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4668              		.loc 1 3198 0
 4669 2a54 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3200:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4670              		.loc 1 3200 0
 4671 2a58 0B00A0E3 		mov	r0, #11
3198:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4672              		.loc 1 3198 0
 4673 2a5c 030052E3 		cmp	r2, #3
3200:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4674              		.loc 1 3200 0
 4675 2a60 A4169F05 		ldreq	r1, .L488+60
3204:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4676              		.loc 1 3204 0
 4677 2a64 A4169F15 		ldrne	r1, .L488+64
 4678 2a68 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4679 2a6c 28309DE5 		ldr	r3, [sp, #40]
 4680 2a70 ECFEFFEA 		b	.L385
 4681              	.L388:
2997:../uvc.c      ****             switch (bRequest)
 4682              		.loc 1 2997 0
 4683 2a74 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4684 2a78 830052E3 		cmp	r2, #131
 4685 2a7c 2B00008A 		bhi	.L399
 4686 2a80 810052E3 		cmp	r2, #129
 4687 2a84 1000003A 		bcc	.L486
 4688              	.L396:
3012:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4689              		.loc 1 3012 0
 4690 2a88 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4691 2a8c 030053E3 		cmp	r3, #3
 4692 2a90 C300000A 		beq	.L487
 4693              	.L449:
3285:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4694              		.loc 1 3285 0
 4695 2a94 1A00A0E3 		mov	r0, #26
 4696 2a98 74169FE5 		ldr	r1, .L488+68
 4697 2a9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4698 2aa0 28309DE5 		ldr	r3, [sp, #40]
 4699 2aa4 DFFEFFEA 		b	.L385
 4700              	.LVL341:
 4701              	.L383:
 4702              	.LBE111:
 4703              	.LBE135:
 4704              	.LBB136:
 4705              	.LBB126:
2899:../uvc.c      ****     switch (wValue)
 4706              		.loc 1 2899 0
 4707 2aa8 110C53E3 		cmp	r3, #4352
 4708 2aac B800000A 		beq	.L377
 4709 2ab0 2D00008A 		bhi	.L384
 4710 2ab4 010A53E3 		cmp	r3, #4096
 4711 2ab8 CBFEFF1A 		bne	.L324
 4712              	.LVL342:
2962:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4713              		.loc 1 2962 0
 4714 2abc 1F00A0E3 		mov	r0, #31
 4715 2ac0 FEFFFFEB 		bl	ControlHandle
 4716              	.LVL343:
 4717 2ac4 28309DE5 		ldr	r3, [sp, #40]
 4718 2ac8 CCFEFFEA 		b	.L323
 4719              	.LVL344:
 4720              	.L486:
 4721              	.LBE126:
 4722              	.LBE136:
 4723              	.LBB137:
 4724              	.LBB114:
2997:../uvc.c      ****             switch (bRequest)
 4725              		.loc 1 2997 0
 4726 2acc 010052E3 		cmp	r2, #1
 4727 2ad0 49FFFF1A 		bne	.L428
3024:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4728              		.loc 1 3024 0
 4729 2ad4 2000A0E3 		mov	r0, #32
 4730 2ad8 1C169FE5 		ldr	r1, .L488+44
 4731 2adc 2E208DE2 		add	r2, sp, #46
 4732 2ae0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4733              	.LVL345:
3026:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4734              		.loc 1 3026 0
 4735 2ae4 000050E3 		cmp	r0, #0
 4736 2ae8 CDFEFF1A 		bne	.L467
3028:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4737              		.loc 1 3028 0
 4738 2aec 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4739 2af0 030051E3 		cmp	r1, #3
 4740 2af4 CAFEFF1A 		bne	.L467
3035:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4741              		.loc 1 3035 0
 4742 2af8 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3032:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4743              		.loc 1 3032 0
 4744 2afc 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3033:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4745              		.loc 1 3033 0
 4746 2b00 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3034:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4747              		.loc 1 3034 0
 4748 2b04 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 4749              	.LVL346:
3036:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4750              		.loc 1 3036 0
 4751 2b08 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3037:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4752              		.loc 1 3037 0
 4753 2b0c 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3035:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4754              		.loc 1 3035 0
 4755 2b10 1936C6E5 		strb	r3, [r6, #1561]
3032:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4756              		.loc 1 3032 0
 4757 2b14 16E6C6E5 		strb	lr, [r6, #1558]
3033:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4758              		.loc 1 3033 0
 4759 2b18 17C6C6E5 		strb	ip, [r6, #1559]
3034:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4760              		.loc 1 3034 0
 4761 2b1c 1806C6E5 		strb	r0, [r6, #1560]
3036:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4762              		.loc 1 3036 0
 4763 2b20 1A26C6E5 		strb	r2, [r6, #1562]
3037:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4764              		.loc 1 3037 0
 4765 2b24 1B96C6E5 		strb	r9, [r6, #1563]
 4766 2b28 28309DE5 		ldr	r3, [sp, #40]
 4767 2b2c BDFEFFEA 		b	.L385
 4768              	.LVL347:
 4769              	.L399:
2997:../uvc.c      ****             switch (bRequest)
 4770              		.loc 1 2997 0
 4771 2b30 860052E3 		cmp	r2, #134
 4772 2b34 1E00000A 		beq	.L471
 4773 2b38 870052E3 		cmp	r2, #135
 4774 2b3c D1FFFF0A 		beq	.L396
 4775              	.L476:
3136:../uvc.c      ****                 switch (bRequest)
 4776              		.loc 1 3136 0
 4777 2b40 850052E3 		cmp	r2, #133
 4778 2b44 2CFFFF1A 		bne	.L428
 4779              	.L431:
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4780              		.loc 1 3195 0
 4781 2b48 C8159FE5 		ldr	r1, .L488+72
 4782 2b4c 0200A0E3 		mov	r0, #2
3193:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4783              		.loc 1 3193 0
 4784 2b50 1A30A0E3 		mov	r3, #26
 4785              	.L468:
3275:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4786              		.loc 1 3275 0
 4787 2b54 0090A0E3 		mov	r9, #0
3274:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4788              		.loc 1 3274 0
 4789 2b58 5C30C4E5 		strb	r3, [r4, #92]
3275:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4790              		.loc 1 3275 0
 4791 2b5c 5D90C4E5 		strb	r9, [r4, #93]
3276:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4792              		.loc 1 3276 0
 4793 2b60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4794 2b64 28309DE5 		ldr	r3, [sp, #40]
 4795 2b68 AEFEFFEA 		b	.L385
 4796              	.LVL348:
 4797              	.L384:
 4798              	.LBE114:
 4799              	.LBE137:
 4800              	.LBB138:
 4801              	.LBB123:
2899:../uvc.c      ****     switch (wValue)
 4802              		.loc 1 2899 0
 4803 2b6c 120C53E3 		cmp	r3, #4608
 4804 2b70 5201000A 		beq	.L378
 4805 2b74 130C53E3 		cmp	r3, #4864
 4806 2b78 9BFEFF1A 		bne	.L324
 4807              	.LVL349:
2974:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4808              		.loc 1 2974 0
 4809 2b7c 2200A0E3 		mov	r0, #34
 4810 2b80 FEFFFFEB 		bl	ControlHandle
 4811              	.LVL350:
 4812 2b84 28309DE5 		ldr	r3, [sp, #40]
 4813 2b88 9CFEFFEA 		b	.L323
 4814              	.LVL351:
 4815              	.L408:
 4816              	.LBE123:
 4817              	.LBE138:
 4818              	.LBB139:
 4819              	.LBB110:
3059:../uvc.c      ****             switch (bRequest)
 4820              		.loc 1 3059 0
 4821 2b8c 850053E3 		cmp	r3, #133
 4822 2b90 ECFFFF0A 		beq	.L431
 4823 2b94 860053E3 		cmp	r3, #134
 4824 2b98 17FFFF1A 		bne	.L428
 4825              	.L472:
3063:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4826              		.loc 1 3063 0
 4827 2b9c 0100A0E3 		mov	r0, #1
 4828 2ba0 040000EA 		b	.L466
 4829              	.L433:
3186:../uvc.c      ****                 switch (bRequest)
 4830              		.loc 1 3186 0
 4831 2ba4 850052E3 		cmp	r2, #133
 4832 2ba8 E6FFFF0A 		beq	.L431
 4833 2bac 860052E3 		cmp	r2, #134
 4834 2bb0 11FFFF1A 		bne	.L428
 4835              	.L471:
3190:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4836              		.loc 1 3190 0
 4837 2bb4 0300A0E1 		mov	r0, r3
 4838              	.L466:
3063:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4839              		.loc 1 3063 0
 4840 2bb8 58159FE5 		ldr	r1, .L488+72
3062:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4841              		.loc 1 3062 0
 4842 2bbc 0390A0E3 		mov	r9, #3
 4843 2bc0 5C90C4E5 		strb	r9, [r4, #92]
3063:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4844              		.loc 1 3063 0
 4845 2bc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4846 2bc8 28309DE5 		ldr	r3, [sp, #40]
 4847 2bcc 95FEFFEA 		b	.L385
 4848              	.L485:
3136:../uvc.c      ****                 switch (bRequest)
 4849              		.loc 1 3136 0
 4850 2bd0 010052E3 		cmp	r2, #1
 4851 2bd4 08FFFF1A 		bne	.L428
3161:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4852              		.loc 1 3161 0
 4853 2bd8 2000A0E3 		mov	r0, #32
 4854 2bdc 18159FE5 		ldr	r1, .L488+44
 4855 2be0 2E208DE2 		add	r2, sp, #46
 4856 2be4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4857              	.LVL352:
3163:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4858              		.loc 1 3163 0
 4859 2be8 000050E3 		cmp	r0, #0
 4860 2bec 8CFEFF1A 		bne	.L467
3165:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4861              		.loc 1 3165 0
 4862 2bf0 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4863 2bf4 030051E3 		cmp	r1, #3
 4864 2bf8 0B00001A 		bne	.L427
3169:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4865              		.loc 1 3169 0
 4866 2bfc 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3170:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4867              		.loc 1 3170 0
 4868 2c00 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3171:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4869              		.loc 1 3171 0
 4870 2c04 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 4871              	.LVL353:
3172:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4872              		.loc 1 3172 0
 4873 2c08 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3173:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4874              		.loc 1 3173 0
 4875 2c0c 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3174:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4876              		.loc 1 3174 0
 4877 2c10 8690D5E5 		ldrb	r9, [r5, #134]	@ zero_extendqisi2
3169:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4878              		.loc 1 3169 0
 4879 2c14 69E6C6E5 		strb	lr, [r6, #1641]
3170:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4880              		.loc 1 3170 0
 4881 2c18 6AC6C6E5 		strb	ip, [r6, #1642]
3171:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4882              		.loc 1 3171 0
 4883 2c1c 6B06C6E5 		strb	r0, [r6, #1643]
3172:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4884              		.loc 1 3172 0
 4885 2c20 6C36C6E5 		strb	r3, [r6, #1644]
3173:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4886              		.loc 1 3173 0
 4887 2c24 6D26C6E5 		strb	r2, [r6, #1645]
3174:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4888              		.loc 1 3174 0
 4889 2c28 6E96C6E5 		strb	r9, [r6, #1646]
 4890              	.L427:
3176:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4891              		.loc 1 3176 0
 4892 2c2c 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 4893 2c30 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4894 2c34 BE22DDE1 		ldrh	r2, [sp, #46]
 4895              	.LVL354:
 4896 2c38 0400A0E3 		mov	r0, #4
 4897 2c3c D8149FE5 		ldr	r1, .L488+76
 4898 2c40 00908DE5 		str	r9, [sp, #0]
 4899 2c44 FEFFFFEB 		bl	CyU3PDebugPrint
 4900 2c48 28309DE5 		ldr	r3, [sp, #40]
 4901 2c4c 75FEFFEA 		b	.L385
 4902              	.LVL355:
 4903              	.L424:
3136:../uvc.c      ****                 switch (bRequest)
 4904              		.loc 1 3136 0
 4905 2c50 860052E3 		cmp	r2, #134
 4906 2c54 D6FFFF0A 		beq	.L471
 4907 2c58 870052E3 		cmp	r2, #135
 4908 2c5c B7FFFF1A 		bne	.L476
 4909 2c60 7BFFFFEA 		b	.L430
 4910              	.LVL356:
 4911              	.L482:
 4912              	.LBE110:
 4913              	.LBE139:
3528:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4914              		.loc 1 3528 0
 4915 2c64 0400A0E3 		mov	r0, #4
 4916              	.LVL357:
 4917 2c68 B0149FE5 		ldr	r1, .L488+80
 4918 2c6c FEFFFFEB 		bl	CyU3PDebugPrint
 4919              	.LVL358:
 4920              	.L457:
 4921              	.LBB140:
 4922              	.LBB141:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4923              		.loc 1 1313 0
 4924 2c70 AC149FE5 		ldr	r1, .L488+84
 4925 2c74 0400A0E3 		mov	r0, #4
 4926 2c78 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 4927              		.loc 1 1314 0
 4928 2c7c FA0FA0E3 		mov	r0, #1000
 4929 2c80 FEFFFFEB 		bl	_tx_thread_sleep
 4930 2c84 F9FFFFEA 		b	.L457
 4931              	.LVL359:
 4932              	.L448:
 4933              	.LBE141:
 4934              	.LBE140:
 4935              	.LBB142:
 4936              	.LBB115:
3267:../uvc.c      ****             	switch (bRequest)
 4937              		.loc 1 3267 0
 4938 2c88 850052E3 		cmp	r2, #133
 4939 2c8c 0801000A 		beq	.L446
 4940 2c90 860052E3 		cmp	r2, #134
 4941 2c94 5EFEFF1A 		bne	.L387
 4942 2c98 BFFFFFEA 		b	.L472
 4943              	.LVL360:
 4944              	.L357:
 4945              	.LBE115:
 4946              	.LBE142:
 4947              	.LBB143:
 4948              	.LBB100:
2674:../uvc.c      ****     switch (wValue)
 4949              		.loc 1 2674 0
 4950 2c9c 010B52E3 		cmp	r2, #1024
 4951 2ca0 FF00000A 		beq	.L348
 4952 2ca4 050C52E3 		cmp	r2, #1280
 4953 2ca8 4BFEFF1A 		bne	.L344
 4954              	.LVL361:
2696:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4955              		.loc 1 2696 0
 4956 2cac 0400A0E3 		mov	r0, #4
 4957 2cb0 FEFFFFEB 		bl	CTControlHandle
 4958              	.LVL362:
 4959 2cb4 28309DE5 		ldr	r3, [sp, #40]
 4960 2cb8 50FEFFEA 		b	.L323
 4961              	.L343:
 4962              	.LBE100:
 4963              	.LBE143:
 4964              	.LBB144:
 4965              	.LBB92:
2599:../uvc.c      ****     switch (wValue)
 4966              		.loc 1 2599 0
 4967 2cbc 0D0C52E3 		cmp	r2, #3328
 4968 2cc0 5800000A 		beq	.L338
 4969 2cc4 0E0C52E3 		cmp	r2, #3584
 4970 2cc8 F100000A 		beq	.L340
 4971 2ccc 030B52E3 		cmp	r2, #3072
 4972 2cd0 41FEFF1A 		bne	.L344
 4973              	.LVL363:
2640:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4974              		.loc 1 2640 0
 4975 2cd4 0B00A0E3 		mov	r0, #11
 4976 2cd8 FEFFFFEB 		bl	ControlHandle
 4977              	.LVL364:
 4978 2cdc 28309DE5 		ldr	r3, [sp, #40]
 4979 2ce0 46FEFFEA 		b	.L323
 4980              	.L342:
2599:../uvc.c      ****     switch (wValue)
 4981              		.loc 1 2599 0
 4982 2ce4 010B52E3 		cmp	r2, #1024
 4983 2ce8 44FEFF0A 		beq	.L323
 4984 2cec 050C52E3 		cmp	r2, #1280
 4985 2cf0 39FEFF1A 		bne	.L344
 4986              	.LVL365:
2618:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4987              		.loc 1 2618 0
 4988 2cf4 0400A0E3 		mov	r0, #4
 4989 2cf8 FEFFFFEB 		bl	ControlHandle
 4990              	.LVL366:
 4991 2cfc 28309DE5 		ldr	r3, [sp, #40]
 4992 2d00 3EFEFFEA 		b	.L323
 4993              	.LVL367:
 4994              	.L484:
 4995              	.LBE92:
 4996              	.LBE144:
3501:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4997              		.loc 1 3501 0
 4998 2d04 0400A0E3 		mov	r0, #4
 4999              	.LVL368:
 5000 2d08 10149FE5 		ldr	r1, .L488+80
 5001 2d0c FEFFFFEB 		bl	CyU3PDebugPrint
 5002              	.LVL369:
 5003              	.L455:
 5004              	.LBB145:
 5005              	.LBB146:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5006              		.loc 1 1313 0
 5007 2d10 0C149FE5 		ldr	r1, .L488+84
 5008 2d14 0400A0E3 		mov	r0, #4
 5009 2d18 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 5010              		.loc 1 1314 0
 5011 2d1c FA0FA0E3 		mov	r0, #1000
 5012 2d20 FEFFFFEB 		bl	_tx_thread_sleep
 5013 2d24 F9FFFFEA 		b	.L455
 5014              	.L381:
 5015              	.LBE146:
 5016              	.LBE145:
 5017              	.LBB147:
 5018              	.LBB127:
2899:../uvc.c      ****     switch (wValue)
 5019              		.loc 1 2899 0
 5020 2d28 060C53E3 		cmp	r3, #1536
 5021 2d2c D400000A 		beq	.L368
 5022 2d30 0F00008A 		bhi	.L382
 5023 2d34 050C53E3 		cmp	r3, #1280
 5024 2d38 2BFEFF1A 		bne	.L324
 5025              	.LVL370:
2919:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5026              		.loc 1 2919 0
 5027 2d3c 1400A0E3 		mov	r0, #20
 5028 2d40 FEFFFFEB 		bl	ControlHandle
 5029              	.LVL371:
 5030 2d44 28309DE5 		ldr	r3, [sp, #40]
 5031 2d48 2CFEFFEA 		b	.L323
 5032              	.L358:
 5033              	.LBE127:
 5034              	.LBE147:
 5035              	.LBB148:
 5036              	.LBB104:
2674:../uvc.c      ****     switch (wValue)
 5037              		.loc 1 2674 0
 5038 2d4c 0B0C52E3 		cmp	r2, #2816
 5039 2d50 C700000A 		beq	.L354
 5040 2d54 030B52E3 		cmp	r2, #3072
 5041 2d58 C100000A 		beq	.L355
 5042 2d5c 0A0C52E3 		cmp	r2, #2560
 5043 2d60 1DFEFF1A 		bne	.L344
 5044              	.LVL372:
2715:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5045              		.loc 1 2715 0
 5046 2d64 0800A0E3 		mov	r0, #8
 5047 2d68 FEFFFFEB 		bl	CTControlHandle
 5048              	.LVL373:
 5049 2d6c 28309DE5 		ldr	r3, [sp, #40]
 5050 2d70 22FEFFEA 		b	.L323
 5051              	.L382:
 5052              	.LBE104:
 5053              	.LBE148:
 5054              	.LBB149:
 5055              	.LBB122:
2899:../uvc.c      ****     switch (wValue)
 5056              		.loc 1 2899 0
 5057 2d74 070C53E3 		cmp	r3, #1792
 5058 2d78 B500000A 		beq	.L369
 5059 2d7c 020B53E3 		cmp	r3, #2048
 5060 2d80 19FEFF1A 		bne	.L324
 5061              	.LVL374:
2931:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5062              		.loc 1 2931 0
 5063 2d84 1700A0E3 		mov	r0, #23
 5064 2d88 FEFFFFEB 		bl	ControlHandle
 5065              	.LVL375:
 5066 2d8c 28309DE5 		ldr	r3, [sp, #40]
 5067 2d90 1AFEFFEA 		b	.L323
 5068              	.L377:
 5069              	.LVL376:
2966:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5070              		.loc 1 2966 0
 5071 2d94 2000A0E3 		mov	r0, #32
 5072 2d98 FEFFFFEB 		bl	ControlHandle
 5073              	.LVL377:
 5074 2d9c 28309DE5 		ldr	r3, [sp, #40]
 5075 2da0 16FEFFEA 		b	.L323
 5076              	.LVL378:
 5077              	.L487:
 5078              	.LBE122:
 5079              	.LBE149:
 5080              	.LBB150:
 5081              	.LBB109:
3014:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5082              		.loc 1 3014 0
 5083 2da4 7C139FE5 		ldr	r1, .L488+88
 5084 2da8 1A00A0E3 		mov	r0, #26
 5085 2dac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3015:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5086              		.loc 1 3015 0
 5087 2db0 0400A0E3 		mov	r0, #4
 5088 2db4 70139FE5 		ldr	r1, .L488+92
 5089 2db8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5090 2dbc FEFFFFEB 		bl	CyU3PDebugPrint
 5091 2dc0 28309DE5 		ldr	r3, [sp, #40]
 5092 2dc4 17FEFFEA 		b	.L385
 5093              	.LVL379:
 5094              	.L374:
 5095              	.LBE109:
 5096              	.LBE150:
 5097              	.LBB151:
 5098              	.LBB128:
2950:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5099              		.loc 1 2950 0
 5100 2dc8 1C00A0E3 		mov	r0, #28
 5101 2dcc FEFFFFEB 		bl	ControlHandle
 5102              	.LVL380:
 5103 2dd0 28309DE5 		ldr	r3, [sp, #40]
 5104 2dd4 09FEFFEA 		b	.L323
 5105              	.L373:
 5106              	.LVL381:
2946:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5107              		.loc 1 2946 0
 5108 2dd8 1A00A0E3 		mov	r0, #26
 5109 2ddc FEFFFFEB 		bl	ControlHandle
 5110              	.LVL382:
 5111 2de0 28309DE5 		ldr	r3, [sp, #40]
 5112 2de4 05FEFFEA 		b	.L323
 5113              	.L375:
 5114              	.LVL383:
2958:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5115              		.loc 1 2958 0
 5116 2de8 1E00A0E3 		mov	r0, #30
 5117 2dec FEFFFFEB 		bl	ControlHandle
 5118              	.LVL384:
 5119 2df0 28309DE5 		ldr	r3, [sp, #40]
 5120 2df4 01FEFFEA 		b	.L323
 5121              	.L351:
 5122              	.LVL385:
 5123              	.LBE128:
 5124              	.LBE151:
 5125              	.LBB152:
 5126              	.LBB99:
2704:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5127              		.loc 1 2704 0
 5128 2df8 0600A0E3 		mov	r0, #6
 5129 2dfc FEFFFFEB 		bl	CTControlHandle
 5130              	.LVL386:
 5131 2e00 28309DE5 		ldr	r3, [sp, #40]
 5132 2e04 FDFDFFEA 		b	.L323
 5133              	.L352:
 5134              	.LVL387:
2710:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5135              		.loc 1 2710 0
 5136 2e08 0700A0E3 		mov	r0, #7
 5137 2e0c FEFFFFEB 		bl	CTControlHandle
 5138              	.LVL388:
 5139 2e10 28309DE5 		ldr	r3, [sp, #40]
 5140 2e14 F9FDFFEA 		b	.L323
 5141              	.L336:
 5142              	.LVL389:
 5143              	.LBE99:
 5144              	.LBE152:
 5145              	.LBB153:
 5146              	.LBB95:
2626:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5147              		.loc 1 2626 0
 5148 2e18 0600A0E3 		mov	r0, #6
 5149 2e1c FEFFFFEB 		bl	ControlHandle
 5150              	.LVL390:
 5151 2e20 28309DE5 		ldr	r3, [sp, #40]
 5152 2e24 F5FDFFEA 		b	.L323
 5153              	.L338:
 5154              	.LVL391:
2636:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5155              		.loc 1 2636 0
 5156 2e28 0900A0E3 		mov	r0, #9
 5157 2e2c FEFFFFEB 		bl	ControlHandle
 5158              	.LVL392:
 5159 2e30 28309DE5 		ldr	r3, [sp, #40]
 5160 2e34 F1FDFFEA 		b	.L323
 5161              	.LVL393:
 5162              	.L450:
 5163              	.LBE95:
 5164              	.LBE153:
 5165              	.LBB154:
 5166              	.LBB116:
3310:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5167              		.loc 1 3310 0
 5168 2e38 F0129FE5 		ldr	r1, .L488+96
 5169 2e3c BE22DDE1 		ldrh	r2, [sp, #46]
 5170 2e40 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5171 2e44 0400A0E3 		mov	r0, #4
 5172              	.LVL394:
 5173 2e48 FEFFFFEB 		bl	CyU3PDebugPrint
 5174 2e4c F0FDFFEA 		b	.L387
 5175              	.LVL395:
 5176              	.L483:
3084:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5177              		.loc 1 3084 0
 5178 2e50 2000A0E3 		mov	r0, #32
 5179 2e54 A0129FE5 		ldr	r1, .L488+44
 5180 2e58 2E208DE2 		add	r2, sp, #46
 5181 2e5c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5182              	.LVL396:
3086:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5183              		.loc 1 3086 0
 5184 2e60 000050E3 		cmp	r0, #0
 5185 2e64 EEFDFF1A 		bne	.L467
3088:../uvc.c      ****                         switch (glCommitCtrl[3])
 5186              		.loc 1 3088 0
 5187 2e68 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5188              	.LVL397:
 5189 2e6c 020050E3 		cmp	r0, #2
 5190 2e70 2600000A 		beq	.L413
 5191 2e74 030050E3 		cmp	r0, #3
 5192 2e78 1700000A 		beq	.L414
 5193 2e7c 010050E3 		cmp	r0, #1
 5194 2e80 0800001A 		bne	.L411
3091:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5195              		.loc 1 3091 0
 5196 2e84 582095E5 		ldr	r2, [r5, #88]
 5197 2e88 3010A0E3 		mov	r1, #48
 5198 2e8c 000052E3 		cmp	r2, #0
 5199 2e90 E420A003 		moveq	r2, #228
 5200 2e94 6420A013 		movne	r2, #100
 5201 2e98 5230A0E3 		mov	r3, #82
 5202 2e9c FEFFFFEB 		bl	SensorSetIrisControl
3092:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5203              		.loc 1 3092 0
 5204 2ea0 7D0FA0E3 		mov	r0, #500
 5205 2ea4 FEFFFFEB 		bl	_tx_thread_sleep
 5206              	.L411:
3108:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5207              		.loc 1 3108 0
 5208 2ea8 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3120:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5209              		.loc 1 3120 0
 5210 2eac 0020A0E3 		mov	r2, #0
 5211 2eb0 18029FE5 		ldr	r0, .L488
 5212 2eb4 0110A0E3 		mov	r1, #1
3108:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5213              		.loc 1 3108 0
 5214 2eb8 7DC0C4E5 		strb	ip, [r4, #125]
3120:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5215              		.loc 1 3120 0
 5216 2ebc FEFFFFEB 		bl	_txe_event_flags_set
 5217              	.LVL398:
3121:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5218              		.loc 1 3121 0
 5219 2ec0 002050E2 		subs	r2, r0, #0
 5220 2ec4 D6FDFF0A 		beq	.L467
3123:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5221              		.loc 1 3123 0
 5222 2ec8 0400A0E3 		mov	r0, #4
 5223              	.LVL399:
 5224 2ecc 2C129FE5 		ldr	r1, .L488+48
 5225 2ed0 FEFFFFEB 		bl	CyU3PDebugPrint
 5226              	.LVL400:
 5227 2ed4 28309DE5 		ldr	r3, [sp, #40]
 5228 2ed8 D2FDFFEA 		b	.L385
 5229              	.L414:
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5230              		.loc 1 3101 0
 5231 2edc 582095E5 		ldr	r2, [r5, #88]
 5232 2ee0 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5233 2ee4 000052E3 		cmp	r2, #0
 5234 2ee8 C420A003 		moveq	r2, #196
 5235 2eec 4420A013 		movne	r2, #68
 5236 2ef0 032082E1 		orr	r2, r2, r3
 5237 2ef4 3010A0E3 		mov	r1, #48
 5238 2ef8 5230A0E3 		mov	r3, #82
 5239 2efc 0100A0E3 		mov	r0, #1
 5240 2f00 FEFFFFEB 		bl	SensorSetIrisControl
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5241              		.loc 1 3102 0
 5242 2f04 7D0FA0E3 		mov	r0, #500
 5243 2f08 FEFFFFEB 		bl	_tx_thread_sleep
 5244 2f0c E5FFFFEA 		b	.L411
 5245              	.L413:
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5246              		.loc 1 3096 0
 5247 2f10 582095E5 		ldr	r2, [r5, #88]
 5248 2f14 3010A0E3 		mov	r1, #48
 5249 2f18 000052E3 		cmp	r2, #0
 5250 2f1c D420A003 		moveq	r2, #212
 5251 2f20 5420A013 		movne	r2, #84
 5252 2f24 5230A0E3 		mov	r3, #82
 5253 2f28 0100A0E3 		mov	r0, #1
 5254 2f2c FEFFFFEB 		bl	SensorSetIrisControl
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5255              		.loc 1 3097 0
 5256 2f30 7D0FA0E3 		mov	r0, #500
 5257 2f34 FEFFFFEB 		bl	_tx_thread_sleep
 5258 2f38 DAFFFFEA 		b	.L411
 5259              	.LVL401:
 5260              	.L445:
3279:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5261              		.loc 1 3279 0
 5262 2f3c 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5263 2f40 030051E3 		cmp	r1, #3
 5264 2f44 D2FEFF1A 		bne	.L449
3281:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5265              		.loc 1 3281 0
 5266 2f48 1A00A0E3 		mov	r0, #26
 5267 2f4c E0119FE5 		ldr	r1, .L488+100
 5268 2f50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5269 2f54 28309DE5 		ldr	r3, [sp, #40]
 5270 2f58 B2FDFFEA 		b	.L385
 5271              	.LVL402:
 5272              	.L365:
 5273              	.LBE116:
 5274              	.LBE154:
 5275              	.LBB155:
 5276              	.LBB121:
2911:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5277              		.loc 1 2911 0
 5278 2f5c 1200A0E3 		mov	r0, #18
 5279 2f60 FEFFFFEB 		bl	ControlHandle
 5280              	.LVL403:
 5281 2f64 28309DE5 		ldr	r3, [sp, #40]
 5282 2f68 A4FDFFEA 		b	.L323
 5283              	.L364:
 5284              	.LVL404:
2907:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5285              		.loc 1 2907 0
 5286 2f6c 1100A0E3 		mov	r0, #17
 5287 2f70 FEFFFFEB 		bl	ControlHandle
 5288              	.LVL405:
 5289 2f74 28309DE5 		ldr	r3, [sp, #40]
 5290 2f78 A0FDFFEA 		b	.L323
 5291              	.L366:
 5292              	.LVL406:
2915:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5293              		.loc 1 2915 0
 5294 2f7c 1300A0E3 		mov	r0, #19
 5295 2f80 FEFFFFEB 		bl	ControlHandle
 5296              	.LVL407:
 5297 2f84 28309DE5 		ldr	r3, [sp, #40]
 5298 2f88 9CFDFFEA 		b	.L323
 5299              	.L371:
 5300              	.LVL408:
2935:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5301              		.loc 1 2935 0
 5302 2f8c 1800A0E3 		mov	r0, #24
 5303 2f90 FEFFFFEB 		bl	ControlHandle
 5304              	.LVL409:
 5305 2f94 28309DE5 		ldr	r3, [sp, #40]
 5306 2f98 98FDFFEA 		b	.L323
 5307              	.L345:
 5308              	.LVL410:
 5309              	.LBE121:
 5310              	.LBE155:
 5311              	.LBB156:
 5312              	.LBB105:
2678:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5313              		.loc 1 2678 0
 5314 2f9c 0000A0E3 		mov	r0, #0
 5315 2fa0 FEFFFFEB 		bl	CTControlHandle
 5316              	.LVL411:
 5317 2fa4 28309DE5 		ldr	r3, [sp, #40]
 5318 2fa8 94FDFFEA 		b	.L323
 5319              	.L347:
 5320              	.LVL412:
2686:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5321              		.loc 1 2686 0
 5322 2fac 0200A0E3 		mov	r0, #2
 5323 2fb0 FEFFFFEB 		bl	CTControlHandle
 5324              	.LVL413:
 5325 2fb4 28309DE5 		ldr	r3, [sp, #40]
 5326 2fb8 90FDFFEA 		b	.L323
 5327              	.L350:
 5328              	.LVL414:
2700:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 5329              		.loc 1 2700 0
 5330 2fbc 0500A0E3 		mov	r0, #5
 5331 2fc0 FEFFFFEB 		bl	CTControlHandle
 5332              	.LVL415:
 5333 2fc4 28309DE5 		ldr	r3, [sp, #40]
 5334 2fc8 8CFDFFEA 		b	.L323
 5335              	.L479:
 5336              	.LVL416:
 5337              	.LBE105:
 5338              	.LBE156:
 5339              	.LBB157:
 5340              	.LBB91:
2607:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5341              		.loc 1 2607 0
 5342 2fcc 0100A0E3 		mov	r0, #1
 5343 2fd0 FEFFFFEB 		bl	ControlHandle
 5344              	.LVL417:
 5345 2fd4 28309DE5 		ldr	r3, [sp, #40]
 5346 2fd8 88FDFFEA 		b	.L323
 5347              	.L331:
 5348              	.LVL418:
2603:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 5349              		.loc 1 2603 0
 5350 2fdc 0000A0E3 		mov	r0, #0
 5351 2fe0 FEFFFFEB 		bl	ControlHandle
 5352              	.LVL419:
 5353 2fe4 28309DE5 		ldr	r3, [sp, #40]
 5354 2fe8 84FDFFEA 		b	.L323
 5355              	.L333:
 5356              	.LVL420:
2611:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5357              		.loc 1 2611 0
 5358 2fec 0200A0E3 		mov	r0, #2
 5359 2ff0 FEFFFFEB 		bl	ControlHandle
 5360              	.LVL421:
 5361 2ff4 28309DE5 		ldr	r3, [sp, #40]
 5362 2ff8 80FDFFEA 		b	.L323
 5363              	.L335:
 5364              	.LVL422:
2622:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5365              		.loc 1 2622 0
 5366 2ffc 0500A0E3 		mov	r0, #5
 5367 3000 FEFFFFEB 		bl	ControlHandle
 5368              	.LVL423:
 5369 3004 28309DE5 		ldr	r3, [sp, #40]
 5370 3008 7CFDFFEA 		b	.L323
 5371              	.L439:
 5372              	.LBE91:
 5373              	.LBE157:
 5374              	.LBB158:
 5375              	.LBB108:
3235:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 5376              		.loc 1 3235 0
 5377 300c 582094E5 		ldr	r2, [r4, #88]
 5378 3010 3010A0E3 		mov	r1, #48
 5379 3014 000052E3 		cmp	r2, #0
 5380 3018 E420A003 		moveq	r2, #228
 5381 301c 6420A013 		movne	r2, #100
 5382 3020 5230A0E3 		mov	r3, #82
 5383 3024 0100A0E3 		mov	r0, #1
 5384 3028 FEFFFFEB 		bl	SensorSetIrisControl
 5385 302c 79FEFFEA 		b	.L436
 5386              	.L438:
3240:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 5387              		.loc 1 3240 0
 5388 3030 582094E5 		ldr	r2, [r4, #88]
 5389 3034 3010A0E3 		mov	r1, #48
 5390 3038 000052E3 		cmp	r2, #0
 5391 303c D420A003 		moveq	r2, #212
 5392 3040 5420A013 		movne	r2, #84
 5393 3044 5230A0E3 		mov	r3, #82
 5394 3048 0100A0E3 		mov	r0, #1
 5395 304c FEFFFFEB 		bl	SensorSetIrisControl
 5396 3050 70FEFFEA 		b	.L436
 5397              	.L369:
 5398              	.LVL424:
 5399              	.LBE108:
 5400              	.LBE158:
 5401              	.LBB159:
 5402              	.LBB129:
2927:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5403              		.loc 1 2927 0
 5404 3054 1600A0E3 		mov	r0, #22
 5405 3058 FEFFFFEB 		bl	ControlHandle
 5406              	.LVL425:
 5407 305c 28309DE5 		ldr	r3, [sp, #40]
 5408 3060 66FDFFEA 		b	.L323
 5409              	.L355:
 5410              	.LVL426:
 5411              	.LBE129:
 5412              	.LBE159:
 5413              	.LBB160:
 5414              	.LBB98:
2723:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5415              		.loc 1 2723 0
 5416 3064 0A00A0E3 		mov	r0, #10
 5417 3068 FEFFFFEB 		bl	CTControlHandle
 5418              	.LVL427:
 5419 306c 28309DE5 		ldr	r3, [sp, #40]
 5420 3070 62FDFFEA 		b	.L323
 5421              	.L354:
 5422              	.LVL428:
2719:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5423              		.loc 1 2719 0
 5424 3074 0900A0E3 		mov	r0, #9
 5425 3078 FEFFFFEB 		bl	CTControlHandle
 5426              	.LVL429:
 5427 307c 28309DE5 		ldr	r3, [sp, #40]
 5428 3080 5EFDFFEA 		b	.L323
 5429              	.L368:
 5430              	.LVL430:
 5431              	.LBE98:
 5432              	.LBE160:
 5433              	.LBB161:
 5434              	.LBB120:
2923:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5435              		.loc 1 2923 0
 5436 3084 1500A0E3 		mov	r0, #21
 5437 3088 FEFFFFEB 		bl	ControlHandle
 5438              	.LVL431:
 5439 308c 28309DE5 		ldr	r3, [sp, #40]
 5440 3090 5AFDFFEA 		b	.L323
 5441              	.L340:
 5442              	.LVL432:
 5443              	.LBE120:
 5444              	.LBE161:
 5445              	.LBB162:
 5446              	.LBB96:
2644:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5447              		.loc 1 2644 0
 5448 3094 0E00A0E3 		mov	r0, #14
 5449 3098 FEFFFFEB 		bl	ControlHandle
 5450              	.LVL433:
 5451 309c 28309DE5 		ldr	r3, [sp, #40]
 5452 30a0 56FDFFEA 		b	.L323
 5453              	.L348:
 5454              	.LVL434:
 5455              	.LBE96:
 5456              	.LBE162:
 5457              	.LBB163:
 5458              	.LBB106:
2691:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 5459              		.loc 1 2691 0
 5460 30a4 0300A0E3 		mov	r0, #3
 5461 30a8 FEFFFFEB 		bl	CTControlHandle
 5462              	.LVL435:
 5463 30ac 28309DE5 		ldr	r3, [sp, #40]
 5464 30b0 52FDFFEA 		b	.L323
 5465              	.LVL436:
 5466              	.L446:
 5467              	.LBE106:
 5468              	.LBE163:
 5469              	.LBB164:
 5470              	.LBB117:
3276:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5471              		.loc 1 3276 0
 5472 30b4 0200A0E3 		mov	r0, #2
 5473 30b8 58109FE5 		ldr	r1, .L488+72
 5474 30bc A4FEFFEA 		b	.L468
 5475              	.LVL437:
 5476              	.L378:
 5477              	.LBE117:
 5478              	.LBE164:
 5479              	.LBB165:
 5480              	.LBB130:
2970:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5481              		.loc 1 2970 0
 5482 30c0 2100A0E3 		mov	r0, #33
 5483 30c4 FEFFFFEB 		bl	ControlHandle
 5484              	.LVL438:
 5485 30c8 28309DE5 		ldr	r3, [sp, #40]
 5486 30cc 4BFDFFEA 		b	.L323
 5487              	.L489:
 5488              		.align	2
 5489              	.L488:
 5490 30d0 00000000 		.word	.LANCHOR0
 5491 30d4 00000000 		.word	.LANCHOR1
 5492 30d8 00000000 		.word	bRequest
 5493 30dc 00000000 		.word	wValue
 5494 30e0 00000000 		.word	wIndex
 5495 30e4 00000000 		.word	glInterStaBuffer
 5496 30e8 10050000 		.word	.LC27
 5497 30ec 00000000 		.word	glChHandleInterStat
 5498 30f0 00000000 		.word	bmReqType
 5499 30f4 00000000 		.word	wLength
 5500 30f8 94040000 		.word	.LC26
 5501 30fc 80000000 		.word	.LANCHOR0+128
 5502 3100 64050000 		.word	.LC29
 5503 3104 E0050000 		.word	.LC32
 5504 3108 B8050000 		.word	.LC31
 5505 310c 68060000 		.word	.LANCHOR1+1640
 5506 3110 74060000 		.word	.LANCHOR1+1652
 5507 3114 30060000 		.word	.LANCHOR1+1584
 5508 3118 5C000000 		.word	.LANCHOR0+92
 5509 311c 8C050000 		.word	.LC30
 5510 3120 34060000 		.word	.LC34
 5511 3124 D8010000 		.word	.LC12
 5512 3128 14060000 		.word	.LANCHOR1+1556
 5513 312c 3C050000 		.word	.LC28
 5514 3130 0C060000 		.word	.LC33
 5515 3134 4C060000 		.word	.LANCHOR1+1612
 5516              	.LBE130:
 5517              	.LBE165:
 5518              		.cfi_endproc
 5519              	.LFE24:
 5521              		.align	2
 5522              		.global	CamDefSet
 5524              	CamDefSet:
 5525              	.LFB4:
1208:../uvc.c      **** {
 5526              		.loc 1 1208 0
 5527              		.cfi_startproc
 5528              		@ args = 0, pretend = 0, frame = 24
 5529              		@ frame_needed = 0, uses_anonymous_args = 0
 5530              	.LVL439:
 5531 3138 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5532              	.LCFI19:
 5533              		.cfi_def_cfa_offset 36
1214:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5534              		.loc 1 1214 0
 5535 313c AC429FE5 		ldr	r4, .L493
 5536              		.cfi_offset 14, -4
 5537              		.cfi_offset 11, -8
 5538              		.cfi_offset 10, -12
 5539              		.cfi_offset 9, -16
 5540              		.cfi_offset 8, -20
 5541              		.cfi_offset 7, -24
 5542              		.cfi_offset 6, -28
 5543              		.cfi_offset 5, -32
 5544              		.cfi_offset 4, -36
1219:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5545              		.loc 1 1219 0
 5546 3140 AC229FE5 		ldr	r2, .L493+4
1216:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5547              		.loc 1 1216 0
 5548 3144 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1208:../uvc.c      **** {
 5549              		.loc 1 1208 0
 5550 3148 2CD04DE2 		sub	sp, sp, #44
 5551              	.LCFI20:
 5552              		.cfi_def_cfa_offset 80
1219:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5553              		.loc 1 1219 0
 5554 314c 1C0092E5 		ldr	r0, [r2, #28]
 5555 3150 0010E0E3 		mvn	r1, #0
1221:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5556              		.loc 1 1221 0
 5557 3154 2963A0E1 		mov	r6, r9, lsr #6
1215:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5558              		.loc 1 1215 0
 5559 3158 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1214:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5560              		.loc 1 1214 0
 5561 315c 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5562              	.LVL440:
1219:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5563              		.loc 1 1219 0
 5564 3160 FEFFFFEB 		bl	_txe_mutex_get
1220:../uvc.c      ****     if(Data1&0x80){
 5565              		.loc 1 1220 0
 5566 3164 800019E3 		tst	r9, #128
1221:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5567              		.loc 1 1221 0
 5568 3168 01600612 		andne	r6, r6, #1
 5569 316c 0660E011 		mvnne	r6, r6
 5570 3170 3B600612 		andne	r6, r6, #59
 5571 3174 0660E011 		mvnne	r6, r6
 5572 3178 FF600612 		andne	r6, r6, #255
 5573              	.LVL441:
1223:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5574              		.loc 1 1223 0
 5575 317c C6608603 		orreq	r6, r6, #198
 5576              	.LVL442:
1227:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5577              		.loc 1 1227 0
 5578 3180 0080A0E3 		mov	r8, #0
 5579 3184 0A20A0E1 		mov	r2, sl
 5580 3188 0730A0E1 		mov	r3, r7
 5581 318c 0110A0E3 		mov	r1, #1
1225:../uvc.c      ****     Data0 = (Data0 << 2);
 5582              		.loc 1 1225 0
 5583 3190 0951A0E1 		mov	r5, r9, asl #2
1227:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5584              		.loc 1 1227 0
 5585 3194 58029FE5 		ldr	r0, .L493+4
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5586              		.loc 1 1230 0
 5587 3198 0190A0E3 		mov	r9, #1
 5588              	.LVL443:
1225:../uvc.c      ****     Data0 = (Data0 << 2);
 5589              		.loc 1 1225 0
 5590 319c FF5005E2 		and	r5, r5, #255
 5591              	.LVL444:
1227:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5592              		.loc 1 1227 0
 5593 31a0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5594 31a4 FEFFFFEB 		bl	cmdSet
 5595              	.LVL445:
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5596              		.loc 1 1230 0
 5597 31a8 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5598 31ac 0910A0E1 		mov	r1, r9
 5599 31b0 0730A0E1 		mov	r3, r7
 5600 31b4 38029FE5 		ldr	r0, .L493+4
 5601 31b8 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5602 31bc FEFFFFEB 		bl	cmdSet
 5603              	.LVL446:
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5604              		.loc 1 1233 0
 5605 31c0 0620A0E1 		mov	r2, r6
 5606 31c4 0530A0E1 		mov	r3, r5
 5607 31c8 28129FE5 		ldr	r1, .L493+8
 5608 31cc 0400A0E3 		mov	r0, #4
1232:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5609              		.loc 1 1232 0
 5610 31d0 A661C4E5 		strb	r6, [r4, #422]
1231:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5611              		.loc 1 1231 0
 5612 31d4 A551C4E5 		strb	r5, [r4, #421]
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5613              		.loc 1 1233 0
 5614 31d8 FEFFFFEB 		bl	CyU3PDebugPrint
 5615              	.LVL447:
1238:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5616              		.loc 1 1238 0
 5617 31dc BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5618              	.LVL448:
1239:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5619              		.loc 1 1239 0
 5620 31e0 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5621 31e4 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5622 31e8 0210A0E3 		mov	r1, #2
 5623 31ec 00029FE5 		ldr	r0, .L493+4
 5624 31f0 00B08DE5 		str	fp, [sp, #0]
 5625 31f4 04808DE5 		str	r8, [sp, #4]
 5626 31f8 FEFFFFEB 		bl	cmdSet
 5627              	.LVL449:
1241:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5628              		.loc 1 1241 0
 5629 31fc 0B20A0E1 		mov	r2, fp
 5630 3200 0530A0E1 		mov	r3, r5
 5631 3204 EC119FE5 		ldr	r1, .L493+8
 5632 3208 0400A0E3 		mov	r0, #4
1240:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5633              		.loc 1 1240 0
 5634 320c BD51C4E5 		strb	r5, [r4, #445]
1241:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5635              		.loc 1 1241 0
 5636 3210 FEFFFFEB 		bl	CyU3PDebugPrint
 5637              	.LVL450:
1246:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5638              		.loc 1 1246 0
 5639 3214 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1245:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5640              		.loc 1 1245 0
 5641 3218 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5642              	.LVL451:
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5643              		.loc 1 1247 0
 5644 321c 80B047E2 		sub	fp, r7, #128
 5645 3220 FF100BE2 		and	r1, fp, #255
 5646 3224 14108DE5 		str	r1, [sp, #20]
 5647 3228 14C09DE5 		ldr	ip, [sp, #20]
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5648              		.loc 1 1248 0
 5649 322c 760047E2 		sub	r0, r7, #118
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5650              		.loc 1 1249 0
 5651 3230 7EE087E2 		add	lr, r7, #126
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5652              		.loc 1 1247 0
 5653 3234 0630A0E1 		mov	r3, r6
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5654              		.loc 1 1248 0
 5655 3238 18008DE5 		str	r0, [sp, #24]
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5656              		.loc 1 1247 0
 5657 323c 0510A0E3 		mov	r1, #5
 5658 3240 DF20A0E3 		mov	r2, #223
 5659 3244 A8019FE5 		ldr	r0, .L493+4
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5660              		.loc 1 1249 0
 5661 3248 1CE08DE5 		str	lr, [sp, #28]
1247:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5662              		.loc 1 1247 0
 5663 324c 00C08DE5 		str	ip, [sp, #0]
 5664 3250 04808DE5 		str	r8, [sp, #4]
 5665 3254 FEFFFFEB 		bl	cmdSet
 5666              	.LVL452:
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5667              		.loc 1 1248 0
 5668 3258 18A09DE5 		ldr	sl, [sp, #24]
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5669              		.loc 1 1250 0
 5670 325c 72E087E2 		add	lr, r7, #114
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5671              		.loc 1 1248 0
 5672 3260 FFC00AE2 		and	ip, sl, #255
 5673 3264 0630A0E1 		mov	r3, r6
 5674 3268 0510A0E3 		mov	r1, #5
 5675 326c DC20A0E3 		mov	r2, #220
 5676 3270 7C019FE5 		ldr	r0, .L493+4
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5677              		.loc 1 1250 0
 5678 3274 20E08DE5 		str	lr, [sp, #32]
1248:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5679              		.loc 1 1248 0
 5680 3278 00C08DE5 		str	ip, [sp, #0]
 5681 327c 04908DE5 		str	r9, [sp, #4]
 5682 3280 FEFFFFEB 		bl	cmdSet
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5683              		.loc 1 1249 0
 5684 3284 1C009DE5 		ldr	r0, [sp, #28]
 5685 3288 02E0A0E3 		mov	lr, #2
 5686 328c FFC000E2 		and	ip, r0, #255
 5687 3290 0630A0E1 		mov	r3, r6
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5688              		.loc 1 1251 0
 5689 3294 6FA047E2 		sub	sl, r7, #111
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5690              		.loc 1 1249 0
 5691 3298 0510A0E3 		mov	r1, #5
 5692 329c DE20A0E3 		mov	r2, #222
 5693 32a0 4C019FE5 		ldr	r0, .L493+4
 5694 32a4 04E08DE5 		str	lr, [sp, #4]
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5695              		.loc 1 1251 0
 5696 32a8 24A08DE5 		str	sl, [sp, #36]
1249:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5697              		.loc 1 1249 0
 5698 32ac 00C08DE5 		str	ip, [sp, #0]
 5699 32b0 FEFFFFEB 		bl	cmdSet
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5700              		.loc 1 1250 0
 5701 32b4 20A09DE5 		ldr	sl, [sp, #32]
 5702 32b8 0630A0E1 		mov	r3, r6
 5703 32bc FFC00AE2 		and	ip, sl, #255
 5704 32c0 00C08DE5 		str	ip, [sp, #0]
 5705 32c4 0510A0E3 		mov	r1, #5
 5706 32c8 03C0A0E3 		mov	ip, #3
 5707 32cc E020A0E3 		mov	r2, #224
 5708 32d0 1C019FE5 		ldr	r0, .L493+4
 5709 32d4 04C08DE5 		str	ip, [sp, #4]
 5710 32d8 FEFFFFEB 		bl	cmdSet
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5711              		.loc 1 1251 0
 5712 32dc 24009DE5 		ldr	r0, [sp, #36]
 5713 32e0 04A0A0E3 		mov	sl, #4
 5714 32e4 FFC000E2 		and	ip, r0, #255
 5715 32e8 0630A0E1 		mov	r3, r6
 5716 32ec 0510A0E3 		mov	r1, #5
 5717 32f0 DD20A0E3 		mov	r2, #221
 5718 32f4 F8009FE5 		ldr	r0, .L493+4
 5719 32f8 00C08DE5 		str	ip, [sp, #0]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5720              		.loc 1 1252 0
 5721 32fc 7F7087E2 		add	r7, r7, #127
 5722              	.LVL453:
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5723              		.loc 1 1251 0
 5724 3300 04A08DE5 		str	sl, [sp, #4]
 5725 3304 FEFFFFEB 		bl	cmdSet
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5726              		.loc 1 1252 0
 5727 3308 05E0A0E3 		mov	lr, #5
 5728 330c 0E10A0E1 		mov	r1, lr
 5729 3310 0630A0E1 		mov	r3, r6
 5730 3314 E120A0E3 		mov	r2, #225
 5731 3318 FF6007E2 		and	r6, r7, #255
 5732              	.LVL454:
 5733 331c D0009FE5 		ldr	r0, .L493+4
 5734 3320 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5735 3324 FEFFFFEB 		bl	cmdSet
 5736              	.LVL455:
1253:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5737              		.loc 1 1253 0
 5738 3328 14C09DE5 		ldr	ip, [sp, #20]
1254:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5739              		.loc 1 1254 0
 5740 332c 24E09DE5 		ldr	lr, [sp, #36]
 5741 3330 1C609DE5 		ldr	r6, [sp, #28]
1253:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5742              		.loc 1 1253 0
 5743 3334 05C2C4E5 		strb	ip, [r4, #517]
1254:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5744              		.loc 1 1254 0
 5745 3338 20C09DE5 		ldr	ip, [sp, #32]
 5746 333c 0B20A0E1 		mov	r2, fp
 5747 3340 18309DE5 		ldr	r3, [sp, #24]
 5748 3344 B0109FE5 		ldr	r1, .L493+12
 5749 3348 0A00A0E1 		mov	r0, sl
 5750 334c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5751 3350 0C708DE5 		str	r7, [sp, #12]
 5752 3354 FEFFFFEB 		bl	CyU3PDebugPrint
 5753              	.LVL456:
1258:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5754              		.loc 1 1258 0
 5755 3358 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5756              	.LVL457:
1259:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5757              		.loc 1 1259 0
 5758 335c 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5759              	.LVL458:
1260:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5760              		.loc 1 1260 0
 5761 3360 0730A0E1 		mov	r3, r7
 5762 3364 0610A0E3 		mov	r1, #6
 5763 3368 8520A0E3 		mov	r2, #133
 5764 336c 80009FE5 		ldr	r0, .L493+4
 5765 3370 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5766 3374 FEFFFFEB 		bl	cmdSet
1261:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5767              		.loc 1 1261 0
 5768 3378 0730A0E1 		mov	r3, r7
 5769 337c 0610A0E3 		mov	r1, #6
 5770 3380 8620A0E3 		mov	r2, #134
 5771 3384 68009FE5 		ldr	r0, .L493+4
 5772 3388 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5773 338c FEFFFFEB 		bl	cmdSet
1263:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5774              		.loc 1 1263 0
 5775 3390 0620A0E1 		mov	r2, r6
 5776 3394 0530A0E1 		mov	r3, r5
 5777 3398 58109FE5 		ldr	r1, .L493+8
 5778 339c 0A00A0E1 		mov	r0, sl
1262:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5779              		.loc 1 1262 0
 5780 33a0 1D62C4E5 		strb	r6, [r4, #541]
1263:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5781              		.loc 1 1263 0
 5782 33a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5783              	.LVL459:
1268:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5784              		.loc 1 1268 0
 5785 33a8 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5786              	.LVL460:
1269:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5787              		.loc 1 1269 0
 5788 33ac 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5789 33b0 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5790 33b4 0710A0E3 		mov	r1, #7
 5791 33b8 34009FE5 		ldr	r0, .L493+4
 5792 33bc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5793 33c0 FEFFFFEB 		bl	cmdSet
 5794              	.LVL461:
1271:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5795              		.loc 1 1271 0
 5796 33c4 0530A0E1 		mov	r3, r5
 5797 33c8 0A00A0E1 		mov	r0, sl
 5798 33cc 24109FE5 		ldr	r1, .L493+8
 5799 33d0 0620A0E1 		mov	r2, r6
1270:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5800              		.loc 1 1270 0
 5801 33d4 3552C4E5 		strb	r5, [r4, #565]
1271:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5802              		.loc 1 1271 0
 5803 33d8 FEFFFFEB 		bl	CyU3PDebugPrint
1273:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5804              		.loc 1 1273 0
 5805 33dc 10309FE5 		ldr	r3, .L493+4
 5806 33e0 1C0093E5 		ldr	r0, [r3, #28]
1276:../uvc.c      **** }
 5807              		.loc 1 1276 0
 5808 33e4 2CD08DE2 		add	sp, sp, #44
 5809 33e8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1273:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5810              		.loc 1 1273 0
 5811 33ec FEFFFFEA 		b	_txe_mutex_put
 5812              	.L494:
 5813              		.align	2
 5814              	.L493:
 5815 33f0 00000000 		.word	.LANCHOR1
 5816 33f4 00000000 		.word	cmdQu
 5817 33f8 68060000 		.word	.LC35
 5818 33fc 88060000 		.word	.LC36
 5819              		.cfi_endproc
 5820              	.LFE4:
 5822              		.align	2
 5823              		.global	CyFxUVCAddHeader
 5825              	CyFxUVCAddHeader:
 5826              	.LFB5:
1284:../uvc.c      **** {
 5827              		.loc 1 1284 0
 5828              		.cfi_startproc
 5829              		@ args = 0, pretend = 0, frame = 0
 5830              		@ frame_needed = 0, uses_anonymous_args = 0
 5831              	.LVL462:
 5832 3400 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5833              	.LCFI21:
 5834              		.cfi_def_cfa_offset 16
1284:../uvc.c      **** {
 5835              		.loc 1 1284 0
 5836 3404 0040A0E1 		mov	r4, r0
 5837              		.cfi_offset 14, -4
 5838              		.cfi_offset 5, -8
 5839              		.cfi_offset 4, -12
 5840              		.cfi_offset 3, -16
 5841 3408 0150A0E1 		mov	r5, r1
1286:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 5842              		.loc 1 1286 0
 5843 340c 30009FE5 		ldr	r0, .L497
 5844              	.LVL463:
 5845 3410 0010E0E3 		mvn	r1, #0
 5846              	.LVL464:
 5847 3414 FEFFFFEB 		bl	_txe_mutex_get
1287:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5848              		.loc 1 1287 0
 5849 3418 0400A0E1 		mov	r0, r4
 5850 341c 24109FE5 		ldr	r1, .L497+4
 5851 3420 0C20A0E3 		mov	r2, #12
 5852 3424 FEFFFFEB 		bl	CyU3PMemCopy
1288:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5853              		.loc 1 1288 0
 5854 3428 14009FE5 		ldr	r0, .L497
 5855 342c FEFFFFEB 		bl	_txe_mutex_put
1291:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5856              		.loc 1 1291 0
 5857 3430 020015E3 		tst	r5, #2
1293:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5858              		.loc 1 1293 0
 5859 3434 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5860 3438 02308313 		orrne	r3, r3, #2
 5861 343c 0130C415 		strneb	r3, [r4, #1]
 5862 3440 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5863              	.L498:
 5864              		.align	2
 5865              	.L497:
 5866 3444 00000000 		.word	imgHdMux
 5867 3448 80040000 		.word	.LANCHOR1+1152
 5868              		.cfi_endproc
 5869              	.LFE5:
 5871              		.align	2
 5872              		.global	CyFxAppErrorHandler
 5874              	CyFxAppErrorHandler:
 5875              	.LFB6:
1303:../uvc.c      **** {
 5876              		.loc 1 1303 0
 5877              		.cfi_startproc
 5878              		@ args = 0, pretend = 0, frame = 0
 5879              		@ frame_needed = 0, uses_anonymous_args = 0
 5880              	.LVL465:
 5881 344c 08402DE9 		stmfd	sp!, {r3, lr}
 5882              	.LCFI22:
 5883              		.cfi_def_cfa_offset 8
 5884              	.LVL466:
 5885              	.L500:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5886              		.loc 1 1313 0 discriminator 1
 5887 3450 10109FE5 		ldr	r1, .L501
 5888 3454 0400A0E3 		mov	r0, #4
 5889              		.cfi_offset 14, -4
 5890              		.cfi_offset 3, -8
 5891 3458 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 5892              		.loc 1 1314 0 discriminator 1
 5893 345c FA0FA0E3 		mov	r0, #1000
 5894 3460 FEFFFFEB 		bl	_tx_thread_sleep
 5895 3464 F9FFFFEA 		b	.L500
 5896              	.L502:
 5897              		.align	2
 5898              	.L501:
 5899 3468 D8010000 		.word	.LC12
 5900              		.cfi_endproc
 5901              	.LFE6:
 5903              		.align	2
 5904              		.global	UVCAppThread_Entry
 5906              	UVCAppThread_Entry:
 5907              	.LFB18:
2290:../uvc.c      **** {
 5908              		.loc 1 2290 0
 5909              		.cfi_startproc
 5910              		@ args = 0, pretend = 0, frame = 176
 5911              		@ frame_needed = 0, uses_anonymous_args = 0
 5912              	.LVL467:
 5913 346c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5914              	.LCFI23:
 5915              		.cfi_def_cfa_offset 28
 5916 3470 BCD04DE2 		sub	sp, sp, #188
 5917              	.LCFI24:
 5918              		.cfi_def_cfa_offset 216
 5919              	.LBB218:
 5920              	.LBB219:
1746:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5921              		.loc 1 1746 0
 5922              		.cfi_offset 14, -4
 5923              		.cfi_offset 10, -8
 5924              		.cfi_offset 8, -12
 5925              		.cfi_offset 7, -16
 5926              		.cfi_offset 6, -20
 5927              		.cfi_offset 5, -24
 5928              		.cfi_offset 4, -28
 5929 3474 FEFFFFEB 		bl	CyU3PUartInit
 5930              	.LVL468:
1747:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5931              		.loc 1 1747 0
 5932 3478 004050E2 		subs	r4, r0, #0
 5933 347c 0400000A 		beq	.L504
1749:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5934              		.loc 1 1749 0
 5935 3480 0400A0E3 		mov	r0, #4
 5936              	.LVL469:
 5937 3484 301B9FE5 		ldr	r1, .L608
 5938 3488 FEFFFFEB 		bl	CyU3PDebugPrint
1750:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5939              		.loc 1 1750 0
 5940 348c 0400A0E1 		mov	r0, r4
 5941 3490 FEFFFFEB 		bl	CyFxAppErrorHandler
 5942              	.L504:
1754:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5943              		.loc 1 1754 0
 5944 3494 24CB9FE5 		ldr	ip, .L608+4
1756:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5945              		.loc 1 1756 0
 5946 3498 0030A0E3 		mov	r3, #0
1755:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5947              		.loc 1 1755 0
 5948 349c 0120A0E3 		mov	r2, #1
1763:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5949              		.loc 1 1763 0
 5950 34a0 50008DE2 		add	r0, sp, #80
 5951 34a4 0310A0E1 		mov	r1, r3
1754:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5952              		.loc 1 1754 0
 5953 34a8 60C08DE5 		str	ip, [sp, #96]
1755:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5954              		.loc 1 1755 0
 5955 34ac 6420CDE5 		strb	r2, [sp, #100]
1756:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5956              		.loc 1 1756 0
 5957 34b0 6530CDE5 		strb	r3, [sp, #101]
1757:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5958              		.loc 1 1757 0
 5959 34b4 50208DE5 		str	r2, [sp, #80]
1758:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5960              		.loc 1 1758 0
 5961 34b8 54308DE5 		str	r3, [sp, #84]
1759:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5962              		.loc 1 1759 0
 5963 34bc 58308DE5 		str	r3, [sp, #88]
1760:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5964              		.loc 1 1760 0
 5965 34c0 5C208DE5 		str	r2, [sp, #92]
1763:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5966              		.loc 1 1763 0
 5967 34c4 FEFFFFEB 		bl	CyU3PUartSetConfig
 5968              	.LVL470:
1764:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5969              		.loc 1 1764 0
 5970 34c8 000050E3 		cmp	r0, #0
 5971 34cc 0000000A 		beq	.L505
1766:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5972              		.loc 1 1766 0
 5973 34d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5974              	.LVL471:
 5975              	.L505:
1770:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5976              		.loc 1 1770 0
 5977 34d4 0000E0E3 		mvn	r0, #0
 5978 34d8 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5979              	.LVL472:
1771:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5980              		.loc 1 1771 0
 5981 34dc 000050E3 		cmp	r0, #0
 5982 34e0 0000000A 		beq	.L506
1773:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5983              		.loc 1 1773 0
 5984 34e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5985              	.LVL473:
 5986              	.L506:
1777:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5987              		.loc 1 1777 0
 5988 34e8 0300A0E3 		mov	r0, #3
 5989 34ec 0410A0E3 		mov	r1, #4
 5990 34f0 FEFFFFEB 		bl	CyU3PDebugInit
 5991              	.LVL474:
1778:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5992              		.loc 1 1778 0
 5993 34f4 000050E3 		cmp	r0, #0
 5994 34f8 0000000A 		beq	.L507
1780:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5995              		.loc 1 1780 0
 5996 34fc FEFFFFEB 		bl	CyFxAppErrorHandler
 5997              	.LVL475:
 5998              	.L507:
1784:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5999              		.loc 1 1784 0
 6000 3500 0000A0E3 		mov	r0, #0
 6001 3504 FEFFFFEB 		bl	CyU3PDebugPreamble
 6002              	.LVL476:
 6003              	.LBE219:
 6004              	.LBE218:
2306:../uvc.c      **** 		CyU3PThreadSleep(500);
 6005              		.loc 1 2306 0
 6006 3508 7D0FA0E3 		mov	r0, #500
 6007 350c FEFFFFEB 		bl	_tx_thread_sleep
 6008              	.LVL477:
 6009 3510 7D0FA0E3 		mov	r0, #500
 6010 3514 FEFFFFEB 		bl	_tx_thread_sleep
 6011 3518 7D0FA0E3 		mov	r0, #500
 6012 351c FEFFFFEB 		bl	_tx_thread_sleep
 6013 3520 7D0FA0E3 		mov	r0, #500
 6014 3524 FEFFFFEB 		bl	_tx_thread_sleep
 6015 3528 7D0FA0E3 		mov	r0, #500
 6016 352c FEFFFFEB 		bl	_tx_thread_sleep
 6017 3530 7D0FA0E3 		mov	r0, #500
 6018 3534 FEFFFFEB 		bl	_tx_thread_sleep
 6019              	.LBB220:
 6020              	.LBB221:
1794:../uvc.c      ****     status = CyU3PI2cInit ();
 6021              		.loc 1 1794 0
 6022 3538 FEFFFFEB 		bl	CyU3PI2cInit
 6023              	.LVL478:
1795:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6024              		.loc 1 1795 0
 6025 353c 004050E2 		subs	r4, r0, #0
 6026 3540 0400000A 		beq	.L508
1797:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6027              		.loc 1 1797 0
 6028 3544 0400A0E3 		mov	r0, #4
 6029              	.LVL479:
 6030 3548 741A9FE5 		ldr	r1, .L608+8
 6031 354c FEFFFFEB 		bl	CyU3PDebugPrint
1798:../uvc.c      ****         CyFxAppErrorHandler (status);
 6032              		.loc 1 1798 0
 6033 3550 0400A0E1 		mov	r0, r4
 6034 3554 FEFFFFEB 		bl	CyFxAppErrorHandler
 6035              	.L508:
1802:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6036              		.loc 1 1802 0
 6037 3558 686A9FE5 		ldr	r6, .L608+12
1803:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6038              		.loc 1 1803 0
 6039 355c 0050A0E3 		mov	r5, #0
1804:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6040              		.loc 1 1804 0
 6041 3560 0040E0E3 		mvn	r4, #0
 6042              	.LVL480:
1807:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6043              		.loc 1 1807 0
 6044 3564 8C008DE2 		add	r0, sp, #140
 6045 3568 0510A0E1 		mov	r1, r5
1804:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6046              		.loc 1 1804 0
 6047 356c 94408DE5 		str	r4, [sp, #148]
1805:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6048              		.loc 1 1805 0
 6049 3570 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1802:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6050              		.loc 1 1802 0
 6051 3574 8C608DE5 		str	r6, [sp, #140]
1803:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6052              		.loc 1 1803 0
 6053 3578 90508DE5 		str	r5, [sp, #144]
1807:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6054              		.loc 1 1807 0
 6055 357c FEFFFFEB 		bl	CyU3PI2cSetConfig
 6056              	.LVL481:
1808:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6057              		.loc 1 1808 0
 6058 3580 004050E2 		subs	r4, r0, #0
 6059 3584 0400000A 		beq	.L509
1810:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6060              		.loc 1 1810 0
 6061 3588 0400A0E3 		mov	r0, #4
 6062              	.LVL482:
 6063 358c 381A9FE5 		ldr	r1, .L608+16
 6064 3590 FEFFFFEB 		bl	CyU3PDebugPrint
1811:../uvc.c      ****         CyFxAppErrorHandler (status);
 6065              		.loc 1 1811 0
 6066 3594 0400A0E1 		mov	r0, r4
 6067 3598 FEFFFFEB 		bl	CyFxAppErrorHandler
 6068              	.L509:
 6069              	.LBE221:
 6070              	.LBE220:
 6071              	.LBB222:
 6072              	.LBB225:
1881:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6073              		.loc 1 1881 0
 6074 359c 2C4A9FE5 		ldr	r4, .L608+20
 6075              	.LVL483:
 6076 35a0 2820A0E3 		mov	r2, #40
 6077 35a4 0010A0E3 		mov	r1, #0
 6078 35a8 0400A0E1 		mov	r0, r4
 6079 35ac FEFFFFEB 		bl	_txe_event_flags_create
 6080              	.LVL484:
1882:../uvc.c      ****     if (apiRetStatus != 0)
 6081              		.loc 1 1882 0
 6082 35b0 002050E2 		subs	r2, r0, #0
 6083 35b4 F800001A 		bne	.L582
1896:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6084              		.loc 1 1896 0
 6085 35b8 0260A0E3 		mov	r6, #2
1903:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6086              		.loc 1 1903 0
 6087 35bc 0210A0E1 		mov	r1, r2
1892:../uvc.c      ****     isUsbConnected = CyFalse;
 6088              		.loc 1 1892 0
 6089 35c0 302084E5 		str	r2, [r4, #48]
1893:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6090              		.loc 1 1893 0
 6091 35c4 442084E5 		str	r2, [r4, #68]
1899:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6092              		.loc 1 1899 0
 6093 35c8 0370A0E3 		mov	r7, #3
1903:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6094              		.loc 1 1903 0
 6095 35cc 9C008DE2 		add	r0, sp, #156
 6096              	.LVL485:
1898:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6097              		.loc 1 1898 0
 6098 35d0 A420CDE5 		strb	r2, [sp, #164]
1900:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6099              		.loc 1 1900 0
 6100 35d4 A0208DE5 		str	r2, [sp, #160]
1896:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6101              		.loc 1 1896 0
 6102 35d8 9C60CDE5 		strb	r6, [sp, #156]
1897:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6103              		.loc 1 1897 0
 6104 35dc 9D60CDE5 		strb	r6, [sp, #157]
1899:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6105              		.loc 1 1899 0
 6106 35e0 A570CDE5 		strb	r7, [sp, #165]
1903:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6107              		.loc 1 1903 0
 6108 35e4 FEFFFFEB 		bl	CyU3PGpioInit
 6109              	.LVL486:
1904:../uvc.c      ****     if (apiRetStatus != 0)
 6110              		.loc 1 1904 0
 6111 35e8 002050E2 		subs	r2, r0, #0
 6112 35ec FC00001A 		bne	.L583
1912:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6113              		.loc 1 1912 0
 6114 35f0 1600A0E3 		mov	r0, #22
 6115              	.LVL487:
 6116 35f4 0110A0E3 		mov	r1, #1
 6117 35f8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6118              	.LVL488:
1913:../uvc.c      ****     if (apiRetStatus != 0)
 6119              		.loc 1 1913 0
 6120 35fc 002050E2 		subs	r2, r0, #0
 6121 3600 EE00001A 		bne	.L584
1918:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6122              		.loc 1 1918 0
 6123 3604 1400A0E3 		mov	r0, #20
 6124              	.LVL489:
 6125 3608 0110A0E3 		mov	r1, #1
 6126 360c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6127              	.LVL490:
1919:../uvc.c      ****     if (apiRetStatus != 0)
 6128              		.loc 1 1919 0
 6129 3610 002050E2 		subs	r2, r0, #0
 6130 3614 FB00001A 		bne	.L585
1924:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6131              		.loc 1 1924 0
 6132 3618 1800A0E3 		mov	r0, #24
 6133              	.LVL491:
 6134 361c 0110A0E3 		mov	r1, #1
 6135 3620 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6136              	.LVL492:
1925:../uvc.c      ****     if (apiRetStatus != 0)
 6137              		.loc 1 1925 0
 6138 3624 002050E2 		subs	r2, r0, #0
 6139 3628 D601001A 		bne	.L586
1932:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6140              		.loc 1 1932 0
 6141 362c 0150A0E3 		mov	r5, #1
1937:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6142              		.loc 1 1937 0
 6143 3630 1600A0E3 		mov	r0, #22
 6144              	.LVL493:
 6145 3634 68108DE2 		add	r1, sp, #104
1935:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6146              		.loc 1 1935 0
 6147 3638 74208DE5 		str	r2, [sp, #116]
1936:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6148              		.loc 1 1936 0
 6149 363c 7820CDE5 		strb	r2, [sp, #120]
1932:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6150              		.loc 1 1932 0
 6151 3640 68508DE5 		str	r5, [sp, #104]
1933:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6152              		.loc 1 1933 0
 6153 3644 6C508DE5 		str	r5, [sp, #108]
1934:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6154              		.loc 1 1934 0
 6155 3648 70508DE5 		str	r5, [sp, #112]
1937:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6156              		.loc 1 1937 0
 6157 364c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6158              	.LVL494:
1938:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6159              		.loc 1 1938 0
 6160 3650 002050E2 		subs	r2, r0, #0
 6161 3654 C201001A 		bne	.L587
1951:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6162              		.loc 1 1951 0
 6163 3658 1400A0E3 		mov	r0, #20
 6164              	.LVL495:
 6165 365c 68108DE2 		add	r1, sp, #104
1949:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6166              		.loc 1 1949 0
 6167 3660 74208DE5 		str	r2, [sp, #116]
1950:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6168              		.loc 1 1950 0
 6169 3664 7820CDE5 		strb	r2, [sp, #120]
1946:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6170              		.loc 1 1946 0
 6171 3668 68508DE5 		str	r5, [sp, #104]
1947:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6172              		.loc 1 1947 0
 6173 366c 6C508DE5 		str	r5, [sp, #108]
1948:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6174              		.loc 1 1948 0
 6175 3670 70508DE5 		str	r5, [sp, #112]
1951:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6176              		.loc 1 1951 0
 6177 3674 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6178              	.LVL496:
1952:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6179              		.loc 1 1952 0
 6180 3678 002050E2 		subs	r2, r0, #0
 6181 367c CA01001A 		bne	.L588
1965:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6182              		.loc 1 1965 0
 6183 3680 1800A0E3 		mov	r0, #24
 6184              	.LVL497:
 6185 3684 68108DE2 		add	r1, sp, #104
1960:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6186              		.loc 1 1960 0
 6187 3688 68208DE5 		str	r2, [sp, #104]
1961:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6188              		.loc 1 1961 0
 6189 368c 6C208DE5 		str	r2, [sp, #108]
1962:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6190              		.loc 1 1962 0
 6191 3690 70208DE5 		str	r2, [sp, #112]
1964:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6192              		.loc 1 1964 0
 6193 3694 7820CDE5 		strb	r2, [sp, #120]
1963:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6194              		.loc 1 1963 0
 6195 3698 74508DE5 		str	r5, [sp, #116]
1965:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6196              		.loc 1 1965 0
 6197 369c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6198              	.LVL498:
1966:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6199              		.loc 1 1966 0
 6200 36a0 002050E2 		subs	r2, r0, #0
 6201 36a4 A501001A 		bne	.L589
1978:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6202              		.loc 1 1978 0
 6203 36a8 0500A0E1 		mov	r0, r5
 6204              	.LVL499:
 6205 36ac 7C108DE2 		add	r1, sp, #124
1975:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6206              		.loc 1 1975 0
 6207 36b0 84208DE5 		str	r2, [sp, #132]
1976:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6208              		.loc 1 1976 0
 6209 36b4 80208DE5 		str	r2, [sp, #128]
1973:../uvc.c      ****     pibclock.clkDiv      = 2;
 6210              		.loc 1 1973 0
 6211 36b8 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
1974:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6212              		.loc 1 1974 0
 6213 36bc 8870CDE5 		strb	r7, [sp, #136]
1978:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6214              		.loc 1 1978 0
 6215 36c0 FEFFFFEB 		bl	CyU3PPibInit
 6216              	.LVL500:
1979:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6217              		.loc 1 1979 0
 6218 36c4 002050E2 		subs	r2, r0, #0
 6219 36c8 9301001A 		bne	.L590
1986:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6220              		.loc 1 1986 0
 6221 36cc 00099FE5 		ldr	r0, .L608+24
 6222              	.LVL501:
 6223 36d0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6224              	.LVL502:
1994:../uvc.c      ****     SensorReset ();
 6225              		.loc 1 1994 0
 6226 36d4 FEFFFFEB 		bl	SensorReset
1995:../uvc.c      ****     CyU3PThreadSleep(5000);
 6227              		.loc 1 1995 0
 6228 36d8 F8089FE5 		ldr	r0, .L608+28
 6229 36dc FEFFFFEB 		bl	_tx_thread_sleep
1999:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6230              		.loc 1 1999 0
 6231 36e0 FEFFFFEB 		bl	CyU3PUsbStart
 6232              	.LVL503:
2000:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6233              		.loc 1 2000 0
 6234 36e4 002050E2 		subs	r2, r0, #0
 6235 36e8 8201001A 		bne	.L591
2006:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6236              		.loc 1 2006 0
 6237 36ec 0010A0E3 		mov	r1, #0
 6238 36f0 E4089FE5 		ldr	r0, .L608+32
 6239              	.LVL504:
 6240 36f4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6241              	.LVL505:
2009:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6242              		.loc 1 2009 0
 6243 36f8 E0089FE5 		ldr	r0, .L608+36
 6244 36fc FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2015:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6245              		.loc 1 2015 0
 6246 3700 0010A0E3 		mov	r1, #0
 6247 3704 D8289FE5 		ldr	r2, .L608+40
 6248 3708 0100A0E3 		mov	r0, #1
 6249 370c FEFFFFEB 		bl	CyU3PUsbSetDesc
2016:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6250              		.loc 1 2016 0
 6251 3710 0000A0E3 		mov	r0, #0
 6252 3714 0010A0E1 		mov	r1, r0
 6253 3718 C8289FE5 		ldr	r2, .L608+44
 6254 371c FEFFFFEB 		bl	CyU3PUsbSetDesc
2019:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6255              		.loc 1 2019 0
 6256 3720 0010A0E3 		mov	r1, #0
 6257 3724 C0289FE5 		ldr	r2, .L608+48
 6258 3728 0200A0E3 		mov	r0, #2
 6259 372c FEFFFFEB 		bl	CyU3PUsbSetDesc
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6260              		.loc 1 2020 0
 6261 3730 0010A0E3 		mov	r1, #0
 6262 3734 B4289FE5 		ldr	r2, .L608+52
 6263 3738 0700A0E3 		mov	r0, #7
 6264 373c FEFFFFEB 		bl	CyU3PUsbSetDesc
2023:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6265              		.loc 1 2023 0
 6266 3740 0010A0E3 		mov	r1, #0
 6267 3744 A8289FE5 		ldr	r2, .L608+56
 6268 3748 0400A0E3 		mov	r0, #4
 6269 374c FEFFFFEB 		bl	CyU3PUsbSetDesc
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6270              		.loc 1 2024 0
 6271 3750 0010A0E3 		mov	r1, #0
 6272 3754 9C289FE5 		ldr	r2, .L608+60
 6273 3758 0300A0E3 		mov	r0, #3
 6274 375c FEFFFFEB 		bl	CyU3PUsbSetDesc
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6275              		.loc 1 2025 0
 6276 3760 0010A0E3 		mov	r1, #0
 6277 3764 90289FE5 		ldr	r2, .L608+64
 6278 3768 0600A0E3 		mov	r0, #6
 6279 376c FEFFFFEB 		bl	CyU3PUsbSetDesc
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6280              		.loc 1 2028 0
 6281 3770 0010A0E3 		mov	r1, #0
 6282 3774 84289FE5 		ldr	r2, .L608+68
 6283 3778 0500A0E3 		mov	r0, #5
 6284 377c FEFFFFEB 		bl	CyU3PUsbSetDesc
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6285              		.loc 1 2029 0
 6286 3780 0110A0E3 		mov	r1, #1
 6287 3784 78289FE5 		ldr	r2, .L608+72
 6288 3788 0500A0E3 		mov	r0, #5
 6289 378c FEFFFFEB 		bl	CyU3PUsbSetDesc
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6290              		.loc 1 2030 0
 6291 3790 0210A0E3 		mov	r1, #2
 6292 3794 6C289FE5 		ldr	r2, .L608+76
 6293 3798 0500A0E3 		mov	r0, #5
 6294 379c FEFFFFEB 		bl	CyU3PUsbSetDesc
2040:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6295              		.loc 1 2040 0
 6296 37a0 0080A0E3 		mov	r8, #0
2037:../uvc.c      ****     endPointConfig.enable   = 1;
 6297              		.loc 1 2037 0
 6298 37a4 0150A0E3 		mov	r5, #1
2039:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6299              		.loc 1 2039 0
 6300 37a8 4070A0E3 		mov	r7, #64	@ movhi
2043:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6301              		.loc 1 2043 0
 6302 37ac 8200A0E3 		mov	r0, #130
 6303 37b0 A8108DE2 		add	r1, sp, #168
2038:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6304              		.loc 1 2038 0
 6305 37b4 03A0A0E3 		mov	sl, #3
2039:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6306              		.loc 1 2039 0
 6307 37b8 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2037:../uvc.c      ****     endPointConfig.enable   = 1;
 6308              		.loc 1 2037 0
 6309 37bc A8508DE5 		str	r5, [sp, #168]
2038:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6310              		.loc 1 2038 0
 6311 37c0 ACA0CDE5 		strb	sl, [sp, #172]
2040:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6312              		.loc 1 2040 0
 6313 37c4 B380CDE5 		strb	r8, [sp, #179]
2041:../uvc.c      ****     endPointConfig.streams  = 0;
 6314              		.loc 1 2041 0
 6315 37c8 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2042:../uvc.c      ****     endPointConfig.burstLen = 1;
 6316              		.loc 1 2042 0
 6317 37cc B250CDE5 		strb	r5, [sp, #178]
2043:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6318              		.loc 1 2043 0
 6319 37d0 FEFFFFEB 		bl	CyU3PSetEpConfig
 6320              	.LVL506:
2041:../uvc.c      ****     endPointConfig.streams  = 0;
 6321              		.loc 1 2041 0
 6322 37d4 0870A0E1 		mov	r7, r8	@ movhi
2044:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6323              		.loc 1 2044 0
 6324 37d8 003050E2 		subs	r3, r0, #0
 6325 37dc 3B01001A 		bne	.L592
2054:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6326              		.loc 1 2054 0
 6327 37e0 24C89FE5 		ldr	ip, .L608+80
2055:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6328              		.loc 1 2055 0
 6329 37e4 24E89FE5 		ldr	lr, .L608+84
2052:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6330              		.loc 1 2052 0
 6331 37e8 016BA0E3 		mov	r6, #1024	@ movhi
2061:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6332              		.loc 1 2061 0
 6333 37ec 1080A0E3 		mov	r8, #16
2063:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6334              		.loc 1 2063 0
 6335 37f0 1C089FE5 		ldr	r0, .L608+88
 6336              	.LVL507:
 6337 37f4 0410A0E3 		mov	r1, #4
 6338 37f8 34208DE2 		add	r2, sp, #52
2052:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6339              		.loc 1 2052 0
 6340 37fc B463CDE1 		strh	r6, [sp, #52]	@ movhi
2053:../uvc.c      ****     dmaInterConfig.count          = 1;
 6341              		.loc 1 2053 0
 6342 3800 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2054:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6343              		.loc 1 2054 0
 6344 3804 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2055:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6345              		.loc 1 2055 0
 6346 3808 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2056:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6347              		.loc 1 2056 0
 6348 380c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2057:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6349              		.loc 1 2057 0
 6350 3810 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2058:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6351              		.loc 1 2058 0
 6352 3814 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2059:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6353              		.loc 1 2059 0
 6354 3818 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2060:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6355              		.loc 1 2060 0
 6356 381c 4470CDE5 		strb	r7, [sp, #68]
2061:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6357              		.loc 1 2061 0
 6358 3820 48808DE5 		str	r8, [sp, #72]
2062:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6359              		.loc 1 2062 0
 6360 3824 4C308DE5 		str	r3, [sp, #76]
2063:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6361              		.loc 1 2063 0
 6362 3828 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6363              	.LVL508:
2065:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6364              		.loc 1 2065 0
 6365 382c 006050E2 		subs	r6, r0, #0
 6366 3830 DF00001A 		bne	.L593
2072:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6367              		.loc 1 2072 0
 6368 3834 010BA0E3 		mov	r0, #1024
 6369              	.LVL509:
 6370 3838 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6371 383c D4179FE5 		ldr	r1, .L608+92
2073:../uvc.c      ****     if (glInterStaBuffer == 0)
 6372              		.loc 1 2073 0
 6373 3840 000050E3 		cmp	r0, #0
2072:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6374              		.loc 1 2072 0
 6375 3844 000081E5 		str	r0, [r1, #0]
2073:../uvc.c      ****     if (glInterStaBuffer == 0)
 6376              		.loc 1 2073 0
 6377 3848 D000000A 		beq	.L594
2080:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6378              		.loc 1 2080 0
 6379 384c 0610A0E1 		mov	r1, r6
 6380 3850 0620A0E1 		mov	r2, r6
 6381 3854 3830A0E3 		mov	r3, #56
 6382 3858 BC079FE5 		ldr	r0, .L608+96
 6383 385c FEFFFFEB 		bl	_txe_mutex_create
2082:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6384              		.loc 1 2082 0
 6385 3860 0430A0E3 		mov	r3, #4	@ movhi
 6386 3864 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2085:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6387              		.loc 1 2085 0
 6388 3868 B0379FE5 		ldr	r3, .L608+100
2081:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6389              		.loc 1 2081 0
 6390 386c 01C9A0E3 		mov	ip, #16384	@ movhi
 6391 3870 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2084:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6392              		.loc 1 2084 0
 6393 3874 01CCA0E3 		mov	ip, #256	@ movhi
 6394 3878 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2085:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6395              		.loc 1 2085 0
 6396 387c B431CDE1 		strh	r3, [sp, #20]	@ movhi
2086:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6397              		.loc 1 2086 0
 6398 3880 9CC79FE5 		ldr	ip, .L608+104
2088:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6399              		.loc 1 2088 0
 6400 3884 0C30A0E3 		mov	r3, #12	@ movhi
 6401 3888 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2093:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6402              		.loc 1 2093 0
 6403 388c 94379FE5 		ldr	r3, .L608+108
2094:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6404              		.loc 1 2094 0
 6405 3890 0C208DE2 		add	r2, sp, #12
2086:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6406              		.loc 1 2086 0
 6407 3894 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2091:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6408              		.loc 1 2091 0
 6409 3898 2A70CDE5 		strb	r7, [sp, #42]
2089:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6410              		.loc 1 2089 0
 6411 389c 04C0A0E3 		mov	ip, #4	@ movhi
2083:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6412              		.loc 1 2083 0
 6413 38a0 02A0A0E3 		mov	sl, #2	@ movhi
2094:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6414              		.loc 1 2094 0
 6415 38a4 80079FE5 		ldr	r0, .L608+112
 6416 38a8 0710A0E3 		mov	r1, #7
2092:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6417              		.loc 1 2092 0
 6418 38ac 1870A0E3 		mov	r7, #24
2083:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6419              		.loc 1 2083 0
 6420 38b0 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2087:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6421              		.loc 1 2087 0
 6422 38b4 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2089:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6423              		.loc 1 2089 0
 6424 38b8 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2090:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6425              		.loc 1 2090 0
 6426 38bc B862CDE1 		strh	r6, [sp, #40]	@ movhi
2092:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6427              		.loc 1 2092 0
 6428 38c0 2C708DE5 		str	r7, [sp, #44]
2093:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6429              		.loc 1 2093 0
 6430 38c4 30308DE5 		str	r3, [sp, #48]
2094:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6431              		.loc 1 2094 0
 6432 38c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6433              	.LVL510:
2096:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6434              		.loc 1 2096 0
 6435 38cc 002050E2 		subs	r2, r0, #0
 6436 38d0 A500001A 		bne	.L595
2187:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6437              		.loc 1 2187 0
 6438 38d4 0500A0E1 		mov	r0, r5
 6439              	.LVL511:
 6440 38d8 0510A0E1 		mov	r1, r5
 6441 38dc FEFFFFEB 		bl	CyU3PConnectState
 6442              	.LVL512:
2188:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6443              		.loc 1 2188 0
 6444 38e0 002050E2 		subs	r2, r0, #0
 6445 38e4 9700001A 		bne	.L596
2194:../uvc.c      ****     CyU3PBusyWait(100);
 6446              		.loc 1 2194 0
 6447 38e8 6400A0E3 		mov	r0, #100
 6448              	.LVL513:
 6449 38ec FEFFFFEB 		bl	CyU3PBusyWait
 6450              	.LVL514:
2196:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6451              		.loc 1 2196 0
 6452 38f0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2210:../uvc.c      ****     endPointConfig.streams  = 0;
 6453              		.loc 1 2210 0
 6454 38f4 0020A0E3 		mov	r2, #0	@ movhi
2199:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6455              		.loc 1 2199 0
 6456 38f8 ACA0CDE5 		strb	sl, [sp, #172]
2211:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6457              		.loc 1 2211 0
 6458 38fc A8108DE2 		add	r1, sp, #168
2210:../uvc.c      ****     endPointConfig.streams  = 0;
 6459              		.loc 1 2210 0
 6460 3900 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2198:../uvc.c      ****     endPointConfig.enable   = 1;
 6461              		.loc 1 2198 0
 6462 3904 A8508DE5 		str	r5, [sp, #168]
2200:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6463              		.loc 1 2200 0
 6464 3908 030050E3 		cmp	r0, #3
2196:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6465              		.loc 1 2196 0
 6466 390c 4800C4E5 		strb	r0, [r4, #72]
2207:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6467              		.loc 1 2207 0
 6468 3910 020CA013 		movne	r0, #512	@ movhi
2202:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6469              		.loc 1 2202 0
 6470 3914 01ABA003 		moveq	sl, #1024	@ movhi
2207:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6471              		.loc 1 2207 0
 6472 3918 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2211:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6473              		.loc 1 2211 0
 6474 391c 8300A0E3 		mov	r0, #131
2202:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6475              		.loc 1 2202 0
 6476 3920 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2203:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6477              		.loc 1 2203 0
 6478 3924 B280CD05 		streqb	r8, [sp, #178]
2208:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6479              		.loc 1 2208 0
 6480 3928 B250CD15 		strneb	r5, [sp, #178]
2211:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6481              		.loc 1 2211 0
 6482 392c FEFFFFEB 		bl	CyU3PSetEpConfig
 6483              	.LVL515:
2212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6484              		.loc 1 2212 0
 6485 3930 002050E2 		subs	r2, r0, #0
 6486 3934 4F00001A 		bne	.L579
 6487 3938 F0769FE5 		ldr	r7, .L608+116
 6488              	.LBE225:
 6489              	.LBE222:
2335:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6490              		.loc 1 2335 0
 6491 393c 8C569FE5 		ldr	r5, .L608+20
 6492 3940 0260A0E1 		mov	r6, r2
2519:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6493              		.loc 1 2519 0
 6494 3944 0080E0E3 		mvn	r8, #0
 6495              	.LVL516:
 6496              	.L542:
2335:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6497              		.loc 1 2335 0
 6498 3948 80069FE5 		ldr	r0, .L608+20
 6499 394c 0110A0E3 		mov	r1, #1
 6500 3950 0220A0E3 		mov	r2, #2
 6501 3954 B4308DE2 		add	r3, sp, #180
 6502 3958 00608DE5 		str	r6, [sp, #0]
 6503 395c FEFFFFEB 		bl	_txe_event_flags_get
 6504 3960 000050E3 		cmp	r0, #0
 6505 3964 3000001A 		bne	.L544
2381:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6506              		.loc 1 2381 0
 6507 3968 3CE095E5 		ldr	lr, [r5, #60]
 6508 396c 00005EE3 		cmp	lr, #0
 6509 3970 0300000A 		beq	.L545
2381:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6510              		.loc 1 2381 0 is_stmt 0 discriminator 1
 6511 3974 B014D5E1 		ldrh	r1, [r5, #64]
 6512 3978 B234D5E1 		ldrh	r3, [r5, #66]
 6513 397c 030051E1 		cmp	r1, r3
 6514 3980 1201000A 		beq	.L597
 6515              	.L545:
2580:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6516              		.loc 1 2580 0 is_stmt 1
 6517 3984 4010A0E3 		mov	r1, #64
 6518 3988 0020A0E3 		mov	r2, #0
 6519 398c 3C069FE5 		ldr	r0, .L608+20
 6520 3990 FEFFFFEB 		bl	_txe_event_flags_set
2583:../uvc.c      ****         CyU3PThreadRelinquish ();
 6521              		.loc 1 2583 0
 6522 3994 FEFFFFEB 		bl	_txe_thread_relinquish
2584:../uvc.c      ****     }
 6523              		.loc 1 2584 0
 6524 3998 EAFFFFEA 		b	.L542
 6525              	.LVL517:
 6526              	.L582:
 6527              	.LBB260:
 6528              	.LBB224:
1884:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6529              		.loc 1 1884 0
 6530 399c 0400A0E3 		mov	r0, #4
 6531              	.LVL518:
 6532 39a0 8C169FE5 		ldr	r1, .L608+120
 6533 39a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6534              	.LVL519:
 6535              	.L511:
 6536              	.LBB240:
 6537              	.LBB241:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6538              		.loc 1 1313 0
 6539 39a8 88169FE5 		ldr	r1, .L608+124
 6540 39ac 0400A0E3 		mov	r0, #4
 6541 39b0 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6542              		.loc 1 1314 0
 6543 39b4 FA0FA0E3 		mov	r0, #1000
 6544 39b8 FEFFFFEB 		bl	_tx_thread_sleep
 6545 39bc F9FFFFEA 		b	.L511
 6546              	.LVL520:
 6547              	.L584:
 6548              	.LBE241:
 6549              	.LBE240:
1915:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6550              		.loc 1 1915 0
 6551 39c0 0400A0E3 		mov	r0, #4
 6552              	.LVL521:
 6553 39c4 70169FE5 		ldr	r1, .L608+128
 6554 39c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6555              	.LVL522:
 6556              	.L515:
 6557              	.LBB238:
 6558              	.LBB239:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6559              		.loc 1 1313 0
 6560 39cc 64169FE5 		ldr	r1, .L608+124
 6561 39d0 0400A0E3 		mov	r0, #4
 6562 39d4 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6563              		.loc 1 1314 0
 6564 39d8 FA0FA0E3 		mov	r0, #1000
 6565 39dc FEFFFFEB 		bl	_tx_thread_sleep
 6566 39e0 F9FFFFEA 		b	.L515
 6567              	.LVL523:
 6568              	.L583:
 6569              	.LBE239:
 6570              	.LBE238:
1906:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6571              		.loc 1 1906 0
 6572 39e4 0400A0E3 		mov	r0, #4
 6573              	.LVL524:
 6574 39e8 50169FE5 		ldr	r1, .L608+132
 6575 39ec FEFFFFEB 		bl	CyU3PDebugPrint
 6576              	.LVL525:
 6577              	.L513:
 6578              	.LBB236:
 6579              	.LBB237:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6580              		.loc 1 1313 0
 6581 39f0 40169FE5 		ldr	r1, .L608+124
 6582 39f4 0400A0E3 		mov	r0, #4
 6583 39f8 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6584              		.loc 1 1314 0
 6585 39fc FA0FA0E3 		mov	r0, #1000
 6586 3a00 FEFFFFEB 		bl	_tx_thread_sleep
 6587 3a04 F9FFFFEA 		b	.L513
 6588              	.LVL526:
 6589              	.L585:
 6590              	.LBE237:
 6591              	.LBE236:
1921:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6592              		.loc 1 1921 0
 6593 3a08 0400A0E3 		mov	r0, #4
 6594              	.LVL527:
 6595 3a0c 30169FE5 		ldr	r1, .L608+136
 6596 3a10 FEFFFFEB 		bl	CyU3PDebugPrint
 6597              	.LVL528:
 6598              	.L517:
 6599              	.LBB234:
 6600              	.LBB235:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6601              		.loc 1 1313 0
 6602 3a14 1C169FE5 		ldr	r1, .L608+124
 6603 3a18 0400A0E3 		mov	r0, #4
 6604 3a1c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6605              		.loc 1 1314 0
 6606 3a20 FA0FA0E3 		mov	r0, #1000
 6607 3a24 FEFFFFEB 		bl	_tx_thread_sleep
 6608 3a28 F9FFFFEA 		b	.L517
 6609              	.LVL529:
 6610              	.L544:
 6611              	.LBE235:
 6612              	.LBE234:
 6613              	.LBE224:
 6614              	.LBE260:
2487:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6615              		.loc 1 2487 0
 6616 3a2c 9C059FE5 		ldr	r0, .L608+20
 6617 3a30 0210A0E3 		mov	r1, #2
 6618 3a34 0320A0E3 		mov	r2, #3
 6619 3a38 B4308DE2 		add	r3, sp, #180
 6620 3a3c 00608DE5 		str	r6, [sp, #0]
 6621 3a40 FEFFFFEB 		bl	_txe_event_flags_get
 6622 3a44 000050E3 		cmp	r0, #0
 6623 3a48 2500001A 		bne	.L560
2502:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6624              		.loc 1 2502 0
 6625 3a4c 441095E5 		ldr	r1, [r5, #68]
2490:../uvc.c      ****                 hitFV     = CyFalse;
 6626              		.loc 1 2490 0
 6627 3a50 3C6085E5 		str	r6, [r5, #60]
2502:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6628              		.loc 1 2502 0
 6629 3a54 000051E3 		cmp	r1, #0
2491:../uvc.c      ****                 prodCount = 0;
 6630              		.loc 1 2491 0
 6631 3a58 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2498:../uvc.c      ****                 fb=0;
 6632              		.loc 1 2498 0
 6633 3a5c B463C5E1 		strh	r6, [r5, #52]	@ movhi
2492:../uvc.c      ****                 consCount = 0;
 6634              		.loc 1 2492 0
 6635 3a60 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2499:../uvc.c      ****                 pb=0;
 6636              		.loc 1 2499 0
 6637 3a64 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2500:../uvc.c      ****                 pbc=0;
 6638              		.loc 1 2500 0
 6639 3a68 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2502:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6640              		.loc 1 2502 0
 6641 3a6c 0A00000A 		beq	.L598
 6642              	.L561:
2514:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6643              		.loc 1 2514 0
 6644 3a70 446084E5 		str	r6, [r4, #68]
 6645 3a74 C2FFFFEA 		b	.L545
 6646              	.LVL530:
 6647              	.L579:
 6648              	.LBB261:
 6649              	.LBB258:
2215:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6650              		.loc 1 2215 0
 6651 3a78 0400A0E3 		mov	r0, #4
 6652              	.LVL531:
 6653 3a7c C4159FE5 		ldr	r1, .L608+140
 6654 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
 6655              	.LVL532:
 6656              	.L543:
 6657              	.LBB242:
 6658              	.LBB243:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6659              		.loc 1 1313 0
 6660 3a84 AC159FE5 		ldr	r1, .L608+124
 6661 3a88 0400A0E3 		mov	r0, #4
 6662 3a8c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6663              		.loc 1 1314 0
 6664 3a90 FA0FA0E3 		mov	r0, #1000
 6665 3a94 FEFFFFEB 		bl	_tx_thread_sleep
 6666 3a98 F9FFFFEA 		b	.L543
 6667              	.LVL533:
 6668              	.L598:
 6669              	.LBE243:
 6670              	.LBE242:
 6671              	.LBE258:
 6672              	.LBE261:
2504:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6673              		.loc 1 2504 0
 6674 3a9c 88059FE5 		ldr	r0, .L608+112
 6675 3aa0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6676              	.LVL534:
2505:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6677              		.loc 1 2505 0
 6678 3aa4 000050E3 		cmp	r0, #0
 6679 3aa8 0200001A 		bne	.L580
2511:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6680              		.loc 1 2511 0
 6681 3aac 8300A0E3 		mov	r0, #131
 6682              	.LVL535:
 6683 3ab0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6684 3ab4 EDFFFFEA 		b	.L561
 6685              	.L580:
 6686              	.LBB262:
 6687              	.LBB263:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6688              		.loc 1 1313 0
 6689 3ab8 78159FE5 		ldr	r1, .L608+124
 6690 3abc 0400A0E3 		mov	r0, #4
 6691 3ac0 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6692              		.loc 1 1314 0
 6693 3ac4 FA0FA0E3 		mov	r0, #1000
 6694 3ac8 FEFFFFEB 		bl	_tx_thread_sleep
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6695              		.loc 1 1313 0
 6696 3acc 64159FE5 		ldr	r1, .L608+124
 6697 3ad0 0400A0E3 		mov	r0, #4
 6698 3ad4 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6699              		.loc 1 1314 0
 6700 3ad8 FA0FA0E3 		mov	r0, #1000
 6701 3adc FEFFFFEB 		bl	_tx_thread_sleep
 6702 3ae0 F4FFFFEA 		b	.L580
 6703              	.L560:
 6704              	.LBE263:
 6705              	.LBE262:
2519:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6706              		.loc 1 2519 0
 6707 3ae4 0110A0E3 		mov	r1, #1
 6708 3ae8 0220A0E3 		mov	r2, #2
 6709 3aec B4308DE2 		add	r3, sp, #180
 6710 3af0 D8049FE5 		ldr	r0, .L608+20
 6711 3af4 00808DE5 		str	r8, [sp, #0]
 6712 3af8 FEFFFFEB 		bl	_txe_event_flags_get
2523:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6713              		.loc 1 2523 0
 6714 3afc 0620A0E1 		mov	r2, r6
 6715 3b00 24059FE5 		ldr	r0, .L608+112
 6716 3b04 0610A0E1 		mov	r1, r6
 6717 3b08 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6718              	.LVL536:
2524:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6719              		.loc 1 2524 0
 6720 3b0c 002050E2 		subs	r2, r0, #0
 6721 3b10 6500001A 		bne	.L599
2532:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6722              		.loc 1 2532 0
 6723 3b14 282095E5 		ldr	r2, [r5, #40]
 6724 3b18 000052E3 		cmp	r2, #0
 6725 3b1c 5A00001A 		bne	.L566
 6726              	.LVL537:
 6727              	.LBB264:
 6728              	.LBB265:
2240:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6729              		.loc 1 2240 0
 6730 3b20 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6731 3b24 030053E3 		cmp	r3, #3
 6732 3b28 4700000A 		beq	.L600
2245:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6733              		.loc 1 2245 0
 6734 3b2c 020053E3 		cmp	r3, #2
 6735 3b30 2900000A 		beq	.L601
 6736              	.LVL538:
 6737              	.L569:
 6738              	.LBE265:
 6739              	.LBE264:
2568:../uvc.c      ****                     gpif_initialized = CyTrue;
 6740              		.loc 1 2568 0
 6741 3b34 01E0A0E3 		mov	lr, #1
 6742 3b38 28E084E5 		str	lr, [r4, #40]
2569:../uvc.c      ****                     CyU3PThreadSleep(200);
 6743              		.loc 1 2569 0
 6744 3b3c C800A0E3 		mov	r0, #200
 6745 3b40 FEFFFFEB 		bl	_tx_thread_sleep
 6746 3b44 8EFFFFEA 		b	.L545
 6747              	.LVL539:
 6748              	.L596:
 6749              	.LBB271:
 6750              	.LBB223:
2190:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6751              		.loc 1 2190 0
 6752 3b48 0400A0E3 		mov	r0, #4
 6753              	.LVL540:
 6754 3b4c F8149FE5 		ldr	r1, .L608+144
 6755 3b50 FEFFFFEB 		bl	CyU3PDebugPrint
 6756              	.LVL541:
 6757              	.L539:
 6758              	.LBB232:
 6759              	.LBB233:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6760              		.loc 1 1313 0
 6761 3b54 DC149FE5 		ldr	r1, .L608+124
 6762 3b58 0400A0E3 		mov	r0, #4
 6763 3b5c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6764              		.loc 1 1314 0
 6765 3b60 FA0FA0E3 		mov	r0, #1000
 6766 3b64 FEFFFFEB 		bl	_tx_thread_sleep
 6767 3b68 F9FFFFEA 		b	.L539
 6768              	.LVL542:
 6769              	.L595:
 6770              	.LBE233:
 6771              	.LBE232:
2099:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6772              		.loc 1 2099 0
 6773 3b6c 0400A0E3 		mov	r0, #4
 6774              	.LVL543:
 6775 3b70 D8149FE5 		ldr	r1, .L608+148
 6776 3b74 FEFFFFEB 		bl	CyU3PDebugPrint
 6777              	.LVL544:
 6778              	.L537:
 6779              	.LBB230:
 6780              	.LBB231:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6781              		.loc 1 1313 0
 6782 3b78 B8149FE5 		ldr	r1, .L608+124
 6783 3b7c 0400A0E3 		mov	r0, #4
 6784 3b80 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6785              		.loc 1 1314 0
 6786 3b84 FA0FA0E3 		mov	r0, #1000
 6787 3b88 FEFFFFEB 		bl	_tx_thread_sleep
 6788 3b8c F9FFFFEA 		b	.L537
 6789              	.LVL545:
 6790              	.L594:
 6791              	.LBE231:
 6792              	.LBE230:
2075:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6793              		.loc 1 2075 0
 6794 3b90 040080E2 		add	r0, r0, #4
 6795 3b94 B8149FE5 		ldr	r1, .L608+152
 6796 3b98 FEFFFFEB 		bl	CyU3PDebugPrint
 6797              	.LVL546:
 6798              	.L535:
 6799              	.LBB228:
 6800              	.LBB229:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6801              		.loc 1 1313 0
 6802 3b9c 94149FE5 		ldr	r1, .L608+124
 6803 3ba0 0400A0E3 		mov	r0, #4
 6804 3ba4 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6805              		.loc 1 1314 0
 6806 3ba8 FA0FA0E3 		mov	r0, #1000
 6807 3bac FEFFFFEB 		bl	_tx_thread_sleep
 6808 3bb0 F9FFFFEA 		b	.L535
 6809              	.LVL547:
 6810              	.L593:
 6811              	.LBE229:
 6812              	.LBE228:
2068:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6813              		.loc 1 2068 0
 6814 3bb4 0400A0E3 		mov	r0, #4
 6815 3bb8 98149FE5 		ldr	r1, .L608+156
 6816 3bbc 0620A0E1 		mov	r2, r6
 6817 3bc0 FEFFFFEB 		bl	CyU3PDebugPrint
 6818              	.L533:
 6819              	.LBB226:
 6820              	.LBB227:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6821              		.loc 1 1313 0
 6822 3bc4 6C149FE5 		ldr	r1, .L608+124
 6823 3bc8 0400A0E3 		mov	r0, #4
 6824 3bcc FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6825              		.loc 1 1314 0
 6826 3bd0 FA0FA0E3 		mov	r0, #1000
 6827 3bd4 FEFFFFEB 		bl	_tx_thread_sleep
 6828 3bd8 F9FFFFEA 		b	.L533
 6829              	.LVL548:
 6830              	.L601:
 6831              	.LBE227:
 6832              	.LBE226:
 6833              	.LBE223:
 6834              	.LBE271:
 6835              	.LBB272:
 6836              	.LBB270:
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6837              		.loc 1 2247 0
 6838 3bdc 78149FE5 		ldr	r1, .L608+160
 6839 3be0 0100A0E3 		mov	r0, #1
 6840              	.LVL549:
 6841 3be4 FEFFFFEB 		bl	CyU3PDebugPrint
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6842              		.loc 1 2248 0
 6843 3be8 70049FE5 		ldr	r0, .L608+164
 6844 3bec FEFFFFEB 		bl	CyU3PGpifLoad
 6845 3bf0 0020A0E1 		mov	r2, r0
 6846              	.LVL550:
 6847              	.L568:
2250:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6848              		.loc 1 2250 0
 6849 3bf4 000052E3 		cmp	r2, #0
 6850 3bf8 1A00001A 		bne	.L602
2258:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6851              		.loc 1 2258 0
 6852 3bfc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6853 3c00 030053E3 		cmp	r3, #3
 6854 3c04 0100000A 		beq	.L581
2262:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6855              		.loc 1 2262 0
 6856 3c08 020053E3 		cmp	r3, #2
 6857 3c0c C8FFFF1A 		bne	.L569
 6858              	.L581:
2264:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6859              		.loc 1 2264 0
 6860 3c10 0200A0E1 		mov	r0, r2
 6861              	.LVL551:
 6862 3c14 0210A0E1 		mov	r1, r2
 6863 3c18 FEFFFFEB 		bl	CyU3PGpifSMStart
 6864              	.LVL552:
2266:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6865              		.loc 1 2266 0
 6866 3c1c 000050E3 		cmp	r0, #0
2264:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6867              		.loc 1 2264 0
 6868 3c20 0020A0E1 		mov	r2, r0
 6869              	.LVL553:
2266:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6870              		.loc 1 2266 0
 6871 3c24 C2FFFF0A 		beq	.L569
2269:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6872              		.loc 1 2269 0
 6873 3c28 0400A0E3 		mov	r0, #4
 6874              	.LVL554:
 6875 3c2c 30149FE5 		ldr	r1, .L608+168
 6876 3c30 FEFFFFEB 		bl	CyU3PDebugPrint
 6877              	.LVL555:
 6878              	.L574:
 6879              	.LBB266:
 6880              	.LBB267:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6881              		.loc 1 1313 0
 6882 3c34 FC139FE5 		ldr	r1, .L608+124
 6883 3c38 0400A0E3 		mov	r0, #4
 6884 3c3c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6885              		.loc 1 1314 0
 6886 3c40 FA0FA0E3 		mov	r0, #1000
 6887 3c44 FEFFFFEB 		bl	_tx_thread_sleep
 6888 3c48 F9FFFFEA 		b	.L574
 6889              	.LVL556:
 6890              	.L600:
 6891              	.LBE267:
 6892              	.LBE266:
2242:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6893              		.loc 1 2242 0
 6894 3c4c 14149FE5 		ldr	r1, .L608+172
 6895 3c50 0100A0E3 		mov	r0, #1
 6896              	.LVL557:
 6897 3c54 FEFFFFEB 		bl	CyU3PDebugPrint
2243:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6898              		.loc 1 2243 0
 6899 3c58 0C049FE5 		ldr	r0, .L608+176
 6900 3c5c FEFFFFEB 		bl	CyU3PGpifLoad
 6901 3c60 0020A0E1 		mov	r2, r0
 6902              	.LVL558:
 6903 3c64 E2FFFFEA 		b	.L568
 6904              	.L602:
2253:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6905              		.loc 1 2253 0
 6906 3c68 0400A0E3 		mov	r0, #4
 6907              	.LVL559:
 6908 3c6c FC139FE5 		ldr	r1, .L608+180
 6909 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
 6910              	.LVL560:
 6911              	.L571:
 6912              	.LBB268:
 6913              	.LBB269:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6914              		.loc 1 1313 0
 6915 3c74 BC139FE5 		ldr	r1, .L608+124
 6916 3c78 0400A0E3 		mov	r0, #4
 6917 3c7c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6918              		.loc 1 1314 0
 6919 3c80 FA0FA0E3 		mov	r0, #1000
 6920 3c84 FEFFFFEB 		bl	_tx_thread_sleep
 6921 3c88 F9FFFFEA 		b	.L571
 6922              	.LVL561:
 6923              	.L566:
 6924              	.LBE269:
 6925              	.LBE268:
 6926              	.LBE270:
 6927              	.LBE272:
2576:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6928              		.loc 1 2576 0
 6929 3c8c 8C039FE5 		ldr	r0, .L608+100
 6930              	.LVL562:
 6931 3c90 02C0A0E3 		mov	ip, #2
 6932 3c94 0610A0E1 		mov	r1, r6
 6933 3c98 0020A0E1 		mov	r2, r0
 6934 3c9c 0630A0E1 		mov	r3, r6
 6935 3ca0 00C08DE5 		str	ip, [sp, #0]
 6936 3ca4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6937 3ca8 35FFFFEA 		b	.L545
 6938              	.LVL563:
 6939              	.L599:
2527:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6940              		.loc 1 2527 0
 6941 3cac 0400A0E3 		mov	r0, #4
 6942              	.LVL564:
 6943 3cb0 BC139FE5 		ldr	r1, .L608+184
 6944 3cb4 FEFFFFEB 		bl	CyU3PDebugPrint
 6945              	.LVL565:
 6946              	.L565:
 6947              	.LBB273:
 6948              	.LBB274:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6949              		.loc 1 1313 0
 6950 3cb8 78139FE5 		ldr	r1, .L608+124
 6951 3cbc 0400A0E3 		mov	r0, #4
 6952 3cc0 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6953              		.loc 1 1314 0
 6954 3cc4 FA0FA0E3 		mov	r0, #1000
 6955 3cc8 FEFFFFEB 		bl	_tx_thread_sleep
 6956 3ccc F9FFFFEA 		b	.L565
 6957              	.LVL566:
 6958              	.L592:
 6959              	.LBE274:
 6960              	.LBE273:
 6961              	.LBB275:
 6962              	.LBB259:
2047:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6963              		.loc 1 2047 0
 6964 3cd0 0400A0E3 		mov	r0, #4
 6965              	.LVL567:
 6966 3cd4 6C139FE5 		ldr	r1, .L608+140
 6967 3cd8 0320A0E1 		mov	r2, r3
 6968 3cdc FEFFFFEB 		bl	CyU3PDebugPrint
 6969              	.LVL568:
 6970              	.L531:
 6971              	.LBB244:
 6972              	.LBB245:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6973              		.loc 1 1313 0
 6974 3ce0 50139FE5 		ldr	r1, .L608+124
 6975 3ce4 0400A0E3 		mov	r0, #4
 6976 3ce8 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6977              		.loc 1 1314 0
 6978 3cec FA0FA0E3 		mov	r0, #1000
 6979 3cf0 FEFFFFEB 		bl	_tx_thread_sleep
 6980 3cf4 F9FFFFEA 		b	.L531
 6981              	.LVL569:
 6982              	.L591:
 6983              	.LBE245:
 6984              	.LBE244:
2002:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6985              		.loc 1 2002 0
 6986 3cf8 0400A0E3 		mov	r0, #4
 6987              	.LVL570:
 6988 3cfc 74139FE5 		ldr	r1, .L608+188
 6989 3d00 FEFFFFEB 		bl	CyU3PDebugPrint
 6990              	.LVL571:
 6991              	.L529:
 6992              	.LBB246:
 6993              	.LBB247:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6994              		.loc 1 1313 0
 6995 3d04 2C139FE5 		ldr	r1, .L608+124
 6996 3d08 0400A0E3 		mov	r0, #4
 6997 3d0c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 6998              		.loc 1 1314 0
 6999 3d10 FA0FA0E3 		mov	r0, #1000
 7000 3d14 FEFFFFEB 		bl	_tx_thread_sleep
 7001 3d18 F9FFFFEA 		b	.L529
 7002              	.LVL572:
 7003              	.L590:
 7004              	.LBE247:
 7005              	.LBE246:
1981:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7006              		.loc 1 1981 0
 7007 3d1c 0400A0E3 		mov	r0, #4
 7008              	.LVL573:
 7009 3d20 54139FE5 		ldr	r1, .L608+192
 7010 3d24 FEFFFFEB 		bl	CyU3PDebugPrint
 7011              	.LVL574:
 7012              	.L527:
 7013              	.LBB248:
 7014              	.LBB249:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7015              		.loc 1 1313 0
 7016 3d28 08139FE5 		ldr	r1, .L608+124
 7017 3d2c 0400A0E3 		mov	r0, #4
 7018 3d30 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7019              		.loc 1 1314 0
 7020 3d34 FA0FA0E3 		mov	r0, #1000
 7021 3d38 FEFFFFEB 		bl	_tx_thread_sleep
 7022 3d3c F9FFFFEA 		b	.L527
 7023              	.LVL575:
 7024              	.L589:
 7025              	.LBE249:
 7026              	.LBE248:
1968:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7027              		.loc 1 1968 0
 7028 3d40 0400A0E3 		mov	r0, #4
 7029              	.LVL576:
 7030 3d44 34139FE5 		ldr	r1, .L608+196
 7031 3d48 FEFFFFEB 		bl	CyU3PDebugPrint
 7032              	.LVL577:
 7033              	.L525:
 7034              	.LBB250:
 7035              	.LBB251:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7036              		.loc 1 1313 0
 7037 3d4c E4129FE5 		ldr	r1, .L608+124
 7038 3d50 0400A0E3 		mov	r0, #4
 7039 3d54 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7040              		.loc 1 1314 0
 7041 3d58 FA0FA0E3 		mov	r0, #1000
 7042 3d5c FEFFFFEB 		bl	_tx_thread_sleep
 7043 3d60 F9FFFFEA 		b	.L525
 7044              	.LVL578:
 7045              	.L587:
 7046              	.LBE251:
 7047              	.LBE250:
1940:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7048              		.loc 1 1940 0
 7049 3d64 0400A0E3 		mov	r0, #4
 7050              	.LVL579:
 7051 3d68 14139FE5 		ldr	r1, .L608+200
 7052 3d6c FEFFFFEB 		bl	CyU3PDebugPrint
 7053              	.LVL580:
 7054              	.L521:
 7055              	.LBB252:
 7056              	.LBB253:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7057              		.loc 1 1313 0
 7058 3d70 C0129FE5 		ldr	r1, .L608+124
 7059 3d74 0400A0E3 		mov	r0, #4
 7060 3d78 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7061              		.loc 1 1314 0
 7062 3d7c FA0FA0E3 		mov	r0, #1000
 7063 3d80 FEFFFFEB 		bl	_tx_thread_sleep
 7064 3d84 F9FFFFEA 		b	.L521
 7065              	.LVL581:
 7066              	.L586:
 7067              	.LBE253:
 7068              	.LBE252:
1927:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7069              		.loc 1 1927 0
 7070 3d88 0400A0E3 		mov	r0, #4
 7071              	.LVL582:
 7072 3d8c F4129FE5 		ldr	r1, .L608+204
 7073 3d90 FEFFFFEB 		bl	CyU3PDebugPrint
 7074              	.LVL583:
 7075              	.L519:
 7076              	.LBB254:
 7077              	.LBB255:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7078              		.loc 1 1313 0
 7079 3d94 9C129FE5 		ldr	r1, .L608+124
 7080 3d98 0400A0E3 		mov	r0, #4
 7081 3d9c FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7082              		.loc 1 1314 0
 7083 3da0 FA0FA0E3 		mov	r0, #1000
 7084 3da4 FEFFFFEB 		bl	_tx_thread_sleep
 7085 3da8 F9FFFFEA 		b	.L519
 7086              	.LVL584:
 7087              	.L588:
 7088              	.LBE255:
 7089              	.LBE254:
1954:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7090              		.loc 1 1954 0
 7091 3dac 0400A0E3 		mov	r0, #4
 7092              	.LVL585:
 7093 3db0 D4129FE5 		ldr	r1, .L608+208
 7094 3db4 FEFFFFEB 		bl	CyU3PDebugPrint
 7095              	.LVL586:
 7096              	.L523:
 7097              	.LBB256:
 7098              	.LBB257:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7099              		.loc 1 1313 0
 7100 3db8 78129FE5 		ldr	r1, .L608+124
 7101 3dbc 0400A0E3 		mov	r0, #4
 7102 3dc0 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7103              		.loc 1 1314 0
 7104 3dc4 FA0FA0E3 		mov	r0, #1000
 7105 3dc8 FEFFFFEB 		bl	_tx_thread_sleep
 7106 3dcc F9FFFFEA 		b	.L523
 7107              	.LVL587:
 7108              	.L597:
 7109              	.LBE257:
 7110              	.LBE256:
 7111              	.LBE259:
 7112              	.LBE275:
2391:../uvc.c      ****                 prodCount = 0;
 7113              		.loc 1 2391 0
 7114 3dd0 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2406:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7115              		.loc 1 2406 0
 7116 3dd4 40029FE5 		ldr	r0, .L608+96
2392:../uvc.c      ****                 consCount = 0;
 7117              		.loc 1 2392 0
 7118 3dd8 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2406:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7119              		.loc 1 2406 0
 7120 3ddc 0010E0E3 		mvn	r1, #0
2388:../uvc.c      ****             	fb=0;
 7121              		.loc 1 2388 0
 7122 3de0 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2389:../uvc.c      ****             	pb=0;
 7123              		.loc 1 2389 0
 7124 3de4 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2390:../uvc.c      ****             	pbc=0;
 7125              		.loc 1 2390 0
 7126 3de8 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2393:../uvc.c      ****                 hitFV     = CyFalse;
 7127              		.loc 1 2393 0
 7128 3dec 3C6085E5 		str	r6, [r5, #60]
2406:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7129              		.loc 1 2406 0
 7130 3df0 FEFFFFEB 		bl	_txe_mutex_get
2407:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7131              		.loc 1 2407 0
 7132 3df4 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7133 3df8 012020E2 		eor	r2, r0, #1
 7134 3dfc 8124C7E5 		strb	r2, [r7, #1153]
2409:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7135              		.loc 1 2409 0
 7136 3e00 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7137 3e04 F0005CE3 		cmp	ip, #240
 7138 3e08 1800000A 		beq	.L603
 7139              	.L546:
2417:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7140              		.loc 1 2417 0
 7141 3e0c 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7142 3e10 FF005AE3 		cmp	sl, #255
 7143 3e14 5C00000A 		beq	.L604
2429:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7144              		.loc 1 2429 0
 7145 3e18 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7146 3e1c AA0050E3 		cmp	r0, #170
 7147 3e20 2F00000A 		beq	.L605
 7148              	.L547:
2462:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7149              		.loc 1 2462 0
 7150 3e24 F0019FE5 		ldr	r0, .L608+96
 7151 3e28 FEFFFFEB 		bl	_txe_mutex_put
2464:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7152              		.loc 1 2464 0
 7153 3e2c F8019FE5 		ldr	r0, .L608+112
 7154 3e30 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7155              	.LVL588:
2465:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7156              		.loc 1 2465 0
 7157 3e34 002050E2 		subs	r2, r0, #0
 7158 3e38 2000001A 		bne	.L606
2472:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7159              		.loc 1 2472 0
 7160 3e3c 0210A0E1 		mov	r1, r2
 7161 3e40 E4019FE5 		ldr	r0, .L608+112
 7162              	.LVL589:
 7163 3e44 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7164              	.LVL590:
2473:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7165              		.loc 1 2473 0
 7166 3e48 002050E2 		subs	r2, r0, #0
 7167 3e4c 1200001A 		bne	.L607
2481:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7168              		.loc 1 2481 0
 7169 3e50 C8019FE5 		ldr	r0, .L608+100
 7170              	.LVL591:
 7171 3e54 0210A0E1 		mov	r1, r2
 7172 3e58 02A0A0E3 		mov	sl, #2
 7173 3e5c 0020A0E1 		mov	r2, r0
 7174              	.LVL592:
 7175 3e60 0130A0E1 		mov	r3, r1
 7176 3e64 00A08DE5 		str	sl, [sp, #0]
 7177 3e68 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7178              	.LVL593:
 7179 3e6c C4FEFFEA 		b	.L545
 7180              	.L603:
2409:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7181              		.loc 1 2409 0 discriminator 1
 7182 3e70 58019FE5 		ldr	r0, .L608+20
 7183 3e74 8010A0E3 		mov	r1, #128
 7184 3e78 0320A0E3 		mov	r2, #3
 7185 3e7c B4308DE2 		add	r3, sp, #180
 7186 3e80 00608DE5 		str	r6, [sp, #0]
 7187 3e84 FEFFFFEB 		bl	_txe_event_flags_get
 7188 3e88 000050E3 		cmp	r0, #0
2414:../uvc.c      ****                 		stiflag = 0xFF;
 7189              		.loc 1 2414 0 discriminator 1
 7190 3e8c 3A80C505 		streqb	r8, [r5, #58]
2415:../uvc.c      ****                 		IMcount = 0;
 7191              		.loc 1 2415 0 discriminator 1
 7192 3e90 A160C505 		streqb	r6, [r5, #161]
2409:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7193              		.loc 1 2409 0 discriminator 1
 7194 3e94 E2FFFF0A 		beq	.L547
 7195 3e98 DBFFFFEA 		b	.L546
 7196              	.LVL594:
 7197              	.L607:
2475:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7198              		.loc 1 2475 0
 7199 3e9c 0400A0E3 		mov	r0, #4
 7200              	.LVL595:
 7201 3ea0 E8119FE5 		ldr	r1, .L608+212
 7202 3ea4 FEFFFFEB 		bl	CyU3PDebugPrint
 7203              	.LVL596:
 7204              	.L559:
 7205              	.LBB276:
 7206              	.LBB277:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7207              		.loc 1 1313 0
 7208 3ea8 88119FE5 		ldr	r1, .L608+124
 7209 3eac 0400A0E3 		mov	r0, #4
 7210 3eb0 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7211              		.loc 1 1314 0
 7212 3eb4 FA0FA0E3 		mov	r0, #1000
 7213 3eb8 FEFFFFEB 		bl	_tx_thread_sleep
 7214 3ebc F9FFFFEA 		b	.L559
 7215              	.LVL597:
 7216              	.L606:
 7217              	.LBE277:
 7218              	.LBE276:
2467:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7219              		.loc 1 2467 0
 7220 3ec0 0400A0E3 		mov	r0, #4
 7221              	.LVL598:
 7222 3ec4 C8119FE5 		ldr	r1, .L608+216
 7223 3ec8 FEFFFFEB 		bl	CyU3PDebugPrint
 7224              	.LVL599:
 7225              	.L557:
 7226              	.LBB278:
 7227              	.LBB279:
1313:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7228              		.loc 1 1313 0
 7229 3ecc 64119FE5 		ldr	r1, .L608+124
 7230 3ed0 0400A0E3 		mov	r0, #4
 7231 3ed4 FEFFFFEB 		bl	CyU3PDebugPrint
1314:../uvc.c      ****         CyU3PThreadSleep (1000);
 7232              		.loc 1 1314 0
 7233 3ed8 FA0FA0E3 		mov	r0, #1000
 7234 3edc FEFFFFEB 		bl	_tx_thread_sleep
 7235 3ee0 F9FFFFEA 		b	.L557
 7236              	.L605:
 7237              	.LBE279:
 7238              	.LBE278:
2435:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 7239              		.loc 1 2435 0
 7240 3ee4 A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 7241 3ee8 01A08EE2 		add	sl, lr, #1
 7242 3eec 02005EE3 		cmp	lr, #2
 7243 3ef0 A1A0C5E5 		strb	sl, [r5, #161]
 7244 3ef4 CAFFFF9A 		bls	.L547
2437:../uvc.c      ****                     switch (setRes)
 7245              		.loc 1 2437 0
 7246 3ef8 7D00D5E5 		ldrb	r0, [r5, #125]	@ zero_extendqisi2
 7247 3efc 020050E3 		cmp	r0, #2
 7248 3f00 1800000A 		beq	.L551
 7249 3f04 030050E3 		cmp	r0, #3
 7250 3f08 0B00000A 		beq	.L552
 7251 3f0c 010050E3 		cmp	r0, #1
 7252 3f10 0600001A 		bne	.L549
2440:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 7253              		.loc 1 2440 0
 7254 3f14 582095E5 		ldr	r2, [r5, #88]
 7255 3f18 3010A0E3 		mov	r1, #48
 7256 3f1c 000052E3 		cmp	r2, #0
 7257 3f20 E420A003 		moveq	r2, #228
 7258 3f24 6420A013 		movne	r2, #100
 7259 3f28 5230A0E3 		mov	r3, #82
 7260 3f2c FEFFFFEB 		bl	SensorSetIrisControl
 7261              	.L549:
2457:../uvc.c      ****                     IMcount = 0;
 7262              		.loc 1 2457 0
 7263 3f30 A160C4E5 		strb	r6, [r4, #161]
2459:../uvc.c      ****                 	stiflag = 0x0;
 7264              		.loc 1 2459 0
 7265 3f34 3A60C4E5 		strb	r6, [r4, #58]
 7266 3f38 B9FFFFEA 		b	.L547
 7267              	.L552:
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 7268              		.loc 1 2450 0
 7269 3f3c 58C095E5 		ldr	ip, [r5, #88]
 7270 3f40 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 7271 3f44 00005CE3 		cmp	ip, #0
 7272 3f48 C4C0A003 		moveq	ip, #196
 7273 3f4c 44C0A013 		movne	ip, #68
 7274 3f50 03208CE1 		orr	r2, ip, r3
 7275 3f54 3010A0E3 		mov	r1, #48
 7276 3f58 5230A0E3 		mov	r3, #82
 7277 3f5c 0100A0E3 		mov	r0, #1
 7278 3f60 FEFFFFEB 		bl	SensorSetIrisControl
2453:../uvc.c      ****                  		break;
 7279              		.loc 1 2453 0
 7280 3f64 F1FFFFEA 		b	.L549
 7281              	.L551:
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 7282              		.loc 1 2445 0
 7283 3f68 582095E5 		ldr	r2, [r5, #88]
 7284 3f6c 3010A0E3 		mov	r1, #48
 7285 3f70 000052E3 		cmp	r2, #0
 7286 3f74 D420A003 		moveq	r2, #212
 7287 3f78 5420A013 		movne	r2, #84
 7288 3f7c 5230A0E3 		mov	r3, #82
 7289 3f80 0100A0E3 		mov	r0, #1
 7290 3f84 FEFFFFEB 		bl	SensorSetIrisControl
2448:../uvc.c      ****                  		break;
 7291              		.loc 1 2448 0
 7292 3f88 E8FFFFEA 		b	.L549
 7293              	.L604:
2419:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 7294              		.loc 1 2419 0
 7295 3f8c A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 7296 3f90 01E081E2 		add	lr, r1, #1
 7297 3f94 020051E3 		cmp	r1, #2
 7298 3f98 A1E0C5E5 		strb	lr, [r5, #161]
 7299 3f9c A0FFFF9A 		bls	.L547
2420:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7300              		.loc 1 2420 0
 7301 3fa0 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2421:../uvc.c      ****                 		stiflag = 0x0F;
 7302              		.loc 1 2421 0
 7303 3fa4 0F30A0E3 		mov	r3, #15
2420:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7304              		.loc 1 2420 0
 7305 3fa8 20C082E3 		orr	ip, r2, #32
 7306 3fac 81C4C7E5 		strb	ip, [r7, #1153]
2422:../uvc.c      ****                 		IMcount = 0;
 7307              		.loc 1 2422 0
 7308 3fb0 A160C5E5 		strb	r6, [r5, #161]
2421:../uvc.c      ****                 		stiflag = 0x0F;
 7309              		.loc 1 2421 0
 7310 3fb4 3A30C5E5 		strb	r3, [r5, #58]
 7311 3fb8 99FFFFEA 		b	.L547
 7312              	.L609:
 7313              		.align	2
 7314              	.L608:
 7315 3fbc C0060000 		.word	.LC37
 7316 3fc0 00C20100 		.word	115200
 7317 3fc4 E0060000 		.word	.LC38
 7318 3fc8 A0860100 		.word	100000
 7319 3fcc FC060000 		.word	.LC39
 7320 3fd0 00000000 		.word	.LANCHOR0
 7321 3fd4 00000000 		.word	CyFxGpifCB
 7322 3fd8 88130000 		.word	5000
 7323 3fdc 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7324 3fe0 00000000 		.word	CyFxUVCApplnUSBEventCB
 7325 3fe4 00000000 		.word	CyFxUSBDeviceDscr
 7326 3fe8 00000000 		.word	CyFxUSBDeviceDscrSS
 7327 3fec 00000000 		.word	CyFxUSBDeviceQualDscr
 7328 3ff0 00000000 		.word	CyFxUSBBOSDscr
 7329 3ff4 00000000 		.word	CyFxUSBHSConfigDscr
 7330 3ff8 00000000 		.word	CyFxUSBFSConfigDscr
 7331 3ffc 00000000 		.word	CyFxUSBSSConfigDscr
 7332 4000 00000000 		.word	CyFxUSBStringLangIDDscr
 7333 4004 00000000 		.word	CyFxUSBManufactureDscr
 7334 4008 00000000 		.word	CyFxUSBProductDscr
 7335 400c 013F0000 		.word	16129
 7336 4010 02030000 		.word	770
 7337 4014 00000000 		.word	glChHandleInterStat
 7338 4018 00000000 		.word	glInterStaBuffer
 7339 401c 00000000 		.word	imgHdMux
 7340 4020 01010000 		.word	257
 7341 4024 03030000 		.word	771
 7342 4028 00000000 		.word	CyFxUvcApplnDmaCallback
 7343 402c 00000000 		.word	glChHandleUVCStream
 7344 4030 00000000 		.word	.LANCHOR1
 7345 4034 18070000 		.word	.LC40
 7346 4038 D8010000 		.word	.LC12
 7347 403c 68070000 		.word	.LC42
 7348 4040 44070000 		.word	.LC41
 7349 4044 90070000 		.word	.LC43
 7350 4048 E8080000 		.word	.LC50
 7351 404c C4090000 		.word	.LC54
 7352 4050 94090000 		.word	.LC53
 7353 4054 5C090000 		.word	.LC52
 7354 4058 1C090000 		.word	.LC51
 7355 405c 900A0000 		.word	.LC59
 7356 4060 2C000000 		.word	.LANCHOR2+44
 7357 4064 D80A0000 		.word	.LC61
 7358 4068 800A0000 		.word	.LC58
 7359 406c 10000000 		.word	.LANCHOR2+16
 7360 4070 A00A0000 		.word	.LC60
 7361 4074 4C0A0000 		.word	.LC57
 7362 4078 B8080000 		.word	.LC49
 7363 407c 88080000 		.word	.LC48
 7364 4080 50080000 		.word	.LC47
 7365 4084 E8070000 		.word	.LC45
 7366 4088 BC070000 		.word	.LC44
 7367 408c 1C080000 		.word	.LC46
 7368 4090 180A0000 		.word	.LC56
 7369 4094 EC090000 		.word	.LC55
 7370              		.cfi_endproc
 7371              	.LFE18:
 7373              		.align	2
 7374              		.global	CyFxApplicationDefine
 7376              	CyFxApplicationDefine:
 7377              	.LFB26:
3871:../uvc.c      **** }
3872:../uvc.c      **** 
3873:../uvc.c      **** 
3874:../uvc.c      **** /*
3875:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3876:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3877:../uvc.c      ****  */
3878:../uvc.c      **** void
3879:../uvc.c      **** CyFxApplicationDefine (
3880:../uvc.c      ****         void)
3881:../uvc.c      **** {
 7378              		.loc 1 3881 0
 7379              		.cfi_startproc
 7380              		@ args = 0, pretend = 0, frame = 40
 7381              		@ frame_needed = 0, uses_anonymous_args = 0
 7382              	.LVL600:
 7383 4098 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7384              	.LCFI25:
 7385              		.cfi_def_cfa_offset 36
3882:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3883:../uvc.c      ****     uint32_t retThrdCreate;
3884:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3885:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3886:../uvc.c      **** 
3887:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3888:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7386              		.loc 1 3888 0
 7387 409c 010AA0E3 		mov	r0, #4096
3881:../uvc.c      **** {
 7388              		.loc 1 3881 0
 7389 40a0 4CD04DE2 		sub	sp, sp, #76
 7390              	.LCFI26:
 7391              		.cfi_def_cfa_offset 112
 7392              		.loc 1 3888 0
 7393              		.cfi_offset 14, -4
 7394              		.cfi_offset 11, -8
 7395              		.cfi_offset 10, -12
 7396              		.cfi_offset 9, -16
 7397              		.cfi_offset 8, -20
 7398              		.cfi_offset 7, -24
 7399              		.cfi_offset 6, -28
 7400              		.cfi_offset 5, -32
 7401              		.cfi_offset 4, -36
 7402 40a4 FEFFFFEB 		bl	CyU3PMemAlloc
 7403 40a8 00A0A0E1 		mov	sl, r0
 7404              	.LVL601:
3889:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7405              		.loc 1 3889 0
 7406 40ac 010AA0E3 		mov	r0, #4096
 7407              	.LVL602:
 7408 40b0 FEFFFFEB 		bl	CyU3PMemAlloc
 7409 40b4 00B0A0E1 		mov	fp, r0
 7410              	.LVL603:
3890:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7411              		.loc 1 3890 0
 7412 40b8 010AA0E3 		mov	r0, #4096
 7413              	.LVL604:
 7414 40bc FEFFFFEB 		bl	CyU3PMemAlloc
3891:../uvc.c      **** 
3892:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7415              		.loc 1 3892 0
 7416 40c0 00005AE3 		cmp	sl, #0
 7417 40c4 00005B13 		cmpne	fp, #0
 7418 40c8 0090A013 		movne	r9, #0
 7419 40cc 0190A003 		moveq	r9, #1
3890:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7420              		.loc 1 3890 0
 7421 40d0 24008DE5 		str	r0, [sp, #36]
 7422              	.LVL605:
 7423              		.loc 1 3892 0
 7424 40d4 0000001A 		bne	.L614
 7425              	.LVL606:
 7426              	.L611:
 7427              	.L613:
 7428 40d8 FEFFFFEA 		b	.L613
 7429              	.L614:
 7430              		.loc 1 3892 0 is_stmt 0 discriminator 1
 7431 40dc 000050E3 		cmp	r0, #0
 7432 40e0 FCFFFF0A 		beq	.L611
3893:../uvc.c      ****         goto fatalErrorHandler;
3894:../uvc.c      **** 
3895:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3896:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7433              		.loc 1 3896 0 is_stmt 1
 7434 40e4 28408DE2 		add	r4, sp, #40
 7435 40e8 0400A0E1 		mov	r0, r4
 7436 40ec 4010A0E3 		mov	r1, #64
 7437 40f0 18219FE5 		ldr	r2, .L615
 7438 40f4 FEFFFFEB 		bl	cmdbufCreate
 7439 40f8 0450A0E1 		mov	r5, r4
 7440 40fc 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7441 4100 0C719FE5 		ldr	r7, .L615+4
3897:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7442              		.loc 1 3897 0
 7443 4104 0C819FE5 		ldr	r8, .L615+8
3896:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7444              		.loc 1 3896 0
 7445 4108 07C0A0E1 		mov	ip, r7
 7446 410c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7447 4110 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3898:../uvc.c      **** 
3899:../uvc.c      **** 	/****** initialize command descriptor ***********/
3900:../uvc.c      **** 	cmdquInit(cmdQuptr);
3901:../uvc.c      **** 	cmdquInit(statQuptr);
3902:../uvc.c      **** 
3903:../uvc.c      ****     /* Create the UVC application thread. */
3904:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7448              		.loc 1 3904 0
 7449 4114 0860A0E3 		mov	r6, #8
3896:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7450              		.loc 1 3896 0
 7451 4118 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3897:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7452              		.loc 1 3897 0
 7453 411c F8209FE5 		ldr	r2, .L615+12
 7454 4120 0400A0E1 		mov	r0, r4
 7455 4124 2010A0E3 		mov	r1, #32
 7456 4128 FEFFFFEB 		bl	cmdbufCreate
 7457 412c 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7458 4130 08C0A0E1 		mov	ip, r8
 7459 4134 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7460 4138 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7461              		.loc 1 3904 0
 7462 413c 0140A0E3 		mov	r4, #1
3897:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7463              		.loc 1 3897 0
 7464 4140 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3900:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7465              		.loc 1 3900 0
 7466 4144 0700A0E1 		mov	r0, r7
 7467 4148 FEFFFFEB 		bl	cmdquInit
3901:../uvc.c      **** 	cmdquInit(statQuptr);
 7468              		.loc 1 3901 0
 7469 414c 0800A0E1 		mov	r0, r8
 7470 4150 FEFFFFEB 		bl	cmdquInit
 7471              		.loc 1 3904 0
 7472 4154 A850A0E3 		mov	r5, #168
 7473 4158 01CAA0E3 		mov	ip, #4096
 7474 415c BC009FE5 		ldr	r0, .L615+16
 7475 4160 BC109FE5 		ldr	r1, .L615+20
 7476 4164 BC209FE5 		ldr	r2, .L615+24
 7477 4168 0930A0E1 		mov	r3, r9
 7478 416c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7479 4170 08608DE5 		str	r6, [sp, #8]
 7480 4174 0C608DE5 		str	r6, [sp, #12]
 7481 4178 10908DE5 		str	r9, [sp, #16]
 7482 417c 14408DE5 		str	r4, [sp, #20]
 7483 4180 18508DE5 		str	r5, [sp, #24]
 7484 4184 FEFFFFEB 		bl	_txe_thread_create
 7485              	.LVL607:
3905:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3906:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3907:../uvc.c      ****             0,                                          /* No input parameter to thread */
3908:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3909:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3910:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3911:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3912:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3913:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3914:../uvc.c      ****             );
3915:../uvc.c      ****     if (retThrdCreate != 0)
 7486              		.loc 1 3915 0
 7487 4188 00C050E2 		subs	ip, r0, #0
 7488 418c D1FFFF1A 		bne	.L611
3916:../uvc.c      ****     {
3917:../uvc.c      ****         goto fatalErrorHandler;
3918:../uvc.c      ****     }
3919:../uvc.c      **** 
3920:../uvc.c      ****     /* Create the control request handling thread. */
3921:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7489              		.loc 1 3921 0
 7490 4190 0C30A0E1 		mov	r3, ip
 7491 4194 027BA0E3 		mov	r7, #2048
 7492 4198 8C009FE5 		ldr	r0, .L615+28
 7493              	.LVL608:
 7494 419c 8C109FE5 		ldr	r1, .L615+32
 7495 41a0 8C209FE5 		ldr	r2, .L615+36
 7496 41a4 10C08DE5 		str	ip, [sp, #16]
 7497 41a8 00B08DE5 		str	fp, [sp, #0]
 7498 41ac 04708DE5 		str	r7, [sp, #4]
 7499 41b0 08608DE5 		str	r6, [sp, #8]
 7500 41b4 0C608DE5 		str	r6, [sp, #12]
 7501 41b8 14408DE5 		str	r4, [sp, #20]
 7502 41bc 18508DE5 		str	r5, [sp, #24]
 7503 41c0 FEFFFFEB 		bl	_txe_thread_create
 7504              	.LVL609:
3922:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3923:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3924:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3925:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3926:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3927:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3928:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3929:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3930:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3931:../uvc.c      ****             );
3932:../uvc.c      ****     if (retThrdCreate != 0)
 7505              		.loc 1 3932 0
 7506 41c4 00C050E2 		subs	ip, r0, #0
 7507 41c8 C2FFFF1A 		bne	.L611
3933:../uvc.c      ****     {
3934:../uvc.c      ****         goto fatalErrorHandler;
3935:../uvc.c      ****     }
3936:../uvc.c      **** #if 1
3937:../uvc.c      ****     /* Create the I2C control command handling thread. */
3938:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7508              		.loc 1 3938 0
 7509 41cc 24E09DE5 		ldr	lr, [sp, #36]
 7510 41d0 60009FE5 		ldr	r0, .L615+40
 7511              	.LVL610:
 7512 41d4 60109FE5 		ldr	r1, .L615+44
 7513 41d8 60209FE5 		ldr	r2, .L615+48
 7514 41dc 0C30A0E1 		mov	r3, ip
 7515 41e0 00E08DE5 		str	lr, [sp, #0]
 7516 41e4 04708DE5 		str	r7, [sp, #4]
 7517 41e8 08608DE5 		str	r6, [sp, #8]
 7518 41ec 0C608DE5 		str	r6, [sp, #12]
 7519 41f0 10C08DE5 		str	ip, [sp, #16]
 7520 41f4 14408DE5 		str	r4, [sp, #20]
 7521 41f8 18508DE5 		str	r5, [sp, #24]
 7522 41fc FEFFFFEB 		bl	_txe_thread_create
 7523              	.LVL611:
3939:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3940:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3941:../uvc.c      ****             0,                                          /* No input parameter to thread */
3942:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3943:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3944:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3945:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3946:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3947:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3948:../uvc.c      ****             );
3949:../uvc.c      ****     if (retThrdCreate != 0)
 7524              		.loc 1 3949 0
 7525 4200 000050E3 		cmp	r0, #0
 7526 4204 B3FFFF1A 		bne	.L611
3950:../uvc.c      ****     {
3951:../uvc.c      ****         goto fatalErrorHandler;
3952:../uvc.c      ****     }
3953:../uvc.c      **** #endif
3954:../uvc.c      **** 
3955:../uvc.c      ****     return;
3956:../uvc.c      **** 
3957:../uvc.c      **** fatalErrorHandler:
3958:../uvc.c      ****     /* Add custom recovery or debug actions here */
3959:../uvc.c      ****     /* Loop indefinitely */
3960:../uvc.c      ****     while (1);
3961:../uvc.c      **** }
 7527              		.loc 1 3961 0
 7528 4208 4CD08DE2 		add	sp, sp, #76
 7529 420c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7530              	.L616:
 7531              		.align	2
 7532              	.L615:
 7533 4210 00000000 		.word	cmdQuMux
 7534 4214 00000000 		.word	cmdQu
 7535 4218 00000000 		.word	statQu
 7536 421c 00000000 		.word	staQuMux
 7537 4220 A4000000 		.word	.LANCHOR0+164
 7538 4224 100B0000 		.word	.LC62
 7539 4228 00000000 		.word	UVCAppThread_Entry
 7540 422c 4C010000 		.word	.LANCHOR0+332
 7541 4230 240B0000 		.word	.LC63
 7542 4234 00000000 		.word	UVCAppEP0Thread_Entry
 7543 4238 F4010000 		.word	.LANCHOR0+500
 7544 423c 3C0B0000 		.word	.LC64
 7545 4240 00000000 		.word	I2cAppThread_Entry
 7546              		.cfi_endproc
 7547              	.LFE26:
 7549              		.align	2
 7550              		.global	main
 7552              	main:
 7553              	.LFB27:
3962:../uvc.c      **** 
3963:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3964:../uvc.c      ****  * the ThreadX RTOS here.
3965:../uvc.c      ****  */
3966:../uvc.c      **** int
3967:../uvc.c      **** main (
3968:../uvc.c      ****         void)
3969:../uvc.c      **** {
 7554              		.loc 1 3969 0
 7555              		.cfi_startproc
 7556              		@ args = 0, pretend = 0, frame = 56
 7557              		@ frame_needed = 0, uses_anonymous_args = 0
 7558 4244 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7559              	.LCFI27:
 7560              		.cfi_def_cfa_offset 12
3970:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3971:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3972:../uvc.c      **** 
3973:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3974:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3975:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3976:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3977:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3978:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7561              		.loc 1 3978 0
 7562 4248 0010A0E3 		mov	r1, #0
3969:../uvc.c      **** {
 7563              		.loc 1 3969 0
 7564 424c 3CD04DE2 		sub	sp, sp, #60
 7565              	.LCFI28:
 7566              		.cfi_def_cfa_offset 72
3975:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7567              		.loc 1 3975 0
 7568 4250 0220A0E3 		mov	r2, #2
3979:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7569              		.loc 1 3979 0
 7570 4254 033081E2 		add	r3, r1, #3
3974:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7571              		.loc 1 3974 0
 7572 4258 0150A0E3 		mov	r5, #1
 7573              		.cfi_offset 14, -4
 7574              		.cfi_offset 5, -8
 7575              		.cfi_offset 4, -12
3980:../uvc.c      **** 
3981:../uvc.c      ****     /* Initialize the device */
3982:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7576              		.loc 1 3982 0
 7577 425c 28008DE2 		add	r0, sp, #40
3974:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7578              		.loc 1 3974 0
 7579 4260 28508DE5 		str	r5, [sp, #40]
3975:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7580              		.loc 1 3975 0
 7581 4264 2C20CDE5 		strb	r2, [sp, #44]
3976:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7582              		.loc 1 3976 0
 7583 4268 2D20CDE5 		strb	r2, [sp, #45]
3977:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7584              		.loc 1 3977 0
 7585 426c 2E20CDE5 		strb	r2, [sp, #46]
3978:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7586              		.loc 1 3978 0
 7587 4270 30108DE5 		str	r1, [sp, #48]
3979:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7588              		.loc 1 3979 0
 7589 4274 3430CDE5 		strb	r3, [sp, #52]
 7590              		.loc 1 3982 0
 7591 4278 FEFFFFEB 		bl	CyU3PDeviceInit
 7592              	.LVL612:
3983:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7593              		.loc 1 3983 0
 7594 427c 004050E2 		subs	r4, r0, #0
 7595 4280 0000000A 		beq	.L620
 7596              	.L618:
 7597              	.L619:
 7598 4284 FEFFFFEA 		b	.L619
 7599              	.L620:
3984:../uvc.c      ****     {
3985:../uvc.c      ****         goto handle_fatal_error;
3986:../uvc.c      ****     }
3987:../uvc.c      **** 
3988:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3989:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7600              		.loc 1 3989 0
 7601 4288 0410A0E1 		mov	r1, r4
 7602 428c 0420A0E1 		mov	r2, r4
 7603 4290 0500A0E1 		mov	r0, r5
 7604              	.LVL613:
 7605 4294 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7606              	.LVL614:
3990:../uvc.c      **** 
3991:../uvc.c      ****     /* Configure the IO matrix for the device. */
3992:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3993:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3994:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3995:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3996:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3997:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3998:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3999:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4000:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4001:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4002:../uvc.c      **** 
4003:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7607              		.loc 1 4003 0
 7608 4298 0D00A0E1 		mov	r0, sp
3993:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7609              		.loc 1 3993 0
 7610 429c 1640CDE5 		strb	r4, [sp, #22]
3994:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7611              		.loc 1 3994 0
 7612 42a0 18408DE5 		str	r4, [sp, #24]
3995:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7613              		.loc 1 3995 0
 7614 42a4 1C408DE5 		str	r4, [sp, #28]
3996:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7615              		.loc 1 3996 0
 7616 42a8 20408DE5 		str	r4, [sp, #32]
3997:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7617              		.loc 1 3997 0
 7618 42ac 24408DE5 		str	r4, [sp, #36]
4000:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7619              		.loc 1 4000 0
 7620 42b0 0C408DE5 		str	r4, [sp, #12]
4001:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7621              		.loc 1 4001 0
 7622 42b4 10408DE5 		str	r4, [sp, #16]
3992:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7623              		.loc 1 3992 0
 7624 42b8 00508DE5 		str	r5, [sp, #0]
3998:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7625              		.loc 1 3998 0
 7626 42bc 04508DE5 		str	r5, [sp, #4]
3999:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7627              		.loc 1 3999 0
 7628 42c0 08508DE5 		str	r5, [sp, #8]
 7629              		.loc 1 4003 0
 7630 42c4 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7631              	.LVL615:
4004:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7632              		.loc 1 4004 0
 7633 42c8 004050E2 		subs	r4, r0, #0
 7634 42cc ECFFFF1A 		bne	.L618
4005:../uvc.c      ****     {
4006:../uvc.c      ****         goto handle_fatal_error;
4007:../uvc.c      ****     }
4008:../uvc.c      **** 
4009:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4010:../uvc.c      ****     CyU3PKernelEntry ();
 7635              		.loc 1 4010 0
 7636 42d0 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7637              	.LVL616:
4011:../uvc.c      **** 
4012:../uvc.c      ****     /* Dummy return to make the compiler happy */
4013:../uvc.c      ****     return 0;
4014:../uvc.c      **** 
4015:../uvc.c      **** handle_fatal_error:
4016:../uvc.c      ****     /* Cannot recover from this error. */
4017:../uvc.c      ****     while (1);
4018:../uvc.c      **** }
 7638              		.loc 1 4018 0
 7639 42d4 0400A0E1 		mov	r0, r4
 7640 42d8 3CD08DE2 		add	sp, sp, #60
 7641 42dc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7642              		.cfi_endproc
 7643              	.LFE27:
 7645              		.global	CyFxGpifTransition
 7646              		.global	CyFxGpifWavedata
 7647              		.global	CyFxGpifWavedataPosition
 7648              		.global	CyFxGpifRegValue
 7649              		.global	CyFxGpifConfig
 7650              		.global	CyFxGpifTransition_usb2
 7651              		.global	CyFxGpifWavedata_usb2
 7652              		.global	CyFxGpifWavedataPosition_usb2
 7653              		.global	CyFxGpifRegValue_usb2
 7654              		.global	CyFxGpifConfig_usb2
 7655              		.global	snapButFlag
 7656              		.global	testSnap
 7657              		.global	fb
 7658              		.global	pb
 7659              		.global	pbc
 7660              		.global	fbbak
 7661              		.global	pbbak
 7662              		.global	pbcbak
 7663              		.global	pbcpbak
 7664              		.global	isUsbConnected
 7665              		.global	usbSpeed
 7666              		.global	clearFeatureRqtReceived
 7667              		.global	streamingStarted
 7668              		.global	glProbeCtrl
 7669              		.global	glProbeCtrlFull
 7670              		.global	glProbeStilCtrl
 7671              		.global	glProbeCtrl20
 7672              		.global	glProbeStilCtrl20
 7673              		.global	glUVCHeader
 7674              		.comm	glChHandleUVCStream,220,4
 7675              		.comm	glChHandleStillStream,220,4
 7676              		.comm	glChHandleInterStat,160,4
 7677              		.comm	glInterStaBuffer,4,4
 7678              		.comm	cmdQu,32,4
 7679              		.comm	statQu,32,4
 7680              		.comm	cmdQuMux,56,4
 7681              		.comm	staQuMux,56,4
 7682              		.comm	timMux,56,4
 7683              		.comm	imgHdMux,56,4
 7684              		.comm	bmReqType,1,1
 7685              		.comm	bRequest,1,1
 7686              		.comm	wValue,2,2
 7687              		.comm	wIndex,2,2
 7688              		.comm	wLength,2,2
 7689              		.comm	posTick,4,4
 7690              		.comm	I2CCmdTimer,44,4
 7691              		.section	.rodata
 7692              		.align	2
 7693              		.set	.LANCHOR2,. + 0
 7696              	ExTime:
 7697 0000 9C       		.byte	-100
 7698 0001 00       		.byte	0
 7699 0002 4E       		.byte	78
 7700 0003 00       		.byte	0
 7701 0004 27       		.byte	39
 7702 0005 00       		.byte	0
 7703 0006 14       		.byte	20
 7704 0007 00       		.byte	0
 7705 0008 0A       		.byte	10
 7706 0009 00       		.byte	0
 7707 000a 05       		.byte	5
 7708 000b 00       		.byte	0
 7709 000c 02       		.byte	2
 7710 000d 00       		.byte	0
 7711 000e 01       		.byte	1
 7712 000f 00       		.byte	0
 7715              	CyFxGpifConfig:
 7716 0010 0F00     		.short	15
 7717 0012 0000     		.space	2
 7718 0014 00000000 		.word	CyFxGpifWavedata
 7719 0018 00000000 		.word	CyFxGpifWavedataPosition
 7720 001c 0500     		.short	5
 7721 001e 0000     		.space	2
 7722 0020 00000000 		.word	CyFxGpifTransition
 7723 0024 4C00     		.short	76
 7724 0026 0000     		.space	2
 7725 0028 00000000 		.word	CyFxGpifRegValue
 7728              	CyFxGpifConfig_usb2:
 7729 002c 9300     		.short	147
 7730 002e 0000     		.space	2
 7731 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7732 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7733 0038 0800     		.short	8
 7734 003a 0000     		.space	2
 7735 003c 00000000 		.word	CyFxGpifTransition_usb2
 7736 0040 4C00     		.short	76
 7737 0042 0000     		.space	2
 7738 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7739              		.data
 7740              		.align	2
 7741              		.set	.LANCHOR1,. + 0
 7744              	ExUCtrlParArry:
 7745 0000 13       		.byte	19
 7746 0001 14       		.byte	20
 7747 0002 02       		.byte	2
 7748 0003 01       		.byte	1
 7749 0004 00       		.byte	0
 7750 0005 03       		.byte	3
 7751 0006 00       		.byte	0
 7752 0007 01       		.byte	1
 7753 0008 00       		.byte	0
 7754 0009 03       		.byte	3
 7755 000a 00       		.byte	0
 7756 000b 23       		.byte	35
 7757 000c 37       		.byte	55
 7758 000d 23       		.byte	35
 7759 000e 37       		.byte	55
 7760 000f 30       		.byte	48
 7761 0010 01       		.byte	1
 7762 0011 00       		.byte	0
 7763 0012 00       		.byte	0
 7764 0013 00000000 		.space	5
 7764      00
 7765 0018 11       		.byte	17
 7766 0019 00       		.byte	0
 7767 001a 02       		.byte	2
 7768 001b 01       		.byte	1
 7769 001c 00       		.byte	0
 7770 001d 03       		.byte	3
 7771 001e 00       		.byte	0
 7772 001f 01       		.byte	1
 7773 0020 00       		.byte	0
 7774 0021 03       		.byte	3
 7775 0022 00       		.byte	0
 7776 0023 01       		.byte	1
 7777 0024 00       		.byte	0
 7778 0025 01       		.byte	1
 7779 0026 00       		.byte	0
 7780 0027 30       		.byte	48
 7781 0028 01       		.byte	1
 7782 0029 01       		.byte	1
 7783 002a 00       		.byte	0
 7784 002b 00000000 		.space	5
 7784      00
 7785 0030 17       		.byte	23
 7786 0031 00       		.byte	0
 7787 0032 01       		.byte	1
 7788 0033 01       		.byte	1
 7789 0034 00       		.byte	0
 7790 0035 02       		.byte	2
 7791 0036 00       		.byte	0
 7792 0037 01       		.byte	1
 7793 0038 00       		.byte	0
 7794 0039 03       		.byte	3
 7795 003a 00       		.byte	0
 7796 003b 00       		.byte	0
 7797 003c 00       		.byte	0
 7798 003d 00       		.byte	0
 7799 003e 00       		.byte	0
 7800 003f 30       		.byte	48
 7801 0040 01       		.byte	1
 7802 0041 01       		.byte	1
 7803 0042 00       		.byte	0
 7804 0043 00000000 		.space	5
 7804      00
 7805 0048 00       		.byte	0
 7806 0049 00       		.byte	0
 7807 004a 04       		.byte	4
 7808 004b 01       		.byte	1
 7809 004c 00       		.byte	0
 7810 004d 38       		.byte	56
 7811 004e 01       		.byte	1
 7812 004f 01       		.byte	1
 7813 0050 00       		.byte	0
 7814 0051 03       		.byte	3
 7815 0052 00       		.byte	0
 7816 0053 4E       		.byte	78
 7817 0054 00       		.byte	0
 7818 0055 4E       		.byte	78
 7819 0056 00       		.byte	0
 7820 0057 30       		.byte	48
 7821 0058 01       		.byte	1
 7822 0059 00       		.byte	0
 7823 005a 00       		.byte	0
 7824 005b 00000000 		.space	5
 7824      00
 7825 0060 00       		.byte	0
 7826 0061 00       		.byte	0
 7827 0062 01       		.byte	1
 7828 0063 00       		.byte	0
 7829 0064 00       		.byte	0
 7830 0065 00       		.byte	0
 7831 0066 00       		.byte	0
 7832 0067 01       		.byte	1
 7833 0068 00       		.byte	0
 7834 0069 03       		.byte	3
 7835 006a 00       		.byte	0
 7836 006b 00       		.byte	0
 7837 006c 00       		.byte	0
 7838 006d 00       		.byte	0
 7839 006e 00       		.byte	0
 7840 006f 30       		.byte	48
 7841 0070 01       		.byte	1
 7842 0071 00       		.byte	0
 7843 0072 00       		.byte	0
 7844 0073 00000000 		.space	5
 7844      00
 7845 0078 00       		.byte	0
 7846 0079 00       		.byte	0
 7847 007a 02       		.byte	2
 7848 007b 00       		.byte	0
 7849 007c 00       		.byte	0
 7850 007d FF       		.byte	-1
 7851 007e 00       		.byte	0
 7852 007f 01       		.byte	1
 7853 0080 00       		.byte	0
 7854 0081 03       		.byte	3
 7855 0082 00       		.byte	0
 7856 0083 01       		.byte	1
 7857 0084 00       		.byte	0
 7858 0085 00       		.byte	0
 7859 0086 00       		.byte	0
 7860 0087 30       		.byte	48
 7861 0088 01       		.byte	1
 7862 0089 01       		.byte	1
 7863 008a 00       		.byte	0
 7864 008b 00000000 		.space	5
 7864      00
 7865 0090 00       		.byte	0
 7866 0091 00       		.byte	0
 7867 0092 02       		.byte	2
 7868 0093 00       		.byte	0
 7869 0094 00       		.byte	0
 7870 0095 00       		.byte	0
 7871 0096 00       		.byte	0
 7872 0097 00       		.byte	0
 7873 0098 00       		.byte	0
 7874 0099 03       		.byte	3
 7875 009a 00       		.byte	0
 7876 009b 00       		.byte	0
 7877 009c 00       		.byte	0
 7878 009d 00       		.byte	0
 7879 009e 00       		.byte	0
 7880 009f 30       		.byte	48
 7881 00a0 01       		.byte	1
 7882 00a1 01       		.byte	1
 7883 00a2 00       		.byte	0
 7884 00a3 00000000 		.space	5
 7884      00
 7885 00a8 00       		.byte	0
 7886 00a9 00       		.byte	0
 7887 00aa 02       		.byte	2
 7888 00ab 00       		.byte	0
 7889 00ac 00       		.byte	0
 7890 00ad 30       		.byte	48
 7891 00ae 00       		.byte	0
 7892 00af 01       		.byte	1
 7893 00b0 00       		.byte	0
 7894 00b1 03       		.byte	3
 7895 00b2 0A       		.byte	10
 7896 00b3 00       		.byte	0
 7897 00b4 00       		.byte	0
 7898 00b5 0A       		.byte	10
 7899 00b6 00       		.byte	0
 7900 00b7 30       		.byte	48
 7901 00b8 01       		.byte	1
 7902 00b9 01       		.byte	1
 7903 00ba 00       		.byte	0
 7904 00bb 00000000 		.space	5
 7904      00
 7905 00c0 00       		.byte	0
 7906 00c1 00       		.byte	0
 7907 00c2 01       		.byte	1
 7908 00c3 00       		.byte	0
 7909 00c4 00       		.byte	0
 7910 00c5 7F       		.byte	127
 7911 00c6 00       		.byte	0
 7912 00c7 01       		.byte	1
 7913 00c8 00       		.byte	0
 7914 00c9 03       		.byte	3
 7915 00ca 00       		.byte	0
 7916 00cb 00       		.byte	0
 7917 00cc 00       		.byte	0
 7918 00cd 00       		.byte	0
 7919 00ce 00       		.byte	0
 7920 00cf 30       		.byte	48
 7921 00d0 01       		.byte	1
 7922 00d1 00       		.byte	0
 7923 00d2 00       		.byte	0
 7924 00d3 00000000 		.space	5
 7924      00
 7925 00d8 00       		.byte	0
 7926 00d9 00       		.byte	0
 7927 00da 02       		.byte	2
 7928 00db 00       		.byte	0
 7929 00dc 00       		.byte	0
 7930 00dd 05       		.byte	5
 7931 00de 00       		.byte	0
 7932 00df 01       		.byte	1
 7933 00e0 00       		.byte	0
 7934 00e1 03       		.byte	3
 7935 00e2 00       		.byte	0
 7936 00e3 00       		.byte	0
 7937 00e4 00       		.byte	0
 7938 00e5 00       		.byte	0
 7939 00e6 00       		.byte	0
 7940 00e7 30       		.byte	48
 7941 00e8 01       		.byte	1
 7942 00e9 00       		.byte	0
 7943 00ea 00       		.byte	0
 7944 00eb 00000000 		.space	5
 7944      00
 7945 00f0 00       		.byte	0
 7946 00f1 00       		.byte	0
 7947 00f2 03       		.byte	3
 7948 00f3 00       		.byte	0
 7949 00f4 00       		.byte	0
 7950 00f5 0A       		.byte	10
 7951 00f6 00       		.byte	0
 7952 00f7 01       		.byte	1
 7953 00f8 00       		.byte	0
 7954 00f9 03       		.byte	3
 7955 00fa 00       		.byte	0
 7956 00fb 00       		.byte	0
 7957 00fc 00       		.byte	0
 7958 00fd 00       		.byte	0
 7959 00fe 00       		.byte	0
 7960 00ff 30       		.byte	48
 7961 0100 01       		.byte	1
 7962 0101 00       		.byte	0
 7963 0102 00       		.byte	0
 7964 0103 00000000 		.space	5
 7964      00
 7965 0108 00       		.byte	0
 7966 0109 00       		.byte	0
 7967 010a 02       		.byte	2
 7968 010b 00       		.byte	0
 7969 010c 00       		.byte	0
 7970 010d 40       		.byte	64
 7971 010e 00       		.byte	0
 7972 010f 01       		.byte	1
 7973 0110 00       		.byte	0
 7974 0111 03       		.byte	3
 7975 0112 00       		.byte	0
 7976 0113 0F       		.byte	15
 7977 0114 11       		.byte	17
 7978 0115 00       		.byte	0
 7979 0116 00       		.byte	0
 7980 0117 30       		.byte	48
 7981 0118 01       		.byte	1
 7982 0119 00       		.byte	0
 7983 011a 00       		.byte	0
 7984 011b 00000000 		.space	5
 7984      00
 7985 0120 00       		.byte	0
 7986 0121 00       		.byte	0
 7987 0122 02       		.byte	2
 7988 0123 00       		.byte	0
 7989 0124 00       		.byte	0
 7990 0125 64       		.byte	100
 7991 0126 00       		.byte	0
 7992 0127 01       		.byte	1
 7993 0128 00       		.byte	0
 7994 0129 03       		.byte	3
 7995 012a 00       		.byte	0
 7996 012b 00       		.byte	0
 7997 012c 00       		.byte	0
 7998 012d 00       		.byte	0
 7999 012e 00       		.byte	0
 8000 012f 30       		.byte	48
 8001 0130 01       		.byte	1
 8002 0131 00       		.byte	0
 8003 0132 00       		.byte	0
 8004 0133 00000000 		.space	5
 8004      00
 8005 0138 00       		.byte	0
 8006 0139 00       		.byte	0
 8007 013a 02       		.byte	2
 8008 013b 00       		.byte	0
 8009 013c 00       		.byte	0
 8010 013d 64       		.byte	100
 8011 013e 00       		.byte	0
 8012 013f 01       		.byte	1
 8013 0140 00       		.byte	0
 8014 0141 03       		.byte	3
 8015 0142 00       		.byte	0
 8016 0143 00       		.byte	0
 8017 0144 00       		.byte	0
 8018 0145 00       		.byte	0
 8019 0146 00       		.byte	0
 8020 0147 30       		.byte	48
 8021 0148 01       		.byte	1
 8022 0149 00       		.byte	0
 8023 014a 00       		.byte	0
 8024 014b 00000000 		.space	5
 8024      00
 8025 0150 00       		.byte	0
 8026 0151 00       		.byte	0
 8027 0152 02       		.byte	2
 8028 0153 00       		.byte	0
 8029 0154 00       		.byte	0
 8030 0155 64       		.byte	100
 8031 0156 00       		.byte	0
 8032 0157 01       		.byte	1
 8033 0158 00       		.byte	0
 8034 0159 03       		.byte	3
 8035 015a 00       		.byte	0
 8036 015b 00       		.byte	0
 8037 015c 00       		.byte	0
 8038 015d 00       		.byte	0
 8039 015e 00       		.byte	0
 8040 015f 30       		.byte	48
 8041 0160 01       		.byte	1
 8042 0161 00       		.byte	0
 8043 0162 00       		.byte	0
 8044 0163 00000000 		.space	5
 8044      00
 8045 0168 00       		.byte	0
 8046 0169 00       		.byte	0
 8047 016a 02       		.byte	2
 8048 016b 00       		.byte	0
 8049 016c 00       		.byte	0
 8050 016d 64       		.byte	100
 8051 016e 00       		.byte	0
 8052 016f 01       		.byte	1
 8053 0170 00       		.byte	0
 8054 0171 03       		.byte	3
 8055 0172 00       		.byte	0
 8056 0173 00       		.byte	0
 8057 0174 00       		.byte	0
 8058 0175 00       		.byte	0
 8059 0176 00       		.byte	0
 8060 0177 30       		.byte	48
 8061 0178 01       		.byte	1
 8062 0179 00       		.byte	0
 8063 017a 00       		.byte	0
 8064 017b 00000000 		.space	5
 8064      00
 8067              	CtrlParArry:
 8068 0180 10       		.byte	16
 8069 0181 10       		.byte	16
 8070 0182 02       		.byte	2
 8071 0183 00       		.byte	0
 8072 0184 00       		.byte	0
 8073 0185 03       		.byte	3
 8074 0186 00       		.byte	0
 8075 0187 01       		.byte	1
 8076 0188 00       		.byte	0
 8077 0189 03       		.byte	3
 8078 018a 00       		.byte	0
 8079 018b 03       		.byte	3
 8080 018c 00       		.byte	0
 8081 018d 03       		.byte	3
 8082 018e 00       		.byte	0
 8083 018f 30       		.byte	48
 8084 0190 01       		.byte	1
 8085 0191 00       		.byte	0
 8086 0192 00       		.byte	0
 8087 0193 00000000 		.space	5
 8087      00
 8088 0198 15       		.byte	21
 8089 0199 15       		.byte	21
 8090 019a 02       		.byte	2
 8091 019b 00       		.byte	0
 8092 019c 00       		.byte	0
 8093 019d FF       		.byte	-1
 8094 019e 00       		.byte	0
 8095 019f 01       		.byte	1
 8096 01a0 00       		.byte	0
 8097 01a1 03       		.byte	3
 8098 01a2 00       		.byte	0
 8099 01a3 76       		.byte	118
 8100 01a4 00       		.byte	0
 8101 01a5 76       		.byte	118
 8102 01a6 C7       		.byte	-57
 8103 01a7 30       		.byte	48
 8104 01a8 01       		.byte	1
 8105 01a9 01       		.byte	1
 8106 01aa 00       		.byte	0
 8107 01ab 00000000 		.space	5
 8107      00
 8108 01b0 02       		.byte	2
 8109 01b1 02       		.byte	2
 8110 01b2 02       		.byte	2
 8111 01b3 00       		.byte	0
 8112 01b4 00       		.byte	0
 8113 01b5 FF       		.byte	-1
 8114 01b6 00       		.byte	0
 8115 01b7 01       		.byte	1
 8116 01b8 00       		.byte	0
 8117 01b9 03       		.byte	3
 8118 01ba 00       		.byte	0
 8119 01bb 70       		.byte	112
 8120 01bc 00       		.byte	0
 8121 01bd 70       		.byte	112
 8122 01be 00       		.byte	0
 8123 01bf C6       		.byte	-58
 8124 01c0 01       		.byte	1
 8125 01c1 01       		.byte	1
 8126 01c2 00       		.byte	0
 8127 01c3 00000000 		.space	5
 8127      00
 8128 01c8 00       		.byte	0
 8129 01c9 00       		.byte	0
 8130 01ca 02       		.byte	2
 8131 01cb 00       		.byte	0
 8132 01cc 00       		.byte	0
 8133 01cd 64       		.byte	100
 8134 01ce 00       		.byte	0
 8135 01cf 01       		.byte	1
 8136 01d0 00       		.byte	0
 8137 01d1 03       		.byte	3
 8138 01d2 00       		.byte	0
 8139 01d3 00       		.byte	0
 8140 01d4 00       		.byte	0
 8141 01d5 00       		.byte	0
 8142 01d6 00       		.byte	0
 8143 01d7 30       		.byte	48
 8144 01d8 01       		.byte	1
 8145 01d9 00       		.byte	0
 8146 01da 00       		.byte	0
 8147 01db 00000000 		.space	5
 8147      00
 8148 01e0 07       		.byte	7
 8149 01e1 07       		.byte	7
 8150 01e2 02       		.byte	2
 8151 01e3 00       		.byte	0
 8152 01e4 00       		.byte	0
 8153 01e5 01       		.byte	1
 8154 01e6 00       		.byte	0
 8155 01e7 01       		.byte	1
 8156 01e8 00       		.byte	0
 8157 01e9 03       		.byte	3
 8158 01ea 00       		.byte	0
 8159 01eb 01       		.byte	1
 8160 01ec 00       		.byte	0
 8161 01ed 01       		.byte	1
 8162 01ee 00       		.byte	0
 8163 01ef 30       		.byte	48
 8164 01f0 01       		.byte	1
 8165 01f1 00       		.byte	0
 8166 01f2 00       		.byte	0
 8167 01f3 00000000 		.space	5
 8167      00
 8168 01f8 DF       		.byte	-33
 8169 01f9 E1       		.byte	-31
 8170 01fa 02       		.byte	2
 8171 01fb 00       		.byte	0
 8172 01fc 00       		.byte	0
 8173 01fd FF       		.byte	-1
 8174 01fe 00       		.byte	0
 8175 01ff 01       		.byte	1
 8176 0200 00       		.byte	0
 8177 0201 03       		.byte	3
 8178 0202 00       		.byte	0
 8179 0203 80       		.byte	-128
 8180 0204 00       		.byte	0
 8181 0205 00       		.byte	0
 8182 0206 00       		.byte	0
 8183 0207 C6       		.byte	-58
 8184 0208 01       		.byte	1
 8185 0209 01       		.byte	1
 8186 020a 00       		.byte	0
 8187 020b 00000000 		.space	5
 8187      00
 8188 0210 85       		.byte	-123
 8189 0211 86       		.byte	-122
 8190 0212 02       		.byte	2
 8191 0213 00       		.byte	0
 8192 0214 00       		.byte	0
 8193 0215 64       		.byte	100
 8194 0216 00       		.byte	0
 8195 0217 01       		.byte	1
 8196 0218 00       		.byte	0
 8197 0219 03       		.byte	3
 8198 021a 00       		.byte	0
 8199 021b 32       		.byte	50
 8200 021c 00       		.byte	0
 8201 021d 32       		.byte	50
 8202 021e 00       		.byte	0
 8203 021f F2       		.byte	-14
 8204 0220 01       		.byte	1
 8205 0221 01       		.byte	1
 8206 0222 00       		.byte	0
 8207 0223 00000000 		.space	5
 8207      00
 8208 0228 06       		.byte	6
 8209 0229 06       		.byte	6
 8210 022a 02       		.byte	2
 8211 022b 00       		.byte	0
 8212 022c 00       		.byte	0
 8213 022d 40       		.byte	64
 8214 022e 00       		.byte	0
 8215 022f 01       		.byte	1
 8216 0230 00       		.byte	0
 8217 0231 03       		.byte	3
 8218 0232 00       		.byte	0
 8219 0233 20       		.byte	32
 8220 0234 00       		.byte	0
 8221 0235 20       		.byte	32
 8222 0236 00       		.byte	0
 8223 0237 30       		.byte	48
 8224 0238 01       		.byte	1
 8225 0239 01       		.byte	1
 8226 023a 00       		.byte	0
 8227 023b 00000000 		.space	5
 8227      00
 8228 0240 00       		.byte	0
 8229 0241 00       		.byte	0
 8230 0242 02       		.byte	2
 8231 0243 00       		.byte	0
 8232 0244 00       		.byte	0
 8233 0245 64       		.byte	100
 8234 0246 00       		.byte	0
 8235 0247 01       		.byte	1
 8236 0248 00       		.byte	0
 8237 0249 03       		.byte	3
 8238 024a 00       		.byte	0
 8239 024b 00       		.byte	0
 8240 024c 00       		.byte	0
 8241 024d 00       		.byte	0
 8242 024e 00       		.byte	0
 8243 024f 30       		.byte	48
 8244 0250 01       		.byte	1
 8245 0251 00       		.byte	0
 8246 0252 00       		.byte	0
 8247 0253 00000000 		.space	5
 8247      00
 8248 0258 08       		.byte	8
 8249 0259 08       		.byte	8
 8250 025a 02       		.byte	2
 8251 025b 00       		.byte	0
 8252 025c 00       		.byte	0
 8253 025d 05       		.byte	5
 8254 025e 00       		.byte	0
 8255 025f 01       		.byte	1
 8256 0260 00       		.byte	0
 8257 0261 03       		.byte	3
 8258 0262 00       		.byte	0
 8259 0263 00       		.byte	0
 8260 0264 00       		.byte	0
 8261 0265 00       		.byte	0
 8262 0266 00       		.byte	0
 8263 0267 30       		.byte	48
 8264 0268 01       		.byte	1
 8265 0269 00       		.byte	0
 8266 026a 00       		.byte	0
 8267 026b 00000000 		.space	5
 8267      00
 8268 0270 00       		.byte	0
 8269 0271 00       		.byte	0
 8270 0272 02       		.byte	2
 8271 0273 00       		.byte	0
 8272 0274 00       		.byte	0
 8273 0275 40       		.byte	64
 8274 0276 00       		.byte	0
 8275 0277 01       		.byte	1
 8276 0278 00       		.byte	0
 8277 0279 03       		.byte	3
 8278 027a 00       		.byte	0
 8279 027b 00       		.byte	0
 8280 027c 00       		.byte	0
 8281 027d 00       		.byte	0
 8282 027e 00       		.byte	0
 8283 027f 30       		.byte	48
 8284 0280 01       		.byte	1
 8285 0281 00       		.byte	0
 8286 0282 00       		.byte	0
 8287 0283 00000000 		.space	5
 8287      00
 8288 0288 09       		.byte	9
 8289 0289 0A       		.byte	10
 8290 028a 04       		.byte	4
 8291 028b 00       		.byte	0
 8292 028c 00       		.byte	0
 8293 028d 40       		.byte	64
 8294 028e 00       		.byte	0
 8295 028f 01       		.byte	1
 8296 0290 00       		.byte	0
 8297 0291 03       		.byte	3
 8298 0292 00       		.byte	0
 8299 0293 20       		.byte	32
 8300 0294 38       		.byte	56
 8301 0295 20       		.byte	32
 8302 0296 38       		.byte	56
 8303 0297 30       		.byte	48
 8304 0298 01       		.byte	1
 8305 0299 00       		.byte	0
 8306 029a 00       		.byte	0
 8307 029b 00000000 		.space	5
 8307      00
 8308 02a0 00       		.byte	0
 8309 02a1 00       		.byte	0
 8310 02a2 02       		.byte	2
 8311 02a3 00       		.byte	0
 8312 02a4 00       		.byte	0
 8313 02a5 64       		.byte	100
 8314 02a6 00       		.byte	0
 8315 02a7 01       		.byte	1
 8316 02a8 00       		.byte	0
 8317 02a9 03       		.byte	3
 8318 02aa 00       		.byte	0
 8319 02ab 00       		.byte	0
 8320 02ac 00       		.byte	0
 8321 02ad 00       		.byte	0
 8322 02ae 00       		.byte	0
 8323 02af 30       		.byte	48
 8324 02b0 01       		.byte	1
 8325 02b1 00       		.byte	0
 8326 02b2 00       		.byte	0
 8327 02b3 00000000 		.space	5
 8327      00
 8328 02b8 00       		.byte	0
 8329 02b9 00       		.byte	0
 8330 02ba 02       		.byte	2
 8331 02bb 00       		.byte	0
 8332 02bc 00       		.byte	0
 8333 02bd 64       		.byte	100
 8334 02be 00       		.byte	0
 8335 02bf 01       		.byte	1
 8336 02c0 00       		.byte	0
 8337 02c1 03       		.byte	3
 8338 02c2 00       		.byte	0
 8339 02c3 00       		.byte	0
 8340 02c4 00       		.byte	0
 8341 02c5 00       		.byte	0
 8342 02c6 00       		.byte	0
 8343 02c7 30       		.byte	48
 8344 02c8 01       		.byte	1
 8345 02c9 00       		.byte	0
 8346 02ca 00       		.byte	0
 8347 02cb 00000000 		.space	5
 8347      00
 8348 02d0 2A       		.byte	42
 8349 02d1 2A       		.byte	42
 8350 02d2 02       		.byte	2
 8351 02d3 00       		.byte	0
 8352 02d4 00       		.byte	0
 8353 02d5 1B       		.byte	27
 8354 02d6 00       		.byte	0
 8355 02d7 01       		.byte	1
 8356 02d8 00       		.byte	0
 8357 02d9 03       		.byte	3
 8358 02da 00       		.byte	0
 8359 02db 00       		.byte	0
 8360 02dc 00       		.byte	0
 8361 02dd 00       		.byte	0
 8362 02de 00       		.byte	0
 8363 02df 30       		.byte	48
 8364 02e0 01       		.byte	1
 8365 02e1 00       		.byte	0
 8366 02e2 00       		.byte	0
 8367 02e3 00000000 		.space	5
 8367      00
 8368 02e8 00       		.byte	0
 8369 02e9 00       		.byte	0
 8370 02ea 02       		.byte	2
 8371 02eb 00       		.byte	0
 8372 02ec 00       		.byte	0
 8373 02ed 64       		.byte	100
 8374 02ee 00       		.byte	0
 8375 02ef 01       		.byte	1
 8376 02f0 00       		.byte	0
 8377 02f1 03       		.byte	3
 8378 02f2 00       		.byte	0
 8379 02f3 00       		.byte	0
 8380 02f4 00       		.byte	0
 8381 02f5 00       		.byte	0
 8382 02f6 00       		.byte	0
 8383 02f7 30       		.byte	48
 8384 02f8 01       		.byte	1
 8385 02f9 00       		.byte	0
 8386 02fa 00       		.byte	0
 8387 02fb 00000000 		.space	5
 8387      00
 8388 0300 00       		.byte	0
 8389 0301 00       		.byte	0
 8390 0302 02       		.byte	2
 8391 0303 00       		.byte	0
 8392 0304 00       		.byte	0
 8393 0305 12       		.byte	18
 8394 0306 00       		.byte	0
 8395 0307 01       		.byte	1
 8396 0308 00       		.byte	0
 8397 0309 03       		.byte	3
 8398 030a 00       		.byte	0
 8399 030b 00       		.byte	0
 8400 030c 00       		.byte	0
 8401 030d 00       		.byte	0
 8402 030e 00       		.byte	0
 8403 030f 30       		.byte	48
 8404 0310 01       		.byte	1
 8405 0311 00       		.byte	0
 8406 0312 00       		.byte	0
 8407 0313 00000000 		.space	5
 8407      00
 8408 0318 01       		.byte	1
 8409 0319 01       		.byte	1
 8410 031a 02       		.byte	2
 8411 031b 00       		.byte	0
 8412 031c 00       		.byte	0
 8413 031d 09       		.byte	9
 8414 031e 00       		.byte	0
 8415 031f 01       		.byte	1
 8416 0320 00       		.byte	0
 8417 0321 03       		.byte	3
 8418 0322 00       		.byte	0
 8419 0323 00       		.byte	0
 8420 0324 00       		.byte	0
 8421 0325 01       		.byte	1
 8422 0326 00       		.byte	0
 8423 0327 30       		.byte	48
 8424 0328 01       		.byte	1
 8425 0329 00       		.byte	0
 8426 032a 00       		.byte	0
 8427 032b 00000000 		.space	5
 8427      00
 8428 0330 05       		.byte	5
 8429 0331 05       		.byte	5
 8430 0332 02       		.byte	2
 8431 0333 00       		.byte	0
 8432 0334 00       		.byte	0
 8433 0335 03       		.byte	3
 8434 0336 00       		.byte	0
 8435 0337 01       		.byte	1
 8436 0338 00       		.byte	0
 8437 0339 03       		.byte	3
 8438 033a 00       		.byte	0
 8439 033b 00       		.byte	0
 8440 033c 00       		.byte	0
 8441 033d 02       		.byte	2
 8442 033e 00       		.byte	0
 8443 033f 30       		.byte	48
 8444 0340 01       		.byte	1
 8445 0341 00       		.byte	0
 8446 0342 00       		.byte	0
 8447 0343 00000000 		.space	5
 8447      00
 8448 0348 18       		.byte	24
 8449 0349 18       		.byte	24
 8450 034a 02       		.byte	2
 8451 034b 00       		.byte	0
 8452 034c 00       		.byte	0
 8453 034d 01       		.byte	1
 8454 034e 00       		.byte	0
 8455 034f 01       		.byte	1
 8456 0350 00       		.byte	0
 8457 0351 03       		.byte	3
 8458 0352 00       		.byte	0
 8459 0353 00       		.byte	0
 8460 0354 00       		.byte	0
 8461 0355 00       		.byte	0
 8462 0356 00       		.byte	0
 8463 0357 30       		.byte	48
 8464 0358 01       		.byte	1
 8465 0359 00       		.byte	0
 8466 035a 00       		.byte	0
 8467 035b 00000000 		.space	5
 8467      00
 8468 0360 19       		.byte	25
 8469 0361 19       		.byte	25
 8470 0362 01       		.byte	1
 8471 0363 00       		.byte	0
 8472 0364 00       		.byte	0
 8473 0365 40       		.byte	64
 8474 0366 00       		.byte	0
 8475 0367 01       		.byte	1
 8476 0368 00       		.byte	0
 8477 0369 03       		.byte	3
 8478 036a 00       		.byte	0
 8479 036b 20       		.byte	32
 8480 036c 00       		.byte	0
 8481 036d 20       		.byte	32
 8482 036e 00       		.byte	0
 8483 036f 30       		.byte	48
 8484 0370 01       		.byte	1
 8485 0371 00       		.byte	0
 8486 0372 00       		.byte	0
 8487 0373 00000000 		.space	5
 8487      00
 8488 0378 20       		.byte	32
 8489 0379 20       		.byte	32
 8490 037a 02       		.byte	2
 8491 037b 00       		.byte	0
 8492 037c 00       		.byte	0
 8493 037d 02       		.byte	2
 8494 037e 00       		.byte	0
 8495 037f 01       		.byte	1
 8496 0380 00       		.byte	0
 8497 0381 03       		.byte	3
 8498 0382 00       		.byte	0
 8499 0383 00       		.byte	0
 8500 0384 00       		.byte	0
 8501 0385 00       		.byte	0
 8502 0386 00       		.byte	0
 8503 0387 30       		.byte	48
 8504 0388 01       		.byte	1
 8505 0389 00       		.byte	0
 8506 038a 00       		.byte	0
 8507 038b 00000000 		.space	5
 8507      00
 8508 0390 22       		.byte	34
 8509 0391 22       		.byte	34
 8510 0392 02       		.byte	2
 8511 0393 00       		.byte	0
 8512 0394 00       		.byte	0
 8513 0395 3F       		.byte	63
 8514 0396 00       		.byte	0
 8515 0397 01       		.byte	1
 8516 0398 00       		.byte	0
 8517 0399 03       		.byte	3
 8518 039a 00       		.byte	0
 8519 039b 00       		.byte	0
 8520 039c 00       		.byte	0
 8521 039d 00       		.byte	0
 8522 039e 00       		.byte	0
 8523 039f 30       		.byte	48
 8524 03a0 01       		.byte	1
 8525 03a1 00       		.byte	0
 8526 03a2 00       		.byte	0
 8527 03a3 00000000 		.space	5
 8527      00
 8528 03a8 23       		.byte	35
 8529 03a9 23       		.byte	35
 8530 03aa 02       		.byte	2
 8531 03ab 00       		.byte	0
 8532 03ac 00       		.byte	0
 8533 03ad 64       		.byte	100
 8534 03ae 00       		.byte	0
 8535 03af 01       		.byte	1
 8536 03b0 00       		.byte	0
 8537 03b1 03       		.byte	3
 8538 03b2 00       		.byte	0
 8539 03b3 10       		.byte	16
 8540 03b4 00       		.byte	0
 8541 03b5 10       		.byte	16
 8542 03b6 00       		.byte	0
 8543 03b7 30       		.byte	48
 8544 03b8 01       		.byte	1
 8545 03b9 00       		.byte	0
 8546 03ba 00       		.byte	0
 8547 03bb 00000000 		.space	5
 8547      00
 8548 03c0 24       		.byte	36
 8549 03c1 24       		.byte	36
 8550 03c2 02       		.byte	2
 8551 03c3 00       		.byte	0
 8552 03c4 00       		.byte	0
 8553 03c5 64       		.byte	100
 8554 03c6 00       		.byte	0
 8555 03c7 01       		.byte	1
 8556 03c8 00       		.byte	0
 8557 03c9 03       		.byte	3
 8558 03ca 00       		.byte	0
 8559 03cb 10       		.byte	16
 8560 03cc 00       		.byte	0
 8561 03cd 10       		.byte	16
 8562 03ce 00       		.byte	0
 8563 03cf 30       		.byte	48
 8564 03d0 01       		.byte	1
 8565 03d1 00       		.byte	0
 8566 03d2 00       		.byte	0
 8567 03d3 00000000 		.space	5
 8567      00
 8568 03d8 02       		.byte	2
 8569 03d9 03       		.byte	3
 8570 03da 04       		.byte	4
 8571 03db 00       		.byte	0
 8572 03dc 00       		.byte	0
 8573 03dd 7F       		.byte	127
 8574 03de 00       		.byte	0
 8575 03df 01       		.byte	1
 8576 03e0 00       		.byte	0
 8577 03e1 03       		.byte	3
 8578 03e2 00       		.byte	0
 8579 03e3 00       		.byte	0
 8580 03e4 20       		.byte	32
 8581 03e5 00       		.byte	0
 8582 03e6 20       		.byte	32
 8583 03e7 30       		.byte	48
 8584 03e8 01       		.byte	1
 8585 03e9 00       		.byte	0
 8586 03ea 00       		.byte	0
 8587 03eb 00000000 		.space	5
 8587      00
 8588 03f0 04       		.byte	4
 8589 03f1 04       		.byte	4
 8590 03f2 02       		.byte	2
 8591 03f3 00       		.byte	0
 8592 03f4 00       		.byte	0
 8593 03f5 40       		.byte	64
 8594 03f6 00       		.byte	0
 8595 03f7 01       		.byte	1
 8596 03f8 00       		.byte	0
 8597 03f9 03       		.byte	3
 8598 03fa 00       		.byte	0
 8599 03fb 20       		.byte	32
 8600 03fc 00       		.byte	0
 8601 03fd 20       		.byte	32
 8602 03fe 00       		.byte	0
 8603 03ff 30       		.byte	48
 8604 0400 01       		.byte	1
 8605 0401 00       		.byte	0
 8606 0402 00       		.byte	0
 8607 0403 00000000 		.space	5
 8607      00
 8608 0408 00       		.byte	0
 8609 0409 00       		.byte	0
 8610 040a 02       		.byte	2
 8611 040b 00       		.byte	0
 8612 040c 00       		.byte	0
 8613 040d 19       		.byte	25
 8614 040e 00       		.byte	0
 8615 040f 01       		.byte	1
 8616 0410 00       		.byte	0
 8617 0411 03       		.byte	3
 8618 0412 00       		.byte	0
 8619 0413 00       		.byte	0
 8620 0414 00       		.byte	0
 8621 0415 00       		.byte	0
 8622 0416 00       		.byte	0
 8623 0417 30       		.byte	48
 8624 0418 01       		.byte	1
 8625 0419 00       		.byte	0
 8626 041a 00       		.byte	0
 8627 041b 00000000 		.space	5
 8627      00
 8628 0420 10       		.byte	16
 8629 0421 10       		.byte	16
 8630 0422 02       		.byte	2
 8631 0423 00       		.byte	0
 8632 0424 00       		.byte	0
 8633 0425 06       		.byte	6
 8634 0426 00       		.byte	0
 8635 0427 01       		.byte	1
 8636 0428 00       		.byte	0
 8637 0429 03       		.byte	3
 8638 042a 00       		.byte	0
 8639 042b 03       		.byte	3
 8640 042c 00       		.byte	0
 8641 042d 03       		.byte	3
 8642 042e 00       		.byte	0
 8643 042f 30       		.byte	48
 8644 0430 01       		.byte	1
 8645 0431 00       		.byte	0
 8646 0432 00       		.byte	0
 8647 0433 00000000 		.space	5
 8647      00
 8648 0438 00       		.byte	0
 8649 0439 00       		.byte	0
 8650 043a 02       		.byte	2
 8651 043b 00       		.byte	0
 8652 043c 00       		.byte	0
 8653 043d 03       		.byte	3
 8654 043e 00       		.byte	0
 8655 043f 01       		.byte	1
 8656 0440 00       		.byte	0
 8657 0441 03       		.byte	3
 8658 0442 00       		.byte	0
 8659 0443 00       		.byte	0
 8660 0444 00       		.byte	0
 8661 0445 00       		.byte	0
 8662 0446 00       		.byte	0
 8663 0447 30       		.byte	48
 8664 0448 01       		.byte	1
 8665 0449 00       		.byte	0
 8666 044a 00       		.byte	0
 8667 044b 00000000 		.space	5
 8667      00
 8668 0450 50       		.byte	80
 8669 0451 50       		.byte	80
 8670 0452 01       		.byte	1
 8671 0453 00       		.byte	0
 8672 0454 00       		.byte	0
 8673 0455 03       		.byte	3
 8674 0456 00       		.byte	0
 8675 0457 01       		.byte	1
 8676 0458 00       		.byte	0
 8677 0459 03       		.byte	3
 8678 045a 00       		.byte	0
 8679 045b 00       		.byte	0
 8680 045c 00       		.byte	0
 8681 045d 00       		.byte	0
 8682 045e 00       		.byte	0
 8683 045f 30       		.byte	48
 8684 0460 01       		.byte	1
 8685 0461 00       		.byte	0
 8686 0462 00       		.byte	0
 8687 0463 00000000 		.space	5
 8687      00
 8688 0468 00       		.byte	0
 8689 0469 00       		.byte	0
 8690 046a 0B       		.byte	11
 8691 046b 00       		.byte	0
 8692 046c 00       		.byte	0
 8693 046d FF       		.byte	-1
 8694 046e FF       		.byte	-1
 8695 046f 01       		.byte	1
 8696 0470 00       		.byte	0
 8697 0471 03       		.byte	3
 8698 0472 00       		.byte	0
 8699 0473 00       		.byte	0
 8700 0474 00       		.byte	0
 8701 0475 00       		.byte	0
 8702 0476 00       		.byte	0
 8703 0477 00       		.byte	0
 8704 0478 01       		.byte	1
 8705 0479 00       		.byte	0
 8706 047a 00       		.byte	0
 8707 047b 00000000 		.space	5
 8707      00
 8710              	glUVCHeader:
 8711 0480 0C       		.byte	12
 8712 0481 8C       		.byte	-116
 8713 0482 00       		.byte	0
 8714 0483 00       		.byte	0
 8715 0484 00       		.byte	0
 8716 0485 00       		.byte	0
 8717 0486 00       		.byte	0
 8718 0487 00       		.byte	0
 8719 0488 00       		.byte	0
 8720 0489 00       		.byte	0
 8721 048a 00       		.byte	0
 8722 048b 00       		.byte	0
 8725              	ROIMode:
 8726 048c 01       		.byte	1
 8727 048d 000000   		.space	3
 8730              	WBMenuCmpArry:
 8731 0490 20       		.byte	32
 8732 0491 0F       		.byte	15
 8733 0492 38       		.byte	56
 8734 0493 F0       		.byte	-16
 8737              	CTCtrlParArry:
 8738 0494 00       		.byte	0
 8739 0495 00       		.byte	0
 8740 0496 01       		.byte	1
 8741 0497 00       		.byte	0
 8742 0498 00       		.byte	0
 8743 0499 03       		.byte	3
 8744 049a 00       		.byte	0
 8745 049b 01       		.byte	1
 8746 049c 00       		.byte	0
 8747 049d 03       		.byte	3
 8748 049e 00       		.byte	0
 8749 049f 03       		.byte	3
 8750 04a0 00       		.byte	0
 8751 04a1 03       		.byte	3
 8752 04a2 00       		.byte	0
 8753 04a3 30       		.byte	48
 8754 04a4 01       		.byte	1
 8755 04a5 00       		.byte	0
 8756 04a6 00       		.byte	0
 8757 04a7 00000000 		.space	5
 8757      00
 8758 04ac 00       		.byte	0
 8759 04ad 00       		.byte	0
 8760 04ae 01       		.byte	1
 8761 04af 01       		.byte	1
 8762 04b0 00       		.byte	0
 8763 04b1 0F       		.byte	15
 8764 04b2 00       		.byte	0
 8765 04b3 0F       		.byte	15
 8766 04b4 00       		.byte	0
 8767 04b5 03       		.byte	3
 8768 04b6 00       		.byte	0
 8769 04b7 02       		.byte	2
 8770 04b8 00       		.byte	0
 8771 04b9 02       		.byte	2
 8772 04ba 00       		.byte	0
 8773 04bb 30       		.byte	48
 8774 04bc 01       		.byte	1
 8775 04bd 01       		.byte	1
 8776 04be 00       		.byte	0
 8777 04bf 00000000 		.space	5
 8777      00
 8778 04c4 02       		.byte	2
 8779 04c5 00       		.byte	0
 8780 04c6 01       		.byte	1
 8781 04c7 00       		.byte	0
 8782 04c8 00       		.byte	0
 8783 04c9 01       		.byte	1
 8784 04ca 00       		.byte	0
 8785 04cb 01       		.byte	1
 8786 04cc 00       		.byte	0
 8787 04cd 03       		.byte	3
 8788 04ce 00       		.byte	0
 8789 04cf 00       		.byte	0
 8790 04d0 00       		.byte	0
 8791 04d1 00       		.byte	0
 8792 04d2 00       		.byte	0
 8793 04d3 30       		.byte	48
 8794 04d4 01       		.byte	1
 8795 04d5 01       		.byte	1
 8796 04d6 00       		.byte	0
 8797 04d7 00000000 		.space	5
 8797      00
 8798 04dc 00       		.byte	0
 8799 04dd 00       		.byte	0
 8800 04de 04       		.byte	4
 8801 04df 01       		.byte	1
 8802 04e0 00       		.byte	0
 8803 04e1 38       		.byte	56
 8804 04e2 01       		.byte	1
 8805 04e3 01       		.byte	1
 8806 04e4 00       		.byte	0
 8807 04e5 03       		.byte	3
 8808 04e6 00       		.byte	0
 8809 04e7 4E       		.byte	78
 8810 04e8 00       		.byte	0
 8811 04e9 4E       		.byte	78
 8812 04ea 00       		.byte	0
 8813 04eb 30       		.byte	48
 8814 04ec 01       		.byte	1
 8815 04ed 00       		.byte	0
 8816 04ee 00       		.byte	0
 8817 04ef 00000000 		.space	5
 8817      00
 8818 04f4 04       		.byte	4
 8819 04f5 00       		.byte	0
 8820 04f6 01       		.byte	1
 8821 04f7 00       		.byte	0
 8822 04f8 00       		.byte	0
 8823 04f9 00       		.byte	0
 8824 04fa 00       		.byte	0
 8825 04fb 01       		.byte	1
 8826 04fc 00       		.byte	0
 8827 04fd 03       		.byte	3
 8828 04fe 00       		.byte	0
 8829 04ff 00       		.byte	0
 8830 0500 00       		.byte	0
 8831 0501 00       		.byte	0
 8832 0502 00       		.byte	0
 8833 0503 30       		.byte	48
 8834 0504 01       		.byte	1
 8835 0505 00       		.byte	0
 8836 0506 00       		.byte	0
 8837 0507 00000000 		.space	5
 8837      00
 8838 050c 05       		.byte	5
 8839 050d 00       		.byte	0
 8840 050e 02       		.byte	2
 8841 050f 00       		.byte	0
 8842 0510 00       		.byte	0
 8843 0511 FF       		.byte	-1
 8844 0512 00       		.byte	0
 8845 0513 01       		.byte	1
 8846 0514 00       		.byte	0
 8847 0515 03       		.byte	3
 8848 0516 00       		.byte	0
 8849 0517 01       		.byte	1
 8850 0518 00       		.byte	0
 8851 0519 00       		.byte	0
 8852 051a 00       		.byte	0
 8853 051b 30       		.byte	48
 8854 051c 01       		.byte	1
 8855 051d 01       		.byte	1
 8856 051e 00       		.byte	0
 8857 051f 00000000 		.space	5
 8857      00
 8858 0524 06       		.byte	6
 8859 0525 00       		.byte	0
 8860 0526 02       		.byte	2
 8861 0527 00       		.byte	0
 8862 0528 00       		.byte	0
 8863 0529 00       		.byte	0
 8864 052a 00       		.byte	0
 8865 052b 00       		.byte	0
 8866 052c 00       		.byte	0
 8867 052d 03       		.byte	3
 8868 052e 00       		.byte	0
 8869 052f 00       		.byte	0
 8870 0530 00       		.byte	0
 8871 0531 00       		.byte	0
 8872 0532 00       		.byte	0
 8873 0533 30       		.byte	48
 8874 0534 01       		.byte	1
 8875 0535 01       		.byte	1
 8876 0536 00       		.byte	0
 8877 0537 00000000 		.space	5
 8877      00
 8878 053c 23       		.byte	35
 8879 053d 00       		.byte	0
 8880 053e 02       		.byte	2
 8881 053f 00       		.byte	0
 8882 0540 00       		.byte	0
 8883 0541 30       		.byte	48
 8884 0542 00       		.byte	0
 8885 0543 01       		.byte	1
 8886 0544 00       		.byte	0
 8887 0545 03       		.byte	3
 8888 0546 0A       		.byte	10
 8889 0547 00       		.byte	0
 8890 0548 00       		.byte	0
 8891 0549 0A       		.byte	10
 8892 054a 00       		.byte	0
 8893 054b 30       		.byte	48
 8894 054c 01       		.byte	1
 8895 054d 01       		.byte	1
 8896 054e 00       		.byte	0
 8897 054f 00000000 		.space	5
 8897      00
 8898 0554 08       		.byte	8
 8899 0555 00       		.byte	0
 8900 0556 01       		.byte	1
 8901 0557 00       		.byte	0
 8902 0558 00       		.byte	0
 8903 0559 7F       		.byte	127
 8904 055a 00       		.byte	0
 8905 055b 01       		.byte	1
 8906 055c 00       		.byte	0
 8907 055d 03       		.byte	3
 8908 055e 00       		.byte	0
 8909 055f 00       		.byte	0
 8910 0560 00       		.byte	0
 8911 0561 00       		.byte	0
 8912 0562 00       		.byte	0
 8913 0563 30       		.byte	48
 8914 0564 01       		.byte	1
 8915 0565 00       		.byte	0
 8916 0566 00       		.byte	0
 8917 0567 00000000 		.space	5
 8917      00
 8918 056c 09       		.byte	9
 8919 056d 00       		.byte	0
 8920 056e 02       		.byte	2
 8921 056f 00       		.byte	0
 8922 0570 00       		.byte	0
 8923 0571 05       		.byte	5
 8924 0572 00       		.byte	0
 8925 0573 01       		.byte	1
 8926 0574 00       		.byte	0
 8927 0575 03       		.byte	3
 8928 0576 00       		.byte	0
 8929 0577 00       		.byte	0
 8930 0578 00       		.byte	0
 8931 0579 00       		.byte	0
 8932 057a 00       		.byte	0
 8933 057b 30       		.byte	48
 8934 057c 01       		.byte	1
 8935 057d 00       		.byte	0
 8936 057e 00       		.byte	0
 8937 057f 00000000 		.space	5
 8937      00
 8938 0584 10       		.byte	16
 8939 0585 00       		.byte	0
 8940 0586 03       		.byte	3
 8941 0587 00       		.byte	0
 8942 0588 00       		.byte	0
 8943 0589 00       		.byte	0
 8944 058a 00       		.byte	0
 8945 058b 00       		.byte	0
 8946 058c 00       		.byte	0
 8947 058d 03       		.byte	3
 8948 058e 00       		.byte	0
 8949 058f 00       		.byte	0
 8950 0590 00       		.byte	0
 8951 0591 00       		.byte	0
 8952 0592 00       		.byte	0
 8953 0593 30       		.byte	48
 8954 0594 01       		.byte	1
 8955 0595 00       		.byte	0
 8956 0596 00       		.byte	0
 8957 0597 00000000 		.space	5
 8957      00
 8958 059c 00       		.byte	0
 8959 059d 00       		.byte	0
 8960 059e 02       		.byte	2
 8961 059f 00       		.byte	0
 8962 05a0 00       		.byte	0
 8963 05a1 40       		.byte	64
 8964 05a2 00       		.byte	0
 8965 05a3 01       		.byte	1
 8966 05a4 00       		.byte	0
 8967 05a5 03       		.byte	3
 8968 05a6 00       		.byte	0
 8969 05a7 0F       		.byte	15
 8970 05a8 11       		.byte	17
 8971 05a9 00       		.byte	0
 8972 05aa 00       		.byte	0
 8973 05ab 30       		.byte	48
 8974 05ac 01       		.byte	1
 8975 05ad 00       		.byte	0
 8976 05ae 00       		.byte	0
 8977 05af 00000000 		.space	5
 8977      00
 8978 05b4 00       		.byte	0
 8979 05b5 00       		.byte	0
 8980 05b6 02       		.byte	2
 8981 05b7 00       		.byte	0
 8982 05b8 00       		.byte	0
 8983 05b9 64       		.byte	100
 8984 05ba 00       		.byte	0
 8985 05bb 01       		.byte	1
 8986 05bc 00       		.byte	0
 8987 05bd 03       		.byte	3
 8988 05be 00       		.byte	0
 8989 05bf 00       		.byte	0
 8990 05c0 00       		.byte	0
 8991 05c1 00       		.byte	0
 8992 05c2 00       		.byte	0
 8993 05c3 30       		.byte	48
 8994 05c4 01       		.byte	1
 8995 05c5 00       		.byte	0
 8996 05c6 00       		.byte	0
 8997 05c7 00000000 		.space	5
 8997      00
 8998 05cc 00       		.byte	0
 8999 05cd 00       		.byte	0
 9000 05ce 02       		.byte	2
 9001 05cf 00       		.byte	0
 9002 05d0 00       		.byte	0
 9003 05d1 64       		.byte	100
 9004 05d2 00       		.byte	0
 9005 05d3 01       		.byte	1
 9006 05d4 00       		.byte	0
 9007 05d5 03       		.byte	3
 9008 05d6 00       		.byte	0
 9009 05d7 00       		.byte	0
 9010 05d8 00       		.byte	0
 9011 05d9 00       		.byte	0
 9012 05da 00       		.byte	0
 9013 05db 30       		.byte	48
 9014 05dc 01       		.byte	1
 9015 05dd 00       		.byte	0
 9016 05de 00       		.byte	0
 9017 05df 00000000 		.space	5
 9017      00
 9018 05e4 00       		.byte	0
 9019 05e5 00       		.byte	0
 9020 05e6 02       		.byte	2
 9021 05e7 00       		.byte	0
 9022 05e8 00       		.byte	0
 9023 05e9 64       		.byte	100
 9024 05ea 00       		.byte	0
 9025 05eb 01       		.byte	1
 9026 05ec 00       		.byte	0
 9027 05ed 03       		.byte	3
 9028 05ee 00       		.byte	0
 9029 05ef 00       		.byte	0
 9030 05f0 00       		.byte	0
 9031 05f1 00       		.byte	0
 9032 05f2 00       		.byte	0
 9033 05f3 30       		.byte	48
 9034 05f4 01       		.byte	1
 9035 05f5 00       		.byte	0
 9036 05f6 00       		.byte	0
 9037 05f7 00000000 		.space	5
 9037      00
 9038 05fc 00       		.byte	0
 9039 05fd 00       		.byte	0
 9040 05fe 02       		.byte	2
 9041 05ff 00       		.byte	0
 9042 0600 00       		.byte	0
 9043 0601 64       		.byte	100
 9044 0602 00       		.byte	0
 9045 0603 01       		.byte	1
 9046 0604 00       		.byte	0
 9047 0605 03       		.byte	3
 9048 0606 00       		.byte	0
 9049 0607 00       		.byte	0
 9050 0608 00       		.byte	0
 9051 0609 00       		.byte	0
 9052 060a 00       		.byte	0
 9053 060b 30       		.byte	48
 9054 060c 01       		.byte	1
 9055 060d 00       		.byte	0
 9056 060e 00       		.byte	0
 9057 060f 00000000 		.space	5
 9057      00
 9060              	glProbeCtrlFull:
 9061 0614 00       		.byte	0
 9062 0615 00       		.byte	0
 9063 0616 01       		.byte	1
 9064 0617 01       		.byte	1
 9065 0618 15       		.byte	21
 9066 0619 16       		.byte	22
 9067 061a 05       		.byte	5
 9068 061b 00       		.byte	0
 9069 061c 00       		.byte	0
 9070 061d 00       		.byte	0
 9071 061e 00       		.byte	0
 9072 061f 00       		.byte	0
 9073 0620 00       		.byte	0
 9074 0621 00       		.byte	0
 9075 0622 00       		.byte	0
 9076 0623 00       		.byte	0
 9077 0624 00       		.byte	0
 9078 0625 00       		.byte	0
 9079 0626 00       		.byte	0
 9080 0627 C6       		.byte	-58
 9081 0628 99       		.byte	-103
 9082 0629 00       		.byte	0
 9083 062a 00       		.byte	0
 9084 062b 40       		.byte	64
 9085 062c 00       		.byte	0
 9086 062d 00       		.byte	0
 9087 062e 0000     		.space	2
 9090              	glProbeCtrl20:
 9091 0630 00       		.byte	0
 9092 0631 00       		.byte	0
 9093 0632 01       		.byte	1
 9094 0633 01       		.byte	1
 9095 0634 80       		.byte	-128
 9096 0635 1A       		.byte	26
 9097 0636 06       		.byte	6
 9098 0637 00       		.byte	0
 9099 0638 00       		.byte	0
 9100 0639 00       		.byte	0
 9101 063a 00       		.byte	0
 9102 063b 00       		.byte	0
 9103 063c 00       		.byte	0
 9104 063d 00       		.byte	0
 9105 063e 00       		.byte	0
 9106 063f 00       		.byte	0
 9107 0640 00       		.byte	0
 9108 0641 00       		.byte	0
 9109 0642 00       		.byte	0
 9110 0643 D2       		.byte	-46
 9111 0644 0F       		.byte	15
 9112 0645 00       		.byte	0
 9113 0646 00       		.byte	0
 9114 0647 40       		.byte	64
 9115 0648 00       		.byte	0
 9116 0649 00       		.byte	0
 9117 064a 0000     		.space	2
 9120              	glProbeCtrl:
 9121 064c 00       		.byte	0
 9122 064d 00       		.byte	0
 9123 064e 01       		.byte	1
 9124 064f 01       		.byte	1
 9125 0650 15       		.byte	21
 9126 0651 16       		.byte	22
 9127 0652 05       		.byte	5
 9128 0653 00       		.byte	0
 9129 0654 00       		.byte	0
 9130 0655 00       		.byte	0
 9131 0656 00       		.byte	0
 9132 0657 00       		.byte	0
 9133 0658 00       		.byte	0
 9134 0659 00       		.byte	0
 9135 065a 00       		.byte	0
 9136 065b 00       		.byte	0
 9137 065c 00       		.byte	0
 9138 065d 00       		.byte	0
 9139 065e 00       		.byte	0
 9140 065f 48       		.byte	72
 9141 0660 3F       		.byte	63
 9142 0661 00       		.byte	0
 9143 0662 00       		.byte	0
 9144 0663 40       		.byte	64
 9145 0664 00       		.byte	0
 9146 0665 00       		.byte	0
 9147 0666 0000     		.space	2
 9150              	glProbeStilCtrl:
 9151 0668 01       		.byte	1
 9152 0669 02       		.byte	2
 9153 066a 00       		.byte	0
 9154 066b 00       		.byte	0
 9155 066c C6       		.byte	-58
 9156 066d 99       		.byte	-103
 9157 066e 00       		.byte	0
 9158 066f 00       		.byte	0
 9159 0670 40       		.byte	64
 9160 0671 00       		.byte	0
 9161 0672 00       		.byte	0
 9162 0673 00       		.space	1
 9165              	glProbeStilCtrl20:
 9166 0674 01       		.byte	1
 9167 0675 01       		.byte	1
 9168 0676 00       		.byte	0
 9169 0677 00       		.byte	0
 9170 0678 D2       		.byte	-46
 9171 0679 0F       		.byte	15
 9172 067a 00       		.byte	0
 9173 067b 00       		.byte	0
 9174 067c 40       		.byte	64
 9175 067d 00       		.byte	0
 9176 067e 00       		.byte	0
 9179              	snapButFlag:
 9180 067f 01       		.byte	1
 9183              	CyFxGpifTransition:
 9184 0680 0000     		.short	0
 9185 0682 5555     		.short	21845
 9186 0684 8888     		.short	-30584
 9187 0686 AAAA     		.short	-21846
 9188 0688 3333     		.short	13107
 9189 068a 0000     		.space	2
 9192              	CyFxGpifWavedata:
 9193 068c 0181731E 		.word	510886145
 9194 0690 00000000 		.word	0
 9195 0694 00000080 		.word	-2147483648
 9196 0698 00000000 		.word	0
 9197 069c 00000000 		.word	0
 9198 06a0 00000000 		.word	0
 9199 06a4 0201702E 		.word	779092226
 9200 06a8 00010000 		.word	256
 9201 06ac A0000080 		.word	-2147483488
 9202 06b0 00000000 		.word	0
 9203 06b4 00000000 		.word	0
 9204 06b8 00000000 		.word	0
 9205 06bc 0380722E 		.word	779255811
 9206 06c0 02010020 		.word	536871170
 9207 06c4 60000080 		.word	-2147483552
 9208 06c8 00000000 		.word	0
 9209 06cc 00000000 		.word	0
 9210 06d0 00000000 		.word	0
 9211 06d4 0460722E 		.word	779247620
 9212 06d8 02010024 		.word	603980034
 9213 06dc 90000080 		.word	-2147483504
 9214 06e0 0594731E 		.word	510891013
 9215 06e4 06000000 		.word	6
 9216 06e8 00000080 		.word	-2147483648
 9217 06ec 0380722E 		.word	779255811
 9218 06f0 02010020 		.word	536871170
 9219 06f4 60000080 		.word	-2147483552
 9220 06f8 0693731E 		.word	510890758
 9221 06fc 06000000 		.word	6
 9222 0700 00000080 		.word	-2147483648
 9223 0704 0720703E 		.word	1047535623
 9224 0708 08010000 		.word	264
 9225 070c 00000080 		.word	-2147483648
 9226 0710 0820703E 		.word	1047535624
 9227 0714 08010000 		.word	264
 9228 0718 00000080 		.word	-2147483648
 9229 071c 0920703E 		.word	1047535625
 9230 0720 08010000 		.word	264
 9231 0724 00000080 		.word	-2147483648
 9232 0728 0A20703E 		.word	1047535626
 9233 072c 08010000 		.word	264
 9234 0730 00000080 		.word	-2147483648
 9235 0734 0380722E 		.word	779255811
 9236 0738 02010020 		.word	536871170
 9237 073c 60000080 		.word	-2147483552
 9238 0740 0B000000 		.word	11
 9239 0744 00000000 		.word	0
 9240 0748 00010080 		.word	-2147483392
 9241 074c 0460722E 		.word	779247620
 9242 0750 02010024 		.word	603980034
 9243 0754 90000080 		.word	-2147483504
 9244 0758 0D000000 		.word	13
 9245 075c 00000000 		.word	0
 9246 0760 00010080 		.word	-2147483392
 9247 0764 0460722E 		.word	779247620
 9248 0768 02010024 		.word	603980034
 9249 076c 90000080 		.word	-2147483504
 9250 0770 0C000000 		.word	12
 9251 0774 00000000 		.word	0
 9252 0778 00010080 		.word	-2147483392
 9253 077c 0380722E 		.word	779255811
 9254 0780 02010020 		.word	536871170
 9255 0784 60000080 		.word	-2147483552
 9256 0788 0E000000 		.word	14
 9257 078c 00000000 		.word	0
 9258 0790 00010080 		.word	-2147483392
 9259 0794 00000000 		.word	0
 9260 0798 00000000 		.word	0
 9261 079c 00000000 		.word	0
 9262 07a0 00000000 		.word	0
 9263 07a4 00000000 		.word	0
 9264 07a8 00000000 		.word	0
 9267              	CyFxGpifWavedataPosition:
 9268 07ac 00       		.byte	0
 9269 07ad 01       		.byte	1
 9270 07ae 02       		.byte	2
 9271 07af 03       		.byte	3
 9272 07b0 04       		.byte	4
 9273 07b1 05       		.byte	5
 9274 07b2 06       		.byte	6
 9275 07b3 07       		.byte	7
 9276 07b4 08       		.byte	8
 9277 07b5 09       		.byte	9
 9278 07b6 0A       		.byte	10
 9279 07b7 0B       		.byte	11
 9280 07b8 0B       		.byte	11
 9281 07b9 0B       		.byte	11
 9282 07ba 0B       		.byte	11
 9283 07bb 00       		.space	1
 9286              	CyFxGpifRegValue:
 9287 07bc 08830080 		.word	-2147450104
 9288 07c0 67000000 		.word	103
 9289 07c4 00000000 		.word	0
 9290 07c8 46000000 		.word	70
 9291 07cc 00000000 		.word	0
 9292 07d0 00000000 		.word	0
 9293 07d4 02000000 		.word	2
 9294 07d8 82000000 		.word	130
 9295 07dc 82070000 		.word	1922
 9296 07e0 40040000 		.word	1088
 9297 07e4 FCFF0000 		.word	65532
 9298 07e8 28000000 		.word	40
 9299 07ec 00000000 		.word	0
 9300 07f0 00000000 		.word	0
 9301 07f4 00000000 		.word	0
 9302 07f8 00000000 		.word	0
 9303 07fc 01000000 		.word	1
 9304 0800 00000000 		.word	0
 9305 0804 00000000 		.word	0
 9306 0808 00000000 		.word	0
 9307 080c 00000000 		.word	0
 9308 0810 00000000 		.word	0
 9309 0814 00000000 		.word	0
 9310 0818 00000000 		.word	0
 9311 081c 00000000 		.word	0
 9312 0820 00000000 		.word	0
 9313 0824 00000000 		.word	0
 9314 0828 00000000 		.word	0
 9315 082c 00000000 		.word	0
 9316 0830 06000000 		.word	6
 9317 0834 00000000 		.word	0
 9318 0838 FFFF0000 		.word	65535
 9319 083c 09010000 		.word	265
 9320 0840 00000000 		.word	0
 9321 0844 F71F0000 		.word	8183
 9322 0848 00000000 		.word	0
 9323 084c FFFF0000 		.word	65535
 9324 0850 09010000 		.word	265
 9325 0854 00000000 		.word	0
 9326 0858 F71F0000 		.word	8183
 9327 085c 00000000 		.word	0
 9328 0860 00000000 		.word	0
 9329 0864 00000000 		.word	0
 9330 0868 00000000 		.word	0
 9331 086c 00000000 		.word	0
 9332 0870 00000000 		.word	0
 9333 0874 00000000 		.word	0
 9334 0878 00000000 		.word	0
 9335 087c 00000000 		.word	0
 9336 0880 00000000 		.word	0
 9337 0884 00000000 		.word	0
 9338 0888 00000000 		.word	0
 9339 088c 00000000 		.word	0
 9340 0890 00000000 		.word	0
 9341 0894 00000000 		.word	0
 9342 0898 00000000 		.word	0
 9343 089c 00000000 		.word	0
 9344 08a0 00000000 		.word	0
 9345 08a4 00000000 		.word	0
 9346 08a8 00000000 		.word	0
 9347 08ac 00000000 		.word	0
 9348 08b0 00000000 		.word	0
 9349 08b4 00000000 		.word	0
 9350 08b8 00040180 		.word	-2147417088
 9351 08bc 01040180 		.word	-2147417087
 9352 08c0 02040180 		.word	-2147417086
 9353 08c4 03040180 		.word	-2147417085
 9354 08c8 00000000 		.word	0
 9355 08cc 00000000 		.word	0
 9356 08d0 00000000 		.word	0
 9357 08d4 00000000 		.word	0
 9358 08d8 00000000 		.word	0
 9359 08dc 00000000 		.word	0
 9360 08e0 00000000 		.word	0
 9361 08e4 00000000 		.word	0
 9362 08e8 C1FFFFFF 		.word	-63
 9365              	CyFxGpifTransition_usb2:
 9366 08ec 0000     		.short	0
 9367 08ee 5555     		.short	21845
 9368 08f0 AAAA     		.short	-21846
 9369 08f2 8888     		.short	-30584
 9370 08f4 1111     		.short	4369
 9371 08f6 4444     		.short	17476
 9372 08f8 3333     		.short	13107
 9373 08fa CCCC     		.short	-13108
 9376              	CyFxGpifWavedata_usb2:
 9377 08fc 0181731E 		.word	510886145
 9378 0900 00000000 		.word	0
 9379 0904 00000080 		.word	-2147483648
 9380 0908 00000000 		.word	0
 9381 090c 00000000 		.word	0
 9382 0910 00000000 		.word	0
 9383 0914 0201703E 		.word	1047527682
 9384 0918 00010000 		.word	256
 9385 091c A00000C0 		.word	-1073741664
 9386 0920 00000000 		.word	0
 9387 0924 00000000 		.word	0
 9388 0928 00000000 		.word	0
 9389 092c 0394731E 		.word	510891011
 9390 0930 04000020 		.word	536870916
 9391 0934 60004080 		.word	-2143289248
 9392 0938 00000000 		.word	0
 9393 093c 00000000 		.word	0
 9394 0940 00000000 		.word	0
 9395 0944 0620702E 		.word	779100166
 9396 0948 0C000000 		.word	12
 9397 094c 00000080 		.word	-2147483648
 9398 0950 0620702E 		.word	779100166
 9399 0954 0C000000 		.word	12
 9400 0958 00000080 		.word	-2147483648
 9401 095c 0394731E 		.word	510891011
 9402 0960 04000020 		.word	536870916
 9403 0964 60004080 		.word	-2143289248
 9404 0968 0620702E 		.word	779100166
 9405 096c 0C000000 		.word	12
 9406 0970 00000080 		.word	-2147483648
 9407 0974 0C93731E 		.word	510890764
 9408 0978 04000024 		.word	603979780
 9409 097c 90004080 		.word	-2143289200
 9410 0980 0D20702E 		.word	779100173
 9411 0984 0C000000 		.word	12
 9412 0988 00000080 		.word	-2147483648
 9413 098c 0780724E 		.word	1316126727
 9414 0990 0A000000 		.word	10
 9415 0994 00000080 		.word	-2147483648
 9416 0998 08000000 		.word	8
 9417 099c 00000000 		.word	0
 9418 09a0 00010080 		.word	-2147483392
 9419 09a4 0920702E 		.word	779100169
 9420 09a8 0C010000 		.word	268
 9421 09ac 00000080 		.word	-2147483648
 9422 09b0 0A01701E 		.word	510656778
 9423 09b4 0E000100 		.word	65550
 9424 09b8 00000080 		.word	-2147483648
 9425 09bc 00000000 		.word	0
 9426 09c0 00000000 		.word	0
 9427 09c4 00000000 		.word	0
 9428 09c8 00000000 		.word	0
 9429 09cc 00000000 		.word	0
 9430 09d0 00000000 		.word	0
 9431 09d4 0394731E 		.word	510891011
 9432 09d8 04000020 		.word	536870916
 9433 09dc 60004080 		.word	-2143289248
 9434 09e0 08000000 		.word	8
 9435 09e4 00000000 		.word	0
 9436 09e8 00010080 		.word	-2147483392
 9437 09ec 0B000000 		.word	11
 9438 09f0 00000000 		.word	0
 9439 09f4 00010080 		.word	-2147483392
 9440 09f8 0C93731E 		.word	510890764
 9441 09fc 04000024 		.word	603979780
 9442 0a00 90004080 		.word	-2143289200
 9443 0a04 0D20702E 		.word	779100173
 9444 0a08 0C000000 		.word	12
 9445 0a0c 00000080 		.word	-2147483648
 9446 0a10 0D20702E 		.word	779100173
 9447 0a14 0C000000 		.word	12
 9448 0a18 00000080 		.word	-2147483648
 9449 0a1c 0E60724E 		.word	1316118542
 9450 0a20 0A000000 		.word	10
 9451 0a24 00000080 		.word	-2147483648
 9452 0a28 0F000000 		.word	15
 9453 0a2c 00000000 		.word	0
 9454 0a30 00010080 		.word	-2147483392
 9455 0a34 1020702E 		.word	779100176
 9456 0a38 0C010000 		.word	268
 9457 0a3c 00000080 		.word	-2147483648
 9458 0a40 1101701E 		.word	510656785
 9459 0a44 0E000100 		.word	65550
 9460 0a48 00000080 		.word	-2147483648
 9461 0a4c 0C93731E 		.word	510890764
 9462 0a50 04000024 		.word	603979780
 9463 0a54 90004080 		.word	-2143289200
 9464 0a58 0F000000 		.word	15
 9465 0a5c 00000000 		.word	0
 9466 0a60 00010080 		.word	-2147483392
 9467 0a64 12000000 		.word	18
 9468 0a68 00000000 		.word	0
 9469 0a6c 00010080 		.word	-2147483392
 9470 0a70 0394731E 		.word	510891011
 9471 0a74 04000020 		.word	536870916
 9472 0a78 60004080 		.word	-2143289248
 9473 0a7c 0480732E 		.word	779321348
 9474 0a80 02010000 		.word	258
 9475 0a84 0000C0C0 		.word	-1061158912
 9476 0a88 0580732E 		.word	779321349
 9477 0a8c 02010000 		.word	258
 9478 0a90 0000C0C0 		.word	-1061158912
 9479 0a94 0580732E 		.word	779321349
 9480 0a98 02010000 		.word	258
 9481 0a9c 0000C0C0 		.word	-1061158912
 9482 0aa0 0480732E 		.word	779321348
 9483 0aa4 02010000 		.word	258
 9484 0aa8 0000C0C0 		.word	-1061158912
 9487              	CyFxGpifWavedataPosition_usb2:
 9488 0aac 00       		.byte	0
 9489 0aad 01       		.byte	1
 9490 0aae 02       		.byte	2
 9491 0aaf 03       		.byte	3
 9492 0ab0 04       		.byte	4
 9493 0ab1 05       		.byte	5
 9494 0ab2 06       		.byte	6
 9495 0ab3 07       		.byte	7
 9496 0ab4 08       		.byte	8
 9497 0ab5 09       		.byte	9
 9498 0ab6 0A       		.byte	10
 9499 0ab7 08       		.byte	8
 9500 0ab8 0B       		.byte	11
 9501 0ab9 0C       		.byte	12
 9502 0aba 0D       		.byte	13
 9503 0abb 08       		.byte	8
 9504 0abc 0E       		.byte	14
 9505 0abd 0F       		.byte	15
 9506 0abe 08       		.byte	8
 9507 0abf 08       		.byte	8
 9508 0ac0 08       		.byte	8
 9509 0ac1 08       		.byte	8
 9510 0ac2 08       		.byte	8
 9511 0ac3 08       		.byte	8
 9512 0ac4 08       		.byte	8
 9513 0ac5 08       		.byte	8
 9514 0ac6 08       		.byte	8
 9515 0ac7 08       		.byte	8
 9516 0ac8 08       		.byte	8
 9517 0ac9 08       		.byte	8
 9518 0aca 08       		.byte	8
 9519 0acb 08       		.byte	8
 9520 0acc 08       		.byte	8
 9521 0acd 08       		.byte	8
 9522 0ace 08       		.byte	8
 9523 0acf 08       		.byte	8
 9524 0ad0 08       		.byte	8
 9525 0ad1 08       		.byte	8
 9526 0ad2 08       		.byte	8
 9527 0ad3 08       		.byte	8
 9528 0ad4 08       		.byte	8
 9529 0ad5 08       		.byte	8
 9530 0ad6 08       		.byte	8
 9531 0ad7 08       		.byte	8
 9532 0ad8 08       		.byte	8
 9533 0ad9 08       		.byte	8
 9534 0ada 08       		.byte	8
 9535 0adb 08       		.byte	8
 9536 0adc 08       		.byte	8
 9537 0add 08       		.byte	8
 9538 0ade 08       		.byte	8
 9539 0adf 08       		.byte	8
 9540 0ae0 08       		.byte	8
 9541 0ae1 08       		.byte	8
 9542 0ae2 08       		.byte	8
 9543 0ae3 08       		.byte	8
 9544 0ae4 08       		.byte	8
 9545 0ae5 08       		.byte	8
 9546 0ae6 08       		.byte	8
 9547 0ae7 08       		.byte	8
 9548 0ae8 08       		.byte	8
 9549 0ae9 08       		.byte	8
 9550 0aea 08       		.byte	8
 9551 0aeb 08       		.byte	8
 9552 0aec 08       		.byte	8
 9553 0aed 08       		.byte	8
 9554 0aee 08       		.byte	8
 9555 0aef 08       		.byte	8
 9556 0af0 08       		.byte	8
 9557 0af1 08       		.byte	8
 9558 0af2 08       		.byte	8
 9559 0af3 08       		.byte	8
 9560 0af4 08       		.byte	8
 9561 0af5 08       		.byte	8
 9562 0af6 08       		.byte	8
 9563 0af7 08       		.byte	8
 9564 0af8 08       		.byte	8
 9565 0af9 08       		.byte	8
 9566 0afa 08       		.byte	8
 9567 0afb 08       		.byte	8
 9568 0afc 08       		.byte	8
 9569 0afd 08       		.byte	8
 9570 0afe 08       		.byte	8
 9571 0aff 08       		.byte	8
 9572 0b00 08       		.byte	8
 9573 0b01 08       		.byte	8
 9574 0b02 08       		.byte	8
 9575 0b03 08       		.byte	8
 9576 0b04 08       		.byte	8
 9577 0b05 08       		.byte	8
 9578 0b06 08       		.byte	8
 9579 0b07 08       		.byte	8
 9580 0b08 08       		.byte	8
 9581 0b09 08       		.byte	8
 9582 0b0a 08       		.byte	8
 9583 0b0b 08       		.byte	8
 9584 0b0c 08       		.byte	8
 9585 0b0d 08       		.byte	8
 9586 0b0e 08       		.byte	8
 9587 0b0f 08       		.byte	8
 9588 0b10 08       		.byte	8
 9589 0b11 08       		.byte	8
 9590 0b12 08       		.byte	8
 9591 0b13 08       		.byte	8
 9592 0b14 08       		.byte	8
 9593 0b15 08       		.byte	8
 9594 0b16 08       		.byte	8
 9595 0b17 08       		.byte	8
 9596 0b18 08       		.byte	8
 9597 0b19 08       		.byte	8
 9598 0b1a 08       		.byte	8
 9599 0b1b 08       		.byte	8
 9600 0b1c 08       		.byte	8
 9601 0b1d 08       		.byte	8
 9602 0b1e 08       		.byte	8
 9603 0b1f 08       		.byte	8
 9604 0b20 08       		.byte	8
 9605 0b21 08       		.byte	8
 9606 0b22 08       		.byte	8
 9607 0b23 08       		.byte	8
 9608 0b24 08       		.byte	8
 9609 0b25 08       		.byte	8
 9610 0b26 08       		.byte	8
 9611 0b27 08       		.byte	8
 9612 0b28 08       		.byte	8
 9613 0b29 08       		.byte	8
 9614 0b2a 08       		.byte	8
 9615 0b2b 08       		.byte	8
 9616 0b2c 00       		.byte	0
 9617 0b2d 01       		.byte	1
 9618 0b2e 02       		.byte	2
 9619 0b2f 10       		.byte	16
 9620 0b30 04       		.byte	4
 9621 0b31 05       		.byte	5
 9622 0b32 06       		.byte	6
 9623 0b33 07       		.byte	7
 9624 0b34 08       		.byte	8
 9625 0b35 09       		.byte	9
 9626 0b36 0A       		.byte	10
 9627 0b37 08       		.byte	8
 9628 0b38 11       		.byte	17
 9629 0b39 0C       		.byte	12
 9630 0b3a 0D       		.byte	13
 9631 0b3b 08       		.byte	8
 9632 0b3c 0E       		.byte	14
 9633 0b3d 0F       		.byte	15
 9634 0b3e 08       		.byte	8
 9635 0b3f 00       		.space	1
 9638              	CyFxGpifRegValue_usb2:
 9639 0b40 08830080 		.word	-2147450104
 9640 0b44 67000000 		.word	103
 9641 0b48 01000000 		.word	1
 9642 0b4c 46000000 		.word	70
 9643 0b50 00000000 		.word	0
 9644 0b54 00000000 		.word	0
 9645 0b58 02000000 		.word	2
 9646 0b5c 82000000 		.word	130
 9647 0b60 82070000 		.word	1922
 9648 0b64 40040000 		.word	1088
 9649 0b68 FCFF0000 		.word	65532
 9650 0b6c 28000000 		.word	40
 9651 0b70 00000000 		.word	0
 9652 0b74 00000000 		.word	0
 9653 0b78 00000000 		.word	0
 9654 0b7c 00000000 		.word	0
 9655 0b80 01000000 		.word	1
 9656 0b84 00000000 		.word	0
 9657 0b88 00000000 		.word	0
 9658 0b8c 00000000 		.word	0
 9659 0b90 00000000 		.word	0
 9660 0b94 00000000 		.word	0
 9661 0b98 00000000 		.word	0
 9662 0b9c 00000000 		.word	0
 9663 0ba0 00000000 		.word	0
 9664 0ba4 00000000 		.word	0
 9665 0ba8 00000000 		.word	0
 9666 0bac 00000000 		.word	0
 9667 0bb0 00000000 		.word	0
 9668 0bb4 06000000 		.word	6
 9669 0bb8 00000000 		.word	0
 9670 0bbc FFFF0000 		.word	65535
 9671 0bc0 09010000 		.word	265
 9672 0bc4 00000000 		.word	0
 9673 0bc8 F71F0000 		.word	8183
 9674 0bcc 00000000 		.word	0
 9675 0bd0 FFFF0000 		.word	65535
 9676 0bd4 09010000 		.word	265
 9677 0bd8 00000000 		.word	0
 9678 0bdc F71F0000 		.word	8183
 9679 0be0 00000000 		.word	0
 9680 0be4 00000000 		.word	0
 9681 0be8 00000000 		.word	0
 9682 0bec 00000000 		.word	0
 9683 0bf0 00000000 		.word	0
 9684 0bf4 00000000 		.word	0
 9685 0bf8 00000000 		.word	0
 9686 0bfc 00000000 		.word	0
 9687 0c00 00000000 		.word	0
 9688 0c04 00000000 		.word	0
 9689 0c08 00000000 		.word	0
 9690 0c0c 00000000 		.word	0
 9691 0c10 00000000 		.word	0
 9692 0c14 00000000 		.word	0
 9693 0c18 00000000 		.word	0
 9694 0c1c 00000000 		.word	0
 9695 0c20 00000000 		.word	0
 9696 0c24 00000000 		.word	0
 9697 0c28 00000000 		.word	0
 9698 0c2c 00000000 		.word	0
 9699 0c30 00000000 		.word	0
 9700 0c34 00000000 		.word	0
 9701 0c38 00000000 		.word	0
 9702 0c3c 00040180 		.word	-2147417088
 9703 0c40 01040180 		.word	-2147417087
 9704 0c44 02040180 		.word	-2147417086
 9705 0c48 03040180 		.word	-2147417085
 9706 0c4c 00000000 		.word	0
 9707 0c50 00000000 		.word	0
 9708 0c54 00000000 		.word	0
 9709 0c58 00000000 		.word	0
 9710 0c5c 00000000 		.word	0
 9711 0c60 00000000 		.word	0
 9712 0c64 00000000 		.word	0
 9713 0c68 00000000 		.word	0
 9714 0c6c C1FFFFFF 		.word	-63
 9715              		.section	.rodata.str1.4,"aMS",%progbits,1
 9716              		.align	2
 9717              	.LC0:
 9718 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9718      7065722D 
 9718      74696D65 
 9718      72202564 
 9718      0D0A00
 9719 0013 00       		.space	1
 9720              	.LC1:
 9721 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9721      636F6D6D 
 9721      616E6420 
 9721      71756575 
 9721      65206973 
 9722 0037 00       		.space	1
 9723              	.LC2:
 9724 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9724      5420656E 
 9724      636F756E 
 9724      74657265 
 9724      642E2E2E 
 9725              	.LC3:
 9726 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9726      454E4420 
 9726      656E636F 
 9726      756E7465 
 9726      7265642E 
 9727 007a 0000     		.space	2
 9728              	.LC4:
 9729 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9729      64697363 
 9729      6F6E6E65 
 9729      63746564 
 9729      2E2E2E30 
 9730 009b 00       		.space	1
 9731              	.LC5:
 9732 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9732      7220696E 
 9732      206D756C 
 9732      74696368 
 9732      616E6E65 
 9733 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9733      2025782C 
 9733      20646D61 
 9733      446F6E65 
 9733      20256420 
 9734              	.LC6:
 9735 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9735      43595F46 
 9735      585F5556 
 9735      435F5649 
 9735      44454F5F 
 9736 011b 0A00     		.ascii	"\012\000"
 9737 011d 000000   		.space	3
 9738              	.LC7:
 9739 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9739      43595F46 
 9739      585F5556 
 9739      435F5649 
 9739      44454F5F 
 9740 0153 00       		.ascii	"\000"
 9741              	.LC8:
 9742 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9742      726E6174 
 9742      65207365 
 9742      7474696E 
 9742      6720302E 
 9743              	.LC9:
 9744 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9744      72206665 
 9744      61747572 
 9744      65207265 
 9744      71756573 
 9745 018f 00       		.space	1
 9746              	.LC10:
 9747 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9747      6F6D6D69 
 9747      74656F66 
 9747      20737461 
 9747      7465203D 
 9748              	.LC11:
 9749 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9749      6E656C20 
 9749      53657420 
 9749      57726170 
 9749      55702066 
 9750 01d5 000000   		.space	3
 9751              	.LC12:
 9752 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9752      72206861 
 9752      6E646C65 
 9752      722E2E2E 
 9752      0D0A00
 9753 01eb 00       		.space	1
 9754              	.LC13:
 9755 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9755      69742045 
 9755      4F462066 
 9755      61696C65 
 9755      64210D0A 
 9756 0201 000000   		.space	3
 9757              	.LC14:
 9758 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9758      49324320 
 9758      636F6D6D 
 9758      616E6420 
 9758      69732030 
 9759 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9759      78257820 
 9759      30782578 
 9759      20307825 
 9759      78203078 
 9760              	.LC15:
 9761 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 9761      49324320 
 9761      636F6D6D 
 9761      616E6420 
 9761      73657474 
 9762 0276 0000     		.space	2
 9763              	.LC16:
 9764 0278 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9764      206C6967 
 9764      68742063 
 9764      6F6D7065 
 9764      6E736174 
 9765 02ab 25640D0A 		.ascii	"%d\015\012\000"
 9765      00
 9766              	.LC17:
 9767 02b0 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9767      49324320 
 9767      63757272 
 9767      656E7420 
 9767      64617461 
 9768 02e3 64202564 		.ascii	"d %d\015\012\000"
 9768      0D0A00
 9769 02ea 0000     		.space	2
 9770              	.LC18:
 9771 02ec 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9771      26414743 
 9771      2073656E 
 9771      7420746F 
 9771      20686F73 
 9772 0312 0000     		.space	2
 9773              	.LC19:
 9774 0314 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9774      26414743 
 9774      20676F74 
 9774      74656E20 
 9774      66726F6D 
 9775 033e 0000     		.space	2
 9776              	.LC20:
 9777 0340 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9777      67657420 
 9777      64617461 
 9777      2066726F 
 9777      6D20686F 
 9778 036d 000000   		.space	3
 9779              	.LC21:
 9780 0370 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9780      52657175 
 9780      65737420 
 9780      30782578 
 9780      20706172 
 9781 03a3 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9781      6E642074 
 9781      6F20686F 
 9781      73742030 
 9781      78257820 
 9782 03be 0000     		.space	2
 9783              	.LC22:
 9784 03c0 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9784      204F7020 
 9784      72656365 
 9784      69766573 
 9784      20284354 
 9785 03e7 00       		.space	1
 9786              	.LC23:
 9787 03e8 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9787      756C7420 
 9787      73656C65 
 9787      63746F72 
 9787      20284354 
 9788 040a 0000     		.space	2
 9789              	.LC24:
 9790 040c 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9790      756C7420 
 9790      72657175 
 9790      65737420 
 9790      28435429 
 9791 042d 000000   		.space	3
 9792              	.LC25:
 9793 0430 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9793      52657175 
 9793      65737420 
 9793      30782578 
 9793      20706172 
 9794 0463 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9794      20307825 
 9794      78202F20 
 9794      73656E64 
 9794      20746F20 
 9795 0490 00       		.ascii	"\000"
 9796 0491 000000   		.space	3
 9797              	.LC26:
 9798 0494 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9798      73706565 
 9798      64203D20 
 9798      25642065 
 9798      76656E66 
 9799 04c4 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9799      71756573 
 9799      74203D20 
 9799      30782578 
 9799      20775661 
 9800 04f4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9800      203D2030 
 9800      78257820 
 9800      6973666C 
 9800      61672030 
 9801 050e 0000     		.space	2
 9802              	.LC27:
 9803 0510 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9803      64656661 
 9803      756C7420 
 9803      73657475 
 9803      70207265 
 9804              	.LC28:
 9805 053c 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 9805      6F207374 
 9805      7265616D 
 9805      20474554 
 9805      20726571 
 9806 0561 000000   		.space	3
 9807              	.LC29:
 9808 0564 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9808      43595F46 
 9808      585F5556 
 9808      435F5354 
 9808      5245414D 
 9809 058a 0000     		.space	2
 9810              	.LC30:
 9811 058c 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 9811      55564320 
 9811      7374696C 
 9811      6C205072 
 9811      6F622873 
 9812 05b7 00       		.space	1
 9813              	.LC31:
 9814 05b8 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 9814      7374696C 
 9814      6C20636F 
 9814      6D6D6974 
 9814      20636F6E 
 9815              	.LC32:
 9816 05e0 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 9816      55564320 
 9816      7374696C 
 9816      6C207472 
 9816      69676765 
 9817 0609 000000   		.space	3
 9818              	.LC33:
 9819 060c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9819      7374696C 
 9819      6C207472 
 9819      69676765 
 9819      7220636F 
 9820 0633 00       		.space	1
 9821              	.LC34:
 9822 0634 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9822      65642074 
 9822      6F207365 
 9822      6E642069 
 9822      6E746572 
 9823 0665 0A00     		.ascii	"\012\000"
 9824 0667 00       		.space	1
 9825              	.LC35:
 9826 0668 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9826      73657420 
 9826      64656620 
 9826      64617461 
 9826      20307825 
 9827 0687 00       		.space	1
 9828              	.LC36:
 9829 0688 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9829      73657420 
 9829      64656620 
 9829      64617461 
 9829      20307825 
 9830 06bb 2E0D0A00 		.ascii	".\015\012\000"
 9831 06bf 00       		.space	1
 9832              	.LC37:
 9833 06c0 55415254 		.ascii	"UART initialization failed!\012\000"
 9833      20696E69 
 9833      7469616C 
 9833      697A6174 
 9833      696F6E20 
 9834 06dd 000000   		.space	3
 9835              	.LC38:
 9836 06e0 49324320 		.ascii	"I2C initialization failed!\012\000"
 9836      696E6974 
 9836      69616C69 
 9836      7A617469 
 9836      6F6E2066 
 9837              	.LC39:
 9838 06fc 49324320 		.ascii	"I2C configuration failed!\012\000"
 9838      636F6E66 
 9838      69677572 
 9838      6174696F 
 9838      6E206661 
 9839 0717 00       		.space	1
 9840              	.LC40:
 9841 0718 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9841      43726561 
 9841      74652045 
 9841      76656E74 
 9841      20666169 
 9842 0742 0000     		.space	2
 9843              	.LC41:
 9844 0744 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9844      20496E69 
 9844      74206661 
 9844      696C6564 
 9844      2C204572 
 9845 0767 00       		.space	1
 9846              	.LC42:
 9847 0768 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9847      204F7665 
 9847      72726964 
 9847      65206661 
 9847      696C6564 
 9848 078f 00       		.space	1
 9849              	.LC43:
 9850 0790 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9850      28323029 
 9850      204F7665 
 9850      72726964 
 9850      65206661 
 9851 07bb 00       		.space	1
 9852              	.LC44:
 9853 07bc 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9853      28323429 
 9853      204F7665 
 9853      72726964 
 9853      65206661 
 9854 07e7 00       		.space	1
 9855              	.LC45:
 9856 07e8 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9856      20536574 
 9856      20287265 
 9856      73657420 
 9856      32322920 
 9857 081a 00       		.ascii	"\000"
 9858 081b 00       		.space	1
 9859              	.LC46:
 9860 081c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9860      20536574 
 9860      2028706F 
 9860      77657220 
 9860      32302920 
 9861 084e 00       		.ascii	"\000"
 9862 084f 00       		.space	1
 9863              	.LC47:
 9864 0850 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9864      20536574 
 9864      2028736E 
 9864      61702073 
 9864      686F7420 
 9865 0883 25640A00 		.ascii	"%d\012\000"
 9866 0887 00       		.space	1
 9867              	.LC48:
 9868 0888 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9868      46756E63 
 9868      74696F6E 
 9868      20466169 
 9868      6C656420 
 9869 08b7 00       		.space	1
 9870              	.LC49:
 9871 08b8 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9871      46756E63 
 9871      74696F6E 
 9871      20466169 
 9871      6C656420 
 9872 08e7 00       		.space	1
 9873              	.LC50:
 9874 08e8 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9874      53657420 
 9874      456E6470 
 9874      6F696E74 
 9874      20636F6E 
 9875 0918 00       		.ascii	"\000"
 9876 0919 000000   		.space	3
 9877              	.LC51:
 9878 091c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9878      496E7465 
 9878      72727570 
 9878      74205374 
 9878      61747573 
 9879 094f 20436F64 		.ascii	" Code = %d\012\000"
 9879      65203D20 
 9879      25640A00 
 9880 095b 00       		.space	1
 9881              	.LC52:
 9882 095c 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9882      65642074 
 9882      6F20616C 
 9882      6C6F6361 
 9882      7465206D 
 9883 098f 65720D0A 		.ascii	"er\015\012\000"
 9883      00
 9884              	.LC53:
 9885 0994 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9885      4368616E 
 9885      6E656C20 
 9885      43726561 
 9885      74696F6E 
 9886 09c2 0000     		.space	2
 9887              	.LC54:
 9888 09c4 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9888      436F6E6E 
 9888      65637420 
 9888      6661696C 
 9888      65642C20 
 9889 09e9 000000   		.space	3
 9890              	.LC55:
 9891 09ec 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9891      4368616E 
 9891      6E656C20 
 9891      52657365 
 9891      74204661 
 9892 0a17 00       		.space	1
 9893              	.LC56:
 9894 0a18 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9894      4368616E 
 9894      6E656C20 
 9894      53657420 
 9894      5472616E 
 9895 0a49 00       		.ascii	"\000"
 9896 0a4a 0000     		.space	2
 9897              	.LC57:
 9898 0a4c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9898      4368616E 
 9898      6E656C20 
 9898      53657420 
 9898      5472616E 
 9899 0a7d 0A00     		.ascii	"\012\000"
 9900 0a7f 00       		.space	1
 9901              	.LC58:
 9902 0a80 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9902      75706572 
 9902      20677069 
 9902      6600
 9903 0a8e 0000     		.space	2
 9904              	.LC59:
 9905 0a90 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9905      69676820 
 9905      67706966 
 9905      00
 9906 0a9d 000000   		.space	3
 9907              	.LC60:
 9908 0aa0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9908      696E6720 
 9908      47504946 
 9908      20436F6E 
 9908      66696775 
 9909 0ad3 0A00     		.ascii	"\012\000"
 9910 0ad5 000000   		.space	3
 9911              	.LC61:
 9912 0ad8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9912      74696E67 
 9912      20475049 
 9912      46207374 
 9912      61746520 
 9913 0b0b 0D0A00   		.ascii	"\015\012\000"
 9914 0b0e 0000     		.space	2
 9915              	.LC62:
 9916 0b10 33303A55 		.ascii	"30:UVC App Thread\000"
 9916      56432041 
 9916      70702054 
 9916      68726561 
 9916      6400
 9917 0b22 0000     		.space	2
 9918              	.LC63:
 9919 0b24 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9919      56432041 
 9919      70702045 
 9919      50302054 
 9919      68726561 
 9920 0b3a 0000     		.space	2
 9921              	.LC64:
 9922 0b3c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9922      32432041 
 9922      70702043 
 9922      54524C20 
 9922      54687265 
 9923 0b53 00       		.bss
 9924              		.align	2
 9925              		.set	.LANCHOR0,. + 0
 9928              	glFxUVCEvent:
 9929 0000 00000000 		.space	40
 9929      00000000 
 9929      00000000 
 9929      00000000 
 9929      00000000 
 9932              	gpif_initialized:
 9933 0028 00000000 		.space	4
 9936              	streamingStarted:
 9937 002c 00000000 		.space	4
 9940              	isUsbConnected:
 9941 0030 00000000 		.space	4
 9944              	fb:
 9945 0034 0000     		.space	2
 9948              	pb:
 9949 0036 0000     		.space	2
 9952              	pbc:
 9953 0038 0000     		.space	2
 9956              	stiflag:
 9957 003a 00       		.space	1
 9958 003b 00       		.space	1
 9961              	hitFV:
 9962 003c 00000000 		.space	4
 9965              	prodCount:
 9966 0040 0000     		.space	2
 9969              	consCount:
 9970 0042 0000     		.space	2
 9973              	clearFeatureRqtReceived:
 9974 0044 00000000 		.space	4
 9977              	usbSpeed:
 9978 0048 00       		.space	1
 9979 0049 000000   		.space	3
 9982              	I2CCMDArry:
 9983 004c 00000000 		.space	12
 9983      00000000 
 9983      00000000 
 9986              	is60Hz:
 9987 0058 00000000 		.space	4
 9990              	glEp0Buffer:
 9991 005c 00000000 		.space	32
 9991      00000000 
 9991      00000000 
 9991      00000000 
 9991      00000000 
 9994              	CamMode:
 9995 007c 00       		.space	1
 9998              	setRes:
 9999 007d 00       		.space	1
 10000 007e 0000     		.space	2
 10003              	glCommitCtrl:
 10004 0080 00000000 		.space	32
 10004      00000000 
 10004      00000000 
 10004      00000000 
 10004      00000000 
 10007              	setstilRes:
 10008 00a0 00       		.space	1
 10011              	IMcount.7789:
 10012 00a1 00       		.space	1
 10013 00a2 0000     		.space	2
 10016              	uvcAppThread:
 10017 00a4 00000000 		.space	168
 10017      00000000 
 10017      00000000 
 10017      00000000 
 10017      00000000 
 10020              	uvcAppEP0Thread:
 10021 014c 00000000 		.space	168
 10021      00000000 
 10021      00000000 
 10021      00000000 
 10021      00000000 
 10024              	i2cAppThread:
 10025 01f4 00000000 		.space	168
 10025      00000000 
 10025      00000000 
 10025      00000000 
 10025      00000000 
 10028              	testSnap:
 10029 029c 00       		.space	1
 10030 029d 00       		.space	1
 10033              	fbbak:
 10034 029e 0000     		.space	2
 10037              	pbbak:
 10038 02a0 0000     		.space	2
 10041              	pbcbak:
 10042 02a2 0000     		.space	2
 10045              	pbcpbak:
 10046 02a4 0000     		.space	2
 10047 02a6 0000     		.text
 10048              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1461   .text:00000bb8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1469   .text:00000bcc $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1472   .text:00000bcc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1535   .text:00000c4c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1742   .text:00000de8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1780   .text:00000e74 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1844   .text:00000ef8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:1880   .text:00000f80 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3148   .text:00001b54 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3166   .text:00001b90 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3169   .text:00001b90 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3337   .text:00001cec $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3350   .text:00001d14 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3845   .text:00002224 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:3856   .text:00002244 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:4111   .text:000024fc $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:4124   .text:00002524 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:4127   .text:00002524 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:4189   .text:000025a0 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:4197   .text:000025b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5490   .text:000030d0 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5521   .text:00003138 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5524   .text:00003138 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5815   .text:000033f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5822   .text:00003400 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5825   .text:00003400 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5866   .text:00003444 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5871   .text:0000344c $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5874   .text:0000344c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5899   .text:00003468 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5903   .text:0000346c $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:5906   .text:0000346c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7315   .text:00003fbc $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7373   .text:00004098 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7376   .text:00004098 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7533   .text:00004210 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7549   .text:00004244 $a
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7552   .text:00004244 main
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9183   .data:00000680 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9192   .data:0000068c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9267   .data:000007ac CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9286   .data:000007bc CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7715   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9365   .data:000008ec CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9376   .data:000008fc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9487   .data:00000aac CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9638   .data:00000b40 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7728   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9179   .data:0000067f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10028  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9944   .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9948   .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9952   .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10033  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10037  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10041  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10045  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9940   .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9977   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9973   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9936   .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9120   .data:0000064c glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9060   .data:00000614 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9150   .data:00000668 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9090   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9165   .data:00000674 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:8710   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7692   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7696   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7740   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:7744   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:8067   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:8725   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:8730   .data:00000490 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:8737   .data:00000494 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9716   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9924   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9928   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9932   .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9956   .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9961   .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9965   .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9969   .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9982   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9986   .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9990   .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9994   .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:9998   .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10003  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10007  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10011  .bss:000000a1 IMcount.7789
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10016  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10020  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccCpc0Si.s:10024  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
