   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0,
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x22,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x22, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x22,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x22,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** /*
 594:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 595:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 596:../uvc.c      ****  */
 597:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 598:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 599:../uvc.c      **** };
 600:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 601:../uvc.c      **** 		0
 602:../uvc.c      **** };
 603:../uvc.c      **** 
 604:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 605:../uvc.c      **** 
 606:../uvc.c      **** void I2CCmdHandler(){
 607:../uvc.c      **** 	uint8_t buf[2];
 608:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 612:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 613:../uvc.c      **** 	uint8_t i;
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 615:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 616:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 618:../uvc.c      **** 	{
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 621:../uvc.c      **** 			{
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 623:../uvc.c      **** 			}
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 625:../uvc.c      **** 
 626:../uvc.c      **** 	}
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 628:../uvc.c      **** 	{
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 630:../uvc.c      **** #if 0 //for debugging
 631:../uvc.c      **** 		/* test still image operation */
 632:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 633:../uvc.c      **** 			snapButFlag = 0; //press
 634:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 635:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 636:../uvc.c      **** 			snapButFlag = 0xf; //release
 637:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 638:../uvc.c      **** 		}
 639:../uvc.c      **** 
 640:../uvc.c      **** 		/* end of the test */
 641:../uvc.c      **** #endif
 642:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 647:../uvc.c      **** 				}
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 649:../uvc.c      **** 		}else{//not support currently
 650:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 651:../uvc.c      **** 		}
 652:../uvc.c      **** 	}else if(CmdType == 1){
 653:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 655:../uvc.c      **** 				for(i = 0; i<4; i++)
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else{
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 663:../uvc.c      **** 				}
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 665:../uvc.c      **** 			}
 666:../uvc.c      **** 		}else{//not support currently
 667:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 	}
 671:../uvc.c      **** }
 672:../uvc.c      **** 
 673:../uvc.c      **** /************************************
 674:../uvc.c      ****  * set Iris mode
 675:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 676:../uvc.c      ****  */
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 678:../uvc.c      **** 	uint8_t dataIdx = 0;
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 683:../uvc.c      **** }
 684:../uvc.c      **** 
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 688:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 689:../uvc.c      **** 	uint16_t NumLn;
 690:../uvc.c      **** 	uint16_t fRate, shutTm;
 691:../uvc.c      **** 	uint8_t LnVal;
 692:../uvc.c      **** 	switch (Data){
 693:../uvc.c      **** 	case 1:
 694:../uvc.c      **** 	case 2:
 695:../uvc.c      **** 	case 3:
 696:../uvc.c      **** 	case 4:
 697:../uvc.c      **** 	case 5:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 699:../uvc.c      **** 		fRate = 30;
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 701:../uvc.c      **** 		if(NumLn > 1944)
 702:../uvc.c      **** 			NumLn =1944;
 703:../uvc.c      **** 		else if(NumLn < 8)
 704:../uvc.c      **** 			NumLn = 8;
 705:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 706:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 707:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 708:../uvc.c      **** 		break;
 709:../uvc.c      **** 	case 6:
 710:../uvc.c      **** 	case 7:
 711:../uvc.c      **** 	case 8:
 712:../uvc.c      **** 	case 9:
 713:../uvc.c      **** 	case 10:
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 715:../uvc.c      **** 		fRate = 30;
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 717:../uvc.c      **** 		if(NumLn > 1944)
 718:../uvc.c      **** 			NumLn =1944;
 719:../uvc.c      **** 		else if(NumLn < 8)
 720:../uvc.c      **** 			NumLn = 8;
 721:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 724:../uvc.c      **** 		break;
 725:../uvc.c      **** 	case 0: //auto
 726:../uvc.c      **** 	default:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 728:../uvc.c      **** 		LnVal = 1;
 729:../uvc.c      **** 		break;
 730:../uvc.c      **** 	}
 731:../uvc.c      **** 	return LnVal;
 732:../uvc.c      **** }
 733:../uvc.c      **** 
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 736:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 737:../uvc.c      ****     uint16_t readCount;
 738:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 739:../uvc.c      ****     uint8_t devAdd;
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 746:../uvc.c      ****     }else{
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 751:../uvc.c      ****     }
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 754:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 755:../uvc.c      **** #endif
 756:../uvc.c      ****     reqData = bRequest;
 757:../uvc.c      ****     /*
 758:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 759:../uvc.c      ****      */
 760:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 761:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 762:../uvc.c      ****     	goto EndofSet;
 763:../uvc.c      ****     }
 764:../uvc.c      ****     switch (bRequest)
 765:../uvc.c      **** 		 {
 766:../uvc.c      **** 
 767:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 772:../uvc.c      **** 			  break;
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 774:../uvc.c      **** 
 775:../uvc.c      **** 			 switch(CtrlID)
 776:../uvc.c      **** 			 {
 777:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 778:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 779:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 780:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 781:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 782:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 783:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 784:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 785:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 786:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 787:../uvc.c      **** 			 	 		 break;
 788:../uvc.c      **** 			 	 }
 789:../uvc.c      **** 			 	 case ExtShutCtlID0:
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 791:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 793:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 794:../uvc.c      **** 			 		 break;
 795:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 797:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 799:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 800:../uvc.c      **** 			 		 break;
 801:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 802:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 804:../uvc.c      **** 						if(sendData >= 3){
 805:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 806:../uvc.c      **** 							sendData = 0; //set back to default
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 808:../uvc.c      **** 						}
 809:../uvc.c      **** 						sendData += 4;
 810:../uvc.c      **** 					 }
 811:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 812:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 814:../uvc.c      **** 					 break;
 815:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 818:../uvc.c      **** 			 		 }
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 820:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 821:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 822:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 823:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 824:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 825:../uvc.c      **** #endif
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 827:../uvc.c      **** 			 		 {
 828:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 829:../uvc.c      **** 			 		 }
 830:../uvc.c      **** 			 		 break;
 831:../uvc.c      **** 				 case ExtAexModCtlID9:
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 834:../uvc.c      **** 
 835:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 837:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 838:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 839:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 840:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 841:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 842:../uvc.c      **** 					 break;
 843:../uvc.c      **** 
 844:../uvc.c      **** 			 	 case BrgtCtlID1:
 845:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 846:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 847:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 848:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 849:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 850:../uvc.c      **** 					 }else{
 851:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 852:../uvc.c      **** 					 }
 853:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 854:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 855:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 856:../uvc.c      **** 					 */
 857:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 858:../uvc.c      **** 					  if(Data0&0x80){
 859:../uvc.c      **** 						  Data0 = ~Data0;
 860:../uvc.c      **** 					  }else{
 861:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 862:../uvc.c      **** 					  }
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 865:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 866:../uvc.c      **** 			 		 break;
 867:../uvc.c      **** 				 case HueCtlID5:
 868:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 871:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 872:../uvc.c      **** 					 break;
 873:../uvc.c      **** 				 case WBTLevCtlID11:
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 877:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 878:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 879:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 880:../uvc.c      **** 					 break;
 881:../uvc.c      **** 				 case BLCCtlID0:
 882:../uvc.c      **** 				 case ShapCtlID7:
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 884:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 885:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 886:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 887:../uvc.c      **** 					 break;
 888:../uvc.c      **** 				 case SaturCtlID6:
 889:../uvc.c      **** 				 default:
 890:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 891:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 892:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 893:../uvc.c      **** 					 break;
 894:../uvc.c      **** 			 }
 895:../uvc.c      **** 
 896:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 897:../uvc.c      **** 
 898:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 899:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 900:../uvc.c      **** #endif
 901:../uvc.c      **** 			  break;
 902:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 903:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 904:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 905:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 906:../uvc.c      **** 		 	 }
 907:../uvc.c      **** 
 908:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 909:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 910:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 911:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 912:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 913:../uvc.c      **** 			 }else
 914:../uvc.c      **** 			 {
 915:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 916:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 917:../uvc.c      **** 			 }
 918:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 919:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 920:../uvc.c      **** 			  break;
 921:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 922:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 923:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 924:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 925:../uvc.c      **** 		 	 }
 926:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 927:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 928:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 929:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 930:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 931:../uvc.c      **** 			 }else
 932:../uvc.c      **** 			 {
 933:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 934:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 935:../uvc.c      **** 			 }
 936:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 937:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 938:../uvc.c      **** 			  break;
 939:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 940:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 941:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 942:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 943:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 944:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 945:../uvc.c      **** 		 	 }
 946:../uvc.c      **** 		 	 else{
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 948:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 949:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 950:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 951:../uvc.c      **** 		 	 }
 952:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 953:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 954:../uvc.c      **** 			  break;
 955:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 956:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 957:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 958:../uvc.c      **** 		 	 }
 959:../uvc.c      **** 		 	 else{
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 961:../uvc.c      **** 		 	 }
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 963:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 964:../uvc.c      **** 			  Len = 1;
 965:../uvc.c      **** 			  break;
 966:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 967:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 968:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 969:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 970:../uvc.c      **** 		 	 }
 971:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 972:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 973:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 974:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 975:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 976:../uvc.c      **** 			 }else{
 977:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 978:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 979:../uvc.c      **** 			 }
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 981:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 982:../uvc.c      **** 			  break;
 983:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 984:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 985:../uvc.c      **** 				  glEp0Buffer, &readCount);
 986:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 987:../uvc.c      **** 			   {
 988:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 989:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 990:../uvc.c      **** 				  getData = glEp0Buffer[0];
 991:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 992:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 993:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 994:../uvc.c      **** #endif
 995:../uvc.c      **** 				  switch(CtrlID)
 996:../uvc.c      **** 					 {
 997:../uvc.c      **** 						 case ExtShutCtlID0:
 998:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 999:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1000:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1001:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1002:../uvc.c      **** #if 1	// register setting directly
1003:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1004:../uvc.c      **** 						     {
1005:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1006:../uvc.c      **** 						    	 dataIdx = 0;
1007:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1008:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1009:../uvc.c      **** 								 dataIdx++;
1010:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1011:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1012:../uvc.c      **** 						     }
1013:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1014:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1015:../uvc.c      **** 						     break;
1016:../uvc.c      **** #else	// old fashion
1017:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1018:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1019:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1020:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1021:../uvc.c      **** 									 }else{
1022:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1023:../uvc.c      **** 									 }
1024:../uvc.c      **** 								 }
1025:../uvc.c      **** 							 }else{
1026:../uvc.c      **** 								 Data1 = Data0 - 1;
1027:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1028:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1029:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1030:../uvc.c      **** 									 }else{
1031:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1032:../uvc.c      **** 									 }
1033:../uvc.c      **** 								 }
1034:../uvc.c      **** 								 if(Data1 < 8){
1035:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1036:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1037:../uvc.c      **** 								 }else{
1038:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1039:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1040:../uvc.c      **** 								 }
1041:../uvc.c      **** 							 }
1042:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1043:../uvc.c      **** 							 dataIdx = 0;
1044:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1045:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1046:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1047:../uvc.c      **** 							 if(AxMode){
1048:../uvc.c      **** 								 dataIdx++;
1049:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1050:../uvc.c      **** 								 dataIdx++;
1051:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1052:../uvc.c      **** 							 }
1053:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1054:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1055:../uvc.c      **** 							 break;
1056:../uvc.c      **** #endif
1057:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1058:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1059:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1060:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1061:../uvc.c      **** 						     dataIdx = 0;
1062:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1063:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1064:../uvc.c      **** 							 {
1065:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1066:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1067:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1068:../uvc.c      **** 								 /*
1069:../uvc.c      **** 								 dataIdx++;
1070:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1071:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1072:../uvc.c      **** 									 dataIdx++;
1073:../uvc.c      **** 								 }else{
1074:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1075:../uvc.c      **** 									 dataIdx++;
1076:../uvc.c      **** 								 }
1077:../uvc.c      **** 								 */
1078:../uvc.c      **** 							 }
1079:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1080:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1081:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1082:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1083:../uvc.c      **** 								 }
1084:../uvc.c      **** 							 }
1085:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1086:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1087:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1088:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1089:../uvc.c      **** 							 break;
1090:../uvc.c      **** 
1091:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1092:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1093:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1094:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1095:../uvc.c      **** 						     dataIdx = 0;
1096:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1097:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1098:../uvc.c      **** 							 {
1099:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1100:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1101:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1102:../uvc.c      **** 								 dataIdx++;
1103:../uvc.c      **** 							 }
1104:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1105:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1106:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1107:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1108:../uvc.c      **** 									 dataIdx++;
1109:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1110:../uvc.c      **** 								 }
1111:../uvc.c      **** 							 }
1112:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1113:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1114:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1115:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1116:../uvc.c      **** 							 break;
1117:../uvc.c      **** 						 case ExtCamMCtlID12:
1118:../uvc.c      **** 							 dataIdx = 0;
1119:../uvc.c      **** 							 if(Data0 <= 3){
1120:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1121:../uvc.c      **** 								 Data1 = Data0;
1122:../uvc.c      **** 							 }else{
1123:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1124:../uvc.c      **** 								 Data1 = Data0-4;
1125:../uvc.c      **** 							 }
1126:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1127:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1128:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1129:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1130:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1131:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1132:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1133:../uvc.c      **** 							 break;
1134:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1135:../uvc.c      **** 							 dataIdx = 0;
1136:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1137:../uvc.c      **** 								 Data0 = 1;
1138:../uvc.c      **** 							 }else{ //save current sensor parameters.
1139:../uvc.c      **** 								 Data0 = 0;
1140:../uvc.c      **** 							 }
1141:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1142:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1143:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1144:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1145:../uvc.c      **** 							 break;
1146:../uvc.c      **** 						 case ExtI2CCtlID15:
1147:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1148:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1149:../uvc.c      **** 					 		 }
1150:../uvc.c      **** 					 		I2CCmdHandler();
1151:../uvc.c      **** 							 break;
1152:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1153:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1154:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1155:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1156:../uvc.c      **** 
1157:../uvc.c      **** 							 dataIdx = 0;
1158:../uvc.c      **** #if 0 //seperate version
1159:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1160:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1161:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1162:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1163:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1164:../uvc.c      **** 							 }else{ //disable BLD window
1165:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1166:../uvc.c      **** 							 }
1167:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1168:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1169:../uvc.c      **** 							 dataIdx++;
1170:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1171:../uvc.c      **** 							 dataIdx++;
1172:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1173:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1174:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1175:../uvc.c      **** 							 dataIdx++;
1176:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1177:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1178:../uvc.c      **** #else //combination version
1179:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
1180:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1181:../uvc.c      **** 						     /* end test */
1182:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1183:../uvc.c      **** 							 dataIdx++;
1184:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1185:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1186:../uvc.c      **** 							 getData1 = Data1;
1187:../uvc.c      **** #endif
1188:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1189:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1190:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1191:../uvc.c      **** 							 break;
1192:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1193:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1194:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1195:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1196:../uvc.c      **** 
1197:../uvc.c      **** 							 dataIdx = 0;
1198:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1200:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1201:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1202:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1203:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1204:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1205:../uvc.c      **** 							 break;
1206:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1207:../uvc.c      **** 							 dataIdx = 0;
1208:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1209:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1210:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1211:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1212:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1213:../uvc.c      **** 							 break;
1214:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1215:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1216:../uvc.c      **** 							 dataIdx = 0;
1217:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1218:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1219:../uvc.c      **** 							  if(Data0&0x80){
1220:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1221:../uvc.c      **** 							  }else{
1222:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1223:../uvc.c      **** 							  }
1224:../uvc.c      **** 							 Data1 |= ~0x03;
1225:../uvc.c      **** 							 Data1 &= 0xC7;
1226:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1227:../uvc.c      **** 						  	 dataIdx++;
1228:../uvc.c      **** 
1229:../uvc.c      **** 							 Data0 = (Data0 << 2);
1230:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1231:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1232:../uvc.c      **** 
1233:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1234:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1235:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1236:../uvc.c      **** #endif
1237:../uvc.c      **** 							 dataIdx = 0;
1238:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1239:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1240:../uvc.c      **** 							  if(Data0&0x80){
1241:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1242:../uvc.c      **** 							  }else{
1243:../uvc.c      **** 								  Data0 = ~Data0;
1244:../uvc.c      **** 							  }
1245:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1246:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1247:../uvc.c      **** 
1248:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1249:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1250:../uvc.c      **** 
1251:../uvc.c      **** 
1252:../uvc.c      **** 							 break;
1253:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1254:../uvc.c      **** 							 dataIdx = 0;
1255:../uvc.c      **** 
1256:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1257:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1258:../uvc.c      **** 							 dataIdx++;
1259:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1260:../uvc.c      **** 							 dataIdx++;
1261:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1262:../uvc.c      **** 							 dataIdx++;
1263:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1264:../uvc.c      **** 							 dataIdx++;
1265:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1266:../uvc.c      **** 							 dataIdx++;
1267:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1268:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1269:../uvc.c      **** 
1270:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1271:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1272:../uvc.c      **** 							 break;
1273:../uvc.c      **** 						 case SaturCtlID6:
1274:../uvc.c      **** 							 dataIdx = 0;
1275:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1276:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1278:../uvc.c      **** 							 dataIdx++;
1279:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1280:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1281:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1282:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1283:../uvc.c      **** 							 break;
1284:../uvc.c      **** 
1285:../uvc.c      **** 						 case WBTLevCtlID11:
1286:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1287:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1288:../uvc.c      **** 							 dataIdx = 0;
1289:../uvc.c      **** 
1290:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1291:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1292:../uvc.c      **** 							 dataIdx++;
1293:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1294:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1295:../uvc.c      **** 
1296:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1297:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1298:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1299:../uvc.c      **** 							 break;
1300:../uvc.c      **** 						 case MFreqCtlID4:
1301:../uvc.c      **** 							 dataIdx = 0;
1302:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1303:../uvc.c      **** 							 Data0 = Data0 - 1;
1304:../uvc.c      **** 							 is60Hz = Data0;
1305:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1306:../uvc.c      **** 							 {
1307:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1308:../uvc.c      **** 								 is60Hz = CyFalse;
1309:../uvc.c      **** 							 }
1310:../uvc.c      **** 							 else if(Data0 >2)
1311:../uvc.c      **** 							 {
1312:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1313:../uvc.c      **** 								 is60Hz = CyTrue;
1314:../uvc.c      **** 							 }
1315:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1316:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1317:../uvc.c      **** 							 {
1318:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1319:../uvc.c      **** 			                       switch (setRes)
1320:../uvc.c      **** 			                         {
1321:../uvc.c      **** 			                         	case 1: //1944
1322:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1323:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1324:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1325:../uvc.c      **** 			                         		break;
1326:../uvc.c      **** 			                         	case 2: //1080
1327:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1328:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1329:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1330:../uvc.c      **** 			                         		break;
1331:../uvc.c      **** 			                         	case 3: //720
1332:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1333:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1334:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1335:../uvc.c      **** 			                         		break;
1336:../uvc.c      **** 			                         	case 4: //VGA
1337:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1338:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1339:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1340:../uvc.c      **** 			                         	default:
1341:../uvc.c      **** 			                         		break;
1342:../uvc.c      **** 			                         }
1343:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1344:../uvc.c      **** 							 }
1345:../uvc.c      **** 
1346:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1347:../uvc.c      **** 							 break;
1348:../uvc.c      **** 					 	 case BLCCtlID0:
1349:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1350:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1351:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1352:../uvc.c      **** 						     dataIdx = 0;
1353:../uvc.c      **** 
1354:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1355:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1356:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1357:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1358:../uvc.c      **** 
1359:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1360:../uvc.c      **** 							 {
1361:../uvc.c      **** 								 if(Data0 < 3){
1362:../uvc.c      **** 					 				 Data0 += 4;
1363:../uvc.c      **** 					 			 }else{
1364:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1365:../uvc.c      **** 									Data0 = 4; //set to default.
1366:../uvc.c      **** 					 			 }
1367:../uvc.c      **** 					 		 }
1368:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1369:../uvc.c      **** 							 dataIdx = 0;
1370:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1371:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1372:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1373:../uvc.c      **** 
1374:../uvc.c      **** 					 		 break;
1375:../uvc.c      **** 					 	 case ShapCtlID7:
1376:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1377:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1378:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1379:../uvc.c      **** 						     dataIdx = 0;
1380:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1381:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1382:../uvc.c      **** 							 if(Data0 != 0){
1383:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1384:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1385:../uvc.c      **** 								 dataIdx++;
1386:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1387:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1388:../uvc.c      **** 							 }else{
1389:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1390:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1391:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1392:../uvc.c      **** 
1393:../uvc.c      **** 							 }
1394:../uvc.c      **** 							 break;
1395:../uvc.c      **** 						 default:
1396:../uvc.c      **** 							 dataIdx = 0;
1397:../uvc.c      **** 
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1401:../uvc.c      **** 
1402:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1403:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1404:../uvc.c      **** 							 break;
1405:../uvc.c      **** 					 }
1406:../uvc.c      **** 			   }else{
1407:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1408:../uvc.c      **** 			   }
1409:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1410:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1411:../uvc.c      **** #endif
1412:../uvc.c      **** 
1413:../uvc.c      **** 			  break;
1414:../uvc.c      **** 		  default:
1415:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1416:../uvc.c      **** 			  break;
1417:../uvc.c      **** 		 }
1418:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1419:../uvc.c      **** }
1420:../uvc.c      **** /************** CT control requests handler *************************/
1421:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1422:../uvc.c      **** 
1423:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1424:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1425:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1426:../uvc.c      ****     uint16_t readCount;
1427:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1428:../uvc.c      ****     uint16_t diff, value, diffRd;
1429:../uvc.c      ****     uint8_t i, shutter, index;
1430:../uvc.c      ****     diff = 0xffff;
1431:../uvc.c      ****     shutter = 1;
1432:../uvc.c      ****     index = 1;
1433:../uvc.c      **** 
1434:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1435:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1436:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1437:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1439:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1440:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1441:../uvc.c      **** #endif
1442:../uvc.c      ****     reqData = bRequest;
1443:../uvc.c      **** 
1444:../uvc.c      ****     switch (bRequest)
1445:../uvc.c      **** 		 {
1446:../uvc.c      **** 
1447:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1448:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1449:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1450:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1451:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1452:../uvc.c      **** 			  break;
1453:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1454:../uvc.c      **** 
1455:../uvc.c      **** 			 switch(CtrlID)
1456:../uvc.c      **** 			 {
1457:../uvc.c      **** 				 default:
1458:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1459:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1460:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1461:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1462:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1463:../uvc.c      **** 					 break;
1464:../uvc.c      **** 			 }
1465:../uvc.c      **** 
1466:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1467:../uvc.c      **** 
1468:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1469:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1470:../uvc.c      **** #endif
1471:../uvc.c      **** 			  break;
1472:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1473:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1474:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1475:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1476:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1477:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1478:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1479:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1480:../uvc.c      **** 			  break;
1481:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1482:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1483:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1484:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1485:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1486:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1487:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1488:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1489:../uvc.c      **** 			  break;
1490:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1491:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1492:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1493:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1494:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1495:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1496:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1497:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1498:../uvc.c      **** 			  break;
1499:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1500:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1501:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1502:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1503:../uvc.c      **** 			  Len = 1;
1504:../uvc.c      **** 			  break;
1505:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1506:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1507:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1508:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1509:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1510:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1511:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1512:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1513:../uvc.c      **** 			  break;
1514:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1515:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1516:../uvc.c      **** 			  glEp0Buffer, &readCount);
1517:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1518:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1519:../uvc.c      **** 			  value = Data1;
1520:../uvc.c      **** 
1521:../uvc.c      **** 			  switch(CtrlID)
1522:../uvc.c      **** 			  {
1523:../uvc.c      **** 		  	      case AutoExMCtlID1:
1524:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1525:../uvc.c      **** 
1526:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1527:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1528:../uvc.c      **** 				    getData = glEp0Buffer[0];
1529:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1530:../uvc.c      **** 		  		    switch (getData){
1531:../uvc.c      **** 						case 1:
1532:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1533:../uvc.c      **** 							break;
1534:../uvc.c      **** 						case 2:
1535:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1536:../uvc.c      **** 							dataIdx = 0;
1537:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1538:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1539:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1540:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1541:../uvc.c      **** 
1542:../uvc.c      **** 							break;
1543:../uvc.c      **** 						case 4:
1544:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1545:../uvc.c      **** 							break;
1546:../uvc.c      **** 						case 8:
1547:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1548:../uvc.c      **** 			  		    	dataIdx = 0;
1549:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1550:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1551:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1552:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1553:../uvc.c      **** 							break;
1554:../uvc.c      **** 		  		    }
1555:../uvc.c      **** #if 0
1556:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1557:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1558:../uvc.c      **** 						  dataIdx = 0;
1559:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1560:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1561:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1562:../uvc.c      **** 		  		    }
1563:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1564:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1565:../uvc.c      **** 		  		    }
1566:../uvc.c      **** #endif
1567:../uvc.c      **** 				    break;
1568:../uvc.c      **** 
1569:../uvc.c      **** 			  	  case ExTmACtlID3:
1570:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1571:../uvc.c      **** 
1572:../uvc.c      **** 					  value = (value << 8)|Data0;
1573:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1574:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1575:../uvc.c      **** 					  {
1576:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1577:../uvc.c      **** 						  {
1578:../uvc.c      **** 							if(value > ShutValueArry[i]){
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1580:../uvc.c      **** 							}else{
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1582:../uvc.c      **** 							}
1583:../uvc.c      **** 							  if(diff > diffRd){
1584:../uvc.c      **** 								  diff = diffRd;
1585:../uvc.c      **** 								  index = i;
1586:../uvc.c      **** 							  }
1587:../uvc.c      **** 						  }
1588:../uvc.c      **** 						  shutter = shutter+index;
1589:../uvc.c      **** 
1590:../uvc.c      **** 						  dataIdx = 0;
1591:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1592:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1593:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1594:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1595:../uvc.c      **** 
1596:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1597:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1598:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1599:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1600:../uvc.c      **** 					  }else{
1601:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1602:../uvc.c      **** 					  }
1603:../uvc.c      **** 					  getData = glEp0Buffer[0];
1604:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1605:../uvc.c      **** 					  break;
1606:../uvc.c      **** 			  	  case IriACtlID7:
1607:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1608:../uvc.c      **** 					  {
1609:../uvc.c      **** 							 dataIdx = 0;
1610:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1611:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1612:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1613:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1614:../uvc.c      **** 
1615:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1616:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1617:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1618:../uvc.c      **** 					  }else{
1619:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1620:../uvc.c      **** 					  }
1621:../uvc.c      **** 					  getData = glEp0Buffer[0];
1622:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1623:../uvc.c      **** 
1624:../uvc.c      **** 					  break;
1625:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1626:../uvc.c      **** 					  getData = glEp0Buffer[0];
1627:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1628:../uvc.c      **** #if 1
1629:../uvc.c      **** 					  dataIdx = 0;
1630:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1631:../uvc.c      **** 					  if(getData == 1)
1632:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1633:../uvc.c      **** 					  else if(getData == 0xff)
1634:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1635:../uvc.c      **** 					  else
1636:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1637:../uvc.c      **** 					  //dataIdx++;
1638:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1639:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1640:../uvc.c      **** #endif
1641:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1642:../uvc.c      **** 					  break;
1643:../uvc.c      **** 
1644:../uvc.c      **** 			  	  default:
1645:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1646:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1647:../uvc.c      **** 			  		 break;
1648:../uvc.c      **** 			  }
1649:../uvc.c      **** 			  break;
1650:../uvc.c      **** 		  default:
1651:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1652:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1653:../uvc.c      **** 			  break;
1654:../uvc.c      **** 		 }
1655:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1656:../uvc.c      **** 
1657:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1658:../uvc.c      **** }
1659:../uvc.c      **** 
1660:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1661:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1662:../uvc.c      **** {
1663:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1664:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1665:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1666:../uvc.c      **** 
1667:../uvc.c      ****     CtrlID = BrgtCtlID1;
1668:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1669:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1670:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1671:../uvc.c      ****     Data1 = Data0;
1672:../uvc.c      **** 
1673:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1674:../uvc.c      ****     if(Data1&0x80){
1675:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1676:../uvc.c      ****     }else{
1677:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1678:../uvc.c      ****     }
1679:../uvc.c      ****     Data0 = (Data0 << 2);
1680:../uvc.c      **** 
1681:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1682:../uvc.c      **** 
1683:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1684:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1685:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1686:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1687:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1688:../uvc.c      **** 
1689:../uvc.c      ****     CtrlID = ConsCtlID2;
1690:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1691:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1692:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1693:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1694:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1695:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1696:../uvc.c      **** 
1697:../uvc.c      ****     CtrlID = HueCtlID5;
1698:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1699:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1700:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1701:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1704:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1705:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1706:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1707:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1708:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1709:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1710:../uvc.c      **** 
1711:../uvc.c      ****     CtrlID = SaturCtlID6;
1712:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1713:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1714:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1715:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1716:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1717:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1718:../uvc.c      **** 
1719:../uvc.c      ****     CtrlID = ShapCtlID7;
1720:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1721:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1722:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1723:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1724:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1725:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1726:../uvc.c      **** 
1727:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1728:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1729:../uvc.c      **** 	return;
1730:../uvc.c      **** }
1731:../uvc.c      **** 
1732:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1733:../uvc.c      **** void
1734:../uvc.c      **** CyFxUVCAddHeader (
1735:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1736:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1737:../uvc.c      ****         )
1738:../uvc.c      **** {
1739:../uvc.c      ****     /* Copy header to buffer */
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1741:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1742:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1743:../uvc.c      **** 
1744:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1745:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1746:../uvc.c      ****     {
1747:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1748:../uvc.c      ****     }
1749:../uvc.c      **** }
1750:../uvc.c      **** 
1751:../uvc.c      **** 
1752:../uvc.c      **** /* Application Error Handler */
1753:../uvc.c      **** void
1754:../uvc.c      **** CyFxAppErrorHandler (
1755:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1756:../uvc.c      ****         )
1757:../uvc.c      **** {
1758:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1759:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1760:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1761:../uvc.c      **** 
1762:../uvc.c      ****        This function can be modified to take additional error handling actions such
1763:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1764:../uvc.c      ****      */
1765:../uvc.c      ****     for (;;)
1766:../uvc.c      ****     {
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
1769:../uvc.c      ****     }
1770:../uvc.c      **** }
1771:../uvc.c      **** 
1772:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1773:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1774:../uvc.c      ****  */
1775:../uvc.c      **** static void
1776:../uvc.c      **** CyFxUVCApplnAbortHandler (
1777:../uvc.c      ****         void)
1778:../uvc.c      **** {
1779:../uvc.c      **** 	uint32_t flag;
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1781:../uvc.c      **** 	{
1782:../uvc.c      ****         /* Clear the Video Stream Request Event */
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1784:../uvc.c      **** 
1785:../uvc.c      ****         /* Set Video Stream Abort Event */
1786:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1787:../uvc.c      **** 	}
1788:../uvc.c      **** }
1789:../uvc.c      **** 
1790:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1791:../uvc.c      **** static void
1792:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1793:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1794:../uvc.c      ****         uint16_t             evdata  /* Event data */
1795:../uvc.c      ****         )
1796:../uvc.c      **** {
1797:../uvc.c      ****     switch (evtype)
1798:../uvc.c      ****     {
1799:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1800:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1801:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1802:../uvc.c      ****             gpif_initialized = 0;
1803:../uvc.c      ****             streamingStarted = CyFalse;
1804:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1805:../uvc.c      ****             break;
1806:../uvc.c      **** 
1807:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1808:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1809:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1810:../uvc.c      ****             gpif_initialized = 0;
1811:../uvc.c      ****             streamingStarted = CyFalse;
1812:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1813:../uvc.c      ****             break;
1814:../uvc.c      **** 
1815:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1816:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1817:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1818:../uvc.c      ****             gpif_initialized = 0;
1819:../uvc.c      ****             isUsbConnected = CyFalse;
1820:../uvc.c      ****             streamingStarted = CyFalse;
1821:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1822:../uvc.c      ****             break;
1823:../uvc.c      **** 
1824:../uvc.c      **** #ifdef BACKFLOW_DETECT
1825:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1826:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1827:../uvc.c      ****             break;
1828:../uvc.c      **** #endif
1829:../uvc.c      **** 
1830:../uvc.c      ****         default:
1831:../uvc.c      ****             break;
1832:../uvc.c      ****     }
1833:../uvc.c      **** }
1834:../uvc.c      **** 
1835:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1836:../uvc.c      **** static CyBool_t
1837:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1838:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1839:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1840:../uvc.c      ****         )
1841:../uvc.c      **** {
1842:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1843:../uvc.c      ****     uint32_t status;
1844:../uvc.c      **** 
1845:../uvc.c      ****     /* Obtain Request Type and Request */
1846:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1847:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1848:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1849:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1850:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1851:../uvc.c      **** 
1852:../uvc.c      ****     /* Check for UVC Class Requests */
1853:../uvc.c      ****     switch (bmReqType)
1854:../uvc.c      ****     {
1855:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1856:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1857:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1858:../uvc.c      ****             switch (wIndex & 0xFF)
1859:../uvc.c      ****             {
1860:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1861:../uvc.c      ****                     {
1862:../uvc.c      ****                         uvcHandleReq = CyTrue;
1863:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1864:../uvc.c      ****                                 CYU3P_EVENT_OR);
1865:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1866:../uvc.c      ****                         {
1867:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1868:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1869:../uvc.c      ****                         }
1870:../uvc.c      ****                     }
1871:../uvc.c      ****                     break;
1872:../uvc.c      **** 
1873:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1874:../uvc.c      ****                     {
1875:../uvc.c      ****                         uvcHandleReq = CyTrue;
1876:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1877:../uvc.c      ****                                 CYU3P_EVENT_OR);
1878:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1879:../uvc.c      ****                         {
1880:../uvc.c      ****                             /* Error handling */
1881:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1882:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1883:../uvc.c      ****                         }
1884:../uvc.c      ****                     }
1885:../uvc.c      ****                     break;
1886:../uvc.c      **** 
1887:../uvc.c      ****                 default:
1888:../uvc.c      ****                     break;
1889:../uvc.c      ****             }
1890:../uvc.c      ****             break;
1891:../uvc.c      **** 
1892:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1893:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1894:../uvc.c      ****             {
1895:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1896:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1897:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1898:../uvc.c      ****                 {
1899:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1900:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1901:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1902:../uvc.c      ****                     gpif_initialized = 0;
1903:../uvc.c      ****                     streamingStarted = CyFalse;
1904:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1905:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1906:../uvc.c      ****                     CyU3PBusyWait (100);
1907:../uvc.c      **** 
1908:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1909:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1910:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1911:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1912:../uvc.c      ****                     CyU3PBusyWait (100);
1913:../uvc.c      **** 
1914:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1915:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1916:../uvc.c      ****                     uvcHandleReq = CyTrue;
1917:../uvc.c      ****                     /* Complete Control request handshake */
1918:../uvc.c      ****                     CyU3PUsbAckSetup ();
1919:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1920:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1921:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1922:../uvc.c      **** 
1923:../uvc.c      ****                 }
1924:../uvc.c      ****             }
1925:../uvc.c      ****             break;
1926:../uvc.c      **** 
1927:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1928:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1929:../uvc.c      ****             {
1930:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1931:../uvc.c      ****                 {
1932:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1933:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1934:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1935:../uvc.c      ****                 	 * has started. */
1936:../uvc.c      ****                     if (streamingStarted == CyTrue)
1937:../uvc.c      ****                     {
1938:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1939:../uvc.c      **** 
1940:../uvc.c      ****                         /* Disable the GPIF state machine. */
1941:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1942:../uvc.c      ****                         gpif_initialized = 0;
1943:../uvc.c      ****                         streamingStarted = CyFalse;
1944:../uvc.c      **** 
1945:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1946:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1947:../uvc.c      ****                         CyU3PBusyWait (100);
1948:../uvc.c      **** 
1949:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1950:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1951:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1952:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1953:../uvc.c      ****                         CyU3PBusyWait (100);
1954:../uvc.c      **** 
1955:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1956:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1957:../uvc.c      **** 
1958:../uvc.c      ****                         uvcHandleReq = CyTrue;
1959:../uvc.c      ****                         /* Complete Control request handshake */
1960:../uvc.c      ****                         CyU3PUsbAckSetup ();
1961:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1962:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1963:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1964:../uvc.c      ****                     }
1965:../uvc.c      ****                     else
1966:../uvc.c      ****                     {
1967:../uvc.c      ****                         uvcHandleReq = CyTrue;
1968:../uvc.c      ****                         CyU3PUsbAckSetup ();
1969:../uvc.c      ****                     }
1970:../uvc.c      ****                 }
1971:../uvc.c      ****             }
1972:../uvc.c      ****             break;
1973:../uvc.c      **** 
1974:../uvc.c      ****         default:
1975:../uvc.c      ****             break;
1976:../uvc.c      ****     }
1977:../uvc.c      **** 
1978:../uvc.c      ****     /* Return status of request handling to the USB driver */
1979:../uvc.c      ****     return uvcHandleReq;
1980:../uvc.c      **** }
1981:../uvc.c      **** 
1982:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1983:../uvc.c      **** 
1984:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1985:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1986:../uvc.c      ****  */
1987:../uvc.c      **** void
1988:../uvc.c      **** CyFxUvcApplnDmaCallback (
1989:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1990:../uvc.c      ****         CyU3PDmaCbType_t      type,
1991:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1992:../uvc.c      ****         )
1993:../uvc.c      **** {
1994:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1995:../uvc.c      **** #if 1
1996:../uvc.c      ****     CyU3PReturnStatus_t status;
1997:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1998:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1999:../uvc.c      **** 
2000:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2001:../uvc.c      ****     {
2002:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2003:../uvc.c      ****             {
2004:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2005:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2006:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2007:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2008:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2009:../uvc.c      ****                 	stiflag = 0x03;
2010:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2011:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2012:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2013:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2014:../uvc.c      ****                 }
2015:../uvc.c      **** #endif
2016:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2017:../uvc.c      ****                 fb++;
2018:../uvc.c      ****             }
2019:../uvc.c      ****             else
2020:../uvc.c      ****             {
2021:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2022:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2023:../uvc.c      ****                 pb++;
2024:../uvc.c      ****                 pbc = input->buffer_p.count;
2025:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2026:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2027:../uvc.c      ****                 //lineCount = 0; //res test
2028:../uvc.c      **** #if 1   //remove the still flag clearing here
2029:../uvc.c      ****                 if(stiflag == 0x0F){
2030:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2031:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2032:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2033:../uvc.c      ****                 	stiflag = 0xAA;
2034:../uvc.c      ****                 }
2035:../uvc.c      **** #endif
2036:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2037:../uvc.c      ****             }
2038:../uvc.c      **** 
2039:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2040:../uvc.c      ****             prodCount++;
2041:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2042:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2043:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2044:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2045:../uvc.c      ****             {
2046:../uvc.c      ****                 prodCount--;
2047:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2048:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2049:../uvc.c      ****             }
2050:../uvc.c      ****     }
2051:../uvc.c      **** #endif
2052:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2053:../uvc.c      ****     {
2054:../uvc.c      ****         consCount++;
2055:../uvc.c      ****         streamingStarted = CyTrue;
2056:../uvc.c      ****     }
2057:../uvc.c      **** }
2058:../uvc.c      **** 
2059:../uvc.c      **** /*
2060:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2061:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2062:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2063:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2064:../uvc.c      ****  * to commit the buffer.
2065:../uvc.c      ****  */
2066:../uvc.c      **** static uint8_t
2067:../uvc.c      **** CyFxUvcAppCommitEOF (
2068:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2069:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2070:../uvc.c      ****         )
2071:../uvc.c      **** {
2072:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2073:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2074:../uvc.c      **** 
2075:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2076:../uvc.c      **** 
2077:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2078:../uvc.c      ****     {
2079:../uvc.c      ****         switch (stateId)
2080:../uvc.c      ****         {
2081:../uvc.c      **** 
2082:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2083:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2084:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2085:../uvc.c      ****                 break;
2086:../uvc.c      **** 
2087:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2088:../uvc.c      ****                 socket = 0;
2089:../uvc.c      ****                 break;
2090:../uvc.c      **** 
2091:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2092:../uvc.c      ****                 socket = 1;
2093:../uvc.c      ****                 break;
2094:../uvc.c      **** 
2095:../uvc.c      ****             default:
2096:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2097:../uvc.c      ****                 /* Unexpected current state. Return error. */
2098:../uvc.c      ****             	//lineCount++;
2099:../uvc.c      ****             	return 1;
2100:../uvc.c      ****         }
2101:../uvc.c      ****     }
2102:../uvc.c      **** 
2103:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2104:../uvc.c      ****     {
2105:../uvc.c      ****         switch (stateId)
2106:../uvc.c      ****         {
2107:../uvc.c      **** #ifndef CAM720
2108:../uvc.c      **** #ifdef GPIFIIM
2109:../uvc.c      ****             case 13:
2110:../uvc.c      ****             case 24:
2111:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2112:../uvc.c      ****                 break;
2113:../uvc.c      **** 
2114:../uvc.c      ****             case 8:
2115:../uvc.c      ****                 socket = 0;
2116:../uvc.c      ****                 break;
2117:../uvc.c      **** 
2118:../uvc.c      ****             case 20:
2119:../uvc.c      ****                 socket = 1;
2120:../uvc.c      ****                 break;
2121:../uvc.c      **** #else
2122:../uvc.c      ****             case 11:
2123:../uvc.c      ****             case 18:
2124:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2125:../uvc.c      ****                 break;
2126:../uvc.c      **** 
2127:../uvc.c      ****             case 8:
2128:../uvc.c      ****                 socket = 0;
2129:../uvc.c      ****                 break;
2130:../uvc.c      **** 
2131:../uvc.c      ****             case 15:
2132:../uvc.c      ****                 socket = 1;
2133:../uvc.c      ****                 break;
2134:../uvc.c      **** #endif
2135:../uvc.c      **** #else
2136:../uvc.c      ****             case 11:
2137:../uvc.c      ****             case 18:
2138:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2139:../uvc.c      ****                 break;
2140:../uvc.c      **** 
2141:../uvc.c      ****             case 8:
2142:../uvc.c      ****                 socket = 0;
2143:../uvc.c      ****                 break;
2144:../uvc.c      **** 
2145:../uvc.c      ****             case 15:
2146:../uvc.c      ****                 socket = 1;
2147:../uvc.c      ****                 break;
2148:../uvc.c      **** 
2149:../uvc.c      **** #endif
2150:../uvc.c      ****              default:
2151:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2152:../uvc.c      ****                 /* Unexpected current state. Return error. */
2153:../uvc.c      ****                return 1;
2154:../uvc.c      ****         }
2155:../uvc.c      ****     }
2156:../uvc.c      **** 
2157:../uvc.c      ****     if (socket != 0xFF)
2158:../uvc.c      ****     {
2159:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2160:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2161:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2162:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2163:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2164:../uvc.c      ****         {
2165:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2166:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2167:../uvc.c      ****         }
2168:../uvc.c      ****     }
2169:../uvc.c      **** 
2170:../uvc.c      ****     return 0;
2171:../uvc.c      **** }
2172:../uvc.c      **** 
2173:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2174:../uvc.c      **** void
2175:../uvc.c      **** CyFxGpifCB (
2176:../uvc.c      ****         CyU3PGpifEventType event,
2177:../uvc.c      ****         uint8_t currentState
2178:../uvc.c      ****         )
2179:../uvc.c      **** {
2180:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2181:../uvc.c      ****     {
2182:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2183:../uvc.c      ****     	           in the UVC implementation. */
2184:../uvc.c      ****     	//hitFV = CyTrue;
2185:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2186:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2187:../uvc.c      ****     }
2188:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2189:../uvc.c      **** }
2190:../uvc.c      **** 
2191:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2192:../uvc.c      **** static void
2193:../uvc.c      **** CyFxUVCApplnDebugInit (
2194:../uvc.c      ****         void)
2195:../uvc.c      **** {
2196:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2197:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2198:../uvc.c      **** 
2199:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2200:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2201:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2202:../uvc.c      ****     {
2203:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2204:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2205:../uvc.c      ****     }
2206:../uvc.c      **** 
2207:../uvc.c      ****     /* Set UART Configuration */
2208:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2209:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2210:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2211:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2212:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2213:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2214:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2215:../uvc.c      **** 
2216:../uvc.c      ****     /* Set the UART configuration */
2217:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2218:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2219:../uvc.c      ****     {
2220:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2221:../uvc.c      ****     }
2222:../uvc.c      **** 
2223:../uvc.c      ****     /* Set the UART transfer */
2224:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2226:../uvc.c      ****     {
2227:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2228:../uvc.c      ****     }
2229:../uvc.c      **** 
2230:../uvc.c      ****     /* Initialize the Debug logger module. */
2231:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2232:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2233:../uvc.c      ****     {
2234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2235:../uvc.c      ****     }
2236:../uvc.c      **** 
2237:../uvc.c      ****     /* Disable log message headers. */
2238:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2239:../uvc.c      **** }
2240:../uvc.c      **** 
2241:../uvc.c      **** /* I2C initialization. */
2242:../uvc.c      **** static void
2243:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2244:../uvc.c      **** {
2245:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2246:../uvc.c      ****     CyU3PReturnStatus_t status;
2247:../uvc.c      **** 
2248:../uvc.c      ****     status = CyU3PI2cInit ();
2249:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2250:../uvc.c      ****     {
2251:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2252:../uvc.c      ****         CyFxAppErrorHandler (status);
2253:../uvc.c      ****     }
2254:../uvc.c      **** 
2255:../uvc.c      ****     /*  Set I2C Configuration */
2256:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2257:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2258:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2259:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2260:../uvc.c      **** 
2261:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2262:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2263:../uvc.c      ****     {
2264:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2265:../uvc.c      ****         CyFxAppErrorHandler (status);
2266:../uvc.c      ****     }
2267:../uvc.c      **** }
2268:../uvc.c      **** 
2269:../uvc.c      **** #ifdef BACKFLOW_DETECT
2270:../uvc.c      **** static void CyFxUvcAppPibCallback (
2271:../uvc.c      ****         CyU3PPibIntrType cbType,
2272:../uvc.c      ****         uint16_t cbArg)
2273:../uvc.c      **** {
2274:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2275:../uvc.c      ****     {
2276:../uvc.c      ****         if (!back_flow_detected)
2277:../uvc.c      ****         {
2278:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2279:../uvc.c      ****             back_flow_detected = 1;
2280:../uvc.c      ****         }
2281:../uvc.c      ****     }
2282:../uvc.c      **** }
2283:../uvc.c      **** #endif
2284:../uvc.c      **** 
2285:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2286:../uvc.c      **** static void
2287:../uvc.c      **** CyFxUvcAppDebugCallback (
2288:../uvc.c      ****         CyU3PDmaChannel   *handle,
2289:../uvc.c      ****         CyU3PDmaCbType_t   type,
2290:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2291:../uvc.c      **** {
2292:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2293:../uvc.c      ****     {
2294:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2295:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2296:../uvc.c      ****     }
2297:../uvc.c      **** }
2298:../uvc.c      **** #endif
2299:../uvc.c      **** 
2300:../uvc.c      **** #if 0
2301:../uvc.c      **** static void CyFxAppIntEpCb(
2302:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2303:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2304:../uvc.c      **** 		uint8_t  ebNum)
2305:../uvc.c      **** 		{
2306:../uvc.c      **** 			//CyBool_t value;
2307:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2308:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2309:../uvc.c      **** 
2310:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2311:../uvc.c      **** 		}
2312:../uvc.c      **** #endif
2313:../uvc.c      **** 
2314:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2315:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2316:../uvc.c      ****    configures the DMA module for the UVC Application */
2317:../uvc.c      **** static void
2318:../uvc.c      **** CyFxUVCApplnInit (void)
2319:../uvc.c      **** {
2320:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2321:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2322:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2323:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2324:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2325:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2326:../uvc.c      **** 
2327:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2328:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2329:../uvc.c      **** 
2330:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2331:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2332:../uvc.c      **** #endif
2333:../uvc.c      **** 
2334:../uvc.c      ****     /* Create UVC event group */
2335:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2336:../uvc.c      ****     if (apiRetStatus != 0)
2337:../uvc.c      ****     {
2338:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2339:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2340:../uvc.c      ****     }
2341:../uvc.c      **** 
2342:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2343:../uvc.c      ****     CyFxUvcAppPTZInit ();
2344:../uvc.c      **** #endif
2345:../uvc.c      **** 
2346:../uvc.c      ****     isUsbConnected = CyFalse;
2347:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2348:../uvc.c      **** 
2349:../uvc.c      ****     /* Init the GPIO module */
2350:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2351:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2352:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2353:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2354:../uvc.c      ****     gpioClock.halfDiv    = 0;
2355:../uvc.c      **** 
2356:../uvc.c      ****     /* Initialize Gpio interface */
2357:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2358:../uvc.c      ****     if (apiRetStatus != 0)
2359:../uvc.c      ****     {
2360:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2361:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2362:../uvc.c      ****     }
2363:../uvc.c      **** 
2364:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2365:../uvc.c      ****      * must use GpioOverride to configure it */
2366:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2367:../uvc.c      ****     if (apiRetStatus != 0)
2368:../uvc.c      ****     {
2369:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2370:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2371:../uvc.c      ****     }
2372:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2373:../uvc.c      ****     if (apiRetStatus != 0)
2374:../uvc.c      ****     {
2375:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2376:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2377:../uvc.c      ****     }
2378:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2379:../uvc.c      ****     if (apiRetStatus != 0)
2380:../uvc.c      ****     {
2381:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2382:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2383:../uvc.c      ****     }
2384:../uvc.c      **** 
2385:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2386:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2387:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2388:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2389:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2390:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2391:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2392:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2393:../uvc.c      ****     {
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2395:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2396:../uvc.c      ****     }
2397:../uvc.c      **** 
2398:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2399:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2400:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2401:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2402:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2403:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2404:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2405:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2406:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2407:../uvc.c      ****     {
2408:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2409:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2410:../uvc.c      ****     }
2411:../uvc.c      **** 
2412:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2413:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2414:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2415:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2416:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2417:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2418:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2419:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2420:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2421:../uvc.c      ****     {
2422:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2423:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2424:../uvc.c      ****     }
2425:../uvc.c      **** 
2426:../uvc.c      ****     /* Initialize the P-port. */
2427:../uvc.c      ****     pibclock.clkDiv      = 2;
2428:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2429:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2430:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2431:../uvc.c      **** 
2432:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2433:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2434:../uvc.c      ****     {
2435:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2436:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2437:../uvc.c      ****     }
2438:../uvc.c      **** 
2439:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2440:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2441:../uvc.c      **** 
2442:../uvc.c      **** #ifdef BACKFLOW_DETECT
2443:../uvc.c      ****     back_flow_detected = 0;
2444:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2445:../uvc.c      **** #endif
2446:../uvc.c      **** 
2447:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2448:../uvc.c      ****     SensorReset ();
2449:../uvc.c      ****     CyU3PThreadSleep(5000);
2450:../uvc.c      ****     //SensorInit ();
2451:../uvc.c      **** 
2452:../uvc.c      ****     /* USB initialization. */
2453:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2454:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2455:../uvc.c      ****     {
2456:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2457:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2458:../uvc.c      ****     }
2459:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2460:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2461:../uvc.c      **** 
2462:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2463:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2464:../uvc.c      **** 
2465:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2466:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2467:../uvc.c      **** 
2468:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2469:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2470:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2471:../uvc.c      **** 
2472:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2473:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2474:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2475:../uvc.c      **** 
2476:../uvc.c      ****     /* Configuration descriptors. */
2477:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2478:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2479:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2480:../uvc.c      **** 
2481:../uvc.c      ****     /* String Descriptors */
2482:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2483:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2484:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2485:../uvc.c      **** 
2486:../uvc.c      ****     /* Configure the status interrupt endpoint.
2487:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2488:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2489:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2490:../uvc.c      ****      */
2491:../uvc.c      ****     endPointConfig.enable   = 1;
2492:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2493:../uvc.c      ****     endPointConfig.pcktSize = 64;
2494:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2495:../uvc.c      ****     endPointConfig.streams  = 0;
2496:../uvc.c      ****     endPointConfig.burstLen = 1;
2497:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2498:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2499:../uvc.c      ****     {
2500:../uvc.c      ****         /* Error Handling */
2501:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2502:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2503:../uvc.c      ****     }
2504:../uvc.c      **** 
2505:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2506:../uvc.c      ****     dmaInterConfig.size           = 1024;
2507:../uvc.c      ****     dmaInterConfig.count          = 1;
2508:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2509:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2510:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2511:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2512:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2513:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2514:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2515:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2516:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2517:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2518:../uvc.c      ****             &dmaInterConfig);
2519:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2520:../uvc.c      ****     {
2521:../uvc.c      ****         /* Error handling */
2522:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2523:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2524:../uvc.c      ****     }
2525:../uvc.c      **** 
2526:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2527:../uvc.c      ****     if (glInterStaBuffer == 0)
2528:../uvc.c      ****     {
2529:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2530:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2531:../uvc.c      ****     }
2532:../uvc.c      **** 
2533:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2534:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2535:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2536:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2537:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2538:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2539:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2540:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2541:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2542:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2543:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2544:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2545:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2546:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2547:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2548:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2549:../uvc.c      ****             &dmaMultiConfig);
2550:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2551:../uvc.c      ****     {
2552:../uvc.c      ****         /* Error handling */
2553:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2554:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2555:../uvc.c      ****     }
2556:../uvc.c      **** 
2557:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2558:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2559:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2560:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2561:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2562:../uvc.c      ****      */
2563:../uvc.c      **** 
2564:../uvc.c      ****     endPointConfig.enable   = 1;
2565:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2566:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2567:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2568:../uvc.c      ****     endPointConfig.streams  = 0;
2569:../uvc.c      ****     endPointConfig.burstLen = 1;
2570:../uvc.c      **** 
2571:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2572:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2573:../uvc.c      ****     {
2574:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2575:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2576:../uvc.c      ****     }
2577:../uvc.c      **** 
2578:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2579:../uvc.c      **** 
2580:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2581:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2582:../uvc.c      ****     {
2583:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2584:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2585:../uvc.c      ****     }
2586:../uvc.c      **** 
2587:../uvc.c      ****     channelConfig.size           = 1024;
2588:../uvc.c      ****     channelConfig.count          = 1;
2589:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2590:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2591:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2592:../uvc.c      ****     channelConfig.prodHeader     = 0;
2593:../uvc.c      ****     channelConfig.prodFooter     = 0;
2594:../uvc.c      ****     channelConfig.consHeader     = 0;
2595:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2596:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2597:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2598:../uvc.c      **** 
2599:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2600:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2603:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2604:../uvc.c      ****     }
2605:../uvc.c      **** 
2606:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2607:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2608:../uvc.c      ****     {
2609:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2610:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2611:../uvc.c      ****     }
2612:../uvc.c      **** 
2613:../uvc.c      ****     channelConfig.size           = 1024;
2614:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2615:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2616:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2617:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2618:../uvc.c      ****     channelConfig.prodHeader     = 0;
2619:../uvc.c      ****     channelConfig.prodFooter     = 0;
2620:../uvc.c      ****     channelConfig.consHeader     = 0;
2621:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2622:../uvc.c      ****     channelConfig.notification   = 0;
2623:../uvc.c      ****     channelConfig.cb             = 0;
2624:../uvc.c      **** 
2625:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2626:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2627:../uvc.c      ****     {
2628:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2629:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2630:../uvc.c      ****     }
2631:../uvc.c      **** 
2632:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2633:../uvc.c      ****     if (glDebugRspBuffer == 0)
2634:../uvc.c      ****     {
2635:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2636:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2637:../uvc.c      ****     }
2638:../uvc.c      **** #endif
2639:../uvc.c      **** 
2640:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2641:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2642:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2643:../uvc.c      ****     {
2644:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2645:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2646:../uvc.c      ****     }
2647:../uvc.c      **** 
2648:../uvc.c      ****     CyU3PBusyWait(100);
2649:../uvc.c      **** 
2650:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2651:../uvc.c      **** 
2652:../uvc.c      ****     endPointConfig.enable   = 1;
2653:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2654:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2655:../uvc.c      ****     {
2656:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2657:../uvc.c      ****     	endPointConfig.burstLen = 16;
2658:../uvc.c      ****     }
2659:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2660:../uvc.c      ****     {
2661:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2662:../uvc.c      ****     	endPointConfig.burstLen = 1;
2663:../uvc.c      ****     }
2664:../uvc.c      ****     endPointConfig.streams  = 0;
2665:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         /* Error Handling */
2669:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2670:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2671:../uvc.c      ****     }
2672:../uvc.c      **** #if 0    //for still image method 3 using
2673:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2674:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2675:../uvc.c      ****     {
2676:../uvc.c      ****         /* Error Handling */
2677:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2679:../uvc.c      ****     }
2680:../uvc.c      **** #endif
2681:../uvc.c      **** 
2682:../uvc.c      **** }
2683:../uvc.c      **** 
2684:../uvc.c      **** /*
2685:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2686:../uvc.c      ****  * streaming session is started.
2687:../uvc.c      ****  */
2688:../uvc.c      **** static void
2689:../uvc.c      **** CyFxUvcAppGpifInit (
2690:../uvc.c      ****         void)
2691:../uvc.c      **** {
2692:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2693:../uvc.c      **** 
2694:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2695:../uvc.c      ****     {
2696:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2697:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2698:../uvc.c      ****     }
2699:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2700:../uvc.c      ****     {
2701:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2702:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2703:../uvc.c      ****     }
2704:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2705:../uvc.c      ****     {
2706:../uvc.c      ****         /* Error Handling */
2707:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2708:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2709:../uvc.c      ****     }
2710:../uvc.c      **** 
2711:../uvc.c      ****     /* Start the state machine from the designated start state. */
2712:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2713:../uvc.c      ****     {
2714:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2715:../uvc.c      ****     }
2716:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2717:../uvc.c      ****     {
2718:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2719:../uvc.c      ****     }
2720:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2721:../uvc.c      ****     {
2722:../uvc.c      ****         /* Error Handling */
2723:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2724:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2725:../uvc.c      ****     }
2726:../uvc.c      **** }
2727:../uvc.c      **** 
2728:../uvc.c      **** /*
2729:../uvc.c      ****  * Entry function for the UVC Application Thread
2730:../uvc.c      ****  */
2731:../uvc.c      **** 
2732:../uvc.c      **** uint32_t posTick;
2733:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2734:../uvc.c      **** 
2735:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2736:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2737:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2738:../uvc.c      **** }
2739:../uvc.c      **** 
2740:../uvc.c      **** 
2741:../uvc.c      **** void
2742:../uvc.c      **** UVCAppThread_Entry (
2743:../uvc.c      ****         uint32_t input)
2744:../uvc.c      **** {
2745:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2746:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2747:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2748:../uvc.c      ****     uint8_t i = 0;
2749:../uvc.c      ****     uint32_t flag;
2750:../uvc.c      ****     uint32_t prinflag = 0;
2751:../uvc.c      **** static uint8_t IMcount = 0;
2752:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2753:../uvc.c      ****     uint32_t frameCnt = 0;
2754:../uvc.c      **** #endif
2755:../uvc.c      ****     /* Initialize the Uart Debug Module */
2756:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2757:../uvc.c      **** 
2758:../uvc.c      ****     /* Initialize the I2C interface */
2759:../uvc.c      **** 	while (i++ < 6){
2760:../uvc.c      **** 		CyU3PThreadSleep(500);
2761:../uvc.c      **** 	}
2762:../uvc.c      **** 
2763:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2764:../uvc.c      **** 
2765:../uvc.c      ****     /* Initialize the UVC Application */
2766:../uvc.c      ****     CyFxUVCApplnInit ();
2767:../uvc.c      ****     /*
2768:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2769:../uvc.c      **** 
2770:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2771:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2772:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2773:../uvc.c      **** 
2774:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2775:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2776:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2777:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2778:../uvc.c      **** 
2779:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2780:../uvc.c      ****        of handling the abort request.
2781:../uvc.c      ****      */
2782:../uvc.c      **** 
2783:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2784:../uvc.c      ****     //CyU3PThreadSleep(1000);
2785:../uvc.c      **** 
2786:../uvc.c      ****     for (;;)
2787:../uvc.c      ****     {
2788:../uvc.c      ****         /* Waiting for the Video Stream Event */
2789:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2790:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2791:../uvc.c      ****         {
2792:../uvc.c      **** #if 0 //test for new firmware no video bring up
2793:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2794:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2795:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2796:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2797:../uvc.c      ****             {
2798:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2799:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2800:../uvc.c      ****                 {
2801:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2802:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2803:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2804:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2805:../uvc.c      **** #endif
2806:../uvc.c      **** #endif
2807:../uvc.c      ****                     }
2808:../uvc.c      ****                 else
2809:../uvc.c      ****                 {
2810:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2811:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2812:../uvc.c      **** #ifdef USB_LOWRES_IMG
2813:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2814:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2815:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2816:../uvc.c      **** #endif
2817:../uvc.c      **** #endif
2818:../uvc.c      ****                 }
2819:../uvc.c      **** 
2820:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2821:../uvc.c      ****                 prodCount++;
2822:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2823:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2824:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2825:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2826:../uvc.c      ****                 {
2827:../uvc.c      ****                     prodCount--;
2828:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2829:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2830:../uvc.c      ****                 }
2831:../uvc.c      ****             }
2832:../uvc.c      **** #endif
2833:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2834:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2835:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2836:../uvc.c      ****             {
2837:../uvc.c      ****             	if(0&&(prinflag == 0)){
2838:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2839:../uvc.c      ****             		prinflag = 1;
2840:../uvc.c      ****             	}
2841:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2842:../uvc.c      ****             	fb=0;
2843:../uvc.c      ****             	pb=0;
2844:../uvc.c      ****             	pbc=0;
2845:../uvc.c      ****                 prodCount = 0;
2846:../uvc.c      ****                 consCount = 0;
2847:../uvc.c      ****                 hitFV     = CyFalse;
2848:../uvc.c      **** 
2849:../uvc.c      **** #ifdef BACKFLOW_DETECT
2850:../uvc.c      ****                 back_flow_detected = 0;
2851:../uvc.c      **** #endif
2852:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2853:../uvc.c      ****                 frameCnt++;
2854:../uvc.c      **** #endif
2855:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2856:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2857:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2858:../uvc.c      ****                 //}
2859:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2860:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2861:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2862:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2863:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2864:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2865:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2866:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2867:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2868:../uvc.c      ****                 		stiflag = 0xFF;
2869:../uvc.c      ****                 		IMcount = 0;
2870:../uvc.c      ****                 	}
2871:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2872:../uvc.c      **** 
2873:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2874:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2875:../uvc.c      ****                 		stiflag = 0x0F;
2876:../uvc.c      ****                 		IMcount = 0;
2877:../uvc.c      ****                 		}
2878:../uvc.c      ****                  		/*if(IMcount > 0x4){
2879:../uvc.c      ****                 			stiflag = 0x0F;
2880:../uvc.c      ****                 			IMcount = 0;
2881:../uvc.c      ****                 		}*/
2882:../uvc.c      **** 
2883:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2884:../uvc.c      ****                     //CyU3PThreadSleep(400);
2885:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2886:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2887:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2888:../uvc.c      **** 
2889:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2890:../uvc.c      ****                 	{
2891:../uvc.c      ****                     switch (setRes)
2892:../uvc.c      ****                      {
2893:../uvc.c      ****                  	case 1: //1944
2894:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2895:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2896:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
2897:../uvc.c      ****                  		break;
2898:../uvc.c      ****                  	case 2: //1080
2899:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2900:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2901:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
2902:../uvc.c      ****                  		break;
2903:../uvc.c      ****                  	case 3: //720
2904:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2905:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2906:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
2907:../uvc.c      ****                  		break;
2908:../uvc.c      ****                  	case 4: //VGA
2909:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
2910:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2911:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
2912:../uvc.c      ****                  		break;
2913:../uvc.c      ****                  	default:
2914:../uvc.c      ****                  		break;
2915:../uvc.c      ****                      }
2916:../uvc.c      ****                     IMcount = 0;
2917:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2918:../uvc.c      ****                 	stiflag = 0x0;
2919:../uvc.c      ****                 	}
2920:../uvc.c      ****                 }
2921:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2922:../uvc.c      ****                 /* Reset the DMA channel. */
2923:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2924:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2925:../uvc.c      ****                 {
2926:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2927:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2928:../uvc.c      ****                 }
2929:../uvc.c      **** 
2930:../uvc.c      ****                 /* Start Channel Immediately */
2931:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2932:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2933:../uvc.c      ****                 {
2934:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2935:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2936:../uvc.c      ****                 }
2937:../uvc.c      **** 
2938:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2939:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2940:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2941:../uvc.c      ****                 }
2942:../uvc.c      ****         }
2943:../uvc.c      ****         else
2944:../uvc.c      ****         {
2945:../uvc.c      ****             /* If we have a stream abort request pending. */
2946:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2947:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2948:../uvc.c      ****             {
2949:../uvc.c      ****                 hitFV     = CyFalse;
2950:../uvc.c      ****                 prodCount = 0;
2951:../uvc.c      ****                 consCount = 0;
2952:../uvc.c      ****                 if(0&&(prinflag == 0)){
2953:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2954:../uvc.c      ****                 	prinflag = 1;
2955:../uvc.c      ****                 }
2956:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2957:../uvc.c      ****                 fb=0;
2958:../uvc.c      ****                 pb=0;
2959:../uvc.c      ****                 pbc=0;
2960:../uvc.c      **** 
2961:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2962:../uvc.c      ****                 {
2963:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2964:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2965:../uvc.c      ****                     {
2966:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2967:../uvc.c      ****                     }
2968:../uvc.c      **** 
2969:../uvc.c      ****                     /* Flush the Endpoint memory */
2970:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2971:../uvc.c      ****                 }
2972:../uvc.c      **** 
2973:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2974:../uvc.c      ****             }
2975:../uvc.c      ****             else
2976:../uvc.c      ****             {
2977:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2978:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2979:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2980:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2981:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2982:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2983:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2984:../uvc.c      ****                 {
2985:../uvc.c      ****                     /* Error handling */
2986:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2987:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2988:../uvc.c      ****                 }
2989:../uvc.c      **** 
2990:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2991:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2992:../uvc.c      ****                 {
2993:../uvc.c      **** #if 0
2994:../uvc.c      ****                 	//for start up of the AF Lens
2995:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2996:../uvc.c      ****                     CyU3PThreadSleep(500);
2997:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2998:../uvc.c      ****                     CyU3PThreadSleep(500);
2999:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3000:../uvc.c      ****                    	CyU3PThreadSleep(300);
3001:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3002:../uvc.c      ****                     CyU3PThreadSleep(500);
3003:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3004:../uvc.c      ****                     CyU3PThreadSleep(500);
3005:../uvc.c      **** #endif
3006:../uvc.c      **** #if 0
3007:../uvc.c      ****                     switch (setRes)
3008:../uvc.c      ****                     {
3009:../uvc.c      ****                     	case 1: //1944
3010:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3011:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3012:../uvc.c      ****                     		break;
3013:../uvc.c      ****                     	case 2: //1080
3014:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3015:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3016:../uvc.c      ****                     		break;
3017:../uvc.c      ****                     	case 3: //720
3018:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3019:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3020:../uvc.c      ****                     		break;
3021:../uvc.c      ****                     	default:
3022:../uvc.c      ****                     		break;
3023:../uvc.c      ****                     }
3024:../uvc.c      **** #endif
3025:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3026:../uvc.c      **** 
3027:../uvc.c      ****                     gpif_initialized = CyTrue;
3028:../uvc.c      ****                     CyU3PThreadSleep(200);
3029:../uvc.c      ****                     
3030:../uvc.c      ****                 }
3031:../uvc.c      ****                 else
3032:../uvc.c      ****                 {
3033:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3034:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3035:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3036:../uvc.c      ****                 }
3037:../uvc.c      ****             }
3038:../uvc.c      ****         }
3039:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3040:../uvc.c      **** 
3041:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3042:../uvc.c      ****         CyU3PThreadRelinquish ();
3043:../uvc.c      ****     }
3044:../uvc.c      **** }
3045:../uvc.c      **** 
3046:../uvc.c      **** /*
3047:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3048:../uvc.c      ****  */
3049:../uvc.c      **** 
3050:../uvc.c      **** static void
3051:../uvc.c      **** UVCHandleProcessingUnitRqts (
3052:../uvc.c      ****         void)
3053:../uvc.c      **** {
3054:../uvc.c      ****     uint8_t CtrlAdd;
3055:../uvc.c      **** #ifdef DbgInfo
3056:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3057:../uvc.c      **** #endif
3058:../uvc.c      ****     switch (wValue)
3059:../uvc.c      ****     {
3060:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3061:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3062:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3063:../uvc.c      ****     		break;
3064:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3065:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3066:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3067:../uvc.c      ****     		break;
3068:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3069:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3070:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3071:../uvc.c      **** 			break;
3072:../uvc.c      **** 
3073:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3074:../uvc.c      **** 
3075:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3076:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3077:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3078:../uvc.c      ****       		break;
3079:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3080:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3081:../uvc.c      ****      		ControlHandle(HueCtlID5);
3082:../uvc.c      ****      		break;
3083:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3084:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3085:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3086:../uvc.c      ****           		break;
3087:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3088:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3089:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3090:../uvc.c      ****           		break;
3091:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3092:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3093:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3094:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3095:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3096:../uvc.c      ****     		break;
3097:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3098:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3099:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3100:../uvc.c      ****     		break;
3101:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3102:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3103:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3104:../uvc.c      ****     		break;
3105:../uvc.c      **** 
3106:../uvc.c      ****         default:
3107:../uvc.c      ****             /*
3108:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3109:../uvc.c      ****              * other controls.
3110:../uvc.c      ****              */
3111:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3112:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3113:../uvc.c      ****             break;
3114:../uvc.c      ****     }
3115:../uvc.c      **** }
3116:../uvc.c      **** 
3117:../uvc.c      **** /*
3118:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3119:../uvc.c      ****  */
3120:../uvc.c      **** static void
3121:../uvc.c      **** UVCHandleCameraTerminalRqts (
3122:../uvc.c      ****         void)
3123:../uvc.c      **** {
3124:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3125:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3126:../uvc.c      ****     uint16_t readCount;
3127:../uvc.c      ****     uint16_t zoomVal;
3128:../uvc.c      ****     int32_t  panVal, tiltVal;
3129:../uvc.c      ****     CyBool_t sendData = CyFalse;
3130:../uvc.c      **** #endif
3131:../uvc.c      ****     uint8_t CtrlAdd;
3132:../uvc.c      **** 
3133:../uvc.c      ****     switch (wValue)
3134:../uvc.c      ****     {
3135:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3136:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3137:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3138:../uvc.c      ****     		break;
3139:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3140:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3141:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3142:../uvc.c      ****     		break;
3143:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3144:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3145:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3146:../uvc.c      **** 			break;
3147:../uvc.c      **** 
3148:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3149:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3150:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3151:../uvc.c      **** 			break;
3152:../uvc.c      **** 
3153:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3154:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3155:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3156:../uvc.c      ****       		break;
3157:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3158:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3159:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3160:../uvc.c      ****      		break;
3161:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3162:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3163:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3164:../uvc.c      ****           		break;
3165:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3166:../uvc.c      ****           		break;
3167:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3168:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3169:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3170:../uvc.c      ****      		break;
3171:../uvc.c      **** 
3172:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3173:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3174:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3175:../uvc.c      ****     		break;
3176:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3177:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3178:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3179:../uvc.c      ****     		break;
3180:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3181:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3182:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3183:../uvc.c      ****     		break;
3184:../uvc.c      **** 
3185:../uvc.c      ****         default:
3186:../uvc.c      ****             /*
3187:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3188:../uvc.c      ****              * other controls.
3189:../uvc.c      ****              */
3190:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3191:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3192:../uvc.c      ****             break;
3193:../uvc.c      ****     }
3194:../uvc.c      **** 
3195:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3196:../uvc.c      ****     switch (wValue)
3197:../uvc.c      ****     {
3198:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3199:../uvc.c      ****             switch (bRequest)
3200:../uvc.c      ****             {
3201:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3202:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3203:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3204:../uvc.c      ****                     break;
3205:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3206:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3207:../uvc.c      ****                     sendData = CyTrue;
3208:../uvc.c      ****                     break;
3209:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3210:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3211:../uvc.c      ****                     sendData = CyTrue;
3212:../uvc.c      ****                     break;
3213:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3214:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3215:../uvc.c      ****                     sendData = CyTrue;
3216:../uvc.c      ****                     break;
3217:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3218:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3219:../uvc.c      ****                     sendData = CyTrue;
3220:../uvc.c      ****                     break;
3221:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3222:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3223:../uvc.c      ****                     sendData = CyTrue;
3224:../uvc.c      ****                     break;
3225:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3226:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3227:../uvc.c      ****                             glEp0Buffer, &readCount);
3228:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3229:../uvc.c      ****                     {
3230:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3231:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3232:../uvc.c      ****                     }
3233:../uvc.c      ****                     break;
3234:../uvc.c      ****                 default:
3235:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3236:../uvc.c      ****                     break;
3237:../uvc.c      ****             }
3238:../uvc.c      **** 
3239:../uvc.c      ****             if (sendData)
3240:../uvc.c      ****             {
3241:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3242:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3243:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3244:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3245:../uvc.c      ****             }
3246:../uvc.c      ****             break;
3247:../uvc.c      **** 
3248:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3249:../uvc.c      ****             switch (bRequest)
3250:../uvc.c      ****             {
3251:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3252:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3253:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3254:../uvc.c      ****                     break;
3255:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3256:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3257:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3258:../uvc.c      ****                     sendData = CyTrue;
3259:../uvc.c      ****                     break;
3260:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3261:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3262:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3263:../uvc.c      ****                     sendData = CyTrue;
3264:../uvc.c      ****                     break;
3265:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3266:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3267:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3268:../uvc.c      ****                     sendData = CyTrue;
3269:../uvc.c      ****                     break;
3270:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3271:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3272:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3273:../uvc.c      ****                     sendData = CyTrue;
3274:../uvc.c      ****                     break;
3275:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3276:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3277:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3278:../uvc.c      ****                     sendData = CyTrue;
3279:../uvc.c      ****                     break;
3280:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3281:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3282:../uvc.c      ****                             glEp0Buffer, &readCount);
3283:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3284:../uvc.c      ****                     {
3285:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3286:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3287:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3288:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3289:../uvc.c      **** 
3290:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3291:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3292:../uvc.c      ****                     }
3293:../uvc.c      ****                     break;
3294:../uvc.c      ****                 default:
3295:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3296:../uvc.c      ****                     break;
3297:../uvc.c      ****             }
3298:../uvc.c      **** 
3299:../uvc.c      ****             if (sendData)
3300:../uvc.c      ****             {
3301:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3302:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3303:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3304:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3305:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3306:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3307:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3308:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3309:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3310:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3311:../uvc.c      ****             }
3312:../uvc.c      ****             break;
3313:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3314:../uvc.c      ****         default:
3315:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3316:../uvc.c      ****             break;
3317:../uvc.c      ****     }
3318:../uvc.c      **** #endif
3319:../uvc.c      **** }
3320:../uvc.c      **** 
3321:../uvc.c      **** /*
3322:../uvc.c      ****  * Handler for UVC Interface control requests.
3323:../uvc.c      ****  */
3324:../uvc.c      **** static void
3325:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3326:../uvc.c      ****         void)
3327:../uvc.c      **** {
3328:../uvc.c      **** 
3329:../uvc.c      ****     switch (wValue)
3330:../uvc.c      ****     {
3331:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3332:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3333:../uvc.c      ****     		break;
3334:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3335:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3336:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3337:../uvc.c      ****     		break;
3338:../uvc.c      ****     	default:
3339:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3340:../uvc.c      ****      		break;
3341:../uvc.c      ****     }
3342:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3343:../uvc.c      **** 
3344:../uvc.c      **** }
3345:../uvc.c      **** 
3346:../uvc.c      **** /*
3347:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3348:../uvc.c      ****  */
3349:../uvc.c      **** static void
3350:../uvc.c      **** UVCHandleExtensionUnitRqts (
3351:../uvc.c      ****         void)
3352:../uvc.c      **** {
3353:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3354:../uvc.c      **** 
3355:../uvc.c      **** #ifdef DbgInfo
3356:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3357:../uvc.c      **** #endif
3358:../uvc.c      ****     switch (wValue)
3359:../uvc.c      ****     {
3360:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3361:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3362:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3363:../uvc.c      ****     		break;
3364:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3365:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3366:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3367:../uvc.c      ****     		break;
3368:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3369:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3370:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3371:../uvc.c      ****      		break;
3372:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3373:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3374:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3375:../uvc.c      ****     		break;
3376:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3377:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3378:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3379:../uvc.c      ****     		break;
3380:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3381:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3382:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3383:../uvc.c      ****      		break;
3384:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3385:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3386:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3387:../uvc.c      ****     		break;
3388:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3389:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3390:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3391:../uvc.c      ****     		break;
3392:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3393:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3394:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3395:../uvc.c      ****      		break;
3396:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3397:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3398:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3399:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3400:../uvc.c      ****     		}else/* no support for 1080p camera */
3401:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3402:../uvc.c      ****     		break;
3403:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3404:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3405:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3406:../uvc.c      ****     		break;
3407:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3408:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3409:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3410:../uvc.c      ****     		break;
3411:../uvc.c      **** 
3412:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3413:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3414:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3415:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3416:../uvc.c      ****     		break;
3417:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3418:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3419:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3420:../uvc.c      ****     		//break;
3421:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3422:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3423:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3424:../uvc.c      ****     		break;
3425:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3426:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3427:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3428:../uvc.c      ****     		break;
3429:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3430:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3431:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3432:../uvc.c      ****     		break;
3433:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3434:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3435:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3436:../uvc.c      ****     		break;
3437:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3438:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3439:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3440:../uvc.c      ****     		break;
3441:../uvc.c      ****    	default:
3442:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3443:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3444:../uvc.c      ****     		break;
3445:../uvc.c      ****     }
3446:../uvc.c      **** 
3447:../uvc.c      **** }
3448:../uvc.c      **** 
3449:../uvc.c      **** /*
3450:../uvc.c      ****  * Handler for the video streaming control requests.
3451:../uvc.c      ****  */
3452:../uvc.c      **** static void
3453:../uvc.c      **** UVCHandleVideoStreamingRqts (
3454:../uvc.c      ****         void)
3455:../uvc.c      **** {
3456:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3457:../uvc.c      ****     uint16_t readCount;
3458:../uvc.c      **** 
3459:../uvc.c      ****     switch (wValue)
3460:../uvc.c      ****     {
3461:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3462:../uvc.c      ****             switch (bRequest)
3463:../uvc.c      ****             {
3464:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3465:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3466:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3467:../uvc.c      ****                     break;
3468:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3469:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3470:../uvc.c      ****                     glEp0Buffer[1] = 0;
3471:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3472:../uvc.c      ****                     break;
3473:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3474:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3475:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3476:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3477:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3478:../uvc.c      ****                     {
3479:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3480:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3481:../uvc.c      **** 
3482:../uvc.c      ****                     }
3483:../uvc.c      ****                     else
3484:../uvc.c      ****                     {
3485:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3486:../uvc.c      ****                     }
3487:../uvc.c      ****                     break;
3488:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3489:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3490:../uvc.c      ****                             glCommitCtrl, &readCount);
3491:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3492:../uvc.c      ****                     {
3493:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3494:../uvc.c      ****                         {
3495:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3496:../uvc.c      ****                                active data structure. */
3497:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3498:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3499:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3500:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3501:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3502:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3503:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3504:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3505:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3506:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3507:../uvc.c      **** #if 0
3508:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3509:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3510:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3511:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3512:../uvc.c      **** #endif
3513:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3514:../uvc.c      ****                        }
3515:../uvc.c      ****                     }
3516:../uvc.c      ****                     break;
3517:../uvc.c      ****                 default:
3518:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3519:../uvc.c      ****                     break;
3520:../uvc.c      ****             }
3521:../uvc.c      ****             break;
3522:../uvc.c      **** 
3523:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3524:../uvc.c      ****             switch (bRequest)
3525:../uvc.c      ****             {
3526:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3527:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3528:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3529:../uvc.c      ****                     break;
3530:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3531:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3532:../uvc.c      ****                     glEp0Buffer[1] = 0;
3533:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3534:../uvc.c      ****                     break;
3535:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3536:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3537:../uvc.c      ****                     {
3538:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3539:../uvc.c      ****                     }
3540:../uvc.c      ****                     else
3541:../uvc.c      ****                     {
3542:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3543:../uvc.c      ****                     }
3544:../uvc.c      ****                     break;
3545:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3546:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3547:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3548:../uvc.c      ****                        */
3549:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3550:../uvc.c      ****                             glCommitCtrl, &readCount);
3551:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3552:../uvc.c      ****                     {
3553:../uvc.c      ****                         switch (glCommitCtrl[3])
3554:../uvc.c      ****                          {
3555:../uvc.c      ****                          	case 1: //1944
3556:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3557:../uvc.c      ****                          		CyU3PThreadSleep(500);
3558:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3559:../uvc.c      ****                          		break;
3560:../uvc.c      ****                          	case 2: //1080
3561:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3562:../uvc.c      ****                          		CyU3PThreadSleep(500);
3563:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3564:../uvc.c      ****                          		break;
3565:../uvc.c      ****                          	case 3: //720
3566:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3567:../uvc.c      ****                          		CyU3PThreadSleep(500);
3568:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3569:../uvc.c      ****                          		break;
3570:../uvc.c      ****                          	case 4: //VGA
3571:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3572:../uvc.c      ****                          		CyU3PThreadSleep(500);
3573:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3574:../uvc.c      ****                          		break;
3575:../uvc.c      ****                          	default:
3576:../uvc.c      ****                          		break;
3577:../uvc.c      ****                          }
3578:../uvc.c      ****                         setRes = glCommitCtrl[3];
3579:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3580:../uvc.c      **** 
3581:../uvc.c      **** #if 0
3582:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3583:../uvc.c      ****                         {
3584:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3585:../uvc.c      ****                         }
3586:../uvc.c      ****                         else
3587:../uvc.c      ****                         {
3588:../uvc.c      ****                             SensorScaling_VGA ();
3589:../uvc.c      ****                         }
3590:../uvc.c      **** #endif
3591:../uvc.c      ****                         /* We can start streaming video now. */
3592:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3593:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3594:../uvc.c      ****                         {
3595:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3596:../uvc.c      ****                         }
3597:../uvc.c      ****                     }
3598:../uvc.c      ****                     break;
3599:../uvc.c      **** 
3600:../uvc.c      ****                 default:
3601:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3602:../uvc.c      ****                     break;
3603:../uvc.c      ****             }
3604:../uvc.c      ****             break;
3605:../uvc.c      **** 
3606:../uvc.c      **** /* still image streaming handler */
3607:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3608:../uvc.c      ****                 switch (bRequest)
3609:../uvc.c      ****                 {
3610:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3611:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3612:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3613:../uvc.c      ****                         break;
3614:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3615:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3616:../uvc.c      ****                         glEp0Buffer[1] = 0;
3617:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3618:../uvc.c      ****                         break;
3619:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3620:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3621:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3622:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3623:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3624:../uvc.c      ****                         {
3625:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3626:../uvc.c      ****                         }
3627:../uvc.c      ****                         else
3628:../uvc.c      ****                         {
3629:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3630:../uvc.c      ****                         }
3631:../uvc.c      ****                         break;
3632:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3633:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3634:../uvc.c      ****                                 glCommitCtrl, &readCount);
3635:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3636:../uvc.c      ****                         {
3637:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3638:../uvc.c      ****                             {
3639:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3640:../uvc.c      ****                                    active data structure. */
3641:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3642:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3643:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3644:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3645:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3646:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3647:../uvc.c      ****                             }
3648:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3649:../uvc.c      ****                         }
3650:../uvc.c      ****                         break;
3651:../uvc.c      ****                     default:
3652:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3653:../uvc.c      ****                         break;
3654:../uvc.c      ****                 }
3655:../uvc.c      ****                 break;
3656:../uvc.c      **** 
3657:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3658:../uvc.c      ****                 switch (bRequest)
3659:../uvc.c      ****                 {
3660:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3661:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3662:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3663:../uvc.c      ****                         break;
3664:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3665:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3666:../uvc.c      ****                         glEp0Buffer[1] = 0;
3667:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3668:../uvc.c      ****                         break;
3669:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3670:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3671:../uvc.c      ****                         {
3672:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3673:../uvc.c      ****                         }
3674:../uvc.c      ****                         else
3675:../uvc.c      ****                         {
3676:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3677:../uvc.c      ****                         }
3678:../uvc.c      ****                         break;
3679:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3680:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3681:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3682:../uvc.c      ****                            */
3683:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3684:../uvc.c      ****                                 glCommitCtrl, &readCount);
3685:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3686:../uvc.c      ****                         {
3687:../uvc.c      ****     #if 0
3688:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3689:../uvc.c      ****                             {
3690:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3691:../uvc.c      ****                             }
3692:../uvc.c      ****                             else
3693:../uvc.c      ****                             {
3694:../uvc.c      ****                                 SensorScaling_VGA ();
3695:../uvc.c      ****                             }
3696:../uvc.c      ****                             /* We can start streaming video now. */
3697:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3698:../uvc.c      **** 
3699:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3700:../uvc.c      ****                             {
3701:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3702:../uvc.c      ****                             }
3703:../uvc.c      **** 	#endif
3704:../uvc.c      ****                            switch (glCommitCtrl[1])
3705:../uvc.c      ****                              {
3706:../uvc.c      ****                              	case 4: //1944
3707:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3708:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3709:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3710:../uvc.c      ****                              		break;
3711:../uvc.c      ****                              	case 3: //1080
3712:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3713:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3714:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3715:../uvc.c      ****                              		break;
3716:../uvc.c      ****                              	case 2: //720
3717:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3718:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3719:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3720:../uvc.c      ****                              		break;
3721:../uvc.c      ****                             	case 1: //VGA
3722:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3723:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3724:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3725:../uvc.c      ****                              		break;
3726:../uvc.c      ****                               	default:
3727:../uvc.c      ****                              		break;
3728:../uvc.c      ****                              }
3729:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3730:../uvc.c      **** 
3731:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3732:../uvc.c      **** 
3733:../uvc.c      ****                         }
3734:../uvc.c      ****                         break;
3735:../uvc.c      **** 
3736:../uvc.c      ****                     default:
3737:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3738:../uvc.c      ****                         break;
3739:../uvc.c      ****                 }
3740:../uvc.c      ****                 break;
3741:../uvc.c      **** 
3742:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3743:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3744:../uvc.c      ****             	switch (bRequest)
3745:../uvc.c      ****                 {
3746:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3747:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3748:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3749:../uvc.c      ****                         break;
3750:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3751:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3752:../uvc.c      ****                         glEp0Buffer[1] = 0;
3753:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3754:../uvc.c      ****                         break;
3755:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3756:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3757:../uvc.c      ****                         {
3758:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3759:../uvc.c      ****                         }
3760:../uvc.c      ****                         else
3761:../uvc.c      ****                         {
3762:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3763:../uvc.c      ****                         }
3764:../uvc.c      ****                         break;
3765:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3766:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3767:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3768:../uvc.c      ****                            */
3769:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3770:../uvc.c      ****                                 glCommitCtrl, &readCount);
3771:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3772:../uvc.c      ****                         {
3773:../uvc.c      ****     #if 1
3774:../uvc.c      ****                             /* We can start still streaming video now. */
3775:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3776:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3777:../uvc.c      ****                             {
3778:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3779:../uvc.c      ****                             }
3780:../uvc.c      ****     #endif
3781:../uvc.c      ****                             else{
3782:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3783:../uvc.c      ****                             //stillcont = 0;
3784:../uvc.c      ****                             }
3785:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3786:../uvc.c      ****                         }else{
3787:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3788:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3789:../uvc.c      ****                         }
3790:../uvc.c      ****                         break;
3791:../uvc.c      **** 
3792:../uvc.c      ****                     default:
3793:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3794:../uvc.c      ****                         break;
3795:../uvc.c      ****                 }
3796:../uvc.c      ****                 break;
3797:../uvc.c      **** 
3798:../uvc.c      ****         default:
3799:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3800:../uvc.c      ****             break;
3801:../uvc.c      ****     }
3802:../uvc.c      **** }
3803:../uvc.c      **** 
3804:../uvc.c      **** /*
3805:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3806:../uvc.c      ****  */
3807:../uvc.c      **** void
3808:../uvc.c      **** UVCAppEP0Thread_Entry (
3809:../uvc.c      ****         uint32_t input)
3810:../uvc.c      **** {
3811:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3812:../uvc.c      ****     uint32_t eventFlag;
3813:../uvc.c      **** 	CyBool_t value;
3814:../uvc.c      **** 	CyBool_t *valueptr = &value;
3815:../uvc.c      **** 
3816:../uvc.c      **** 
3817:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3818:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3819:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3820:../uvc.c      **** 
3821:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3822:../uvc.c      **** #endif
3823:../uvc.c      **** 
3824:../uvc.c      ****     /* for interrupt status test */
3825:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3826:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3827:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3828:../uvc.c      **** 
3829:../uvc.c      ****     for (;;)
3830:../uvc.c      ****     {
3831:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3832:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3833:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3834:../uvc.c      ****         {
3835:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3836:../uvc.c      ****             if (!isUsbConnected)
3837:../uvc.c      ****             {
3838:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3839:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3840:../uvc.c      ****                 {
3841:../uvc.c      ****                     isUsbConnected = CyTrue;
3842:../uvc.c      ****                 }
3843:../uvc.c      ****             }
3844:../uvc.c      **** //#ifdef DbgInfo
3845:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3846:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3847:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3848:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3849:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3850:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3851:../uvc.c      **** //#endif
3852:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3853:../uvc.c      ****             {
3854:../uvc.c      ****             	switch ((wIndex >> 8))
3855:../uvc.c      ****                 {
3856:../uvc.c      **** 
3857:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3858:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3859:../uvc.c      ****                         break;
3860:../uvc.c      **** 
3861:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3862:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3863:../uvc.c      ****                         break;
3864:../uvc.c      **** 
3865:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3866:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3867:../uvc.c      ****                         break;
3868:../uvc.c      **** 
3869:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3870:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3871:../uvc.c      ****                         break;
3872:../uvc.c      **** 
3873:../uvc.c      ****                     default:
3874:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3875:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3876:../uvc.c      ****                         break;
3877:../uvc.c      ****                 }
3878:../uvc.c      ****             }
3879:../uvc.c      **** 
3880:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3881:../uvc.c      ****             {
3882:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3883:../uvc.c      **** 
3884:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3885:../uvc.c      ****                 {
3886:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3887:../uvc.c      ****                 }
3888:../uvc.c      ****                 else
3889:../uvc.c      ****                 {
3890:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3891:../uvc.c      ****                 }
3892:../uvc.c      ****             }
3893:../uvc.c      **** 
3894:../uvc.c      ****             /* handle interrupt status event */
3895:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3896:../uvc.c      ****             {
3897:../uvc.c      **** 
3898:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3899:../uvc.c      ****             	/** preparing interrupt status data **/
3900:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3901:../uvc.c      **** 
3902:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3903:../uvc.c      **** 
3904:../uvc.c      **** #if 0 //for real button
3905:../uvc.c      **** 				if(value&&(!snapButFlag)){
3906:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3907:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3908:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3909:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3910:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3911:../uvc.c      **** 
3912:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3913:../uvc.c      **** 					interStabuf.size   = 1024;
3914:../uvc.c      **** 					interStabuf.status = 0;
3915:../uvc.c      **** 
3916:../uvc.c      **** 					interStabuf.count = 4;
3917:../uvc.c      **** 
3918:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3919:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3920:../uvc.c      **** 
3921:../uvc.c      **** 					/** send a interrupt status data **/
3922:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3923:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3924:../uvc.c      **** 					{
3925:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3926:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3927:../uvc.c      **** 					}
3928:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3929:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3930:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3931:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3932:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3933:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3934:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3935:../uvc.c      **** 
3936:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3937:../uvc.c      **** 					interStabuf.size   = 1024;
3938:../uvc.c      **** 					interStabuf.status = 0;
3939:../uvc.c      **** 
3940:../uvc.c      **** 					interStabuf.count = 4;
3941:../uvc.c      **** 
3942:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3943:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3944:../uvc.c      **** 
3945:../uvc.c      **** 					/** send a interrupt status data **/
3946:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3947:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3948:../uvc.c      **** 					{
3949:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3950:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3951:../uvc.c      **** 					}
3952:../uvc.c      **** 
3953:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3954:../uvc.c      **** 					stiflag = 0xFF;
3955:../uvc.c      **** 				}
3956:../uvc.c      **** #else			//for botton simulation
3957:../uvc.c      **** 				if(snapButFlag == 0x0f){
3958:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3959:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3960:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3961:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3962:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3963:../uvc.c      **** 
3964:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3965:../uvc.c      **** 					interStabuf.size   = 1024;
3966:../uvc.c      **** 					interStabuf.status = 0;
3967:../uvc.c      **** 
3968:../uvc.c      **** 					interStabuf.count = 4;
3969:../uvc.c      **** 
3970:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3971:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3972:../uvc.c      **** 
3973:../uvc.c      **** 					/** send a interrupt status data **/
3974:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3975:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3976:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3977:../uvc.c      **** 					{
3978:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3979:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3980:../uvc.c      **** 					}
3981:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3982:../uvc.c      **** 
3983:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3984:../uvc.c      **** 				}else if(!snapButFlag){
3985:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3986:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3987:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3988:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3989:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3990:../uvc.c      **** 
3991:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3992:../uvc.c      **** 					interStabuf.size   = 1024;
3993:../uvc.c      **** 					interStabuf.status = 0;
3994:../uvc.c      **** 
3995:../uvc.c      **** 					interStabuf.count = 4;
3996:../uvc.c      **** 
3997:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3998:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3999:../uvc.c      **** 
4000:../uvc.c      **** 					/** send a interrupt status data **/
4001:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4002:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4003:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4004:../uvc.c      **** 					{
4005:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4006:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4007:../uvc.c      **** 					}
4008:../uvc.c      **** 
4009:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4010:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4011:../uvc.c      **** 				}
4012:../uvc.c      **** #endif
4013:../uvc.c      **** 
4014:../uvc.c      ****             }
4015:../uvc.c      **** 
4016:../uvc.c      **** 
4017:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4018:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4019:../uvc.c      ****             {
4020:../uvc.c      ****                 /* Get the command buffer */
4021:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4022:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4023:../uvc.c      ****                 {
4024:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4025:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4026:../uvc.c      ****                 }
4027:../uvc.c      **** 
4028:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4029:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4030:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4031:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4032:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4033:../uvc.c      ****                  * register value high byte and register value low byte.
4034:../uvc.c      ****                  */
4035:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4036:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4037:../uvc.c      ****                 {
4038:../uvc.c      ****                     if (dmaInfo.count == 3)
4039:../uvc.c      ****                     {
4040:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4041:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4042:../uvc.c      ****                         dmaInfo.count = 3;
4043:../uvc.c      ****                     }
4044:../uvc.c      ****                     else if (dmaInfo.count == 4)
4045:../uvc.c      ****                     {
4046:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4047:../uvc.c      ****                         {
4048:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4049:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4050:../uvc.c      ****                         }
4051:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4052:../uvc.c      ****                     }
4053:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4054:../uvc.c      ****                 }
4055:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4056:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4057:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4058:../uvc.c      ****                  */
4059:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4060:../uvc.c      ****                 {
4061:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4062:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4063:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4064:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4065:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4066:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4067:../uvc.c      ****                         	break;
4068:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4069:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4070:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4071:../uvc.c      ****                         	break;*/
4072:../uvc.c      ****                     dmaInfo.count -= 2;
4073:../uvc.c      ****                 }
4074:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4075:../uvc.c      ****                 else
4076:../uvc.c      ****                 {
4077:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4078:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4079:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4080:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4081:../uvc.c      ****                 }
4082:../uvc.c      **** 
4083:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4084:../uvc.c      ****                 dmaInfo.size   = 1024;
4085:../uvc.c      ****                 dmaInfo.status = 0;
4086:../uvc.c      **** 
4087:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4088:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4089:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4090:../uvc.c      ****                 {
4091:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4092:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4093:../uvc.c      ****                 }
4094:../uvc.c      **** 
4095:../uvc.c      ****                 /* Wait until the response has gone out. */
4096:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4097:../uvc.c      **** 
4098:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4099:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4100:../uvc.c      ****                 {
4101:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4102:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4103:../uvc.c      ****                 }
4104:../uvc.c      ****             }
4105:../uvc.c      **** #endif
4106:../uvc.c      ****         }
4107:../uvc.c      ****         /* Allow other ready threads to run. */
4108:../uvc.c      ****         CyU3PThreadRelinquish ();
4109:../uvc.c      ****     }
4110:../uvc.c      **** }
4111:../uvc.c      **** 
4112:../uvc.c      **** /*
4113:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4114:../uvc.c      ****  * added 10/2013
4115:../uvc.c      ****  */
4116:../uvc.c      **** /*
4117:../uvc.c      **** static uint8_t timeDelay[64] = {
4118:../uvc.c      **** 
4119:../uvc.c      **** };
4120:../uvc.c      **** */
4121:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4121 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4122:../uvc.c      **** 
4123:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
4124:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4125:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4126:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4127:../uvc.c      **** 	VdstateDes *lcStaDes;
4128:../uvc.c      **** 	uint32_t flag = 0;
4129:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4130:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4131:../uvc.c      **** 	uint8_t i;
4132:../uvc.c      **** 	uint16_t delaytime;
4133:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4134:../uvc.c      **** 
4135:../uvc.c      **** #if 0 //for test the command queue
4136:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4137:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4138:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4139:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4140:../uvc.c      **** 		lcCmdDes += 1;
4141:../uvc.c      **** 	}
4142:../uvc.c      **** #endif
4143:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4144:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4144 0
  36 0004 10229FE5 		ldr	r2, .L22
4128:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4128 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4121:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4121 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4144 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4128:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4128 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4144 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4145:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4145 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4146:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4146 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4147:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4147 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4148:../uvc.c      **** 
4149:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4149 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4150:../uvc.c      ****         /* Allow other ready threads to run. */
4151:../uvc.c      **** 
4152:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4152 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4149:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4149 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4153:../uvc.c      **** 	}
4154:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4154 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
4155:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4156:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4157:../uvc.c      **** 	//CyU3PThreadSleep(100);
4158:../uvc.c      **** 	//SetCurCmd();
4159:../uvc.c      **** 	/*********** the loop of the thread ***********/
4160:../uvc.c      **** 	for(;;){
4161:../uvc.c      **** 
4162:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4162 0
 101 0098 0060E0E3 		mvn	r6, #0
4163:../uvc.c      **** /*  // for test GPIO output
4164:../uvc.c      **** 		if(trigger)
4165:../uvc.c      **** 		{
4166:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4167:../uvc.c      **** 			{
4168:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4169:../uvc.c      **** 			}
4170:../uvc.c      **** 
4171:../uvc.c      **** 		}else{
4172:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4173:../uvc.c      **** 			{
4174:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4175:../uvc.c      **** 			}
4176:../uvc.c      **** 
4177:../uvc.c      **** 		}
4178:../uvc.c      **** */
4179:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4180:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4181:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
4182:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
4183:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
4184:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
4185:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
4186:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4187:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4188:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4189:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4190:../uvc.c      **** #endif
4191:../uvc.c      **** 				}
4192:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
4193:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
4194:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4195:../uvc.c      **** 			}
4196:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4197:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4198:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4199:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4200:../uvc.c      **** 
4201:../uvc.c      **** 				/*
4202:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4203:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4204:../uvc.c      **** 				*/
4205:../uvc.c      **** 
4206:../uvc.c      **** 				/* find a available command */
4207:../uvc.c      **** 				i = 0;
4208:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4208 0
 103 009c 0090A0E3 		mov	r9, #0
4209:../uvc.c      **** 					i++;
4210:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4211:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4212:../uvc.c      **** 				}
4213:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4214:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4215:../uvc.c      **** 					i = lcCmdDes->curNum;
4216:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4217:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4218:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4219:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4220:../uvc.c      **** #if 1
4221:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4222:../uvc.c      **** 						case 0x20:
4223:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4224:../uvc.c      **** 							delaytime = 500;
4225:../uvc.c      **** 							break;
4226:../uvc.c      **** 						case 0x21:
4227:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4228:../uvc.c      **** 							delaytime = 500;
4229:../uvc.c      **** 							break;
4230:../uvc.c      **** 						case 0x22:
4231:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4232:../uvc.c      **** 							delaytime = 300;
4233:../uvc.c      **** 							break;
4234:../uvc.c      **** 						case 0x23:
4235:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4236:../uvc.c      **** 							delaytime = 300;
4237:../uvc.c      **** 							break;
4238:../uvc.c      **** 						default:
4239:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4240:../uvc.c      **** 							break;
4241:../uvc.c      **** 					}
4242:../uvc.c      **** #endif
4243:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4244:../uvc.c      **** 					/** timer's ticket modify **/
4245:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4246:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4247:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4248:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4249:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4250:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4251:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4252:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4253:../uvc.c      **** #endif
4254:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4255:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4256:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4257:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4258:../uvc.c      **** 						}else{
4259:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4260:../uvc.c      **** 						}
4261:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4262:../uvc.c      **** 					}else{
4263:../uvc.c      **** 						lcCmdDes->curNum ++;
4264:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4264 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
4162:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4162 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4179:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4179 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4196:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 4196 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
4198:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 4198 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
4199:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 4199 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
4208:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4208 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
4210:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 4210 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
4209:../uvc.c      **** 					i++;
 140              		.loc 1 4209 0
 141 00f4 011083E2 		add	r1, r3, #1
4208:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 4208 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
4209:../uvc.c      **** 					i++;
 144              		.loc 1 4209 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
4208:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 4208 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
4214:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 4214 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
4216:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 4216 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4221:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 4221 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
4216:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 4216 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
4221:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 4221 0
 166 0128 20C042E2 		sub	ip, r2, #32
4216:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 4216 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
4217:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 4217 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
4218:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 4218 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
4219:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 4219 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
4221:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 4221 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
4235:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 4235 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
4237:../uvc.c      **** 							break;
 193              		.loc 1 4237 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
4246:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 4246 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
4247:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 4247 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
4254:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 4254 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
4263:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 4263 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 4264 0
 213 018c 3C808415 		strne	r8, [r4, #60]
4254:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 4254 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
4265:../uvc.c      **** 					}
4266:../uvc.c      **** 				}else{
4267:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4268:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4269:../uvc.c      **** 				}
4270:../uvc.c      **** 			}
4271:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 4271 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
4272:../uvc.c      **** /*
4273:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4274:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4275:../uvc.c      **** */
4276:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4277:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4278:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4279:../uvc.c      **** #endif
4280:../uvc.c      **** 
4281:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4282:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4283:../uvc.c      **** #if 0
4284:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4285:../uvc.c      **** 
4286:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4287:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4288:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4289:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4290:../uvc.c      **** 			    i = 0;
4291:../uvc.c      **** 				 switch(cmdCopyIdx)
4292:../uvc.c      **** 				 {
4293:../uvc.c      **** 					 case BrgtCtlID1:
4294:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4295:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4296:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4297:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4298:../uvc.c      **** 							 i++;
4299:../uvc.c      **** 						 }
4300:../uvc.c      **** 						 else{
4301:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4302:../uvc.c      **** 						 }
4303:../uvc.c      **** 
4304:../uvc.c      **** 						 CyU3PBusyWait(500);
4305:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4306:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4307:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4308:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4309:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4310:../uvc.c      **** 						 }
4311:../uvc.c      **** 						 else{
4312:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4313:../uvc.c      **** 						 }
4314:../uvc.c      **** 						 break;
4315:../uvc.c      **** 					 case HueCtlID5:
4316:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4317:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4318:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4319:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4320:../uvc.c      **** 						 }
4321:../uvc.c      **** 						 else{
4322:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4323:../uvc.c      **** 						 }
4324:../uvc.c      **** 						 break;
4325:../uvc.c      **** 					 case SaturCtlID6:
4326:../uvc.c      **** 					 case WBTLevCtlID10:
4327:../uvc.c      **** 					 default:
4328:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4329:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4330:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4331:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4332:../uvc.c      **** 						 }
4333:../uvc.c      **** 						 else{
4334:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4335:../uvc.c      **** 						 }
4336:../uvc.c      **** 						 break;
4337:../uvc.c      **** 				 }
4338:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4339:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4340:../uvc.c      **** 			}
4341:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4342:../uvc.c      **** #endif
4343:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4344:../uvc.c      **** 		/* Allow other ready threads to run. */
4345:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4346:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 4346 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
4347:../uvc.c      **** 		}
 224              		.loc 1 4347 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
4227:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 4227 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
4229:../uvc.c      **** 							break;
 232              		.loc 1 4229 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
4239:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 4239 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
4240:../uvc.c      **** 							break;
 241              		.loc 1 4240 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
4223:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 4223 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
4225:../uvc.c      **** 							break;
 249              		.loc 1 4225 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
4267:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 4267 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
4268:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 4268 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
4256:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 4256 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4255:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 4255 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
4256:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 4256 0
 269 01f0 23005CE3 		cmp	ip, #35
4257:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 4257 0
 271 01f4 24C04C82 		subhi	ip, ip, #36
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
4259:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 4259 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
4257:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 4257 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
4259:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 4259 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
4257:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 4257 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
4259:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 4259 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
4261:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 4261 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE26:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB18:
2735:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2735 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2737:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2737 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2738:../uvc.c      **** }
 318              		.loc 1 2738 0
2737:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2737 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE18:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB9:
1796:../uvc.c      **** {
 332              		.loc 1 1796 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1797:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1797 0
 338 0250 020050E3 		cmp	r0, #2
1796:../uvc.c      **** {
 339              		.loc 1 1796 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1796:../uvc.c      **** {
 347              		.loc 1 1796 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1797:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1797 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1833:../uvc.c      **** }
 361              		.loc 1 1833 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1818:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1818 0
 367 0280 28519FE5 		ldr	r5, .L34
1816:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1816 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1817:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1817 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1818:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1818 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1780 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1818:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1818 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1819:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1819 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1820:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1820 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1780 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1783 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1786:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1786 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1802:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1802 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1800:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1800 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1801:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1801 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1802:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1802 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1780 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1802:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1802 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1803:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1803 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1780 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1783 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1780 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1810:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1810 0
 462 0344 64509FE5 		ldr	r5, .L34
1808:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1808 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1809:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1809 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1810:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1810 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1780 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1810:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1810 0
 485 0374 286085E5 		str	r6, [r5, #40]
1811:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1811 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1780 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1783 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1786:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1786 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE9:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB11:
1993:../uvc.c      **** {
 523              		.loc 1 1993 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
2000:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 2000 0
 529 03c0 080051E3 		cmp	r1, #8
1993:../uvc.c      **** {
 530              		.loc 1 1993 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
2000:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 2000 0
 544 03d0 0B00000A 		beq	.L42
2052:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 2052 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
2054:../uvc.c      ****         consCount++;
 548              		.loc 1 2054 0
 549 03dc 7C319FE5 		ldr	r3, .L45
2055:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 2055 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
2054:../uvc.c      ****         consCount++;
 553              		.loc 1 2054 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
2055:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 2055 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
2054:../uvc.c      ****         consCount++;
 558              		.loc 1 2054 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
2057:../uvc.c      **** }
 565              		.loc 1 2057 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
2002:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 2002 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
2022:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 2022 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1741:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1741 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1740 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
2022:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 2022 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1740 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1741:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1741 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1742:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1742 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1747:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1747 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
2023:../uvc.c      ****                 pb++;
 607              		.loc 1 2023 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1747:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1747 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
2023:../uvc.c      ****                 pb++;
 617              		.loc 1 2023 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
2029:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 2029 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
2024:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 2024 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
2023:../uvc.c      ****                 pb++;
 623              		.loc 1 2023 0
 624 0460 013080E2 		add	r3, r0, #1
2029:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 2029 0
 626 0464 0F0052E3 		cmp	r2, #15
2023:../uvc.c      ****                 pb++;
 627              		.loc 1 2023 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
2024:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 2024 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
2029:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 2029 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
2036:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 2036 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
2040:../uvc.c      ****             prodCount++;
 639              		.loc 1 2040 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
2041:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 2041 0
 642 0480 0C1081E2 		add	r1, r1, #12
2040:../uvc.c      ****             prodCount++;
 643              		.loc 1 2040 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
2041:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 2041 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
2040:../uvc.c      ****             prodCount++;
 652              		.loc 1 2040 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
2041:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 2041 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
2040:../uvc.c      ****             prodCount++;
 657              		.loc 1 2040 0
 658 04a8 B0109FE5 		ldr	r1, .L45
2044:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 2044 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
2046:../uvc.c      ****                 prodCount--;
 662              		.loc 1 2046 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
2047:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 2047 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
2046:../uvc.c      ****                 prodCount--;
 667              		.loc 1 2046 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
2047:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 2047 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
2016:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 2016 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1740 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
2017:../uvc.c      ****                 fb++;
 693              		.loc 1 2017 0
 694 04f4 64409FE5 		ldr	r4, .L45
2016:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 2016 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1740 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1741:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1741 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1742:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1742 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
2017:../uvc.c      ****                 fb++;
 714              		.loc 1 2017 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
2030:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 2030 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
2031:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 2031 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2032:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 2032 0
 729 0540 24009FE5 		ldr	r0, .L45+12
2031:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 2031 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
2032:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 2032 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
2033:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 2033 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE11:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB10:
1841:../uvc.c      **** {
 757              		.loc 1 1841 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1846:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1846 0
 763 057c C0329FE5 		ldr	r3, .L72
1841:../uvc.c      **** {
 764              		.loc 1 1841 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1847:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1847 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1846:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1846 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1847:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1847 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1848:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1848 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1846:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1846 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1848:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1848 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1849:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1849 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1850:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1850 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1849:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1849 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1847:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1847 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1849:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1849 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1850:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1850 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1853:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1853 0
 801 05b4 020054E3 		cmp	r4, #2
1841:../uvc.c      **** {
 802              		.loc 1 1841 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1847:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1847 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1848:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1848 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1849:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1849 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1850:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1850 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1853:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1853 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1842:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1842 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1980:../uvc.c      **** }
 826              		.loc 1 1980 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1853:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1853 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1893:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1893 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1897:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1897 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1897:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1897 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1902:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1902 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1900:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1900 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1901:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1901 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1905:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1905 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1902:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1902 0
 856 0630 287084E5 		str	r7, [r4, #40]
1903:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1903 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1905:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1905 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1906:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1906 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1909:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1909 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1910:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1910 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1911:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1911 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1912:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1912 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1915:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1915 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1918:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1918 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1920:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1920 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1780 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1783 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1786:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1786 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1916:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1916 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1858:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1858 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1863:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1863 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1865:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1865 0
 926 06e0 002050E2 		subs	r2, r0, #0
1862:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1862 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1865:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1865 0
 931 06e8 BEFFFF0A 		beq	.L48
1867:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1867 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1868:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1868 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1862:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1862 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1928:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1928 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1930:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1930 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1936:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1936 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1968:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1968 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1967:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1967 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1858:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1858 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1876:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1876 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1878:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1878 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1916:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1916 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1881:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1881 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1882:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1882 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1875:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1875 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1938:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1938 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1942:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1942 0
 1011 0794 0080A0E3 		mov	r8, #0
1941:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1941 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1946:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1946 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1942:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1942 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1943:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1943 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1946:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1946 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1947:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1947 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1950:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1950 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1951:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1951 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1952:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1952 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1953:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1953 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1956:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1956 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1960:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1960 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1962:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1962 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1780 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1958:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1958 0
 1061 0814 0600A011 		movne	r0, r6
1780:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1780 0
 1063 0818 72FFFF1A 		bne	.L48
1783:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1783 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1786:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1786 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1958:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1958 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE10:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB13:
2179:../uvc.c      **** {
 1101              		.loc 1 2179 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
2180:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 2180 0
 1107 0870 010050E3 		cmp	r0, #1
2179:../uvc.c      **** {
 1108              		.loc 1 2179 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
2179:../uvc.c      **** {
 1112              		.loc 1 2179 0
 1113 0878 0120A0E1 		mov	r2, r1
2180:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 2180 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
2077:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 2077 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
2103:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 2103 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
2105:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 2105 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
2088:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 2088 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
2162:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 2162 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
2163:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 2163 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
2165:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 2165 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1767 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1768 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
2132:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 2132 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
2079:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 2079 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
2151:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 2151 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
2186:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 2186 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
2189:../uvc.c      **** }
 1214              		.loc 1 2189 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
2186:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 2186 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE13:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 606:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 606 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 609 0
 1243 0970 40429FE5 		ldr	r4, .L106
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 606:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 606 0
 1254 0974 3CD04DE2 		sub	sp, sp, #60
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 96
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 614 0
 1258 0978 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 609 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 610 0
 1263 0980 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1265              		.loc 1 611 0
 1266 0984 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1267              	.LVL99:
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1268              		.loc 1 614 0
 1269 0988 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1270 098c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1271 0990 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1272 0994 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1273 0998 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1274 099c 14208DE5 		str	r2, [sp, #20]
 1275 09a0 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1276 09a4 0730A0E1 		mov	r3, r7
 1277 09a8 1C108DE5 		str	r1, [sp, #28]
 1278 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1279 09b0 0400A0E3 		mov	r0, #4
 1280 09b4 00129FE5 		ldr	r1, .L106+4
 1281 09b8 0520A0E1 		mov	r2, r5
 1282 09bc 00E08DE5 		str	lr, [sp, #0]
 1283 09c0 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1284 09c4 0C908DE5 		str	r9, [sp, #12]
 1285 09c8 10B08DE5 		str	fp, [sp, #16]
 1286 09cc 18608DE5 		str	r6, [sp, #24]
 1287 09d0 20C08DE5 		str	ip, [sp, #32]
 1288 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1289              		.loc 1 617 0
 1290 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1291 09dc 520053E3 		cmp	r3, #82
 1292 09e0 2C00000A 		beq	.L102
 1293              	.L92:
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1294              		.loc 1 627 0
 1295 09e4 000055E3 		cmp	r5, #0
 1296 09e8 1600000A 		beq	.L103
 652:../uvc.c      **** 	}else if(CmdType == 1){
 1297              		.loc 1 652 0
 1298 09ec 010055E3 		cmp	r5, #1
 1299 09f0 0100000A 		beq	.L104
 1300              	.LVL100:
 1301              	.L91:
 671:../uvc.c      **** }
 1302              		.loc 1 671 0
 1303 09f4 3CD08DE2 		add	sp, sp, #60
 1304 09f8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1305              	.LVL101:
 1306              	.L104:
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 1307              		.loc 1 654 0
 1308 09fc 020057E3 		cmp	r7, #2
 1309 0a00 3700000A 		beq	.L105
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1310              		.loc 1 659 0
 1311 0a04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1312 0a08 A8319FE5 		ldr	r3, .L106
 1313 0a0c FE1001E2 		and	r1, r1, #254
 1314 0a10 820051E3 		cmp	r1, #130
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1315              		.loc 1 662 0
 1316 0a14 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1317              	.LVL102:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1318              		.loc 1 659 0
 1319 0a18 0200001A 		bne	.L101
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1320              		.loc 1 659 0 is_stmt 0 discriminator 1
 1321 0a1c 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1322 0a20 300055E3 		cmp	r5, #48
 1323 0a24 4F00000A 		beq	.L99
 1324              	.L101:
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1325              		.loc 1 662 0 is_stmt 1
 1326 0a28 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1327              	.L100:
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1328              		.loc 1 664 0
 1329 0a2c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1330 0a30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1331 0a34 FE0002E2 		and	r0, r2, #254
 1332 0a38 0520A0E1 		mov	r2, r5
 1333 0a3c 00E08DE5 		str	lr, [sp, #0]
 1334 0a40 FEFFFFEB 		bl	SensorWrite2B
 1335 0a44 EAFFFFEA 		b	.L91
 1336              	.LVL103:
 1337              	.L103:
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1338              		.loc 1 643 0
 1339 0a48 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1340 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1341              		.loc 1 629 0
 1342 0a50 0FE0A0E3 		mov	lr, #15
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1343              		.loc 1 643 0
 1344 0a54 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1345 0a58 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1346              		.loc 1 629 0
 1347 0a5c 57E0C4E5 		strb	lr, [r4, #87]
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1348              		.loc 1 643 0
 1349 0a60 34C08DE2 		add	ip, sp, #52
 1350 0a64 010080E3 		orr	r0, r0, #1
 1351 0a68 011081E3 		orr	r1, r1, #1
 1352 0a6c 00C08DE5 		str	ip, [sp, #0]
 1353 0a70 FEFFFFEB 		bl	SensorRead2B
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1354              		.loc 1 644 0
 1355 0a74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 1356              		.loc 1 645 0
 1357 0a78 020056E3 		cmp	r6, #2
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1358              		.loc 1 644 0
 1359 0a7c 5530C4E5 		strb	r3, [r4, #85]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1360              		.loc 1 646 0
 1361 0a80 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1362 0a84 2C319F05 		ldreq	r3, .L106
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1363              		.loc 1 648 0
 1364 0a88 0020E0E3 		mvn	r2, #0
 1365 0a8c 5720C4E5 		strb	r2, [r4, #87]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1366              		.loc 1 646 0
 1367 0a90 5600C305 		streqb	r0, [r3, #86]
 1368 0a94 D6FFFFEA 		b	.L91
 1369              	.L102:
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1370              		.loc 1 617 0 discriminator 1
 1371 0a98 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1372 0a9c 300050E3 		cmp	r0, #48
 1373 0aa0 CFFFFF1A 		bne	.L92
 1374 0aa4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1375 0aa8 010053E3 		cmp	r3, #1
 1376 0aac CCFFFF1A 		bne	.L92
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1377              		.loc 1 619 0
 1378 0ab0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1379 0ab4 04C19FE5 		ldr	ip, .L106+8
 1380 0ab8 031002E2 		and	r1, r2, #3
 1381 0abc 8C14CCE5 		strb	r1, [ip, #1164]
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1382              		.loc 1 620 0
 1383 0ac0 58E094E5 		ldr	lr, [r4, #88]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1384              		.loc 1 624 0
 1385 0ac4 F8109FE5 		ldr	r1, .L106+12
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1386              		.loc 1 620 0
 1387 0ac8 00005EE3 		cmp	lr, #0
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1388              		.loc 1 622 0
 1389 0acc 80208203 		orreq	r2, r2, #128
 1390 0ad0 5520C405 		streqb	r2, [r4, #85]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1391              		.loc 1 624 0
 1392 0ad4 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1393 0ad8 0400A0E3 		mov	r0, #4
 1394 0adc FEFFFFEB 		bl	CyU3PDebugPrint
 1395 0ae0 BFFFFFEA 		b	.L92
 1396              	.L105:
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1397              		.loc 1 656 0
 1398 0ae4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1399 0ae8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1400 0aec 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1401 0af0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1402 0af4 0020A0E3 		mov	r2, #0
 1403 0af8 FE0000E2 		and	r0, r0, #254
 1404 0afc 00E08DE5 		str	lr, [sp, #0]
 1405 0b00 FEFFFFEB 		bl	SensorWrite2B2
 1406 0b04 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1407 0b08 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1408 0b0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1409 0b10 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1410 0b14 FE0002E2 		and	r0, r2, #254
 1411 0b18 0020A0E3 		mov	r2, #0
 1412 0b1c 00C08DE5 		str	ip, [sp, #0]
 1413 0b20 FEFFFFEB 		bl	SensorWrite2B2
 1414              	.LVL104:
 1415 0b24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1416 0b28 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1417 0b2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1418 0b30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1419 0b34 0020A0E3 		mov	r2, #0
 1420 0b38 FE0000E2 		and	r0, r0, #254
 1421 0b3c 00C08DE5 		str	ip, [sp, #0]
 1422 0b40 FEFFFFEB 		bl	SensorWrite2B2
 1423 0b44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1424 0b48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1425 0b4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1426 0b50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1427 0b54 FE0002E2 		and	r0, r2, #254
 1428 0b58 0020A0E3 		mov	r2, #0
 1429 0b5c 00C08DE5 		str	ip, [sp, #0]
 1430 0b60 FEFFFFEB 		bl	SensorWrite2B2
 1431 0b64 A2FFFFEA 		b	.L91
 1432              	.LVL105:
 1433              	.L99:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1434              		.loc 1 659 0 discriminator 1
 1435 0b68 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1436 0b6c 100053E3 		cmp	r3, #16
 1437 0b70 ADFFFF1A 		bne	.L100
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1438              		.loc 1 660 0
 1439 0b74 4C409FE5 		ldr	r4, .L106+16
 1440 0b78 0010E0E3 		mvn	r1, #0
 1441 0b7c 1C0094E5 		ldr	r0, [r4, #28]
 1442 0b80 2C308DE5 		str	r3, [sp, #44]
 1443 0b84 FEFFFFEB 		bl	_txe_mutex_get
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1444              		.loc 1 661 0
 1445 0b88 2C309DE5 		ldr	r3, [sp, #44]
 1446 0b8c 00C0A0E3 		mov	ip, #0
 1447 0b90 0320A0E1 		mov	r2, r3
 1448 0b94 0400A0E1 		mov	r0, r4
 1449 0b98 1710A0E3 		mov	r1, #23
 1450 0b9c 0530A0E1 		mov	r3, r5
 1451 0ba0 00C08DE5 		str	ip, [sp, #0]
 1452 0ba4 04C08DE5 		str	ip, [sp, #4]
 1453 0ba8 FEFFFFEB 		bl	cmdSet
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1454              		.loc 1 662 0
 1455 0bac 1C0094E5 		ldr	r0, [r4, #28]
 1456 0bb0 FEFFFFEB 		bl	_txe_mutex_put
 1457 0bb4 8EFFFFEA 		b	.L91
 1458              	.L107:
 1459              		.align	2
 1460              	.L106:
 1461 0bb8 00000000 		.word	.LANCHOR0
 1462 0bbc 04020000 		.word	.LC14
 1463 0bc0 00000000 		.word	.LANCHOR1
 1464 0bc4 50020000 		.word	.LC15
 1465 0bc8 00000000 		.word	cmdQu
 1466              		.cfi_endproc
 1467              	.LFE0:
 1469              		.align	2
 1470              		.global	setIrisauto
 1472              	setIrisauto:
 1473              	.LFB1:
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1474              		.loc 1 677 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 0
 1477              		@ frame_needed = 0, uses_anonymous_args = 0
 1478              	.LVL106:
 1479 0bcc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1480              	.LCFI11:
 1481              		.cfi_def_cfa_offset 16
 1482 0bd0 0160A0E1 		mov	r6, r1
 1483              		.cfi_offset 14, -4
 1484              		.cfi_offset 6, -8
 1485              		.cfi_offset 5, -12
 1486              		.cfi_offset 4, -16
 1487 0bd4 08D04DE2 		sub	sp, sp, #8
 1488              	.LCFI12:
 1489              		.cfi_def_cfa_offset 24
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1490              		.loc 1 677 0
 1491 0bd8 0040A0E1 		mov	r4, r0
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1492              		.loc 1 680 0
 1493 0bdc 0050A0E3 		mov	r5, #0
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1494              		.loc 1 679 0
 1495 0be0 0010E0E3 		mvn	r1, #0
 1496              	.LVL107:
 1497 0be4 1C0090E5 		ldr	r0, [r0, #28]
 1498              	.LVL108:
 1499 0be8 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1500              		.loc 1 680 0
 1501 0bec 060065E0 		rsb	r0, r5, r6
 1502 0bf0 00C070E2 		rsbs	ip, r0, #0
 1503 0bf4 00C0ACE0 		adc	ip, ip, r0
 1504 0bf8 2010A0E3 		mov	r1, #32
 1505 0bfc 2720A0E3 		mov	r2, #39
 1506 0c00 3030A0E3 		mov	r3, #48
 1507 0c04 0400A0E1 		mov	r0, r4
 1508 0c08 00C08DE5 		str	ip, [sp, #0]
 1509 0c0c 04508DE5 		str	r5, [sp, #4]
 1510 0c10 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1511              		.loc 1 681 0
 1512 0c14 050056E1 		cmp	r6, r5
 1513 0c18 0260A003 		moveq	r6, #2
 1514 0c1c 0160A013 		movne	r6, #1
 1515 0c20 0400A0E1 		mov	r0, r4
 1516 0c24 2110A0E3 		mov	r1, #33
 1517 0c28 2520A0E3 		mov	r2, #37
 1518 0c2c 3030A0E3 		mov	r3, #48
 1519 0c30 00608DE5 		str	r6, [sp, #0]
 1520 0c34 04508DE5 		str	r5, [sp, #4]
 1521 0c38 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1522              		.loc 1 682 0
 1523 0c3c 1C0094E5 		ldr	r0, [r4, #28]
 683:../uvc.c      **** }
 1524              		.loc 1 683 0
 1525 0c40 08D08DE2 		add	sp, sp, #8
 1526 0c44 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1527              		.loc 1 682 0
 1528 0c48 FEFFFFEA 		b	_txe_mutex_put
 1529              		.cfi_endproc
 1530              	.LFE1:
 1532              		.align	2
 1533              		.global	getShutCtrl
 1535              	getShutCtrl:
 1536              	.LFB2:
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1537              		.loc 1 687 0
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 0
 1540              		@ frame_needed = 0, uses_anonymous_args = 0
 1541              	.LVL109:
 692:../uvc.c      **** 	switch (Data){
 1542              		.loc 1 692 0
 1543 0c4c 013040E2 		sub	r3, r0, #1
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1544              		.loc 1 687 0
 1545 0c50 10402DE9 		stmfd	sp!, {r4, lr}
 1546              	.LCFI13:
 1547              		.cfi_def_cfa_offset 8
 1548 0c54 08D04DE2 		sub	sp, sp, #8
 1549              	.LCFI14:
 1550              		.cfi_def_cfa_offset 16
 692:../uvc.c      **** 	switch (Data){
 1551              		.loc 1 692 0
 1552 0c58 090053E3 		cmp	r3, #9
 1553 0c5c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1554 0c60 380000EA 		b	.L112
 1555              		.cfi_offset 14, -4
 1556              		.cfi_offset 4, -8
 1557              	.L115:
 1558 0c64 FC0C0000 		.word	.L113
 1559 0c68 FC0C0000 		.word	.L113
 1560 0c6c FC0C0000 		.word	.L113
 1561 0c70 FC0C0000 		.word	.L113
 1562 0c74 FC0C0000 		.word	.L113
 1563 0c78 8C0C0000 		.word	.L114
 1564 0c7c 8C0C0000 		.word	.L114
 1565 0c80 8C0C0000 		.word	.L114
 1566 0c84 8C0C0000 		.word	.L114
 1567 0c88 8C0C0000 		.word	.L114
 1568              	.L114:
 1569              	.LVL110:
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1570              		.loc 1 716 0
 1571 0c8c ECC09FE5 		ldr	ip, .L124
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1572              		.loc 1 714 0
 1573 0c90 8330A0E1 		mov	r3, r3, asl #1
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1574              		.loc 1 716 0
 1575 0c94 B3309CE1 		ldrh	r3, [ip, r3]
 1576 0c98 E4E09FE5 		ldr	lr, .L124+4
 1577 0c9c 032263E0 		rsb	r2, r3, r3, asl #4
 1578 0ca0 8240A0E1 		mov	r4, r2, asl #1
 1579 0ca4 94CECEE0 		smull	ip, lr, r4, lr
 1580 0ca8 C4CFA0E1 		mov	ip, r4, asr #31
 1581 0cac 4E246CE0 		rsb	r2, ip, lr, asr #8
 717:../uvc.c      **** 		if(NumLn > 1944)
 1582              		.loc 1 717 0
 1583 0cb0 D0E09FE5 		ldr	lr, .L124+8
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1584              		.loc 1 716 0
 1585 0cb4 0228A0E1 		mov	r2, r2, asl #16
 1586 0cb8 22C8A0E1 		mov	ip, r2, lsr #16
 1587              	.LVL111:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1588              		.loc 1 717 0
 1589 0cbc 0E005CE1 		cmp	ip, lr
 1590 0cc0 2600008A 		bhi	.L121
 719:../uvc.c      **** 		else if(NumLn < 8)
 1591              		.loc 1 719 0
 1592 0cc4 07005CE3 		cmp	ip, #7
 1593 0cc8 2700008A 		bhi	.L123
 1594              	.LVL112:
 1595              	.L122:
 1596 0ccc 01C0A0E3 		mov	ip, #1
 1597 0cd0 08E0A0E3 		mov	lr, #8
 1598 0cd4 0C40A0E1 		mov	r4, ip
 1599              	.L118:
 1600              	.LVL113:
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1601              		.loc 1 722 0
 1602 0cd8 0120A0E3 		mov	r2, #1
 1603 0cdc 0020C1E5 		strb	r2, [r1, #0]
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1604              		.loc 1 723 0
 1605 0ce0 0020A0E1 		mov	r2, r0
 1606 0ce4 A0109FE5 		ldr	r1, .L124+12
 1607              	.LVL114:
 1608 0ce8 0400A0E3 		mov	r0, #4
 1609              	.LVL115:
 1610 0cec 00E08DE5 		str	lr, [sp, #0]
 1611 0cf0 04C08DE5 		str	ip, [sp, #4]
 1612 0cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 724:../uvc.c      **** 		break;
 1613              		.loc 1 724 0
 1614 0cf8 150000EA 		b	.L117
 1615              	.LVL116:
 1616              	.L113:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1617              		.loc 1 698 0
 1618 0cfc 7CE09FE5 		ldr	lr, .L124
 1619 0d00 8330A0E1 		mov	r3, r3, asl #1
 1620 0d04 B3309EE1 		ldrh	r3, [lr, r3]
 1621              	.LVL117:
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1622              		.loc 1 700 0
 1623 0d08 80C09FE5 		ldr	ip, .L124+16
 701:../uvc.c      **** 		if(NumLn > 1944)
 1624              		.loc 1 701 0
 1625 0d0c 74E09FE5 		ldr	lr, .L124+8
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1626              		.loc 1 700 0
 1627 0d10 932C8CE0 		umull	r2, ip, r3, ip
 1628 0d14 AC24A0E1 		mov	r2, ip, lsr #9
 1629 0d18 024262E0 		rsb	r4, r2, r2, asl #4
 1630 0d1c 8448A0E1 		mov	r4, r4, asl #17
 1631 0d20 2428A0E1 		mov	r2, r4, lsr #16
 1632              	.LVL118:
 701:../uvc.c      **** 		if(NumLn > 1944)
 1633              		.loc 1 701 0
 1634 0d24 0E0052E1 		cmp	r2, lr
 1635 0d28 0C00008A 		bhi	.L121
 703:../uvc.c      **** 		else if(NumLn < 8)
 1636              		.loc 1 703 0
 1637 0d2c 070052E3 		cmp	r2, #7
 1638 0d30 E5FFFF9A 		bls	.L122
 1639 0d34 A449A0E1 		mov	r4, r4, lsr #19
 1640 0d38 FF4004E2 		and	r4, r4, #255
 1641 0d3c 02E0A0E1 		mov	lr, r2
 1642 0d40 04C0A0E1 		mov	ip, r4
 1643 0d44 E3FFFFEA 		b	.L118
 1644              	.LVL119:
 1645              	.L112:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1646              		.loc 1 727 0
 1647 0d48 0000A0E3 		mov	r0, #0
 1648              	.LVL120:
 728:../uvc.c      **** 		LnVal = 1;
 1649              		.loc 1 728 0
 1650 0d4c 0140A0E3 		mov	r4, #1
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1651              		.loc 1 727 0
 1652 0d50 0000C1E5 		strb	r0, [r1, #0]
 1653              	.LVL121:
 1654              	.L117:
 732:../uvc.c      **** }
 1655              		.loc 1 732 0
 1656 0d54 0400A0E1 		mov	r0, r4
 1657 0d58 08D08DE2 		add	sp, sp, #8
 1658 0d5c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1659              	.LVL122:
 1660              	.L121:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1661              		.loc 1 717 0
 1662 0d60 F3C0A0E3 		mov	ip, #243
 1663 0d64 0C40A0E1 		mov	r4, ip
 1664 0d68 DAFFFFEA 		b	.L118
 1665              	.LVL123:
 1666              	.L123:
 719:../uvc.c      **** 		else if(NumLn < 8)
 1667              		.loc 1 719 0
 1668 0d6c A2E9A0E1 		mov	lr, r2, lsr #19
 1669 0d70 FF400EE2 		and	r4, lr, #255
 1670 0d74 0CE0A0E1 		mov	lr, ip
 1671 0d78 04C0A0E1 		mov	ip, r4
 1672              	.LVL124:
 1673 0d7c D5FFFFEA 		b	.L118
 1674              	.L125:
 1675              		.align	2
 1676              	.L124:
 1677 0d80 00000000 		.word	.LANCHOR2
 1678 0d84 817F807F 		.word	2139127681
 1679 0d88 98070000 		.word	1944
 1680 0d8c 78020000 		.word	.LC16
 1681 0d90 01FF00FF 		.word	-16711935
 1682              		.cfi_endproc
 1683              	.LFE2:
 1685              		.align	2
 1686              		.global	ControlHandle
 1688              	ControlHandle:
 1689              	.LFB3:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1690              		.loc 1 734 0
 1691              		.cfi_startproc
 1692              		@ args = 0, pretend = 0, frame = 24
 1693              		@ frame_needed = 0, uses_anonymous_args = 0
 1694              	.LVL125:
 1695 0d94 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1696              	.LCFI15:
 1697              		.cfi_def_cfa_offset 36
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1698              		.loc 1 741 0
 1699 0d98 230050E3 		cmp	r0, #35
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1700              		.loc 1 740 0
 1701 0d9c 207040E2 		sub	r7, r0, #32
 1702              		.cfi_offset 14, -4
 1703              		.cfi_offset 11, -8
 1704              		.cfi_offset 10, -12
 1705              		.cfi_offset 9, -16
 1706              		.cfi_offset 8, -20
 1707              		.cfi_offset 7, -24
 1708              		.cfi_offset 6, -28
 1709              		.cfi_offset 5, -32
 1710              		.cfi_offset 4, -36
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1711              		.loc 1 734 0
 1712 0da0 2CD04DE2 		sub	sp, sp, #44
 1713              	.LCFI16:
 1714              		.cfi_def_cfa_offset 80
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1715              		.loc 1 734 0
 1716 0da4 0040A0E1 		mov	r4, r0
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1717              		.loc 1 740 0
 1718 0da8 FF7007E2 		and	r7, r7, #255
 1719              	.LVL126:
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1720              		.loc 1 741 0
 1721 0dac 2400009A 		bls	.L127
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1722              		.loc 1 742 0
 1723 0db0 A46E9FE5 		ldr	r6, .L262+60
 1724 0db4 872087E0 		add	r2, r7, r7, asl #1
 1725 0db8 8221A0E1 		mov	r2, r2, asl #3
 1726 0dbc 023086E0 		add	r3, r6, r2
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1727              		.loc 1 743 0
 1728 0dc0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1729              		.loc 1 744 0
 1730 0dc4 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1731              		.loc 1 745 0
 1732 0dc8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 756:../uvc.c      ****     reqData = bRequest;
 1733              		.loc 1 756 0
 1734 0dcc 4C3E9FE5 		ldr	r3, .L262
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1735              		.loc 1 742 0
 1736 0dd0 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1737              	.LVL127:
 756:../uvc.c      ****     reqData = bRequest;
 1738              		.loc 1 756 0
 1739 0dd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1740              	.LVL128:
 764:../uvc.c      ****     switch (bRequest)
 1741              		.loc 1 764 0
 1742 0dd8 830055E3 		cmp	r5, #131
 1743 0ddc 2300000A 		beq	.L133
 1744              	.LVL129:
 1745              	.L254:
 1746 0de0 2C00009A 		bls	.L252
 1747 0de4 850055E3 		cmp	r5, #133
 1748 0de8 8B00000A 		beq	.L135
 1749 0dec 7900003A 		bcc	.L134
 1750 0df0 860055E3 		cmp	r5, #134
 1751 0df4 C800000A 		beq	.L136
 1752 0df8 870055E3 		cmp	r5, #135
 1753 0dfc BC00000A 		beq	.L253
 1754              	.L129:
1415:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1755              		.loc 1 1415 0
 1756 0e00 0000A0E3 		mov	r0, #0
 1757 0e04 0110A0E3 		mov	r1, #1
 1758 0e08 0020A0E1 		mov	r2, r0
 1759 0e0c FEFFFFEB 		bl	CyU3PUsbStall
1416:../uvc.c      **** 			  break;
 1760              		.loc 1 1416 0
 1761 0e10 FFC0A0E3 		mov	ip, #255
 1762 0e14 0C40A0E1 		mov	r4, ip
 1763 0e18 0C70A0E1 		mov	r7, ip
 1764              	.LVL130:
 1765 0e1c 0C80A0E1 		mov	r8, ip
 1766              	.LVL131:
 1767              	.L139:
1418:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1768              		.loc 1 1418 0
 1769 0e20 FC1D9FE5 		ldr	r1, .L262+4
 1770 0e24 0520A0E1 		mov	r2, r5
 1771 0e28 0830A0E1 		mov	r3, r8
 1772 0e2c 0400A0E3 		mov	r0, #4
 1773 0e30 00708DE5 		str	r7, [sp, #0]
 1774 0e34 10108DE9 		stmib	sp, {r4, ip}	@ phole stm
 1775 0e38 FEFFFFEB 		bl	CyU3PDebugPrint
1419:../uvc.c      **** }
 1776              		.loc 1 1419 0
 1777 0e3c 2CD08DE2 		add	sp, sp, #44
 1778 0e40 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1779              	.LVL132:
 1780              	.L127:
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1781              		.loc 1 747 0
 1782 0e44 106E9FE5 		ldr	r6, .L262+60
 756:../uvc.c      ****     reqData = bRequest;
 1783              		.loc 1 756 0
 1784 0e48 D03D9FE5 		ldr	r3, .L262
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1785              		.loc 1 747 0
 1786 0e4c 805080E0 		add	r5, r0, r0, asl #1
 1787 0e50 850186E0 		add	r0, r6, r5, asl #3
 1788              	.LVL133:
 756:../uvc.c      ****     reqData = bRequest;
 1789              		.loc 1 756 0
 1790 0e54 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1791              		.loc 1 747 0
 1792 0e58 80A1D0E5 		ldrb	sl, [r0, #384]	@ zero_extendqisi2
 1793              	.LVL134:
 764:../uvc.c      ****     switch (bRequest)
 1794              		.loc 1 764 0
 1795 0e5c 830055E3 		cmp	r5, #131
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1796              		.loc 1 748 0
 1797 0e60 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1798              	.LVL135:
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1799              		.loc 1 749 0
 1800 0e64 8F91D0E5 		ldrb	r9, [r0, #399]	@ zero_extendqisi2
 1801              	.LVL136:
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1802              		.loc 1 750 0
 1803 0e68 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1804              	.LVL137:
 764:../uvc.c      ****     switch (bRequest)
 1805              		.loc 1 764 0
 1806 0e6c DBFFFF1A 		bne	.L254
 1807              	.LVL138:
 1808              	.L133:
 922:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1809              		.loc 1 922 0
 1810 0e70 230054E3 		cmp	r4, #35
 1811 0e74 C600009A 		bls	.L166
 923:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1812              		.loc 1 923 0
 1813 0e78 877087E0 		add	r7, r7, r7, asl #1
 1814              	.LVL139:
 1815 0e7c 876186E0 		add	r6, r6, r7, asl #3
 1816 0e80 DCAD9FE5 		ldr	sl, .L262+68
 1817 0e84 05E0D6E5 		ldrb	lr, [r6, #5]	@ zero_extendqisi2
 924:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1818              		.loc 1 924 0
 1819 0e88 0640D6E5 		ldrb	r4, [r6, #6]	@ zero_extendqisi2
 923:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1820              		.loc 1 923 0
 1821 0e8c 5CE0CAE5 		strb	lr, [sl, #92]
 924:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1822              		.loc 1 924 0
 1823 0e90 5D40CAE5 		strb	r4, [sl, #93]
 1824 0e94 0B0000EA 		b	.L174
 1825              	.LVL140:
 1826              	.L252:
 764:../uvc.c      ****     switch (bRequest)
 1827              		.loc 1 764 0
 1828 0e98 810055E3 		cmp	r5, #129
 1829 0e9c 6A00000A 		beq	.L131
 1830 0ea0 1000009A 		bls	.L255
 903:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1831              		.loc 1 903 0
 1832 0ea4 230054E3 		cmp	r4, #35
 1833 0ea8 AD00009A 		bls	.L163
 904:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1834              		.loc 1 904 0
 1835 0eac 87A087E0 		add	sl, r7, r7, asl #1
 1836 0eb0 8A6186E0 		add	r6, r6, sl, asl #3
 1837 0eb4 0310D6E5 		ldrb	r1, [r6, #3]	@ zero_extendqisi2
 1838 0eb8 A4AD9FE5 		ldr	sl, .L262+68
 905:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1839              		.loc 1 905 0
 1840 0ebc 0400D6E5 		ldrb	r0, [r6, #4]	@ zero_extendqisi2
 904:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1841              		.loc 1 904 0
 1842 0ec0 5C10CAE5 		strb	r1, [sl, #92]
 905:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1843              		.loc 1 905 0
 1844 0ec4 5D00CAE5 		strb	r0, [sl, #93]
 1845              	.LVL141:
 1846              	.L174:
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1847              		.loc 1 980 0
 1848 0ec8 0800A0E1 		mov	r0, r8
 1849 0ecc 541D9FE5 		ldr	r1, .L262+8
 1850 0ed0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1851              	.LVL142:
 982:../uvc.c      **** 			  break;
 1852              		.loc 1 982 0
 1853 0ed4 FFC0A0E3 		mov	ip, #255
 980:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1854              		.loc 1 980 0
 1855 0ed8 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 982:../uvc.c      **** 			  break;
 1856              		.loc 1 982 0
 1857 0edc 0C70A0E1 		mov	r7, ip
 1858 0ee0 0C80A0E1 		mov	r8, ip
 1859 0ee4 CDFFFFEA 		b	.L139
 1860              	.LVL143:
 1861              	.L255:
 764:../uvc.c      ****     switch (bRequest)
 1862              		.loc 1 764 0
 1863 0ee8 010055E3 		cmp	r5, #1
 1864 0eec C3FFFF1A 		bne	.L129
 984:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1865              		.loc 1 984 0
 1866 0ef0 6C3D9FE5 		ldr	r3, .L262+68
 1867 0ef4 26208DE2 		add	r2, sp, #38
 1868 0ef8 2000A0E3 		mov	r0, #32
 1869 0efc 5C1083E2 		add	r1, r3, #92
 1870 0f00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1871              	.LVL144:
 986:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1872              		.loc 1 986 0
 1873 0f04 002050E2 		subs	r2, r0, #0
 1874 0f08 BA03001A 		bne	.L176
 988:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1875              		.loc 1 988 0
 1876 0f0c 503D9FE5 		ldr	r3, .L262+68
 989:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1877              		.loc 1 989 0
 1878 0f10 4CCD9FE5 		ldr	ip, .L262+68
 991:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1879              		.loc 1 991 0
 1880 0f14 48ED9FE5 		ldr	lr, .L262+68
 988:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1881              		.loc 1 988 0
 1882 0f18 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
 989:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1883              		.loc 1 989 0
 1884 0f1c 5DC0DCE5 		ldrb	ip, [ip, #93]	@ zero_extendqisi2
 991:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1885              		.loc 1 991 0
 1886 0f20 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1887              	.LVL145:
 988:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1888              		.loc 1 988 0
 1889 0f24 14308DE5 		str	r3, [sp, #20]
 1890              	.LVL146:
 989:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1891              		.loc 1 989 0
 1892 0f28 1CC08DE5 		str	ip, [sp, #28]
 1893              	.LVL147:
 991:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1894              		.loc 1 991 0
 1895 0f2c 18008DE5 		str	r0, [sp, #24]
 1896              	.LVL148:
 995:../uvc.c      **** 				  switch(CtrlID)
 1897              		.loc 1 995 0
 1898 0f30 260054E3 		cmp	r4, #38
 1899 0f34 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1900 0f38 1F0300EA 		b	.L177
 1901              	.L194:
 1902 0f3c 501B0000 		.word	.L178
 1903 0f40 E81A0000 		.word	.L179
 1904 0f44 BC1B0000 		.word	.L177
 1905 0f48 BC1B0000 		.word	.L177
 1906 0f4c A81D0000 		.word	.L180
 1907 0f50 681C0000 		.word	.L181
 1908 0f54 3C170000 		.word	.L182
 1909 0f58 A8160000 		.word	.L183
 1910 0f5c BC1B0000 		.word	.L177
 1911 0f60 BC1B0000 		.word	.L177
 1912 0f64 BC1B0000 		.word	.L177
 1913 0f68 EC190000 		.word	.L184
 1914 0f6c BC1B0000 		.word	.L177
 1915 0f70 BC1B0000 		.word	.L177
 1916 0f74 BC1B0000 		.word	.L177
 1917 0f78 BC1B0000 		.word	.L177
 1918 0f7c 1C190000 		.word	.L185
 1919 0f80 BC1B0000 		.word	.L177
 1920 0f84 BC1B0000 		.word	.L177
 1921 0f88 BC1B0000 		.word	.L177
 1922 0f8c BC1B0000 		.word	.L177
 1923 0f90 BC1B0000 		.word	.L177
 1924 0f94 BC1B0000 		.word	.L177
 1925 0f98 BC1B0000 		.word	.L177
 1926 0f9c BC1B0000 		.word	.L177
 1927 0fa0 4C180000 		.word	.L186
 1928 0fa4 BC1B0000 		.word	.L177
 1929 0fa8 B8170000 		.word	.L187
 1930 0fac 701A0000 		.word	.L188
 1931 0fb0 BC1B0000 		.word	.L177
 1932 0fb4 4C160000 		.word	.L189
 1933 0fb8 C8150000 		.word	.L190
 1934 0fbc BC1B0000 		.word	.L177
 1935 0fc0 BC1B0000 		.word	.L177
 1936 0fc4 BC1B0000 		.word	.L177
 1937 0fc8 BC1B0000 		.word	.L177
 1938 0fcc 34150000 		.word	.L191
 1939 0fd0 C4140000 		.word	.L192
 1940 0fd4 5C140000 		.word	.L193
 1941              	.LVL149:
 1942              	.L134:
 940:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1943              		.loc 1 940 0
 1944 0fd8 230054E3 		cmp	r4, #35
 941:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1945              		.loc 1 941 0
 1946 0fdc 87708780 		addhi	r7, r7, r7, asl #1
 1947              	.LVL150:
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1948              		.loc 1 947 0
 1949 0fe0 84408490 		addls	r4, r4, r4, asl #1
 941:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1950              		.loc 1 941 0
 1951 0fe4 87618680 		addhi	r6, r6, r7, asl #3
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1952              		.loc 1 947 0
 1953 0fe8 84618690 		addls	r6, r6, r4, asl #3
 941:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1954              		.loc 1 941 0
 1955 0fec 70AC9F85 		ldrhi	sl, .L262+68
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1956              		.loc 1 947 0
 1957 0ff0 6CAC9F95 		ldrls	sl, .L262+68
 941:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1958              		.loc 1 941 0
 1959 0ff4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 942:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1960              		.loc 1 942 0
 1961 0ff8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1962              		.loc 1 947 0
 1963 0ffc 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 948:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1964              		.loc 1 948 0
 1965 1000 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 949:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1966              		.loc 1 949 0
 1967 1004 00C0A0E3 		mov	ip, #0
 947:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1968              		.loc 1 947 0
 1969 1008 5C10CAE5 		strb	r1, [sl, #92]
 948:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1970              		.loc 1 948 0
 1971 100c 5D20CAE5 		strb	r2, [sl, #93]
 949:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1972              		.loc 1 949 0
 1973 1010 5EC0CAE5 		strb	ip, [sl, #94]
 950:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1974              		.loc 1 950 0
 1975 1014 5FC0CAE5 		strb	ip, [sl, #95]
 1976 1018 AAFFFFEA 		b	.L174
 1977              	.LVL151:
 1978              	.L135:
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1979              		.loc 1 768 0
 1980 101c 404C9FE5 		ldr	r4, .L262+68
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1981              		.loc 1 770 0
 1982 1020 0200A0E3 		mov	r0, #2
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1983              		.loc 1 768 0
 1984 1024 5C80C4E5 		strb	r8, [r4, #92]
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1985              		.loc 1 769 0
 1986 1028 0080A0E3 		mov	r8, #0
 1987 102c 5D80C4E5 		strb	r8, [r4, #93]
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1988              		.loc 1 770 0
 1989 1030 5C1084E2 		add	r1, r4, #92
 1990 1034 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1991              	.LVL152:
 772:../uvc.c      **** 			  break;
 1992              		.loc 1 772 0
 1993 1038 FFC0A0E3 		mov	ip, #255
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1994              		.loc 1 770 0
 1995 103c 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 772:../uvc.c      **** 			  break;
 1996              		.loc 1 772 0
 1997 1040 0C70A0E1 		mov	r7, ip
 1998              	.LVL153:
 1999 1044 0C80A0E1 		mov	r8, ip
 2000 1048 74FFFFEA 		b	.L139
 2001              	.LVL154:
 2002              	.L131:
 775:../uvc.c      **** 			 switch(CtrlID)
 2003              		.loc 1 775 0
 2004 104c 260054E3 		cmp	r4, #38
 2005 1050 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2006 1054 F70000EA 		b	.L140
 2007              	.L151:
 2008 1058 0C140000 		.word	.L141
 2009 105c E0130000 		.word	.L142
 2010 1060 38140000 		.word	.L140
 2011 1064 38140000 		.word	.L140
 2012 1068 38140000 		.word	.L140
 2013 106c C0130000 		.word	.L143
 2014 1070 38140000 		.word	.L140
 2015 1074 0C140000 		.word	.L141
 2016 1078 38140000 		.word	.L140
 2017 107c 38140000 		.word	.L140
 2018 1080 38140000 		.word	.L140
 2019 1084 9C130000 		.word	.L144
 2020 1088 38140000 		.word	.L140
 2021 108c 38140000 		.word	.L140
 2022 1090 38140000 		.word	.L140
 2023 1094 38140000 		.word	.L140
 2024 1098 7C130000 		.word	.L145
 2025 109c 38140000 		.word	.L140
 2026 10a0 38140000 		.word	.L140
 2027 10a4 38140000 		.word	.L140
 2028 10a8 38140000 		.word	.L140
 2029 10ac 38140000 		.word	.L140
 2030 10b0 38140000 		.word	.L140
 2031 10b4 38140000 		.word	.L140
 2032 10b8 38140000 		.word	.L140
 2033 10bc 38130000 		.word	.L146
 2034 10c0 38140000 		.word	.L140
 2035 10c4 18130000 		.word	.L147
 2036 10c8 F0120000 		.word	.L148
 2037 10cc 38140000 		.word	.L140
 2038 10d0 38140000 		.word	.L140
 2039 10d4 54120000 		.word	.L149
 2040 10d8 38140000 		.word	.L140
 2041 10dc 38140000 		.word	.L140
 2042 10e0 38140000 		.word	.L140
 2043 10e4 38140000 		.word	.L140
 2044 10e8 10120000 		.word	.L150
 2045 10ec 10120000 		.word	.L150
 2046 10f0 10120000 		.word	.L150
 2047              	.L253:
 967:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2048              		.loc 1 967 0
 2049 10f4 230054E3 		cmp	r4, #35
 2050 10f8 3100009A 		bls	.L173
 968:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2051              		.loc 1 968 0
 2052 10fc 870087E0 		add	r0, r7, r7, asl #1
 2053 1100 806186E0 		add	r6, r6, r0, asl #3
 2054 1104 58AB9FE5 		ldr	sl, .L262+68
 2055 1108 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 969:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2056              		.loc 1 969 0
 2057 110c 0C30D6E5 		ldrb	r3, [r6, #12]	@ zero_extendqisi2
 968:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2058              		.loc 1 968 0
 2059 1110 5C20CAE5 		strb	r2, [sl, #92]
 969:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2060              		.loc 1 969 0
 2061 1114 5D30CAE5 		strb	r3, [sl, #93]
 2062 1118 6AFFFFEA 		b	.L174
 2063              	.L136:
 956:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2064              		.loc 1 956 0
 2065 111c 230054E3 		cmp	r4, #35
 957:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2066              		.loc 1 957 0
 2067 1120 87708780 		addhi	r7, r7, r7, asl #1
 2068              	.LVL155:
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2069              		.loc 1 960 0
 2070 1124 84408490 		addls	r4, r4, r4, asl #1
 957:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2071              		.loc 1 957 0
 2072 1128 87618680 		addhi	r6, r6, r7, asl #3
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2073              		.loc 1 960 0
 2074 112c 84618690 		addls	r6, r6, r4, asl #3
 957:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2075              		.loc 1 957 0
 2076 1130 2C8B9F85 		ldrhi	r8, .L262+68
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2077              		.loc 1 960 0
 2078 1134 288B9F95 		ldrls	r8, .L262+68
 957:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2079              		.loc 1 957 0
 2080 1138 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2081              		.loc 1 960 0
 2082 113c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2083              		.loc 1 962 0
 2084 1140 0100A0E3 		mov	r0, #1
 960:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2085              		.loc 1 960 0
 2086 1144 5C30C8E5 		strb	r3, [r8, #92]
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2087              		.loc 1 962 0
 2088 1148 D81A9FE5 		ldr	r1, .L262+8
 2089 114c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2090              	.LVL156:
 965:../uvc.c      **** 			  break;
 2091              		.loc 1 965 0
 2092 1150 FFC0A0E3 		mov	ip, #255
 962:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2093              		.loc 1 962 0
 2094 1154 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 965:../uvc.c      **** 			  break;
 2095              		.loc 1 965 0
 2096 1158 0C70A0E1 		mov	r7, ip
 2097 115c 0C80A0E1 		mov	r8, ip
 2098 1160 2EFFFFEA 		b	.L139
 2099              	.LVL157:
 2100              	.L163:
 908:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2101              		.loc 1 908 0
 2102 1164 0B0054E3 		cmp	r4, #11
 915:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2103              		.loc 1 915 0
 2104 1168 84408410 		addne	r4, r4, r4, asl #1
 2105 116c 84618610 		addne	r6, r6, r4, asl #3
 2106 1170 ECAA9F15 		ldrne	sl, .L262+68
 909:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2107              		.loc 1 909 0
 2108 1174 E8AA9F05 		ldreq	sl, .L262+68
 2109 1178 AC3A9F05 		ldreq	r3, .L262+12
 915:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2110              		.loc 1 915 0
 2111 117c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 916:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2112              		.loc 1 916 0
 2113 1180 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 909:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2114              		.loc 1 909 0
 2115 1184 5C308A05 		streq	r3, [sl, #92]
 915:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2116              		.loc 1 915 0
 2117 1188 5C20CA15 		strneb	r2, [sl, #92]
 916:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2118              		.loc 1 916 0
 2119 118c 5D30CA15 		strneb	r3, [sl, #93]
 2120 1190 4CFFFFEA 		b	.L174
 2121              	.L166:
 926:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2122              		.loc 1 926 0
 2123 1194 0B0054E3 		cmp	r4, #11
 933:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2124              		.loc 1 933 0
 2125 1198 84408410 		addne	r4, r4, r4, asl #1
 2126 119c 84618610 		addne	r6, r6, r4, asl #3
 2127 11a0 BCAA9F15 		ldrne	sl, .L262+68
 927:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2128              		.loc 1 927 0
 2129 11a4 B8AA9F05 		ldreq	sl, .L262+68
 2130 11a8 803A9F05 		ldreq	r3, .L262+16
 933:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2131              		.loc 1 933 0
 2132 11ac 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 934:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2133              		.loc 1 934 0
 2134 11b0 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 927:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2135              		.loc 1 927 0
 2136 11b4 5C308A05 		streq	r3, [sl, #92]
 933:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2137              		.loc 1 933 0
 2138 11b8 5C20CA15 		strneb	r2, [sl, #92]
 934:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2139              		.loc 1 934 0
 2140 11bc 5D30CA15 		strneb	r3, [sl, #93]
 2141 11c0 40FFFFEA 		b	.L174
 2142              	.L173:
 971:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2143              		.loc 1 971 0
 2144 11c4 0B0054E3 		cmp	r4, #11
 2145 11c8 0700000A 		beq	.L256
 977:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2146              		.loc 1 977 0
 2147 11cc 84A084E0 		add	sl, r4, r4, asl #1
 2148 11d0 8A6186E0 		add	r6, r6, sl, asl #3
 2149 11d4 8BC1D6E5 		ldrb	ip, [r6, #395]	@ zero_extendqisi2
 2150 11d8 84AA9FE5 		ldr	sl, .L262+68
 978:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2151              		.loc 1 978 0
 2152 11dc 8C71D6E5 		ldrb	r7, [r6, #396]	@ zero_extendqisi2
 2153              	.LVL158:
 977:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2154              		.loc 1 977 0
 2155 11e0 5CC0CAE5 		strb	ip, [sl, #92]
 978:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2156              		.loc 1 978 0
 2157 11e4 5D70CAE5 		strb	r7, [sl, #93]
 2158 11e8 36FFFFEA 		b	.L174
 2159              	.LVL159:
 2160              	.L256:
 972:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2161              		.loc 1 972 0
 2162 11ec 70AA9FE5 		ldr	sl, .L262+68
 2163 11f0 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
 974:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2164              		.loc 1 974 0
 2165 11f4 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 973:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2166              		.loc 1 973 0
 2167 11f8 0040A0E3 		mov	r4, #0
 972:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2168              		.loc 1 972 0
 2169 11fc 5C10CAE5 		strb	r1, [sl, #92]
 973:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2170              		.loc 1 973 0
 2171 1200 5D40CAE5 		strb	r4, [sl, #93]
 974:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2172              		.loc 1 974 0
 2173 1204 5EE0CAE5 		strb	lr, [sl, #94]
 975:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2174              		.loc 1 975 0
 2175 1208 5F40CAE5 		strb	r4, [sl, #95]
 2176 120c 2DFFFFEA 		b	.L174
 2177              	.L150:
 783:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2178              		.loc 1 783 0
 2179 1210 1C3A9FE5 		ldr	r3, .L262+20
 2180 1214 481A9FE5 		ldr	r1, .L262+68
 2181 1218 047183E0 		add	r7, r3, r4, asl #2
 2182              	.LVL160:
 2183 121c 20C017E5 		ldr	ip, [r7, #-32]
 2184 1220 0DE0DCE5 		ldrb	lr, [ip, #13]	@ zero_extendqisi2
 2185 1224 FF400EE2 		and	r4, lr, #255
 2186 1228 5C40C1E5 		strb	r4, [r1, #92]
 784:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2187              		.loc 1 784 0
 2188 122c 0E60DCE5 		ldrb	r6, [ip, #14]	@ zero_extendqisi2
 2189 1230 FF6006E2 		and	r6, r6, #255
 2190 1234 5D60C1E5 		strb	r6, [r1, #93]
 2191              	.LVL161:
 2192              	.L154:
 896:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2193              		.loc 1 896 0
 2194 1238 0800A0E1 		mov	r0, r8
 2195 123c E4199FE5 		ldr	r1, .L262+8
 2196 1240 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 901:../uvc.c      **** 			  break;
 2197              		.loc 1 901 0
 2198 1244 FF70A0E3 		mov	r7, #255
 896:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2199              		.loc 1 896 0
 2200 1248 06C0A0E1 		mov	ip, r6
 901:../uvc.c      **** 			  break;
 2201              		.loc 1 901 0
 2202 124c 0780A0E1 		mov	r8, r7
 2203 1250 F2FEFFEA 		b	.L139
 2204              	.LVL162:
 2205              	.L149:
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2206              		.loc 1 816 0 discriminator 1
 2207 1254 000058E3 		cmp	r8, #0
 2208 1258 9A03000A 		beq	.L249
 814:../uvc.c      **** 					 break;
 2209              		.loc 1 814 0
 2210 125c 28E1A0E1 		mov	lr, r8, lsr #2
 2211 1260 00005EE3 		cmp	lr, #0
 2212 1264 03005813 		cmpne	r8, #3
 2213 1268 0020A083 		movhi	r2, #0
 2214 126c 0120A093 		movls	r2, #1
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2215              		.loc 1 734 0
 2216 1270 0E31A0E1 		mov	r3, lr, asl #2
 814:../uvc.c      **** 					 break;
 2217              		.loc 1 814 0
 2218 1274 9703009A 		bls	.L229
 2219 1278 A8199FE5 		ldr	r1, .L262+8
 2220 127c 100041E2 		sub	r0, r1, #16
 2221              	.LVL163:
 2222              	.L158:
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2223              		.loc 1 817 0 discriminator 2
 2224 1280 047090E4 		ldr	r7, [r0], #4
 2225 1284 014082E2 		add	r4, r2, #1
 2226 1288 FF2004E2 		and	r2, r4, #255
 2227 128c 0E0052E1 		cmp	r2, lr
 2228 1290 047081E4 		str	r7, [r1], #4
 2229 1294 F9FFFF3A 		bcc	.L158
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2230              		.loc 1 817 0 is_stmt 0
 2231 1298 030058E1 		cmp	r8, r3
 2232 129c C0099F15 		ldrne	r0, .L262+68
 2233 12a0 8803000A 		beq	.L249
 2234              	.L242:
 2235 12a4 03C080E0 		add	ip, r0, r3
 2236 12a8 4C10DCE5 		ldrb	r1, [ip, #76]	@ zero_extendqisi2
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2237              		.loc 1 816 0 is_stmt 1
 2238 12ac 01E083E2 		add	lr, r3, #1
 2239 12b0 FF300EE2 		and	r3, lr, #255
 2240              	.LVL164:
 2241 12b4 030058E1 		cmp	r8, r3
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2242              		.loc 1 817 0
 2243 12b8 5C10CCE5 		strb	r1, [ip, #92]
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2244              		.loc 1 816 0
 2245 12bc F8FFFF8A 		bhi	.L242
 2246              	.LVL165:
 2247              	.L153:
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2248              		.loc 1 826 0
 2249 12c0 5760D0E5 		ldrb	r6, [r0, #87]	@ zero_extendqisi2
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2250              		.loc 1 819 0
 2251 12c4 98399FE5 		ldr	r3, .L262+68
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2252              		.loc 1 826 0
 2253 12c8 FF0056E3 		cmp	r6, #255
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2254              		.loc 1 819 0
 2255 12cc 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2256              	.LVL166:
 820:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2257              		.loc 1 820 0
 2258 12d0 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2259              	.LVL167:
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2260              		.loc 1 826 0
 2261 12d4 D7FFFF0A 		beq	.L154
 828:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2262              		.loc 1 828 0
 2263 12d8 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2264 12dc 54199FE5 		ldr	r1, .L262+24
 2265 12e0 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2266 12e4 0400A0E3 		mov	r0, #4
 2267 12e8 FEFFFFEB 		bl	CyU3PDebugPrint
 2268 12ec D1FFFFEA 		b	.L154
 2269              	.LVL168:
 2270              	.L148:
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 2271              		.loc 1 803 0
 2272 12f0 6C799FE5 		ldr	r7, .L262+68
 2273              	.LVL169:
 802:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2274              		.loc 1 802 0
 2275 12f4 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2276              	.LVL170:
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 2277              		.loc 1 803 0
 2278 12f8 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2279 12fc 010052E3 		cmp	r2, #1
 2280 1300 C402000A 		beq	.L257
 2281              	.LVL171:
 2282              	.L155:
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2283              		.loc 1 813 0
 2284 1304 0000A0E3 		mov	r0, #0
 812:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2285              		.loc 1 812 0
 2286 1308 5C40C7E5 		strb	r4, [r7, #92]
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2287              		.loc 1 813 0
 2288 130c 5D00C7E5 		strb	r0, [r7, #93]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2289              		.loc 1 752 0
 2290 1310 FF60A0E3 		mov	r6, #255
 814:../uvc.c      **** 					 break;
 2291              		.loc 1 814 0
 2292 1314 C7FFFFEA 		b	.L154
 2293              	.LVL172:
 2294              	.L147:
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2295              		.loc 1 796 0
 2296 1318 B1E4D6E5 		ldrb	lr, [r6, #1201]	@ zero_extendqisi2
 2297 131c 40C99FE5 		ldr	ip, .L262+68
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2298              		.loc 1 798 0
 2299 1320 B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2300              		.loc 1 796 0
 2301 1324 FF400EE2 		and	r4, lr, #255
 2302 1328 5C40CCE5 		strb	r4, [ip, #92]
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2303              		.loc 1 798 0
 2304 132c 5D10CCE5 		strb	r1, [ip, #93]
 2305              	.LVL173:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2306              		.loc 1 752 0
 2307 1330 FF60A0E3 		mov	r6, #255
 800:../uvc.c      **** 			 		 break;
 2308              		.loc 1 800 0
 2309 1334 BFFFFFEA 		b	.L154
 2310              	.LVL174:
 2311              	.L146:
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2312              		.loc 1 832 0
 2313 1338 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2314              		.loc 1 833 0
 2315 133c C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2316              		.loc 1 832 0
 2317 1340 1CC99FE5 		ldr	ip, .L262+68
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2318              		.loc 1 836 0
 2319 1344 0070A0E3 		mov	r7, #0
 2320              	.LVL175:
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2321              		.loc 1 833 0
 2322 1348 FF6003E2 		and	r6, r3, #255
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2323              		.loc 1 832 0
 2324 134c FF4002E2 		and	r4, r2, #255
 2325 1350 5C40CCE5 		strb	r4, [ip, #92]
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2326              		.loc 1 833 0
 2327 1354 5E60CCE5 		strb	r6, [ip, #94]
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2328              		.loc 1 836 0
 2329 1358 5D70CCE5 		strb	r7, [ip, #93]
 838:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2330              		.loc 1 838 0
 2331 135c 5F70CCE5 		strb	r7, [ip, #95]
 2332              	.LVL176:
 841:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2333              		.loc 1 841 0
 2334 1360 D4189FE5 		ldr	r1, .L262+28
 2335 1364 0420A0E1 		mov	r2, r4
 2336 1368 0730A0E1 		mov	r3, r7
 2337 136c 0400A0E3 		mov	r0, #4
 2338 1370 C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 2339 1374 FEFFFFEB 		bl	CyU3PDebugPrint
 842:../uvc.c      **** 					 break;
 2340              		.loc 1 842 0
 2341 1378 AEFFFFEA 		b	.L154
 2342              	.LVL177:
 2343              	.L145:
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2344              		.loc 1 790 0
 2345 137c 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 2346 1380 DC089FE5 		ldr	r0, .L262+68
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2347              		.loc 1 792 0
 2348 1384 9E24D6E5 		ldrb	r2, [r6, #1182]	@ zero_extendqisi2
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2349              		.loc 1 790 0
 2350 1388 FF4004E2 		and	r4, r4, #255
 2351 138c 5C40C0E5 		strb	r4, [r0, #92]
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2352              		.loc 1 792 0
 2353 1390 5D20C0E5 		strb	r2, [r0, #93]
 2354              	.LVL178:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2355              		.loc 1 752 0
 2356 1394 FF60A0E3 		mov	r6, #255
 794:../uvc.c      **** 			 		 break;
 2357              		.loc 1 794 0
 2358 1398 A6FFFFEA 		b	.L154
 2359              	.LVL179:
 2360              	.L144:
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2361              		.loc 1 874 0
 2362 139c C0389FE5 		ldr	r3, .L262+68
 2363 13a0 CC44D6E5 		ldrb	r4, [r6, #1228]	@ zero_extendqisi2
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2364              		.loc 1 876 0
 2365 13a4 CE64D6E5 		ldrb	r6, [r6, #1230]	@ zero_extendqisi2
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2366              		.loc 1 875 0
 2367 13a8 00C0A0E3 		mov	ip, #0
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2368              		.loc 1 874 0
 2369 13ac 5C40C3E5 		strb	r4, [r3, #92]
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2370              		.loc 1 875 0
 2371 13b0 5DC0C3E5 		strb	ip, [r3, #93]
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2372              		.loc 1 876 0
 2373 13b4 5E60C3E5 		strb	r6, [r3, #94]
 877:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2374              		.loc 1 877 0
 2375 13b8 5FC0C3E5 		strb	ip, [r3, #95]
 2376              	.LVL180:
 880:../uvc.c      **** 					 break;
 2377              		.loc 1 880 0
 2378 13bc 9DFFFFEA 		b	.L154
 2379              	.LVL181:
 2380              	.L143:
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2381              		.loc 1 869 0
 2382 13c0 0572D6E5 		ldrb	r7, [r6, #517]	@ zero_extendqisi2
 2383              	.LVL182:
 2384 13c4 98689FE5 		ldr	r6, .L262+68
 2385 13c8 804027E2 		eor	r4, r7, #128
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2386              		.loc 1 870 0
 2387 13cc 00E0A0E3 		mov	lr, #0
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2388              		.loc 1 869 0
 2389 13d0 5C40C6E5 		strb	r4, [r6, #92]
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2390              		.loc 1 870 0
 2391 13d4 5DE0C6E5 		strb	lr, [r6, #93]
 2392              	.LVL183:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2393              		.loc 1 752 0
 2394 13d8 FF60A0E3 		mov	r6, #255
 872:../uvc.c      **** 					 break;
 2395              		.loc 1 872 0
 2396 13dc 95FFFFEA 		b	.L154
 2397              	.LVL184:
 2398              	.L142:
 857:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2399              		.loc 1 857 0
 2400 13e0 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2401              	.LVL185:
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2402              		.loc 1 863 0
 2403 13e4 78189FE5 		ldr	r1, .L262+68
 858:../uvc.c      **** 					  if(Data0&0x80){
 2404              		.loc 1 858 0
 2405 13e8 800014E3 		tst	r4, #128
 859:../uvc.c      **** 						  Data0 = ~Data0;
 2406              		.loc 1 859 0
 2407 13ec 0440E011 		mvnne	r4, r4
 2408              	.LVL186:
 861:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2409              		.loc 1 861 0
 2410 13f0 80404402 		subeq	r4, r4, #128
 2411 13f4 FF4004E2 		and	r4, r4, #255
 2412              	.LVL187:
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2413              		.loc 1 864 0
 2414 13f8 0000A0E3 		mov	r0, #0
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2415              		.loc 1 863 0
 2416 13fc 5C40C1E5 		strb	r4, [r1, #92]
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2417              		.loc 1 864 0
 2418 1400 5D00C1E5 		strb	r0, [r1, #93]
 2419              	.LVL188:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2420              		.loc 1 752 0
 2421 1404 FF60A0E3 		mov	r6, #255
 866:../uvc.c      **** 			 		 break;
 2422              		.loc 1 866 0
 2423 1408 8AFFFFEA 		b	.L154
 2424              	.LVL189:
 2425              	.L141:
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2426              		.loc 1 883 0
 2427 140c 20689FE5 		ldr	r6, .L262+20
 2428 1410 4C089FE5 		ldr	r0, .L262+68
 2429 1414 04E186E0 		add	lr, r6, r4, asl #2
 2430 1418 A0109EE5 		ldr	r1, [lr, #160]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2431              		.loc 1 752 0
 2432 141c FF60A0E3 		mov	r6, #255
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2433              		.loc 1 883 0
 2434 1420 0D40D1E5 		ldrb	r4, [r1, #13]	@ zero_extendqisi2
 2435 1424 064004E0 		and	r4, r4, r6
 2436 1428 5C40C0E5 		strb	r4, [r0, #92]
 885:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2437              		.loc 1 885 0
 2438 142c 0E20D1E5 		ldrb	r2, [r1, #14]	@ zero_extendqisi2
 2439 1430 5D20C0E5 		strb	r2, [r0, #93]
 2440              	.LVL190:
 887:../uvc.c      **** 					 break;
 2441              		.loc 1 887 0
 2442 1434 7FFFFFEA 		b	.L154
 2443              	.LVL191:
 2444              	.L140:
 890:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2445              		.loc 1 890 0
 2446 1438 842084E0 		add	r2, r4, r4, asl #1
 2447 143c 823186E0 		add	r3, r6, r2, asl #3
 2448 1440 1CC89FE5 		ldr	ip, .L262+68
 2449 1444 8D41D3E5 		ldrb	r4, [r3, #397]	@ zero_extendqisi2
 891:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2450              		.loc 1 891 0
 2451 1448 0070A0E3 		mov	r7, #0
 2452              	.LVL192:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2453              		.loc 1 752 0
 2454 144c FF60A0E3 		mov	r6, #255
 890:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2455              		.loc 1 890 0
 2456 1450 5C40CCE5 		strb	r4, [ip, #92]
 891:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2457              		.loc 1 891 0
 2458 1454 5D70CCE5 		strb	r7, [ip, #93]
 2459              	.LVL193:
 893:../uvc.c      **** 					 break;
 2460              		.loc 1 893 0
 2461 1458 76FFFFEA 		b	.L154
 2462              	.LVL194:
 2463              	.L193:
1208:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2464              		.loc 1 1208 0
 2465 145c F4479FE5 		ldr	r4, .L262+56
 2466 1460 0010E0E3 		mvn	r1, #0
 2467 1464 1C0094E5 		ldr	r0, [r4, #28]
 2468 1468 FEFFFFEB 		bl	_txe_mutex_get
 2469              	.LVL195:
1209:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2470              		.loc 1 1209 0
 2471 146c 14C09DE5 		ldr	ip, [sp, #20]
 2472 1470 0A20A0E1 		mov	r2, sl
 2473 1474 0930A0E1 		mov	r3, r9
 2474 1478 2610A0E3 		mov	r1, #38
 2475 147c 0400A0E1 		mov	r0, r4
 2476 1480 0080A0E3 		mov	r8, #0
 2477 1484 00C08DE5 		str	ip, [sp, #0]
 2478 1488 04808DE5 		str	r8, [sp, #4]
 2479 148c FEFFFFEB 		bl	cmdSet
1210:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2480              		.loc 1 1210 0
 2481 1490 1C0094E5 		ldr	r0, [r4, #28]
 2482 1494 FEFFFFEB 		bl	_txe_mutex_put
1211:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2483              		.loc 1 1211 0
 2484 1498 14209DE5 		ldr	r2, [sp, #20]
 2485 149c 873087E0 		add	r3, r7, r7, asl #1
 2486 14a0 836186E0 		add	r6, r6, r3, asl #3
1213:../uvc.c      **** 							 break;
 2487              		.loc 1 1213 0
 2488 14a4 FFC0A0E3 		mov	ip, #255
1212:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2489              		.loc 1 1212 0
 2490 14a8 0100A0E3 		mov	r0, #1
1211:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2491              		.loc 1 1211 0
 2492 14ac 0D20C6E5 		strb	r2, [r6, #13]
1212:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2493              		.loc 1 1212 0
 2494 14b0 1000C6E5 		strb	r0, [r6, #16]
 2495 14b4 0280A0E1 		mov	r8, r2
 2496 14b8 18709DE5 		ldr	r7, [sp, #24]
 2497              	.LVL196:
1213:../uvc.c      **** 							 break;
 2498              		.loc 1 1213 0
 2499 14bc 0C40A0E1 		mov	r4, ip
 2500 14c0 56FEFFEA 		b	.L139
 2501              	.LVL197:
 2502              	.L192:
1193:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2503              		.loc 1 1193 0
 2504 14c4 E4C4D6E5 		ldrb	ip, [r6, #1252]	@ zero_extendqisi2
1198:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2505              		.loc 1 1198 0
 2506 14c8 88479FE5 		ldr	r4, .L262+56
1194:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2507              		.loc 1 1194 0
 2508 14cc E534D6E5 		ldrb	r3, [r6, #1253]	@ zero_extendqisi2
1195:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2509              		.loc 1 1195 0
 2510 14d0 F314D6E5 		ldrb	r1, [r6, #1267]	@ zero_extendqisi2
1198:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2511              		.loc 1 1198 0
 2512 14d4 1C0094E5 		ldr	r0, [r4, #28]
1195:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2513              		.loc 1 1195 0
 2514 14d8 FF7001E2 		and	r7, r1, #255
 2515              	.LVL198:
1198:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2516              		.loc 1 1198 0
 2517 14dc 0010E0E3 		mvn	r1, #0
1193:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2518              		.loc 1 1193 0
 2519 14e0 FF800CE2 		and	r8, ip, #255
 2520              	.LVL199:
1198:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2521              		.loc 1 1198 0
 2522 14e4 FEFFFFEB 		bl	_txe_mutex_get
 2523              	.LVL200:
1199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2524              		.loc 1 1199 0
 2525 14e8 0730A0E1 		mov	r3, r7
 2526 14ec 14709DE5 		ldr	r7, [sp, #20]
 2527              	.LVL201:
 2528 14f0 0820A0E1 		mov	r2, r8
 2529 14f4 2510A0E3 		mov	r1, #37
 2530 14f8 0400A0E1 		mov	r0, r4
 2531 14fc 0080A0E3 		mov	r8, #0
 2532              	.LVL202:
 2533 1500 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 2534 1504 FEFFFFEB 		bl	cmdSet
 2535              	.LVL203:
1200:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2536              		.loc 1 1200 0
 2537 1508 1C0094E5 		ldr	r0, [r4, #28]
 2538 150c FEFFFFEB 		bl	_txe_mutex_put
1201:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2539              		.loc 1 1201 0
 2540 1510 14309DE5 		ldr	r3, [sp, #20]
1205:../uvc.c      **** 							 break;
 2541              		.loc 1 1205 0
 2542 1514 FFC0A0E3 		mov	ip, #255
1202:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2543              		.loc 1 1202 0
 2544 1518 0100A0E3 		mov	r0, #1
1201:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2545              		.loc 1 1201 0
 2546 151c F134C6E5 		strb	r3, [r6, #1265]
1202:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2547              		.loc 1 1202 0
 2548 1520 0380A0E1 		mov	r8, r3
 2549 1524 F504C6E5 		strb	r0, [r6, #1269]
 2550 1528 18709DE5 		ldr	r7, [sp, #24]
1205:../uvc.c      **** 							 break;
 2551              		.loc 1 1205 0
 2552 152c 0C40A0E1 		mov	r4, ip
 2553 1530 3AFEFFEA 		b	.L139
 2554              	.LVL204:
 2555              	.L191:
1153:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2556              		.loc 1 1153 0
 2557 1534 D0E4D6E5 		ldrb	lr, [r6, #1232]	@ zero_extendqisi2
1180:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2558              		.loc 1 1180 0
 2559 1538 18479FE5 		ldr	r4, .L262+56
1154:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2560              		.loc 1 1154 0
 2561 153c D194D6E5 		ldrb	r9, [r6, #1233]	@ zero_extendqisi2
1155:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2562              		.loc 1 1155 0
 2563 1540 DF24D6E5 		ldrb	r2, [r6, #1247]	@ zero_extendqisi2
 2564              	.LVL205:
1153:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2565              		.loc 1 1153 0
 2566 1544 FFA00EE2 		and	sl, lr, #255
 2567              	.LVL206:
1155:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2568              		.loc 1 1155 0
 2569 1548 FF7002E2 		and	r7, r2, #255
 2570              	.LVL207:
1180:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2571              		.loc 1 1180 0
 2572 154c 0010E0E3 		mvn	r1, #0
 2573 1550 1C0094E5 		ldr	r0, [r4, #28]
1179:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2574              		.loc 1 1179 0
 2575 1554 7F8003E2 		and	r8, r3, #127
1180:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2576              		.loc 1 1180 0
 2577 1558 FEFFFFEB 		bl	_txe_mutex_get
1182:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2578              		.loc 1 1182 0
 2579 155c 0A20A0E1 		mov	r2, sl
 2580 1560 0730A0E1 		mov	r3, r7
 2581 1564 00C0A0E3 		mov	ip, #0
 2582 1568 2410A0E3 		mov	r1, #36
 2583 156c 0400A0E1 		mov	r0, r4
 2584 1570 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2585 1574 FEFFFFEB 		bl	cmdSet
1184:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2586              		.loc 1 1184 0
 2587 1578 1CC09DE5 		ldr	ip, [sp, #28]
1154:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2588              		.loc 1 1154 0
 2589 157c FF9009E2 		and	r9, r9, #255
 2590              	.LVL208:
1184:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2591              		.loc 1 1184 0
 2592 1580 0730A0E1 		mov	r3, r7
 2593 1584 01A0A0E3 		mov	sl, #1
 2594              	.LVL209:
 2595 1588 2410A0E3 		mov	r1, #36
 2596 158c 0920A0E1 		mov	r2, r9
 2597 1590 0400A0E1 		mov	r0, r4
 2598 1594 00C08DE5 		str	ip, [sp, #0]
 2599 1598 04A08DE5 		str	sl, [sp, #4]
 2600 159c FEFFFFEB 		bl	cmdSet
1185:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2601              		.loc 1 1185 0
 2602 15a0 1C0094E5 		ldr	r0, [r4, #28]
 2603 15a4 FEFFFFEB 		bl	_txe_mutex_put
 2604              	.LVL210:
1189:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2605              		.loc 1 1189 0
 2606 15a8 1C709DE5 		ldr	r7, [sp, #28]
 2607              	.LVL211:
1191:../uvc.c      **** 							 break;
 2608              		.loc 1 1191 0
 2609 15ac FFC0A0E3 		mov	ip, #255
1188:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2610              		.loc 1 1188 0
 2611 15b0 DD84C6E5 		strb	r8, [r6, #1245]
1191:../uvc.c      **** 							 break;
 2612              		.loc 1 1191 0
 2613 15b4 0C40A0E1 		mov	r4, ip
1189:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2614              		.loc 1 1189 0
 2615 15b8 DE74C6E5 		strb	r7, [r6, #1246]
1190:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2616              		.loc 1 1190 0
 2617 15bc 14809DE5 		ldr	r8, [sp, #20]
 2618              	.LVL212:
 2619 15c0 E1A4C6E5 		strb	sl, [r6, #1249]
1191:../uvc.c      **** 							 break;
 2620              		.loc 1 1191 0
 2621 15c4 15FEFFEA 		b	.L139
 2622              	.LVL213:
 2623              	.L190:
1147:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2624              		.loc 1 1147 0 discriminator 1
 2625 15c8 000058E3 		cmp	r8, #0
 2626 15cc 1800000A 		beq	.L196
1145:../uvc.c      **** 							 break;
 2627              		.loc 1 1145 0
 2628 15d0 28E1A0E1 		mov	lr, r8, lsr #2
 2629 15d4 00005EE3 		cmp	lr, #0
 2630 15d8 03005813 		cmpne	r8, #3
 2631 15dc 0020A083 		movhi	r2, #0
 2632 15e0 0120A093 		movls	r2, #1
 2633              	.LVL214:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2634              		.loc 1 734 0
 2635 15e4 0E31A0E1 		mov	r3, lr, asl #2
1145:../uvc.c      **** 							 break;
 2636              		.loc 1 1145 0
 2637 15e8 B802009A 		bls	.L231
 2638 15ec 4C169FE5 		ldr	r1, .L262+32
 2639 15f0 100081E2 		add	r0, r1, #16
 2640              	.LVL215:
 2641              	.L206:
1148:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2642              		.loc 1 1148 0 discriminator 2
 2643 15f4 044090E4 		ldr	r4, [r0], #4
 2644 15f8 012082E2 		add	r2, r2, #1
 2645 15fc FF2002E2 		and	r2, r2, #255
 2646 1600 02005EE1 		cmp	lr, r2
 2647 1604 044081E4 		str	r4, [r1], #4
 2648 1608 F9FFFF8A 		bhi	.L206
1148:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2649              		.loc 1 1148 0 is_stmt 0
 2650 160c 030058E1 		cmp	r8, r3
 2651 1610 0700000A 		beq	.L196
 2652              	.L243:
 2653 1614 48169FE5 		ldr	r1, .L262+68
 2654 1618 030081E0 		add	r0, r1, r3
 2655 161c 5CE0D0E5 		ldrb	lr, [r0, #92]	@ zero_extendqisi2
1147:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2656              		.loc 1 1147 0 is_stmt 1
 2657 1620 013083E2 		add	r3, r3, #1
 2658 1624 FF3003E2 		and	r3, r3, #255
 2659              	.LVL216:
 2660 1628 030058E1 		cmp	r8, r3
1148:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2661              		.loc 1 1148 0
 2662 162c 4CE0C0E5 		strb	lr, [r0, #76]
1147:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2663              		.loc 1 1147 0
 2664 1630 F7FFFF8A 		bhi	.L243
 2665              	.LVL217:
 2666              	.L196:
1150:../uvc.c      **** 					 		I2CCmdHandler();
 2667              		.loc 1 1150 0
 2668 1634 FEFFFFEB 		bl	I2CCmdHandler
1151:../uvc.c      **** 							 break;
 2669              		.loc 1 1151 0
 2670 1638 FFC0A0E3 		mov	ip, #255
1150:../uvc.c      **** 					 		I2CCmdHandler();
 2671              		.loc 1 1150 0
 2672 163c 14809DE5 		ldr	r8, [sp, #20]
 2673 1640 18709DE5 		ldr	r7, [sp, #24]
 2674              	.LVL218:
1151:../uvc.c      **** 							 break;
 2675              		.loc 1 1151 0
 2676 1644 0C40A0E1 		mov	r4, ip
 2677 1648 F4FDFFEA 		b	.L139
 2678              	.LVL219:
 2679              	.L189:
1141:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2680              		.loc 1 1141 0
 2681 164c 04469FE5 		ldr	r4, .L262+56
 2682 1650 0010E0E3 		mvn	r1, #0
 2683 1654 1C0094E5 		ldr	r0, [r4, #28]
 2684 1658 FEFFFFEB 		bl	_txe_mutex_get
 2685              	.LVL220:
1142:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2686              		.loc 1 1142 0
 2687 165c 14C09DE5 		ldr	ip, [sp, #20]
 2688 1660 1E10A0E3 		mov	r1, #30
 2689 1664 01707CE2 		rsbs	r7, ip, #1
 2690              	.LVL221:
 2691 1668 0070A033 		movcc	r7, #0
 2692 166c 0A20A0E1 		mov	r2, sl
 2693 1670 0930A0E1 		mov	r3, r9
 2694 1674 0400A0E1 		mov	r0, r4
 2695 1678 0080A0E3 		mov	r8, #0
 2696 167c 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 2697 1680 FEFFFFEB 		bl	cmdSet
1143:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2698              		.loc 1 1143 0
 2699 1684 1C0094E5 		ldr	r0, [r4, #28]
 2700 1688 FEFFFFEB 		bl	_txe_mutex_put
1145:../uvc.c      **** 							 break;
 2701              		.loc 1 1145 0
 2702 168c FFC0A0E3 		mov	ip, #255
1144:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2703              		.loc 1 1144 0
 2704 1690 0110A0E3 		mov	r1, #1
 2705 1694 6014C6E5 		strb	r1, [r6, #1120]
 2706 1698 14809DE5 		ldr	r8, [sp, #20]
 2707 169c 18709DE5 		ldr	r7, [sp, #24]
1145:../uvc.c      **** 							 break;
 2708              		.loc 1 1145 0
 2709 16a0 0C40A0E1 		mov	r4, ip
 2710 16a4 DDFDFFEA 		b	.L139
 2711              	.LVL222:
 2712              	.L183:
1376:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2713              		.loc 1 1376 0
 2714 16a8 0C15D6E5 		ldrb	r1, [r6, #1292]	@ zero_extendqisi2
1377:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2715              		.loc 1 1377 0
 2716 16ac 0DA5D6E5 		ldrb	sl, [r6, #1293]	@ zero_extendqisi2
1378:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 2717              		.loc 1 1378 0
 2718 16b0 1BE5D6E5 		ldrb	lr, [r6, #1307]	@ zero_extendqisi2
1381:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 2719              		.loc 1 1381 0
 2720 16b4 0140A0E3 		mov	r4, #1
1382:../uvc.c      **** 							 if(Data0 != 0){
 2721              		.loc 1 1382 0
 2722 16b8 000053E3 		cmp	r3, #0
1380:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 2723              		.loc 1 1380 0
 2724 16bc 1935C6E5 		strb	r3, [r6, #1305]
1376:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2725              		.loc 1 1376 0
 2726 16c0 FF8001E2 		and	r8, r1, #255
 2727              	.LVL223:
1377:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2728              		.loc 1 1377 0
 2729 16c4 FFA00AE2 		and	sl, sl, #255
 2730              	.LVL224:
1378:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 2731              		.loc 1 1378 0
 2732 16c8 FF700EE2 		and	r7, lr, #255
 2733              	.LVL225:
1381:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 2734              		.loc 1 1381 0
 2735 16cc 1D45C6E5 		strb	r4, [r6, #1309]
1382:../uvc.c      **** 							 if(Data0 != 0){
 2736              		.loc 1 1382 0
 2737 16d0 D501000A 		beq	.L228
1383:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2738              		.loc 1 1383 0
 2739 16d4 7C659FE5 		ldr	r6, .L262+56
 2740 16d8 0010E0E3 		mvn	r1, #0
 2741 16dc 1C0096E5 		ldr	r0, [r6, #28]
 2742 16e0 FEFFFFEB 		bl	_txe_mutex_get
 2743              	.LVL226:
1384:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 2744              		.loc 1 1384 0
 2745 16e4 0820A0E1 		mov	r2, r8
 2746 16e8 00C0A0E3 		mov	ip, #0
 2747 16ec 0710A0E3 		mov	r1, #7
 2748 16f0 0730A0E1 		mov	r3, r7
 2749 16f4 0600A0E1 		mov	r0, r6
 2750 16f8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2751 16fc FEFFFFEB 		bl	cmdSet
 2752              	.LVL227:
1386:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 2753              		.loc 1 1386 0
 2754 1700 14809DE5 		ldr	r8, [sp, #20]
 2755              	.LVL228:
 2756 1704 0710A0E3 		mov	r1, #7
 2757 1708 0A20A0E1 		mov	r2, sl
 2758 170c 0730A0E1 		mov	r3, r7
 2759 1710 0600A0E1 		mov	r0, r6
 2760 1714 00808DE5 		str	r8, [sp, #0]
 2761 1718 04408DE5 		str	r4, [sp, #4]
 2762 171c FEFFFFEB 		bl	cmdSet
1387:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2763              		.loc 1 1387 0
 2764 1720 1C0096E5 		ldr	r0, [r6, #28]
 2765              	.LVL229:
 2766              	.L251:
 2767 1724 FEFFFFEB 		bl	_txe_mutex_put
 2768 1728 FFC0A0E3 		mov	ip, #255
 2769 172c 14809DE5 		ldr	r8, [sp, #20]
 2770 1730 18709DE5 		ldr	r7, [sp, #24]
 2771 1734 0C40A0E1 		mov	r4, ip
 2772 1738 B8FDFFEA 		b	.L139
 2773              	.LVL230:
 2774              	.L182:
1276:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2775              		.loc 1 1276 0
 2776 173c 14459FE5 		ldr	r4, .L262+56
 2777 1740 0010E0E3 		mvn	r1, #0
 2778 1744 1C0094E5 		ldr	r0, [r4, #28]
 2779 1748 FEFFFFEB 		bl	_txe_mutex_get
 2780              	.LVL231:
1277:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2781              		.loc 1 1277 0
 2782 174c 14C09DE5 		ldr	ip, [sp, #20]
 2783 1750 0610A0E3 		mov	r1, #6
 2784 1754 0A20A0E1 		mov	r2, sl
 2785 1758 0930A0E1 		mov	r3, r9
 2786 175c 0400A0E1 		mov	r0, r4
 2787 1760 0080A0E3 		mov	r8, #0
 2788 1764 00C08DE5 		str	ip, [sp, #0]
 2789 1768 04808DE5 		str	r8, [sp, #4]
 2790 176c FEFFFFEB 		bl	cmdSet
 2791              	.LVL232:
1279:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2792              		.loc 1 1279 0
 2793 1770 14C09DE5 		ldr	ip, [sp, #20]
 2794 1774 0170A0E3 		mov	r7, #1
 2795              	.LVL233:
 2796 1778 0610A0E3 		mov	r1, #6
 2797 177c 0B20A0E1 		mov	r2, fp
 2798 1780 0930A0E1 		mov	r3, r9
 2799 1784 0400A0E1 		mov	r0, r4
 2800 1788 00C08DE5 		str	ip, [sp, #0]
 2801 178c 04708DE5 		str	r7, [sp, #4]
 2802 1790 FEFFFFEB 		bl	cmdSet
1280:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2803              		.loc 1 1280 0
 2804 1794 1C0094E5 		ldr	r0, [r4, #28]
 2805 1798 FEFFFFEB 		bl	_txe_mutex_put
1281:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2806              		.loc 1 1281 0
 2807 179c 14809DE5 		ldr	r8, [sp, #20]
1283:../uvc.c      **** 							 break;
 2808              		.loc 1 1283 0
 2809 17a0 FFC0A0E3 		mov	ip, #255
1282:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2810              		.loc 1 1282 0
 2811 17a4 2072C6E5 		strb	r7, [r6, #544]
1281:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2812              		.loc 1 1281 0
 2813 17a8 1D82C6E5 		strb	r8, [r6, #541]
1282:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2814              		.loc 1 1282 0
 2815 17ac 18709DE5 		ldr	r7, [sp, #24]
1283:../uvc.c      **** 							 break;
 2816              		.loc 1 1283 0
 2817 17b0 0C40A0E1 		mov	r4, ip
 2818 17b4 99FDFFEA 		b	.L139
 2819              	.LVL234:
 2820              	.L187:
1096:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2821              		.loc 1 1096 0
 2822 17b8 98449FE5 		ldr	r4, .L262+56
1092:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2823              		.loc 1 1092 0
 2824 17bc A4A4D6E5 		ldrb	sl, [r6, #1188]	@ zero_extendqisi2
1093:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2825              		.loc 1 1093 0
 2826 17c0 A584D6E5 		ldrb	r8, [r6, #1189]	@ zero_extendqisi2
1094:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2827              		.loc 1 1094 0
 2828 17c4 B334D6E5 		ldrb	r3, [r6, #1203]	@ zero_extendqisi2
1096:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2829              		.loc 1 1096 0
 2830 17c8 0010E0E3 		mvn	r1, #0
 2831 17cc 1C0094E5 		ldr	r0, [r4, #28]
1094:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2832              		.loc 1 1094 0
 2833 17d0 FF7003E2 		and	r7, r3, #255
 2834              	.LVL235:
1096:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2835              		.loc 1 1096 0
 2836 17d4 FEFFFFEB 		bl	_txe_mutex_get
 2837              	.LVL236:
1104:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2838              		.loc 1 1104 0
 2839 17d8 B114D6E5 		ldrb	r1, [r6, #1201]	@ zero_extendqisi2
 2840 17dc 14009DE5 		ldr	r0, [sp, #20]
1092:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2841              		.loc 1 1092 0
 2842 17e0 FFA00AE2 		and	sl, sl, #255
 2843              	.LVL237:
1104:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2844              		.loc 1 1104 0
 2845 17e4 010050E1 		cmp	r0, r1
1093:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2846              		.loc 1 1093 0
 2847 17e8 FF8008E2 		and	r8, r8, #255
 2848              	.LVL238:
1092:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2849              		.loc 1 1092 0
 2850 17ec 68349FE5 		ldr	r3, .L262+60
1104:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2851              		.loc 1 1104 0
 2852 17f0 0600000A 		beq	.L201
1105:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 2853              		.loc 1 1105 0
 2854 17f4 B104C3E5 		strb	r0, [r3, #1201]
1106:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2855              		.loc 1 1106 0
 2856 17f8 C504D3E5 		ldrb	r0, [r3, #1221]	@ zero_extendqisi2
 2857 17fc 010050E3 		cmp	r0, #1
 2858 1800 0C02000A 		beq	.L202
1106:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2859              		.loc 1 1106 0 is_stmt 0 discriminator 1
 2860 1804 C524D3E5 		ldrb	r2, [r3, #1221]	@ zero_extendqisi2
 2861 1808 030052E3 		cmp	r2, #3
 2862 180c 0902000A 		beq	.L202
 2863              	.LVL239:
 2864              	.L201:
1113:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2865              		.loc 1 1113 0 is_stmt 1
 2866 1810 1C0094E5 		ldr	r0, [r4, #28]
 2867 1814 FEFFFFEB 		bl	_txe_mutex_put
1115:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2868              		.loc 1 1115 0
 2869 1818 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1114:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2870              		.loc 1 1114 0
 2871 181c 14809DE5 		ldr	r8, [sp, #20]
 2872              	.LVL240:
1115:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2873              		.loc 1 1115 0
 2874 1820 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
1114:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2875              		.loc 1 1114 0
 2876 1824 18709DE5 		ldr	r7, [sp, #24]
1115:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2877              		.loc 1 1115 0
 2878 1828 B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
1114:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2879              		.loc 1 1114 0
 2880 182c 0400A0E3 		mov	r0, #4
 2881 1830 0C149FE5 		ldr	r1, .L262+36
 2882 1834 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 2883 1838 08708DE5 		str	r7, [sp, #8]
 2884 183c FEFFFFEB 		bl	CyU3PDebugPrint
1116:../uvc.c      **** 							 break;
 2885              		.loc 1 1116 0
 2886 1840 FFC0A0E3 		mov	ip, #255
 2887 1844 0C40A0E1 		mov	r4, ip
 2888 1848 74FDFFEA 		b	.L139
 2889              	.LVL241:
 2890              	.L186:
1062:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2891              		.loc 1 1062 0
 2892 184c 04449FE5 		ldr	r4, .L262+56
1058:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2893              		.loc 1 1058 0
 2894 1850 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
1059:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2895              		.loc 1 1059 0
 2896 1854 B974D6E5 		ldrb	r7, [r6, #1209]	@ zero_extendqisi2
 2897              	.LVL242:
1060:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 2898              		.loc 1 1060 0
 2899 1858 C724D6E5 		ldrb	r2, [r6, #1223]	@ zero_extendqisi2
 2900              	.LVL243:
1062:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2901              		.loc 1 1062 0
 2902 185c 1C0094E5 		ldr	r0, [r4, #28]
 2903 1860 0010E0E3 		mvn	r1, #0
1059:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2904              		.loc 1 1059 0
 2905 1864 FF9007E2 		and	r9, r7, #255
1060:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 2906              		.loc 1 1060 0
 2907 1868 FF7002E2 		and	r7, r2, #255
1062:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2908              		.loc 1 1062 0
 2909 186c FEFFFFEB 		bl	_txe_mutex_get
1063:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2910              		.loc 1 1063 0
 2911 1870 14C09DE5 		ldr	ip, [sp, #20]
 2912 1874 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
1058:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2913              		.loc 1 1058 0
 2914 1878 FFA00AE2 		and	sl, sl, #255
 2915              	.LVL244:
1063:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2916              		.loc 1 1063 0
 2917 187c 03005CE1 		cmp	ip, r3
1058:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2918              		.loc 1 1058 0
 2919 1880 D4239FE5 		ldr	r2, .L262+60
 2920 1884 0C80A001 		moveq	r8, ip
1063:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2921              		.loc 1 1063 0
 2922 1888 0A00000A 		beq	.L199
1065:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 2923              		.loc 1 1065 0
 2924 188c C5C4C2E5 		strb	ip, [r2, #1221]
1066:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 2925              		.loc 1 1066 0
 2926 1890 9DE4D2E5 		ldrb	lr, [r2, #1181]	@ zero_extendqisi2
1067:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 2927              		.loc 1 1067 0
 2928 1894 1910A0E3 		mov	r1, #25
1066:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 2929              		.loc 1 1066 0
 2930 1898 0E028CE1 		orr	r0, ip, lr, asl #4
 2931 189c FF8000E2 		and	r8, r0, #255
 2932              	.LVL245:
1067:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 2933              		.loc 1 1067 0
 2934 18a0 00C0A0E3 		mov	ip, #0
 2935 18a4 0400A0E1 		mov	r0, r4
 2936 18a8 0A20A0E1 		mov	r2, sl
 2937 18ac 0730A0E1 		mov	r3, r7
 2938 18b0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2939 18b4 FEFFFFEB 		bl	cmdSet
 2940              	.LVL246:
 2941              	.L199:
1079:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 2942              		.loc 1 1079 0
 2943 18b8 C614D6E5 		ldrb	r1, [r6, #1222]	@ zero_extendqisi2
 2944 18bc 18009DE5 		ldr	r0, [sp, #24]
 2945 18c0 000051E1 		cmp	r1, r0
 2946 18c4 0500000A 		beq	.L200
1081:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2947              		.loc 1 1081 0
 2948 18c8 14C09DE5 		ldr	ip, [sp, #20]
1080:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 2949              		.loc 1 1080 0
 2950 18cc 88339FE5 		ldr	r3, .L262+60
1081:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2951              		.loc 1 1081 0
 2952 18d0 02204CE2 		sub	r2, ip, #2
 2953 18d4 010052E3 		cmp	r2, #1
1080:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 2954              		.loc 1 1080 0
 2955 18d8 C604C3E5 		strb	r0, [r3, #1222]
1081:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2956              		.loc 1 1081 0
 2957 18dc E601009A 		bls	.L258
 2958              	.LVL247:
 2959              	.L200:
1086:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2960              		.loc 1 1086 0
 2961 18e0 1C0094E5 		ldr	r0, [r4, #28]
 2962 18e4 FEFFFFEB 		bl	_txe_mutex_put
1088:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 2963              		.loc 1 1088 0
 2964 18e8 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1087:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2965              		.loc 1 1087 0
 2966 18ec 18709DE5 		ldr	r7, [sp, #24]
1088:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 2967              		.loc 1 1088 0
 2968 18f0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 2969 18f4 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
1087:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2970              		.loc 1 1087 0
 2971 18f8 0400A0E3 		mov	r0, #4
 2972 18fc 44139FE5 		ldr	r1, .L262+40
 2973 1900 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 2974 1904 08708DE5 		str	r7, [sp, #8]
 2975 1908 FEFFFFEB 		bl	CyU3PDebugPrint
1089:../uvc.c      **** 							 break;
 2976              		.loc 1 1089 0
 2977 190c FFC0A0E3 		mov	ip, #255
1087:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2978              		.loc 1 1087 0
 2979 1910 14809DE5 		ldr	r8, [sp, #20]
 2980              	.LVL248:
1089:../uvc.c      **** 							 break;
 2981              		.loc 1 1089 0
 2982 1914 0C40A0E1 		mov	r4, ip
 2983 1918 40FDFFEA 		b	.L139
 2984              	.LVL249:
 2985              	.L185:
 998:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2986              		.loc 1 998 0
 2987 191c 9044D6E5 		ldrb	r4, [r6, #1168]	@ zero_extendqisi2
 2988 1920 0310A0E1 		mov	r1, r3
 999:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2989              		.loc 1 999 0
 2990 1924 9184D6E5 		ldrb	r8, [r6, #1169]	@ zero_extendqisi2
1000:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 2991              		.loc 1 1000 0
 2992 1928 9F24D6E5 		ldrb	r2, [r6, #1183]	@ zero_extendqisi2
 2993              	.LVL250:
1001:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 2994              		.loc 1 1001 0
 2995 192c 9D34C6E5 		strb	r3, [r6, #1181]
1003:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 2996              		.loc 1 1003 0
 2997 1930 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
 998:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2998              		.loc 1 998 0
 2999 1934 FFA004E2 		and	sl, r4, #255
 3000              	.LVL251:
1003:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3001              		.loc 1 1003 0
 3002 1938 030013E3 		tst	r3, #3
 999:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3003              		.loc 1 999 0
 3004 193c FF8008E2 		and	r8, r8, #255
 3005              	.LVL252:
1000:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3006              		.loc 1 1000 0
 3007 1940 FF7002E2 		and	r7, r2, #255
 3008              	.LVL253:
1003:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3009              		.loc 1 1003 0
 3010 1944 0130A001 		moveq	r3, r1
 3011 1948 1B00000A 		beq	.L198
 3012 194c 01E0A0E1 		mov	lr, r1
1005:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3013              		.loc 1 1005 0
 3014 1950 04139FE5 		ldr	r1, .L262+60
1007:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3015              		.loc 1 1007 0
 3016 1954 FC429FE5 		ldr	r4, .L262+56
1005:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3017              		.loc 1 1005 0
 3018 1958 C504D1E5 		ldrb	r0, [r1, #1221]	@ zero_extendqisi2
1007:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3019              		.loc 1 1007 0
 3020 195c 0010E0E3 		mvn	r1, #0
1005:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3021              		.loc 1 1005 0
 3022 1960 0E9280E1 		orr	r9, r0, lr, asl #4
1007:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3023              		.loc 1 1007 0
 3024 1964 1C0094E5 		ldr	r0, [r4, #28]
 3025 1968 FEFFFFEB 		bl	_txe_mutex_get
1008:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3026              		.loc 1 1008 0
 3027 196c 00C0A0E3 		mov	ip, #0
 3028 1970 0730A0E1 		mov	r3, r7
 3029 1974 1010A0E3 		mov	r1, #16
 3030 1978 0820A0E1 		mov	r2, r8
 3031 197c 0400A0E1 		mov	r0, r4
 3032 1980 00C08DE5 		str	ip, [sp, #0]
 3033 1984 04C08DE5 		str	ip, [sp, #4]
1005:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3034              		.loc 1 1005 0
 3035 1988 FF9009E2 		and	r9, r9, #255
 3036              	.LVL254:
1008:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3037              		.loc 1 1008 0
 3038 198c FEFFFFEB 		bl	cmdSet
 3039              	.LVL255:
1010:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3040              		.loc 1 1010 0
 3041 1990 0730A0E1 		mov	r3, r7
 3042 1994 1010A0E3 		mov	r1, #16
 3043 1998 0A20A0E1 		mov	r2, sl
 3044 199c 0400A0E1 		mov	r0, r4
 3045 19a0 0170A0E3 		mov	r7, #1
 3046              	.LVL256:
 3047 19a4 00908DE5 		str	r9, [sp, #0]
 3048 19a8 04708DE5 		str	r7, [sp, #4]
 3049 19ac FEFFFFEB 		bl	cmdSet
 3050              	.LVL257:
1011:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3051              		.loc 1 1011 0
 3052 19b0 1C0094E5 		ldr	r0, [r4, #28]
 3053 19b4 FEFFFFEB 		bl	_txe_mutex_put
 3054 19b8 0930A0E1 		mov	r3, r9
 3055              	.LVL258:
 3056              	.L198:
1014:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3057              		.loc 1 1014 0
 3058 19bc C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3059 19c0 9D84D6E5 		ldrb	r8, [r6, #1181]	@ zero_extendqisi2
 3060              	.LVL259:
1013:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3061              		.loc 1 1013 0
 3062 19c4 0400A0E3 		mov	r0, #4
 3063 19c8 7C129FE5 		ldr	r1, .L262+44
 3064 19cc 1C209DE5 		ldr	r2, [sp, #28]
 3065 19d0 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3066 19d4 FEFFFFEB 		bl	CyU3PDebugPrint
1015:../uvc.c      **** 						     break;
 3067              		.loc 1 1015 0
 3068 19d8 FFC0A0E3 		mov	ip, #255
1013:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3069              		.loc 1 1013 0
 3070 19dc 14809DE5 		ldr	r8, [sp, #20]
 3071 19e0 18709DE5 		ldr	r7, [sp, #24]
1015:../uvc.c      **** 						     break;
 3072              		.loc 1 1015 0
 3073 19e4 0C40A0E1 		mov	r4, ip
 3074 19e8 0CFDFFEA 		b	.L139
 3075              	.LVL260:
 3076              	.L184:
1290:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3077              		.loc 1 1290 0
 3078 19ec 64429FE5 		ldr	r4, .L262+56
 3079 19f0 0010E0E3 		mvn	r1, #0
 3080 19f4 1C0094E5 		ldr	r0, [r4, #28]
 3081 19f8 FEFFFFEB 		bl	_txe_mutex_get
 3082              	.LVL261:
1291:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3083              		.loc 1 1291 0
 3084 19fc 14809DE5 		ldr	r8, [sp, #20]
 3085 1a00 00C0A0E3 		mov	ip, #0
 3086 1a04 0B10A0E3 		mov	r1, #11
 3087 1a08 0A20A0E1 		mov	r2, sl
 3088 1a0c 0930A0E1 		mov	r3, r9
 3089 1a10 0400A0E1 		mov	r0, r4
 3090 1a14 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3091 1a18 FEFFFFEB 		bl	cmdSet
 3092              	.LVL262:
1293:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3093              		.loc 1 1293 0
 3094 1a1c 18809DE5 		ldr	r8, [sp, #24]
 3095 1a20 0170A0E3 		mov	r7, #1
 3096              	.LVL263:
 3097 1a24 0B10A0E3 		mov	r1, #11
 3098 1a28 0930A0E1 		mov	r3, r9
 3099 1a2c 0B20A0E1 		mov	r2, fp
 3100 1a30 0400A0E1 		mov	r0, r4
 3101 1a34 00808DE5 		str	r8, [sp, #0]
 3102 1a38 04708DE5 		str	r7, [sp, #4]
 3103 1a3c FEFFFFEB 		bl	cmdSet
1294:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3104              		.loc 1 1294 0
 3105 1a40 1C0094E5 		ldr	r0, [r4, #28]
 3106 1a44 FEFFFFEB 		bl	_txe_mutex_put
1296:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3107              		.loc 1 1296 0
 3108 1a48 14109DE5 		ldr	r1, [sp, #20]
1297:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3109              		.loc 1 1297 0
 3110 1a4c 18309DE5 		ldr	r3, [sp, #24]
1299:../uvc.c      **** 							 break;
 3111              		.loc 1 1299 0
 3112 1a50 FFC0A0E3 		mov	ip, #255
1298:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3113              		.loc 1 1298 0
 3114 1a54 9872C6E5 		strb	r7, [r6, #664]
1296:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3115              		.loc 1 1296 0
 3116 1a58 CC14C6E5 		strb	r1, [r6, #1228]
1297:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3117              		.loc 1 1297 0
 3118 1a5c CE34C6E5 		strb	r3, [r6, #1230]
1298:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3119              		.loc 1 1298 0
 3120 1a60 0180A0E1 		mov	r8, r1
 3121 1a64 0370A0E1 		mov	r7, r3
1299:../uvc.c      **** 							 break;
 3122              		.loc 1 1299 0
 3123 1a68 0C40A0E1 		mov	r4, ip
 3124 1a6c EBFCFFEA 		b	.L139
 3125              	.LVL264:
 3126              	.L188:
1119:../uvc.c      **** 							 if(Data0 <= 3){
 3127              		.loc 1 1119 0
 3128 1a70 030053E3 		cmp	r3, #3
1123:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3129              		.loc 1 1123 0
 3130 1a74 E8C19F85 		ldrhi	ip, .L262+68
1120:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3131              		.loc 1 1120 0
 3132 1a78 E4119F95 		ldrls	r1, .L262+68
1123:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3133              		.loc 1 1123 0
 3134 1a7c 0120A083 		movhi	r2, #1
 3135              	.LVL265:
 3136 1a80 0300A0E1 		mov	r0, r3
 3137              	.LVL266:
 3138 1a84 7C20CC85 		strhib	r2, [ip, #124]
1120:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3139              		.loc 1 1120 0
 3140 1a88 0030A093 		movls	r3, #0
1129:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3141              		.loc 1 1129 0
 3142 1a8c C4819FE5 		ldr	r8, .L262+56
1126:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3143              		.loc 1 1126 0
 3144 1a90 14209DE5 		ldr	r2, [sp, #20]
1120:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3145              		.loc 1 1120 0
 3146 1a94 7C30C195 		strlsb	r3, [r1, #124]
 3147              	.LVL267:
1124:../uvc.c      **** 								 Data1 = Data0-4;
 3148              		.loc 1 1124 0
 3149 1a98 04304382 		subhi	r3, r3, #4
1120:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3150              		.loc 1 1120 0
 3151 1a9c 0030A091 		movls	r3, r0
 3152              	.LVL268:
1127:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 3153              		.loc 1 1127 0
 3154 1aa0 8D31C6E5 		strb	r3, [r6, #397]
1128:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3155              		.loc 1 1128 0
 3156 1aa4 0130A0E3 		mov	r3, #1
 3157              	.LVL269:
1129:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3158              		.loc 1 1129 0
 3159 1aa8 0010E0E3 		mvn	r1, #0
1126:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3160              		.loc 1 1126 0
 3161 1aac 2D24C6E5 		strb	r2, [r6, #1069]
1128:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3162              		.loc 1 1128 0
 3163 1ab0 3034C6E5 		strb	r3, [r6, #1072]
1129:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3164              		.loc 1 1129 0
 3165 1ab4 1C0098E5 		ldr	r0, [r8, #28]
 3166 1ab8 FEFFFFEB 		bl	_txe_mutex_get
1130:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3167              		.loc 1 1130 0
 3168 1abc 14C09DE5 		ldr	ip, [sp, #20]
 3169 1ac0 1C10A0E3 		mov	r1, #28
 3170 1ac4 0A20A0E1 		mov	r2, sl
 3171 1ac8 0930A0E1 		mov	r3, r9
 3172 1acc 0800A0E1 		mov	r0, r8
 3173 1ad0 0070A0E3 		mov	r7, #0
 3174              	.LVL270:
 3175 1ad4 00C08DE5 		str	ip, [sp, #0]
 3176 1ad8 04708DE5 		str	r7, [sp, #4]
 3177 1adc FEFFFFEB 		bl	cmdSet
1131:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3178              		.loc 1 1131 0
 3179 1ae0 1C0098E5 		ldr	r0, [r8, #28]
 3180 1ae4 0EFFFFEA 		b	.L251
 3181              	.LVL271:
 3182              	.L179:
1238:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3183              		.loc 1 1238 0
 3184 1ae8 68419FE5 		ldr	r4, .L262+56
 3185 1aec 0010E0E3 		mvn	r1, #0
 3186 1af0 1C0094E5 		ldr	r0, [r4, #28]
 3187 1af4 FEFFFFEB 		bl	_txe_mutex_get
 3188              	.LVL272:
1240:../uvc.c      **** 							  if(Data0&0x80){
 3189              		.loc 1 1240 0
 3190 1af8 14109DE5 		ldr	r1, [sp, #20]
1245:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3191              		.loc 1 1245 0
 3192 1afc 00C0A0E3 		mov	ip, #0
1240:../uvc.c      **** 							  if(Data0&0x80){
 3193              		.loc 1 1240 0
 3194 1b00 800011E3 		tst	r1, #128
1241:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3195              		.loc 1 1241 0
 3196 1b04 80704112 		subne	r7, r1, #128
 3197              	.LVL273:
1243:../uvc.c      **** 								  Data0 = ~Data0;
 3198              		.loc 1 1243 0
 3199 1b08 0170E001 		mvneq	r7, r1
 3200 1b0c FF8007E2 		and	r8, r7, #255
 3201              	.LVL274:
1245:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3202              		.loc 1 1245 0
 3203 1b10 0110A0E3 		mov	r1, #1
 3204 1b14 0B20A0E1 		mov	r2, fp
 3205 1b18 0930A0E1 		mov	r3, r9
 3206 1b1c 34019FE5 		ldr	r0, .L262+56
 3207 1b20 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3208 1b24 FEFFFFEB 		bl	cmdSet
1246:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3209              		.loc 1 1246 0
 3210 1b28 1C0094E5 		ldr	r0, [r4, #28]
 3211 1b2c FEFFFFEB 		bl	_txe_mutex_put
1249:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3212              		.loc 1 1249 0
 3213 1b30 0170A0E3 		mov	r7, #1
1252:../uvc.c      **** 							 break;
 3214              		.loc 1 1252 0
 3215 1b34 FFC0A0E3 		mov	ip, #255
1248:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3216              		.loc 1 1248 0
 3217 1b38 A581C6E5 		strb	r8, [r6, #421]
1249:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3218              		.loc 1 1249 0
 3219 1b3c A871C6E5 		strb	r7, [r6, #424]
 3220 1b40 14809DE5 		ldr	r8, [sp, #20]
 3221              	.LVL275:
 3222 1b44 18709DE5 		ldr	r7, [sp, #24]
1252:../uvc.c      **** 							 break;
 3223              		.loc 1 1252 0
 3224 1b48 0C40A0E1 		mov	r4, ip
 3225 1b4c B3FCFFEA 		b	.L139
 3226              	.LVL276:
 3227              	.L178:
1359:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3228              		.loc 1 1359 0
 3229 1b50 0C219FE5 		ldr	r2, .L262+68
 3230              	.LVL277:
1349:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3231              		.loc 1 1349 0
 3232 1b54 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3233              	.LVL278:
1359:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3234              		.loc 1 1359 0
 3235 1b58 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 3236 1b5c 03C0A0E1 		mov	ip, r3
1350:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3237              		.loc 1 1350 0
 3238 1b60 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1351:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3239              		.loc 1 1351 0
 3240 1b64 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1359:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3241              		.loc 1 1359 0
 3242 1b68 010052E3 		cmp	r2, #1
1357:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3243              		.loc 1 1357 0
 3244 1b6c 0100A0E3 		mov	r0, #1
1356:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3245              		.loc 1 1356 0
 3246 1b70 05C5C6E5 		strb	ip, [r6, #1285]
1349:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3247              		.loc 1 1349 0
 3248 1b74 FF7007E2 		and	r7, r7, #255
 3249              	.LVL279:
1357:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3250              		.loc 1 1357 0
 3251 1b78 0905C6E5 		strb	r0, [r6, #1289]
1351:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3252              		.loc 1 1351 0
 3253 1b7c FF8008E2 		and	r8, r8, #255
 3254              	.LVL280:
 3255 1b80 0C60A011 		movne	r6, ip
1359:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3256              		.loc 1 1359 0
 3257 1b84 2101000A 		beq	.L259
 3258              	.LVL281:
 3259              	.L226:
1370:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3260              		.loc 1 1370 0
 3261 1b88 C8409FE5 		ldr	r4, .L262+56
 3262 1b8c 0010E0E3 		mvn	r1, #0
 3263 1b90 1C0094E5 		ldr	r0, [r4, #28]
 3264 1b94 FEFFFFEB 		bl	_txe_mutex_get
1371:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3265              		.loc 1 1371 0
 3266 1b98 00C0A0E3 		mov	ip, #0
 3267 1b9c 0C10A0E1 		mov	r1, ip
 3268 1ba0 0720A0E1 		mov	r2, r7
 3269 1ba4 0830A0E1 		mov	r3, r8
 3270 1ba8 0400A0E1 		mov	r0, r4
 3271 1bac 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3272 1bb0 FEFFFFEB 		bl	cmdSet
1372:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3273              		.loc 1 1372 0
 3274 1bb4 1C0094E5 		ldr	r0, [r4, #28]
 3275 1bb8 D9FEFFEA 		b	.L251
 3276              	.LVL282:
 3277              	.L177:
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3278              		.loc 1 1398 0
 3279 1bbc 94809FE5 		ldr	r8, .L262+56
 3280 1bc0 0010E0E3 		mvn	r1, #0
 3281 1bc4 1C0098E5 		ldr	r0, [r8, #28]
 3282 1bc8 FEFFFFEB 		bl	_txe_mutex_get
 3283              	.LVL283:
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3284              		.loc 1 1399 0
 3285 1bcc 14709DE5 		ldr	r7, [sp, #20]
 3286              	.LVL284:
 3287 1bd0 00C0A0E3 		mov	ip, #0
 3288 1bd4 0410A0E1 		mov	r1, r4
 3289 1bd8 0A20A0E1 		mov	r2, sl
 3290 1bdc 0930A0E1 		mov	r3, r9
 3291 1be0 0800A0E1 		mov	r0, r8
 3292 1be4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3293 1be8 FEFFFFEB 		bl	cmdSet
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3294              		.loc 1 1400 0
 3295 1bec 1C0098E5 		ldr	r0, [r8, #28]
 3296 1bf0 FEFFFFEB 		bl	_txe_mutex_put
1402:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3297              		.loc 1 1402 0
 3298 1bf4 14009DE5 		ldr	r0, [sp, #20]
 3299 1bf8 842084E0 		add	r2, r4, r4, asl #1
 3300 1bfc 826186E0 		add	r6, r6, r2, asl #3
1404:../uvc.c      **** 							 break;
 3301              		.loc 1 1404 0
 3302 1c00 FFC0A0E3 		mov	ip, #255
1403:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3303              		.loc 1 1403 0
 3304 1c04 0130A0E3 		mov	r3, #1
1402:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3305              		.loc 1 1402 0
 3306 1c08 8D01C6E5 		strb	r0, [r6, #397]
1403:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3307              		.loc 1 1403 0
 3308 1c0c 9031C6E5 		strb	r3, [r6, #400]
 3309 1c10 0080A0E1 		mov	r8, r0
 3310 1c14 18709DE5 		ldr	r7, [sp, #24]
1404:../uvc.c      **** 							 break;
 3311              		.loc 1 1404 0
 3312 1c18 0C40A0E1 		mov	r4, ip
 3313 1c1c 7FFCFFEA 		b	.L139
 3314              	.L263:
 3315              		.align	2
 3316              	.L262:
 3317 1c20 00000000 		.word	bRequest
 3318 1c24 2C040000 		.word	.LC25
 3319 1c28 5C000000 		.word	.LANCHOR0+92
 3320 1c2c 01000100 		.word	65537
 3321 1c30 FF00FF00 		.word	16711935
 3322 1c34 00000000 		.word	.LANCHOR2
 3323 1c38 DC020000 		.word	.LC18
 3324 1c3c 18030000 		.word	.LC19
 3325 1c40 4C000000 		.word	.LANCHOR0+76
 3326 1c44 A0030000 		.word	.LC22
 3327 1c48 6C030000 		.word	.LC21
 3328 1c4c 40030000 		.word	.LC20
 3329 1c50 FC030000 		.word	.LC24
 3330 1c54 D8030000 		.word	.LC23
 3331 1c58 00000000 		.word	cmdQu
 3332 1c5c 00000000 		.word	.LANCHOR1
 3333 1c60 A4020000 		.word	.LC17
 3334 1c64 00000000 		.word	.LANCHOR0
 3335              	.LVL285:
 3336              	.L181:
1256:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3337              		.loc 1 1256 0
 3338 1c68 18801FE5 		ldr	r8, .L262+56
 3339 1c6c 0010E0E3 		mvn	r1, #0
 3340 1c70 1C0098E5 		ldr	r0, [r8, #28]
 3341 1c74 FEFFFFEB 		bl	_txe_mutex_get
 3342              	.LVL286:
1257:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3343              		.loc 1 1257 0
 3344 1c78 14009DE5 		ldr	r0, [sp, #20]
 3345 1c7c 00C0A0E3 		mov	ip, #0
 3346 1c80 802040E2 		sub	r2, r0, #128
 3347 1c84 FF4002E2 		and	r4, r2, #255
 3348 1c88 0510A0E3 		mov	r1, #5
 3349 1c8c 0A20A0E1 		mov	r2, sl
 3350 1c90 0930A0E1 		mov	r3, r9
 3351 1c94 0800A0E1 		mov	r0, r8
 3352 1c98 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3353 1c9c FEFFFFEB 		bl	cmdSet
 3354              	.LVL287:
1259:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3355              		.loc 1 1259 0
 3356 1ca0 14109DE5 		ldr	r1, [sp, #20]
 3357 1ca4 DC20A0E3 		mov	r2, #220
 3358 1ca8 767041E2 		sub	r7, r1, #118
 3359              	.LVL288:
 3360 1cac FF4007E2 		and	r4, r7, #255
 3361 1cb0 0510A0E3 		mov	r1, #5
 3362 1cb4 0170A0E3 		mov	r7, #1
 3363 1cb8 0930A0E1 		mov	r3, r9
 3364 1cbc 0800A0E1 		mov	r0, r8
 3365 1cc0 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 3366 1cc4 FEFFFFEB 		bl	cmdSet
 3367              	.LVL289:
1261:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3368              		.loc 1 1261 0
 3369 1cc8 14309DE5 		ldr	r3, [sp, #20]
 3370 1ccc 0510A0E3 		mov	r1, #5
 3371 1cd0 7E0083E2 		add	r0, r3, #126
 3372 1cd4 FFC000E2 		and	ip, r0, #255
 3373 1cd8 DE20A0E3 		mov	r2, #222
 3374 1cdc 0930A0E1 		mov	r3, r9
 3375 1ce0 0800A0E1 		mov	r0, r8
 3376 1ce4 0240A0E3 		mov	r4, #2
 3377 1ce8 00C08DE5 		str	ip, [sp, #0]
 3378 1cec 04408DE5 		str	r4, [sp, #4]
 3379 1cf0 FEFFFFEB 		bl	cmdSet
 3380              	.LVL290:
1263:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3381              		.loc 1 1263 0
 3382 1cf4 14209DE5 		ldr	r2, [sp, #20]
 3383 1cf8 0930A0E1 		mov	r3, r9
 3384 1cfc 721082E2 		add	r1, r2, #114
 3385 1d00 FFC001E2 		and	ip, r1, #255
 3386 1d04 E020A0E3 		mov	r2, #224
 3387 1d08 0510A0E3 		mov	r1, #5
 3388 1d0c 0800A0E1 		mov	r0, r8
 3389 1d10 0340A0E3 		mov	r4, #3
 3390 1d14 00C08DE5 		str	ip, [sp, #0]
 3391 1d18 04408DE5 		str	r4, [sp, #4]
 3392 1d1c FEFFFFEB 		bl	cmdSet
 3393              	.LVL291:
1265:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3394              		.loc 1 1265 0
 3395 1d20 14309DE5 		ldr	r3, [sp, #20]
 3396 1d24 0510A0E3 		mov	r1, #5
 3397 1d28 6F0043E2 		sub	r0, r3, #111
 3398 1d2c FFC000E2 		and	ip, r0, #255
 3399 1d30 DD20A0E3 		mov	r2, #221
 3400 1d34 0930A0E1 		mov	r3, r9
 3401 1d38 0800A0E1 		mov	r0, r8
 3402 1d3c 0440A0E3 		mov	r4, #4
 3403 1d40 00C08DE5 		str	ip, [sp, #0]
 3404 1d44 04408DE5 		str	r4, [sp, #4]
 3405 1d48 FEFFFFEB 		bl	cmdSet
 3406              	.LVL292:
1267:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3407              		.loc 1 1267 0
 3408 1d4c F0201FE5 		ldr	r2, .L262+68
 3409 1d50 05E0A0E3 		mov	lr, #5
 3410 1d54 5C10D2E5 		ldrb	r1, [r2, #92]	@ zero_extendqisi2
 3411 1d58 0930A0E1 		mov	r3, r9
 3412 1d5c 7FC081E2 		add	ip, r1, #127
 3413 1d60 FF400CE2 		and	r4, ip, #255
 3414 1d64 0B20A0E1 		mov	r2, fp
 3415 1d68 0E10A0E1 		mov	r1, lr
 3416 1d6c 0800A0E1 		mov	r0, r8
 3417 1d70 10408DE8 		stmia	sp, {r4, lr}	@ phole stm
 3418 1d74 FEFFFFEB 		bl	cmdSet
1268:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3419              		.loc 1 1268 0
 3420 1d78 1C0098E5 		ldr	r0, [r8, #28]
 3421 1d7c FEFFFFEB 		bl	_txe_mutex_put
1270:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3422              		.loc 1 1270 0
 3423 1d80 24311FE5 		ldr	r3, .L262+68
1272:../uvc.c      **** 							 break;
 3424              		.loc 1 1272 0
 3425 1d84 FFC0A0E3 		mov	ip, #255
1270:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3426              		.loc 1 1270 0
 3427 1d88 5C00D3E5 		ldrb	r0, [r3, #92]	@ zero_extendqisi2
1271:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3428              		.loc 1 1271 0
 3429 1d8c 0872C6E5 		strb	r7, [r6, #520]
1270:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3430              		.loc 1 1270 0
 3431 1d90 802040E2 		sub	r2, r0, #128
 3432 1d94 0522C6E5 		strb	r2, [r6, #517]
1271:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3433              		.loc 1 1271 0
 3434 1d98 14809DE5 		ldr	r8, [sp, #20]
 3435 1d9c 18709DE5 		ldr	r7, [sp, #24]
1272:../uvc.c      **** 							 break;
 3436              		.loc 1 1272 0
 3437 1da0 0C40A0E1 		mov	r4, ip
 3438 1da4 1DFCFFEA 		b	.L139
 3439              	.LVL293:
 3440              	.L180:
1303:../uvc.c      **** 							 Data0 = Data0 - 1;
 3441              		.loc 1 1303 0
 3442 1da8 011043E2 		sub	r1, r3, #1
 3443 1dac 0320A0E1 		mov	r2, r3
 3444              	.LVL294:
1304:../uvc.c      **** 							 is60Hz = Data0;
 3445              		.loc 1 1304 0
 3446 1db0 54011FE5 		ldr	r0, .L262+68
1303:../uvc.c      **** 							 Data0 = Data0 - 1;
 3447              		.loc 1 1303 0
 3448 1db4 FF3001E2 		and	r3, r1, #255
 3449              	.LVL295:
1310:../uvc.c      **** 							 else if(Data0 >2)
 3450              		.loc 1 1310 0
 3451 1db8 020053E3 		cmp	r3, #2
1302:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3452              		.loc 1 1302 0
 3453 1dbc ED21C6E5 		strb	r2, [r6, #493]
1313:../uvc.c      **** 								 is60Hz = CyTrue;
 3454              		.loc 1 1313 0
 3455 1dc0 0120A083 		movhi	r2, #1
1304:../uvc.c      **** 							 is60Hz = Data0;
 3456              		.loc 1 1304 0
 3457 1dc4 583080E5 		str	r3, [r0, #88]
 3458              	.LVL296:
1313:../uvc.c      **** 								 is60Hz = CyTrue;
 3459              		.loc 1 1313 0
 3460 1dc8 58208085 		strhi	r2, [r0, #88]
1316:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3461              		.loc 1 1316 0
 3462 1dcc 70011FE5 		ldr	r0, .L262+68
 3463 1dd0 28E090E5 		ldr	lr, [r0, #40]
 3464 1dd4 01005EE3 		cmp	lr, #1
 3465 1dd8 2600000A 		beq	.L260
 3466              	.LVL297:
 3467              	.L212:
1346:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3468              		.loc 1 1346 0
 3469 1ddc 0140A0E3 		mov	r4, #1
1347:../uvc.c      **** 							 break;
 3470              		.loc 1 1347 0
 3471 1de0 FFC0A0E3 		mov	ip, #255
1346:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3472              		.loc 1 1346 0
 3473 1de4 F041C6E5 		strb	r4, [r6, #496]
 3474 1de8 14809DE5 		ldr	r8, [sp, #20]
 3475 1dec 18709DE5 		ldr	r7, [sp, #24]
1347:../uvc.c      **** 							 break;
 3476              		.loc 1 1347 0
 3477 1df0 0C40A0E1 		mov	r4, ip
 3478 1df4 09FCFFEA 		b	.L139
 3479              	.LVL298:
 3480              	.L176:
1407:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3481              		.loc 1 1407 0
 3482 1df8 0400A0E3 		mov	r0, #4
 3483              	.LVL299:
 3484 1dfc B4111FE5 		ldr	r1, .L262+48
 3485 1e00 FEFFFFEB 		bl	CyU3PDebugPrint
 3486              	.LVL300:
 3487 1e04 FFC0A0E3 		mov	ip, #255
 3488 1e08 0C40A0E1 		mov	r4, ip
 3489 1e0c 0C70A0E1 		mov	r7, ip
 3490              	.LVL301:
 3491 1e10 0C80A0E1 		mov	r8, ip
 3492 1e14 01FCFFEA 		b	.L139
 3493              	.LVL302:
 3494              	.L257:
 804:../uvc.c      **** 						if(sendData >= 3){
 3495              		.loc 1 804 0
 3496 1e18 020054E3 		cmp	r4, #2
 3497 1e1c A000008A 		bhi	.L261
 3498              	.LVL303:
 3499              	.L156:
 809:../uvc.c      **** 						sendData += 4;
 3500              		.loc 1 809 0
 3501 1e20 042084E2 		add	r2, r4, #4
 3502 1e24 FF4002E2 		and	r4, r2, #255
 3503              	.LVL304:
 3504 1e28 35FDFFEA 		b	.L155
 3505              	.LVL305:
 3506              	.L228:
1389:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3507              		.loc 1 1389 0
 3508 1e2c DC411FE5 		ldr	r4, .L262+56
 3509 1e30 0010E0E3 		mvn	r1, #0
 3510 1e34 1C0094E5 		ldr	r0, [r4, #28]
 3511 1e38 FEFFFFEB 		bl	_txe_mutex_get
 3512              	.LVL306:
1390:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3513              		.loc 1 1390 0
 3514 1e3c 0730A0E1 		mov	r3, r7
 3515 1e40 14709DE5 		ldr	r7, [sp, #20]
 3516              	.LVL307:
 3517 1e44 0820A0E1 		mov	r2, r8
 3518 1e48 0710A0E3 		mov	r1, #7
 3519 1e4c 0400A0E1 		mov	r0, r4
 3520 1e50 00708DE5 		str	r7, [sp, #0]
 3521 1e54 04708DE5 		str	r7, [sp, #4]
 3522 1e58 FEFFFFEB 		bl	cmdSet
 3523              	.LVL308:
1391:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3524              		.loc 1 1391 0
 3525 1e5c 1C0094E5 		ldr	r0, [r4, #28]
 3526 1e60 FEFFFFEB 		bl	_txe_mutex_put
 3527 1e64 FFC0A0E3 		mov	ip, #255
 3528 1e68 18709DE5 		ldr	r7, [sp, #24]
 3529 1e6c 0C40A0E1 		mov	r4, ip
 3530 1e70 14809DE5 		ldr	r8, [sp, #20]
 3531              	.LVL309:
 3532 1e74 E9FBFFEA 		b	.L139
 3533              	.LVL310:
 3534              	.L260:
1319:../uvc.c      **** 			                       switch (setRes)
 3535              		.loc 1 1319 0
 3536 1e78 7D40D0E5 		ldrb	r4, [r0, #125]	@ zero_extendqisi2
 3537 1e7c 017044E2 		sub	r7, r4, #1
 3538              	.LVL311:
 3539 1e80 030057E3 		cmp	r7, #3
 3540 1e84 07F19F97 		ldrls	pc, [pc, r7, asl #2]
 3541 1e88 D3FFFFEA 		b	.L212
 3542              	.L217:
 3543 1e8c BC1F0000 		.word	.L213
 3544 1e90 681F0000 		.word	.L214
 3545 1e94 001F0000 		.word	.L215
 3546 1e98 9C1E0000 		.word	.L216
 3547              	.L216:
1337:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 3548              		.loc 1 1337 0
 3549 1e9c 40121FE5 		ldr	r1, .L262+68
 3550 1ea0 0100A0E3 		mov	r0, #1
 3551 1ea4 58E091E5 		ldr	lr, [r1, #88]
 3552 1ea8 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 3553 1eac 00005EE3 		cmp	lr, #0
 3554 1eb0 F4E0A003 		moveq	lr, #244
 3555 1eb4 74E0A013 		movne	lr, #116
 3556 1eb8 03208EE1 		orr	r2, lr, r3
 3557 1ebc 3010A0E3 		mov	r1, #48
 3558 1ec0 5230A0E3 		mov	r3, #82
 3559 1ec4 FEFFFFEB 		bl	SensorSetIrisControl
1338:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3560              		.loc 1 1338 0
 3561 1ec8 7D0FA0E3 		mov	r0, #500
 3562 1ecc FEFFFFEB 		bl	_tx_thread_sleep
1339:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3563              		.loc 1 1339 0
 3564 1ed0 74021FE5 		ldr	r0, .L262+68
 3565 1ed4 88121FE5 		ldr	r1, .L262+52
 3566 1ed8 587090E5 		ldr	r7, [r0, #88]
 3567 1edc 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3568 1ee0 000057E3 		cmp	r7, #0
 3569 1ee4 F470A003 		moveq	r7, #244
 3570 1ee8 7470A013 		movne	r7, #116
 3571 1eec 583090E5 		ldr	r3, [r0, #88]
 3572 1ef0 022087E1 		orr	r2, r7, r2
 3573 1ef4 0400A0E3 		mov	r0, #4
 3574 1ef8 FEFFFFEB 		bl	CyU3PDebugPrint
 3575 1efc B6FFFFEA 		b	.L212
 3576              	.L215:
1332:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3577              		.loc 1 1332 0
 3578 1f00 A4821FE5 		ldr	r8, .L262+68
 3579 1f04 3010A0E3 		mov	r1, #48
 3580 1f08 584098E5 		ldr	r4, [r8, #88]
 3581 1f0c 8CC4D6E5 		ldrb	ip, [r6, #1164]	@ zero_extendqisi2
 3582 1f10 000054E3 		cmp	r4, #0
 3583 1f14 C440A003 		moveq	r4, #196
 3584 1f18 4440A013 		movne	r4, #68
 3585 1f1c 0C2084E1 		orr	r2, r4, ip
 3586 1f20 5230A0E3 		mov	r3, #82
 3587 1f24 0100A0E3 		mov	r0, #1
 3588 1f28 FEFFFFEB 		bl	SensorSetIrisControl
1333:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3589              		.loc 1 1333 0
 3590 1f2c 7D0FA0E3 		mov	r0, #500
 3591 1f30 FEFFFFEB 		bl	_tx_thread_sleep
1334:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3592              		.loc 1 1334 0
 3593 1f34 D8121FE5 		ldr	r1, .L262+68
 3594 1f38 DC321FE5 		ldr	r3, .L262+68
 3595 1f3c 587091E5 		ldr	r7, [r1, #88]
 3596 1f40 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3597 1f44 000057E3 		cmp	r7, #0
 3598 1f48 C470A003 		moveq	r7, #196
 3599 1f4c 4470A013 		movne	r7, #68
 3600 1f50 583093E5 		ldr	r3, [r3, #88]
 3601 1f54 08131FE5 		ldr	r1, .L262+52
 3602 1f58 022087E1 		orr	r2, r7, r2
 3603 1f5c 0400A0E3 		mov	r0, #4
 3604 1f60 FEFFFFEB 		bl	CyU3PDebugPrint
1335:../uvc.c      **** 			                         		break;
 3605              		.loc 1 1335 0
 3606 1f64 9CFFFFEA 		b	.L212
 3607              	.L214:
1327:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3608              		.loc 1 1327 0
 3609 1f68 0CE31FE5 		ldr	lr, .L262+68
 3610 1f6c 3010A0E3 		mov	r1, #48
 3611 1f70 58209EE5 		ldr	r2, [lr, #88]
 3612 1f74 5230A0E3 		mov	r3, #82
 3613 1f78 000052E3 		cmp	r2, #0
 3614 1f7c D420A003 		moveq	r2, #212
 3615 1f80 5420A013 		movne	r2, #84
 3616 1f84 0100A0E3 		mov	r0, #1
 3617 1f88 FEFFFFEB 		bl	SensorSetIrisControl
1328:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3618              		.loc 1 1328 0
 3619 1f8c 7D0FA0E3 		mov	r0, #500
 3620 1f90 FEFFFFEB 		bl	_tx_thread_sleep
1329:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3621              		.loc 1 1329 0
 3622 1f94 38031FE5 		ldr	r0, .L262+68
 3623 1f98 4C131FE5 		ldr	r1, .L262+52
 3624 1f9c 582090E5 		ldr	r2, [r0, #88]
 3625 1fa0 583090E5 		ldr	r3, [r0, #88]
 3626 1fa4 000052E3 		cmp	r2, #0
 3627 1fa8 D420A003 		moveq	r2, #212
 3628 1fac 5420A013 		movne	r2, #84
 3629 1fb0 0400A0E3 		mov	r0, #4
 3630 1fb4 FEFFFFEB 		bl	CyU3PDebugPrint
1330:../uvc.c      **** 			                         		break;
 3631              		.loc 1 1330 0
 3632 1fb8 87FFFFEA 		b	.L212
 3633              	.L213:
1322:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3634              		.loc 1 1322 0
 3635 1fbc 60831FE5 		ldr	r8, .L262+68
 3636 1fc0 3010A0E3 		mov	r1, #48
 3637 1fc4 582098E5 		ldr	r2, [r8, #88]
 3638 1fc8 5230A0E3 		mov	r3, #82
 3639 1fcc 000052E3 		cmp	r2, #0
 3640 1fd0 E420A003 		moveq	r2, #228
 3641 1fd4 6420A013 		movne	r2, #100
 3642 1fd8 0100A0E3 		mov	r0, #1
 3643 1fdc FEFFFFEB 		bl	SensorSetIrisControl
1323:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3644              		.loc 1 1323 0
 3645 1fe0 7D0FA0E3 		mov	r0, #500
 3646 1fe4 FEFFFFEB 		bl	_tx_thread_sleep
1324:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3647              		.loc 1 1324 0
 3648 1fe8 8CC31FE5 		ldr	ip, .L262+68
 3649 1fec A0131FE5 		ldr	r1, .L262+52
 3650 1ff0 58209CE5 		ldr	r2, [ip, #88]
 3651 1ff4 0400A0E3 		mov	r0, #4
 3652 1ff8 000052E3 		cmp	r2, #0
 3653 1ffc 58309CE5 		ldr	r3, [ip, #88]
 3654 2000 E420A003 		moveq	r2, #228
 3655 2004 6420A013 		movne	r2, #100
 3656 2008 FEFFFFEB 		bl	CyU3PDebugPrint
1325:../uvc.c      **** 			                         		break;
 3657              		.loc 1 1325 0
 3658 200c 72FFFFEA 		b	.L212
 3659              	.LVL312:
 3660              	.L259:
1361:../uvc.c      **** 								 if(Data0 < 3){
 3661              		.loc 1 1361 0
 3662 2010 02005CE3 		cmp	ip, #2
1362:../uvc.c      **** 					 				 Data0 += 4;
 3663              		.loc 1 1362 0
 3664 2014 04608C92 		addls	r6, ip, #4
 3665 2018 FF600692 		andls	r6, r6, #255
1361:../uvc.c      **** 								 if(Data0 < 3){
 3666              		.loc 1 1361 0
 3667 201c D9FEFF9A 		bls	.L226
1364:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3668              		.loc 1 1364 0
 3669 2020 0400A0E3 		mov	r0, #4
 3670 2024 CC131FE5 		ldr	r1, .L262+64
 3671 2028 14309DE5 		ldr	r3, [sp, #20]
 3672 202c FEFFFFEB 		bl	CyU3PDebugPrint
 3673              	.LVL313:
1365:../uvc.c      **** 									Data0 = 4; //set to default.
 3674              		.loc 1 1365 0
 3675 2030 0460A0E3 		mov	r6, #4
 3676 2034 D3FEFFEA 		b	.L226
 3677              	.LVL314:
 3678              	.L202:
1107:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3679              		.loc 1 1107 0
 3680 2038 0A20A0E1 		mov	r2, sl
 3681 203c 0730A0E1 		mov	r3, r7
 3682 2040 80C0A0E3 		mov	ip, #128
 3683 2044 00E0A0E3 		mov	lr, #0
 3684 2048 1B10A0E3 		mov	r1, #27
 3685 204c FC031FE5 		ldr	r0, .L262+56
 3686 2050 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3687 2054 FEFFFFEB 		bl	cmdSet
 3688              	.LVL315:
1109:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 3689              		.loc 1 1109 0
 3690 2058 0730A0E1 		mov	r3, r7
 3691 205c 14709DE5 		ldr	r7, [sp, #20]
 3692              	.LVL316:
 3693 2060 01C0A0E3 		mov	ip, #1
 3694 2064 1B10A0E3 		mov	r1, #27
 3695 2068 0820A0E1 		mov	r2, r8
 3696 206c 1C041FE5 		ldr	r0, .L262+56
 3697 2070 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3698 2074 FEFFFFEB 		bl	cmdSet
 3699              	.LVL317:
 3700 2078 E4FDFFEA 		b	.L201
 3701              	.LVL318:
 3702              	.L258:
1082:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3703              		.loc 1 1082 0
 3704 207c 18E09DE5 		ldr	lr, [sp, #24]
 3705 2080 0730A0E1 		mov	r3, r7
 3706 2084 1910A0E3 		mov	r1, #25
 3707 2088 0070A0E3 		mov	r7, #0
 3708              	.LVL319:
 3709 208c 0920A0E1 		mov	r2, r9
 3710 2090 40041FE5 		ldr	r0, .L262+56
 3711 2094 00E08DE5 		str	lr, [sp, #0]
 3712 2098 04708DE5 		str	r7, [sp, #4]
 3713 209c FEFFFFEB 		bl	cmdSet
 3714              	.LVL320:
 3715 20a0 0EFEFFEA 		b	.L200
 3716              	.LVL321:
 3717              	.L261:
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3718              		.loc 1 807 0
 3719 20a4 50641FE5 		ldr	r6, .L262+60
 805:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3720              		.loc 1 805 0
 3721 20a8 0430A0E1 		mov	r3, r4
 3722 20ac 0400A0E3 		mov	r0, #4
 3723 20b0 58141FE5 		ldr	r1, .L262+64
 3724 20b4 FEFFFFEB 		bl	CyU3PDebugPrint
 3725              	.LVL322:
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3726              		.loc 1 807 0
 3727 20b8 0030A0E3 		mov	r3, #0
 806:../uvc.c      **** 							sendData = 0; //set back to default
 3728              		.loc 1 806 0
 3729 20bc 0340A0E1 		mov	r4, r3
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3730              		.loc 1 807 0
 3731 20c0 2D34C6E5 		strb	r3, [r6, #1069]
 3732 20c4 55FFFFEA 		b	.L156
 3733              	.LVL323:
 3734              	.L249:
 3735 20c8 6C041FE5 		ldr	r0, .L262+68
 3736 20cc 7BFCFFEA 		b	.L153
 3737              	.LVL324:
 3738              	.L231:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3739              		.loc 1 734 0
 3740 20d0 0030A0E3 		mov	r3, #0
 3741 20d4 4EFDFFEA 		b	.L243
 3742              	.LVL325:
 3743              	.L229:
 3744 20d8 7C041FE5 		ldr	r0, .L262+68
 3745 20dc 0030A0E3 		mov	r3, #0
 3746 20e0 6FFCFFEA 		b	.L242
 3747              		.cfi_endproc
 3748              	.LFE3:
 3750              		.align	2
 3751              		.global	CTControlHandle
 3753              	CTControlHandle:
 3754              	.LFB4:
1423:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3755              		.loc 1 1423 0
 3756              		.cfi_startproc
 3757              		@ args = 0, pretend = 0, frame = 64
 3758              		@ frame_needed = 0, uses_anonymous_args = 0
 3759              	.LVL326:
 3760 20e4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3761              	.LCFI17:
 3762              		.cfi_def_cfa_offset 36
1442:../uvc.c      ****     reqData = bRequest;
 3763              		.loc 1 1442 0
 3764 20e8 64A99FE5 		ldr	sl, .L349
 3765              		.cfi_offset 14, -4
 3766              		.cfi_offset 11, -8
 3767              		.cfi_offset 10, -12
 3768              		.cfi_offset 9, -16
 3769              		.cfi_offset 8, -20
 3770              		.cfi_offset 7, -24
 3771              		.cfi_offset 6, -28
 3772              		.cfi_offset 5, -32
 3773              		.cfi_offset 4, -36
1434:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3774              		.loc 1 1434 0
 3775 20ec 64899FE5 		ldr	r8, .L349+4
1442:../uvc.c      ****     reqData = bRequest;
 3776              		.loc 1 1442 0
 3777 20f0 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1434:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3778              		.loc 1 1434 0
 3779 20f4 8090A0E1 		mov	r9, r0, asl #1
 3780 20f8 002089E0 		add	r2, r9, r0
 3781 20fc 822188E0 		add	r2, r8, r2, asl #3
1444:../uvc.c      ****     switch (bRequest)
 3782              		.loc 1 1444 0
 3783 2100 830055E3 		cmp	r5, #131
1423:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3784              		.loc 1 1423 0
 3785 2104 5CD04DE2 		sub	sp, sp, #92
 3786              	.LCFI18:
 3787              		.cfi_def_cfa_offset 128
1423:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3788              		.loc 1 1423 0
 3789 2108 0060A0E1 		mov	r6, r0
1434:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3790              		.loc 1 1434 0
 3791 210c 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 3792              	.LVL327:
1435:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3793              		.loc 1 1435 0
 3794 2110 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 3795              	.LVL328:
1437:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3796              		.loc 1 1437 0
 3797 2114 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 3798              	.LVL329:
1444:../uvc.c      ****     switch (bRequest)
 3799              		.loc 1 1444 0
 3800 2118 7600000A 		beq	.L269
 3801 211c 2100009A 		bls	.L344
 3802 2120 850055E3 		cmp	r5, #133
 3803 2124 5900000A 		beq	.L271
 3804 2128 4E00003A 		bcc	.L270
 3805 212c 860055E3 		cmp	r5, #134
 3806 2130 8000000A 		beq	.L272
 3807 2134 870055E3 		cmp	r5, #135
 3808 2138 7600000A 		beq	.L345
 3809              	.L265:
1651:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3810              		.loc 1 1651 0
 3811 213c 0000A0E3 		mov	r0, #0
 3812              	.LVL330:
 3813 2140 0110A0E3 		mov	r1, #1
 3814 2144 0020A0E1 		mov	r2, r0
 3815 2148 FEFFFFEB 		bl	CyU3PUsbStall
 3816              	.LVL331:
 3817 214c 08499FE5 		ldr	r4, .L349+8
1652:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3818              		.loc 1 1652 0
 3819 2150 0620A0E1 		mov	r2, r6
 3820 2154 0400A0E3 		mov	r0, #4
 3821 2158 00199FE5 		ldr	r1, .L349+12
 3822 215c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3823 2160 FEFFFFEB 		bl	CyU3PDebugPrint
1653:../uvc.c      **** 			  break;
 3824              		.loc 1 1653 0
 3825 2164 FFC0A0E3 		mov	ip, #255
 3826 2168 0C60A0E1 		mov	r6, ip
 3827 216c 0C80A0E1 		mov	r8, ip
 3828              	.LVL332:
 3829              	.L275:
1657:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3830              		.loc 1 1657 0
 3831 2170 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3832 2174 08C08DE5 		str	ip, [sp, #8]
 3833 2178 E4189FE5 		ldr	r1, .L349+16
 3834 217c FFC0A0E3 		mov	ip, #255
 3835 2180 0520A0E1 		mov	r2, r5
 3836 2184 0830A0E1 		mov	r3, r8
 3837 2188 0400A0E3 		mov	r0, #4
 3838 218c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3839 2190 0CC08DE5 		str	ip, [sp, #12]
 3840 2194 10E08DE5 		str	lr, [sp, #16]
 3841 2198 14708DE5 		str	r7, [sp, #20]
 3842 219c FEFFFFEB 		bl	CyU3PDebugPrint
1658:../uvc.c      **** }
 3843              		.loc 1 1658 0
 3844 21a0 5CD08DE2 		add	sp, sp, #92
 3845 21a4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3846              	.LVL333:
 3847              	.L344:
1444:../uvc.c      ****     switch (bRequest)
 3848              		.loc 1 1444 0
 3849 21a8 810055E3 		cmp	r5, #129
 3850 21ac 4200000A 		beq	.L267
 3851 21b0 1100009A 		bls	.L346
1473:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3852              		.loc 1 1473 0
 3853 21b4 A0489FE5 		ldr	r4, .L349+8
 3854 21b8 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1474:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3855              		.loc 1 1474 0
 3856 21bc 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1475:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3857              		.loc 1 1475 0
 3858 21c0 0A0050E3 		cmp	r0, #10
1473:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3859              		.loc 1 1473 0
 3860 21c4 5C10C4E5 		strb	r1, [r4, #92]
1474:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3861              		.loc 1 1474 0
 3862 21c8 5D60C4E5 		strb	r6, [r4, #93]
1475:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3863              		.loc 1 1475 0
 3864 21cc 2C00000A 		beq	.L343
 3865              	.LVL334:
 3866              	.L282:
1509:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3867              		.loc 1 1509 0
 3868 21d0 00E0A0E3 		mov	lr, #0
 3869 21d4 5EE0C4E5 		strb	lr, [r4, #94]
 3870              	.L283:
1510:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3871              		.loc 1 1510 0
 3872 21d8 0030A0E3 		mov	r3, #0
1511:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3873              		.loc 1 1511 0
 3874 21dc 0700A0E1 		mov	r0, r7
 3875              	.LVL335:
 3876 21e0 80189FE5 		ldr	r1, .L349+20
1513:../uvc.c      **** 			  break;
 3877              		.loc 1 1513 0
 3878 21e4 FF60A0E3 		mov	r6, #255
1510:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3879              		.loc 1 1510 0
 3880 21e8 5F30C4E5 		strb	r3, [r4, #95]
1513:../uvc.c      **** 			  break;
 3881              		.loc 1 1513 0
 3882 21ec 0680A0E1 		mov	r8, r6
1511:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3883              		.loc 1 1511 0
 3884 21f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3885              	.LVL336:
 3886 21f4 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1513:../uvc.c      **** 			  break;
 3887              		.loc 1 1513 0
 3888 21f8 DCFFFFEA 		b	.L275
 3889              	.LVL337:
 3890              	.L346:
1444:../uvc.c      ****     switch (bRequest)
 3891              		.loc 1 1444 0
 3892 21fc 010055E3 		cmp	r5, #1
 3893 2200 CDFFFF1A 		bne	.L265
1515:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3894              		.loc 1 1515 0
 3895 2204 50489FE5 		ldr	r4, .L349+8
 3896 2208 56208DE2 		add	r2, sp, #86
 3897 220c 2000A0E3 		mov	r0, #32
 3898              	.LVL338:
 3899 2210 5C1084E2 		add	r1, r4, #92
 3900 2214 2C308DE5 		str	r3, [sp, #44]
 3901 2218 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3902              	.LVL339:
1517:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3903              		.loc 1 1517 0
 3904 221c 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1518:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3905              		.loc 1 1518 0
 3906 2220 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1521:../uvc.c      **** 			  switch(CtrlID)
 3907              		.loc 1 1521 0
 3908 2224 012046E2 		sub	r2, r6, #1
1517:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3909              		.loc 1 1517 0
 3910 2228 30008DE5 		str	r0, [sp, #48]
 3911              	.LVL340:
1518:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3912              		.loc 1 1518 0
 3913 222c 34C08DE5 		str	ip, [sp, #52]
 3914              	.LVL341:
1521:../uvc.c      **** 			  switch(CtrlID)
 3915              		.loc 1 1521 0
 3916 2230 2C309DE5 		ldr	r3, [sp, #44]
 3917 2234 090052E3 		cmp	r2, #9
 3918 2238 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3919 223c 550100EA 		b	.L284
 3920              	.L289:
 3921 2240 54270000 		.word	.L285
 3922 2244 98270000 		.word	.L284
 3923 2248 64240000 		.word	.L286
 3924 224c 98270000 		.word	.L284
 3925 2250 98270000 		.word	.L284
 3926 2254 98270000 		.word	.L284
 3927 2258 E0230000 		.word	.L287
 3928 225c 98270000 		.word	.L284
 3929 2260 98270000 		.word	.L284
 3930 2264 64230000 		.word	.L288
 3931              	.LVL342:
 3932              	.L270:
1491:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3933              		.loc 1 1491 0
 3934 2268 EC479FE5 		ldr	r4, .L349+8
 3935 226c 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1492:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3936              		.loc 1 1492 0
 3937 2270 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1493:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3938              		.loc 1 1493 0
 3939 2274 0A0050E3 		cmp	r0, #10
1491:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3940              		.loc 1 1491 0
 3941 2278 5C80C4E5 		strb	r8, [r4, #92]
1492:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3942              		.loc 1 1492 0
 3943 227c 5D20C4E5 		strb	r2, [r4, #93]
1493:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3944              		.loc 1 1493 0
 3945 2280 D2FFFF1A 		bne	.L282
 3946              	.LVL343:
 3947              	.L343:
1508:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3948              		.loc 1 1508 0 discriminator 1
 3949 2284 0110A0E3 		mov	r1, #1
 3950 2288 5E10C4E5 		strb	r1, [r4, #94]
 3951 228c D1FFFFEA 		b	.L283
 3952              	.LVL344:
 3953              	.L271:
1448:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3954              		.loc 1 1448 0
 3955 2290 C4479FE5 		ldr	r4, .L349+8
1449:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3956              		.loc 1 1449 0
 3957 2294 0030A0E3 		mov	r3, #0
 3958              	.LVL345:
1450:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3959              		.loc 1 1450 0
 3960 2298 0200A0E3 		mov	r0, #2
 3961              	.LVL346:
 3962 229c 5C1084E2 		add	r1, r4, #92
1452:../uvc.c      **** 			  break;
 3963              		.loc 1 1452 0
 3964 22a0 FF60A0E3 		mov	r6, #255
1448:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3965              		.loc 1 1448 0
 3966 22a4 5C70C4E5 		strb	r7, [r4, #92]
1449:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3967              		.loc 1 1449 0
 3968 22a8 5D30C4E5 		strb	r3, [r4, #93]
1452:../uvc.c      **** 			  break;
 3969              		.loc 1 1452 0
 3970 22ac 0680A0E1 		mov	r8, r6
1450:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3971              		.loc 1 1450 0
 3972 22b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3973              	.LVL347:
 3974 22b4 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1452:../uvc.c      **** 			  break;
 3975              		.loc 1 1452 0
 3976 22b8 ACFFFFEA 		b	.L275
 3977              	.LVL348:
 3978              	.L267:
1458:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3979              		.loc 1 1458 0
 3980 22bc 98479FE5 		ldr	r4, .L349+8
 3981 22c0 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1459:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3982              		.loc 1 1459 0
 3983 22c4 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1460:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3984              		.loc 1 1460 0
 3985 22c8 0080A0E3 		mov	r8, #0
1466:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3986              		.loc 1 1466 0
 3987 22cc 0700A0E1 		mov	r0, r7
 3988              	.LVL349:
 3989 22d0 5C1084E2 		add	r1, r4, #92
1471:../uvc.c      **** 			  break;
 3990              		.loc 1 1471 0
 3991 22d4 FF60A0E3 		mov	r6, #255
1459:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3992              		.loc 1 1459 0
 3993 22d8 5DC0C4E5 		strb	ip, [r4, #93]
1460:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3994              		.loc 1 1460 0
 3995 22dc 5E80C4E5 		strb	r8, [r4, #94]
1461:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3996              		.loc 1 1461 0
 3997 22e0 5F80C4E5 		strb	r8, [r4, #95]
 3998              	.LVL350:
1458:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3999              		.loc 1 1458 0
 4000 22e4 5CA0C4E5 		strb	sl, [r4, #92]
1471:../uvc.c      **** 			  break;
 4001              		.loc 1 1471 0
 4002 22e8 0680A0E1 		mov	r8, r6
1466:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4003              		.loc 1 1466 0
 4004 22ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4005              	.LVL351:
 4006 22f0 0AC0A0E1 		mov	ip, sl
1471:../uvc.c      **** 			  break;
 4007              		.loc 1 1471 0
 4008 22f4 9DFFFFEA 		b	.L275
 4009              	.LVL352:
 4010              	.L269:
1482:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4011              		.loc 1 1482 0
 4012 22f8 5C479FE5 		ldr	r4, .L349+8
 4013 22fc 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4014              	.LVL353:
1483:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4015              		.loc 1 1483 0
 4016 2300 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1484:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4017              		.loc 1 1484 0
 4018 2304 0A0050E3 		cmp	r0, #10
1482:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4019              		.loc 1 1482 0
 4020 2308 5C30C4E5 		strb	r3, [r4, #92]
1483:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4021              		.loc 1 1483 0
 4022 230c 5DE0C4E5 		strb	lr, [r4, #93]
1484:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4023              		.loc 1 1484 0
 4024 2310 AEFFFF1A 		bne	.L282
 4025 2314 DAFFFFEA 		b	.L343
 4026              	.LVL354:
 4027              	.L345:
1506:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4028              		.loc 1 1506 0
 4029 2318 3C479FE5 		ldr	r4, .L349+8
 4030 231c 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1507:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4031              		.loc 1 1507 0
 4032 2320 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1508:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4033              		.loc 1 1508 0
 4034 2324 0A0050E3 		cmp	r0, #10
1506:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4035              		.loc 1 1506 0
 4036 2328 5C60C4E5 		strb	r6, [r4, #92]
1507:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4037              		.loc 1 1507 0
 4038 232c 5DC0C4E5 		strb	ip, [r4, #93]
1508:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4039              		.loc 1 1508 0
 4040 2330 A6FFFF1A 		bne	.L282
 4041 2334 D2FFFFEA 		b	.L343
 4042              	.L272:
1500:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4043              		.loc 1 1500 0
 4044 2338 1C479FE5 		ldr	r4, .L349+8
 4045 233c 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4046              	.LVL355:
 4047 2340 0410A0E1 		mov	r1, r4
 4048 2344 5C00E1E5 		strb	r0, [r1, #92]!
1504:../uvc.c      **** 			  break;
 4049              		.loc 1 1504 0
 4050 2348 FF60A0E3 		mov	r6, #255
1501:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4051              		.loc 1 1501 0
 4052 234c 0100A0E3 		mov	r0, #1
 4053 2350 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4054              	.LVL356:
1504:../uvc.c      **** 			  break;
 4055              		.loc 1 1504 0
 4056 2354 0680A0E1 		mov	r8, r6
1501:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4057              		.loc 1 1501 0
 4058 2358 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1504:../uvc.c      **** 			  break;
 4059              		.loc 1 1504 0
 4060 235c 0170A0E3 		mov	r7, #1
 4061 2360 82FFFFEA 		b	.L275
 4062              	.LVL357:
 4063              	.L288:
1630:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4064              		.loc 1 1630 0
 4065 2364 00679FE5 		ldr	r6, .L349+24
 4066 2368 0010E0E3 		mvn	r1, #0
 4067 236c 1C0096E5 		ldr	r0, [r6, #28]
 4068 2370 2C308DE5 		str	r3, [sp, #44]
 4069 2374 FEFFFFEB 		bl	_txe_mutex_get
1631:../uvc.c      **** 					  if(getData == 1)
 4070              		.loc 1 1631 0
 4071 2378 30E09DE5 		ldr	lr, [sp, #48]
 4072 237c 2C309DE5 		ldr	r3, [sp, #44]
 4073 2380 01005EE3 		cmp	lr, #1
 4074 2384 AA01000A 		beq	.L347
1633:../uvc.c      **** 					  else if(getData == 0xff)
 4075              		.loc 1 1633 0
 4076 2388 FF005EE3 		cmp	lr, #255
 4077 238c 9F01000A 		beq	.L348
1636:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4078              		.loc 1 1636 0
 4079 2390 0080A0E3 		mov	r8, #0
 4080 2394 0600A0E1 		mov	r0, r6
 4081 2398 2310A0E3 		mov	r1, #35
 4082 239c 0B20A0E1 		mov	r2, fp
 4083 23a0 00808DE5 		str	r8, [sp, #0]
 4084 23a4 04808DE5 		str	r8, [sp, #4]
 4085 23a8 FEFFFFEB 		bl	cmdSet
 4086              	.L341:
1639:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4087              		.loc 1 1639 0
 4088 23ac 1C0096E5 		ldr	r0, [r6, #28]
 4089 23b0 FEFFFFEB 		bl	_txe_mutex_put
1641:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4090              		.loc 1 1641 0
 4091 23b4 30809DE5 		ldr	r8, [sp, #48]
 4092 23b8 34609DE5 		ldr	r6, [sp, #52]
 4093 23bc 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4094 23c0 0400A0E3 		mov	r0, #4
 4095 23c4 A4169FE5 		ldr	r1, .L349+28
 4096 23c8 0820A0E1 		mov	r2, r8
 4097 23cc 0630A0E1 		mov	r3, r6
 4098 23d0 00C08DE5 		str	ip, [sp, #0]
 4099 23d4 FEFFFFEB 		bl	CyU3PDebugPrint
1642:../uvc.c      **** 					  break;
 4100              		.loc 1 1642 0
 4101 23d8 FFC0A0E3 		mov	ip, #255
 4102 23dc 63FFFFEA 		b	.L275
 4103              	.LVL358:
 4104              	.L287:
1607:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4105              		.loc 1 1607 0
 4106 23e0 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4107 23e4 010058E3 		cmp	r8, #1
 4108 23e8 08005813 		cmpne	r8, #8
 4109 23ec 0000A013 		movne	r0, #0
 4110 23f0 0100A003 		moveq	r0, #1
 4111 23f4 8101001A 		bne	.L338
 4112              	.LVL359:
1610:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4113              		.loc 1 1610 0
 4114 23f8 6C869FE5 		ldr	r8, .L349+24
 4115 23fc 0010E0E3 		mvn	r1, #0
 4116 2400 1C0098E5 		ldr	r0, [r8, #28]
 4117 2404 2C308DE5 		str	r3, [sp, #44]
 4118 2408 FEFFFFEB 		bl	_txe_mutex_get
1611:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4119              		.loc 1 1611 0
 4120 240c 30A09DE5 		ldr	sl, [sp, #48]
 4121 2410 2210A0E3 		mov	r1, #34
 4122 2414 0B20A0E1 		mov	r2, fp
 4123 2418 2C309DE5 		ldr	r3, [sp, #44]
 4124 241c 00C0A0E3 		mov	ip, #0
 4125 2420 0800A0E1 		mov	r0, r8
 4126 2424 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4127 2428 FEFFFFEB 		bl	cmdSet
1612:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4128              		.loc 1 1612 0
 4129 242c 1C0098E5 		ldr	r0, [r8, #28]
 4130 2430 FEFFFFEB 		bl	_txe_mutex_put
1615:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4131              		.loc 1 1615 0
 4132 2434 1C069FE5 		ldr	r0, .L349+4
1616:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4133              		.loc 1 1616 0
 4134 2438 34209DE5 		ldr	r2, [sp, #52]
1615:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4135              		.loc 1 1615 0
 4136 243c 061089E0 		add	r1, r9, r6
 4137 2440 813180E0 		add	r3, r0, r1, asl #3
1617:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4138              		.loc 1 1617 0
 4139 2444 0160A0E3 		mov	r6, #1
1615:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4140              		.loc 1 1615 0
 4141 2448 2DA5C3E5 		strb	sl, [r3, #1325]
1616:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4142              		.loc 1 1616 0
 4143 244c 2E25C3E5 		strb	r2, [r3, #1326]
1617:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4144              		.loc 1 1617 0
 4145 2450 3065C3E5 		strb	r6, [r3, #1328]
 4146              	.LVL360:
 4147              	.L339:
1619:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4148              		.loc 1 1619 0
 4149 2454 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4150 2458 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1624:../uvc.c      **** 					  break;
 4151              		.loc 1 1624 0
 4152 245c FFC0A0E3 		mov	ip, #255
 4153 2460 42FFFFEA 		b	.L275
 4154              	.LVL361:
 4155              	.L286:
1573:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4156              		.loc 1 1573 0
 4157 2464 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 4158 2468 010050E3 		cmp	r0, #1
 4159 246c 04005013 		cmpne	r0, #4
 4160 2470 5D01001A 		bne	.L296
1572:../uvc.c      **** 					  value = (value << 8)|Data0;
 4161              		.loc 1 1572 0
 4162 2474 30109DE5 		ldr	r1, [sp, #48]
 4163 2478 34E09DE5 		ldr	lr, [sp, #52]
 4164 247c 0E2481E1 		orr	r2, r1, lr, asl #8
1574:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4165              		.loc 1 1574 0
 4166 2480 F90052E3 		cmp	r2, #249
 4167 2484 5801008A 		bhi	.L296
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4168              		.loc 1 1579 0
 4169 2488 C8A042E2 		sub	sl, r2, #200
 4170 248c 0AC8A0E1 		mov	ip, sl, asl #16
 4171 2490 3CC08DE5 		str	ip, [sp, #60]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4172              		.loc 1 1581 0
 4173 2494 27A062E2 		rsb	sl, r2, #39
 4174 2498 38A08DE5 		str	sl, [sp, #56]
 4175 249c 3CA09DE5 		ldr	sl, [sp, #60]
 4176 24a0 C81062E2 		rsb	r1, r2, #200
 4177 24a4 C80052E3 		cmp	r2, #200
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4178              		.loc 1 1579 0
 4179 24a8 640042E2 		sub	r0, r2, #100
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4180              		.loc 1 1581 0
 4181 24ac 0118A0E1 		mov	r1, r1, asl #16
 4182 24b0 64E062E2 		rsb	lr, r2, #100
 4183 24b4 2A18A081 		movhi	r1, sl, lsr #16
 4184 24b8 2118A091 		movls	r1, r1, lsr #16
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4185              		.loc 1 1579 0
 4186 24bc 00C8A0E1 		mov	ip, r0, asl #16
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4187              		.loc 1 1581 0
 4188 24c0 640052E3 		cmp	r2, #100
 4189 24c4 0E08A0E1 		mov	r0, lr, asl #16
 4190 24c8 2C08A081 		movhi	r0, ip, lsr #16
 4191 24cc 38C09DE5 		ldr	ip, [sp, #56]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4192              		.loc 1 1579 0
 4193 24d0 14A042E2 		sub	sl, r2, #20
 4194 24d4 38A08DE5 		str	sl, [sp, #56]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4195              		.loc 1 1581 0
 4196 24d8 2008A091 		movls	r0, r0, lsr #16
 4197 24dc 14A062E2 		rsb	sl, r2, #20
 4198 24e0 3CA08DE5 		str	sl, [sp, #60]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4199              		.loc 1 1579 0
 4200 24e4 27E042E2 		sub	lr, r2, #39
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4201              		.loc 1 1581 0
 4202 24e8 000051E1 		cmp	r1, r0
 4203 24ec 01A0A031 		movcc	sl, r1
 4204 24f0 00A0A021 		movcs	sl, r0
 4205 24f4 0CC8A0E1 		mov	ip, ip, asl #16
 4206 24f8 270052E3 		cmp	r2, #39
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4207              		.loc 1 1579 0
 4208 24fc 0EE8A0E1 		mov	lr, lr, asl #16
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4209              		.loc 1 1581 0
 4210 2500 2CE8A091 		movls	lr, ip, lsr #16
 4211 2504 68C59FE5 		ldr	ip, .L349+32
 4212 2508 20A08DE5 		str	sl, [sp, #32]
 4213 250c 01A06CE0 		rsb	sl, ip, r1
 4214 2510 2EE8A081 		movhi	lr, lr, lsr #16
 4215 2514 00C07AE2 		rsbs	ip, sl, #0
 4216 2518 0AC0ACE0 		adc	ip, ip, sl
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4217              		.loc 1 1579 0
 4218 251c 38A09DE5 		ldr	sl, [sp, #56]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4219              		.loc 1 1581 0
 4220 2520 44C08DE5 		str	ip, [sp, #68]
 4221              	.LVL362:
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4222              		.loc 1 1579 0
 4223 2524 0AC8A0E1 		mov	ip, sl, asl #16
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4224              		.loc 1 1581 0
 4225 2528 3CA09DE5 		ldr	sl, [sp, #60]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4226              		.loc 1 1579 0
 4227 252c 4CC08DE5 		str	ip, [sp, #76]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4228              		.loc 1 1581 0
 4229 2530 0AC8A0E1 		mov	ip, sl, asl #16
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4230              		.loc 1 1579 0
 4231 2534 0AA042E2 		sub	sl, r2, #10
 4232 2538 48A08DE5 		str	sl, [sp, #72]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4233              		.loc 1 1581 0
 4234 253c 20A09DE5 		ldr	sl, [sp, #32]
 4235 2540 3CC08DE5 		str	ip, [sp, #60]
 4236 2544 0A005EE1 		cmp	lr, sl
 4237 2548 0EA0A031 		movcc	sl, lr
 4238 254c 0AC062E2 		rsb	ip, r2, #10
 4239 2550 40C08DE5 		str	ip, [sp, #64]
 4240 2554 38A08DE5 		str	sl, [sp, #56]
 4241 2558 3CC09DE5 		ldr	ip, [sp, #60]
 4242 255c 4CA09DE5 		ldr	sl, [sp, #76]
 4243 2560 140052E3 		cmp	r2, #20
 4244 2564 2CA8A091 		movls	sl, ip, lsr #16
 4245 2568 2AA8A081 		movhi	sl, sl, lsr #16
 4246 256c 44C09DE5 		ldr	ip, [sp, #68]
 4247 2570 010050E1 		cmp	r0, r1
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4248              		.loc 1 1579 0
 4249 2574 48109DE5 		ldr	r1, [sp, #72]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4250              		.loc 1 1581 0
 4251 2578 01C0A033 		movcc	ip, #1
 4252 257c 3CA08DE5 		str	sl, [sp, #60]
 4253 2580 24C08DE5 		str	ip, [sp, #36]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4254              		.loc 1 1579 0
 4255 2584 01A8A0E1 		mov	sl, r1, asl #16
 4256 2588 05C042E2 		sub	ip, r2, #5
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4257              		.loc 1 1581 0
 4258 258c 051062E2 		rsb	r1, r2, #5
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4259              		.loc 1 1579 0
 4260 2590 48A08DE5 		str	sl, [sp, #72]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4261              		.loc 1 1581 0
 4262 2594 40009DE5 		ldr	r0, [sp, #64]
 4263 2598 38A09DE5 		ldr	sl, [sp, #56]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4264              		.loc 1 1579 0
 4265 259c 40C08DE5 		str	ip, [sp, #64]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4266              		.loc 1 1581 0
 4267 25a0 3CC09DE5 		ldr	ip, [sp, #60]
 4268 25a4 4C108DE5 		str	r1, [sp, #76]
 4269 25a8 48109DE5 		ldr	r1, [sp, #72]
 4270 25ac 0008A0E1 		mov	r0, r0, asl #16
 4271 25b0 0A005CE1 		cmp	ip, sl
 4272 25b4 0AC0A021 		movcs	ip, sl
 4273 25b8 0A0052E3 		cmp	r2, #10
 4274 25bc 20A09DE5 		ldr	sl, [sp, #32]
 4275 25c0 2108A081 		movhi	r0, r1, lsr #16
 4276 25c4 2008A091 		movls	r0, r0, lsr #16
 4277 25c8 48008DE5 		str	r0, [sp, #72]
 4278 25cc 24009DE5 		ldr	r0, [sp, #36]
 4279 25d0 0A005EE1 		cmp	lr, sl
 4280 25d4 0200A033 		movcc	r0, #2
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4281              		.loc 1 1579 0
 4282 25d8 02E042E2 		sub	lr, r2, #2
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4283              		.loc 1 1581 0
 4284 25dc 44C08DE5 		str	ip, [sp, #68]
 4285 25e0 24008DE5 		str	r0, [sp, #36]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4286              		.loc 1 1579 0
 4287 25e4 40C09DE5 		ldr	ip, [sp, #64]
 4288 25e8 1CE08DE5 		str	lr, [sp, #28]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4289              		.loc 1 1581 0
 4290 25ec 44009DE5 		ldr	r0, [sp, #68]
 4291 25f0 48E09DE5 		ldr	lr, [sp, #72]
 4292 25f4 4C109DE5 		ldr	r1, [sp, #76]
 4293 25f8 02A062E2 		rsb	sl, r2, #2
 4294 25fc 00005EE1 		cmp	lr, r0
 4295 2600 00E0A021 		movcs	lr, r0
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4296              		.loc 1 1579 0
 4297 2604 0CC8A0E1 		mov	ip, ip, asl #16
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4298              		.loc 1 1581 0
 4299 2608 050052E3 		cmp	r2, #5
 4300 260c 40A08DE5 		str	sl, [sp, #64]
 4301 2610 0118A0E1 		mov	r1, r1, asl #16
 4302 2614 3CA09DE5 		ldr	sl, [sp, #60]
 4303 2618 2C18A081 		movhi	r1, ip, lsr #16
 4304 261c 38C09DE5 		ldr	ip, [sp, #56]
 4305 2620 4CE08DE5 		str	lr, [sp, #76]
 4306 2624 24009DE5 		ldr	r0, [sp, #36]
 4307 2628 40E09DE5 		ldr	lr, [sp, #64]
 4308 262c 2118A091 		movls	r1, r1, lsr #16
 4309 2630 0C005AE1 		cmp	sl, ip
 4310 2634 20108DE5 		str	r1, [sp, #32]
 4311 2638 0300A033 		movcc	r0, #3
 4312 263c 38008DE5 		str	r0, [sp, #56]
 4313 2640 4CA09DE5 		ldr	sl, [sp, #76]
 4314 2644 0E08A0E1 		mov	r0, lr, asl #16
 4315 2648 20E09DE5 		ldr	lr, [sp, #32]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4316              		.loc 1 1579 0
 4317 264c 1C109DE5 		ldr	r1, [sp, #28]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4318              		.loc 1 1581 0
 4319 2650 0A005EE1 		cmp	lr, sl
 4320 2654 0AE0A021 		movcs	lr, sl
 4321 2658 44C09DE5 		ldr	ip, [sp, #68]
 4322 265c 48A09DE5 		ldr	sl, [sp, #72]
 4323 2660 020052E3 		cmp	r2, #2
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4324              		.loc 1 1579 0
 4325 2664 0118A0E1 		mov	r1, r1, asl #16
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4326              		.loc 1 1581 0
 4327 2668 2018A091 		movls	r1, r0, lsr #16
 4328 266c 38009DE5 		ldr	r0, [sp, #56]
 4329 2670 2118A081 		movhi	r1, r1, lsr #16
 4330 2674 0C005AE1 		cmp	sl, ip
 4331 2678 0400A033 		movcc	r0, #4
 4332 267c 40008DE5 		str	r0, [sp, #64]
1579:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4333              		.loc 1 1579 0
 4334 2680 010042E2 		sub	r0, r2, #1
 4335 2684 38008DE5 		str	r0, [sp, #56]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4336              		.loc 1 1581 0
 4337 2688 4CA09DE5 		ldr	sl, [sp, #76]
 4338 268c 20009DE5 		ldr	r0, [sp, #32]
 4339 2690 01C062E2 		rsb	ip, r2, #1
 4340 2694 3CC08DE5 		str	ip, [sp, #60]
 4341 2698 0A0050E1 		cmp	r0, sl
1588:../uvc.c      **** 						  shutter = shutter+index;
 4342              		.loc 1 1588 0
 4343 269c 38A09DE5 		ldr	sl, [sp, #56]
 4344 26a0 3C009DE5 		ldr	r0, [sp, #60]
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4345              		.loc 1 1581 0
 4346 26a4 40C09DE5 		ldr	ip, [sp, #64]
 4347 26a8 05C0A033 		movcc	ip, #5
1588:../uvc.c      **** 						  shutter = shutter+index;
 4348              		.loc 1 1588 0
 4349 26ac 010052E3 		cmp	r2, #1
 4350 26b0 0028A091 		movls	r2, r0, asl #16
 4351 26b4 0A28A081 		movhi	r2, sl, asl #16
 4352 26b8 0E0051E1 		cmp	r1, lr
 4353 26bc 01A0A031 		movcc	sl, r1
 4354 26c0 0EA0A021 		movcs	sl, lr
1581:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4355              		.loc 1 1581 0
 4356 26c4 0E0051E1 		cmp	r1, lr
 4357 26c8 0C10A021 		movcs	r1, ip
 4358 26cc 0610A033 		movcc	r1, #6
1588:../uvc.c      **** 						  shutter = shutter+index;
 4359              		.loc 1 1588 0
 4360 26d0 22085AE1 		cmp	sl, r2, lsr #16
1591:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4361              		.loc 1 1591 0
 4362 26d4 90A39FE5 		ldr	sl, .L349+24
1588:../uvc.c      **** 						  shutter = shutter+index;
 4363              		.loc 1 1588 0
 4364 26d8 0120A091 		movls	r2, r1
 4365 26dc 0720A083 		movhi	r2, #7
 4366 26e0 012082E2 		add	r2, r2, #1
 4367 26e4 FFE002E2 		and	lr, r2, #255
1591:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4368              		.loc 1 1591 0
 4369 26e8 0010E0E3 		mvn	r1, #0
 4370 26ec 1C009AE5 		ldr	r0, [sl, #28]
1588:../uvc.c      **** 						  shutter = shutter+index;
 4371              		.loc 1 1588 0
 4372 26f0 38E08DE5 		str	lr, [sp, #56]
 4373              	.LVL363:
1591:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4374              		.loc 1 1591 0
 4375 26f4 2C308DE5 		str	r3, [sp, #44]
 4376 26f8 FEFFFFEB 		bl	_txe_mutex_get
1592:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 4377              		.loc 1 1592 0
 4378 26fc 38C09DE5 		ldr	ip, [sp, #56]
 4379 2700 0310A0E3 		mov	r1, #3
 4380 2704 0B20A0E1 		mov	r2, fp
 4381 2708 2C309DE5 		ldr	r3, [sp, #44]
 4382 270c 00C08DE5 		str	ip, [sp, #0]
 4383 2710 0A00A0E1 		mov	r0, sl
 4384 2714 00C0A0E3 		mov	ip, #0
 4385 2718 04C08DE5 		str	ip, [sp, #4]
 4386 271c FEFFFFEB 		bl	cmdSet
1593:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4387              		.loc 1 1593 0
 4388 2720 1C009AE5 		ldr	r0, [sl, #28]
 4389 2724 FEFFFFEB 		bl	_txe_mutex_put
1596:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4390              		.loc 1 1596 0
 4391 2728 30009DE5 		ldr	r0, [sp, #48]
1597:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4392              		.loc 1 1597 0
 4393 272c 34C09DE5 		ldr	ip, [sp, #52]
1599:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4394              		.loc 1 1599 0
 4395 2730 38309DE5 		ldr	r3, [sp, #56]
1596:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4396              		.loc 1 1596 0
 4397 2734 061089E0 		add	r1, r9, r6
 4398 2738 816188E0 		add	r6, r8, r1, asl #3
1598:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4399              		.loc 1 1598 0
 4400 273c 0120A0E3 		mov	r2, #1
1596:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4401              		.loc 1 1596 0
 4402 2740 2D05C6E5 		strb	r0, [r6, #1325]
1597:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4403              		.loc 1 1597 0
 4404 2744 2EC5C6E5 		strb	ip, [r6, #1326]
1598:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4405              		.loc 1 1598 0
 4406 2748 3025C6E5 		strb	r2, [r6, #1328]
1599:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4407              		.loc 1 1599 0
 4408 274c 0D33C8E5 		strb	r3, [r8, #781]
 4409 2750 3FFFFFEA 		b	.L339
 4410              	.LVL364:
 4411              	.L285:
1526:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4412              		.loc 1 1526 0
 4413 2754 062089E0 		add	r2, r9, r6
 4414 2758 826188E0 		add	r6, r8, r2, asl #3
1527:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4415              		.loc 1 1527 0
 4416 275c 0110A0E3 		mov	r1, #1
1530:../uvc.c      **** 		  		    switch (getData){
 4417              		.loc 1 1530 0
 4418 2760 01E040E2 		sub	lr, r0, #1
1526:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4419              		.loc 1 1526 0
 4420 2764 2D05C6E5 		strb	r0, [r6, #1325]
1527:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4421              		.loc 1 1527 0
 4422 2768 3015C6E5 		strb	r1, [r6, #1328]
 4423              	.LVL365:
1530:../uvc.c      **** 		  		    switch (getData){
 4424              		.loc 1 1530 0
 4425 276c 07005EE3 		cmp	lr, #7
 4426 2770 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 4427 2774 980000EA 		b	.L290
 4428              	.L295:
 4429 2778 70290000 		.word	.L291
 4430 277c D4280000 		.word	.L292
 4431 2780 DC290000 		.word	.L290
 4432 2784 6C280000 		.word	.L293
 4433 2788 DC290000 		.word	.L290
 4434 278c DC290000 		.word	.L290
 4435 2790 DC290000 		.word	.L290
 4436 2794 CC270000 		.word	.L294
 4437              	.LVL366:
 4438              	.L284:
1646:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4439              		.loc 1 1646 0
 4440 2798 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1645:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4441              		.loc 1 1645 0
 4442 279c 30A09DE5 		ldr	sl, [sp, #48]
 4443 27a0 069089E0 		add	r9, r9, r6
 4444 27a4 89E188E0 		add	lr, r8, r9, asl #3
1646:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4445              		.loc 1 1646 0
 4446 27a8 0620A0E1 		mov	r2, r6
 4447 27ac 0400A0E3 		mov	r0, #4
 4448 27b0 C0129FE5 		ldr	r1, .L349+36
1645:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4449              		.loc 1 1645 0
 4450 27b4 2DA5CEE5 		strb	sl, [lr, #1325]
1646:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4451              		.loc 1 1646 0
 4452 27b8 FEFFFFEB 		bl	CyU3PDebugPrint
1647:../uvc.c      **** 			  		 break;
 4453              		.loc 1 1647 0
 4454 27bc FFC0A0E3 		mov	ip, #255
 4455 27c0 0C60A0E1 		mov	r6, ip
 4456 27c4 0C80A0E1 		mov	r8, ip
 4457 27c8 68FEFFEA 		b	.L275
 4458              	.LVL367:
 4459              	.L294:
1549:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4460              		.loc 1 1549 0
 4461 27cc 98629FE5 		ldr	r6, .L349+24
1547:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4462              		.loc 1 1547 0
 4463 27d0 00A0A0E3 		mov	sl, #0
1549:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4464              		.loc 1 1549 0
 4465 27d4 1C0096E5 		ldr	r0, [r6, #28]
1547:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4466              		.loc 1 1547 0
 4467 27d8 0DA3C8E5 		strb	sl, [r8, #781]
 4468              	.LVL368:
1549:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4469              		.loc 1 1549 0
 4470 27dc 0010E0E3 		mvn	r1, #0
 4471 27e0 2C308DE5 		str	r3, [sp, #44]
 4472 27e4 FEFFFFEB 		bl	_txe_mutex_get
1550:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4473              		.loc 1 1550 0
 4474 27e8 0B20A0E1 		mov	r2, fp
 4475 27ec 2C309DE5 		ldr	r3, [sp, #44]
 4476 27f0 1010A0E3 		mov	r1, #16
 4477 27f4 0600A0E1 		mov	r0, r6
 4478 27f8 00A08DE5 		str	sl, [sp, #0]
 4479 27fc 04A08DE5 		str	sl, [sp, #4]
 4480 2800 FEFFFFEB 		bl	cmdSet
1551:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4481              		.loc 1 1551 0
 4482 2804 1C0096E5 		ldr	r0, [r6, #28]
 4483 2808 FEFFFFEB 		bl	_txe_mutex_put
 4484              	.LVL369:
 4485              	.LBB68:
 4486              	.LBB69:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4487              		.loc 1 679 0
 4488 280c 0010E0E3 		mvn	r1, #0
 4489 2810 1C0096E5 		ldr	r0, [r6, #28]
 4490 2814 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4491              		.loc 1 680 0
 4492 2818 01C0A0E3 		mov	ip, #1
 4493 281c 2010A0E3 		mov	r1, #32
 4494 2820 2720A0E3 		mov	r2, #39
 4495 2824 3030A0E3 		mov	r3, #48
 4496 2828 0600A0E1 		mov	r0, r6
 4497 282c 00C08DE5 		str	ip, [sp, #0]
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4498              		.loc 1 681 0
 4499 2830 0280A0E3 		mov	r8, #2
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4500              		.loc 1 680 0
 4501 2834 04A08DE5 		str	sl, [sp, #4]
 4502 2838 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4503              		.loc 1 681 0
 4504 283c 2110A0E3 		mov	r1, #33
 4505 2840 2520A0E3 		mov	r2, #37
 4506 2844 3030A0E3 		mov	r3, #48
 4507 2848 0600A0E1 		mov	r0, r6
 4508 284c 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4509 2850 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4510              		.loc 1 682 0
 4511 2854 1C0096E5 		ldr	r0, [r6, #28]
 4512 2858 FEFFFFEB 		bl	_txe_mutex_put
 4513              	.LBE69:
 4514              	.LBE68:
1553:../uvc.c      **** 							break;
 4515              		.loc 1 1553 0
 4516 285c FFC0A0E3 		mov	ip, #255
 4517 2860 0C60A0E1 		mov	r6, ip
 4518 2864 0880A0E3 		mov	r8, #8
 4519 2868 40FEFFEA 		b	.L275
 4520              	.LVL370:
 4521              	.L293:
 4522              	.LBB70:
 4523              	.LBB71:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4524              		.loc 1 679 0
 4525 286c F8619FE5 		ldr	r6, .L349+24
 4526 2870 0010E0E3 		mvn	r1, #0
 4527 2874 1C0096E5 		ldr	r0, [r6, #28]
 4528 2878 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4529              		.loc 1 680 0
 4530 287c 0080A0E3 		mov	r8, #0
 4531 2880 2010A0E3 		mov	r1, #32
 4532 2884 2720A0E3 		mov	r2, #39
 4533 2888 3030A0E3 		mov	r3, #48
 4534 288c 0600A0E1 		mov	r0, r6
 4535 2890 00808DE5 		str	r8, [sp, #0]
 4536 2894 04808DE5 		str	r8, [sp, #4]
 4537 2898 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4538              		.loc 1 681 0
 4539 289c 01C0A0E3 		mov	ip, #1
 4540 28a0 2110A0E3 		mov	r1, #33
 4541 28a4 2520A0E3 		mov	r2, #37
 4542 28a8 3030A0E3 		mov	r3, #48
 4543 28ac 0600A0E1 		mov	r0, r6
 4544 28b0 00C08DE5 		str	ip, [sp, #0]
 4545 28b4 04808DE5 		str	r8, [sp, #4]
 4546 28b8 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4547              		.loc 1 682 0
 4548 28bc 1C0096E5 		ldr	r0, [r6, #28]
 4549 28c0 FEFFFFEB 		bl	_txe_mutex_put
 4550 28c4 FFC0A0E3 		mov	ip, #255
 4551 28c8 0C60A0E1 		mov	r6, ip
 4552 28cc 0480A0E3 		mov	r8, #4
 4553 28d0 26FEFFEA 		b	.L275
 4554              	.LVL371:
 4555              	.L292:
 4556              	.LBE71:
 4557              	.LBE70:
1537:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4558              		.loc 1 1537 0
 4559 28d4 90619FE5 		ldr	r6, .L349+24
1535:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4560              		.loc 1 1535 0
 4561 28d8 00A0A0E3 		mov	sl, #0
1537:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4562              		.loc 1 1537 0
 4563 28dc 1C0096E5 		ldr	r0, [r6, #28]
1535:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4564              		.loc 1 1535 0
 4565 28e0 0DA3C8E5 		strb	sl, [r8, #781]
 4566              	.LVL372:
1537:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4567              		.loc 1 1537 0
 4568 28e4 0010E0E3 		mvn	r1, #0
 4569 28e8 2C308DE5 		str	r3, [sp, #44]
 4570 28ec FEFFFFEB 		bl	_txe_mutex_get
1538:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4571              		.loc 1 1538 0
 4572 28f0 0B20A0E1 		mov	r2, fp
 4573 28f4 2C309DE5 		ldr	r3, [sp, #44]
 4574 28f8 1010A0E3 		mov	r1, #16
 4575 28fc 0600A0E1 		mov	r0, r6
 4576 2900 00A08DE5 		str	sl, [sp, #0]
 4577 2904 04A08DE5 		str	sl, [sp, #4]
 4578 2908 FEFFFFEB 		bl	cmdSet
1539:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4579              		.loc 1 1539 0
 4580 290c 1C0096E5 		ldr	r0, [r6, #28]
 4581 2910 FEFFFFEB 		bl	_txe_mutex_put
 4582              	.LVL373:
 4583              	.LBB72:
 4584              	.LBB73:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4585              		.loc 1 679 0
 4586 2914 0010E0E3 		mvn	r1, #0
 4587 2918 1C0096E5 		ldr	r0, [r6, #28]
 4588 291c FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4589              		.loc 1 680 0
 4590 2920 2010A0E3 		mov	r1, #32
 4591 2924 2720A0E3 		mov	r2, #39
 4592 2928 3030A0E3 		mov	r3, #48
 4593 292c 0600A0E1 		mov	r0, r6
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4594              		.loc 1 681 0
 4595 2930 0180A0E3 		mov	r8, #1
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4596              		.loc 1 680 0
 4597 2934 00A08DE5 		str	sl, [sp, #0]
 4598 2938 04A08DE5 		str	sl, [sp, #4]
 4599 293c FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4600              		.loc 1 681 0
 4601 2940 2110A0E3 		mov	r1, #33
 4602 2944 2520A0E3 		mov	r2, #37
 4603 2948 3030A0E3 		mov	r3, #48
 4604 294c 0600A0E1 		mov	r0, r6
 4605 2950 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4606 2954 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4607              		.loc 1 682 0
 4608 2958 1C0096E5 		ldr	r0, [r6, #28]
 4609 295c FEFFFFEB 		bl	_txe_mutex_put
 4610 2960 FFC0A0E3 		mov	ip, #255
 4611 2964 0C60A0E1 		mov	r6, ip
 4612 2968 0280A0E3 		mov	r8, #2
 4613 296c FFFDFFEA 		b	.L275
 4614              	.LVL374:
 4615              	.L291:
 4616              	.LBE73:
 4617              	.LBE72:
 4618              	.LBB74:
 4619              	.LBB75:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4620              		.loc 1 679 0
 4621 2970 F4609FE5 		ldr	r6, .L349+24
 4622 2974 0010E0E3 		mvn	r1, #0
 4623 2978 1C0096E5 		ldr	r0, [r6, #28]
 4624 297c FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4625              		.loc 1 680 0
 4626 2980 0080A0E3 		mov	r8, #0
 4627 2984 01A0A0E3 		mov	sl, #1
 4628 2988 2010A0E3 		mov	r1, #32
 4629 298c 2720A0E3 		mov	r2, #39
 4630 2990 3030A0E3 		mov	r3, #48
 4631 2994 0600A0E1 		mov	r0, r6
 4632 2998 04808DE5 		str	r8, [sp, #4]
 4633 299c 00A08DE5 		str	sl, [sp, #0]
 4634 29a0 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4635              		.loc 1 681 0
 4636 29a4 02C0A0E3 		mov	ip, #2
 4637 29a8 2110A0E3 		mov	r1, #33
 4638 29ac 2520A0E3 		mov	r2, #37
 4639 29b0 3030A0E3 		mov	r3, #48
 4640 29b4 0600A0E1 		mov	r0, r6
 4641 29b8 00C08DE5 		str	ip, [sp, #0]
 4642 29bc 04808DE5 		str	r8, [sp, #4]
 4643 29c0 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4644              		.loc 1 682 0
 4645 29c4 1C0096E5 		ldr	r0, [r6, #28]
 4646 29c8 FEFFFFEB 		bl	_txe_mutex_put
 4647              	.LBE75:
 4648              	.LBE74:
1533:../uvc.c      **** 							break;
 4649              		.loc 1 1533 0
 4650 29cc FFC0A0E3 		mov	ip, #255
 4651 29d0 0C60A0E1 		mov	r6, ip
 4652 29d4 0A80A0E1 		mov	r8, sl
 4653 29d8 E4FDFFEA 		b	.L275
 4654              	.LVL375:
 4655              	.L290:
1530:../uvc.c      **** 		  		    switch (getData){
 4656              		.loc 1 1530 0
 4657 29dc FFC0A0E3 		mov	ip, #255
 4658 29e0 0080A0E1 		mov	r8, r0
 4659 29e4 0C60A0E1 		mov	r6, ip
 4660 29e8 E0FDFFEA 		b	.L275
 4661              	.LVL376:
 4662              	.L296:
1601:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4663              		.loc 1 1601 0
 4664 29ec 0000A0E3 		mov	r0, #0
 4665 29f0 0110A0E3 		mov	r1, #1
 4666 29f4 0020A0E1 		mov	r2, r0
 4667 29f8 FEFFFFEB 		bl	CyU3PUsbStall
 4668              	.LVL377:
 4669 29fc 94FEFFEA 		b	.L339
 4670              	.LVL378:
 4671              	.L338:
1619:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4672              		.loc 1 1619 0
 4673 2a00 0110A0E3 		mov	r1, #1
 4674 2a04 0020A0E1 		mov	r2, r0
 4675 2a08 FEFFFFEB 		bl	CyU3PUsbStall
 4676 2a0c 90FEFFEA 		b	.L339
 4677              	.LVL379:
 4678              	.L348:
1634:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4679              		.loc 1 1634 0
 4680 2a10 08E0A0E3 		mov	lr, #8
 4681 2a14 00C0A0E3 		mov	ip, #0
 4682 2a18 0600A0E1 		mov	r0, r6
 4683 2a1c 2310A0E3 		mov	r1, #35
 4684 2a20 0B20A0E1 		mov	r2, fp
 4685 2a24 00E08DE5 		str	lr, [sp, #0]
 4686 2a28 04C08DE5 		str	ip, [sp, #4]
 4687 2a2c FEFFFFEB 		bl	cmdSet
 4688 2a30 5DFEFFEA 		b	.L341
 4689              	.L347:
1632:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4690              		.loc 1 1632 0
 4691 2a34 0480A0E3 		mov	r8, #4
 4692 2a38 00E0A0E3 		mov	lr, #0
 4693 2a3c 0600A0E1 		mov	r0, r6
 4694 2a40 2310A0E3 		mov	r1, #35
 4695 2a44 0B20A0E1 		mov	r2, fp
 4696 2a48 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4697 2a4c FEFFFFEB 		bl	cmdSet
 4698 2a50 55FEFFEA 		b	.L341
 4699              	.L350:
 4700              		.align	2
 4701              	.L349:
 4702 2a54 00000000 		.word	bRequest
 4703 2a58 00000000 		.word	.LANCHOR1
 4704 2a5c 00000000 		.word	.LANCHOR0
 4705 2a60 C8040000 		.word	.LC28
 4706 2a64 EC040000 		.word	.LC29
 4707 2a68 5C000000 		.word	.LANCHOR0+92
 4708 2a6c 00000000 		.word	cmdQu
 4709 2a70 7C040000 		.word	.LC26
 4710 2a74 FFFF0000 		.word	65535
 4711 2a78 A4040000 		.word	.LC27
 4712              		.cfi_endproc
 4713              	.LFE4:
 4715              		.align	2
 4716              		.global	UVCAppEP0Thread_Entry
 4718              	UVCAppEP0Thread_Entry:
 4719              	.LFB25:
3810:../uvc.c      **** {
 4720              		.loc 1 3810 0
 4721              		.cfi_startproc
 4722              		@ args = 0, pretend = 0, frame = 24
 4723              		@ frame_needed = 0, uses_anonymous_args = 0
 4724              	.LVL380:
 4725 2a7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4726              	.LCFI19:
 4727              		.cfi_def_cfa_offset 36
 4728 2a80 644D9FE5 		ldr	r4, .L546
 4729              		.cfi_offset 14, -4
 4730              		.cfi_offset 11, -8
 4731              		.cfi_offset 10, -12
 4732              		.cfi_offset 9, -16
 4733              		.cfi_offset 8, -20
 4734              		.cfi_offset 7, -24
 4735              		.cfi_offset 6, -28
 4736              		.cfi_offset 5, -32
 4737              		.cfi_offset 4, -36
 4738 2a84 645D9FE5 		ldr	r5, .L546+4
 4739 2a88 648D9FE5 		ldr	r8, .L546+8
 4740 2a8c 64AD9FE5 		ldr	sl, .L546+12
 4741 2a90 64BD9FE5 		ldr	fp, .L546+16
 4742 2a94 647D9FE5 		ldr	r7, .L546+20
 4743 2a98 34D04DE2 		sub	sp, sp, #52
 4744              	.LCFI20:
 4745              		.cfi_def_cfa_offset 88
 4746              	.LVL381:
3832:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4747              		.loc 1 3832 0
 4748 2a9c 0460A0E1 		mov	r6, r4
 4749              	.LVL382:
 4750              	.L506:
 4751 2aa0 00C0E0E3 		mvn	ip, #0
 4752 2aa4 400D9FE5 		ldr	r0, .L546
 4753 2aa8 4C10A0E3 		mov	r1, #76
 4754 2aac 0120A0E3 		mov	r2, #1
 4755 2ab0 28308DE2 		add	r3, sp, #40
 4756 2ab4 00C08DE5 		str	ip, [sp, #0]
 4757 2ab8 FEFFFFEB 		bl	_txe_event_flags_get
 4758 2abc 000050E3 		cmp	r0, #0
 4759 2ac0 3000001A 		bne	.L352
3836:../uvc.c      ****             if (!isUsbConnected)
 4760              		.loc 1 3836 0
 4761 2ac4 303096E5 		ldr	r3, [r6, #48]
 4762 2ac8 000053E3 		cmp	r3, #0
 4763 2acc 8C00000A 		beq	.L535
 4764              	.L353:
3845:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4765              		.loc 1 3845 0
 4766 2ad0 28309DE5 		ldr	r3, [sp, #40]
 4767 2ad4 0C0013E3 		tst	r3, #12
 4768 2ad8 7500001A 		bne	.L536
 4769              	.L354:
3852:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4770              		.loc 1 3852 0
 4771 2adc 040013E3 		tst	r3, #4
 4772 2ae0 1C00000A 		beq	.L355
3854:../uvc.c      ****             	switch ((wIndex >> 8))
 4773              		.loc 1 3854 0
 4774 2ae4 B0E0DBE1 		ldrh	lr, [fp, #0]
 4775 2ae8 2E24A0E1 		mov	r2, lr, lsr #8
 4776 2aec 030052E3 		cmp	r2, #3
 4777 2af0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4778 2af4 120000EA 		b	.L356
 4779              	.L361:
 4780 2af8 442B0000 		.word	.L356
 4781 2afc 342C0000 		.word	.L358
 4782 2b00 082B0000 		.word	.L359
 4783 2b04 702C0000 		.word	.L360
 4784              	.L359:
 4785              	.LBB90:
 4786              	.LBB94:
3058:../uvc.c      ****     switch (wValue)
 4787              		.loc 1 3058 0
 4788 2b08 B020DAE1 		ldrh	r2, [sl, #0]
 4789 2b0c 060C52E3 		cmp	r2, #1536
 4790 2b10 9902000A 		beq	.L367
 4791 2b14 D900008A 		bhi	.L373
 4792 2b18 030C52E3 		cmp	r2, #768
 4793 2b1c 9202000A 		beq	.L365
 4794 2b20 A001008A 		bhi	.L374
 4795 2b24 010C52E3 		cmp	r2, #256
 4796 2b28 B602000A 		beq	.L363
 4797 2b2c 020C52E3 		cmp	r2, #512
 4798 2b30 B002000A 		beq	.L537
 4799              	.L376:
 4800              	.LBE94:
 4801              	.LBE90:
 4802              	.LBB98:
 4803              	.LBB103:
3190:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4804              		.loc 1 3190 0
 4805 2b34 C81C9FE5 		ldr	r1, .L546+24
 4806 2b38 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4807 2b3c 0400A0E3 		mov	r0, #4
 4808 2b40 FEFFFFEB 		bl	CyU3PDebugPrint
 4809              	.L356:
 4810              	.LBE103:
 4811              	.LBE98:
3875:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4812              		.loc 1 3875 0
 4813 2b44 0000A0E3 		mov	r0, #0
 4814 2b48 0110A0E3 		mov	r1, #1
 4815 2b4c 0020A0E1 		mov	r2, r0
 4816 2b50 FEFFFFEB 		bl	CyU3PUsbStall
 4817 2b54 28309DE5 		ldr	r3, [sp, #40]
 4818              	.L355:
3880:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4819              		.loc 1 3880 0
 4820 2b58 080013E3 		tst	r3, #8
 4821 2b5c 0700000A 		beq	.L419
3884:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4822              		.loc 1 3884 0
 4823 2b60 B030DBE1 		ldrh	r3, [fp, #0]
 4824 2b64 010053E3 		cmp	r3, #1
 4825 2b68 6B00000A 		beq	.L420
 4826              	.L421:
 4827              	.LBB109:
 4828              	.LBB113:
3799:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4829              		.loc 1 3799 0
 4830 2b6c 0000A0E3 		mov	r0, #0
 4831 2b70 0110A0E3 		mov	r1, #1
 4832 2b74 0020A0E1 		mov	r2, r0
 4833 2b78 FEFFFFEB 		bl	CyU3PUsbStall
 4834              	.L525:
 4835 2b7c 28309DE5 		ldr	r3, [sp, #40]
 4836              	.L419:
 4837              	.LBE113:
 4838              	.LBE109:
3895:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4839              		.loc 1 3895 0
 4840 2b80 400013E3 		tst	r3, #64
 4841 2b84 0100001A 		bne	.L538
 4842              	.L352:
4108:../uvc.c      ****         CyU3PThreadRelinquish ();
 4843              		.loc 1 4108 0
 4844 2b88 FEFFFFEB 		bl	_txe_thread_relinquish
4109:../uvc.c      ****     }
 4845              		.loc 1 4109 0
 4846 2b8c C3FFFFEA 		b	.L506
 4847              	.L538:
3900:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4848              		.loc 1 3900 0
 4849 2b90 1800A0E3 		mov	r0, #24
 4850 2b94 24108DE2 		add	r1, sp, #36
 4851 2b98 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3957:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4852              		.loc 1 3957 0
 4853 2b9c 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 4854 2ba0 0F0053E3 		cmp	r3, #15
 4855 2ba4 9400000A 		beq	.L539
3984:../uvc.c      **** 				}else if(!snapButFlag){
 4856              		.loc 1 3984 0
 4857 2ba8 000053E3 		cmp	r3, #0
 4858 2bac F5FFFF1A 		bne	.L352
3986:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4859              		.loc 1 3986 0
 4860 2bb0 002097E5 		ldr	r2, [r7, #0]
 4861 2bb4 0290A0E3 		mov	r9, #2
 4862 2bb8 0090C2E5 		strb	r9, [r2, #0]
3987:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4863              		.loc 1 3987 0
 4864 2bbc 001097E5 		ldr	r1, [r7, #0]
 4865 2bc0 0190A0E3 		mov	r9, #1
 4866 2bc4 0190C1E5 		strb	r9, [r1, #1]
3988:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4867              		.loc 1 3988 0
 4868 2bc8 000097E5 		ldr	r0, [r7, #0]
3992:../uvc.c      **** 					interStabuf.size   = 1024;
 4869              		.loc 1 3992 0
 4870 2bcc 01CBA0E3 		mov	ip, #1024	@ movhi
3988:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4871              		.loc 1 3988 0
 4872 2bd0 0230C0E5 		strb	r3, [r0, #2]
3989:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4873              		.loc 1 3989 0
 4874 2bd4 00E097E5 		ldr	lr, [r7, #0]
3998:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4875              		.loc 1 3998 0
 4876 2bd8 0010E0E3 		mvn	r1, #0
3989:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4877              		.loc 1 3989 0
 4878 2bdc 0390CEE5 		strb	r9, [lr, #3]
3991:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4879              		.loc 1 3991 0
 4880 2be0 002097E5 		ldr	r2, [r7, #0]
3995:../uvc.c      **** 					interStabuf.count = 4;
 4881              		.loc 1 3995 0
 4882 2be4 04E0A0E3 		mov	lr, #4	@ movhi
3998:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4883              		.loc 1 3998 0
 4884 2be8 180C9FE5 		ldr	r0, .L546+28
3991:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4885              		.loc 1 3991 0
 4886 2bec 18208DE5 		str	r2, [sp, #24]
3992:../uvc.c      **** 					interStabuf.size   = 1024;
 4887              		.loc 1 3992 0
 4888 2bf0 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3993:../uvc.c      **** 					interStabuf.status = 0;
 4889              		.loc 1 3993 0
 4890 2bf4 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3995:../uvc.c      **** 					interStabuf.count = 4;
 4891              		.loc 1 3995 0
 4892 2bf8 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3998:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4893              		.loc 1 3998 0
 4894 2bfc FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4001:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4895              		.loc 1 4001 0
 4896 2c00 000C9FE5 		ldr	r0, .L546+28
 4897 2c04 18108DE2 		add	r1, sp, #24
 4898 2c08 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4899              	.LVL383:
4003:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4900              		.loc 1 4003 0
 4901 2c0c 002050E2 		subs	r2, r0, #0
 4902 2c10 5B01001A 		bne	.L540
4009:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4903              		.loc 1 4009 0
 4904 2c14 3010A0E3 		mov	r1, #48
 4905 2c18 0920A0E1 		mov	r2, r9
 4906 2c1c 0500A0E3 		mov	r0, #5
 4907              	.LVL384:
 4908 2c20 FEFFFFEB 		bl	SensorSetControl
4010:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4909              		.loc 1 4010 0
 4910 2c24 C43B9FE5 		ldr	r3, .L546+4
 4911 2c28 0B97C3E5 		strb	r9, [r3, #1803]
4108:../uvc.c      ****         CyU3PThreadRelinquish ();
 4912              		.loc 1 4108 0
 4913 2c2c FEFFFFEB 		bl	_txe_thread_relinquish
 4914 2c30 9AFFFFEA 		b	.L506
 4915              	.L358:
 4916              	.LBB118:
 4917              	.LBB104:
3133:../uvc.c      ****     switch (wValue)
 4918              		.loc 1 3133 0
 4919 2c34 B020DAE1 		ldrh	r2, [sl, #0]
 4920 2c38 060C52E3 		cmp	r2, #1536
 4921 2c3c 7502000A 		beq	.L382
 4922 2c40 9900008A 		bhi	.L388
 4923 2c44 030C52E3 		cmp	r2, #768
 4924 2c48 5B02000A 		beq	.L379
 4925 2c4c 8101008A 		bhi	.L389
 4926 2c50 010C52E3 		cmp	r2, #256
 4927 2c54 5402000A 		beq	.L377
 4928 2c58 020C52E3 		cmp	r2, #512
 4929 2c5c B4FFFF1A 		bne	.L376
 4930              	.LVL385:
3141:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4931              		.loc 1 3141 0
 4932 2c60 0100A0E3 		mov	r0, #1
 4933 2c64 FEFFFFEB 		bl	CTControlHandle
 4934              	.LVL386:
 4935 2c68 28309DE5 		ldr	r3, [sp, #40]
 4936 2c6c B9FFFFEA 		b	.L355
 4937              	.L360:
 4938              	.LBE104:
 4939              	.LBE118:
 4940              	.LBB119:
 4941              	.LBB125:
3358:../uvc.c      ****     switch (wValue)
 4942              		.loc 1 3358 0
 4943 2c70 B030DAE1 		ldrh	r3, [sl, #0]
 4944 2c74 090C53E3 		cmp	r3, #2304
 4945 2c78 4702000A 		beq	.L403
 4946 2c7c 9200008A 		bhi	.L413
 4947 2c80 010B53E3 		cmp	r3, #1024
 4948 2c84 4002000A 		beq	.L398
 4949 2c88 5701008A 		bhi	.L414
 4950 2c8c 020C53E3 		cmp	r3, #512
 4951 2c90 C101000A 		beq	.L396
 4952 2c94 030C53E3 		cmp	r3, #768
 4953 2c98 BB01000A 		beq	.L397
 4954 2c9c 010C53E3 		cmp	r3, #256
 4955 2ca0 A7FFFF1A 		bne	.L356
 4956              	.LVL387:
3362:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4957              		.loc 1 3362 0
 4958 2ca4 1000A0E3 		mov	r0, #16
 4959 2ca8 FEFFFFEB 		bl	ControlHandle
 4960              	.LVL388:
 4961 2cac 28309DE5 		ldr	r3, [sp, #40]
 4962 2cb0 A8FFFFEA 		b	.L355
 4963              	.L536:
 4964              	.LBE125:
 4965              	.LBE119:
3846:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4966              		.loc 1 3846 0
 4967 2cb4 B0C0DAE1 		ldrh	ip, [sl, #0]
 4968 2cb8 4C9B9FE5 		ldr	r9, .L546+32
 4969 2cbc 4C1B9FE5 		ldr	r1, .L546+36
 4970 2cc0 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4971 2cc4 08C08DE5 		str	ip, [sp, #8]
 4972 2cc8 B000DBE1 		ldrh	r0, [fp, #0]
 4973 2ccc 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4974 2cd0 0C008DE5 		str	r0, [sp, #12]
 4975 2cd4 B0C0D1E1 		ldrh	ip, [r1, #0]
 4976 2cd8 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4977 2cdc 04908DE5 		str	r9, [sp, #4]
 4978 2ce0 0400A0E3 		mov	r0, #4
 4979 2ce4 281B9FE5 		ldr	r1, .L546+40
 4980 2ce8 0090A0E3 		mov	r9, #0
 4981 2cec 00E08DE5 		str	lr, [sp, #0]
 4982 2cf0 10C08DE5 		str	ip, [sp, #16]
 4983 2cf4 14908DE5 		str	r9, [sp, #20]
 4984 2cf8 FEFFFFEB 		bl	CyU3PDebugPrint
 4985 2cfc 28309DE5 		ldr	r3, [sp, #40]
 4986 2d00 75FFFFEA 		b	.L354
 4987              	.L535:
3838:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4988              		.loc 1 3838 0
 4989 2d04 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3839:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4990              		.loc 1 3839 0
 4991 2d08 000050E3 		cmp	r0, #0
3838:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4992              		.loc 1 3838 0
 4993 2d0c 4800C6E5 		strb	r0, [r6, #72]
3841:../uvc.c      ****                     isUsbConnected = CyTrue;
 4994              		.loc 1 3841 0
 4995 2d10 0100A013 		movne	r0, #1
 4996 2d14 30008615 		strne	r0, [r6, #48]
 4997 2d18 6CFFFFEA 		b	.L353
 4998              	.L420:
 4999              	.LVL389:
 5000              	.LBB132:
 5001              	.LBB114:
3459:../uvc.c      ****     switch (wValue)
 5002              		.loc 1 3459 0
 5003 2d1c B020DAE1 		ldrh	r2, [sl, #0]
 5004 2d20 030C52E3 		cmp	r2, #768
 5005 2d24 CD00000A 		beq	.L424
 5006 2d28 0F00008A 		bhi	.L427
 5007 2d2c 010C52E3 		cmp	r2, #256
 5008 2d30 8600000A 		beq	.L422
 5009 2d34 020C52E3 		cmp	r2, #512
 5010 2d38 8BFFFF1A 		bne	.L421
3524:../uvc.c      ****             switch (bRequest)
 5011              		.loc 1 3524 0
 5012 2d3c 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5013 2d40 810053E3 		cmp	r3, #129
 5014 2d44 8301000A 		beq	.L493
 5015 2d48 D100008A 		bhi	.L442
 5016 2d4c 010053E3 		cmp	r3, #1
 5017 2d50 7101000A 		beq	.L541
 5018              	.L469:
3737:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5019              		.loc 1 3737 0
 5020 2d54 0000A0E3 		mov	r0, #0
 5021 2d58 0110A0E3 		mov	r1, #1
 5022 2d5c 0020A0E1 		mov	r2, r0
 5023 2d60 FEFFFFEB 		bl	CyU3PUsbStall
 5024 2d64 28309DE5 		ldr	r3, [sp, #40]
 5025 2d68 84FFFFEA 		b	.L419
 5026              	.L427:
3459:../uvc.c      ****     switch (wValue)
 5027              		.loc 1 3459 0
 5028 2d6c 010B52E3 		cmp	r2, #1024
 5029 2d70 6100000A 		beq	.L425
 5030 2d74 050C52E3 		cmp	r2, #1280
 5031 2d78 7BFFFF1A 		bne	.L421
3744:../uvc.c      ****             	switch (bRequest)
 5032              		.loc 1 3744 0
 5033 2d7c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5034 2d80 810052E3 		cmp	r2, #129
 5035 2d84 7301000A 		beq	.L493
 5036 2d88 4401008A 		bhi	.L496
 5037 2d8c 010052E3 		cmp	r2, #1
 5038 2d90 75FFFF1A 		bne	.L421
3769:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5039              		.loc 1 3769 0
 5040 2d94 2000A0E3 		mov	r0, #32
 5041 2d98 781A9FE5 		ldr	r1, .L546+44
 5042 2d9c 2E208DE2 		add	r2, sp, #46
 5043 2da0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5044              	.LVL390:
3771:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5045              		.loc 1 3771 0
 5046 2da4 000050E3 		cmp	r0, #0
 5047 2da8 5501001A 		bne	.L498
3775:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5048              		.loc 1 3775 0
 5049 2dac 0020A0E3 		mov	r2, #0
 5050 2db0 340A9FE5 		ldr	r0, .L546
 5051              	.LVL391:
 5052 2db4 8010A0E3 		mov	r1, #128
 5053 2db8 FEFFFFEB 		bl	_txe_event_flags_set
 5054              	.LVL392:
3776:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5055              		.loc 1 3776 0
 5056 2dbc 002050E2 		subs	r2, r0, #0
3782:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5057              		.loc 1 3782 0
 5058 2dc0 0FC0E003 		mvneq	ip, #15
 5059 2dc4 3AC0C605 		streqb	ip, [r6, #58]
3776:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5060              		.loc 1 3776 0
 5061 2dc8 0200000A 		beq	.L500
3778:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5062              		.loc 1 3778 0
 5063 2dcc 481A9FE5 		ldr	r1, .L546+48
 5064 2dd0 0400A0E3 		mov	r0, #4
 5065              	.LVL393:
 5066 2dd4 FEFFFFEB 		bl	CyU3PDebugPrint
 5067              	.LVL394:
 5068              	.L500:
3785:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5069              		.loc 1 3785 0
 5070 2dd8 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
 5071 2ddc 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5072 2de0 BE22DDE1 		ldrh	r2, [sp, #46]
 5073              	.LVL395:
 5074 2de4 0400A0E3 		mov	r0, #4
 5075 2de8 301A9FE5 		ldr	r1, .L546+52
 5076 2dec 00E08DE5 		str	lr, [sp, #0]
 5077 2df0 FEFFFFEB 		bl	CyU3PDebugPrint
 5078 2df4 28309DE5 		ldr	r3, [sp, #40]
 5079 2df8 60FFFFEA 		b	.L419
 5080              	.LVL396:
 5081              	.L539:
 5082              	.LBE114:
 5083              	.LBE132:
3959:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5084              		.loc 1 3959 0
 5085 2dfc 003097E5 		ldr	r3, [r7, #0]
 5086 2e00 0290A0E3 		mov	r9, #2
 5087 2e04 0090C3E5 		strb	r9, [r3, #0]
3960:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5088              		.loc 1 3960 0
 5089 2e08 002097E5 		ldr	r2, [r7, #0]
 5090 2e0c 0190A0E3 		mov	r9, #1
 5091 2e10 0190C2E5 		strb	r9, [r2, #1]
3961:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5092              		.loc 1 3961 0
 5093 2e14 001097E5 		ldr	r1, [r7, #0]
 5094 2e18 0030A0E3 		mov	r3, #0
 5095 2e1c 0230C1E5 		strb	r3, [r1, #2]
3962:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5096              		.loc 1 3962 0
 5097 2e20 000097E5 		ldr	r0, [r7, #0]
3968:../uvc.c      **** 					interStabuf.count = 4;
 5098              		.loc 1 3968 0
 5099 2e24 0420A0E3 		mov	r2, #4	@ movhi
3962:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5100              		.loc 1 3962 0
 5101 2e28 0330C0E5 		strb	r3, [r0, #3]
3964:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5102              		.loc 1 3964 0
 5103 2e2c 00E097E5 		ldr	lr, [r7, #0]
3965:../uvc.c      **** 					interStabuf.size   = 1024;
 5104              		.loc 1 3965 0
 5105 2e30 01CBA0E3 		mov	ip, #1024	@ movhi
3971:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5106              		.loc 1 3971 0
 5107 2e34 0010E0E3 		mvn	r1, #0
 5108 2e38 C8099FE5 		ldr	r0, .L546+28
3968:../uvc.c      **** 					interStabuf.count = 4;
 5109              		.loc 1 3968 0
 5110 2e3c BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3964:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5111              		.loc 1 3964 0
 5112 2e40 18E08DE5 		str	lr, [sp, #24]
3965:../uvc.c      **** 					interStabuf.size   = 1024;
 5113              		.loc 1 3965 0
 5114 2e44 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3966:../uvc.c      **** 					interStabuf.status = 0;
 5115              		.loc 1 3966 0
 5116 2e48 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3971:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5117              		.loc 1 3971 0
 5118 2e4c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3974:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5119              		.loc 1 3974 0
 5120 2e50 B0099FE5 		ldr	r0, .L546+28
 5121 2e54 18108DE2 		add	r1, sp, #24
 5122 2e58 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5123              	.LVL397:
3976:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5124              		.loc 1 3976 0
 5125 2e5c 002050E2 		subs	r2, r0, #0
 5126 2e60 D800001A 		bne	.L542
3981:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5127              		.loc 1 3981 0
 5128 2e64 3010A0E3 		mov	r1, #48
 5129 2e68 0500A0E3 		mov	r0, #5
 5130              	.LVL398:
 5131 2e6c FEFFFFEB 		bl	SensorSetControl
 5132              	.LVL399:
3983:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5133              		.loc 1 3983 0
 5134 2e70 78C99FE5 		ldr	ip, .L546+4
 5135 2e74 0B97CCE5 		strb	r9, [ip, #1803]
4108:../uvc.c      ****         CyU3PThreadRelinquish ();
 5136              		.loc 1 4108 0
 5137 2e78 FEFFFFEB 		bl	_txe_thread_relinquish
 5138 2e7c 07FFFFEA 		b	.L506
 5139              	.L373:
 5140              	.LBB133:
 5141              	.LBB93:
3058:../uvc.c      ****     switch (wValue)
 5142              		.loc 1 3058 0
 5143 2e80 0A0C52E3 		cmp	r2, #2560
 5144 2e84 1A01000A 		beq	.L370
 5145 2e88 FA00008A 		bhi	.L375
 5146 2e8c 070C52E3 		cmp	r2, #1792
 5147 2e90 1301000A 		beq	.L368
 5148 2e94 020B52E3 		cmp	r2, #2048
 5149 2e98 25FFFF1A 		bne	.L376
 5150              	.LVL400:
3089:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5151              		.loc 1 3089 0
 5152 2e9c 0700A0E3 		mov	r0, #7
 5153 2ea0 FEFFFFEB 		bl	ControlHandle
 5154              	.LVL401:
 5155 2ea4 28309DE5 		ldr	r3, [sp, #40]
 5156 2ea8 2AFFFFEA 		b	.L355
 5157              	.L388:
 5158              	.LBE93:
 5159              	.LBE133:
 5160              	.LBB134:
 5161              	.LBB102:
3133:../uvc.c      ****     switch (wValue)
 5162              		.loc 1 3133 0
 5163 2eac 090C52E3 		cmp	r2, #2304
 5164 2eb0 A901000A 		beq	.L384
 5165 2eb4 D500008A 		bhi	.L390
 5166 2eb8 070C52E3 		cmp	r2, #1792
 5167 2ebc A201000A 		beq	.L383
 5168 2ec0 020B52E3 		cmp	r2, #2048
 5169 2ec4 1AFFFF1A 		bne	.L376
 5170 2ec8 22FFFFEA 		b	.L355
 5171              	.L413:
 5172              	.LBE102:
 5173              	.LBE134:
 5174              	.LBB135:
 5175              	.LBB126:
3358:../uvc.c      ****     switch (wValue)
 5176              		.loc 1 3358 0
 5177 2ecc 0F0C53E3 		cmp	r3, #3840
 5178 2ed0 9901000A 		beq	.L408
 5179 2ed4 A100008A 		bhi	.L416
 5180 2ed8 0B0C53E3 		cmp	r3, #2816
 5181 2edc FC00000A 		beq	.L405
 5182 2ee0 9600008A 		bhi	.L417
 5183 2ee4 0A0C53E3 		cmp	r3, #2560
 5184 2ee8 15FFFF1A 		bne	.L356
 5185              	.LVL402:
3399:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5186              		.loc 1 3399 0
 5187 2eec 1900A0E3 		mov	r0, #25
 5188 2ef0 FEFFFFEB 		bl	ControlHandle
 5189              	.LVL403:
 5190 2ef4 28309DE5 		ldr	r3, [sp, #40]
 5191 2ef8 16FFFFEA 		b	.L355
 5192              	.LVL404:
 5193              	.L425:
 5194              	.LBE126:
 5195              	.LBE135:
 5196              	.LBB136:
 5197              	.LBB112:
3658:../uvc.c      ****                 switch (bRequest)
 5198              		.loc 1 3658 0
 5199 2efc 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5200 2f00 810052E3 		cmp	r2, #129
 5201 2f04 5A00000A 		beq	.L471
 5202 2f08 2100008A 		bhi	.L474
 5203 2f0c 010052E3 		cmp	r2, #1
 5204 2f10 8FFFFF1A 		bne	.L469
3683:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5205              		.loc 1 3683 0
 5206 2f14 2000A0E3 		mov	r0, #32
 5207 2f18 F8189FE5 		ldr	r1, .L546+44
 5208 2f1c 2E208DE2 		add	r2, sp, #46
 5209 2f20 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5210              	.LVL405:
3685:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5211              		.loc 1 3685 0
 5212 2f24 000050E3 		cmp	r0, #0
 5213 2f28 13FFFF1A 		bne	.L525
3704:../uvc.c      ****                            switch (glCommitCtrl[1])
 5214              		.loc 1 3704 0
 5215 2f2c 8120D6E5 		ldrb	r2, [r6, #129]	@ zero_extendqisi2
 5216 2f30 011042E2 		sub	r1, r2, #1
 5217 2f34 030051E3 		cmp	r1, #3
 5218 2f38 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5219 2f3c C90100EA 		b	.L477
 5220              	.L482:
 5221 2f40 D4360000 		.word	.L478
 5222 2f44 28370000 		.word	.L479
 5223 2f48 90360000 		.word	.L480
 5224 2f4c 28360000 		.word	.L481
 5225              	.LVL406:
 5226              	.L422:
3462:../uvc.c      ****             switch (bRequest)
 5227              		.loc 1 3462 0
 5228 2f50 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5229 2f54 830052E3 		cmp	r2, #131
 5230 2f58 3100008A 		bhi	.L433
 5231 2f5c 810052E3 		cmp	r2, #129
 5232 2f60 1600003A 		bcc	.L543
 5233              	.L430:
3477:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5234              		.loc 1 3477 0
 5235 2f64 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5236 2f68 030053E3 		cmp	r3, #3
 5237 2f6c FC00001A 		bne	.L497
3479:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5238              		.loc 1 3479 0
 5239 2f70 AC189FE5 		ldr	r1, .L546+56
 5240 2f74 1A00A0E3 		mov	r0, #26
 5241 2f78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3480:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5242              		.loc 1 3480 0
 5243 2f7c 0400A0E3 		mov	r0, #4
 5244 2f80 A0189FE5 		ldr	r1, .L546+60
 5245 2f84 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5246 2f88 FEFFFFEB 		bl	CyU3PDebugPrint
 5247 2f8c 28309DE5 		ldr	r3, [sp, #40]
 5248 2f90 FAFEFFEA 		b	.L419
 5249              	.L474:
3658:../uvc.c      ****                 switch (bRequest)
 5250              		.loc 1 3658 0
 5251 2f94 850052E3 		cmp	r2, #133
 5252 2f98 2700000A 		beq	.L472
 5253 2f9c 860052E3 		cmp	r2, #134
 5254 2fa0 6BFFFF1A 		bne	.L469
 5255              	.L529:
3662:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5256              		.loc 1 3662 0
 5257 2fa4 0300A0E1 		mov	r0, r3
 5258              	.L524:
3528:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5259              		.loc 1 3528 0
 5260 2fa8 7C189FE5 		ldr	r1, .L546+64
3527:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5261              		.loc 1 3527 0
 5262 2fac 0390A0E3 		mov	r9, #3
 5263 2fb0 5C90C4E5 		strb	r9, [r4, #92]
3528:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5264              		.loc 1 3528 0
 5265 2fb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5266 2fb8 28309DE5 		ldr	r3, [sp, #40]
 5267 2fbc EFFEFFEA 		b	.L419
 5268              	.L543:
3462:../uvc.c      ****             switch (bRequest)
 5269              		.loc 1 3462 0
 5270 2fc0 010052E3 		cmp	r2, #1
 5271 2fc4 62FFFF1A 		bne	.L469
3489:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5272              		.loc 1 3489 0
 5273 2fc8 2000A0E3 		mov	r0, #32
 5274 2fcc 44189FE5 		ldr	r1, .L546+44
 5275 2fd0 2E208DE2 		add	r2, sp, #46
 5276 2fd4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5277              	.LVL407:
3491:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5278              		.loc 1 3491 0
 5279 2fd8 000050E3 		cmp	r0, #0
 5280 2fdc E6FEFF1A 		bne	.L525
3493:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5281              		.loc 1 3493 0
 5282 2fe0 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5283 2fe4 030051E3 		cmp	r1, #3
 5284 2fe8 E3FEFF1A 		bne	.L525
3500:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5285              		.loc 1 3500 0
 5286 2fec 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3497:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5287              		.loc 1 3497 0
 5288 2ff0 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3498:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5289              		.loc 1 3498 0
 5290 2ff4 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3499:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5291              		.loc 1 3499 0
 5292 2ff8 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 5293              	.LVL408:
3501:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5294              		.loc 1 3501 0
 5295 2ffc 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3502:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5296              		.loc 1 3502 0
 5297 3000 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3500:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5298              		.loc 1 3500 0
 5299 3004 A536C5E5 		strb	r3, [r5, #1701]
3497:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5300              		.loc 1 3497 0
 5301 3008 A2E6C5E5 		strb	lr, [r5, #1698]
3498:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5302              		.loc 1 3498 0
 5303 300c A3C6C5E5 		strb	ip, [r5, #1699]
3499:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5304              		.loc 1 3499 0
 5305 3010 A406C5E5 		strb	r0, [r5, #1700]
3501:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5306              		.loc 1 3501 0
 5307 3014 A626C5E5 		strb	r2, [r5, #1702]
3502:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5308              		.loc 1 3502 0
 5309 3018 A796C5E5 		strb	r9, [r5, #1703]
 5310 301c 28309DE5 		ldr	r3, [sp, #40]
 5311 3020 D6FEFFEA 		b	.L419
 5312              	.LVL409:
 5313              	.L433:
3462:../uvc.c      ****             switch (bRequest)
 5314              		.loc 1 3462 0
 5315 3024 860052E3 		cmp	r2, #134
 5316 3028 DDFFFF0A 		beq	.L529
 5317 302c 870052E3 		cmp	r2, #135
 5318 3030 CBFFFF0A 		beq	.L430
 5319              	.L534:
3608:../uvc.c      ****                 switch (bRequest)
 5320              		.loc 1 3608 0
 5321 3034 850052E3 		cmp	r2, #133
 5322 3038 45FFFF1A 		bne	.L469
 5323              	.L472:
3667:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5324              		.loc 1 3667 0
 5325 303c E8179FE5 		ldr	r1, .L546+64
 5326 3040 0200A0E3 		mov	r0, #2
3665:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 5327              		.loc 1 3665 0
 5328 3044 1A30A0E3 		mov	r3, #26
 5329              	.L526:
3752:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5330              		.loc 1 3752 0
 5331 3048 0090A0E3 		mov	r9, #0
3751:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5332              		.loc 1 3751 0
 5333 304c 5C30C4E5 		strb	r3, [r4, #92]
3752:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5334              		.loc 1 3752 0
 5335 3050 5D90C4E5 		strb	r9, [r4, #93]
3753:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5336              		.loc 1 3753 0
 5337 3054 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5338 3058 28309DE5 		ldr	r3, [sp, #40]
 5339 305c C7FEFFEA 		b	.L419
 5340              	.L424:
3608:../uvc.c      ****                 switch (bRequest)
 5341              		.loc 1 3608 0
 5342 3060 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5343 3064 830052E3 		cmp	r2, #131
 5344 3068 2F00008A 		bhi	.L465
 5345 306c 810052E3 		cmp	r2, #129
 5346 3070 0D00003A 		bcc	.L544
 5347              	.L471:
3670:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5348              		.loc 1 3670 0
 5349 3074 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3672:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5350              		.loc 1 3672 0
 5351 3078 0B00A0E3 		mov	r0, #11
3670:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5352              		.loc 1 3670 0
 5353 307c 030053E3 		cmp	r3, #3
3672:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5354              		.loc 1 3672 0
 5355 3080 A8179F05 		ldreq	r1, .L546+68
3676:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5356              		.loc 1 3676 0
 5357 3084 A8179F15 		ldrne	r1, .L546+72
 5358 3088 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5359 308c 28309DE5 		ldr	r3, [sp, #40]
 5360 3090 BAFEFFEA 		b	.L419
 5361              	.L442:
3524:../uvc.c      ****             switch (bRequest)
 5362              		.loc 1 3524 0
 5363 3094 850053E3 		cmp	r3, #133
 5364 3098 E7FFFF0A 		beq	.L472
 5365 309c 860053E3 		cmp	r3, #134
 5366 30a0 2BFFFF1A 		bne	.L469
 5367              	.L530:
3528:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5368              		.loc 1 3528 0
 5369 30a4 0100A0E3 		mov	r0, #1
 5370 30a8 BEFFFFEA 		b	.L524
 5371              	.L544:
3608:../uvc.c      ****                 switch (bRequest)
 5372              		.loc 1 3608 0
 5373 30ac 010052E3 		cmp	r2, #1
 5374 30b0 27FFFF1A 		bne	.L469
3633:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5375              		.loc 1 3633 0
 5376 30b4 2000A0E3 		mov	r0, #32
 5377 30b8 58179FE5 		ldr	r1, .L546+44
 5378 30bc 2E208DE2 		add	r2, sp, #46
 5379 30c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5380              	.LVL410:
3635:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5381              		.loc 1 3635 0
 5382 30c4 000050E3 		cmp	r0, #0
 5383 30c8 ABFEFF1A 		bne	.L525
3637:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5384              		.loc 1 3637 0
 5385 30cc 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5386 30d0 030051E3 		cmp	r1, #3
 5387 30d4 0B00001A 		bne	.L468
3641:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5388              		.loc 1 3641 0
 5389 30d8 81E0D6E5 		ldrb	lr, [r6, #129]	@ zero_extendqisi2
3642:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5390              		.loc 1 3642 0
 5391 30dc 82C0D6E5 		ldrb	ip, [r6, #130]	@ zero_extendqisi2
3643:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5392              		.loc 1 3643 0
 5393 30e0 8300D6E5 		ldrb	r0, [r6, #131]	@ zero_extendqisi2
 5394              	.LVL411:
3644:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5395              		.loc 1 3644 0
 5396 30e4 8420D6E5 		ldrb	r2, [r6, #132]	@ zero_extendqisi2
3645:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5397              		.loc 1 3645 0
 5398 30e8 8590D6E5 		ldrb	r9, [r6, #133]	@ zero_extendqisi2
3646:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5399              		.loc 1 3646 0
 5400 30ec 8630D6E5 		ldrb	r3, [r6, #134]	@ zero_extendqisi2
3641:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5401              		.loc 1 3641 0
 5402 30f0 F5E6C5E5 		strb	lr, [r5, #1781]
3642:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5403              		.loc 1 3642 0
 5404 30f4 F6C6C5E5 		strb	ip, [r5, #1782]
3643:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5405              		.loc 1 3643 0
 5406 30f8 F706C5E5 		strb	r0, [r5, #1783]
3644:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5407              		.loc 1 3644 0
 5408 30fc F826C5E5 		strb	r2, [r5, #1784]
3645:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5409              		.loc 1 3645 0
 5410 3100 F996C5E5 		strb	r9, [r5, #1785]
3646:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5411              		.loc 1 3646 0
 5412 3104 FA36C5E5 		strb	r3, [r5, #1786]
 5413              	.L468:
3648:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 5414              		.loc 1 3648 0
 5415 3108 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 5416 310c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5417 3110 BE22DDE1 		ldrh	r2, [sp, #46]
 5418              	.LVL412:
 5419 3114 0400A0E3 		mov	r0, #4
 5420 3118 18179FE5 		ldr	r1, .L546+76
 5421 311c 00908DE5 		str	r9, [sp, #0]
 5422 3120 FEFFFFEB 		bl	CyU3PDebugPrint
 5423 3124 28309DE5 		ldr	r3, [sp, #40]
 5424 3128 94FEFFEA 		b	.L419
 5425              	.LVL413:
 5426              	.L465:
3608:../uvc.c      ****                 switch (bRequest)
 5427              		.loc 1 3608 0
 5428 312c 860052E3 		cmp	r2, #134
 5429 3130 9BFFFF0A 		beq	.L529
 5430 3134 870052E3 		cmp	r2, #135
 5431 3138 BDFFFF1A 		bne	.L534
 5432 313c CCFFFFEA 		b	.L471
 5433              	.LVL414:
 5434              	.L417:
 5435              	.LBE112:
 5436              	.LBE136:
 5437              	.LBB137:
 5438              	.LBB124:
3358:../uvc.c      ****     switch (wValue)
 5439              		.loc 1 3358 0
 5440 3140 030B53E3 		cmp	r3, #3072
 5441 3144 A401000A 		beq	.L406
 5442 3148 0D0C53E3 		cmp	r3, #3328
 5443 314c 7CFEFF1A 		bne	.L356
 5444              	.LVL415:
3415:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5445              		.loc 1 3415 0
 5446 3150 1C00A0E3 		mov	r0, #28
 5447 3154 FEFFFFEB 		bl	ControlHandle
 5448              	.LVL416:
 5449 3158 28309DE5 		ldr	r3, [sp, #40]
 5450 315c 7DFEFFEA 		b	.L355
 5451              	.L416:
3358:../uvc.c      ****     switch (wValue)
 5452              		.loc 1 3358 0
 5453 3160 110C53E3 		cmp	r3, #4352
 5454 3164 9801000A 		beq	.L410
 5455 3168 5100008A 		bhi	.L418
 5456 316c 010A53E3 		cmp	r3, #4096
 5457 3170 73FEFF1A 		bne	.L356
 5458              	.LVL417:
3427:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 5459              		.loc 1 3427 0
 5460 3174 1F00A0E3 		mov	r0, #31
 5461 3178 FEFFFFEB 		bl	ControlHandle
 5462              	.LVL418:
 5463 317c 28309DE5 		ldr	r3, [sp, #40]
 5464 3180 74FEFFEA 		b	.L355
 5465              	.LVL419:
 5466              	.L540:
 5467              	.LBE124:
 5468              	.LBE137:
4005:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5469              		.loc 1 4005 0
 5470 3184 0400A0E3 		mov	r0, #4
 5471              	.LVL420:
 5472 3188 AC169FE5 		ldr	r1, .L546+80
 5473 318c FEFFFFEB 		bl	CyU3PDebugPrint
 5474              	.LVL421:
 5475              	.L505:
 5476              	.LBB138:
 5477              	.LBB139:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5478              		.loc 1 1767 0
 5479 3190 A8169FE5 		ldr	r1, .L546+84
 5480 3194 0400A0E3 		mov	r0, #4
 5481 3198 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 5482              		.loc 1 1768 0
 5483 319c FA0FA0E3 		mov	r0, #1000
 5484 31a0 FEFFFFEB 		bl	_tx_thread_sleep
 5485 31a4 F9FFFFEA 		b	.L505
 5486              	.L374:
 5487              	.LBE139:
 5488              	.LBE138:
 5489              	.LBB140:
 5490              	.LBB95:
3058:../uvc.c      ****     switch (wValue)
 5491              		.loc 1 3058 0
 5492 31a8 010B52E3 		cmp	r2, #1024
 5493 31ac 69FEFF0A 		beq	.L355
 5494 31b0 050C52E3 		cmp	r2, #1280
 5495 31b4 5EFEFF1A 		bne	.L376
 5496              	.LVL422:
3077:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5497              		.loc 1 3077 0
 5498 31b8 0400A0E3 		mov	r0, #4
 5499 31bc FEFFFFEB 		bl	ControlHandle
 5500              	.LVL423:
 5501 31c0 28309DE5 		ldr	r3, [sp, #40]
 5502 31c4 63FEFFEA 		b	.L355
 5503              	.LVL424:
 5504              	.L542:
 5505              	.LBE95:
 5506              	.LBE140:
3978:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5507              		.loc 1 3978 0
 5508 31c8 0400A0E3 		mov	r0, #4
 5509              	.LVL425:
 5510 31cc 68169FE5 		ldr	r1, .L546+80
 5511 31d0 FEFFFFEB 		bl	CyU3PDebugPrint
 5512              	.LVL426:
 5513              	.L503:
 5514              	.LBB141:
 5515              	.LBB142:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5516              		.loc 1 1767 0
 5517 31d4 64169FE5 		ldr	r1, .L546+84
 5518 31d8 0400A0E3 		mov	r0, #4
 5519 31dc FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 5520              		.loc 1 1768 0
 5521 31e0 FA0FA0E3 		mov	r0, #1000
 5522 31e4 FEFFFFEB 		bl	_tx_thread_sleep
 5523 31e8 F9FFFFEA 		b	.L503
 5524              	.L414:
 5525              	.LBE142:
 5526              	.LBE141:
 5527              	.LBB143:
 5528              	.LBB127:
3358:../uvc.c      ****     switch (wValue)
 5529              		.loc 1 3358 0
 5530 31ec 060C53E3 		cmp	r3, #1536
 5531 31f0 7101000A 		beq	.L400
 5532 31f4 0F00008A 		bhi	.L415
 5533 31f8 050C53E3 		cmp	r3, #1280
 5534 31fc 50FEFF1A 		bne	.L356
 5535              	.LVL427:
3378:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5536              		.loc 1 3378 0
 5537 3200 1400A0E3 		mov	r0, #20
 5538 3204 FEFFFFEB 		bl	ControlHandle
 5539              	.LVL428:
 5540 3208 28309DE5 		ldr	r3, [sp, #40]
 5541 320c 51FEFFEA 		b	.L355
 5542              	.L390:
 5543              	.LBE127:
 5544              	.LBE143:
 5545              	.LBB144:
 5546              	.LBB105:
3133:../uvc.c      ****     switch (wValue)
 5547              		.loc 1 3133 0
 5548 3210 0B0C52E3 		cmp	r2, #2816
 5549 3214 6401000A 		beq	.L386
 5550 3218 030B52E3 		cmp	r2, #3072
 5551 321c 5E01000A 		beq	.L387
 5552 3220 0A0C52E3 		cmp	r2, #2560
 5553 3224 42FEFF1A 		bne	.L376
 5554              	.LVL429:
3174:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5555              		.loc 1 3174 0
 5556 3228 0800A0E3 		mov	r0, #8
 5557 322c FEFFFFEB 		bl	CTControlHandle
 5558              	.LVL430:
 5559 3230 28309DE5 		ldr	r3, [sp, #40]
 5560 3234 47FEFFEA 		b	.L355
 5561              	.L415:
 5562              	.LBE105:
 5563              	.LBE144:
 5564              	.LBB145:
 5565              	.LBB123:
3358:../uvc.c      ****     switch (wValue)
 5566              		.loc 1 3358 0
 5567 3238 070C53E3 		cmp	r3, #1792
 5568 323c 5201000A 		beq	.L401
 5569 3240 020B53E3 		cmp	r3, #2048
 5570 3244 3EFEFF1A 		bne	.L356
 5571              	.LVL431:
3390:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5572              		.loc 1 3390 0
 5573 3248 1700A0E3 		mov	r0, #23
 5574 324c FEFFFFEB 		bl	ControlHandle
 5575              	.LVL432:
 5576 3250 28309DE5 		ldr	r3, [sp, #40]
 5577 3254 3FFEFFEA 		b	.L355
 5578              	.L389:
 5579              	.LBE123:
 5580              	.LBE145:
 5581              	.LBB146:
 5582              	.LBB101:
3133:../uvc.c      ****     switch (wValue)
 5583              		.loc 1 3133 0
 5584 3258 010B52E3 		cmp	r2, #1024
 5585 325c 4601000A 		beq	.L380
 5586 3260 050C52E3 		cmp	r2, #1280
 5587 3264 32FEFF1A 		bne	.L376
 5588              	.LVL433:
3155:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 5589              		.loc 1 3155 0
 5590 3268 0400A0E3 		mov	r0, #4
 5591 326c FEFFFFEB 		bl	CTControlHandle
 5592              	.LVL434:
 5593 3270 28309DE5 		ldr	r3, [sp, #40]
 5594 3274 37FEFFEA 		b	.L355
 5595              	.L375:
 5596              	.LBE101:
 5597              	.LBE146:
 5598              	.LBB147:
 5599              	.LBB92:
3058:../uvc.c      ****     switch (wValue)
 5600              		.loc 1 3058 0
 5601 3278 0D0C52E3 		cmp	r2, #3328
 5602 327c 1C00000A 		beq	.L370
 5603 3280 0E0C52E3 		cmp	r2, #3584
 5604 3284 D700000A 		beq	.L372
 5605 3288 030B52E3 		cmp	r2, #3072
 5606 328c 28FEFF1A 		bne	.L376
 5607              	.LVL435:
3099:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5608              		.loc 1 3099 0
 5609 3290 0B00A0E3 		mov	r0, #11
 5610 3294 FEFFFFEB 		bl	ControlHandle
 5611              	.LVL436:
 5612 3298 28309DE5 		ldr	r3, [sp, #40]
 5613 329c 2DFEFFEA 		b	.L355
 5614              	.LVL437:
 5615              	.L496:
 5616              	.LBE92:
 5617              	.LBE147:
 5618              	.LBB148:
 5619              	.LBB115:
3744:../uvc.c      ****             	switch (bRequest)
 5620              		.loc 1 3744 0
 5621 32a0 850052E3 		cmp	r2, #133
 5622 32a4 CC00000A 		beq	.L494
 5623 32a8 860052E3 		cmp	r2, #134
 5624 32ac 2EFEFF1A 		bne	.L421
 5625 32b0 7BFFFFEA 		b	.L530
 5626              	.LVL438:
 5627              	.L418:
 5628              	.LBE115:
 5629              	.LBE148:
 5630              	.LBB149:
 5631              	.LBB128:
3358:../uvc.c      ****     switch (wValue)
 5632              		.loc 1 3358 0
 5633 32b4 120C53E3 		cmp	r3, #4608
 5634 32b8 C300000A 		beq	.L411
 5635 32bc 130C53E3 		cmp	r3, #4864
 5636 32c0 1FFEFF1A 		bne	.L356
 5637              	.LVL439:
3439:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 5638              		.loc 1 3439 0
 5639 32c4 2600A0E3 		mov	r0, #38
 5640 32c8 FEFFFFEB 		bl	ControlHandle
 5641              	.LVL440:
 5642 32cc 28309DE5 		ldr	r3, [sp, #40]
 5643 32d0 20FEFFEA 		b	.L355
 5644              	.L405:
 5645              	.LVL441:
3405:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5646              		.loc 1 3405 0
 5647 32d4 1A00A0E3 		mov	r0, #26
 5648 32d8 FEFFFFEB 		bl	ControlHandle
 5649              	.LVL442:
 5650 32dc 28309DE5 		ldr	r3, [sp, #40]
 5651 32e0 1CFEFFEA 		b	.L355
 5652              	.L368:
 5653              	.LVL443:
 5654              	.LBE128:
 5655              	.LBE149:
 5656              	.LBB150:
 5657              	.LBB96:
3085:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5658              		.loc 1 3085 0
 5659 32e4 0600A0E3 		mov	r0, #6
 5660 32e8 FEFFFFEB 		bl	ControlHandle
 5661              	.LVL444:
 5662 32ec 28309DE5 		ldr	r3, [sp, #40]
 5663 32f0 18FEFFEA 		b	.L355
 5664              	.L370:
 5665              	.LVL445:
3095:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5666              		.loc 1 3095 0
 5667 32f4 0900A0E3 		mov	r0, #9
 5668 32f8 FEFFFFEB 		bl	ControlHandle
 5669              	.LVL446:
 5670 32fc 28309DE5 		ldr	r3, [sp, #40]
 5671 3300 14FEFFEA 		b	.L355
 5672              	.LVL447:
 5673              	.L498:
 5674              	.LBE96:
 5675              	.LBE150:
 5676              	.LBB151:
 5677              	.LBB111:
3787:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5678              		.loc 1 3787 0
 5679 3304 38159FE5 		ldr	r1, .L546+88
 5680 3308 BE22DDE1 		ldrh	r2, [sp, #46]
 5681 330c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5682 3310 0400A0E3 		mov	r0, #4
 5683              	.LVL448:
 5684 3314 FEFFFFEB 		bl	CyU3PDebugPrint
 5685 3318 13FEFFEA 		b	.L421
 5686              	.LVL449:
 5687              	.L541:
3549:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5688              		.loc 1 3549 0
 5689 331c 2000A0E3 		mov	r0, #32
 5690 3320 F0149FE5 		ldr	r1, .L546+44
 5691 3324 2E208DE2 		add	r2, sp, #46
 5692 3328 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5693              	.LVL450:
3551:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5694              		.loc 1 3551 0
 5695 332c 000050E3 		cmp	r0, #0
 5696 3330 11FEFF1A 		bne	.L525
3553:../uvc.c      ****                         switch (glCommitCtrl[3])
 5697              		.loc 1 3553 0
 5698 3334 8320D4E5 		ldrb	r2, [r4, #131]	@ zero_extendqisi2
 5699 3338 011042E2 		sub	r1, r2, #1
 5700 333c 030051E3 		cmp	r1, #3
 5701 3340 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5702 3344 2E0000EA 		b	.L445
 5703              	.L450:
 5704 3348 A4340000 		.word	.L446
 5705 334c F0340000 		.word	.L447
 5706 3350 48340000 		.word	.L448
 5707 3354 AC330000 		.word	.L449
 5708              	.LVL451:
 5709              	.L493:
3756:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5710              		.loc 1 3756 0
 5711 3358 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5712 335c 030051E3 		cmp	r1, #3
 5713 3360 0400000A 		beq	.L545
 5714              	.L497:
3762:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5715              		.loc 1 3762 0
 5716 3364 1A00A0E3 		mov	r0, #26
 5717 3368 D8149FE5 		ldr	r1, .L546+92
 5718 336c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5719 3370 28309DE5 		ldr	r3, [sp, #40]
 5720 3374 01FEFFEA 		b	.L419
 5721              	.L545:
3758:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5722              		.loc 1 3758 0
 5723 3378 1A00A0E3 		mov	r0, #26
 5724 337c C8149FE5 		ldr	r1, .L546+96
 5725 3380 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5726 3384 28309DE5 		ldr	r3, [sp, #40]
 5727 3388 FCFDFFEA 		b	.L419
 5728              	.LVL452:
 5729              	.L397:
 5730              	.LBE111:
 5731              	.LBE151:
 5732              	.LBB152:
 5733              	.LBB122:
3370:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5734              		.loc 1 3370 0
 5735 338c 1200A0E3 		mov	r0, #18
 5736 3390 FEFFFFEB 		bl	ControlHandle
 5737              	.LVL453:
 5738 3394 28309DE5 		ldr	r3, [sp, #40]
 5739 3398 EEFDFFEA 		b	.L355
 5740              	.L396:
 5741              	.LVL454:
3366:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5742              		.loc 1 3366 0
 5743 339c 1100A0E3 		mov	r0, #17
 5744 33a0 FEFFFFEB 		bl	ControlHandle
 5745              	.LVL455:
 5746 33a4 28309DE5 		ldr	r3, [sp, #40]
 5747 33a8 EAFDFFEA 		b	.L355
 5748              	.LVL456:
 5749              	.L449:
 5750              	.LBE122:
 5751              	.LBE152:
 5752              	.LBB153:
 5753              	.LBB116:
3571:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 5754              		.loc 1 3571 0
 5755 33ac 58C094E5 		ldr	ip, [r4, #88]
 5756 33b0 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 5757              	.LVL457:
 5758 33b4 00005CE3 		cmp	ip, #0
 5759 33b8 F4C0A003 		moveq	ip, #244
 5760 33bc 74C0A013 		movne	ip, #116
 5761 33c0 00208CE1 		orr	r2, ip, r0
 5762 33c4 3010A0E3 		mov	r1, #48
 5763 33c8 5230A0E3 		mov	r3, #82
 5764 33cc 0100A0E3 		mov	r0, #1
 5765 33d0 FEFFFFEB 		bl	SensorSetIrisControl
3572:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5766              		.loc 1 3572 0
 5767 33d4 7D0FA0E3 		mov	r0, #500
 5768 33d8 FEFFFFEB 		bl	_tx_thread_sleep
3573:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5769              		.loc 1 3573 0
 5770 33dc 582094E5 		ldr	r2, [r4, #88]
 5771 33e0 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 5772 33e4 000052E3 		cmp	r2, #0
 5773 33e8 F420A003 		moveq	r2, #244
 5774 33ec 7420A013 		movne	r2, #116
 5775 33f0 583094E5 		ldr	r3, [r4, #88]
 5776 33f4 0400A0E3 		mov	r0, #4
 5777 33f8 50149FE5 		ldr	r1, .L546+100
 5778 33fc 092082E1 		orr	r2, r2, r9
 5779 3400 FEFFFFEB 		bl	CyU3PDebugPrint
 5780              	.L445:
3578:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5781              		.loc 1 3578 0
 5782 3404 83E0D4E5 		ldrb	lr, [r4, #131]	@ zero_extendqisi2
3579:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5783              		.loc 1 3579 0
 5784 3408 44149FE5 		ldr	r1, .L546+104
 5785 340c 0E20A0E1 		mov	r2, lr
 5786 3410 0400A0E3 		mov	r0, #4
3578:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5787              		.loc 1 3578 0
 5788 3414 7DE0C4E5 		strb	lr, [r4, #125]
3579:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5789              		.loc 1 3579 0
 5790 3418 FEFFFFEB 		bl	CyU3PDebugPrint
3592:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5791              		.loc 1 3592 0
 5792 341c 0020A0E3 		mov	r2, #0
 5793 3420 C4039FE5 		ldr	r0, .L546
 5794 3424 0110A0E3 		mov	r1, #1
 5795 3428 FEFFFFEB 		bl	_txe_event_flags_set
 5796              	.LVL458:
3593:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5797              		.loc 1 3593 0
 5798 342c 002050E2 		subs	r2, r0, #0
 5799 3430 D1FDFF0A 		beq	.L525
3595:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5800              		.loc 1 3595 0
 5801 3434 0400A0E3 		mov	r0, #4
 5802              	.LVL459:
 5803 3438 18149FE5 		ldr	r1, .L546+108
 5804 343c FEFFFFEB 		bl	CyU3PDebugPrint
 5805              	.LVL460:
 5806 3440 28309DE5 		ldr	r3, [sp, #40]
 5807 3444 CDFDFFEA 		b	.L419
 5808              	.LVL461:
 5809              	.L448:
3566:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5810              		.loc 1 3566 0
 5811 3448 58E094E5 		ldr	lr, [r4, #88]
 5812 344c 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 5813 3450 00005EE3 		cmp	lr, #0
 5814 3454 C4E0A003 		moveq	lr, #196
 5815 3458 44E0A013 		movne	lr, #68
 5816 345c 03208EE1 		orr	r2, lr, r3
 5817 3460 3010A0E3 		mov	r1, #48
 5818 3464 5230A0E3 		mov	r3, #82
 5819 3468 0100A0E3 		mov	r0, #1
 5820              	.LVL462:
 5821 346c FEFFFFEB 		bl	SensorSetIrisControl
3567:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5822              		.loc 1 3567 0
 5823 3470 7D0FA0E3 		mov	r0, #500
 5824 3474 FEFFFFEB 		bl	_tx_thread_sleep
3568:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5825              		.loc 1 3568 0
 5826 3478 580094E5 		ldr	r0, [r4, #88]
 5827 347c 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 5828 3480 000050E3 		cmp	r0, #0
 5829 3484 C400A003 		moveq	r0, #196
 5830 3488 4400A013 		movne	r0, #68
 5831 348c 0C2080E1 		orr	r2, r0, ip
 5832 3490 583094E5 		ldr	r3, [r4, #88]
 5833 3494 B4139FE5 		ldr	r1, .L546+100
 5834 3498 0400A0E3 		mov	r0, #4
 5835 349c FEFFFFEB 		bl	CyU3PDebugPrint
 5836 34a0 D7FFFFEA 		b	.L445
 5837              	.LVL463:
 5838              	.L446:
3556:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5839              		.loc 1 3556 0
 5840 34a4 582094E5 		ldr	r2, [r4, #88]
 5841 34a8 3010A0E3 		mov	r1, #48
 5842 34ac 000052E3 		cmp	r2, #0
 5843 34b0 E420A003 		moveq	r2, #228
 5844 34b4 6420A013 		movne	r2, #100
 5845 34b8 5230A0E3 		mov	r3, #82
 5846 34bc 0100A0E3 		mov	r0, #1
 5847              	.LVL464:
 5848 34c0 FEFFFFEB 		bl	SensorSetIrisControl
3557:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5849              		.loc 1 3557 0
 5850 34c4 7D0FA0E3 		mov	r0, #500
 5851 34c8 FEFFFFEB 		bl	_tx_thread_sleep
3558:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5852              		.loc 1 3558 0
 5853 34cc 582094E5 		ldr	r2, [r4, #88]
 5854 34d0 78139FE5 		ldr	r1, .L546+100
 5855 34d4 000052E3 		cmp	r2, #0
 5856 34d8 583094E5 		ldr	r3, [r4, #88]
 5857 34dc E420A003 		moveq	r2, #228
 5858 34e0 6420A013 		movne	r2, #100
 5859 34e4 0400A0E3 		mov	r0, #4
 5860 34e8 FEFFFFEB 		bl	CyU3PDebugPrint
 5861 34ec C4FFFFEA 		b	.L445
 5862              	.LVL465:
 5863              	.L447:
3561:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5864              		.loc 1 3561 0
 5865 34f0 582094E5 		ldr	r2, [r4, #88]
 5866 34f4 3010A0E3 		mov	r1, #48
 5867 34f8 000052E3 		cmp	r2, #0
 5868 34fc D420A003 		moveq	r2, #212
 5869 3500 5420A013 		movne	r2, #84
 5870 3504 5230A0E3 		mov	r3, #82
 5871 3508 0100A0E3 		mov	r0, #1
 5872              	.LVL466:
 5873 350c FEFFFFEB 		bl	SensorSetIrisControl
3562:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5874              		.loc 1 3562 0
 5875 3510 7D0FA0E3 		mov	r0, #500
 5876 3514 FEFFFFEB 		bl	_tx_thread_sleep
3563:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5877              		.loc 1 3563 0
 5878 3518 582094E5 		ldr	r2, [r4, #88]
 5879 351c 2C139FE5 		ldr	r1, .L546+100
 5880 3520 000052E3 		cmp	r2, #0
 5881 3524 583094E5 		ldr	r3, [r4, #88]
 5882 3528 D420A003 		moveq	r2, #212
 5883 352c 5420A013 		movne	r2, #84
 5884 3530 0400A0E3 		mov	r0, #4
 5885 3534 FEFFFFEB 		bl	CyU3PDebugPrint
 5886 3538 B1FFFFEA 		b	.L445
 5887              	.L408:
 5888              	.LVL467:
 5889              	.LBE116:
 5890              	.LBE153:
 5891              	.LBB154:
 5892              	.LBB129:
3423:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5893              		.loc 1 3423 0
 5894 353c 1E00A0E3 		mov	r0, #30
 5895 3540 FEFFFFEB 		bl	ControlHandle
 5896              	.LVL468:
 5897 3544 28309DE5 		ldr	r3, [sp, #40]
 5898 3548 82FDFFEA 		b	.L355
 5899              	.L383:
 5900              	.LVL469:
 5901              	.LBE129:
 5902              	.LBE154:
 5903              	.LBB155:
 5904              	.LBB106:
3163:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5905              		.loc 1 3163 0
 5906 354c 0600A0E3 		mov	r0, #6
 5907 3550 FEFFFFEB 		bl	CTControlHandle
 5908              	.LVL470:
 5909 3554 28309DE5 		ldr	r3, [sp, #40]
 5910 3558 7EFDFFEA 		b	.L355
 5911              	.L384:
 5912              	.LVL471:
3169:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5913              		.loc 1 3169 0
 5914 355c 0700A0E3 		mov	r0, #7
 5915 3560 FEFFFFEB 		bl	CTControlHandle
 5916              	.LVL472:
 5917 3564 28309DE5 		ldr	r3, [sp, #40]
 5918 3568 7AFDFFEA 		b	.L355
 5919              	.L365:
 5920              	.LVL473:
 5921              	.LBE106:
 5922              	.LBE155:
 5923              	.LBB156:
 5924              	.LBB91:
3070:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5925              		.loc 1 3070 0
 5926 356c 0200A0E3 		mov	r0, #2
 5927 3570 FEFFFFEB 		bl	ControlHandle
 5928              	.LVL474:
 5929 3574 28309DE5 		ldr	r3, [sp, #40]
 5930 3578 76FDFFEA 		b	.L355
 5931              	.L367:
 5932              	.LVL475:
3081:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5933              		.loc 1 3081 0
 5934 357c 0500A0E3 		mov	r0, #5
 5935 3580 FEFFFFEB 		bl	ControlHandle
 5936              	.LVL476:
 5937 3584 28309DE5 		ldr	r3, [sp, #40]
 5938 3588 72FDFFEA 		b	.L355
 5939              	.L398:
 5940              	.LVL477:
 5941              	.LBE91:
 5942              	.LBE156:
 5943              	.LBB157:
 5944              	.LBB121:
3374:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5945              		.loc 1 3374 0
 5946 358c 1300A0E3 		mov	r0, #19
 5947 3590 FEFFFFEB 		bl	ControlHandle
 5948              	.LVL478:
 5949 3594 28309DE5 		ldr	r3, [sp, #40]
 5950 3598 6EFDFFEA 		b	.L355
 5951              	.L403:
 5952              	.LVL479:
3394:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5953              		.loc 1 3394 0
 5954 359c 1800A0E3 		mov	r0, #24
 5955 35a0 FEFFFFEB 		bl	ControlHandle
 5956              	.LVL480:
 5957 35a4 28309DE5 		ldr	r3, [sp, #40]
 5958 35a8 6AFDFFEA 		b	.L355
 5959              	.L377:
 5960              	.LVL481:
 5961              	.LBE121:
 5962              	.LBE157:
 5963              	.LBB158:
 5964              	.LBB100:
3137:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5965              		.loc 1 3137 0
 5966 35ac 0000A0E3 		mov	r0, #0
 5967 35b0 FEFFFFEB 		bl	CTControlHandle
 5968              	.LVL482:
 5969 35b4 28309DE5 		ldr	r3, [sp, #40]
 5970 35b8 66FDFFEA 		b	.L355
 5971              	.L379:
 5972              	.LVL483:
3145:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5973              		.loc 1 3145 0
 5974 35bc 0200A0E3 		mov	r0, #2
 5975 35c0 FEFFFFEB 		bl	CTControlHandle
 5976              	.LVL484:
 5977 35c4 28309DE5 		ldr	r3, [sp, #40]
 5978 35c8 62FDFFEA 		b	.L355
 5979              	.L411:
 5980              	.LVL485:
 5981              	.LBE100:
 5982              	.LBE158:
 5983              	.LBB159:
 5984              	.LBB130:
3435:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 5985              		.loc 1 3435 0
 5986 35cc 2500A0E3 		mov	r0, #37
 5987 35d0 FEFFFFEB 		bl	ControlHandle
 5988              	.LVL486:
 5989 35d4 28309DE5 		ldr	r3, [sp, #40]
 5990 35d8 5EFDFFEA 		b	.L355
 5991              	.LVL487:
 5992              	.L494:
 5993              	.LBE130:
 5994              	.LBE159:
 5995              	.LBB160:
 5996              	.LBB110:
3753:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5997              		.loc 1 3753 0
 5998 35dc 0200A0E3 		mov	r0, #2
 5999 35e0 44129FE5 		ldr	r1, .L546+64
 6000 35e4 97FEFFEA 		b	.L526
 6001              	.LVL488:
 6002              	.L372:
 6003              	.LBE110:
 6004              	.LBE160:
 6005              	.LBB161:
 6006              	.LBB97:
3103:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6007              		.loc 1 3103 0
 6008 35e8 0E00A0E3 		mov	r0, #14
 6009 35ec FEFFFFEB 		bl	ControlHandle
 6010              	.LVL489:
 6011 35f0 28309DE5 		ldr	r3, [sp, #40]
 6012 35f4 57FDFFEA 		b	.L355
 6013              	.L537:
 6014              	.LVL490:
3066:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6015              		.loc 1 3066 0
 6016 35f8 0100A0E3 		mov	r0, #1
 6017 35fc FEFFFFEB 		bl	ControlHandle
 6018              	.LVL491:
 6019 3600 28309DE5 		ldr	r3, [sp, #40]
 6020 3604 53FDFFEA 		b	.L355
 6021              	.L363:
 6022              	.LVL492:
3062:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6023              		.loc 1 3062 0
 6024 3608 0000A0E3 		mov	r0, #0
 6025 360c FEFFFFEB 		bl	ControlHandle
 6026              	.LVL493:
 6027 3610 28309DE5 		ldr	r3, [sp, #40]
 6028 3614 4FFDFFEA 		b	.L355
 6029              	.L382:
 6030              	.LVL494:
 6031              	.LBE97:
 6032              	.LBE161:
 6033              	.LBB162:
 6034              	.LBB107:
3159:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6035              		.loc 1 3159 0
 6036 3618 0500A0E3 		mov	r0, #5
 6037 361c FEFFFFEB 		bl	CTControlHandle
 6038              	.LVL495:
 6039 3620 28309DE5 		ldr	r3, [sp, #40]
 6040 3624 4BFDFFEA 		b	.L355
 6041              	.LVL496:
 6042              	.L481:
 6043              	.LBE107:
 6044              	.LBE162:
 6045              	.LBB163:
 6046              	.LBB117:
3707:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6047              		.loc 1 3707 0
 6048 3628 582094E5 		ldr	r2, [r4, #88]
 6049 362c 3010A0E3 		mov	r1, #48
 6050 3630 000052E3 		cmp	r2, #0
 6051 3634 E420A003 		moveq	r2, #228
 6052 3638 6420A013 		movne	r2, #100
 6053 363c 5230A0E3 		mov	r3, #82
 6054 3640 0100A0E3 		mov	r0, #1
 6055              	.LVL497:
 6056 3644 FEFFFFEB 		bl	SensorSetIrisControl
3709:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6057              		.loc 1 3709 0
 6058 3648 582094E5 		ldr	r2, [r4, #88]
 6059 364c 08129FE5 		ldr	r1, .L546+112
 6060 3650 000052E3 		cmp	r2, #0
 6061 3654 583094E5 		ldr	r3, [r4, #88]
 6062 3658 E420A003 		moveq	r2, #228
 6063 365c 6420A013 		movne	r2, #100
 6064 3660 0400A0E3 		mov	r0, #4
 6065 3664 FEFFFFEB 		bl	CyU3PDebugPrint
 6066              	.L477:
3729:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6067              		.loc 1 3729 0
 6068 3668 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3731:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6069              		.loc 1 3731 0
 6070 366c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 6071 3670 BE22DDE1 		ldrh	r2, [sp, #46]
 6072              	.LVL498:
 6073 3674 0400A0E3 		mov	r0, #4
 6074 3678 E0119FE5 		ldr	r1, .L546+116
3729:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6075              		.loc 1 3729 0
 6076 367c A0E0C4E5 		strb	lr, [r4, #160]
3731:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6077              		.loc 1 3731 0
 6078 3680 00E08DE5 		str	lr, [sp, #0]
 6079 3684 FEFFFFEB 		bl	CyU3PDebugPrint
 6080 3688 28309DE5 		ldr	r3, [sp, #40]
 6081 368c 3BFDFFEA 		b	.L419
 6082              	.LVL499:
 6083              	.L480:
3712:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6084              		.loc 1 3712 0
 6085 3690 582094E5 		ldr	r2, [r4, #88]
 6086 3694 3010A0E3 		mov	r1, #48
 6087 3698 000052E3 		cmp	r2, #0
 6088 369c D420A003 		moveq	r2, #212
 6089 36a0 5420A013 		movne	r2, #84
 6090 36a4 5230A0E3 		mov	r3, #82
 6091 36a8 0100A0E3 		mov	r0, #1
 6092              	.LVL500:
 6093 36ac FEFFFFEB 		bl	SensorSetIrisControl
3714:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6094              		.loc 1 3714 0
 6095 36b0 582094E5 		ldr	r2, [r4, #88]
 6096 36b4 A0119FE5 		ldr	r1, .L546+112
 6097 36b8 000052E3 		cmp	r2, #0
 6098 36bc 583094E5 		ldr	r3, [r4, #88]
 6099 36c0 D420A003 		moveq	r2, #212
 6100 36c4 5420A013 		movne	r2, #84
 6101 36c8 0400A0E3 		mov	r0, #4
 6102 36cc FEFFFFEB 		bl	CyU3PDebugPrint
 6103 36d0 E4FFFFEA 		b	.L477
 6104              	.LVL501:
 6105              	.L478:
3722:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6106              		.loc 1 3722 0
 6107 36d4 580094E5 		ldr	r0, [r4, #88]
 6108              	.LVL502:
 6109 36d8 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6110 36dc 000050E3 		cmp	r0, #0
 6111 36e0 F400A003 		moveq	r0, #244
 6112 36e4 7400A013 		movne	r0, #116
 6113 36e8 032080E1 		orr	r2, r0, r3
 6114 36ec 3010A0E3 		mov	r1, #48
 6115 36f0 5230A0E3 		mov	r3, #82
 6116 36f4 0100A0E3 		mov	r0, #1
 6117 36f8 FEFFFFEB 		bl	SensorSetIrisControl
3724:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6118              		.loc 1 3724 0
 6119 36fc 58C094E5 		ldr	ip, [r4, #88]
 6120 3700 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6121 3704 00005CE3 		cmp	ip, #0
 6122 3708 F4C0A003 		moveq	ip, #244
 6123 370c 74C0A013 		movne	ip, #116
 6124 3710 583094E5 		ldr	r3, [r4, #88]
 6125 3714 40119FE5 		ldr	r1, .L546+112
 6126 3718 02208CE1 		orr	r2, ip, r2
 6127 371c 0400A0E3 		mov	r0, #4
 6128 3720 FEFFFFEB 		bl	CyU3PDebugPrint
 6129 3724 CFFFFFEA 		b	.L477
 6130              	.LVL503:
 6131              	.L479:
3717:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6132              		.loc 1 3717 0
 6133 3728 58E094E5 		ldr	lr, [r4, #88]
 6134 372c 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6135 3730 00005EE3 		cmp	lr, #0
 6136 3734 C4E0A003 		moveq	lr, #196
 6137 3738 44E0A013 		movne	lr, #68
 6138 373c 09208EE1 		orr	r2, lr, r9
 6139 3740 3010A0E3 		mov	r1, #48
 6140 3744 5230A0E3 		mov	r3, #82
 6141 3748 0100A0E3 		mov	r0, #1
 6142              	.LVL504:
 6143 374c FEFFFFEB 		bl	SensorSetIrisControl
3719:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6144              		.loc 1 3719 0
 6145 3750 580094E5 		ldr	r0, [r4, #88]
 6146 3754 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6147 3758 000050E3 		cmp	r0, #0
 6148 375c C400A003 		moveq	r0, #196
 6149 3760 4400A013 		movne	r0, #68
 6150 3764 0C2080E1 		orr	r2, r0, ip
 6151 3768 583094E5 		ldr	r3, [r4, #88]
 6152 376c E8109FE5 		ldr	r1, .L546+112
 6153 3770 0400A0E3 		mov	r0, #4
 6154 3774 FEFFFFEB 		bl	CyU3PDebugPrint
 6155 3778 BAFFFFEA 		b	.L477
 6156              	.L380:
 6157              	.LVL505:
 6158              	.LBE117:
 6159              	.LBE163:
 6160              	.LBB164:
 6161              	.LBB99:
3150:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 6162              		.loc 1 3150 0
 6163 377c 0300A0E3 		mov	r0, #3
 6164 3780 FEFFFFEB 		bl	CTControlHandle
 6165              	.LVL506:
 6166 3784 28309DE5 		ldr	r3, [sp, #40]
 6167 3788 F2FCFFEA 		b	.L355
 6168              	.L401:
 6169              	.LVL507:
 6170              	.LBE99:
 6171              	.LBE164:
 6172              	.LBB165:
 6173              	.LBB120:
3386:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 6174              		.loc 1 3386 0
 6175 378c 1600A0E3 		mov	r0, #22
 6176 3790 FEFFFFEB 		bl	ControlHandle
 6177              	.LVL508:
 6178 3794 28309DE5 		ldr	r3, [sp, #40]
 6179 3798 EEFCFFEA 		b	.L355
 6180              	.L387:
 6181              	.LVL509:
 6182              	.LBE120:
 6183              	.LBE165:
 6184              	.LBB166:
 6185              	.LBB108:
3182:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 6186              		.loc 1 3182 0
 6187 379c 0A00A0E3 		mov	r0, #10
 6188 37a0 FEFFFFEB 		bl	CTControlHandle
 6189              	.LVL510:
 6190 37a4 28309DE5 		ldr	r3, [sp, #40]
 6191 37a8 EAFCFFEA 		b	.L355
 6192              	.L386:
 6193              	.LVL511:
3178:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 6194              		.loc 1 3178 0
 6195 37ac 0900A0E3 		mov	r0, #9
 6196 37b0 FEFFFFEB 		bl	CTControlHandle
 6197              	.LVL512:
 6198 37b4 28309DE5 		ldr	r3, [sp, #40]
 6199 37b8 E6FCFFEA 		b	.L355
 6200              	.L400:
 6201              	.LVL513:
 6202              	.LBE108:
 6203              	.LBE166:
 6204              	.LBB167:
 6205              	.LBB131:
3382:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 6206              		.loc 1 3382 0
 6207 37bc 1500A0E3 		mov	r0, #21
 6208 37c0 FEFFFFEB 		bl	ControlHandle
 6209              	.LVL514:
 6210 37c4 28309DE5 		ldr	r3, [sp, #40]
 6211 37c8 E2FCFFEA 		b	.L355
 6212              	.L410:
 6213              	.LVL515:
3431:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 6214              		.loc 1 3431 0
 6215 37cc 2400A0E3 		mov	r0, #36
 6216 37d0 FEFFFFEB 		bl	ControlHandle
 6217              	.LVL516:
 6218 37d4 28309DE5 		ldr	r3, [sp, #40]
 6219 37d8 DEFCFFEA 		b	.L355
 6220              	.L406:
 6221              	.LVL517:
3409:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6222              		.loc 1 3409 0
 6223 37dc 1B00A0E3 		mov	r0, #27
 6224 37e0 FEFFFFEB 		bl	ControlHandle
 6225              	.LVL518:
 6226 37e4 28309DE5 		ldr	r3, [sp, #40]
 6227 37e8 DAFCFFEA 		b	.L355
 6228              	.L547:
 6229              		.align	2
 6230              	.L546:
 6231 37ec 00000000 		.word	.LANCHOR0
 6232 37f0 00000000 		.word	.LANCHOR1
 6233 37f4 00000000 		.word	bRequest
 6234 37f8 00000000 		.word	wValue
 6235 37fc 00000000 		.word	wIndex
 6236 3800 00000000 		.word	glInterStaBuffer
 6237 3804 CC050000 		.word	.LC31
 6238 3808 00000000 		.word	glChHandleInterStat
 6239 380c 00000000 		.word	bmReqType
 6240 3810 00000000 		.word	wLength
 6241 3814 50050000 		.word	.LC30
 6242 3818 80000000 		.word	.LANCHOR0+128
 6243 381c 0C070000 		.word	.LC39
 6244 3820 30070000 		.word	.LC40
 6245 3824 A0060000 		.word	.LANCHOR1+1696
 6246 3828 F8050000 		.word	.LC32
 6247 382c 5C000000 		.word	.LANCHOR0+92
 6248 3830 F4060000 		.word	.LANCHOR1+1780
 6249 3834 00070000 		.word	.LANCHOR1+1792
 6250 3838 94060000 		.word	.LC36
 6251 383c 84070000 		.word	.LC42
 6252 3840 D8010000 		.word	.LC12
 6253 3844 5C070000 		.word	.LC41
 6254 3848 BC060000 		.word	.LANCHOR1+1724
 6255 384c D8060000 		.word	.LANCHOR1+1752
 6256 3850 20060000 		.word	.LC33
 6257 3854 44060000 		.word	.LC34
 6258 3858 6C060000 		.word	.LC35
 6259 385c C0060000 		.word	.LC37
 6260 3860 E4060000 		.word	.LC38
 6261              	.LBE131:
 6262              	.LBE167:
 6263              		.cfi_endproc
 6264              	.LFE25:
 6266              		.align	2
 6267              		.global	CamDefSet
 6269              	CamDefSet:
 6270              	.LFB5:
1662:../uvc.c      **** {
 6271              		.loc 1 1662 0
 6272              		.cfi_startproc
 6273              		@ args = 0, pretend = 0, frame = 24
 6274              		@ frame_needed = 0, uses_anonymous_args = 0
 6275              	.LVL519:
 6276 3864 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6277              	.LCFI21:
 6278              		.cfi_def_cfa_offset 36
1668:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6279              		.loc 1 1668 0
 6280 3868 AC429FE5 		ldr	r4, .L551
 6281              		.cfi_offset 14, -4
 6282              		.cfi_offset 11, -8
 6283              		.cfi_offset 10, -12
 6284              		.cfi_offset 9, -16
 6285              		.cfi_offset 8, -20
 6286              		.cfi_offset 7, -24
 6287              		.cfi_offset 6, -28
 6288              		.cfi_offset 5, -32
 6289              		.cfi_offset 4, -36
1673:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6290              		.loc 1 1673 0
 6291 386c AC229FE5 		ldr	r2, .L551+4
1670:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6292              		.loc 1 1670 0
 6293 3870 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1662:../uvc.c      **** {
 6294              		.loc 1 1662 0
 6295 3874 2CD04DE2 		sub	sp, sp, #44
 6296              	.LCFI22:
 6297              		.cfi_def_cfa_offset 80
1673:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6298              		.loc 1 1673 0
 6299 3878 1C0092E5 		ldr	r0, [r2, #28]
 6300 387c 0010E0E3 		mvn	r1, #0
1675:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6301              		.loc 1 1675 0
 6302 3880 2963A0E1 		mov	r6, r9, lsr #6
1669:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6303              		.loc 1 1669 0
 6304 3884 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1668:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6305              		.loc 1 1668 0
 6306 3888 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 6307              	.LVL520:
1673:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6308              		.loc 1 1673 0
 6309 388c FEFFFFEB 		bl	_txe_mutex_get
1674:../uvc.c      ****     if(Data1&0x80){
 6310              		.loc 1 1674 0
 6311 3890 800019E3 		tst	r9, #128
1675:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6312              		.loc 1 1675 0
 6313 3894 01600612 		andne	r6, r6, #1
 6314 3898 0660E011 		mvnne	r6, r6
 6315 389c 3B600612 		andne	r6, r6, #59
 6316 38a0 0660E011 		mvnne	r6, r6
 6317 38a4 FF600612 		andne	r6, r6, #255
 6318              	.LVL521:
1677:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 6319              		.loc 1 1677 0
 6320 38a8 C6608603 		orreq	r6, r6, #198
 6321              	.LVL522:
1681:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6322              		.loc 1 1681 0
 6323 38ac 0080A0E3 		mov	r8, #0
 6324 38b0 0A20A0E1 		mov	r2, sl
 6325 38b4 0730A0E1 		mov	r3, r7
 6326 38b8 0110A0E3 		mov	r1, #1
1679:../uvc.c      ****     Data0 = (Data0 << 2);
 6327              		.loc 1 1679 0
 6328 38bc 0951A0E1 		mov	r5, r9, asl #2
1681:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6329              		.loc 1 1681 0
 6330 38c0 58029FE5 		ldr	r0, .L551+4
1684:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6331              		.loc 1 1684 0
 6332 38c4 0190A0E3 		mov	r9, #1
 6333              	.LVL523:
1679:../uvc.c      ****     Data0 = (Data0 << 2);
 6334              		.loc 1 1679 0
 6335 38c8 FF5005E2 		and	r5, r5, #255
 6336              	.LVL524:
1681:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6337              		.loc 1 1681 0
 6338 38cc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6339 38d0 FEFFFFEB 		bl	cmdSet
 6340              	.LVL525:
1684:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6341              		.loc 1 1684 0
 6342 38d4 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6343 38d8 0910A0E1 		mov	r1, r9
 6344 38dc 0730A0E1 		mov	r3, r7
 6345 38e0 38029FE5 		ldr	r0, .L551+4
 6346 38e4 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 6347 38e8 FEFFFFEB 		bl	cmdSet
 6348              	.LVL526:
1687:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6349              		.loc 1 1687 0
 6350 38ec 0620A0E1 		mov	r2, r6
 6351 38f0 0530A0E1 		mov	r3, r5
 6352 38f4 28129FE5 		ldr	r1, .L551+8
 6353 38f8 0400A0E3 		mov	r0, #4
1686:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6354              		.loc 1 1686 0
 6355 38fc A661C4E5 		strb	r6, [r4, #422]
1685:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6356              		.loc 1 1685 0
 6357 3900 A551C4E5 		strb	r5, [r4, #421]
1687:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6358              		.loc 1 1687 0
 6359 3904 FEFFFFEB 		bl	CyU3PDebugPrint
 6360              	.LVL527:
1692:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6361              		.loc 1 1692 0
 6362 3908 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 6363              	.LVL528:
1693:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6364              		.loc 1 1693 0
 6365 390c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6366 3910 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6367 3914 0210A0E3 		mov	r1, #2
 6368 3918 00029FE5 		ldr	r0, .L551+4
 6369 391c 00B08DE5 		str	fp, [sp, #0]
 6370 3920 04808DE5 		str	r8, [sp, #4]
 6371 3924 FEFFFFEB 		bl	cmdSet
 6372              	.LVL529:
1695:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6373              		.loc 1 1695 0
 6374 3928 0B20A0E1 		mov	r2, fp
 6375 392c 0530A0E1 		mov	r3, r5
 6376 3930 EC119FE5 		ldr	r1, .L551+8
 6377 3934 0400A0E3 		mov	r0, #4
1694:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6378              		.loc 1 1694 0
 6379 3938 BD51C4E5 		strb	r5, [r4, #445]
1695:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6380              		.loc 1 1695 0
 6381 393c FEFFFFEB 		bl	CyU3PDebugPrint
 6382              	.LVL530:
1700:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6383              		.loc 1 1700 0
 6384 3940 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1699:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6385              		.loc 1 1699 0
 6386 3944 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6387              	.LVL531:
1701:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6388              		.loc 1 1701 0
 6389 3948 80B047E2 		sub	fp, r7, #128
 6390 394c FF100BE2 		and	r1, fp, #255
 6391 3950 14108DE5 		str	r1, [sp, #20]
 6392 3954 14C09DE5 		ldr	ip, [sp, #20]
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6393              		.loc 1 1702 0
 6394 3958 760047E2 		sub	r0, r7, #118
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6395              		.loc 1 1703 0
 6396 395c 7EE087E2 		add	lr, r7, #126
1701:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6397              		.loc 1 1701 0
 6398 3960 0630A0E1 		mov	r3, r6
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6399              		.loc 1 1702 0
 6400 3964 18008DE5 		str	r0, [sp, #24]
1701:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6401              		.loc 1 1701 0
 6402 3968 0510A0E3 		mov	r1, #5
 6403 396c DF20A0E3 		mov	r2, #223
 6404 3970 A8019FE5 		ldr	r0, .L551+4
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6405              		.loc 1 1703 0
 6406 3974 1CE08DE5 		str	lr, [sp, #28]
1701:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6407              		.loc 1 1701 0
 6408 3978 00C08DE5 		str	ip, [sp, #0]
 6409 397c 04808DE5 		str	r8, [sp, #4]
 6410 3980 FEFFFFEB 		bl	cmdSet
 6411              	.LVL532:
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6412              		.loc 1 1702 0
 6413 3984 18A09DE5 		ldr	sl, [sp, #24]
1704:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6414              		.loc 1 1704 0
 6415 3988 72E087E2 		add	lr, r7, #114
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6416              		.loc 1 1702 0
 6417 398c FFC00AE2 		and	ip, sl, #255
 6418 3990 0630A0E1 		mov	r3, r6
 6419 3994 0510A0E3 		mov	r1, #5
 6420 3998 DC20A0E3 		mov	r2, #220
 6421 399c 7C019FE5 		ldr	r0, .L551+4
1704:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6422              		.loc 1 1704 0
 6423 39a0 20E08DE5 		str	lr, [sp, #32]
1702:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6424              		.loc 1 1702 0
 6425 39a4 00C08DE5 		str	ip, [sp, #0]
 6426 39a8 04908DE5 		str	r9, [sp, #4]
 6427 39ac FEFFFFEB 		bl	cmdSet
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6428              		.loc 1 1703 0
 6429 39b0 1C009DE5 		ldr	r0, [sp, #28]
 6430 39b4 02E0A0E3 		mov	lr, #2
 6431 39b8 FFC000E2 		and	ip, r0, #255
 6432 39bc 0630A0E1 		mov	r3, r6
1705:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6433              		.loc 1 1705 0
 6434 39c0 6FA047E2 		sub	sl, r7, #111
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6435              		.loc 1 1703 0
 6436 39c4 0510A0E3 		mov	r1, #5
 6437 39c8 DE20A0E3 		mov	r2, #222
 6438 39cc 4C019FE5 		ldr	r0, .L551+4
 6439 39d0 04E08DE5 		str	lr, [sp, #4]
1705:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6440              		.loc 1 1705 0
 6441 39d4 24A08DE5 		str	sl, [sp, #36]
1703:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6442              		.loc 1 1703 0
 6443 39d8 00C08DE5 		str	ip, [sp, #0]
 6444 39dc FEFFFFEB 		bl	cmdSet
1704:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6445              		.loc 1 1704 0
 6446 39e0 20A09DE5 		ldr	sl, [sp, #32]
 6447 39e4 0630A0E1 		mov	r3, r6
 6448 39e8 FFC00AE2 		and	ip, sl, #255
 6449 39ec 00C08DE5 		str	ip, [sp, #0]
 6450 39f0 0510A0E3 		mov	r1, #5
 6451 39f4 03C0A0E3 		mov	ip, #3
 6452 39f8 E020A0E3 		mov	r2, #224
 6453 39fc 1C019FE5 		ldr	r0, .L551+4
 6454 3a00 04C08DE5 		str	ip, [sp, #4]
 6455 3a04 FEFFFFEB 		bl	cmdSet
1705:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6456              		.loc 1 1705 0
 6457 3a08 24009DE5 		ldr	r0, [sp, #36]
 6458 3a0c 04A0A0E3 		mov	sl, #4
 6459 3a10 FFC000E2 		and	ip, r0, #255
 6460 3a14 0630A0E1 		mov	r3, r6
 6461 3a18 0510A0E3 		mov	r1, #5
 6462 3a1c DD20A0E3 		mov	r2, #221
 6463 3a20 F8009FE5 		ldr	r0, .L551+4
 6464 3a24 00C08DE5 		str	ip, [sp, #0]
1706:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6465              		.loc 1 1706 0
 6466 3a28 7F7087E2 		add	r7, r7, #127
 6467              	.LVL533:
1705:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6468              		.loc 1 1705 0
 6469 3a2c 04A08DE5 		str	sl, [sp, #4]
 6470 3a30 FEFFFFEB 		bl	cmdSet
1706:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6471              		.loc 1 1706 0
 6472 3a34 05E0A0E3 		mov	lr, #5
 6473 3a38 0E10A0E1 		mov	r1, lr
 6474 3a3c 0630A0E1 		mov	r3, r6
 6475 3a40 E120A0E3 		mov	r2, #225
 6476 3a44 FF6007E2 		and	r6, r7, #255
 6477              	.LVL534:
 6478 3a48 D0009FE5 		ldr	r0, .L551+4
 6479 3a4c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 6480 3a50 FEFFFFEB 		bl	cmdSet
 6481              	.LVL535:
1707:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6482              		.loc 1 1707 0
 6483 3a54 14C09DE5 		ldr	ip, [sp, #20]
1708:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6484              		.loc 1 1708 0
 6485 3a58 24E09DE5 		ldr	lr, [sp, #36]
 6486 3a5c 1C609DE5 		ldr	r6, [sp, #28]
1707:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6487              		.loc 1 1707 0
 6488 3a60 05C2C4E5 		strb	ip, [r4, #517]
1708:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6489              		.loc 1 1708 0
 6490 3a64 20C09DE5 		ldr	ip, [sp, #32]
 6491 3a68 0B20A0E1 		mov	r2, fp
 6492 3a6c 18309DE5 		ldr	r3, [sp, #24]
 6493 3a70 B0109FE5 		ldr	r1, .L551+12
 6494 3a74 0A00A0E1 		mov	r0, sl
 6495 3a78 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 6496 3a7c 0C708DE5 		str	r7, [sp, #12]
 6497 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
 6498              	.LVL536:
1712:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6499              		.loc 1 1712 0
 6500 3a84 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 6501              	.LVL537:
1713:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6502              		.loc 1 1713 0
 6503 3a88 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 6504              	.LVL538:
1714:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6505              		.loc 1 1714 0
 6506 3a8c 0730A0E1 		mov	r3, r7
 6507 3a90 0610A0E3 		mov	r1, #6
 6508 3a94 8520A0E3 		mov	r2, #133
 6509 3a98 80009FE5 		ldr	r0, .L551+4
 6510 3a9c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6511 3aa0 FEFFFFEB 		bl	cmdSet
1715:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6512              		.loc 1 1715 0
 6513 3aa4 0730A0E1 		mov	r3, r7
 6514 3aa8 0610A0E3 		mov	r1, #6
 6515 3aac 8620A0E3 		mov	r2, #134
 6516 3ab0 68009FE5 		ldr	r0, .L551+4
 6517 3ab4 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 6518 3ab8 FEFFFFEB 		bl	cmdSet
1717:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6519              		.loc 1 1717 0
 6520 3abc 0620A0E1 		mov	r2, r6
 6521 3ac0 0530A0E1 		mov	r3, r5
 6522 3ac4 58109FE5 		ldr	r1, .L551+8
 6523 3ac8 0A00A0E1 		mov	r0, sl
1716:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6524              		.loc 1 1716 0
 6525 3acc 1D62C4E5 		strb	r6, [r4, #541]
1717:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6526              		.loc 1 1717 0
 6527 3ad0 FEFFFFEB 		bl	CyU3PDebugPrint
 6528              	.LVL539:
1722:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6529              		.loc 1 1722 0
 6530 3ad4 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 6531              	.LVL540:
1723:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6532              		.loc 1 1723 0
 6533 3ad8 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 6534 3adc 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 6535 3ae0 0710A0E3 		mov	r1, #7
 6536 3ae4 34009FE5 		ldr	r0, .L551+4
 6537 3ae8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6538 3aec FEFFFFEB 		bl	cmdSet
 6539              	.LVL541:
1725:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6540              		.loc 1 1725 0
 6541 3af0 0530A0E1 		mov	r3, r5
 6542 3af4 0A00A0E1 		mov	r0, sl
 6543 3af8 24109FE5 		ldr	r1, .L551+8
 6544 3afc 0620A0E1 		mov	r2, r6
1724:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6545              		.loc 1 1724 0
 6546 3b00 3552C4E5 		strb	r5, [r4, #565]
1725:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6547              		.loc 1 1725 0
 6548 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
1727:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6549              		.loc 1 1727 0
 6550 3b08 10309FE5 		ldr	r3, .L551+4
 6551 3b0c 1C0093E5 		ldr	r0, [r3, #28]
1730:../uvc.c      **** }
 6552              		.loc 1 1730 0
 6553 3b10 2CD08DE2 		add	sp, sp, #44
 6554 3b14 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1727:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6555              		.loc 1 1727 0
 6556 3b18 FEFFFFEA 		b	_txe_mutex_put
 6557              	.L552:
 6558              		.align	2
 6559              	.L551:
 6560 3b1c 00000000 		.word	.LANCHOR1
 6561 3b20 00000000 		.word	cmdQu
 6562 3b24 B8070000 		.word	.LC43
 6563 3b28 D8070000 		.word	.LC44
 6564              		.cfi_endproc
 6565              	.LFE5:
 6567              		.align	2
 6568              		.global	CyFxUVCAddHeader
 6570              	CyFxUVCAddHeader:
 6571              	.LFB6:
1738:../uvc.c      **** {
 6572              		.loc 1 1738 0
 6573              		.cfi_startproc
 6574              		@ args = 0, pretend = 0, frame = 0
 6575              		@ frame_needed = 0, uses_anonymous_args = 0
 6576              	.LVL542:
 6577 3b2c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6578              	.LCFI23:
 6579              		.cfi_def_cfa_offset 16
1738:../uvc.c      **** {
 6580              		.loc 1 1738 0
 6581 3b30 0040A0E1 		mov	r4, r0
 6582              		.cfi_offset 14, -4
 6583              		.cfi_offset 5, -8
 6584              		.cfi_offset 4, -12
 6585              		.cfi_offset 3, -16
 6586 3b34 0150A0E1 		mov	r5, r1
1740:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6587              		.loc 1 1740 0
 6588 3b38 30009FE5 		ldr	r0, .L555
 6589              	.LVL543:
 6590 3b3c 0010E0E3 		mvn	r1, #0
 6591              	.LVL544:
 6592 3b40 FEFFFFEB 		bl	_txe_mutex_get
1741:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6593              		.loc 1 1741 0
 6594 3b44 0400A0E1 		mov	r0, r4
 6595 3b48 24109FE5 		ldr	r1, .L555+4
 6596 3b4c 0C20A0E3 		mov	r2, #12
 6597 3b50 FEFFFFEB 		bl	CyU3PMemCopy
1742:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6598              		.loc 1 1742 0
 6599 3b54 14009FE5 		ldr	r0, .L555
 6600 3b58 FEFFFFEB 		bl	_txe_mutex_put
1745:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 6601              		.loc 1 1745 0
 6602 3b5c 020015E3 		tst	r5, #2
1747:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 6603              		.loc 1 1747 0
 6604 3b60 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6605 3b64 02308313 		orrne	r3, r3, #2
 6606 3b68 0130C415 		strneb	r3, [r4, #1]
 6607 3b6c 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6608              	.L556:
 6609              		.align	2
 6610              	.L555:
 6611 3b70 00000000 		.word	imgHdMux
 6612 3b74 80040000 		.word	.LANCHOR1+1152
 6613              		.cfi_endproc
 6614              	.LFE6:
 6616              		.align	2
 6617              		.global	CyFxAppErrorHandler
 6619              	CyFxAppErrorHandler:
 6620              	.LFB7:
1757:../uvc.c      **** {
 6621              		.loc 1 1757 0
 6622              		.cfi_startproc
 6623              		@ args = 0, pretend = 0, frame = 0
 6624              		@ frame_needed = 0, uses_anonymous_args = 0
 6625              	.LVL545:
 6626 3b78 08402DE9 		stmfd	sp!, {r3, lr}
 6627              	.LCFI24:
 6628              		.cfi_def_cfa_offset 8
 6629              	.LVL546:
 6630              	.L558:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6631              		.loc 1 1767 0 discriminator 1
 6632 3b7c 10109FE5 		ldr	r1, .L559
 6633 3b80 0400A0E3 		mov	r0, #4
 6634              		.cfi_offset 14, -4
 6635              		.cfi_offset 3, -8
 6636 3b84 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 6637              		.loc 1 1768 0 discriminator 1
 6638 3b88 FA0FA0E3 		mov	r0, #1000
 6639 3b8c FEFFFFEB 		bl	_tx_thread_sleep
 6640 3b90 F9FFFFEA 		b	.L558
 6641              	.L560:
 6642              		.align	2
 6643              	.L559:
 6644 3b94 D8010000 		.word	.LC12
 6645              		.cfi_endproc
 6646              	.LFE7:
 6648              		.align	2
 6649              		.global	UVCAppThread_Entry
 6651              	UVCAppThread_Entry:
 6652              	.LFB19:
2744:../uvc.c      **** {
 6653              		.loc 1 2744 0
 6654              		.cfi_startproc
 6655              		@ args = 0, pretend = 0, frame = 176
 6656              		@ frame_needed = 0, uses_anonymous_args = 0
 6657              	.LVL547:
 6658 3b98 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 6659              	.LCFI25:
 6660              		.cfi_def_cfa_offset 28
 6661 3b9c BCD04DE2 		sub	sp, sp, #188
 6662              	.LCFI26:
 6663              		.cfi_def_cfa_offset 216
 6664              	.LBB220:
 6665              	.LBB221:
2200:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 6666              		.loc 1 2200 0
 6667              		.cfi_offset 14, -4
 6668              		.cfi_offset 10, -8
 6669              		.cfi_offset 8, -12
 6670              		.cfi_offset 7, -16
 6671              		.cfi_offset 6, -20
 6672              		.cfi_offset 5, -24
 6673              		.cfi_offset 4, -28
 6674 3ba0 FEFFFFEB 		bl	CyU3PUartInit
 6675              	.LVL548:
2201:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6676              		.loc 1 2201 0
 6677 3ba4 004050E2 		subs	r4, r0, #0
 6678 3ba8 0400000A 		beq	.L562
2203:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6679              		.loc 1 2203 0
 6680 3bac 0400A0E3 		mov	r0, #4
 6681              	.LVL549:
 6682 3bb0 F81B9FE5 		ldr	r1, .L678
 6683 3bb4 FEFFFFEB 		bl	CyU3PDebugPrint
2204:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6684              		.loc 1 2204 0
 6685 3bb8 0400A0E1 		mov	r0, r4
 6686 3bbc FEFFFFEB 		bl	CyFxAppErrorHandler
 6687              	.L562:
2208:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6688              		.loc 1 2208 0
 6689 3bc0 ECCB9FE5 		ldr	ip, .L678+4
2210:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6690              		.loc 1 2210 0
 6691 3bc4 0030A0E3 		mov	r3, #0
2209:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6692              		.loc 1 2209 0
 6693 3bc8 0120A0E3 		mov	r2, #1
2217:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6694              		.loc 1 2217 0
 6695 3bcc 50008DE2 		add	r0, sp, #80
 6696 3bd0 0310A0E1 		mov	r1, r3
2208:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6697              		.loc 1 2208 0
 6698 3bd4 60C08DE5 		str	ip, [sp, #96]
2209:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6699              		.loc 1 2209 0
 6700 3bd8 6420CDE5 		strb	r2, [sp, #100]
2210:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6701              		.loc 1 2210 0
 6702 3bdc 6530CDE5 		strb	r3, [sp, #101]
2211:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6703              		.loc 1 2211 0
 6704 3be0 50208DE5 		str	r2, [sp, #80]
2212:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6705              		.loc 1 2212 0
 6706 3be4 54308DE5 		str	r3, [sp, #84]
2213:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6707              		.loc 1 2213 0
 6708 3be8 58308DE5 		str	r3, [sp, #88]
2214:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6709              		.loc 1 2214 0
 6710 3bec 5C208DE5 		str	r2, [sp, #92]
2217:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6711              		.loc 1 2217 0
 6712 3bf0 FEFFFFEB 		bl	CyU3PUartSetConfig
 6713              	.LVL550:
2218:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6714              		.loc 1 2218 0
 6715 3bf4 000050E3 		cmp	r0, #0
 6716 3bf8 0000000A 		beq	.L563
2220:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6717              		.loc 1 2220 0
 6718 3bfc FEFFFFEB 		bl	CyFxAppErrorHandler
 6719              	.LVL551:
 6720              	.L563:
2224:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 6721              		.loc 1 2224 0
 6722 3c00 0000E0E3 		mvn	r0, #0
 6723 3c04 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6724              	.LVL552:
2225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6725              		.loc 1 2225 0
 6726 3c08 000050E3 		cmp	r0, #0
 6727 3c0c 0000000A 		beq	.L564
2227:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6728              		.loc 1 2227 0
 6729 3c10 FEFFFFEB 		bl	CyFxAppErrorHandler
 6730              	.LVL553:
 6731              	.L564:
2231:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 6732              		.loc 1 2231 0
 6733 3c14 0300A0E3 		mov	r0, #3
 6734 3c18 0410A0E3 		mov	r1, #4
 6735 3c1c FEFFFFEB 		bl	CyU3PDebugInit
 6736              	.LVL554:
2232:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6737              		.loc 1 2232 0
 6738 3c20 000050E3 		cmp	r0, #0
 6739 3c24 0000000A 		beq	.L565
2234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6740              		.loc 1 2234 0
 6741 3c28 FEFFFFEB 		bl	CyFxAppErrorHandler
 6742              	.LVL555:
 6743              	.L565:
2238:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 6744              		.loc 1 2238 0
 6745 3c2c 0000A0E3 		mov	r0, #0
 6746 3c30 FEFFFFEB 		bl	CyU3PDebugPreamble
 6747              	.LVL556:
 6748              	.LBE221:
 6749              	.LBE220:
2760:../uvc.c      **** 		CyU3PThreadSleep(500);
 6750              		.loc 1 2760 0
 6751 3c34 7D0FA0E3 		mov	r0, #500
 6752 3c38 FEFFFFEB 		bl	_tx_thread_sleep
 6753              	.LVL557:
 6754 3c3c 7D0FA0E3 		mov	r0, #500
 6755 3c40 FEFFFFEB 		bl	_tx_thread_sleep
 6756 3c44 7D0FA0E3 		mov	r0, #500
 6757 3c48 FEFFFFEB 		bl	_tx_thread_sleep
 6758 3c4c 7D0FA0E3 		mov	r0, #500
 6759 3c50 FEFFFFEB 		bl	_tx_thread_sleep
 6760 3c54 7D0FA0E3 		mov	r0, #500
 6761 3c58 FEFFFFEB 		bl	_tx_thread_sleep
 6762 3c5c 7D0FA0E3 		mov	r0, #500
 6763 3c60 FEFFFFEB 		bl	_tx_thread_sleep
 6764              	.LBB222:
 6765              	.LBB223:
2248:../uvc.c      ****     status = CyU3PI2cInit ();
 6766              		.loc 1 2248 0
 6767 3c64 FEFFFFEB 		bl	CyU3PI2cInit
 6768              	.LVL558:
2249:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6769              		.loc 1 2249 0
 6770 3c68 004050E2 		subs	r4, r0, #0
 6771 3c6c 0400000A 		beq	.L566
2251:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6772              		.loc 1 2251 0
 6773 3c70 0400A0E3 		mov	r0, #4
 6774              	.LVL559:
 6775 3c74 3C1B9FE5 		ldr	r1, .L678+8
 6776 3c78 FEFFFFEB 		bl	CyU3PDebugPrint
2252:../uvc.c      ****         CyFxAppErrorHandler (status);
 6777              		.loc 1 2252 0
 6778 3c7c 0400A0E1 		mov	r0, r4
 6779 3c80 FEFFFFEB 		bl	CyFxAppErrorHandler
 6780              	.L566:
2256:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6781              		.loc 1 2256 0
 6782 3c84 306B9FE5 		ldr	r6, .L678+12
2257:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6783              		.loc 1 2257 0
 6784 3c88 0050A0E3 		mov	r5, #0
2258:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6785              		.loc 1 2258 0
 6786 3c8c 0040E0E3 		mvn	r4, #0
 6787              	.LVL560:
2261:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6788              		.loc 1 2261 0
 6789 3c90 8C008DE2 		add	r0, sp, #140
 6790 3c94 0510A0E1 		mov	r1, r5
2258:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6791              		.loc 1 2258 0
 6792 3c98 94408DE5 		str	r4, [sp, #148]
2259:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6793              		.loc 1 2259 0
 6794 3c9c B849CDE1 		strh	r4, [sp, #152]	@ movhi
2256:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6795              		.loc 1 2256 0
 6796 3ca0 8C608DE5 		str	r6, [sp, #140]
2257:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6797              		.loc 1 2257 0
 6798 3ca4 90508DE5 		str	r5, [sp, #144]
2261:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6799              		.loc 1 2261 0
 6800 3ca8 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6801              	.LVL561:
2262:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6802              		.loc 1 2262 0
 6803 3cac 004050E2 		subs	r4, r0, #0
 6804 3cb0 0400000A 		beq	.L567
2264:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6805              		.loc 1 2264 0
 6806 3cb4 0400A0E3 		mov	r0, #4
 6807              	.LVL562:
 6808 3cb8 001B9FE5 		ldr	r1, .L678+16
 6809 3cbc FEFFFFEB 		bl	CyU3PDebugPrint
2265:../uvc.c      ****         CyFxAppErrorHandler (status);
 6810              		.loc 1 2265 0
 6811 3cc0 0400A0E1 		mov	r0, r4
 6812 3cc4 FEFFFFEB 		bl	CyFxAppErrorHandler
 6813              	.L567:
 6814              	.LBE223:
 6815              	.LBE222:
 6816              	.LBB224:
 6817              	.LBB227:
2335:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6818              		.loc 1 2335 0
 6819 3cc8 F44A9FE5 		ldr	r4, .L678+20
 6820              	.LVL563:
 6821 3ccc 2820A0E3 		mov	r2, #40
 6822 3cd0 0010A0E3 		mov	r1, #0
 6823 3cd4 0400A0E1 		mov	r0, r4
 6824 3cd8 FEFFFFEB 		bl	_txe_event_flags_create
 6825              	.LVL564:
2336:../uvc.c      ****     if (apiRetStatus != 0)
 6826              		.loc 1 2336 0
 6827 3cdc 002050E2 		subs	r2, r0, #0
 6828 3ce0 F800001A 		bne	.L652
2350:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6829              		.loc 1 2350 0
 6830 3ce4 0260A0E3 		mov	r6, #2
2357:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6831              		.loc 1 2357 0
 6832 3ce8 0210A0E1 		mov	r1, r2
2346:../uvc.c      ****     isUsbConnected = CyFalse;
 6833              		.loc 1 2346 0
 6834 3cec 302084E5 		str	r2, [r4, #48]
2347:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6835              		.loc 1 2347 0
 6836 3cf0 442084E5 		str	r2, [r4, #68]
2353:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6837              		.loc 1 2353 0
 6838 3cf4 0370A0E3 		mov	r7, #3
2357:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6839              		.loc 1 2357 0
 6840 3cf8 9C008DE2 		add	r0, sp, #156
 6841              	.LVL565:
2352:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6842              		.loc 1 2352 0
 6843 3cfc A420CDE5 		strb	r2, [sp, #164]
2354:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6844              		.loc 1 2354 0
 6845 3d00 A0208DE5 		str	r2, [sp, #160]
2350:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6846              		.loc 1 2350 0
 6847 3d04 9C60CDE5 		strb	r6, [sp, #156]
2351:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6848              		.loc 1 2351 0
 6849 3d08 9D60CDE5 		strb	r6, [sp, #157]
2353:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6850              		.loc 1 2353 0
 6851 3d0c A570CDE5 		strb	r7, [sp, #165]
2357:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6852              		.loc 1 2357 0
 6853 3d10 FEFFFFEB 		bl	CyU3PGpioInit
 6854              	.LVL566:
2358:../uvc.c      ****     if (apiRetStatus != 0)
 6855              		.loc 1 2358 0
 6856 3d14 002050E2 		subs	r2, r0, #0
 6857 3d18 FC00001A 		bne	.L653
2366:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6858              		.loc 1 2366 0
 6859 3d1c 1600A0E3 		mov	r0, #22
 6860              	.LVL567:
 6861 3d20 0110A0E3 		mov	r1, #1
 6862 3d24 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6863              	.LVL568:
2367:../uvc.c      ****     if (apiRetStatus != 0)
 6864              		.loc 1 2367 0
 6865 3d28 002050E2 		subs	r2, r0, #0
 6866 3d2c EE00001A 		bne	.L654
2372:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6867              		.loc 1 2372 0
 6868 3d30 1400A0E3 		mov	r0, #20
 6869              	.LVL569:
 6870 3d34 0110A0E3 		mov	r1, #1
 6871 3d38 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6872              	.LVL570:
2373:../uvc.c      ****     if (apiRetStatus != 0)
 6873              		.loc 1 2373 0
 6874 3d3c 002050E2 		subs	r2, r0, #0
 6875 3d40 FB00001A 		bne	.L655
2378:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6876              		.loc 1 2378 0
 6877 3d44 1800A0E3 		mov	r0, #24
 6878              	.LVL571:
 6879 3d48 0110A0E3 		mov	r1, #1
 6880 3d4c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6881              	.LVL572:
2379:../uvc.c      ****     if (apiRetStatus != 0)
 6882              		.loc 1 2379 0
 6883 3d50 002050E2 		subs	r2, r0, #0
 6884 3d54 D601001A 		bne	.L656
2386:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6885              		.loc 1 2386 0
 6886 3d58 0150A0E3 		mov	r5, #1
2391:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6887              		.loc 1 2391 0
 6888 3d5c 1600A0E3 		mov	r0, #22
 6889              	.LVL573:
 6890 3d60 68108DE2 		add	r1, sp, #104
2389:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6891              		.loc 1 2389 0
 6892 3d64 74208DE5 		str	r2, [sp, #116]
2390:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6893              		.loc 1 2390 0
 6894 3d68 7820CDE5 		strb	r2, [sp, #120]
2386:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6895              		.loc 1 2386 0
 6896 3d6c 68508DE5 		str	r5, [sp, #104]
2387:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6897              		.loc 1 2387 0
 6898 3d70 6C508DE5 		str	r5, [sp, #108]
2388:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6899              		.loc 1 2388 0
 6900 3d74 70508DE5 		str	r5, [sp, #112]
2391:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6901              		.loc 1 2391 0
 6902 3d78 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6903              	.LVL574:
2392:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6904              		.loc 1 2392 0
 6905 3d7c 002050E2 		subs	r2, r0, #0
 6906 3d80 C201001A 		bne	.L657
2405:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6907              		.loc 1 2405 0
 6908 3d84 1400A0E3 		mov	r0, #20
 6909              	.LVL575:
 6910 3d88 68108DE2 		add	r1, sp, #104
2403:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6911              		.loc 1 2403 0
 6912 3d8c 74208DE5 		str	r2, [sp, #116]
2404:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6913              		.loc 1 2404 0
 6914 3d90 7820CDE5 		strb	r2, [sp, #120]
2400:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6915              		.loc 1 2400 0
 6916 3d94 68508DE5 		str	r5, [sp, #104]
2401:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6917              		.loc 1 2401 0
 6918 3d98 6C508DE5 		str	r5, [sp, #108]
2402:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6919              		.loc 1 2402 0
 6920 3d9c 70508DE5 		str	r5, [sp, #112]
2405:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6921              		.loc 1 2405 0
 6922 3da0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6923              	.LVL576:
2406:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6924              		.loc 1 2406 0
 6925 3da4 002050E2 		subs	r2, r0, #0
 6926 3da8 CA01001A 		bne	.L658
2419:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6927              		.loc 1 2419 0
 6928 3dac 1800A0E3 		mov	r0, #24
 6929              	.LVL577:
 6930 3db0 68108DE2 		add	r1, sp, #104
2414:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6931              		.loc 1 2414 0
 6932 3db4 68208DE5 		str	r2, [sp, #104]
2415:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6933              		.loc 1 2415 0
 6934 3db8 6C208DE5 		str	r2, [sp, #108]
2416:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6935              		.loc 1 2416 0
 6936 3dbc 70208DE5 		str	r2, [sp, #112]
2418:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6937              		.loc 1 2418 0
 6938 3dc0 7820CDE5 		strb	r2, [sp, #120]
2417:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6939              		.loc 1 2417 0
 6940 3dc4 74508DE5 		str	r5, [sp, #116]
2419:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6941              		.loc 1 2419 0
 6942 3dc8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6943              	.LVL578:
2420:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6944              		.loc 1 2420 0
 6945 3dcc 002050E2 		subs	r2, r0, #0
 6946 3dd0 A501001A 		bne	.L659
2432:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6947              		.loc 1 2432 0
 6948 3dd4 0500A0E1 		mov	r0, r5
 6949              	.LVL579:
 6950 3dd8 7C108DE2 		add	r1, sp, #124
2429:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6951              		.loc 1 2429 0
 6952 3ddc 84208DE5 		str	r2, [sp, #132]
2430:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6953              		.loc 1 2430 0
 6954 3de0 80208DE5 		str	r2, [sp, #128]
2427:../uvc.c      ****     pibclock.clkDiv      = 2;
 6955              		.loc 1 2427 0
 6956 3de4 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2428:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6957              		.loc 1 2428 0
 6958 3de8 8870CDE5 		strb	r7, [sp, #136]
2432:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6959              		.loc 1 2432 0
 6960 3dec FEFFFFEB 		bl	CyU3PPibInit
 6961              	.LVL580:
2433:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6962              		.loc 1 2433 0
 6963 3df0 002050E2 		subs	r2, r0, #0
 6964 3df4 9301001A 		bne	.L660
2440:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6965              		.loc 1 2440 0
 6966 3df8 C8099FE5 		ldr	r0, .L678+24
 6967              	.LVL581:
 6968 3dfc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6969              	.LVL582:
2448:../uvc.c      ****     SensorReset ();
 6970              		.loc 1 2448 0
 6971 3e00 FEFFFFEB 		bl	SensorReset
2449:../uvc.c      ****     CyU3PThreadSleep(5000);
 6972              		.loc 1 2449 0
 6973 3e04 C0099FE5 		ldr	r0, .L678+28
 6974 3e08 FEFFFFEB 		bl	_tx_thread_sleep
2453:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6975              		.loc 1 2453 0
 6976 3e0c FEFFFFEB 		bl	CyU3PUsbStart
 6977              	.LVL583:
2454:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6978              		.loc 1 2454 0
 6979 3e10 002050E2 		subs	r2, r0, #0
 6980 3e14 8201001A 		bne	.L661
2460:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6981              		.loc 1 2460 0
 6982 3e18 0010A0E3 		mov	r1, #0
 6983 3e1c AC099FE5 		ldr	r0, .L678+32
 6984              	.LVL584:
 6985 3e20 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6986              	.LVL585:
2463:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6987              		.loc 1 2463 0
 6988 3e24 A8099FE5 		ldr	r0, .L678+36
 6989 3e28 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2469:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6990              		.loc 1 2469 0
 6991 3e2c 0010A0E3 		mov	r1, #0
 6992 3e30 A0299FE5 		ldr	r2, .L678+40
 6993 3e34 0100A0E3 		mov	r0, #1
 6994 3e38 FEFFFFEB 		bl	CyU3PUsbSetDesc
2470:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6995              		.loc 1 2470 0
 6996 3e3c 0000A0E3 		mov	r0, #0
 6997 3e40 0010A0E1 		mov	r1, r0
 6998 3e44 90299FE5 		ldr	r2, .L678+44
 6999 3e48 FEFFFFEB 		bl	CyU3PUsbSetDesc
2473:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7000              		.loc 1 2473 0
 7001 3e4c 0010A0E3 		mov	r1, #0
 7002 3e50 88299FE5 		ldr	r2, .L678+48
 7003 3e54 0200A0E3 		mov	r0, #2
 7004 3e58 FEFFFFEB 		bl	CyU3PUsbSetDesc
2474:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7005              		.loc 1 2474 0
 7006 3e5c 0010A0E3 		mov	r1, #0
 7007 3e60 7C299FE5 		ldr	r2, .L678+52
 7008 3e64 0700A0E3 		mov	r0, #7
 7009 3e68 FEFFFFEB 		bl	CyU3PUsbSetDesc
2477:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7010              		.loc 1 2477 0
 7011 3e6c 0010A0E3 		mov	r1, #0
 7012 3e70 70299FE5 		ldr	r2, .L678+56
 7013 3e74 0400A0E3 		mov	r0, #4
 7014 3e78 FEFFFFEB 		bl	CyU3PUsbSetDesc
2478:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7015              		.loc 1 2478 0
 7016 3e7c 0010A0E3 		mov	r1, #0
 7017 3e80 64299FE5 		ldr	r2, .L678+60
 7018 3e84 0300A0E3 		mov	r0, #3
 7019 3e88 FEFFFFEB 		bl	CyU3PUsbSetDesc
2479:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7020              		.loc 1 2479 0
 7021 3e8c 0010A0E3 		mov	r1, #0
 7022 3e90 58299FE5 		ldr	r2, .L678+64
 7023 3e94 0600A0E3 		mov	r0, #6
 7024 3e98 FEFFFFEB 		bl	CyU3PUsbSetDesc
2482:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7025              		.loc 1 2482 0
 7026 3e9c 0010A0E3 		mov	r1, #0
 7027 3ea0 4C299FE5 		ldr	r2, .L678+68
 7028 3ea4 0500A0E3 		mov	r0, #5
 7029 3ea8 FEFFFFEB 		bl	CyU3PUsbSetDesc
2483:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7030              		.loc 1 2483 0
 7031 3eac 0110A0E3 		mov	r1, #1
 7032 3eb0 40299FE5 		ldr	r2, .L678+72
 7033 3eb4 0500A0E3 		mov	r0, #5
 7034 3eb8 FEFFFFEB 		bl	CyU3PUsbSetDesc
2484:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7035              		.loc 1 2484 0
 7036 3ebc 0210A0E3 		mov	r1, #2
 7037 3ec0 34299FE5 		ldr	r2, .L678+76
 7038 3ec4 0500A0E3 		mov	r0, #5
 7039 3ec8 FEFFFFEB 		bl	CyU3PUsbSetDesc
2494:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7040              		.loc 1 2494 0
 7041 3ecc 0080A0E3 		mov	r8, #0
2491:../uvc.c      ****     endPointConfig.enable   = 1;
 7042              		.loc 1 2491 0
 7043 3ed0 0150A0E3 		mov	r5, #1
2493:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7044              		.loc 1 2493 0
 7045 3ed4 4070A0E3 		mov	r7, #64	@ movhi
2497:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7046              		.loc 1 2497 0
 7047 3ed8 8200A0E3 		mov	r0, #130
 7048 3edc A8108DE2 		add	r1, sp, #168
2492:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7049              		.loc 1 2492 0
 7050 3ee0 03A0A0E3 		mov	sl, #3
2493:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7051              		.loc 1 2493 0
 7052 3ee4 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2491:../uvc.c      ****     endPointConfig.enable   = 1;
 7053              		.loc 1 2491 0
 7054 3ee8 A8508DE5 		str	r5, [sp, #168]
2492:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7055              		.loc 1 2492 0
 7056 3eec ACA0CDE5 		strb	sl, [sp, #172]
2494:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7057              		.loc 1 2494 0
 7058 3ef0 B380CDE5 		strb	r8, [sp, #179]
2495:../uvc.c      ****     endPointConfig.streams  = 0;
 7059              		.loc 1 2495 0
 7060 3ef4 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2496:../uvc.c      ****     endPointConfig.burstLen = 1;
 7061              		.loc 1 2496 0
 7062 3ef8 B250CDE5 		strb	r5, [sp, #178]
2497:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7063              		.loc 1 2497 0
 7064 3efc FEFFFFEB 		bl	CyU3PSetEpConfig
 7065              	.LVL586:
2495:../uvc.c      ****     endPointConfig.streams  = 0;
 7066              		.loc 1 2495 0
 7067 3f00 0870A0E1 		mov	r7, r8	@ movhi
2498:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7068              		.loc 1 2498 0
 7069 3f04 003050E2 		subs	r3, r0, #0
 7070 3f08 3B01001A 		bne	.L662
2508:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7071              		.loc 1 2508 0
 7072 3f0c ECC89FE5 		ldr	ip, .L678+80
2509:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7073              		.loc 1 2509 0
 7074 3f10 ECE89FE5 		ldr	lr, .L678+84
2506:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7075              		.loc 1 2506 0
 7076 3f14 016BA0E3 		mov	r6, #1024	@ movhi
2515:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7077              		.loc 1 2515 0
 7078 3f18 1080A0E3 		mov	r8, #16
2517:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7079              		.loc 1 2517 0
 7080 3f1c E4089FE5 		ldr	r0, .L678+88
 7081              	.LVL587:
 7082 3f20 0410A0E3 		mov	r1, #4
 7083 3f24 34208DE2 		add	r2, sp, #52
2506:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7084              		.loc 1 2506 0
 7085 3f28 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2507:../uvc.c      ****     dmaInterConfig.count          = 1;
 7086              		.loc 1 2507 0
 7087 3f2c B653CDE1 		strh	r5, [sp, #54]	@ movhi
2508:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7088              		.loc 1 2508 0
 7089 3f30 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2509:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7090              		.loc 1 2509 0
 7091 3f34 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2510:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7092              		.loc 1 2510 0
 7093 3f38 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2511:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7094              		.loc 1 2511 0
 7095 3f3c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2512:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7096              		.loc 1 2512 0
 7097 3f40 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2513:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7098              		.loc 1 2513 0
 7099 3f44 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2514:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7100              		.loc 1 2514 0
 7101 3f48 4470CDE5 		strb	r7, [sp, #68]
2515:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7102              		.loc 1 2515 0
 7103 3f4c 48808DE5 		str	r8, [sp, #72]
2516:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7104              		.loc 1 2516 0
 7105 3f50 4C308DE5 		str	r3, [sp, #76]
2517:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7106              		.loc 1 2517 0
 7107 3f54 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7108              	.LVL588:
2519:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7109              		.loc 1 2519 0
 7110 3f58 006050E2 		subs	r6, r0, #0
 7111 3f5c DF00001A 		bne	.L663
2526:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7112              		.loc 1 2526 0
 7113 3f60 010BA0E3 		mov	r0, #1024
 7114              	.LVL589:
 7115 3f64 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7116 3f68 9C189FE5 		ldr	r1, .L678+92
2527:../uvc.c      ****     if (glInterStaBuffer == 0)
 7117              		.loc 1 2527 0
 7118 3f6c 000050E3 		cmp	r0, #0
2526:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7119              		.loc 1 2526 0
 7120 3f70 000081E5 		str	r0, [r1, #0]
2527:../uvc.c      ****     if (glInterStaBuffer == 0)
 7121              		.loc 1 2527 0
 7122 3f74 D000000A 		beq	.L664
2534:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7123              		.loc 1 2534 0
 7124 3f78 0610A0E1 		mov	r1, r6
 7125 3f7c 0620A0E1 		mov	r2, r6
 7126 3f80 3830A0E3 		mov	r3, #56
 7127 3f84 84089FE5 		ldr	r0, .L678+96
 7128 3f88 FEFFFFEB 		bl	_txe_mutex_create
2536:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7129              		.loc 1 2536 0
 7130 3f8c 0430A0E3 		mov	r3, #4	@ movhi
 7131 3f90 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2539:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7132              		.loc 1 2539 0
 7133 3f94 78389FE5 		ldr	r3, .L678+100
2535:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7134              		.loc 1 2535 0
 7135 3f98 01C9A0E3 		mov	ip, #16384	@ movhi
 7136 3f9c BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2538:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7137              		.loc 1 2538 0
 7138 3fa0 01CCA0E3 		mov	ip, #256	@ movhi
 7139 3fa4 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2539:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7140              		.loc 1 2539 0
 7141 3fa8 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2540:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7142              		.loc 1 2540 0
 7143 3fac 64C89FE5 		ldr	ip, .L678+104
2542:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7144              		.loc 1 2542 0
 7145 3fb0 0C30A0E3 		mov	r3, #12	@ movhi
 7146 3fb4 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2547:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7147              		.loc 1 2547 0
 7148 3fb8 5C389FE5 		ldr	r3, .L678+108
2548:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7149              		.loc 1 2548 0
 7150 3fbc 0C208DE2 		add	r2, sp, #12
2540:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7151              		.loc 1 2540 0
 7152 3fc0 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2545:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7153              		.loc 1 2545 0
 7154 3fc4 2A70CDE5 		strb	r7, [sp, #42]
2543:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7155              		.loc 1 2543 0
 7156 3fc8 04C0A0E3 		mov	ip, #4	@ movhi
2537:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7157              		.loc 1 2537 0
 7158 3fcc 02A0A0E3 		mov	sl, #2	@ movhi
2548:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7159              		.loc 1 2548 0
 7160 3fd0 48089FE5 		ldr	r0, .L678+112
 7161 3fd4 0710A0E3 		mov	r1, #7
2546:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7162              		.loc 1 2546 0
 7163 3fd8 1870A0E3 		mov	r7, #24
2537:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7164              		.loc 1 2537 0
 7165 3fdc B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2541:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7166              		.loc 1 2541 0
 7167 3fe0 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2543:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7168              		.loc 1 2543 0
 7169 3fe4 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2544:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7170              		.loc 1 2544 0
 7171 3fe8 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2546:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7172              		.loc 1 2546 0
 7173 3fec 2C708DE5 		str	r7, [sp, #44]
2547:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7174              		.loc 1 2547 0
 7175 3ff0 30308DE5 		str	r3, [sp, #48]
2548:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7176              		.loc 1 2548 0
 7177 3ff4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7178              	.LVL590:
2550:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7179              		.loc 1 2550 0
 7180 3ff8 002050E2 		subs	r2, r0, #0
 7181 3ffc A500001A 		bne	.L665
2641:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 7182              		.loc 1 2641 0
 7183 4000 0500A0E1 		mov	r0, r5
 7184              	.LVL591:
 7185 4004 0510A0E1 		mov	r1, r5
 7186 4008 FEFFFFEB 		bl	CyU3PConnectState
 7187              	.LVL592:
2642:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7188              		.loc 1 2642 0
 7189 400c 002050E2 		subs	r2, r0, #0
 7190 4010 9700001A 		bne	.L666
2648:../uvc.c      ****     CyU3PBusyWait(100);
 7191              		.loc 1 2648 0
 7192 4014 6400A0E3 		mov	r0, #100
 7193              	.LVL593:
 7194 4018 FEFFFFEB 		bl	CyU3PBusyWait
 7195              	.LVL594:
2650:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7196              		.loc 1 2650 0
 7197 401c FEFFFFEB 		bl	CyU3PUsbGetSpeed
2664:../uvc.c      ****     endPointConfig.streams  = 0;
 7198              		.loc 1 2664 0
 7199 4020 0020A0E3 		mov	r2, #0	@ movhi
2653:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7200              		.loc 1 2653 0
 7201 4024 ACA0CDE5 		strb	sl, [sp, #172]
2665:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7202              		.loc 1 2665 0
 7203 4028 A8108DE2 		add	r1, sp, #168
2664:../uvc.c      ****     endPointConfig.streams  = 0;
 7204              		.loc 1 2664 0
 7205 402c BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2652:../uvc.c      ****     endPointConfig.enable   = 1;
 7206              		.loc 1 2652 0
 7207 4030 A8508DE5 		str	r5, [sp, #168]
2654:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7208              		.loc 1 2654 0
 7209 4034 030050E3 		cmp	r0, #3
2650:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7210              		.loc 1 2650 0
 7211 4038 4800C4E5 		strb	r0, [r4, #72]
2661:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7212              		.loc 1 2661 0
 7213 403c 020CA013 		movne	r0, #512	@ movhi
2656:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7214              		.loc 1 2656 0
 7215 4040 01ABA003 		moveq	sl, #1024	@ movhi
2661:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7216              		.loc 1 2661 0
 7217 4044 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2665:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7218              		.loc 1 2665 0
 7219 4048 8300A0E3 		mov	r0, #131
2656:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7220              		.loc 1 2656 0
 7221 404c B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2657:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7222              		.loc 1 2657 0
 7223 4050 B280CD05 		streqb	r8, [sp, #178]
2662:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7224              		.loc 1 2662 0
 7225 4054 B250CD15 		strneb	r5, [sp, #178]
2665:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7226              		.loc 1 2665 0
 7227 4058 FEFFFFEB 		bl	CyU3PSetEpConfig
 7228              	.LVL595:
2666:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7229              		.loc 1 2666 0
 7230 405c 002050E2 		subs	r2, r0, #0
 7231 4060 4F00001A 		bne	.L649
 7232 4064 B8779FE5 		ldr	r7, .L678+116
 7233              	.LBE227:
 7234              	.LBE224:
2789:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7235              		.loc 1 2789 0
 7236 4068 54579FE5 		ldr	r5, .L678+20
 7237 406c 0260A0E1 		mov	r6, r2
2978:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7238              		.loc 1 2978 0
 7239 4070 0080E0E3 		mvn	r8, #0
 7240              	.LVL596:
 7241              	.L600:
2789:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7242              		.loc 1 2789 0
 7243 4074 48079FE5 		ldr	r0, .L678+20
 7244 4078 0110A0E3 		mov	r1, #1
 7245 407c 0220A0E3 		mov	r2, #2
 7246 4080 B4308DE2 		add	r3, sp, #180
 7247 4084 00608DE5 		str	r6, [sp, #0]
 7248 4088 FEFFFFEB 		bl	_txe_event_flags_get
 7249 408c 000050E3 		cmp	r0, #0
 7250 4090 3000001A 		bne	.L602
2835:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7251              		.loc 1 2835 0
 7252 4094 3CE095E5 		ldr	lr, [r5, #60]
 7253 4098 00005EE3 		cmp	lr, #0
 7254 409c 0300000A 		beq	.L603
2835:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7255              		.loc 1 2835 0 is_stmt 0 discriminator 1
 7256 40a0 B014D5E1 		ldrh	r1, [r5, #64]
 7257 40a4 B234D5E1 		ldrh	r3, [r5, #66]
 7258 40a8 030051E1 		cmp	r1, r3
 7259 40ac 1201000A 		beq	.L667
 7260              	.L603:
3039:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7261              		.loc 1 3039 0 is_stmt 1
 7262 40b0 4010A0E3 		mov	r1, #64
 7263 40b4 0020A0E3 		mov	r2, #0
 7264 40b8 04079FE5 		ldr	r0, .L678+20
 7265 40bc FEFFFFEB 		bl	_txe_event_flags_set
3042:../uvc.c      ****         CyU3PThreadRelinquish ();
 7266              		.loc 1 3042 0
 7267 40c0 FEFFFFEB 		bl	_txe_thread_relinquish
3043:../uvc.c      ****     }
 7268              		.loc 1 3043 0
 7269 40c4 EAFFFFEA 		b	.L600
 7270              	.LVL597:
 7271              	.L652:
 7272              	.LBB262:
 7273              	.LBB226:
2338:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 7274              		.loc 1 2338 0
 7275 40c8 0400A0E3 		mov	r0, #4
 7276              	.LVL598:
 7277 40cc 54179FE5 		ldr	r1, .L678+120
 7278 40d0 FEFFFFEB 		bl	CyU3PDebugPrint
 7279              	.LVL599:
 7280              	.L569:
 7281              	.LBB242:
 7282              	.LBB243:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7283              		.loc 1 1767 0
 7284 40d4 50179FE5 		ldr	r1, .L678+124
 7285 40d8 0400A0E3 		mov	r0, #4
 7286 40dc FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7287              		.loc 1 1768 0
 7288 40e0 FA0FA0E3 		mov	r0, #1000
 7289 40e4 FEFFFFEB 		bl	_tx_thread_sleep
 7290 40e8 F9FFFFEA 		b	.L569
 7291              	.LVL600:
 7292              	.L654:
 7293              	.LBE243:
 7294              	.LBE242:
2369:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 7295              		.loc 1 2369 0
 7296 40ec 0400A0E3 		mov	r0, #4
 7297              	.LVL601:
 7298 40f0 38179FE5 		ldr	r1, .L678+128
 7299 40f4 FEFFFFEB 		bl	CyU3PDebugPrint
 7300              	.LVL602:
 7301              	.L573:
 7302              	.LBB240:
 7303              	.LBB241:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7304              		.loc 1 1767 0
 7305 40f8 2C179FE5 		ldr	r1, .L678+124
 7306 40fc 0400A0E3 		mov	r0, #4
 7307 4100 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7308              		.loc 1 1768 0
 7309 4104 FA0FA0E3 		mov	r0, #1000
 7310 4108 FEFFFFEB 		bl	_tx_thread_sleep
 7311 410c F9FFFFEA 		b	.L573
 7312              	.LVL603:
 7313              	.L653:
 7314              	.LBE241:
 7315              	.LBE240:
2360:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 7316              		.loc 1 2360 0
 7317 4110 0400A0E3 		mov	r0, #4
 7318              	.LVL604:
 7319 4114 18179FE5 		ldr	r1, .L678+132
 7320 4118 FEFFFFEB 		bl	CyU3PDebugPrint
 7321              	.LVL605:
 7322              	.L571:
 7323              	.LBB238:
 7324              	.LBB239:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7325              		.loc 1 1767 0
 7326 411c 08179FE5 		ldr	r1, .L678+124
 7327 4120 0400A0E3 		mov	r0, #4
 7328 4124 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7329              		.loc 1 1768 0
 7330 4128 FA0FA0E3 		mov	r0, #1000
 7331 412c FEFFFFEB 		bl	_tx_thread_sleep
 7332 4130 F9FFFFEA 		b	.L571
 7333              	.LVL606:
 7334              	.L655:
 7335              	.LBE239:
 7336              	.LBE238:
2375:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 7337              		.loc 1 2375 0
 7338 4134 0400A0E3 		mov	r0, #4
 7339              	.LVL607:
 7340 4138 F8169FE5 		ldr	r1, .L678+136
 7341 413c FEFFFFEB 		bl	CyU3PDebugPrint
 7342              	.LVL608:
 7343              	.L575:
 7344              	.LBB236:
 7345              	.LBB237:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7346              		.loc 1 1767 0
 7347 4140 E4169FE5 		ldr	r1, .L678+124
 7348 4144 0400A0E3 		mov	r0, #4
 7349 4148 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7350              		.loc 1 1768 0
 7351 414c FA0FA0E3 		mov	r0, #1000
 7352 4150 FEFFFFEB 		bl	_tx_thread_sleep
 7353 4154 F9FFFFEA 		b	.L575
 7354              	.LVL609:
 7355              	.L602:
 7356              	.LBE237:
 7357              	.LBE236:
 7358              	.LBE226:
 7359              	.LBE262:
2946:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 7360              		.loc 1 2946 0
 7361 4158 64069FE5 		ldr	r0, .L678+20
 7362 415c 0210A0E3 		mov	r1, #2
 7363 4160 0320A0E3 		mov	r2, #3
 7364 4164 B4308DE2 		add	r3, sp, #180
 7365 4168 00608DE5 		str	r6, [sp, #0]
 7366 416c FEFFFFEB 		bl	_txe_event_flags_get
 7367 4170 000050E3 		cmp	r0, #0
 7368 4174 2500001A 		bne	.L625
2961:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7369              		.loc 1 2961 0
 7370 4178 441095E5 		ldr	r1, [r5, #68]
2949:../uvc.c      ****                 hitFV     = CyFalse;
 7371              		.loc 1 2949 0
 7372 417c 3C6085E5 		str	r6, [r5, #60]
2961:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7373              		.loc 1 2961 0
 7374 4180 000051E3 		cmp	r1, #0
2950:../uvc.c      ****                 prodCount = 0;
 7375              		.loc 1 2950 0
 7376 4184 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2957:../uvc.c      ****                 fb=0;
 7377              		.loc 1 2957 0
 7378 4188 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2951:../uvc.c      ****                 consCount = 0;
 7379              		.loc 1 2951 0
 7380 418c B264C5E1 		strh	r6, [r5, #66]	@ movhi
2958:../uvc.c      ****                 pb=0;
 7381              		.loc 1 2958 0
 7382 4190 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2959:../uvc.c      ****                 pbc=0;
 7383              		.loc 1 2959 0
 7384 4194 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2961:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7385              		.loc 1 2961 0
 7386 4198 0A00000A 		beq	.L668
 7387              	.L626:
2973:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 7388              		.loc 1 2973 0
 7389 419c 446084E5 		str	r6, [r4, #68]
 7390 41a0 C2FFFFEA 		b	.L603
 7391              	.LVL610:
 7392              	.L649:
 7393              	.LBB263:
 7394              	.LBB260:
2669:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7395              		.loc 1 2669 0
 7396 41a4 0400A0E3 		mov	r0, #4
 7397              	.LVL611:
 7398 41a8 8C169FE5 		ldr	r1, .L678+140
 7399 41ac FEFFFFEB 		bl	CyU3PDebugPrint
 7400              	.LVL612:
 7401              	.L601:
 7402              	.LBB244:
 7403              	.LBB245:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7404              		.loc 1 1767 0
 7405 41b0 74169FE5 		ldr	r1, .L678+124
 7406 41b4 0400A0E3 		mov	r0, #4
 7407 41b8 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7408              		.loc 1 1768 0
 7409 41bc FA0FA0E3 		mov	r0, #1000
 7410 41c0 FEFFFFEB 		bl	_tx_thread_sleep
 7411 41c4 F9FFFFEA 		b	.L601
 7412              	.LVL613:
 7413              	.L668:
 7414              	.LBE245:
 7415              	.LBE244:
 7416              	.LBE260:
 7417              	.LBE263:
2963:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7418              		.loc 1 2963 0
 7419 41c8 50069FE5 		ldr	r0, .L678+112
 7420 41cc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7421              	.LVL614:
2964:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7422              		.loc 1 2964 0
 7423 41d0 000050E3 		cmp	r0, #0
 7424 41d4 0200001A 		bne	.L650
2970:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 7425              		.loc 1 2970 0
 7426 41d8 8300A0E3 		mov	r0, #131
 7427              	.LVL615:
 7428 41dc FEFFFFEB 		bl	CyU3PUsbFlushEp
 7429 41e0 EDFFFFEA 		b	.L626
 7430              	.L650:
 7431              	.LBB264:
 7432              	.LBB265:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7433              		.loc 1 1767 0
 7434 41e4 40169FE5 		ldr	r1, .L678+124
 7435 41e8 0400A0E3 		mov	r0, #4
 7436 41ec FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7437              		.loc 1 1768 0
 7438 41f0 FA0FA0E3 		mov	r0, #1000
 7439 41f4 FEFFFFEB 		bl	_tx_thread_sleep
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7440              		.loc 1 1767 0
 7441 41f8 2C169FE5 		ldr	r1, .L678+124
 7442 41fc 0400A0E3 		mov	r0, #4
 7443 4200 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7444              		.loc 1 1768 0
 7445 4204 FA0FA0E3 		mov	r0, #1000
 7446 4208 FEFFFFEB 		bl	_tx_thread_sleep
 7447 420c F4FFFFEA 		b	.L650
 7448              	.L625:
 7449              	.LBE265:
 7450              	.LBE264:
2978:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7451              		.loc 1 2978 0
 7452 4210 0110A0E3 		mov	r1, #1
 7453 4214 0220A0E3 		mov	r2, #2
 7454 4218 B4308DE2 		add	r3, sp, #180
 7455 421c A0059FE5 		ldr	r0, .L678+20
 7456 4220 00808DE5 		str	r8, [sp, #0]
 7457 4224 FEFFFFEB 		bl	_txe_event_flags_get
2982:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7458              		.loc 1 2982 0
 7459 4228 0620A0E1 		mov	r2, r6
 7460 422c EC059FE5 		ldr	r0, .L678+112
 7461 4230 0610A0E1 		mov	r1, r6
 7462 4234 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7463              	.LVL616:
2983:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7464              		.loc 1 2983 0
 7465 4238 002050E2 		subs	r2, r0, #0
 7466 423c 6500001A 		bne	.L669
2991:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7467              		.loc 1 2991 0
 7468 4240 280095E5 		ldr	r0, [r5, #40]
 7469              	.LVL617:
 7470 4244 000050E3 		cmp	r0, #0
 7471 4248 5A00001A 		bne	.L631
 7472              	.LVL618:
 7473              	.LBB266:
 7474              	.LBB267:
2694:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7475              		.loc 1 2694 0
 7476 424c 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 7477 4250 030053E3 		cmp	r3, #3
 7478 4254 4700000A 		beq	.L670
2699:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7479              		.loc 1 2699 0
 7480 4258 020053E3 		cmp	r3, #2
 7481 425c 2900000A 		beq	.L671
 7482              	.LVL619:
 7483              	.L634:
 7484              	.LBE267:
 7485              	.LBE266:
3027:../uvc.c      ****                     gpif_initialized = CyTrue;
 7486              		.loc 1 3027 0
 7487 4260 0120A0E3 		mov	r2, #1
 7488 4264 282084E5 		str	r2, [r4, #40]
3028:../uvc.c      ****                     CyU3PThreadSleep(200);
 7489              		.loc 1 3028 0
 7490 4268 C800A0E3 		mov	r0, #200
 7491 426c FEFFFFEB 		bl	_tx_thread_sleep
 7492 4270 8EFFFFEA 		b	.L603
 7493              	.LVL620:
 7494              	.L666:
 7495              	.LBB273:
 7496              	.LBB225:
2644:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 7497              		.loc 1 2644 0
 7498 4274 0400A0E3 		mov	r0, #4
 7499              	.LVL621:
 7500 4278 C0159FE5 		ldr	r1, .L678+144
 7501 427c FEFFFFEB 		bl	CyU3PDebugPrint
 7502              	.LVL622:
 7503              	.L597:
 7504              	.LBB234:
 7505              	.LBB235:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7506              		.loc 1 1767 0
 7507 4280 A4159FE5 		ldr	r1, .L678+124
 7508 4284 0400A0E3 		mov	r0, #4
 7509 4288 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7510              		.loc 1 1768 0
 7511 428c FA0FA0E3 		mov	r0, #1000
 7512 4290 FEFFFFEB 		bl	_tx_thread_sleep
 7513 4294 F9FFFFEA 		b	.L597
 7514              	.LVL623:
 7515              	.L665:
 7516              	.LBE235:
 7517              	.LBE234:
2553:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 7518              		.loc 1 2553 0
 7519 4298 0400A0E3 		mov	r0, #4
 7520              	.LVL624:
 7521 429c A0159FE5 		ldr	r1, .L678+148
 7522 42a0 FEFFFFEB 		bl	CyU3PDebugPrint
 7523              	.LVL625:
 7524              	.L595:
 7525              	.LBB232:
 7526              	.LBB233:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7527              		.loc 1 1767 0
 7528 42a4 80159FE5 		ldr	r1, .L678+124
 7529 42a8 0400A0E3 		mov	r0, #4
 7530 42ac FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7531              		.loc 1 1768 0
 7532 42b0 FA0FA0E3 		mov	r0, #1000
 7533 42b4 FEFFFFEB 		bl	_tx_thread_sleep
 7534 42b8 F9FFFFEA 		b	.L595
 7535              	.LVL626:
 7536              	.L664:
 7537              	.LBE233:
 7538              	.LBE232:
2529:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 7539              		.loc 1 2529 0
 7540 42bc 040080E2 		add	r0, r0, #4
 7541 42c0 80159FE5 		ldr	r1, .L678+152
 7542 42c4 FEFFFFEB 		bl	CyU3PDebugPrint
 7543              	.LVL627:
 7544              	.L593:
 7545              	.LBB230:
 7546              	.LBB231:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7547              		.loc 1 1767 0
 7548 42c8 5C159FE5 		ldr	r1, .L678+124
 7549 42cc 0400A0E3 		mov	r0, #4
 7550 42d0 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7551              		.loc 1 1768 0
 7552 42d4 FA0FA0E3 		mov	r0, #1000
 7553 42d8 FEFFFFEB 		bl	_tx_thread_sleep
 7554 42dc F9FFFFEA 		b	.L593
 7555              	.LVL628:
 7556              	.L663:
 7557              	.LBE231:
 7558              	.LBE230:
2522:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 7559              		.loc 1 2522 0
 7560 42e0 0400A0E3 		mov	r0, #4
 7561 42e4 60159FE5 		ldr	r1, .L678+156
 7562 42e8 0620A0E1 		mov	r2, r6
 7563 42ec FEFFFFEB 		bl	CyU3PDebugPrint
 7564              	.L591:
 7565              	.LBB228:
 7566              	.LBB229:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7567              		.loc 1 1767 0
 7568 42f0 34159FE5 		ldr	r1, .L678+124
 7569 42f4 0400A0E3 		mov	r0, #4
 7570 42f8 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7571              		.loc 1 1768 0
 7572 42fc FA0FA0E3 		mov	r0, #1000
 7573 4300 FEFFFFEB 		bl	_tx_thread_sleep
 7574 4304 F9FFFFEA 		b	.L591
 7575              	.LVL629:
 7576              	.L671:
 7577              	.LBE229:
 7578              	.LBE228:
 7579              	.LBE225:
 7580              	.LBE273:
 7581              	.LBB274:
 7582              	.LBB272:
2701:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7583              		.loc 1 2701 0
 7584 4308 40159FE5 		ldr	r1, .L678+160
 7585 430c 0100A0E3 		mov	r0, #1
 7586 4310 FEFFFFEB 		bl	CyU3PDebugPrint
 7587              	.LVL630:
2702:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7588              		.loc 1 2702 0
 7589 4314 38059FE5 		ldr	r0, .L678+164
 7590 4318 FEFFFFEB 		bl	CyU3PGpifLoad
 7591 431c 0020A0E1 		mov	r2, r0
 7592              	.LVL631:
 7593              	.L633:
2704:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7594              		.loc 1 2704 0
 7595 4320 000052E3 		cmp	r2, #0
 7596 4324 1A00001A 		bne	.L672
2712:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7597              		.loc 1 2712 0
 7598 4328 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7599 432c 030053E3 		cmp	r3, #3
 7600 4330 0100000A 		beq	.L651
2716:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7601              		.loc 1 2716 0
 7602 4334 020053E3 		cmp	r3, #2
 7603 4338 C8FFFF1A 		bne	.L634
 7604              	.L651:
2718:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7605              		.loc 1 2718 0
 7606 433c 0200A0E1 		mov	r0, r2
 7607              	.LVL632:
 7608 4340 0210A0E1 		mov	r1, r2
 7609 4344 FEFFFFEB 		bl	CyU3PGpifSMStart
 7610              	.LVL633:
2720:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7611              		.loc 1 2720 0
 7612 4348 000050E3 		cmp	r0, #0
2718:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7613              		.loc 1 2718 0
 7614 434c 0020A0E1 		mov	r2, r0
 7615              	.LVL634:
2720:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7616              		.loc 1 2720 0
 7617 4350 C2FFFF0A 		beq	.L634
2723:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7618              		.loc 1 2723 0
 7619 4354 0400A0E3 		mov	r0, #4
 7620              	.LVL635:
 7621 4358 F8149FE5 		ldr	r1, .L678+168
 7622 435c FEFFFFEB 		bl	CyU3PDebugPrint
 7623              	.LVL636:
 7624              	.L639:
 7625              	.LBB268:
 7626              	.LBB269:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7627              		.loc 1 1767 0
 7628 4360 C4149FE5 		ldr	r1, .L678+124
 7629 4364 0400A0E3 		mov	r0, #4
 7630 4368 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7631              		.loc 1 1768 0
 7632 436c FA0FA0E3 		mov	r0, #1000
 7633 4370 FEFFFFEB 		bl	_tx_thread_sleep
 7634 4374 F9FFFFEA 		b	.L639
 7635              	.LVL637:
 7636              	.L670:
 7637              	.LBE269:
 7638              	.LBE268:
2696:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7639              		.loc 1 2696 0
 7640 4378 DC149FE5 		ldr	r1, .L678+172
 7641 437c 0100A0E3 		mov	r0, #1
 7642 4380 FEFFFFEB 		bl	CyU3PDebugPrint
 7643              	.LVL638:
2697:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7644              		.loc 1 2697 0
 7645 4384 D4049FE5 		ldr	r0, .L678+176
 7646 4388 FEFFFFEB 		bl	CyU3PGpifLoad
 7647 438c 0020A0E1 		mov	r2, r0
 7648              	.LVL639:
 7649 4390 E2FFFFEA 		b	.L633
 7650              	.L672:
2707:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7651              		.loc 1 2707 0
 7652 4394 0400A0E3 		mov	r0, #4
 7653              	.LVL640:
 7654 4398 C4149FE5 		ldr	r1, .L678+180
 7655 439c FEFFFFEB 		bl	CyU3PDebugPrint
 7656              	.LVL641:
 7657              	.L636:
 7658              	.LBB270:
 7659              	.LBB271:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7660              		.loc 1 1767 0
 7661 43a0 84149FE5 		ldr	r1, .L678+124
 7662 43a4 0400A0E3 		mov	r0, #4
 7663 43a8 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7664              		.loc 1 1768 0
 7665 43ac FA0FA0E3 		mov	r0, #1000
 7666 43b0 FEFFFFEB 		bl	_tx_thread_sleep
 7667 43b4 F9FFFFEA 		b	.L636
 7668              	.LVL642:
 7669              	.L631:
 7670              	.LBE271:
 7671              	.LBE270:
 7672              	.LBE272:
 7673              	.LBE274:
3035:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7674              		.loc 1 3035 0
 7675 43b8 54049FE5 		ldr	r0, .L678+100
 7676 43bc 02C0A0E3 		mov	ip, #2
 7677 43c0 0610A0E1 		mov	r1, r6
 7678 43c4 0020A0E1 		mov	r2, r0
 7679              	.LVL643:
 7680 43c8 0630A0E1 		mov	r3, r6
 7681 43cc 00C08DE5 		str	ip, [sp, #0]
 7682 43d0 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7683 43d4 35FFFFEA 		b	.L603
 7684              	.LVL644:
 7685              	.L669:
2986:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7686              		.loc 1 2986 0
 7687 43d8 0400A0E3 		mov	r0, #4
 7688              	.LVL645:
 7689 43dc 84149FE5 		ldr	r1, .L678+184
 7690 43e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7691              	.LVL646:
 7692              	.L630:
 7693              	.LBB275:
 7694              	.LBB276:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7695              		.loc 1 1767 0
 7696 43e4 40149FE5 		ldr	r1, .L678+124
 7697 43e8 0400A0E3 		mov	r0, #4
 7698 43ec FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7699              		.loc 1 1768 0
 7700 43f0 FA0FA0E3 		mov	r0, #1000
 7701 43f4 FEFFFFEB 		bl	_tx_thread_sleep
 7702 43f8 F9FFFFEA 		b	.L630
 7703              	.LVL647:
 7704              	.L662:
 7705              	.LBE276:
 7706              	.LBE275:
 7707              	.LBB277:
 7708              	.LBB261:
2501:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7709              		.loc 1 2501 0
 7710 43fc 0400A0E3 		mov	r0, #4
 7711              	.LVL648:
 7712 4400 34149FE5 		ldr	r1, .L678+140
 7713 4404 0320A0E1 		mov	r2, r3
 7714 4408 FEFFFFEB 		bl	CyU3PDebugPrint
 7715              	.LVL649:
 7716              	.L589:
 7717              	.LBB246:
 7718              	.LBB247:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7719              		.loc 1 1767 0
 7720 440c 18149FE5 		ldr	r1, .L678+124
 7721 4410 0400A0E3 		mov	r0, #4
 7722 4414 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7723              		.loc 1 1768 0
 7724 4418 FA0FA0E3 		mov	r0, #1000
 7725 441c FEFFFFEB 		bl	_tx_thread_sleep
 7726 4420 F9FFFFEA 		b	.L589
 7727              	.LVL650:
 7728              	.L661:
 7729              	.LBE247:
 7730              	.LBE246:
2456:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7731              		.loc 1 2456 0
 7732 4424 0400A0E3 		mov	r0, #4
 7733              	.LVL651:
 7734 4428 3C149FE5 		ldr	r1, .L678+188
 7735 442c FEFFFFEB 		bl	CyU3PDebugPrint
 7736              	.LVL652:
 7737              	.L587:
 7738              	.LBB248:
 7739              	.LBB249:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7740              		.loc 1 1767 0
 7741 4430 F4139FE5 		ldr	r1, .L678+124
 7742 4434 0400A0E3 		mov	r0, #4
 7743 4438 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7744              		.loc 1 1768 0
 7745 443c FA0FA0E3 		mov	r0, #1000
 7746 4440 FEFFFFEB 		bl	_tx_thread_sleep
 7747 4444 F9FFFFEA 		b	.L587
 7748              	.LVL653:
 7749              	.L660:
 7750              	.LBE249:
 7751              	.LBE248:
2435:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7752              		.loc 1 2435 0
 7753 4448 0400A0E3 		mov	r0, #4
 7754              	.LVL654:
 7755 444c 1C149FE5 		ldr	r1, .L678+192
 7756 4450 FEFFFFEB 		bl	CyU3PDebugPrint
 7757              	.LVL655:
 7758              	.L585:
 7759              	.LBB250:
 7760              	.LBB251:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7761              		.loc 1 1767 0
 7762 4454 D0139FE5 		ldr	r1, .L678+124
 7763 4458 0400A0E3 		mov	r0, #4
 7764 445c FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7765              		.loc 1 1768 0
 7766 4460 FA0FA0E3 		mov	r0, #1000
 7767 4464 FEFFFFEB 		bl	_tx_thread_sleep
 7768 4468 F9FFFFEA 		b	.L585
 7769              	.LVL656:
 7770              	.L659:
 7771              	.LBE251:
 7772              	.LBE250:
2422:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7773              		.loc 1 2422 0
 7774 446c 0400A0E3 		mov	r0, #4
 7775              	.LVL657:
 7776 4470 FC139FE5 		ldr	r1, .L678+196
 7777 4474 FEFFFFEB 		bl	CyU3PDebugPrint
 7778              	.LVL658:
 7779              	.L583:
 7780              	.LBB252:
 7781              	.LBB253:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7782              		.loc 1 1767 0
 7783 4478 AC139FE5 		ldr	r1, .L678+124
 7784 447c 0400A0E3 		mov	r0, #4
 7785 4480 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7786              		.loc 1 1768 0
 7787 4484 FA0FA0E3 		mov	r0, #1000
 7788 4488 FEFFFFEB 		bl	_tx_thread_sleep
 7789 448c F9FFFFEA 		b	.L583
 7790              	.LVL659:
 7791              	.L657:
 7792              	.LBE253:
 7793              	.LBE252:
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7794              		.loc 1 2394 0
 7795 4490 0400A0E3 		mov	r0, #4
 7796              	.LVL660:
 7797 4494 DC139FE5 		ldr	r1, .L678+200
 7798 4498 FEFFFFEB 		bl	CyU3PDebugPrint
 7799              	.LVL661:
 7800              	.L579:
 7801              	.LBB254:
 7802              	.LBB255:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7803              		.loc 1 1767 0
 7804 449c 88139FE5 		ldr	r1, .L678+124
 7805 44a0 0400A0E3 		mov	r0, #4
 7806 44a4 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7807              		.loc 1 1768 0
 7808 44a8 FA0FA0E3 		mov	r0, #1000
 7809 44ac FEFFFFEB 		bl	_tx_thread_sleep
 7810 44b0 F9FFFFEA 		b	.L579
 7811              	.LVL662:
 7812              	.L656:
 7813              	.LBE255:
 7814              	.LBE254:
2381:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7815              		.loc 1 2381 0
 7816 44b4 0400A0E3 		mov	r0, #4
 7817              	.LVL663:
 7818 44b8 BC139FE5 		ldr	r1, .L678+204
 7819 44bc FEFFFFEB 		bl	CyU3PDebugPrint
 7820              	.LVL664:
 7821              	.L577:
 7822              	.LBB256:
 7823              	.LBB257:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7824              		.loc 1 1767 0
 7825 44c0 64139FE5 		ldr	r1, .L678+124
 7826 44c4 0400A0E3 		mov	r0, #4
 7827 44c8 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7828              		.loc 1 1768 0
 7829 44cc FA0FA0E3 		mov	r0, #1000
 7830 44d0 FEFFFFEB 		bl	_tx_thread_sleep
 7831 44d4 F9FFFFEA 		b	.L577
 7832              	.LVL665:
 7833              	.L658:
 7834              	.LBE257:
 7835              	.LBE256:
2408:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7836              		.loc 1 2408 0
 7837 44d8 0400A0E3 		mov	r0, #4
 7838              	.LVL666:
 7839 44dc 9C139FE5 		ldr	r1, .L678+208
 7840 44e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7841              	.LVL667:
 7842              	.L581:
 7843              	.LBB258:
 7844              	.LBB259:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7845              		.loc 1 1767 0
 7846 44e4 40139FE5 		ldr	r1, .L678+124
 7847 44e8 0400A0E3 		mov	r0, #4
 7848 44ec FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7849              		.loc 1 1768 0
 7850 44f0 FA0FA0E3 		mov	r0, #1000
 7851 44f4 FEFFFFEB 		bl	_tx_thread_sleep
 7852 44f8 F9FFFFEA 		b	.L581
 7853              	.LVL668:
 7854              	.L667:
 7855              	.LBE259:
 7856              	.LBE258:
 7857              	.LBE261:
 7858              	.LBE277:
2845:../uvc.c      ****                 prodCount = 0;
 7859              		.loc 1 2845 0
 7860 44fc B064C5E1 		strh	r6, [r5, #64]	@ movhi
2860:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7861              		.loc 1 2860 0
 7862 4500 08039FE5 		ldr	r0, .L678+96
2846:../uvc.c      ****                 consCount = 0;
 7863              		.loc 1 2846 0
 7864 4504 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2860:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7865              		.loc 1 2860 0
 7866 4508 0010E0E3 		mvn	r1, #0
2842:../uvc.c      ****             	fb=0;
 7867              		.loc 1 2842 0
 7868 450c B463C5E1 		strh	r6, [r5, #52]	@ movhi
2843:../uvc.c      ****             	pb=0;
 7869              		.loc 1 2843 0
 7870 4510 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2844:../uvc.c      ****             	pbc=0;
 7871              		.loc 1 2844 0
 7872 4514 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2847:../uvc.c      ****                 hitFV     = CyFalse;
 7873              		.loc 1 2847 0
 7874 4518 3C6085E5 		str	r6, [r5, #60]
2860:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7875              		.loc 1 2860 0
 7876 451c FEFFFFEB 		bl	_txe_mutex_get
2861:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7877              		.loc 1 2861 0
 7878 4520 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7879 4524 012020E2 		eor	r2, r0, #1
 7880 4528 8124C7E5 		strb	r2, [r7, #1153]
2863:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7881              		.loc 1 2863 0
 7882 452c 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7883 4530 F0005CE3 		cmp	ip, #240
 7884 4534 1800000A 		beq	.L673
 7885              	.L604:
2871:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7886              		.loc 1 2871 0
 7887 4538 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7888 453c FF005AE3 		cmp	sl, #255
 7889 4540 4000000A 		beq	.L674
2883:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7890              		.loc 1 2883 0
 7891 4544 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7892 4548 AA0050E3 		cmp	r0, #170
 7893 454c 2F00000A 		beq	.L675
 7894              	.L605:
2921:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7895              		.loc 1 2921 0
 7896 4550 B8029FE5 		ldr	r0, .L678+96
 7897 4554 FEFFFFEB 		bl	_txe_mutex_put
2923:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7898              		.loc 1 2923 0
 7899 4558 C0029FE5 		ldr	r0, .L678+112
 7900 455c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7901              	.LVL669:
2924:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7902              		.loc 1 2924 0
 7903 4560 002050E2 		subs	r2, r0, #0
 7904 4564 2000001A 		bne	.L676
2931:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7905              		.loc 1 2931 0
 7906 4568 0210A0E1 		mov	r1, r2
 7907 456c AC029FE5 		ldr	r0, .L678+112
 7908              	.LVL670:
 7909 4570 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7910              	.LVL671:
2932:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7911              		.loc 1 2932 0
 7912 4574 002050E2 		subs	r2, r0, #0
 7913 4578 1200001A 		bne	.L677
2940:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7914              		.loc 1 2940 0
 7915 457c 90029FE5 		ldr	r0, .L678+100
 7916              	.LVL672:
 7917 4580 0210A0E1 		mov	r1, r2
 7918 4584 02A0A0E3 		mov	sl, #2
 7919 4588 0020A0E1 		mov	r2, r0
 7920              	.LVL673:
 7921 458c 0130A0E1 		mov	r3, r1
 7922 4590 00A08DE5 		str	sl, [sp, #0]
 7923 4594 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7924              	.LVL674:
 7925 4598 C4FEFFEA 		b	.L603
 7926              	.L673:
2863:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7927              		.loc 1 2863 0 discriminator 1
 7928 459c 20029FE5 		ldr	r0, .L678+20
 7929 45a0 8010A0E3 		mov	r1, #128
 7930 45a4 0320A0E3 		mov	r2, #3
 7931 45a8 B4308DE2 		add	r3, sp, #180
 7932 45ac 00608DE5 		str	r6, [sp, #0]
 7933 45b0 FEFFFFEB 		bl	_txe_event_flags_get
 7934 45b4 000050E3 		cmp	r0, #0
2868:../uvc.c      ****                 		stiflag = 0xFF;
 7935              		.loc 1 2868 0 discriminator 1
 7936 45b8 3A80C505 		streqb	r8, [r5, #58]
2869:../uvc.c      ****                 		IMcount = 0;
 7937              		.loc 1 2869 0 discriminator 1
 7938 45bc A160C505 		streqb	r6, [r5, #161]
2863:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7939              		.loc 1 2863 0 discriminator 1
 7940 45c0 E2FFFF0A 		beq	.L605
 7941 45c4 DBFFFFEA 		b	.L604
 7942              	.LVL675:
 7943              	.L677:
2934:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7944              		.loc 1 2934 0
 7945 45c8 0400A0E3 		mov	r0, #4
 7946              	.LVL676:
 7947 45cc B0129FE5 		ldr	r1, .L678+212
 7948 45d0 FEFFFFEB 		bl	CyU3PDebugPrint
 7949              	.LVL677:
 7950              	.L624:
 7951              	.LBB278:
 7952              	.LBB279:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7953              		.loc 1 1767 0
 7954 45d4 50129FE5 		ldr	r1, .L678+124
 7955 45d8 0400A0E3 		mov	r0, #4
 7956 45dc FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7957              		.loc 1 1768 0
 7958 45e0 FA0FA0E3 		mov	r0, #1000
 7959 45e4 FEFFFFEB 		bl	_tx_thread_sleep
 7960 45e8 F9FFFFEA 		b	.L624
 7961              	.LVL678:
 7962              	.L676:
 7963              	.LBE279:
 7964              	.LBE278:
2926:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7965              		.loc 1 2926 0
 7966 45ec 0400A0E3 		mov	r0, #4
 7967              	.LVL679:
 7968 45f0 90129FE5 		ldr	r1, .L678+216
 7969 45f4 FEFFFFEB 		bl	CyU3PDebugPrint
 7970              	.LVL680:
 7971              	.L622:
 7972              	.LBB280:
 7973              	.LBB281:
1767:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7974              		.loc 1 1767 0
 7975 45f8 2C129FE5 		ldr	r1, .L678+124
 7976 45fc 0400A0E3 		mov	r0, #4
 7977 4600 FEFFFFEB 		bl	CyU3PDebugPrint
1768:../uvc.c      ****         CyU3PThreadSleep (1000);
 7978              		.loc 1 1768 0
 7979 4604 FA0FA0E3 		mov	r0, #1000
 7980 4608 FEFFFFEB 		bl	_tx_thread_sleep
 7981 460c F9FFFFEA 		b	.L622
 7982              	.L675:
 7983              	.LBE281:
 7984              	.LBE280:
2889:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 7985              		.loc 1 2889 0
 7986 4610 A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 7987 4614 01A08EE2 		add	sl, lr, #1
 7988 4618 02005EE3 		cmp	lr, #2
 7989 461c A1A0C5E5 		strb	sl, [r5, #161]
 7990 4620 CAFFFF9A 		bls	.L605
2891:../uvc.c      ****                     switch (setRes)
 7991              		.loc 1 2891 0
 7992 4624 7D30D5E5 		ldrb	r3, [r5, #125]	@ zero_extendqisi2
 7993 4628 011043E2 		sub	r1, r3, #1
 7994 462c 030051E3 		cmp	r1, #3
 7995 4630 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 7996 4634 230000EA 		b	.L607
 7997              	.L612:
 7998 4638 28470000 		.word	.L608
 7999 463c 6C470000 		.word	.L609
 8000 4640 D4460000 		.word	.L610
 8001 4644 78460000 		.word	.L611
 8002              	.L674:
2873:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8003              		.loc 1 2873 0
 8004 4648 A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 8005 464c 01E081E2 		add	lr, r1, #1
 8006 4650 020051E3 		cmp	r1, #2
 8007 4654 A1E0C5E5 		strb	lr, [r5, #161]
 8008 4658 BCFFFF9A 		bls	.L605
2874:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8009              		.loc 1 2874 0
 8010 465c 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2875:../uvc.c      ****                 		stiflag = 0x0F;
 8011              		.loc 1 2875 0
 8012 4660 0F30A0E3 		mov	r3, #15
2874:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8013              		.loc 1 2874 0
 8014 4664 20C082E3 		orr	ip, r2, #32
 8015 4668 81C4C7E5 		strb	ip, [r7, #1153]
2876:../uvc.c      ****                 		IMcount = 0;
 8016              		.loc 1 2876 0
 8017 466c A160C5E5 		strb	r6, [r5, #161]
2875:../uvc.c      ****                 		stiflag = 0x0F;
 8018              		.loc 1 2875 0
 8019 4670 3A30C5E5 		strb	r3, [r5, #58]
 8020 4674 B5FFFFEA 		b	.L605
 8021              	.L611:
2909:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8022              		.loc 1 2909 0
 8023 4678 58E094E5 		ldr	lr, [r4, #88]
 8024 467c 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8025 4680 00005EE3 		cmp	lr, #0
 8026 4684 F4E0A003 		moveq	lr, #244
 8027 4688 74E0A013 		movne	lr, #116
 8028 468c 03208EE1 		orr	r2, lr, r3
 8029 4690 3010A0E3 		mov	r1, #48
 8030 4694 5230A0E3 		mov	r3, #82
 8031 4698 0100A0E3 		mov	r0, #1
 8032 469c FEFFFFEB 		bl	SensorSetIrisControl
2911:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8033              		.loc 1 2911 0
 8034 46a0 58C094E5 		ldr	ip, [r4, #88]
 8035 46a4 8C24D7E5 		ldrb	r2, [r7, #1164]	@ zero_extendqisi2
 8036 46a8 00005CE3 		cmp	ip, #0
 8037 46ac F4C0A003 		moveq	ip, #244
 8038 46b0 74C0A013 		movne	ip, #116
 8039 46b4 583094E5 		ldr	r3, [r4, #88]
 8040 46b8 0400A0E3 		mov	r0, #4
 8041 46bc C8119FE5 		ldr	r1, .L678+220
 8042 46c0 02208CE1 		orr	r2, ip, r2
 8043 46c4 FEFFFFEB 		bl	CyU3PDebugPrint
 8044              	.L607:
2916:../uvc.c      ****                     IMcount = 0;
 8045              		.loc 1 2916 0
 8046 46c8 A160C4E5 		strb	r6, [r4, #161]
2918:../uvc.c      ****                 	stiflag = 0x0;
 8047              		.loc 1 2918 0
 8048 46cc 3A60C4E5 		strb	r6, [r4, #58]
 8049 46d0 9EFFFFEA 		b	.L605
 8050              	.L610:
2904:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 8051              		.loc 1 2904 0
 8052 46d4 580094E5 		ldr	r0, [r4, #88]
 8053 46d8 8CA4D7E5 		ldrb	sl, [r7, #1164]	@ zero_extendqisi2
 8054 46dc 000050E3 		cmp	r0, #0
 8055 46e0 C400A003 		moveq	r0, #196
 8056 46e4 4400A013 		movne	r0, #68
 8057 46e8 0A2080E1 		orr	r2, r0, sl
 8058 46ec 3010A0E3 		mov	r1, #48
 8059 46f0 5230A0E3 		mov	r3, #82
 8060 46f4 0100A0E3 		mov	r0, #1
 8061 46f8 FEFFFFEB 		bl	SensorSetIrisControl
2906:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 8062              		.loc 1 2906 0
 8063 46fc 582094E5 		ldr	r2, [r4, #88]
 8064 4700 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 8065 4704 000052E3 		cmp	r2, #0
 8066 4708 C420A003 		moveq	r2, #196
 8067 470c 4420A013 		movne	r2, #68
 8068 4710 583094E5 		ldr	r3, [r4, #88]
 8069 4714 70119FE5 		ldr	r1, .L678+220
 8070 4718 0C2082E1 		orr	r2, r2, ip
 8071 471c 0400A0E3 		mov	r0, #4
 8072 4720 FEFFFFEB 		bl	CyU3PDebugPrint
2907:../uvc.c      ****                  		break;
 8073              		.loc 1 2907 0
 8074 4724 E7FFFFEA 		b	.L607
 8075              	.L608:
2894:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 8076              		.loc 1 2894 0
 8077 4728 582094E5 		ldr	r2, [r4, #88]
 8078 472c 3010A0E3 		mov	r1, #48
 8079 4730 000052E3 		cmp	r2, #0
 8080 4734 E420A003 		moveq	r2, #228
 8081 4738 6420A013 		movne	r2, #100
 8082 473c 5230A0E3 		mov	r3, #82
 8083 4740 0100A0E3 		mov	r0, #1
 8084 4744 FEFFFFEB 		bl	SensorSetIrisControl
2896:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 8085              		.loc 1 2896 0
 8086 4748 582094E5 		ldr	r2, [r4, #88]
 8087 474c 38119FE5 		ldr	r1, .L678+220
 8088 4750 000052E3 		cmp	r2, #0
 8089 4754 583094E5 		ldr	r3, [r4, #88]
 8090 4758 E420A003 		moveq	r2, #228
 8091 475c 6420A013 		movne	r2, #100
 8092 4760 0400A0E3 		mov	r0, #4
 8093 4764 FEFFFFEB 		bl	CyU3PDebugPrint
2897:../uvc.c      ****                  		break;
 8094              		.loc 1 2897 0
 8095 4768 D6FFFFEA 		b	.L607
 8096              	.L609:
2899:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 8097              		.loc 1 2899 0
 8098 476c 582094E5 		ldr	r2, [r4, #88]
 8099 4770 3010A0E3 		mov	r1, #48
 8100 4774 000052E3 		cmp	r2, #0
 8101 4778 D420A003 		moveq	r2, #212
 8102 477c 5420A013 		movne	r2, #84
 8103 4780 5230A0E3 		mov	r3, #82
 8104 4784 0100A0E3 		mov	r0, #1
 8105 4788 FEFFFFEB 		bl	SensorSetIrisControl
2901:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 8106              		.loc 1 2901 0
 8107 478c 582094E5 		ldr	r2, [r4, #88]
 8108 4790 F4109FE5 		ldr	r1, .L678+220
 8109 4794 000052E3 		cmp	r2, #0
 8110 4798 583094E5 		ldr	r3, [r4, #88]
 8111 479c D420A003 		moveq	r2, #212
 8112 47a0 5420A013 		movne	r2, #84
 8113 47a4 0400A0E3 		mov	r0, #4
 8114 47a8 FEFFFFEB 		bl	CyU3PDebugPrint
2902:../uvc.c      ****                  		break;
 8115              		.loc 1 2902 0
 8116 47ac C5FFFFEA 		b	.L607
 8117              	.L679:
 8118              		.align	2
 8119              	.L678:
 8120 47b0 10080000 		.word	.LC45
 8121 47b4 00C20100 		.word	115200
 8122 47b8 30080000 		.word	.LC46
 8123 47bc A0860100 		.word	100000
 8124 47c0 4C080000 		.word	.LC47
 8125 47c4 00000000 		.word	.LANCHOR0
 8126 47c8 00000000 		.word	CyFxGpifCB
 8127 47cc 88130000 		.word	5000
 8128 47d0 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8129 47d4 00000000 		.word	CyFxUVCApplnUSBEventCB
 8130 47d8 00000000 		.word	CyFxUSBDeviceDscr
 8131 47dc 00000000 		.word	CyFxUSBDeviceDscrSS
 8132 47e0 00000000 		.word	CyFxUSBDeviceQualDscr
 8133 47e4 00000000 		.word	CyFxUSBBOSDscr
 8134 47e8 00000000 		.word	CyFxUSBHSConfigDscr
 8135 47ec 00000000 		.word	CyFxUSBFSConfigDscr
 8136 47f0 00000000 		.word	CyFxUSBSSConfigDscr
 8137 47f4 00000000 		.word	CyFxUSBStringLangIDDscr
 8138 47f8 00000000 		.word	CyFxUSBManufactureDscr
 8139 47fc 00000000 		.word	CyFxUSBProductDscr
 8140 4800 013F0000 		.word	16129
 8141 4804 02030000 		.word	770
 8142 4808 00000000 		.word	glChHandleInterStat
 8143 480c 00000000 		.word	glInterStaBuffer
 8144 4810 00000000 		.word	imgHdMux
 8145 4814 01010000 		.word	257
 8146 4818 03030000 		.word	771
 8147 481c 00000000 		.word	CyFxUvcApplnDmaCallback
 8148 4820 00000000 		.word	glChHandleUVCStream
 8149 4824 00000000 		.word	.LANCHOR1
 8150 4828 68080000 		.word	.LC48
 8151 482c D8010000 		.word	.LC12
 8152 4830 B8080000 		.word	.LC50
 8153 4834 94080000 		.word	.LC49
 8154 4838 E0080000 		.word	.LC51
 8155 483c 380A0000 		.word	.LC58
 8156 4840 140B0000 		.word	.LC62
 8157 4844 E40A0000 		.word	.LC61
 8158 4848 AC0A0000 		.word	.LC60
 8159 484c 6C0A0000 		.word	.LC59
 8160 4850 040C0000 		.word	.LC68
 8161 4854 FC000000 		.word	.LANCHOR2+252
 8162 4858 4C0C0000 		.word	.LC70
 8163 485c F40B0000 		.word	.LC67
 8164 4860 E0000000 		.word	.LANCHOR2+224
 8165 4864 140C0000 		.word	.LC69
 8166 4868 C00B0000 		.word	.LC66
 8167 486c 080A0000 		.word	.LC57
 8168 4870 D8090000 		.word	.LC56
 8169 4874 A0090000 		.word	.LC55
 8170 4878 38090000 		.word	.LC53
 8171 487c 0C090000 		.word	.LC52
 8172 4880 6C090000 		.word	.LC54
 8173 4884 8C0B0000 		.word	.LC65
 8174 4888 600B0000 		.word	.LC64
 8175 488c 3C0B0000 		.word	.LC63
 8176              		.cfi_endproc
 8177              	.LFE19:
 8179              		.align	2
 8180              		.global	CyFxApplicationDefine
 8182              	CyFxApplicationDefine:
 8183              	.LFB27:
4348:../uvc.c      **** }
4349:../uvc.c      **** 
4350:../uvc.c      **** 
4351:../uvc.c      **** /*
4352:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4353:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4354:../uvc.c      ****  */
4355:../uvc.c      **** void
4356:../uvc.c      **** CyFxApplicationDefine (
4357:../uvc.c      ****         void)
4358:../uvc.c      **** {
 8184              		.loc 1 4358 0
 8185              		.cfi_startproc
 8186              		@ args = 0, pretend = 0, frame = 40
 8187              		@ frame_needed = 0, uses_anonymous_args = 0
 8188              	.LVL681:
 8189 4890 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8190              	.LCFI27:
 8191              		.cfi_def_cfa_offset 36
4359:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4360:../uvc.c      ****     uint32_t retThrdCreate;
4361:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4362:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4363:../uvc.c      **** 
4364:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4365:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8192              		.loc 1 4365 0
 8193 4894 010AA0E3 		mov	r0, #4096
4358:../uvc.c      **** {
 8194              		.loc 1 4358 0
 8195 4898 4CD04DE2 		sub	sp, sp, #76
 8196              	.LCFI28:
 8197              		.cfi_def_cfa_offset 112
 8198              		.loc 1 4365 0
 8199              		.cfi_offset 14, -4
 8200              		.cfi_offset 11, -8
 8201              		.cfi_offset 10, -12
 8202              		.cfi_offset 9, -16
 8203              		.cfi_offset 8, -20
 8204              		.cfi_offset 7, -24
 8205              		.cfi_offset 6, -28
 8206              		.cfi_offset 5, -32
 8207              		.cfi_offset 4, -36
 8208 489c FEFFFFEB 		bl	CyU3PMemAlloc
 8209 48a0 00A0A0E1 		mov	sl, r0
 8210              	.LVL682:
4366:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8211              		.loc 1 4366 0
 8212 48a4 010AA0E3 		mov	r0, #4096
 8213              	.LVL683:
 8214 48a8 FEFFFFEB 		bl	CyU3PMemAlloc
 8215 48ac 00B0A0E1 		mov	fp, r0
 8216              	.LVL684:
4367:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8217              		.loc 1 4367 0
 8218 48b0 010AA0E3 		mov	r0, #4096
 8219              	.LVL685:
 8220 48b4 FEFFFFEB 		bl	CyU3PMemAlloc
4368:../uvc.c      **** 
4369:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 8221              		.loc 1 4369 0
 8222 48b8 00005AE3 		cmp	sl, #0
 8223 48bc 00005B13 		cmpne	fp, #0
 8224 48c0 0090A013 		movne	r9, #0
 8225 48c4 0190A003 		moveq	r9, #1
4367:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8226              		.loc 1 4367 0
 8227 48c8 24008DE5 		str	r0, [sp, #36]
 8228              	.LVL686:
 8229              		.loc 1 4369 0
 8230 48cc 0000001A 		bne	.L684
 8231              	.LVL687:
 8232              	.L681:
 8233              	.L683:
 8234 48d0 FEFFFFEA 		b	.L683
 8235              	.L684:
 8236              		.loc 1 4369 0 is_stmt 0 discriminator 1
 8237 48d4 000050E3 		cmp	r0, #0
 8238 48d8 FCFFFF0A 		beq	.L681
4370:../uvc.c      ****         goto fatalErrorHandler;
4371:../uvc.c      **** 
4372:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4373:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8239              		.loc 1 4373 0 is_stmt 1
 8240 48dc 28408DE2 		add	r4, sp, #40
 8241 48e0 0400A0E1 		mov	r0, r4
 8242 48e4 4010A0E3 		mov	r1, #64
 8243 48e8 18219FE5 		ldr	r2, .L685
 8244 48ec FEFFFFEB 		bl	cmdbufCreate
 8245 48f0 0450A0E1 		mov	r5, r4
 8246 48f4 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 8247 48f8 0C719FE5 		ldr	r7, .L685+4
4374:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8248              		.loc 1 4374 0
 8249 48fc 0C819FE5 		ldr	r8, .L685+8
4373:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8250              		.loc 1 4373 0
 8251 4900 07C0A0E1 		mov	ip, r7
 8252 4904 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8253 4908 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4375:../uvc.c      **** 
4376:../uvc.c      **** 	/****** initialize command descriptor ***********/
4377:../uvc.c      **** 	cmdquInit(cmdQuptr);
4378:../uvc.c      **** 	cmdquInit(statQuptr);
4379:../uvc.c      **** 
4380:../uvc.c      ****     /* Create the UVC application thread. */
4381:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 8254              		.loc 1 4381 0
 8255 490c 0860A0E3 		mov	r6, #8
4373:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8256              		.loc 1 4373 0
 8257 4910 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4374:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8258              		.loc 1 4374 0
 8259 4914 F8209FE5 		ldr	r2, .L685+12
 8260 4918 0400A0E1 		mov	r0, r4
 8261 491c 2010A0E3 		mov	r1, #32
 8262 4920 FEFFFFEB 		bl	cmdbufCreate
 8263 4924 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 8264 4928 08C0A0E1 		mov	ip, r8
 8265 492c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8266 4930 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 8267              		.loc 1 4381 0
 8268 4934 0140A0E3 		mov	r4, #1
4374:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8269              		.loc 1 4374 0
 8270 4938 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4377:../uvc.c      **** 	cmdquInit(cmdQuptr);
 8271              		.loc 1 4377 0
 8272 493c 0700A0E1 		mov	r0, r7
 8273 4940 FEFFFFEB 		bl	cmdquInit
4378:../uvc.c      **** 	cmdquInit(statQuptr);
 8274              		.loc 1 4378 0
 8275 4944 0800A0E1 		mov	r0, r8
 8276 4948 FEFFFFEB 		bl	cmdquInit
 8277              		.loc 1 4381 0
 8278 494c A850A0E3 		mov	r5, #168
 8279 4950 01CAA0E3 		mov	ip, #4096
 8280 4954 BC009FE5 		ldr	r0, .L685+16
 8281 4958 BC109FE5 		ldr	r1, .L685+20
 8282 495c BC209FE5 		ldr	r2, .L685+24
 8283 4960 0930A0E1 		mov	r3, r9
 8284 4964 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 8285 4968 08608DE5 		str	r6, [sp, #8]
 8286 496c 0C608DE5 		str	r6, [sp, #12]
 8287 4970 10908DE5 		str	r9, [sp, #16]
 8288 4974 14408DE5 		str	r4, [sp, #20]
 8289 4978 18508DE5 		str	r5, [sp, #24]
 8290 497c FEFFFFEB 		bl	_txe_thread_create
 8291              	.LVL688:
4382:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4383:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4384:../uvc.c      ****             0,                                          /* No input parameter to thread */
4385:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4386:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4387:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4388:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4389:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4390:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4391:../uvc.c      ****             );
4392:../uvc.c      ****     if (retThrdCreate != 0)
 8292              		.loc 1 4392 0
 8293 4980 00C050E2 		subs	ip, r0, #0
 8294 4984 D1FFFF1A 		bne	.L681
4393:../uvc.c      ****     {
4394:../uvc.c      ****         goto fatalErrorHandler;
4395:../uvc.c      ****     }
4396:../uvc.c      **** 
4397:../uvc.c      ****     /* Create the control request handling thread. */
4398:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 8295              		.loc 1 4398 0
 8296 4988 0C30A0E1 		mov	r3, ip
 8297 498c 027BA0E3 		mov	r7, #2048
 8298 4990 8C009FE5 		ldr	r0, .L685+28
 8299              	.LVL689:
 8300 4994 8C109FE5 		ldr	r1, .L685+32
 8301 4998 8C209FE5 		ldr	r2, .L685+36
 8302 499c 10C08DE5 		str	ip, [sp, #16]
 8303 49a0 00B08DE5 		str	fp, [sp, #0]
 8304 49a4 04708DE5 		str	r7, [sp, #4]
 8305 49a8 08608DE5 		str	r6, [sp, #8]
 8306 49ac 0C608DE5 		str	r6, [sp, #12]
 8307 49b0 14408DE5 		str	r4, [sp, #20]
 8308 49b4 18508DE5 		str	r5, [sp, #24]
 8309 49b8 FEFFFFEB 		bl	_txe_thread_create
 8310              	.LVL690:
4399:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4400:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4401:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4402:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4403:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4404:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4405:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4406:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4407:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4408:../uvc.c      ****             );
4409:../uvc.c      ****     if (retThrdCreate != 0)
 8311              		.loc 1 4409 0
 8312 49bc 00C050E2 		subs	ip, r0, #0
 8313 49c0 C2FFFF1A 		bne	.L681
4410:../uvc.c      ****     {
4411:../uvc.c      ****         goto fatalErrorHandler;
4412:../uvc.c      ****     }
4413:../uvc.c      **** #if 1
4414:../uvc.c      ****     /* Create the I2C control command handling thread. */
4415:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 8314              		.loc 1 4415 0
 8315 49c4 24E09DE5 		ldr	lr, [sp, #36]
 8316 49c8 60009FE5 		ldr	r0, .L685+40
 8317              	.LVL691:
 8318 49cc 60109FE5 		ldr	r1, .L685+44
 8319 49d0 60209FE5 		ldr	r2, .L685+48
 8320 49d4 0C30A0E1 		mov	r3, ip
 8321 49d8 00E08DE5 		str	lr, [sp, #0]
 8322 49dc 04708DE5 		str	r7, [sp, #4]
 8323 49e0 08608DE5 		str	r6, [sp, #8]
 8324 49e4 0C608DE5 		str	r6, [sp, #12]
 8325 49e8 10C08DE5 		str	ip, [sp, #16]
 8326 49ec 14408DE5 		str	r4, [sp, #20]
 8327 49f0 18508DE5 		str	r5, [sp, #24]
 8328 49f4 FEFFFFEB 		bl	_txe_thread_create
 8329              	.LVL692:
4416:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4417:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4418:../uvc.c      ****             0,                                          /* No input parameter to thread */
4419:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4420:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4421:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4422:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4423:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4424:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4425:../uvc.c      ****             );
4426:../uvc.c      ****     if (retThrdCreate != 0)
 8330              		.loc 1 4426 0
 8331 49f8 000050E3 		cmp	r0, #0
 8332 49fc B3FFFF1A 		bne	.L681
4427:../uvc.c      ****     {
4428:../uvc.c      ****         goto fatalErrorHandler;
4429:../uvc.c      ****     }
4430:../uvc.c      **** #endif
4431:../uvc.c      **** 
4432:../uvc.c      ****     return;
4433:../uvc.c      **** 
4434:../uvc.c      **** fatalErrorHandler:
4435:../uvc.c      ****     /* Add custom recovery or debug actions here */
4436:../uvc.c      ****     /* Loop indefinitely */
4437:../uvc.c      ****     while (1);
4438:../uvc.c      **** }
 8333              		.loc 1 4438 0
 8334 4a00 4CD08DE2 		add	sp, sp, #76
 8335 4a04 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8336              	.L686:
 8337              		.align	2
 8338              	.L685:
 8339 4a08 00000000 		.word	cmdQuMux
 8340 4a0c 00000000 		.word	cmdQu
 8341 4a10 00000000 		.word	statQu
 8342 4a14 00000000 		.word	staQuMux
 8343 4a18 A4000000 		.word	.LANCHOR0+164
 8344 4a1c 840C0000 		.word	.LC71
 8345 4a20 00000000 		.word	UVCAppThread_Entry
 8346 4a24 4C010000 		.word	.LANCHOR0+332
 8347 4a28 980C0000 		.word	.LC72
 8348 4a2c 00000000 		.word	UVCAppEP0Thread_Entry
 8349 4a30 F4010000 		.word	.LANCHOR0+500
 8350 4a34 B00C0000 		.word	.LC73
 8351 4a38 00000000 		.word	I2cAppThread_Entry
 8352              		.cfi_endproc
 8353              	.LFE27:
 8355              		.align	2
 8356              		.global	main
 8358              	main:
 8359              	.LFB28:
4439:../uvc.c      **** 
4440:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4441:../uvc.c      ****  * the ThreadX RTOS here.
4442:../uvc.c      ****  */
4443:../uvc.c      **** int
4444:../uvc.c      **** main (
4445:../uvc.c      ****         void)
4446:../uvc.c      **** {
 8360              		.loc 1 4446 0
 8361              		.cfi_startproc
 8362              		@ args = 0, pretend = 0, frame = 56
 8363              		@ frame_needed = 0, uses_anonymous_args = 0
 8364 4a3c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 8365              	.LCFI29:
 8366              		.cfi_def_cfa_offset 12
4447:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4448:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4449:../uvc.c      **** 
4450:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4451:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4452:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4453:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4454:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4455:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8367              		.loc 1 4455 0
 8368 4a40 0010A0E3 		mov	r1, #0
4446:../uvc.c      **** {
 8369              		.loc 1 4446 0
 8370 4a44 3CD04DE2 		sub	sp, sp, #60
 8371              	.LCFI30:
 8372              		.cfi_def_cfa_offset 72
4452:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8373              		.loc 1 4452 0
 8374 4a48 0220A0E3 		mov	r2, #2
4456:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8375              		.loc 1 4456 0
 8376 4a4c 033081E2 		add	r3, r1, #3
4451:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8377              		.loc 1 4451 0
 8378 4a50 0150A0E3 		mov	r5, #1
 8379              		.cfi_offset 14, -4
 8380              		.cfi_offset 5, -8
 8381              		.cfi_offset 4, -12
4457:../uvc.c      **** 
4458:../uvc.c      ****     /* Initialize the device */
4459:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 8382              		.loc 1 4459 0
 8383 4a54 28008DE2 		add	r0, sp, #40
4451:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8384              		.loc 1 4451 0
 8385 4a58 28508DE5 		str	r5, [sp, #40]
4452:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8386              		.loc 1 4452 0
 8387 4a5c 2C20CDE5 		strb	r2, [sp, #44]
4453:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 8388              		.loc 1 4453 0
 8389 4a60 2D20CDE5 		strb	r2, [sp, #45]
4454:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 8390              		.loc 1 4454 0
 8391 4a64 2E20CDE5 		strb	r2, [sp, #46]
4455:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8392              		.loc 1 4455 0
 8393 4a68 30108DE5 		str	r1, [sp, #48]
4456:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8394              		.loc 1 4456 0
 8395 4a6c 3430CDE5 		strb	r3, [sp, #52]
 8396              		.loc 1 4459 0
 8397 4a70 FEFFFFEB 		bl	CyU3PDeviceInit
 8398              	.LVL693:
4460:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8399              		.loc 1 4460 0
 8400 4a74 004050E2 		subs	r4, r0, #0
 8401 4a78 0000000A 		beq	.L690
 8402              	.L688:
 8403              	.L689:
 8404 4a7c FEFFFFEA 		b	.L689
 8405              	.L690:
4461:../uvc.c      ****     {
4462:../uvc.c      ****         goto handle_fatal_error;
4463:../uvc.c      ****     }
4464:../uvc.c      **** 
4465:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4466:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 8406              		.loc 1 4466 0
 8407 4a80 0410A0E1 		mov	r1, r4
 8408 4a84 0420A0E1 		mov	r2, r4
 8409 4a88 0500A0E1 		mov	r0, r5
 8410              	.LVL694:
 8411 4a8c FEFFFFEB 		bl	CyU3PDeviceCacheControl
 8412              	.LVL695:
4467:../uvc.c      **** 
4468:../uvc.c      ****     /* Configure the IO matrix for the device. */
4469:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4470:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4471:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4472:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4473:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4474:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4475:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4476:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4477:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4478:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4479:../uvc.c      **** 
4480:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 8413              		.loc 1 4480 0
 8414 4a90 0D00A0E1 		mov	r0, sp
4470:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 8415              		.loc 1 4470 0
 8416 4a94 1640CDE5 		strb	r4, [sp, #22]
4471:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 8417              		.loc 1 4471 0
 8418 4a98 18408DE5 		str	r4, [sp, #24]
4472:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 8419              		.loc 1 4472 0
 8420 4a9c 1C408DE5 		str	r4, [sp, #28]
4473:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 8421              		.loc 1 4473 0
 8422 4aa0 20408DE5 		str	r4, [sp, #32]
4474:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 8423              		.loc 1 4474 0
 8424 4aa4 24408DE5 		str	r4, [sp, #36]
4477:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 8425              		.loc 1 4477 0
 8426 4aa8 0C408DE5 		str	r4, [sp, #12]
4478:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 8427              		.loc 1 4478 0
 8428 4aac 10408DE5 		str	r4, [sp, #16]
4469:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 8429              		.loc 1 4469 0
 8430 4ab0 00508DE5 		str	r5, [sp, #0]
4475:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 8431              		.loc 1 4475 0
 8432 4ab4 04508DE5 		str	r5, [sp, #4]
4476:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 8433              		.loc 1 4476 0
 8434 4ab8 08508DE5 		str	r5, [sp, #8]
 8435              		.loc 1 4480 0
 8436 4abc FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 8437              	.LVL696:
4481:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8438              		.loc 1 4481 0
 8439 4ac0 004050E2 		subs	r4, r0, #0
 8440 4ac4 ECFFFF1A 		bne	.L688
4482:../uvc.c      ****     {
4483:../uvc.c      ****         goto handle_fatal_error;
4484:../uvc.c      ****     }
4485:../uvc.c      **** 
4486:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4487:../uvc.c      ****     CyU3PKernelEntry ();
 8441              		.loc 1 4487 0
 8442 4ac8 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 8443              	.LVL697:
4488:../uvc.c      **** 
4489:../uvc.c      ****     /* Dummy return to make the compiler happy */
4490:../uvc.c      ****     return 0;
4491:../uvc.c      **** 
4492:../uvc.c      **** handle_fatal_error:
4493:../uvc.c      ****     /* Cannot recover from this error. */
4494:../uvc.c      ****     while (1);
4495:../uvc.c      **** }
 8444              		.loc 1 4495 0
 8445 4acc 0400A0E1 		mov	r0, r4
 8446 4ad0 3CD08DE2 		add	sp, sp, #60
 8447 4ad4 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 8448              		.cfi_endproc
 8449              	.LFE28:
 8451              		.global	CyFxGpifTransition
 8452              		.global	CyFxGpifWavedata
 8453              		.global	CyFxGpifWavedataPosition
 8454              		.global	CyFxGpifRegValue
 8455              		.global	CyFxGpifConfig
 8456              		.global	CyFxGpifTransition_usb2
 8457              		.global	CyFxGpifWavedata_usb2
 8458              		.global	CyFxGpifWavedataPosition_usb2
 8459              		.global	CyFxGpifRegValue_usb2
 8460              		.global	CyFxGpifConfig_usb2
 8461              		.global	snapButFlag
 8462              		.global	testSnap
 8463              		.global	fb
 8464              		.global	pb
 8465              		.global	pbc
 8466              		.global	fbbak
 8467              		.global	pbbak
 8468              		.global	pbcbak
 8469              		.global	pbcpbak
 8470              		.global	isUsbConnected
 8471              		.global	usbSpeed
 8472              		.global	clearFeatureRqtReceived
 8473              		.global	streamingStarted
 8474              		.global	glProbeCtrl
 8475              		.global	glProbeCtrlFull
 8476              		.global	glProbeStilCtrl
 8477              		.global	glProbeCtrl20
 8478              		.global	glProbeStilCtrl20
 8479              		.global	glUVCHeader
 8480              		.comm	glChHandleUVCStream,220,4
 8481              		.comm	glChHandleStillStream,220,4
 8482              		.comm	glChHandleInterStat,160,4
 8483              		.comm	glInterStaBuffer,4,4
 8484              		.comm	cmdQu,32,4
 8485              		.comm	statQu,32,4
 8486              		.comm	cmdQuMux,56,4
 8487              		.comm	staQuMux,56,4
 8488              		.comm	timMux,56,4
 8489              		.comm	imgHdMux,56,4
 8490              		.comm	bmReqType,1,1
 8491              		.comm	bRequest,1,1
 8492              		.comm	wValue,2,2
 8493              		.comm	wIndex,2,2
 8494              		.comm	wLength,2,2
 8495              		.comm	posTick,4,4
 8496              		.comm	I2CCmdTimer,44,4
 8497              		.section	.rodata
 8498              		.align	2
 8499              		.set	.LANCHOR2,. + 0
 8502              	ShutSp:
 8503 0000 3582     		.short	-32203
 8504 0002 1B41     		.short	16667
 8505 0004 8D20     		.short	8333
 8506 0006 A00F     		.short	4000
 8507 0008 D007     		.short	2000
 8508 000a E803     		.short	1000
 8509 000c F401     		.short	500
 8510 000e C800     		.short	200
 8511 0010 6400     		.short	100
 8512 0012 0A00     		.short	10
 8513 0014 0000     		.short	0
 8514 0016 00000000 		.space	10
 8514      00000000 
 8514      0000
 8517              	pEXTSenCtrl:
 8518 0020 90040000 		.word	EXTShutter
 8519 0024 00000000 		.word	0
 8520 0028 00000000 		.word	0
 8521 002c 00000000 		.word	0
 8522 0030 00000000 		.word	0
 8523 0034 00000000 		.word	0
 8524 0038 00000000 		.word	0
 8525 003c 00000000 		.word	0
 8526 0040 00000000 		.word	0
 8527 0044 B8040000 		.word	EXTAexModGainlev
 8528 0048 00000000 		.word	0
 8529 004c A4040000 		.word	EXTShutlev
 8530 0050 00000000 		.word	0
 8531 0054 00000000 		.word	0
 8532 0058 00000000 		.word	0
 8533 005c 00000000 		.word	0
 8534 0060 00000000 		.word	0
 8535 0064 00000000 		.word	0
 8536 0068 00000000 		.word	0
 8537 006c 00000000 		.word	0
 8538 0070 D0040000 		.word	EXTBLCWinPos
 8539 0074 E4040000 		.word	EXTBLCWeight
 8540 0078 00000000 		.word	0
 8541 007c 00000000 		.word	0
 8542 0080 00000000 		.space	32
 8542      00000000 
 8542      00000000 
 8542      00000000 
 8542      00000000 
 8545              	pPUCSenCtrl:
 8546 00a0 F8040000 		.word	PUCBLC
 8547 00a4 00000000 		.word	0
 8548 00a8 00000000 		.word	0
 8549 00ac 00000000 		.word	0
 8550 00b0 00000000 		.word	0
 8551 00b4 00000000 		.word	0
 8552 00b8 00000000 		.word	0
 8553 00bc 0C050000 		.word	PUCSharp
 8554 00c0 00000000 		.word	0
 8555 00c4 00000000 		.word	0
 8556 00c8 00000000 		.word	0
 8557 00cc 00000000 		.word	0
 8558 00d0 00000000 		.word	0
 8559 00d4 00000000 		.word	0
 8560 00d8 00000000 		.word	0
 8561 00dc 00000000 		.word	0
 8564              	CyFxGpifConfig:
 8565 00e0 0F00     		.short	15
 8566 00e2 0000     		.space	2
 8567 00e4 00000000 		.word	CyFxGpifWavedata
 8568 00e8 00000000 		.word	CyFxGpifWavedataPosition
 8569 00ec 0500     		.short	5
 8570 00ee 0000     		.space	2
 8571 00f0 00000000 		.word	CyFxGpifTransition
 8572 00f4 4C00     		.short	76
 8573 00f6 0000     		.space	2
 8574 00f8 00000000 		.word	CyFxGpifRegValue
 8577              	CyFxGpifConfig_usb2:
 8578 00fc 9300     		.short	147
 8579 00fe 0000     		.space	2
 8580 0100 00000000 		.word	CyFxGpifWavedata_usb2
 8581 0104 00000000 		.word	CyFxGpifWavedataPosition_usb2
 8582 0108 0800     		.short	8
 8583 010a 0000     		.space	2
 8584 010c 00000000 		.word	CyFxGpifTransition_usb2
 8585 0110 4C00     		.short	76
 8586 0112 0000     		.space	2
 8587 0114 00000000 		.word	CyFxGpifRegValue_usb2
 8588              		.data
 8589              		.align	2
 8590              		.set	.LANCHOR1,. + 0
 8593              	ExUCtrlParArry:
 8594 0000 00       		.byte	0
 8595 0001 00       		.byte	0
 8596 0002 04       		.byte	4
 8597 0003 01       		.byte	1
 8598 0004 00       		.byte	0
 8599 0005 38       		.byte	56
 8600 0006 01       		.byte	1
 8601 0007 01       		.byte	1
 8602 0008 00       		.byte	0
 8603 0009 03       		.byte	3
 8604 000a 00       		.byte	0
 8605 000b 4E       		.byte	78
 8606 000c 00       		.byte	0
 8607 000d 4E       		.byte	78
 8608 000e 00       		.byte	0
 8609 000f 30       		.byte	48
 8610 0010 01       		.byte	1
 8611 0011 00       		.byte	0
 8612 0012 00       		.byte	0
 8613 0013 00000000 		.space	5
 8613      00
 8614 0018 00       		.byte	0
 8615 0019 00       		.byte	0
 8616 001a 01       		.byte	1
 8617 001b 00       		.byte	0
 8618 001c 00       		.byte	0
 8619 001d 00       		.byte	0
 8620 001e 00       		.byte	0
 8621 001f 01       		.byte	1
 8622 0020 00       		.byte	0
 8623 0021 03       		.byte	3
 8624 0022 00       		.byte	0
 8625 0023 00       		.byte	0
 8626 0024 00       		.byte	0
 8627 0025 00       		.byte	0
 8628 0026 00       		.byte	0
 8629 0027 30       		.byte	48
 8630 0028 01       		.byte	1
 8631 0029 00       		.byte	0
 8632 002a 00       		.byte	0
 8633 002b 00000000 		.space	5
 8633      00
 8634 0030 00       		.byte	0
 8635 0031 00       		.byte	0
 8636 0032 02       		.byte	2
 8637 0033 00       		.byte	0
 8638 0034 00       		.byte	0
 8639 0035 FF       		.byte	-1
 8640 0036 00       		.byte	0
 8641 0037 01       		.byte	1
 8642 0038 00       		.byte	0
 8643 0039 03       		.byte	3
 8644 003a 00       		.byte	0
 8645 003b 01       		.byte	1
 8646 003c 00       		.byte	0
 8647 003d 00       		.byte	0
 8648 003e 00       		.byte	0
 8649 003f 30       		.byte	48
 8650 0040 01       		.byte	1
 8651 0041 01       		.byte	1
 8652 0042 00       		.byte	0
 8653 0043 00000000 		.space	5
 8653      00
 8654 0048 00       		.byte	0
 8655 0049 00       		.byte	0
 8656 004a 02       		.byte	2
 8657 004b 00       		.byte	0
 8658 004c 00       		.byte	0
 8659 004d 00       		.byte	0
 8660 004e 00       		.byte	0
 8661 004f 00       		.byte	0
 8662 0050 00       		.byte	0
 8663 0051 03       		.byte	3
 8664 0052 00       		.byte	0
 8665 0053 00       		.byte	0
 8666 0054 00       		.byte	0
 8667 0055 00       		.byte	0
 8668 0056 00       		.byte	0
 8669 0057 30       		.byte	48
 8670 0058 01       		.byte	1
 8671 0059 01       		.byte	1
 8672 005a 00       		.byte	0
 8673 005b 00000000 		.space	5
 8673      00
 8674 0060 13       		.byte	19
 8675 0061 14       		.byte	20
 8676 0062 02       		.byte	2
 8677 0063 00       		.byte	0
 8678 0064 00       		.byte	0
 8679 0065 FF       		.byte	-1
 8680 0066 FF       		.byte	-1
 8681 0067 01       		.byte	1
 8682 0068 00       		.byte	0
 8683 0069 03       		.byte	3
 8684 006a 00       		.byte	0
 8685 006b 22       		.byte	34
 8686 006c 22       		.byte	34
 8687 006d 22       		.byte	34
 8688 006e 22       		.byte	34
 8689 006f 30       		.byte	48
 8690 0070 01       		.byte	1
 8691 0071 00       		.byte	0
 8692 0072 00       		.byte	0
 8693 0073 00000000 		.space	5
 8693      00
 8694 0078 11       		.byte	17
 8695 0079 00       		.byte	0
 8696 007a 02       		.byte	2
 8697 007b 01       		.byte	1
 8698 007c 00       		.byte	0
 8699 007d 03       		.byte	3
 8700 007e 00       		.byte	0
 8701 007f 01       		.byte	1
 8702 0080 00       		.byte	0
 8703 0081 03       		.byte	3
 8704 0082 00       		.byte	0
 8705 0083 80       		.byte	-128
 8706 0084 00       		.byte	0
 8707 0085 80       		.byte	-128
 8708 0086 00       		.byte	0
 8709 0087 30       		.byte	48
 8710 0088 01       		.byte	1
 8711 0089 01       		.byte	1
 8712 008a 00       		.byte	0
 8713 008b 00000000 		.space	5
 8713      00
 8714 0090 17       		.byte	23
 8715 0091 00       		.byte	0
 8716 0092 01       		.byte	1
 8717 0093 01       		.byte	1
 8718 0094 00       		.byte	0
 8719 0095 02       		.byte	2
 8720 0096 00       		.byte	0
 8721 0097 01       		.byte	1
 8722 0098 00       		.byte	0
 8723 0099 03       		.byte	3
 8724 009a 00       		.byte	0
 8725 009b 00       		.byte	0
 8726 009c 00       		.byte	0
 8727 009d 00       		.byte	0
 8728 009e 00       		.byte	0
 8729 009f 30       		.byte	48
 8730 00a0 01       		.byte	1
 8731 00a1 01       		.byte	1
 8732 00a2 00       		.byte	0
 8733 00a3 00000000 		.space	5
 8733      00
 8734 00a8 00       		.byte	0
 8735 00a9 00       		.byte	0
 8736 00aa 04       		.byte	4
 8737 00ab 01       		.byte	1
 8738 00ac 00       		.byte	0
 8739 00ad 38       		.byte	56
 8740 00ae 01       		.byte	1
 8741 00af 01       		.byte	1
 8742 00b0 00       		.byte	0
 8743 00b1 03       		.byte	3
 8744 00b2 00       		.byte	0
 8745 00b3 4E       		.byte	78
 8746 00b4 00       		.byte	0
 8747 00b5 4E       		.byte	78
 8748 00b6 00       		.byte	0
 8749 00b7 30       		.byte	48
 8750 00b8 01       		.byte	1
 8751 00b9 00       		.byte	0
 8752 00ba 00       		.byte	0
 8753 00bb 00000000 		.space	5
 8753      00
 8754 00c0 00       		.byte	0
 8755 00c1 00       		.byte	0
 8756 00c2 01       		.byte	1
 8757 00c3 00       		.byte	0
 8758 00c4 00       		.byte	0
 8759 00c5 00       		.byte	0
 8760 00c6 00       		.byte	0
 8761 00c7 01       		.byte	1
 8762 00c8 00       		.byte	0
 8763 00c9 03       		.byte	3
 8764 00ca 00       		.byte	0
 8765 00cb 00       		.byte	0
 8766 00cc 00       		.byte	0
 8767 00cd 00       		.byte	0
 8768 00ce 00       		.byte	0
 8769 00cf 30       		.byte	48
 8770 00d0 01       		.byte	1
 8771 00d1 00       		.byte	0
 8772 00d2 00       		.byte	0
 8773 00d3 00000000 		.space	5
 8773      00
 8774 00d8 00       		.byte	0
 8775 00d9 00       		.byte	0
 8776 00da 02       		.byte	2
 8777 00db 00       		.byte	0
 8778 00dc 00       		.byte	0
 8779 00dd 05       		.byte	5
 8780 00de 00       		.byte	0
 8781 00df 01       		.byte	1
 8782 00e0 00       		.byte	0
 8783 00e1 03       		.byte	3
 8784 00e2 00       		.byte	0
 8785 00e3 00       		.byte	0
 8786 00e4 00       		.byte	0
 8787 00e5 00       		.byte	0
 8788 00e6 00       		.byte	0
 8789 00e7 30       		.byte	48
 8790 00e8 01       		.byte	1
 8791 00e9 00       		.byte	0
 8792 00ea 00       		.byte	0
 8793 00eb 00000000 		.space	5
 8793      00
 8794 00f0 00       		.byte	0
 8795 00f1 00       		.byte	0
 8796 00f2 03       		.byte	3
 8797 00f3 00       		.byte	0
 8798 00f4 00       		.byte	0
 8799 00f5 0A       		.byte	10
 8800 00f6 00       		.byte	0
 8801 00f7 01       		.byte	1
 8802 00f8 00       		.byte	0
 8803 00f9 03       		.byte	3
 8804 00fa 00       		.byte	0
 8805 00fb 00       		.byte	0
 8806 00fc 00       		.byte	0
 8807 00fd 00       		.byte	0
 8808 00fe 00       		.byte	0
 8809 00ff 30       		.byte	48
 8810 0100 01       		.byte	1
 8811 0101 00       		.byte	0
 8812 0102 00       		.byte	0
 8813 0103 00000000 		.space	5
 8813      00
 8814 0108 00       		.byte	0
 8815 0109 00       		.byte	0
 8816 010a 02       		.byte	2
 8817 010b 00       		.byte	0
 8818 010c 00       		.byte	0
 8819 010d 40       		.byte	64
 8820 010e 00       		.byte	0
 8821 010f 01       		.byte	1
 8822 0110 00       		.byte	0
 8823 0111 03       		.byte	3
 8824 0112 00       		.byte	0
 8825 0113 0F       		.byte	15
 8826 0114 11       		.byte	17
 8827 0115 00       		.byte	0
 8828 0116 00       		.byte	0
 8829 0117 30       		.byte	48
 8830 0118 01       		.byte	1
 8831 0119 00       		.byte	0
 8832 011a 00       		.byte	0
 8833 011b 00000000 		.space	5
 8833      00
 8834 0120 00       		.byte	0
 8835 0121 00       		.byte	0
 8836 0122 02       		.byte	2
 8837 0123 00       		.byte	0
 8838 0124 00       		.byte	0
 8839 0125 64       		.byte	100
 8840 0126 00       		.byte	0
 8841 0127 01       		.byte	1
 8842 0128 00       		.byte	0
 8843 0129 03       		.byte	3
 8844 012a 00       		.byte	0
 8845 012b 00       		.byte	0
 8846 012c 00       		.byte	0
 8847 012d 00       		.byte	0
 8848 012e 00       		.byte	0
 8849 012f 30       		.byte	48
 8850 0130 01       		.byte	1
 8851 0131 00       		.byte	0
 8852 0132 00       		.byte	0
 8853 0133 00000000 		.space	5
 8853      00
 8854 0138 00       		.byte	0
 8855 0139 00       		.byte	0
 8856 013a 02       		.byte	2
 8857 013b 00       		.byte	0
 8858 013c 00       		.byte	0
 8859 013d 64       		.byte	100
 8860 013e 00       		.byte	0
 8861 013f 01       		.byte	1
 8862 0140 00       		.byte	0
 8863 0141 03       		.byte	3
 8864 0142 00       		.byte	0
 8865 0143 00       		.byte	0
 8866 0144 00       		.byte	0
 8867 0145 00       		.byte	0
 8868 0146 00       		.byte	0
 8869 0147 30       		.byte	48
 8870 0148 01       		.byte	1
 8871 0149 00       		.byte	0
 8872 014a 00       		.byte	0
 8873 014b 00000000 		.space	5
 8873      00
 8874 0150 00       		.byte	0
 8875 0151 00       		.byte	0
 8876 0152 02       		.byte	2
 8877 0153 00       		.byte	0
 8878 0154 00       		.byte	0
 8879 0155 64       		.byte	100
 8880 0156 00       		.byte	0
 8881 0157 01       		.byte	1
 8882 0158 00       		.byte	0
 8883 0159 03       		.byte	3
 8884 015a 00       		.byte	0
 8885 015b 00       		.byte	0
 8886 015c 00       		.byte	0
 8887 015d 00       		.byte	0
 8888 015e 00       		.byte	0
 8889 015f 30       		.byte	48
 8890 0160 01       		.byte	1
 8891 0161 00       		.byte	0
 8892 0162 00       		.byte	0
 8893 0163 00000000 		.space	5
 8893      00
 8894 0168 00       		.byte	0
 8895 0169 00       		.byte	0
 8896 016a 02       		.byte	2
 8897 016b 00       		.byte	0
 8898 016c 00       		.byte	0
 8899 016d 64       		.byte	100
 8900 016e 00       		.byte	0
 8901 016f 01       		.byte	1
 8902 0170 00       		.byte	0
 8903 0171 03       		.byte	3
 8904 0172 00       		.byte	0
 8905 0173 00       		.byte	0
 8906 0174 00       		.byte	0
 8907 0175 00       		.byte	0
 8908 0176 00       		.byte	0
 8909 0177 30       		.byte	48
 8910 0178 01       		.byte	1
 8911 0179 00       		.byte	0
 8912 017a 00       		.byte	0
 8913 017b 00000000 		.space	5
 8913      00
 8916              	CtrlParArry:
 8917 0180 10       		.byte	16
 8918 0181 10       		.byte	16
 8919 0182 02       		.byte	2
 8920 0183 00       		.byte	0
 8921 0184 00       		.byte	0
 8922 0185 03       		.byte	3
 8923 0186 00       		.byte	0
 8924 0187 01       		.byte	1
 8925 0188 00       		.byte	0
 8926 0189 03       		.byte	3
 8927 018a 00       		.byte	0
 8928 018b 03       		.byte	3
 8929 018c 00       		.byte	0
 8930 018d 03       		.byte	3
 8931 018e 00       		.byte	0
 8932 018f 30       		.byte	48
 8933 0190 01       		.byte	1
 8934 0191 00       		.byte	0
 8935 0192 00       		.byte	0
 8936 0193 00000000 		.space	5
 8936      00
 8937 0198 15       		.byte	21
 8938 0199 15       		.byte	21
 8939 019a 02       		.byte	2
 8940 019b 00       		.byte	0
 8941 019c 00       		.byte	0
 8942 019d FF       		.byte	-1
 8943 019e 00       		.byte	0
 8944 019f 01       		.byte	1
 8945 01a0 00       		.byte	0
 8946 01a1 03       		.byte	3
 8947 01a2 00       		.byte	0
 8948 01a3 76       		.byte	118
 8949 01a4 00       		.byte	0
 8950 01a5 76       		.byte	118
 8951 01a6 C7       		.byte	-57
 8952 01a7 30       		.byte	48
 8953 01a8 01       		.byte	1
 8954 01a9 01       		.byte	1
 8955 01aa 00       		.byte	0
 8956 01ab 00000000 		.space	5
 8956      00
 8957 01b0 02       		.byte	2
 8958 01b1 02       		.byte	2
 8959 01b2 02       		.byte	2
 8960 01b3 00       		.byte	0
 8961 01b4 00       		.byte	0
 8962 01b5 FF       		.byte	-1
 8963 01b6 00       		.byte	0
 8964 01b7 01       		.byte	1
 8965 01b8 00       		.byte	0
 8966 01b9 03       		.byte	3
 8967 01ba 00       		.byte	0
 8968 01bb 70       		.byte	112
 8969 01bc 00       		.byte	0
 8970 01bd 70       		.byte	112
 8971 01be 00       		.byte	0
 8972 01bf C6       		.byte	-58
 8973 01c0 01       		.byte	1
 8974 01c1 01       		.byte	1
 8975 01c2 00       		.byte	0
 8976 01c3 00000000 		.space	5
 8976      00
 8977 01c8 00       		.byte	0
 8978 01c9 00       		.byte	0
 8979 01ca 02       		.byte	2
 8980 01cb 00       		.byte	0
 8981 01cc 00       		.byte	0
 8982 01cd 64       		.byte	100
 8983 01ce 00       		.byte	0
 8984 01cf 01       		.byte	1
 8985 01d0 00       		.byte	0
 8986 01d1 03       		.byte	3
 8987 01d2 00       		.byte	0
 8988 01d3 00       		.byte	0
 8989 01d4 00       		.byte	0
 8990 01d5 00       		.byte	0
 8991 01d6 00       		.byte	0
 8992 01d7 30       		.byte	48
 8993 01d8 01       		.byte	1
 8994 01d9 00       		.byte	0
 8995 01da 00       		.byte	0
 8996 01db 00000000 		.space	5
 8996      00
 8997 01e0 07       		.byte	7
 8998 01e1 07       		.byte	7
 8999 01e2 02       		.byte	2
 9000 01e3 00       		.byte	0
 9001 01e4 00       		.byte	0
 9002 01e5 01       		.byte	1
 9003 01e6 00       		.byte	0
 9004 01e7 01       		.byte	1
 9005 01e8 00       		.byte	0
 9006 01e9 03       		.byte	3
 9007 01ea 00       		.byte	0
 9008 01eb 01       		.byte	1
 9009 01ec 00       		.byte	0
 9010 01ed 01       		.byte	1
 9011 01ee 00       		.byte	0
 9012 01ef 30       		.byte	48
 9013 01f0 01       		.byte	1
 9014 01f1 00       		.byte	0
 9015 01f2 00       		.byte	0
 9016 01f3 00000000 		.space	5
 9016      00
 9017 01f8 DF       		.byte	-33
 9018 01f9 E1       		.byte	-31
 9019 01fa 02       		.byte	2
 9020 01fb 00       		.byte	0
 9021 01fc 00       		.byte	0
 9022 01fd FF       		.byte	-1
 9023 01fe 00       		.byte	0
 9024 01ff 01       		.byte	1
 9025 0200 00       		.byte	0
 9026 0201 03       		.byte	3
 9027 0202 00       		.byte	0
 9028 0203 80       		.byte	-128
 9029 0204 00       		.byte	0
 9030 0205 00       		.byte	0
 9031 0206 00       		.byte	0
 9032 0207 C6       		.byte	-58
 9033 0208 01       		.byte	1
 9034 0209 01       		.byte	1
 9035 020a 00       		.byte	0
 9036 020b 00000000 		.space	5
 9036      00
 9037 0210 85       		.byte	-123
 9038 0211 86       		.byte	-122
 9039 0212 02       		.byte	2
 9040 0213 00       		.byte	0
 9041 0214 00       		.byte	0
 9042 0215 64       		.byte	100
 9043 0216 00       		.byte	0
 9044 0217 01       		.byte	1
 9045 0218 00       		.byte	0
 9046 0219 03       		.byte	3
 9047 021a 00       		.byte	0
 9048 021b 32       		.byte	50
 9049 021c 00       		.byte	0
 9050 021d 32       		.byte	50
 9051 021e 00       		.byte	0
 9052 021f F2       		.byte	-14
 9053 0220 01       		.byte	1
 9054 0221 01       		.byte	1
 9055 0222 00       		.byte	0
 9056 0223 00000000 		.space	5
 9056      00
 9057 0228 06       		.byte	6
 9058 0229 06       		.byte	6
 9059 022a 02       		.byte	2
 9060 022b 00       		.byte	0
 9061 022c 00       		.byte	0
 9062 022d 40       		.byte	64
 9063 022e 00       		.byte	0
 9064 022f 01       		.byte	1
 9065 0230 00       		.byte	0
 9066 0231 03       		.byte	3
 9067 0232 00       		.byte	0
 9068 0233 20       		.byte	32
 9069 0234 00       		.byte	0
 9070 0235 20       		.byte	32
 9071 0236 00       		.byte	0
 9072 0237 30       		.byte	48
 9073 0238 01       		.byte	1
 9074 0239 01       		.byte	1
 9075 023a 00       		.byte	0
 9076 023b 00000000 		.space	5
 9076      00
 9077 0240 00       		.byte	0
 9078 0241 00       		.byte	0
 9079 0242 02       		.byte	2
 9080 0243 00       		.byte	0
 9081 0244 00       		.byte	0
 9082 0245 64       		.byte	100
 9083 0246 00       		.byte	0
 9084 0247 01       		.byte	1
 9085 0248 00       		.byte	0
 9086 0249 03       		.byte	3
 9087 024a 00       		.byte	0
 9088 024b 00       		.byte	0
 9089 024c 00       		.byte	0
 9090 024d 00       		.byte	0
 9091 024e 00       		.byte	0
 9092 024f 30       		.byte	48
 9093 0250 01       		.byte	1
 9094 0251 00       		.byte	0
 9095 0252 00       		.byte	0
 9096 0253 00000000 		.space	5
 9096      00
 9097 0258 08       		.byte	8
 9098 0259 08       		.byte	8
 9099 025a 02       		.byte	2
 9100 025b 00       		.byte	0
 9101 025c 00       		.byte	0
 9102 025d 05       		.byte	5
 9103 025e 00       		.byte	0
 9104 025f 01       		.byte	1
 9105 0260 00       		.byte	0
 9106 0261 03       		.byte	3
 9107 0262 00       		.byte	0
 9108 0263 00       		.byte	0
 9109 0264 00       		.byte	0
 9110 0265 00       		.byte	0
 9111 0266 00       		.byte	0
 9112 0267 30       		.byte	48
 9113 0268 01       		.byte	1
 9114 0269 00       		.byte	0
 9115 026a 00       		.byte	0
 9116 026b 00000000 		.space	5
 9116      00
 9117 0270 00       		.byte	0
 9118 0271 00       		.byte	0
 9119 0272 02       		.byte	2
 9120 0273 00       		.byte	0
 9121 0274 00       		.byte	0
 9122 0275 40       		.byte	64
 9123 0276 00       		.byte	0
 9124 0277 01       		.byte	1
 9125 0278 00       		.byte	0
 9126 0279 03       		.byte	3
 9127 027a 00       		.byte	0
 9128 027b 00       		.byte	0
 9129 027c 00       		.byte	0
 9130 027d 00       		.byte	0
 9131 027e 00       		.byte	0
 9132 027f 30       		.byte	48
 9133 0280 01       		.byte	1
 9134 0281 00       		.byte	0
 9135 0282 00       		.byte	0
 9136 0283 00000000 		.space	5
 9136      00
 9137 0288 09       		.byte	9
 9138 0289 0A       		.byte	10
 9139 028a 04       		.byte	4
 9140 028b 00       		.byte	0
 9141 028c 00       		.byte	0
 9142 028d 40       		.byte	64
 9143 028e 00       		.byte	0
 9144 028f 01       		.byte	1
 9145 0290 00       		.byte	0
 9146 0291 03       		.byte	3
 9147 0292 00       		.byte	0
 9148 0293 20       		.byte	32
 9149 0294 38       		.byte	56
 9150 0295 20       		.byte	32
 9151 0296 38       		.byte	56
 9152 0297 30       		.byte	48
 9153 0298 01       		.byte	1
 9154 0299 00       		.byte	0
 9155 029a 00       		.byte	0
 9156 029b 00000000 		.space	5
 9156      00
 9157 02a0 00       		.byte	0
 9158 02a1 00       		.byte	0
 9159 02a2 02       		.byte	2
 9160 02a3 00       		.byte	0
 9161 02a4 00       		.byte	0
 9162 02a5 64       		.byte	100
 9163 02a6 00       		.byte	0
 9164 02a7 01       		.byte	1
 9165 02a8 00       		.byte	0
 9166 02a9 03       		.byte	3
 9167 02aa 00       		.byte	0
 9168 02ab 00       		.byte	0
 9169 02ac 00       		.byte	0
 9170 02ad 00       		.byte	0
 9171 02ae 00       		.byte	0
 9172 02af 30       		.byte	48
 9173 02b0 01       		.byte	1
 9174 02b1 00       		.byte	0
 9175 02b2 00       		.byte	0
 9176 02b3 00000000 		.space	5
 9176      00
 9177 02b8 00       		.byte	0
 9178 02b9 00       		.byte	0
 9179 02ba 02       		.byte	2
 9180 02bb 00       		.byte	0
 9181 02bc 00       		.byte	0
 9182 02bd 64       		.byte	100
 9183 02be 00       		.byte	0
 9184 02bf 01       		.byte	1
 9185 02c0 00       		.byte	0
 9186 02c1 03       		.byte	3
 9187 02c2 00       		.byte	0
 9188 02c3 00       		.byte	0
 9189 02c4 00       		.byte	0
 9190 02c5 00       		.byte	0
 9191 02c6 00       		.byte	0
 9192 02c7 30       		.byte	48
 9193 02c8 01       		.byte	1
 9194 02c9 00       		.byte	0
 9195 02ca 00       		.byte	0
 9196 02cb 00000000 		.space	5
 9196      00
 9197 02d0 2A       		.byte	42
 9198 02d1 2A       		.byte	42
 9199 02d2 02       		.byte	2
 9200 02d3 00       		.byte	0
 9201 02d4 00       		.byte	0
 9202 02d5 1B       		.byte	27
 9203 02d6 00       		.byte	0
 9204 02d7 01       		.byte	1
 9205 02d8 00       		.byte	0
 9206 02d9 03       		.byte	3
 9207 02da 00       		.byte	0
 9208 02db 00       		.byte	0
 9209 02dc 00       		.byte	0
 9210 02dd 00       		.byte	0
 9211 02de 00       		.byte	0
 9212 02df 30       		.byte	48
 9213 02e0 01       		.byte	1
 9214 02e1 00       		.byte	0
 9215 02e2 00       		.byte	0
 9216 02e3 00000000 		.space	5
 9216      00
 9217 02e8 00       		.byte	0
 9218 02e9 00       		.byte	0
 9219 02ea 02       		.byte	2
 9220 02eb 00       		.byte	0
 9221 02ec 00       		.byte	0
 9222 02ed 64       		.byte	100
 9223 02ee 00       		.byte	0
 9224 02ef 01       		.byte	1
 9225 02f0 00       		.byte	0
 9226 02f1 03       		.byte	3
 9227 02f2 00       		.byte	0
 9228 02f3 00       		.byte	0
 9229 02f4 00       		.byte	0
 9230 02f5 00       		.byte	0
 9231 02f6 00       		.byte	0
 9232 02f7 30       		.byte	48
 9233 02f8 01       		.byte	1
 9234 02f9 00       		.byte	0
 9235 02fa 00       		.byte	0
 9236 02fb 00000000 		.space	5
 9236      00
 9237 0300 00       		.byte	0
 9238 0301 00       		.byte	0
 9239 0302 02       		.byte	2
 9240 0303 00       		.byte	0
 9241 0304 00       		.byte	0
 9242 0305 12       		.byte	18
 9243 0306 00       		.byte	0
 9244 0307 01       		.byte	1
 9245 0308 00       		.byte	0
 9246 0309 03       		.byte	3
 9247 030a 00       		.byte	0
 9248 030b 00       		.byte	0
 9249 030c 00       		.byte	0
 9250 030d 00       		.byte	0
 9251 030e 00       		.byte	0
 9252 030f 30       		.byte	48
 9253 0310 01       		.byte	1
 9254 0311 00       		.byte	0
 9255 0312 00       		.byte	0
 9256 0313 00000000 		.space	5
 9256      00
 9257 0318 01       		.byte	1
 9258 0319 01       		.byte	1
 9259 031a 02       		.byte	2
 9260 031b 00       		.byte	0
 9261 031c 00       		.byte	0
 9262 031d 09       		.byte	9
 9263 031e 00       		.byte	0
 9264 031f 01       		.byte	1
 9265 0320 00       		.byte	0
 9266 0321 03       		.byte	3
 9267 0322 00       		.byte	0
 9268 0323 00       		.byte	0
 9269 0324 00       		.byte	0
 9270 0325 01       		.byte	1
 9271 0326 00       		.byte	0
 9272 0327 30       		.byte	48
 9273 0328 01       		.byte	1
 9274 0329 00       		.byte	0
 9275 032a 00       		.byte	0
 9276 032b 00000000 		.space	5
 9276      00
 9277 0330 05       		.byte	5
 9278 0331 05       		.byte	5
 9279 0332 02       		.byte	2
 9280 0333 00       		.byte	0
 9281 0334 00       		.byte	0
 9282 0335 03       		.byte	3
 9283 0336 00       		.byte	0
 9284 0337 01       		.byte	1
 9285 0338 00       		.byte	0
 9286 0339 03       		.byte	3
 9287 033a 00       		.byte	0
 9288 033b 00       		.byte	0
 9289 033c 00       		.byte	0
 9290 033d 00       		.byte	0
 9291 033e 00       		.byte	0
 9292 033f 30       		.byte	48
 9293 0340 01       		.byte	1
 9294 0341 00       		.byte	0
 9295 0342 00       		.byte	0
 9296 0343 00000000 		.space	5
 9296      00
 9297 0348 18       		.byte	24
 9298 0349 18       		.byte	24
 9299 034a 02       		.byte	2
 9300 034b 00       		.byte	0
 9301 034c 00       		.byte	0
 9302 034d 01       		.byte	1
 9303 034e 00       		.byte	0
 9304 034f 01       		.byte	1
 9305 0350 00       		.byte	0
 9306 0351 03       		.byte	3
 9307 0352 00       		.byte	0
 9308 0353 00       		.byte	0
 9309 0354 00       		.byte	0
 9310 0355 00       		.byte	0
 9311 0356 00       		.byte	0
 9312 0357 30       		.byte	48
 9313 0358 01       		.byte	1
 9314 0359 00       		.byte	0
 9315 035a 00       		.byte	0
 9316 035b 00000000 		.space	5
 9316      00
 9317 0360 19       		.byte	25
 9318 0361 19       		.byte	25
 9319 0362 01       		.byte	1
 9320 0363 00       		.byte	0
 9321 0364 00       		.byte	0
 9322 0365 40       		.byte	64
 9323 0366 00       		.byte	0
 9324 0367 01       		.byte	1
 9325 0368 00       		.byte	0
 9326 0369 03       		.byte	3
 9327 036a 00       		.byte	0
 9328 036b 20       		.byte	32
 9329 036c 00       		.byte	0
 9330 036d 20       		.byte	32
 9331 036e 00       		.byte	0
 9332 036f 30       		.byte	48
 9333 0370 01       		.byte	1
 9334 0371 00       		.byte	0
 9335 0372 00       		.byte	0
 9336 0373 00000000 		.space	5
 9336      00
 9337 0378 20       		.byte	32
 9338 0379 20       		.byte	32
 9339 037a 02       		.byte	2
 9340 037b 00       		.byte	0
 9341 037c 00       		.byte	0
 9342 037d 02       		.byte	2
 9343 037e 00       		.byte	0
 9344 037f 01       		.byte	1
 9345 0380 00       		.byte	0
 9346 0381 03       		.byte	3
 9347 0382 00       		.byte	0
 9348 0383 00       		.byte	0
 9349 0384 00       		.byte	0
 9350 0385 00       		.byte	0
 9351 0386 00       		.byte	0
 9352 0387 30       		.byte	48
 9353 0388 01       		.byte	1
 9354 0389 00       		.byte	0
 9355 038a 00       		.byte	0
 9356 038b 00000000 		.space	5
 9356      00
 9357 0390 22       		.byte	34
 9358 0391 22       		.byte	34
 9359 0392 02       		.byte	2
 9360 0393 00       		.byte	0
 9361 0394 00       		.byte	0
 9362 0395 3F       		.byte	63
 9363 0396 00       		.byte	0
 9364 0397 01       		.byte	1
 9365 0398 00       		.byte	0
 9366 0399 03       		.byte	3
 9367 039a 00       		.byte	0
 9368 039b 00       		.byte	0
 9369 039c 00       		.byte	0
 9370 039d 00       		.byte	0
 9371 039e 00       		.byte	0
 9372 039f 30       		.byte	48
 9373 03a0 01       		.byte	1
 9374 03a1 00       		.byte	0
 9375 03a2 00       		.byte	0
 9376 03a3 00000000 		.space	5
 9376      00
 9377 03a8 23       		.byte	35
 9378 03a9 23       		.byte	35
 9379 03aa 02       		.byte	2
 9380 03ab 00       		.byte	0
 9381 03ac 00       		.byte	0
 9382 03ad 64       		.byte	100
 9383 03ae 00       		.byte	0
 9384 03af 01       		.byte	1
 9385 03b0 00       		.byte	0
 9386 03b1 03       		.byte	3
 9387 03b2 00       		.byte	0
 9388 03b3 10       		.byte	16
 9389 03b4 00       		.byte	0
 9390 03b5 10       		.byte	16
 9391 03b6 00       		.byte	0
 9392 03b7 30       		.byte	48
 9393 03b8 01       		.byte	1
 9394 03b9 00       		.byte	0
 9395 03ba 00       		.byte	0
 9396 03bb 00000000 		.space	5
 9396      00
 9397 03c0 24       		.byte	36
 9398 03c1 24       		.byte	36
 9399 03c2 02       		.byte	2
 9400 03c3 00       		.byte	0
 9401 03c4 00       		.byte	0
 9402 03c5 64       		.byte	100
 9403 03c6 00       		.byte	0
 9404 03c7 01       		.byte	1
 9405 03c8 00       		.byte	0
 9406 03c9 03       		.byte	3
 9407 03ca 00       		.byte	0
 9408 03cb 10       		.byte	16
 9409 03cc 00       		.byte	0
 9410 03cd 10       		.byte	16
 9411 03ce 00       		.byte	0
 9412 03cf 30       		.byte	48
 9413 03d0 01       		.byte	1
 9414 03d1 00       		.byte	0
 9415 03d2 00       		.byte	0
 9416 03d3 00000000 		.space	5
 9416      00
 9417 03d8 02       		.byte	2
 9418 03d9 03       		.byte	3
 9419 03da 04       		.byte	4
 9420 03db 00       		.byte	0
 9421 03dc 00       		.byte	0
 9422 03dd 7F       		.byte	127
 9423 03de 00       		.byte	0
 9424 03df 01       		.byte	1
 9425 03e0 00       		.byte	0
 9426 03e1 03       		.byte	3
 9427 03e2 00       		.byte	0
 9428 03e3 00       		.byte	0
 9429 03e4 20       		.byte	32
 9430 03e5 00       		.byte	0
 9431 03e6 20       		.byte	32
 9432 03e7 30       		.byte	48
 9433 03e8 01       		.byte	1
 9434 03e9 00       		.byte	0
 9435 03ea 00       		.byte	0
 9436 03eb 00000000 		.space	5
 9436      00
 9437 03f0 04       		.byte	4
 9438 03f1 04       		.byte	4
 9439 03f2 02       		.byte	2
 9440 03f3 00       		.byte	0
 9441 03f4 00       		.byte	0
 9442 03f5 FF       		.byte	-1
 9443 03f6 00       		.byte	0
 9444 03f7 01       		.byte	1
 9445 03f8 00       		.byte	0
 9446 03f9 03       		.byte	3
 9447 03fa 00       		.byte	0
 9448 03fb 60       		.byte	96
 9449 03fc 00       		.byte	0
 9450 03fd 60       		.byte	96
 9451 03fe 00       		.byte	0
 9452 03ff 30       		.byte	48
 9453 0400 01       		.byte	1
 9454 0401 00       		.byte	0
 9455 0402 00       		.byte	0
 9456 0403 00000000 		.space	5
 9456      00
 9457 0408 00       		.byte	0
 9458 0409 00       		.byte	0
 9459 040a 02       		.byte	2
 9460 040b 00       		.byte	0
 9461 040c 00       		.byte	0
 9462 040d 19       		.byte	25
 9463 040e 00       		.byte	0
 9464 040f 01       		.byte	1
 9465 0410 00       		.byte	0
 9466 0411 03       		.byte	3
 9467 0412 00       		.byte	0
 9468 0413 00       		.byte	0
 9469 0414 00       		.byte	0
 9470 0415 00       		.byte	0
 9471 0416 00       		.byte	0
 9472 0417 30       		.byte	48
 9473 0418 01       		.byte	1
 9474 0419 00       		.byte	0
 9475 041a 00       		.byte	0
 9476 041b 00000000 		.space	5
 9476      00
 9477 0420 10       		.byte	16
 9478 0421 10       		.byte	16
 9479 0422 02       		.byte	2
 9480 0423 00       		.byte	0
 9481 0424 00       		.byte	0
 9482 0425 06       		.byte	6
 9483 0426 00       		.byte	0
 9484 0427 01       		.byte	1
 9485 0428 00       		.byte	0
 9486 0429 03       		.byte	3
 9487 042a 00       		.byte	0
 9488 042b 03       		.byte	3
 9489 042c 00       		.byte	0
 9490 042d 03       		.byte	3
 9491 042e 00       		.byte	0
 9492 042f 30       		.byte	48
 9493 0430 01       		.byte	1
 9494 0431 00       		.byte	0
 9495 0432 00       		.byte	0
 9496 0433 00000000 		.space	5
 9496      00
 9497 0438 00       		.byte	0
 9498 0439 00       		.byte	0
 9499 043a 02       		.byte	2
 9500 043b 00       		.byte	0
 9501 043c 00       		.byte	0
 9502 043d 03       		.byte	3
 9503 043e 00       		.byte	0
 9504 043f 01       		.byte	1
 9505 0440 00       		.byte	0
 9506 0441 03       		.byte	3
 9507 0442 00       		.byte	0
 9508 0443 00       		.byte	0
 9509 0444 00       		.byte	0
 9510 0445 00       		.byte	0
 9511 0446 00       		.byte	0
 9512 0447 30       		.byte	48
 9513 0448 01       		.byte	1
 9514 0449 00       		.byte	0
 9515 044a 00       		.byte	0
 9516 044b 00000000 		.space	5
 9516      00
 9517 0450 50       		.byte	80
 9518 0451 50       		.byte	80
 9519 0452 01       		.byte	1
 9520 0453 00       		.byte	0
 9521 0454 00       		.byte	0
 9522 0455 03       		.byte	3
 9523 0456 00       		.byte	0
 9524 0457 01       		.byte	1
 9525 0458 00       		.byte	0
 9526 0459 03       		.byte	3
 9527 045a 00       		.byte	0
 9528 045b 00       		.byte	0
 9529 045c 00       		.byte	0
 9530 045d 00       		.byte	0
 9531 045e 00       		.byte	0
 9532 045f 30       		.byte	48
 9533 0460 01       		.byte	1
 9534 0461 00       		.byte	0
 9535 0462 00       		.byte	0
 9536 0463 00000000 		.space	5
 9536      00
 9537 0468 00       		.byte	0
 9538 0469 00       		.byte	0
 9539 046a 0B       		.byte	11
 9540 046b 00       		.byte	0
 9541 046c 00       		.byte	0
 9542 046d FF       		.byte	-1
 9543 046e FF       		.byte	-1
 9544 046f 01       		.byte	1
 9545 0470 00       		.byte	0
 9546 0471 03       		.byte	3
 9547 0472 00       		.byte	0
 9548 0473 00       		.byte	0
 9549 0474 00       		.byte	0
 9550 0475 00       		.byte	0
 9551 0476 00       		.byte	0
 9552 0477 00       		.byte	0
 9553 0478 01       		.byte	1
 9554 0479 00       		.byte	0
 9555 047a 00       		.byte	0
 9556 047b 00000000 		.space	5
 9556      00
 9559              	glUVCHeader:
 9560 0480 0C       		.byte	12
 9561 0481 8C       		.byte	-116
 9562 0482 00       		.byte	0
 9563 0483 00       		.byte	0
 9564 0484 00       		.byte	0
 9565 0485 00       		.byte	0
 9566 0486 00       		.byte	0
 9567 0487 00       		.byte	0
 9568 0488 00       		.byte	0
 9569 0489 00       		.byte	0
 9570 048a 00       		.byte	0
 9571 048b 00       		.byte	0
 9574              	ROIMode:
 9575 048c 01       		.byte	1
 9576 048d 000000   		.space	3
 9579              	EXTShutter:
 9580 0490 00       		.byte	0
 9581 0491 02       		.byte	2
 9582 0492 02       		.byte	2
 9583 0493 00       		.byte	0
 9584 0494 00       		.byte	0
 9585 0495 08       		.byte	8
 9586 0496 00       		.byte	0
 9587 0497 01       		.byte	1
 9588 0498 00       		.byte	0
 9589 0499 03       		.byte	3
 9590 049a 00       		.byte	0
 9591 049b 00       		.byte	0
 9592 049c 00       		.byte	0
 9593 049d 00       		.byte	0
 9594 049e 00       		.byte	0
 9595 049f 30       		.byte	48
 9596 04a0 01       		.byte	1
 9597 04a1 00       		.byte	0
 9598 04a2 0000     		.space	2
 9601              	EXTShutlev:
 9602 04a4 02       		.byte	2
 9603 04a5 12       		.byte	18
 9604 04a6 02       		.byte	2
 9605 04a7 00       		.byte	0
 9606 04a8 00       		.byte	0
 9607 04a9 FF       		.byte	-1
 9608 04aa 7F       		.byte	127
 9609 04ab 01       		.byte	1
 9610 04ac 00       		.byte	0
 9611 04ad 03       		.byte	3
 9612 04ae 00       		.byte	0
 9613 04af 3F       		.byte	63
 9614 04b0 00       		.byte	0
 9615 04b1 3F       		.byte	63
 9616 04b2 00       		.byte	0
 9617 04b3 30       		.byte	48
 9618 04b4 01       		.byte	1
 9619 04b5 00       		.byte	0
 9620 04b6 0000     		.space	2
 9623              	EXTAexModGainlev:
 9624 04b8 00       		.byte	0
 9625 04b9 03       		.byte	3
 9626 04ba 04       		.byte	4
 9627 04bb 00       		.byte	0
 9628 04bc 00       		.byte	0
 9629 04bd 03       		.byte	3
 9630 04be 7F       		.byte	127
 9631 04bf 01       		.byte	1
 9632 04c0 00       		.byte	0
 9633 04c1 03       		.byte	3
 9634 04c2 00       		.byte	0
 9635 04c3 00       		.byte	0
 9636 04c4 3F       		.byte	63
 9637 04c5 00       		.byte	0
 9638 04c6 3F       		.byte	63
 9639 04c7 30       		.byte	48
 9640 04c8 01       		.byte	1
 9641 04c9 00       		.byte	0
 9642 04ca 0000     		.space	2
 9645              	WBMenuCmpArry:
 9646 04cc 20       		.byte	32
 9647 04cd 0F       		.byte	15
 9648 04ce 38       		.byte	56
 9649 04cf F0       		.byte	-16
 9652              	EXTBLCWinPos:
 9653 04d0 13       		.byte	19
 9654 04d1 14       		.byte	20
 9655 04d2 02       		.byte	2
 9656 04d3 00       		.byte	0
 9657 04d4 00       		.byte	0
 9658 04d5 FF       		.byte	-1
 9659 04d6 FF       		.byte	-1
 9660 04d7 01       		.byte	1
 9661 04d8 00       		.byte	0
 9662 04d9 03       		.byte	3
 9663 04da 00       		.byte	0
 9664 04db 22       		.byte	34
 9665 04dc 22       		.byte	34
 9666 04dd 22       		.byte	34
 9667 04de 22       		.byte	34
 9668 04df 30       		.byte	48
 9669 04e0 01       		.byte	1
 9670 04e1 00       		.byte	0
 9671 04e2 0000     		.space	2
 9674              	EXTBLCWeight:
 9675 04e4 11       		.byte	17
 9676 04e5 11       		.byte	17
 9677 04e6 02       		.byte	2
 9678 04e7 00       		.byte	0
 9679 04e8 00       		.byte	0
 9680 04e9 FF       		.byte	-1
 9681 04ea 00       		.byte	0
 9682 04eb 01       		.byte	1
 9683 04ec 00       		.byte	0
 9684 04ed 03       		.byte	3
 9685 04ee 00       		.byte	0
 9686 04ef 80       		.byte	-128
 9687 04f0 00       		.byte	0
 9688 04f1 80       		.byte	-128
 9689 04f2 00       		.byte	0
 9690 04f3 30       		.byte	48
 9691 04f4 01       		.byte	1
 9692 04f5 00       		.byte	0
 9693 04f6 0000     		.space	2
 9696              	PUCBLC:
 9697 04f8 10       		.byte	16
 9698 04f9 11       		.byte	17
 9699 04fa 02       		.byte	2
 9700 04fb 00       		.byte	0
 9701 04fc 00       		.byte	0
 9702 04fd 03       		.byte	3
 9703 04fe 00       		.byte	0
 9704 04ff 01       		.byte	1
 9705 0500 00       		.byte	0
 9706 0501 03       		.byte	3
 9707 0502 00       		.byte	0
 9708 0503 03       		.byte	3
 9709 0504 00       		.byte	0
 9710 0505 03       		.byte	3
 9711 0506 00       		.byte	0
 9712 0507 30       		.byte	48
 9713 0508 01       		.byte	1
 9714 0509 00       		.byte	0
 9715 050a 0000     		.space	2
 9718              	PUCSharp:
 9719 050c 06       		.byte	6
 9720 050d 07       		.byte	7
 9721 050e 02       		.byte	2
 9722 050f 00       		.byte	0
 9723 0510 00       		.byte	0
 9724 0511 08       		.byte	8
 9725 0512 00       		.byte	0
 9726 0513 01       		.byte	1
 9727 0514 00       		.byte	0
 9728 0515 03       		.byte	3
 9729 0516 00       		.byte	0
 9730 0517 00       		.byte	0
 9731 0518 00       		.byte	0
 9732 0519 00       		.byte	0
 9733 051a 00       		.byte	0
 9734 051b 30       		.byte	48
 9735 051c 01       		.byte	1
 9736 051d 00       		.byte	0
 9737 051e 0000     		.space	2
 9740              	CTCtrlParArry:
 9741 0520 00       		.byte	0
 9742 0521 00       		.byte	0
 9743 0522 01       		.byte	1
 9744 0523 00       		.byte	0
 9745 0524 00       		.byte	0
 9746 0525 03       		.byte	3
 9747 0526 00       		.byte	0
 9748 0527 01       		.byte	1
 9749 0528 00       		.byte	0
 9750 0529 03       		.byte	3
 9751 052a 00       		.byte	0
 9752 052b 03       		.byte	3
 9753 052c 00       		.byte	0
 9754 052d 03       		.byte	3
 9755 052e 00       		.byte	0
 9756 052f 30       		.byte	48
 9757 0530 01       		.byte	1
 9758 0531 00       		.byte	0
 9759 0532 00       		.byte	0
 9760 0533 00000000 		.space	5
 9760      00
 9761 0538 00       		.byte	0
 9762 0539 00       		.byte	0
 9763 053a 01       		.byte	1
 9764 053b 01       		.byte	1
 9765 053c 00       		.byte	0
 9766 053d 0F       		.byte	15
 9767 053e 00       		.byte	0
 9768 053f 0F       		.byte	15
 9769 0540 00       		.byte	0
 9770 0541 03       		.byte	3
 9771 0542 00       		.byte	0
 9772 0543 02       		.byte	2
 9773 0544 00       		.byte	0
 9774 0545 02       		.byte	2
 9775 0546 00       		.byte	0
 9776 0547 30       		.byte	48
 9777 0548 01       		.byte	1
 9778 0549 01       		.byte	1
 9779 054a 00       		.byte	0
 9780 054b 00000000 		.space	5
 9780      00
 9781 0550 02       		.byte	2
 9782 0551 00       		.byte	0
 9783 0552 01       		.byte	1
 9784 0553 00       		.byte	0
 9785 0554 00       		.byte	0
 9786 0555 01       		.byte	1
 9787 0556 00       		.byte	0
 9788 0557 01       		.byte	1
 9789 0558 00       		.byte	0
 9790 0559 03       		.byte	3
 9791 055a 00       		.byte	0
 9792 055b 00       		.byte	0
 9793 055c 00       		.byte	0
 9794 055d 00       		.byte	0
 9795 055e 00       		.byte	0
 9796 055f 30       		.byte	48
 9797 0560 01       		.byte	1
 9798 0561 01       		.byte	1
 9799 0562 00       		.byte	0
 9800 0563 00000000 		.space	5
 9800      00
 9801 0568 00       		.byte	0
 9802 0569 00       		.byte	0
 9803 056a 04       		.byte	4
 9804 056b 01       		.byte	1
 9805 056c 00       		.byte	0
 9806 056d 38       		.byte	56
 9807 056e 01       		.byte	1
 9808 056f 01       		.byte	1
 9809 0570 00       		.byte	0
 9810 0571 03       		.byte	3
 9811 0572 00       		.byte	0
 9812 0573 4E       		.byte	78
 9813 0574 00       		.byte	0
 9814 0575 4E       		.byte	78
 9815 0576 00       		.byte	0
 9816 0577 30       		.byte	48
 9817 0578 01       		.byte	1
 9818 0579 00       		.byte	0
 9819 057a 00       		.byte	0
 9820 057b 00000000 		.space	5
 9820      00
 9821 0580 04       		.byte	4
 9822 0581 00       		.byte	0
 9823 0582 01       		.byte	1
 9824 0583 00       		.byte	0
 9825 0584 00       		.byte	0
 9826 0585 00       		.byte	0
 9827 0586 00       		.byte	0
 9828 0587 01       		.byte	1
 9829 0588 00       		.byte	0
 9830 0589 03       		.byte	3
 9831 058a 00       		.byte	0
 9832 058b 00       		.byte	0
 9833 058c 00       		.byte	0
 9834 058d 00       		.byte	0
 9835 058e 00       		.byte	0
 9836 058f 30       		.byte	48
 9837 0590 01       		.byte	1
 9838 0591 00       		.byte	0
 9839 0592 00       		.byte	0
 9840 0593 00000000 		.space	5
 9840      00
 9841 0598 05       		.byte	5
 9842 0599 00       		.byte	0
 9843 059a 02       		.byte	2
 9844 059b 00       		.byte	0
 9845 059c 00       		.byte	0
 9846 059d FF       		.byte	-1
 9847 059e 00       		.byte	0
 9848 059f 01       		.byte	1
 9849 05a0 00       		.byte	0
 9850 05a1 03       		.byte	3
 9851 05a2 00       		.byte	0
 9852 05a3 01       		.byte	1
 9853 05a4 00       		.byte	0
 9854 05a5 00       		.byte	0
 9855 05a6 00       		.byte	0
 9856 05a7 30       		.byte	48
 9857 05a8 01       		.byte	1
 9858 05a9 01       		.byte	1
 9859 05aa 00       		.byte	0
 9860 05ab 00000000 		.space	5
 9860      00
 9861 05b0 06       		.byte	6
 9862 05b1 00       		.byte	0
 9863 05b2 02       		.byte	2
 9864 05b3 00       		.byte	0
 9865 05b4 00       		.byte	0
 9866 05b5 00       		.byte	0
 9867 05b6 00       		.byte	0
 9868 05b7 00       		.byte	0
 9869 05b8 00       		.byte	0
 9870 05b9 03       		.byte	3
 9871 05ba 00       		.byte	0
 9872 05bb 00       		.byte	0
 9873 05bc 00       		.byte	0
 9874 05bd 00       		.byte	0
 9875 05be 00       		.byte	0
 9876 05bf 30       		.byte	48
 9877 05c0 01       		.byte	1
 9878 05c1 01       		.byte	1
 9879 05c2 00       		.byte	0
 9880 05c3 00000000 		.space	5
 9880      00
 9881 05c8 23       		.byte	35
 9882 05c9 00       		.byte	0
 9883 05ca 02       		.byte	2
 9884 05cb 00       		.byte	0
 9885 05cc 00       		.byte	0
 9886 05cd 30       		.byte	48
 9887 05ce 00       		.byte	0
 9888 05cf 01       		.byte	1
 9889 05d0 00       		.byte	0
 9890 05d1 03       		.byte	3
 9891 05d2 0A       		.byte	10
 9892 05d3 00       		.byte	0
 9893 05d4 00       		.byte	0
 9894 05d5 0A       		.byte	10
 9895 05d6 00       		.byte	0
 9896 05d7 30       		.byte	48
 9897 05d8 01       		.byte	1
 9898 05d9 01       		.byte	1
 9899 05da 00       		.byte	0
 9900 05db 00000000 		.space	5
 9900      00
 9901 05e0 08       		.byte	8
 9902 05e1 00       		.byte	0
 9903 05e2 01       		.byte	1
 9904 05e3 00       		.byte	0
 9905 05e4 00       		.byte	0
 9906 05e5 7F       		.byte	127
 9907 05e6 00       		.byte	0
 9908 05e7 01       		.byte	1
 9909 05e8 00       		.byte	0
 9910 05e9 03       		.byte	3
 9911 05ea 00       		.byte	0
 9912 05eb 00       		.byte	0
 9913 05ec 00       		.byte	0
 9914 05ed 00       		.byte	0
 9915 05ee 00       		.byte	0
 9916 05ef 30       		.byte	48
 9917 05f0 01       		.byte	1
 9918 05f1 00       		.byte	0
 9919 05f2 00       		.byte	0
 9920 05f3 00000000 		.space	5
 9920      00
 9921 05f8 09       		.byte	9
 9922 05f9 00       		.byte	0
 9923 05fa 02       		.byte	2
 9924 05fb 00       		.byte	0
 9925 05fc 00       		.byte	0
 9926 05fd 05       		.byte	5
 9927 05fe 00       		.byte	0
 9928 05ff 01       		.byte	1
 9929 0600 00       		.byte	0
 9930 0601 03       		.byte	3
 9931 0602 00       		.byte	0
 9932 0603 00       		.byte	0
 9933 0604 00       		.byte	0
 9934 0605 00       		.byte	0
 9935 0606 00       		.byte	0
 9936 0607 30       		.byte	48
 9937 0608 01       		.byte	1
 9938 0609 00       		.byte	0
 9939 060a 00       		.byte	0
 9940 060b 00000000 		.space	5
 9940      00
 9941 0610 10       		.byte	16
 9942 0611 00       		.byte	0
 9943 0612 03       		.byte	3
 9944 0613 00       		.byte	0
 9945 0614 00       		.byte	0
 9946 0615 00       		.byte	0
 9947 0616 00       		.byte	0
 9948 0617 00       		.byte	0
 9949 0618 00       		.byte	0
 9950 0619 03       		.byte	3
 9951 061a 00       		.byte	0
 9952 061b 00       		.byte	0
 9953 061c 00       		.byte	0
 9954 061d 00       		.byte	0
 9955 061e 00       		.byte	0
 9956 061f 30       		.byte	48
 9957 0620 01       		.byte	1
 9958 0621 00       		.byte	0
 9959 0622 00       		.byte	0
 9960 0623 00000000 		.space	5
 9960      00
 9961 0628 00       		.byte	0
 9962 0629 00       		.byte	0
 9963 062a 02       		.byte	2
 9964 062b 00       		.byte	0
 9965 062c 00       		.byte	0
 9966 062d 40       		.byte	64
 9967 062e 00       		.byte	0
 9968 062f 01       		.byte	1
 9969 0630 00       		.byte	0
 9970 0631 03       		.byte	3
 9971 0632 00       		.byte	0
 9972 0633 0F       		.byte	15
 9973 0634 11       		.byte	17
 9974 0635 00       		.byte	0
 9975 0636 00       		.byte	0
 9976 0637 30       		.byte	48
 9977 0638 01       		.byte	1
 9978 0639 00       		.byte	0
 9979 063a 00       		.byte	0
 9980 063b 00000000 		.space	5
 9980      00
 9981 0640 00       		.byte	0
 9982 0641 00       		.byte	0
 9983 0642 02       		.byte	2
 9984 0643 00       		.byte	0
 9985 0644 00       		.byte	0
 9986 0645 64       		.byte	100
 9987 0646 00       		.byte	0
 9988 0647 01       		.byte	1
 9989 0648 00       		.byte	0
 9990 0649 03       		.byte	3
 9991 064a 00       		.byte	0
 9992 064b 00       		.byte	0
 9993 064c 00       		.byte	0
 9994 064d 00       		.byte	0
 9995 064e 00       		.byte	0
 9996 064f 30       		.byte	48
 9997 0650 01       		.byte	1
 9998 0651 00       		.byte	0
 9999 0652 00       		.byte	0
 10000 0653 00000000 		.space	5
 10000      00
 10001 0658 00       		.byte	0
 10002 0659 00       		.byte	0
 10003 065a 02       		.byte	2
 10004 065b 00       		.byte	0
 10005 065c 00       		.byte	0
 10006 065d 64       		.byte	100
 10007 065e 00       		.byte	0
 10008 065f 01       		.byte	1
 10009 0660 00       		.byte	0
 10010 0661 03       		.byte	3
 10011 0662 00       		.byte	0
 10012 0663 00       		.byte	0
 10013 0664 00       		.byte	0
 10014 0665 00       		.byte	0
 10015 0666 00       		.byte	0
 10016 0667 30       		.byte	48
 10017 0668 01       		.byte	1
 10018 0669 00       		.byte	0
 10019 066a 00       		.byte	0
 10020 066b 00000000 		.space	5
 10020      00
 10021 0670 00       		.byte	0
 10022 0671 00       		.byte	0
 10023 0672 02       		.byte	2
 10024 0673 00       		.byte	0
 10025 0674 00       		.byte	0
 10026 0675 64       		.byte	100
 10027 0676 00       		.byte	0
 10028 0677 01       		.byte	1
 10029 0678 00       		.byte	0
 10030 0679 03       		.byte	3
 10031 067a 00       		.byte	0
 10032 067b 00       		.byte	0
 10033 067c 00       		.byte	0
 10034 067d 00       		.byte	0
 10035 067e 00       		.byte	0
 10036 067f 30       		.byte	48
 10037 0680 01       		.byte	1
 10038 0681 00       		.byte	0
 10039 0682 00       		.byte	0
 10040 0683 00000000 		.space	5
 10040      00
 10041 0688 00       		.byte	0
 10042 0689 00       		.byte	0
 10043 068a 02       		.byte	2
 10044 068b 00       		.byte	0
 10045 068c 00       		.byte	0
 10046 068d 64       		.byte	100
 10047 068e 00       		.byte	0
 10048 068f 01       		.byte	1
 10049 0690 00       		.byte	0
 10050 0691 03       		.byte	3
 10051 0692 00       		.byte	0
 10052 0693 00       		.byte	0
 10053 0694 00       		.byte	0
 10054 0695 00       		.byte	0
 10055 0696 00       		.byte	0
 10056 0697 30       		.byte	48
 10057 0698 01       		.byte	1
 10058 0699 00       		.byte	0
 10059 069a 00       		.byte	0
 10060 069b 00000000 		.space	5
 10060      00
 10063              	glProbeCtrlFull:
 10064 06a0 00       		.byte	0
 10065 06a1 00       		.byte	0
 10066 06a2 01       		.byte	1
 10067 06a3 01       		.byte	1
 10068 06a4 15       		.byte	21
 10069 06a5 16       		.byte	22
 10070 06a6 05       		.byte	5
 10071 06a7 00       		.byte	0
 10072 06a8 00       		.byte	0
 10073 06a9 00       		.byte	0
 10074 06aa 00       		.byte	0
 10075 06ab 00       		.byte	0
 10076 06ac 00       		.byte	0
 10077 06ad 00       		.byte	0
 10078 06ae 00       		.byte	0
 10079 06af 00       		.byte	0
 10080 06b0 00       		.byte	0
 10081 06b1 00       		.byte	0
 10082 06b2 00       		.byte	0
 10083 06b3 C6       		.byte	-58
 10084 06b4 99       		.byte	-103
 10085 06b5 00       		.byte	0
 10086 06b6 00       		.byte	0
 10087 06b7 40       		.byte	64
 10088 06b8 00       		.byte	0
 10089 06b9 00       		.byte	0
 10090 06ba 0000     		.space	2
 10093              	glProbeCtrl20:
 10094 06bc 00       		.byte	0
 10095 06bd 00       		.byte	0
 10096 06be 01       		.byte	1
 10097 06bf 01       		.byte	1
 10098 06c0 80       		.byte	-128
 10099 06c1 1A       		.byte	26
 10100 06c2 06       		.byte	6
 10101 06c3 00       		.byte	0
 10102 06c4 00       		.byte	0
 10103 06c5 00       		.byte	0
 10104 06c6 00       		.byte	0
 10105 06c7 00       		.byte	0
 10106 06c8 00       		.byte	0
 10107 06c9 00       		.byte	0
 10108 06ca 00       		.byte	0
 10109 06cb 00       		.byte	0
 10110 06cc 00       		.byte	0
 10111 06cd 00       		.byte	0
 10112 06ce 00       		.byte	0
 10113 06cf D2       		.byte	-46
 10114 06d0 0F       		.byte	15
 10115 06d1 00       		.byte	0
 10116 06d2 00       		.byte	0
 10117 06d3 40       		.byte	64
 10118 06d4 00       		.byte	0
 10119 06d5 00       		.byte	0
 10120 06d6 0000     		.space	2
 10123              	glProbeCtrl:
 10124 06d8 00       		.byte	0
 10125 06d9 00       		.byte	0
 10126 06da 01       		.byte	1
 10127 06db 01       		.byte	1
 10128 06dc 15       		.byte	21
 10129 06dd 16       		.byte	22
 10130 06de 05       		.byte	5
 10131 06df 00       		.byte	0
 10132 06e0 00       		.byte	0
 10133 06e1 00       		.byte	0
 10134 06e2 00       		.byte	0
 10135 06e3 00       		.byte	0
 10136 06e4 00       		.byte	0
 10137 06e5 00       		.byte	0
 10138 06e6 00       		.byte	0
 10139 06e7 00       		.byte	0
 10140 06e8 00       		.byte	0
 10141 06e9 00       		.byte	0
 10142 06ea 00       		.byte	0
 10143 06eb 48       		.byte	72
 10144 06ec 3F       		.byte	63
 10145 06ed 00       		.byte	0
 10146 06ee 00       		.byte	0
 10147 06ef 40       		.byte	64
 10148 06f0 00       		.byte	0
 10149 06f1 00       		.byte	0
 10150 06f2 0000     		.space	2
 10153              	glProbeStilCtrl:
 10154 06f4 01       		.byte	1
 10155 06f5 02       		.byte	2
 10156 06f6 00       		.byte	0
 10157 06f7 00       		.byte	0
 10158 06f8 C6       		.byte	-58
 10159 06f9 99       		.byte	-103
 10160 06fa 00       		.byte	0
 10161 06fb 00       		.byte	0
 10162 06fc 40       		.byte	64
 10163 06fd 00       		.byte	0
 10164 06fe 00       		.byte	0
 10165 06ff 00       		.space	1
 10168              	glProbeStilCtrl20:
 10169 0700 01       		.byte	1
 10170 0701 01       		.byte	1
 10171 0702 00       		.byte	0
 10172 0703 00       		.byte	0
 10173 0704 D2       		.byte	-46
 10174 0705 0F       		.byte	15
 10175 0706 00       		.byte	0
 10176 0707 00       		.byte	0
 10177 0708 40       		.byte	64
 10178 0709 00       		.byte	0
 10179 070a 00       		.byte	0
 10182              	snapButFlag:
 10183 070b 01       		.byte	1
 10186              	CyFxGpifTransition:
 10187 070c 0000     		.short	0
 10188 070e 5555     		.short	21845
 10189 0710 8888     		.short	-30584
 10190 0712 AAAA     		.short	-21846
 10191 0714 3333     		.short	13107
 10192 0716 0000     		.space	2
 10195              	CyFxGpifWavedata:
 10196 0718 0181731E 		.word	510886145
 10197 071c 00000000 		.word	0
 10198 0720 00000080 		.word	-2147483648
 10199 0724 00000000 		.word	0
 10200 0728 00000000 		.word	0
 10201 072c 00000000 		.word	0
 10202 0730 0201702E 		.word	779092226
 10203 0734 00010000 		.word	256
 10204 0738 A0000080 		.word	-2147483488
 10205 073c 00000000 		.word	0
 10206 0740 00000000 		.word	0
 10207 0744 00000000 		.word	0
 10208 0748 0380722E 		.word	779255811
 10209 074c 02010020 		.word	536871170
 10210 0750 60000080 		.word	-2147483552
 10211 0754 00000000 		.word	0
 10212 0758 00000000 		.word	0
 10213 075c 00000000 		.word	0
 10214 0760 0460722E 		.word	779247620
 10215 0764 02010024 		.word	603980034
 10216 0768 90000080 		.word	-2147483504
 10217 076c 0594731E 		.word	510891013
 10218 0770 06000000 		.word	6
 10219 0774 00000080 		.word	-2147483648
 10220 0778 0380722E 		.word	779255811
 10221 077c 02010020 		.word	536871170
 10222 0780 60000080 		.word	-2147483552
 10223 0784 0693731E 		.word	510890758
 10224 0788 06000000 		.word	6
 10225 078c 00000080 		.word	-2147483648
 10226 0790 0720703E 		.word	1047535623
 10227 0794 08010000 		.word	264
 10228 0798 00000080 		.word	-2147483648
 10229 079c 0820703E 		.word	1047535624
 10230 07a0 08010000 		.word	264
 10231 07a4 00000080 		.word	-2147483648
 10232 07a8 0920703E 		.word	1047535625
 10233 07ac 08010000 		.word	264
 10234 07b0 00000080 		.word	-2147483648
 10235 07b4 0A20703E 		.word	1047535626
 10236 07b8 08010000 		.word	264
 10237 07bc 00000080 		.word	-2147483648
 10238 07c0 0380722E 		.word	779255811
 10239 07c4 02010020 		.word	536871170
 10240 07c8 60000080 		.word	-2147483552
 10241 07cc 0B000000 		.word	11
 10242 07d0 00000000 		.word	0
 10243 07d4 00010080 		.word	-2147483392
 10244 07d8 0460722E 		.word	779247620
 10245 07dc 02010024 		.word	603980034
 10246 07e0 90000080 		.word	-2147483504
 10247 07e4 0D000000 		.word	13
 10248 07e8 00000000 		.word	0
 10249 07ec 00010080 		.word	-2147483392
 10250 07f0 0460722E 		.word	779247620
 10251 07f4 02010024 		.word	603980034
 10252 07f8 90000080 		.word	-2147483504
 10253 07fc 0C000000 		.word	12
 10254 0800 00000000 		.word	0
 10255 0804 00010080 		.word	-2147483392
 10256 0808 0380722E 		.word	779255811
 10257 080c 02010020 		.word	536871170
 10258 0810 60000080 		.word	-2147483552
 10259 0814 0E000000 		.word	14
 10260 0818 00000000 		.word	0
 10261 081c 00010080 		.word	-2147483392
 10262 0820 00000000 		.word	0
 10263 0824 00000000 		.word	0
 10264 0828 00000000 		.word	0
 10265 082c 00000000 		.word	0
 10266 0830 00000000 		.word	0
 10267 0834 00000000 		.word	0
 10270              	CyFxGpifWavedataPosition:
 10271 0838 00       		.byte	0
 10272 0839 01       		.byte	1
 10273 083a 02       		.byte	2
 10274 083b 03       		.byte	3
 10275 083c 04       		.byte	4
 10276 083d 05       		.byte	5
 10277 083e 06       		.byte	6
 10278 083f 07       		.byte	7
 10279 0840 08       		.byte	8
 10280 0841 09       		.byte	9
 10281 0842 0A       		.byte	10
 10282 0843 0B       		.byte	11
 10283 0844 0B       		.byte	11
 10284 0845 0B       		.byte	11
 10285 0846 0B       		.byte	11
 10286 0847 00       		.space	1
 10289              	CyFxGpifRegValue:
 10290 0848 08830080 		.word	-2147450104
 10291 084c 67000000 		.word	103
 10292 0850 00000000 		.word	0
 10293 0854 46000000 		.word	70
 10294 0858 00000000 		.word	0
 10295 085c 00000000 		.word	0
 10296 0860 02000000 		.word	2
 10297 0864 82000000 		.word	130
 10298 0868 82070000 		.word	1922
 10299 086c 40040000 		.word	1088
 10300 0870 FCFF0000 		.word	65532
 10301 0874 28000000 		.word	40
 10302 0878 00000000 		.word	0
 10303 087c 00000000 		.word	0
 10304 0880 00000000 		.word	0
 10305 0884 00000000 		.word	0
 10306 0888 01000000 		.word	1
 10307 088c 00000000 		.word	0
 10308 0890 00000000 		.word	0
 10309 0894 00000000 		.word	0
 10310 0898 00000000 		.word	0
 10311 089c 00000000 		.word	0
 10312 08a0 00000000 		.word	0
 10313 08a4 00000000 		.word	0
 10314 08a8 00000000 		.word	0
 10315 08ac 00000000 		.word	0
 10316 08b0 00000000 		.word	0
 10317 08b4 00000000 		.word	0
 10318 08b8 00000000 		.word	0
 10319 08bc 06000000 		.word	6
 10320 08c0 00000000 		.word	0
 10321 08c4 FFFF0000 		.word	65535
 10322 08c8 09010000 		.word	265
 10323 08cc 00000000 		.word	0
 10324 08d0 F71F0000 		.word	8183
 10325 08d4 00000000 		.word	0
 10326 08d8 FFFF0000 		.word	65535
 10327 08dc 09010000 		.word	265
 10328 08e0 00000000 		.word	0
 10329 08e4 F71F0000 		.word	8183
 10330 08e8 00000000 		.word	0
 10331 08ec 00000000 		.word	0
 10332 08f0 00000000 		.word	0
 10333 08f4 00000000 		.word	0
 10334 08f8 00000000 		.word	0
 10335 08fc 00000000 		.word	0
 10336 0900 00000000 		.word	0
 10337 0904 00000000 		.word	0
 10338 0908 00000000 		.word	0
 10339 090c 00000000 		.word	0
 10340 0910 00000000 		.word	0
 10341 0914 00000000 		.word	0
 10342 0918 00000000 		.word	0
 10343 091c 00000000 		.word	0
 10344 0920 00000000 		.word	0
 10345 0924 00000000 		.word	0
 10346 0928 00000000 		.word	0
 10347 092c 00000000 		.word	0
 10348 0930 00000000 		.word	0
 10349 0934 00000000 		.word	0
 10350 0938 00000000 		.word	0
 10351 093c 00000000 		.word	0
 10352 0940 00000000 		.word	0
 10353 0944 00040180 		.word	-2147417088
 10354 0948 01040180 		.word	-2147417087
 10355 094c 02040180 		.word	-2147417086
 10356 0950 03040180 		.word	-2147417085
 10357 0954 00000000 		.word	0
 10358 0958 00000000 		.word	0
 10359 095c 00000000 		.word	0
 10360 0960 00000000 		.word	0
 10361 0964 00000000 		.word	0
 10362 0968 00000000 		.word	0
 10363 096c 00000000 		.word	0
 10364 0970 00000000 		.word	0
 10365 0974 C1FFFFFF 		.word	-63
 10368              	CyFxGpifTransition_usb2:
 10369 0978 0000     		.short	0
 10370 097a 5555     		.short	21845
 10371 097c AAAA     		.short	-21846
 10372 097e 8888     		.short	-30584
 10373 0980 1111     		.short	4369
 10374 0982 4444     		.short	17476
 10375 0984 3333     		.short	13107
 10376 0986 CCCC     		.short	-13108
 10379              	CyFxGpifWavedata_usb2:
 10380 0988 0181731E 		.word	510886145
 10381 098c 00000000 		.word	0
 10382 0990 00000080 		.word	-2147483648
 10383 0994 00000000 		.word	0
 10384 0998 00000000 		.word	0
 10385 099c 00000000 		.word	0
 10386 09a0 0201703E 		.word	1047527682
 10387 09a4 00010000 		.word	256
 10388 09a8 A00000C0 		.word	-1073741664
 10389 09ac 00000000 		.word	0
 10390 09b0 00000000 		.word	0
 10391 09b4 00000000 		.word	0
 10392 09b8 0394731E 		.word	510891011
 10393 09bc 04000020 		.word	536870916
 10394 09c0 60004080 		.word	-2143289248
 10395 09c4 00000000 		.word	0
 10396 09c8 00000000 		.word	0
 10397 09cc 00000000 		.word	0
 10398 09d0 0620702E 		.word	779100166
 10399 09d4 0C000000 		.word	12
 10400 09d8 00000080 		.word	-2147483648
 10401 09dc 0620702E 		.word	779100166
 10402 09e0 0C000000 		.word	12
 10403 09e4 00000080 		.word	-2147483648
 10404 09e8 0394731E 		.word	510891011
 10405 09ec 04000020 		.word	536870916
 10406 09f0 60004080 		.word	-2143289248
 10407 09f4 0620702E 		.word	779100166
 10408 09f8 0C000000 		.word	12
 10409 09fc 00000080 		.word	-2147483648
 10410 0a00 0C93731E 		.word	510890764
 10411 0a04 04000024 		.word	603979780
 10412 0a08 90004080 		.word	-2143289200
 10413 0a0c 0D20702E 		.word	779100173
 10414 0a10 0C000000 		.word	12
 10415 0a14 00000080 		.word	-2147483648
 10416 0a18 0780724E 		.word	1316126727
 10417 0a1c 0A000000 		.word	10
 10418 0a20 00000080 		.word	-2147483648
 10419 0a24 08000000 		.word	8
 10420 0a28 00000000 		.word	0
 10421 0a2c 00010080 		.word	-2147483392
 10422 0a30 0920702E 		.word	779100169
 10423 0a34 0C010000 		.word	268
 10424 0a38 00000080 		.word	-2147483648
 10425 0a3c 0A01701E 		.word	510656778
 10426 0a40 0E000100 		.word	65550
 10427 0a44 00000080 		.word	-2147483648
 10428 0a48 00000000 		.word	0
 10429 0a4c 00000000 		.word	0
 10430 0a50 00000000 		.word	0
 10431 0a54 00000000 		.word	0
 10432 0a58 00000000 		.word	0
 10433 0a5c 00000000 		.word	0
 10434 0a60 0394731E 		.word	510891011
 10435 0a64 04000020 		.word	536870916
 10436 0a68 60004080 		.word	-2143289248
 10437 0a6c 08000000 		.word	8
 10438 0a70 00000000 		.word	0
 10439 0a74 00010080 		.word	-2147483392
 10440 0a78 0B000000 		.word	11
 10441 0a7c 00000000 		.word	0
 10442 0a80 00010080 		.word	-2147483392
 10443 0a84 0C93731E 		.word	510890764
 10444 0a88 04000024 		.word	603979780
 10445 0a8c 90004080 		.word	-2143289200
 10446 0a90 0D20702E 		.word	779100173
 10447 0a94 0C000000 		.word	12
 10448 0a98 00000080 		.word	-2147483648
 10449 0a9c 0D20702E 		.word	779100173
 10450 0aa0 0C000000 		.word	12
 10451 0aa4 00000080 		.word	-2147483648
 10452 0aa8 0E60724E 		.word	1316118542
 10453 0aac 0A000000 		.word	10
 10454 0ab0 00000080 		.word	-2147483648
 10455 0ab4 0F000000 		.word	15
 10456 0ab8 00000000 		.word	0
 10457 0abc 00010080 		.word	-2147483392
 10458 0ac0 1020702E 		.word	779100176
 10459 0ac4 0C010000 		.word	268
 10460 0ac8 00000080 		.word	-2147483648
 10461 0acc 1101701E 		.word	510656785
 10462 0ad0 0E000100 		.word	65550
 10463 0ad4 00000080 		.word	-2147483648
 10464 0ad8 0C93731E 		.word	510890764
 10465 0adc 04000024 		.word	603979780
 10466 0ae0 90004080 		.word	-2143289200
 10467 0ae4 0F000000 		.word	15
 10468 0ae8 00000000 		.word	0
 10469 0aec 00010080 		.word	-2147483392
 10470 0af0 12000000 		.word	18
 10471 0af4 00000000 		.word	0
 10472 0af8 00010080 		.word	-2147483392
 10473 0afc 0394731E 		.word	510891011
 10474 0b00 04000020 		.word	536870916
 10475 0b04 60004080 		.word	-2143289248
 10476 0b08 0480732E 		.word	779321348
 10477 0b0c 02010000 		.word	258
 10478 0b10 0000C0C0 		.word	-1061158912
 10479 0b14 0580732E 		.word	779321349
 10480 0b18 02010000 		.word	258
 10481 0b1c 0000C0C0 		.word	-1061158912
 10482 0b20 0580732E 		.word	779321349
 10483 0b24 02010000 		.word	258
 10484 0b28 0000C0C0 		.word	-1061158912
 10485 0b2c 0480732E 		.word	779321348
 10486 0b30 02010000 		.word	258
 10487 0b34 0000C0C0 		.word	-1061158912
 10490              	CyFxGpifWavedataPosition_usb2:
 10491 0b38 00       		.byte	0
 10492 0b39 01       		.byte	1
 10493 0b3a 02       		.byte	2
 10494 0b3b 03       		.byte	3
 10495 0b3c 04       		.byte	4
 10496 0b3d 05       		.byte	5
 10497 0b3e 06       		.byte	6
 10498 0b3f 07       		.byte	7
 10499 0b40 08       		.byte	8
 10500 0b41 09       		.byte	9
 10501 0b42 0A       		.byte	10
 10502 0b43 08       		.byte	8
 10503 0b44 0B       		.byte	11
 10504 0b45 0C       		.byte	12
 10505 0b46 0D       		.byte	13
 10506 0b47 08       		.byte	8
 10507 0b48 0E       		.byte	14
 10508 0b49 0F       		.byte	15
 10509 0b4a 08       		.byte	8
 10510 0b4b 08       		.byte	8
 10511 0b4c 08       		.byte	8
 10512 0b4d 08       		.byte	8
 10513 0b4e 08       		.byte	8
 10514 0b4f 08       		.byte	8
 10515 0b50 08       		.byte	8
 10516 0b51 08       		.byte	8
 10517 0b52 08       		.byte	8
 10518 0b53 08       		.byte	8
 10519 0b54 08       		.byte	8
 10520 0b55 08       		.byte	8
 10521 0b56 08       		.byte	8
 10522 0b57 08       		.byte	8
 10523 0b58 08       		.byte	8
 10524 0b59 08       		.byte	8
 10525 0b5a 08       		.byte	8
 10526 0b5b 08       		.byte	8
 10527 0b5c 08       		.byte	8
 10528 0b5d 08       		.byte	8
 10529 0b5e 08       		.byte	8
 10530 0b5f 08       		.byte	8
 10531 0b60 08       		.byte	8
 10532 0b61 08       		.byte	8
 10533 0b62 08       		.byte	8
 10534 0b63 08       		.byte	8
 10535 0b64 08       		.byte	8
 10536 0b65 08       		.byte	8
 10537 0b66 08       		.byte	8
 10538 0b67 08       		.byte	8
 10539 0b68 08       		.byte	8
 10540 0b69 08       		.byte	8
 10541 0b6a 08       		.byte	8
 10542 0b6b 08       		.byte	8
 10543 0b6c 08       		.byte	8
 10544 0b6d 08       		.byte	8
 10545 0b6e 08       		.byte	8
 10546 0b6f 08       		.byte	8
 10547 0b70 08       		.byte	8
 10548 0b71 08       		.byte	8
 10549 0b72 08       		.byte	8
 10550 0b73 08       		.byte	8
 10551 0b74 08       		.byte	8
 10552 0b75 08       		.byte	8
 10553 0b76 08       		.byte	8
 10554 0b77 08       		.byte	8
 10555 0b78 08       		.byte	8
 10556 0b79 08       		.byte	8
 10557 0b7a 08       		.byte	8
 10558 0b7b 08       		.byte	8
 10559 0b7c 08       		.byte	8
 10560 0b7d 08       		.byte	8
 10561 0b7e 08       		.byte	8
 10562 0b7f 08       		.byte	8
 10563 0b80 08       		.byte	8
 10564 0b81 08       		.byte	8
 10565 0b82 08       		.byte	8
 10566 0b83 08       		.byte	8
 10567 0b84 08       		.byte	8
 10568 0b85 08       		.byte	8
 10569 0b86 08       		.byte	8
 10570 0b87 08       		.byte	8
 10571 0b88 08       		.byte	8
 10572 0b89 08       		.byte	8
 10573 0b8a 08       		.byte	8
 10574 0b8b 08       		.byte	8
 10575 0b8c 08       		.byte	8
 10576 0b8d 08       		.byte	8
 10577 0b8e 08       		.byte	8
 10578 0b8f 08       		.byte	8
 10579 0b90 08       		.byte	8
 10580 0b91 08       		.byte	8
 10581 0b92 08       		.byte	8
 10582 0b93 08       		.byte	8
 10583 0b94 08       		.byte	8
 10584 0b95 08       		.byte	8
 10585 0b96 08       		.byte	8
 10586 0b97 08       		.byte	8
 10587 0b98 08       		.byte	8
 10588 0b99 08       		.byte	8
 10589 0b9a 08       		.byte	8
 10590 0b9b 08       		.byte	8
 10591 0b9c 08       		.byte	8
 10592 0b9d 08       		.byte	8
 10593 0b9e 08       		.byte	8
 10594 0b9f 08       		.byte	8
 10595 0ba0 08       		.byte	8
 10596 0ba1 08       		.byte	8
 10597 0ba2 08       		.byte	8
 10598 0ba3 08       		.byte	8
 10599 0ba4 08       		.byte	8
 10600 0ba5 08       		.byte	8
 10601 0ba6 08       		.byte	8
 10602 0ba7 08       		.byte	8
 10603 0ba8 08       		.byte	8
 10604 0ba9 08       		.byte	8
 10605 0baa 08       		.byte	8
 10606 0bab 08       		.byte	8
 10607 0bac 08       		.byte	8
 10608 0bad 08       		.byte	8
 10609 0bae 08       		.byte	8
 10610 0baf 08       		.byte	8
 10611 0bb0 08       		.byte	8
 10612 0bb1 08       		.byte	8
 10613 0bb2 08       		.byte	8
 10614 0bb3 08       		.byte	8
 10615 0bb4 08       		.byte	8
 10616 0bb5 08       		.byte	8
 10617 0bb6 08       		.byte	8
 10618 0bb7 08       		.byte	8
 10619 0bb8 00       		.byte	0
 10620 0bb9 01       		.byte	1
 10621 0bba 02       		.byte	2
 10622 0bbb 10       		.byte	16
 10623 0bbc 04       		.byte	4
 10624 0bbd 05       		.byte	5
 10625 0bbe 06       		.byte	6
 10626 0bbf 07       		.byte	7
 10627 0bc0 08       		.byte	8
 10628 0bc1 09       		.byte	9
 10629 0bc2 0A       		.byte	10
 10630 0bc3 08       		.byte	8
 10631 0bc4 11       		.byte	17
 10632 0bc5 0C       		.byte	12
 10633 0bc6 0D       		.byte	13
 10634 0bc7 08       		.byte	8
 10635 0bc8 0E       		.byte	14
 10636 0bc9 0F       		.byte	15
 10637 0bca 08       		.byte	8
 10638 0bcb 00       		.space	1
 10641              	CyFxGpifRegValue_usb2:
 10642 0bcc 08830080 		.word	-2147450104
 10643 0bd0 67000000 		.word	103
 10644 0bd4 01000000 		.word	1
 10645 0bd8 46000000 		.word	70
 10646 0bdc 00000000 		.word	0
 10647 0be0 00000000 		.word	0
 10648 0be4 02000000 		.word	2
 10649 0be8 82000000 		.word	130
 10650 0bec 82070000 		.word	1922
 10651 0bf0 40040000 		.word	1088
 10652 0bf4 FCFF0000 		.word	65532
 10653 0bf8 28000000 		.word	40
 10654 0bfc 00000000 		.word	0
 10655 0c00 00000000 		.word	0
 10656 0c04 00000000 		.word	0
 10657 0c08 00000000 		.word	0
 10658 0c0c 01000000 		.word	1
 10659 0c10 00000000 		.word	0
 10660 0c14 00000000 		.word	0
 10661 0c18 00000000 		.word	0
 10662 0c1c 00000000 		.word	0
 10663 0c20 00000000 		.word	0
 10664 0c24 00000000 		.word	0
 10665 0c28 00000000 		.word	0
 10666 0c2c 00000000 		.word	0
 10667 0c30 00000000 		.word	0
 10668 0c34 00000000 		.word	0
 10669 0c38 00000000 		.word	0
 10670 0c3c 00000000 		.word	0
 10671 0c40 06000000 		.word	6
 10672 0c44 00000000 		.word	0
 10673 0c48 FFFF0000 		.word	65535
 10674 0c4c 09010000 		.word	265
 10675 0c50 00000000 		.word	0
 10676 0c54 F71F0000 		.word	8183
 10677 0c58 00000000 		.word	0
 10678 0c5c FFFF0000 		.word	65535
 10679 0c60 09010000 		.word	265
 10680 0c64 00000000 		.word	0
 10681 0c68 F71F0000 		.word	8183
 10682 0c6c 00000000 		.word	0
 10683 0c70 00000000 		.word	0
 10684 0c74 00000000 		.word	0
 10685 0c78 00000000 		.word	0
 10686 0c7c 00000000 		.word	0
 10687 0c80 00000000 		.word	0
 10688 0c84 00000000 		.word	0
 10689 0c88 00000000 		.word	0
 10690 0c8c 00000000 		.word	0
 10691 0c90 00000000 		.word	0
 10692 0c94 00000000 		.word	0
 10693 0c98 00000000 		.word	0
 10694 0c9c 00000000 		.word	0
 10695 0ca0 00000000 		.word	0
 10696 0ca4 00000000 		.word	0
 10697 0ca8 00000000 		.word	0
 10698 0cac 00000000 		.word	0
 10699 0cb0 00000000 		.word	0
 10700 0cb4 00000000 		.word	0
 10701 0cb8 00000000 		.word	0
 10702 0cbc 00000000 		.word	0
 10703 0cc0 00000000 		.word	0
 10704 0cc4 00000000 		.word	0
 10705 0cc8 00040180 		.word	-2147417088
 10706 0ccc 01040180 		.word	-2147417087
 10707 0cd0 02040180 		.word	-2147417086
 10708 0cd4 03040180 		.word	-2147417085
 10709 0cd8 00000000 		.word	0
 10710 0cdc 00000000 		.word	0
 10711 0ce0 00000000 		.word	0
 10712 0ce4 00000000 		.word	0
 10713 0ce8 00000000 		.word	0
 10714 0cec 00000000 		.word	0
 10715 0cf0 00000000 		.word	0
 10716 0cf4 00000000 		.word	0
 10717 0cf8 C1FFFFFF 		.word	-63
 10718              		.section	.rodata.str1.4,"aMS",%progbits,1
 10719              		.align	2
 10720              	.LC0:
 10721 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 10721      7065722D 
 10721      74696D65 
 10721      72202564 
 10721      0D0A00
 10722 0013 00       		.space	1
 10723              	.LC1:
 10724 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 10724      636F6D6D 
 10724      616E6420 
 10724      71756575 
 10724      65206973 
 10725 0037 00       		.space	1
 10726              	.LC2:
 10727 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 10727      5420656E 
 10727      636F756E 
 10727      74657265 
 10727      642E2E2E 
 10728              	.LC3:
 10729 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 10729      454E4420 
 10729      656E636F 
 10729      756E7465 
 10729      7265642E 
 10730 007a 0000     		.space	2
 10731              	.LC4:
 10732 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 10732      64697363 
 10732      6F6E6E65 
 10732      63746564 
 10732      2E2E2E30 
 10733 009b 00       		.space	1
 10734              	.LC5:
 10735 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 10735      7220696E 
 10735      206D756C 
 10735      74696368 
 10735      616E6E65 
 10736 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 10736      2025782C 
 10736      20646D61 
 10736      446F6E65 
 10736      20256420 
 10737              	.LC6:
 10738 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 10738      43595F46 
 10738      585F5556 
 10738      435F5649 
 10738      44454F5F 
 10739 011b 0A00     		.ascii	"\012\000"
 10740 011d 000000   		.space	3
 10741              	.LC7:
 10742 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 10742      43595F46 
 10742      585F5556 
 10742      435F5649 
 10742      44454F5F 
 10743 0153 00       		.ascii	"\000"
 10744              	.LC8:
 10745 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 10745      726E6174 
 10745      65207365 
 10745      7474696E 
 10745      6720302E 
 10746              	.LC9:
 10747 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 10747      72206665 
 10747      61747572 
 10747      65207265 
 10747      71756573 
 10748 018f 00       		.space	1
 10749              	.LC10:
 10750 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 10750      6F6D6D69 
 10750      74656F66 
 10750      20737461 
 10750      7465203D 
 10751              	.LC11:
 10752 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 10752      6E656C20 
 10752      53657420 
 10752      57726170 
 10752      55702066 
 10753 01d5 000000   		.space	3
 10754              	.LC12:
 10755 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 10755      72206861 
 10755      6E646C65 
 10755      722E2E2E 
 10755      0D0A00
 10756 01eb 00       		.space	1
 10757              	.LC13:
 10758 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 10758      69742045 
 10758      4F462066 
 10758      61696C65 
 10758      64210D0A 
 10759 0201 000000   		.space	3
 10760              	.LC14:
 10761 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 10761      49324320 
 10761      636F6D6D 
 10761      616E6420 
 10761      69732030 
 10762 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10762      78257820 
 10762      30782578 
 10762      20307825 
 10762      78203078 
 10763              	.LC15:
 10764 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 10764      49324320 
 10764      636F6D6D 
 10764      616E6420 
 10764      73657474 
 10765 0276 0000     		.space	2
 10766              	.LC16:
 10767 0278 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 10767      73687574 
 10767      74657220 
 10767      73657420 
 10767      76616C75 
 10768 02a2 0000     		.space	2
 10769              	.LC17:
 10770 02a4 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 10770      206C6967 
 10770      68742063 
 10770      6F6D7065 
 10770      6E736174 
 10771 02d7 25640D0A 		.ascii	"%d\015\012\000"
 10771      00
 10772              	.LC18:
 10773 02dc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 10773      49324320 
 10773      63757272 
 10773      656E7420 
 10773      64617461 
 10774 030f 64202564 		.ascii	"d %d\015\012\000"
 10774      0D0A00
 10775 0316 0000     		.space	2
 10776              	.LC19:
 10777 0318 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 10777      26414743 
 10777      2073656E 
 10777      7420746F 
 10777      20686F73 
 10778 033e 0000     		.space	2
 10779              	.LC20:
 10780 0340 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10780      73687574 
 10780      74657226 
 10780      6578706F 
 10780      73757265 
 10781 036b 00       		.space	1
 10782              	.LC21:
 10783 036c 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 10783      26414743 
 10783      20676F74 
 10783      74656E20 
 10783      66726F6D 
 10784 039d 0A00     		.ascii	"\012\000"
 10785 039f 00       		.space	1
 10786              	.LC22:
 10787 03a0 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 10787      74657220 
 10787      6C657665 
 10787      6C20676F 
 10787      7474656E 
 10788 03d3 25640D0A 		.ascii	"%d\015\012\000"
 10788      00
 10789              	.LC23:
 10790 03d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 10790      20746865 
 10790      20766964 
 10790      656F206D 
 10790      6F646520 
 10791 03fa 0000     		.space	2
 10792              	.LC24:
 10793 03fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 10793      67657420 
 10793      64617461 
 10793      2066726F 
 10793      6D20686F 
 10794 0429 000000   		.space	3
 10795              	.LC25:
 10796 042c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 10796      52657175 
 10796      65737420 
 10796      30782578 
 10796      20706172 
 10797 045f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 10797      6E642074 
 10797      6F20686F 
 10797      73742030 
 10797      78257820 
 10798 047a 0000     		.space	2
 10799              	.LC26:
 10800 047c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 10800      204F7020 
 10800      72656365 
 10800      69766573 
 10800      20284354 
 10801 04a3 00       		.space	1
 10802              	.LC27:
 10803 04a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 10803      756C7420 
 10803      73656C65 
 10803      63746F72 
 10803      20284354 
 10804 04c6 0000     		.space	2
 10805              	.LC28:
 10806 04c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 10806      756C7420 
 10806      72657175 
 10806      65737420 
 10806      28435429 
 10807 04e9 000000   		.space	3
 10808              	.LC29:
 10809 04ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 10809      52657175 
 10809      65737420 
 10809      30782578 
 10809      20706172 
 10810 051f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 10810      20307825 
 10810      78202F20 
 10810      73656E64 
 10810      20746F20 
 10811 054c 00       		.ascii	"\000"
 10812 054d 000000   		.space	3
 10813              	.LC30:
 10814 0550 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 10814      73706565 
 10814      64203D20 
 10814      25642065 
 10814      76656E66 
 10815 0580 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 10815      71756573 
 10815      74203D20 
 10815      30782578 
 10815      20775661 
 10816 05b0 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 10816      203D2030 
 10816      78257820 
 10816      6973666C 
 10816      61672030 
 10817 05ca 0000     		.space	2
 10818              	.LC31:
 10819 05cc 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 10819      64656661 
 10819      756C7420 
 10819      73657475 
 10819      70207265 
 10820              	.LC32:
 10821 05f8 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 10821      6F207374 
 10821      7265616D 
 10821      20474554 
 10821      20726571 
 10822 061d 000000   		.space	3
 10823              	.LC33:
 10824 0620 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 10824      74686520 
 10824      76696465 
 10824      6F206D6F 
 10824      64652066 
 10825 0641 000000   		.space	3
 10826              	.LC34:
 10827 0644 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 10827      74686520 
 10827      76696465 
 10827      6F206D6F 
 10827      64652066 
 10828 0669 000000   		.space	3
 10829              	.LC35:
 10830 066c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 10830      43595F46 
 10830      585F5556 
 10830      435F5354 
 10830      5245414D 
 10831 0692 0000     		.space	2
 10832              	.LC36:
 10833 0694 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 10833      55564320 
 10833      7374696C 
 10833      6C205072 
 10833      6F622873 
 10834 06bf 00       		.space	1
 10835              	.LC37:
 10836 06c0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 10836      74686520 
 10836      7374696C 
 10836      6C206D6F 
 10836      64652066 
 10837 06e1 000000   		.space	3
 10838              	.LC38:
 10839 06e4 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 10839      7374696C 
 10839      6C20636F 
 10839      6D6D6974 
 10839      20636F6E 
 10840              	.LC39:
 10841 070c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 10841      43595F46 
 10841      585F5556 
 10841      435F5354 
 10841      494C5F45 
 10842              	.LC40:
 10843 0730 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 10843      55564320 
 10843      7374696C 
 10843      6C207472 
 10843      69676765 
 10844 0759 000000   		.space	3
 10845              	.LC41:
 10846 075c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 10846      7374696C 
 10846      6C207472 
 10846      69676765 
 10846      7220636F 
 10847 0783 00       		.space	1
 10848              	.LC42:
 10849 0784 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 10849      65642074 
 10849      6F207365 
 10849      6E642069 
 10849      6E746572 
 10850 07b5 0A00     		.ascii	"\012\000"
 10851 07b7 00       		.space	1
 10852              	.LC43:
 10853 07b8 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 10853      73657420 
 10853      64656620 
 10853      64617461 
 10853      20307825 
 10854 07d7 00       		.space	1
 10855              	.LC44:
 10856 07d8 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 10856      73657420 
 10856      64656620 
 10856      64617461 
 10856      20307825 
 10857 080b 2E0D0A00 		.ascii	".\015\012\000"
 10858 080f 00       		.space	1
 10859              	.LC45:
 10860 0810 55415254 		.ascii	"UART initialization failed!\012\000"
 10860      20696E69 
 10860      7469616C 
 10860      697A6174 
 10860      696F6E20 
 10861 082d 000000   		.space	3
 10862              	.LC46:
 10863 0830 49324320 		.ascii	"I2C initialization failed!\012\000"
 10863      696E6974 
 10863      69616C69 
 10863      7A617469 
 10863      6F6E2066 
 10864              	.LC47:
 10865 084c 49324320 		.ascii	"I2C configuration failed!\012\000"
 10865      636F6E66 
 10865      69677572 
 10865      6174696F 
 10865      6E206661 
 10866 0867 00       		.space	1
 10867              	.LC48:
 10868 0868 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 10868      43726561 
 10868      74652045 
 10868      76656E74 
 10868      20666169 
 10869 0892 0000     		.space	2
 10870              	.LC49:
 10871 0894 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 10871      20496E69 
 10871      74206661 
 10871      696C6564 
 10871      2C204572 
 10872 08b7 00       		.space	1
 10873              	.LC50:
 10874 08b8 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 10874      204F7665 
 10874      72726964 
 10874      65206661 
 10874      696C6564 
 10875 08df 00       		.space	1
 10876              	.LC51:
 10877 08e0 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 10877      28323029 
 10877      204F7665 
 10877      72726964 
 10877      65206661 
 10878 090b 00       		.space	1
 10879              	.LC52:
 10880 090c 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 10880      28323429 
 10880      204F7665 
 10880      72726964 
 10880      65206661 
 10881 0937 00       		.space	1
 10882              	.LC53:
 10883 0938 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 10883      20536574 
 10883      20287265 
 10883      73657420 
 10883      32322920 
 10884 096a 00       		.ascii	"\000"
 10885 096b 00       		.space	1
 10886              	.LC54:
 10887 096c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 10887      20536574 
 10887      2028706F 
 10887      77657220 
 10887      32302920 
 10888 099e 00       		.ascii	"\000"
 10889 099f 00       		.space	1
 10890              	.LC55:
 10891 09a0 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 10891      20536574 
 10891      2028736E 
 10891      61702073 
 10891      686F7420 
 10892 09d3 25640A00 		.ascii	"%d\012\000"
 10893 09d7 00       		.space	1
 10894              	.LC56:
 10895 09d8 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 10895      46756E63 
 10895      74696F6E 
 10895      20466169 
 10895      6C656420 
 10896 0a07 00       		.space	1
 10897              	.LC57:
 10898 0a08 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 10898      46756E63 
 10898      74696F6E 
 10898      20466169 
 10898      6C656420 
 10899 0a37 00       		.space	1
 10900              	.LC58:
 10901 0a38 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 10901      53657420 
 10901      456E6470 
 10901      6F696E74 
 10901      20636F6E 
 10902 0a68 00       		.ascii	"\000"
 10903 0a69 000000   		.space	3
 10904              	.LC59:
 10905 0a6c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 10905      496E7465 
 10905      72727570 
 10905      74205374 
 10905      61747573 
 10906 0a9f 20436F64 		.ascii	" Code = %d\012\000"
 10906      65203D20 
 10906      25640A00 
 10907 0aab 00       		.space	1
 10908              	.LC60:
 10909 0aac 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 10909      65642074 
 10909      6F20616C 
 10909      6C6F6361 
 10909      7465206D 
 10910 0adf 65720D0A 		.ascii	"er\015\012\000"
 10910      00
 10911              	.LC61:
 10912 0ae4 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 10912      4368616E 
 10912      6E656C20 
 10912      43726561 
 10912      74696F6E 
 10913 0b12 0000     		.space	2
 10914              	.LC62:
 10915 0b14 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 10915      436F6E6E 
 10915      65637420 
 10915      6661696C 
 10915      65642C20 
 10916 0b39 000000   		.space	3
 10917              	.LC63:
 10918 0b3c 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 10918      74686520 
 10918      76696465 
 10918      6F206D6F 
 10918      64652066 
 10919 0b5e 0000     		.space	2
 10920              	.LC64:
 10921 0b60 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 10921      4368616E 
 10921      6E656C20 
 10921      52657365 
 10921      74204661 
 10922 0b8b 00       		.space	1
 10923              	.LC65:
 10924 0b8c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 10924      4368616E 
 10924      6E656C20 
 10924      53657420 
 10924      5472616E 
 10925 0bbd 00       		.ascii	"\000"
 10926 0bbe 0000     		.space	2
 10927              	.LC66:
 10928 0bc0 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 10928      4368616E 
 10928      6E656C20 
 10928      53657420 
 10928      5472616E 
 10929 0bf1 0A00     		.ascii	"\012\000"
 10930 0bf3 00       		.space	1
 10931              	.LC67:
 10932 0bf4 0D0A2073 		.ascii	"\015\012 super gpif\000"
 10932      75706572 
 10932      20677069 
 10932      6600
 10933 0c02 0000     		.space	2
 10934              	.LC68:
 10935 0c04 0D0A2068 		.ascii	"\015\012 high gpif\000"
 10935      69676820 
 10935      67706966 
 10935      00
 10936 0c11 000000   		.space	3
 10937              	.LC69:
 10938 0c14 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 10938      696E6720 
 10938      47504946 
 10938      20436F6E 
 10938      66696775 
 10939 0c47 0A00     		.ascii	"\012\000"
 10940 0c49 000000   		.space	3
 10941              	.LC70:
 10942 0c4c 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 10942      74696E67 
 10942      20475049 
 10942      46207374 
 10942      61746520 
 10943 0c7f 0D0A00   		.ascii	"\015\012\000"
 10944 0c82 0000     		.space	2
 10945              	.LC71:
 10946 0c84 33303A55 		.ascii	"30:UVC App Thread\000"
 10946      56432041 
 10946      70702054 
 10946      68726561 
 10946      6400
 10947 0c96 0000     		.space	2
 10948              	.LC72:
 10949 0c98 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 10949      56432041 
 10949      70702045 
 10949      50302054 
 10949      68726561 
 10950 0cae 0000     		.space	2
 10951              	.LC73:
 10952 0cb0 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 10952      32432041 
 10952      70702043 
 10952      54524C20 
 10952      54687265 
 10953 0cc7 00       		.bss
 10954              		.align	2
 10955              		.set	.LANCHOR0,. + 0
 10958              	glFxUVCEvent:
 10959 0000 00000000 		.space	40
 10959      00000000 
 10959      00000000 
 10959      00000000 
 10959      00000000 
 10962              	gpif_initialized:
 10963 0028 00000000 		.space	4
 10966              	streamingStarted:
 10967 002c 00000000 		.space	4
 10970              	isUsbConnected:
 10971 0030 00000000 		.space	4
 10974              	fb:
 10975 0034 0000     		.space	2
 10978              	pb:
 10979 0036 0000     		.space	2
 10982              	pbc:
 10983 0038 0000     		.space	2
 10986              	stiflag:
 10987 003a 00       		.space	1
 10988 003b 00       		.space	1
 10991              	hitFV:
 10992 003c 00000000 		.space	4
 10995              	prodCount:
 10996 0040 0000     		.space	2
 10999              	consCount:
 11000 0042 0000     		.space	2
 11003              	clearFeatureRqtReceived:
 11004 0044 00000000 		.space	4
 11007              	usbSpeed:
 11008 0048 00       		.space	1
 11009 0049 000000   		.space	3
 11012              	I2CCMDArry:
 11013 004c 00000000 		.space	12
 11013      00000000 
 11013      00000000 
 11016              	is60Hz:
 11017 0058 00000000 		.space	4
 11020              	glEp0Buffer:
 11021 005c 00000000 		.space	32
 11021      00000000 
 11021      00000000 
 11021      00000000 
 11021      00000000 
 11024              	CamMode:
 11025 007c 00       		.space	1
 11028              	setRes:
 11029 007d 00       		.space	1
 11030 007e 0000     		.space	2
 11033              	glCommitCtrl:
 11034 0080 00000000 		.space	32
 11034      00000000 
 11034      00000000 
 11034      00000000 
 11034      00000000 
 11037              	setstilRes:
 11038 00a0 00       		.space	1
 11041              	IMcount.7849:
 11042 00a1 00       		.space	1
 11043 00a2 0000     		.space	2
 11046              	uvcAppThread:
 11047 00a4 00000000 		.space	168
 11047      00000000 
 11047      00000000 
 11047      00000000 
 11047      00000000 
 11050              	uvcAppEP0Thread:
 11051 014c 00000000 		.space	168
 11051      00000000 
 11051      00000000 
 11051      00000000 
 11051      00000000 
 11054              	i2cAppThread:
 11055 01f4 00000000 		.space	168
 11055      00000000 
 11055      00000000 
 11055      00000000 
 11055      00000000 
 11058              	testSnap:
 11059 029c 00       		.space	1
 11060 029d 00       		.space	1
 11063              	fbbak:
 11064 029e 0000     		.space	2
 11067              	pbbak:
 11068 02a0 0000     		.space	2
 11071              	pbcbak:
 11072 02a2 0000     		.space	2
 11075              	pbcpbak:
 11076 02a4 0000     		.space	2
 11077 02a6 0000     		.text
 11078              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1461   .text:00000bb8 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1469   .text:00000bcc $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1472   .text:00000bcc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1535   .text:00000c4c getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1558   .text:00000c64 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1571   .text:00000c8c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1677   .text:00000d80 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1685   .text:00000d94 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1688   .text:00000d94 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1902   .text:00000f3c $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:1944   .text:00000fd8 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:2008   .text:00001058 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:2049   .text:000010f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3317   .text:00001c20 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3338   .text:00001c68 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3543   .text:00001e8c $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3549   .text:00001e9c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3753   .text:000020e4 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3921   .text:00002240 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:3934   .text:00002268 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4429   .text:00002778 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4440   .text:00002798 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4702   .text:00002a54 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4715   .text:00002a7c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4718   .text:00002a7c UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4780   .text:00002af8 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:4788   .text:00002b08 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:5221   .text:00002f40 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:5228   .text:00002f50 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:5704   .text:00003348 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:5711   .text:00003358 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6231   .text:000037ec $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6266   .text:00003864 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6269   .text:00003864 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6560   .text:00003b1c $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6567   .text:00003b2c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6570   .text:00003b2c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6611   .text:00003b70 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6616   .text:00003b78 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6619   .text:00003b78 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6644   .text:00003b94 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6648   .text:00003b98 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:6651   .text:00003b98 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:7998   .text:00004638 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8004   .text:00004648 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8120   .text:000047b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8179   .text:00004890 $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8182   .text:00004890 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8339   .text:00004a08 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8355   .text:00004a3c $a
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8358   .text:00004a3c main
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10186  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10195  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10270  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10289  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8564   .rodata:000000e0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10368  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10379  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10490  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10641  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8577   .rodata:000000fc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10182  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11058  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10974  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10978  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10982  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11063  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11067  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11071  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11075  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10970  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11007  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11003  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10966  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10123  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10063  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10153  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10093  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10168  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9559   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8498   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8502   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8517   .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9579   .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9623   .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9601   .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9652   .data:000004d0 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9674   .data:000004e4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8545   .rodata:000000a0 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9696   .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9718   .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8589   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8593   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:8916   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9574   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9645   .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:9740   .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10719  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10954  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10958  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10962  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10986  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10991  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10995  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:10999  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11012  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11016  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11020  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11024  .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11028  .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11033  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11037  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11041  .bss:000000a1 IMcount.7849
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11046  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11050  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccysmPQl.s:11054  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
