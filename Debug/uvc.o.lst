   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1083:../uvc.c      **** 		&EXTShutter,
1084:../uvc.c      **** 		&EXTSensUp,
1085:../uvc.c      **** 		&EXTMirror,
1086:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1087:../uvc.c      **** 		&EXT3DNoiseLev,
1088:../uvc.c      **** 		&EXTDayNightMode,
1089:../uvc.c      **** 		&EXTDayNightdely,
1090:../uvc.c      **** 		&EXTDayNightlev,
1091:../uvc.c      **** 		&EXTNightDaylev,
1092:../uvc.c      **** 		&EXTAexModGainlev,
1093:../uvc.c      **** 		&EXTExpReflev,
1094:../uvc.c      **** 		&EXTShutlev,
1095:../uvc.c      **** 		&EXTCamMode,
1096:../uvc.c      **** 		0, //&EXTSnapshot,
1097:../uvc.c      **** 		&EXTSensorPare,
1098:../uvc.c      **** 		&EXTI2Ccmd,
1099:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1100:../uvc.c      **** 		0, //&Ext1CtlID1,
1101:../uvc.c      **** 		0, //&Ext1CtlID2,
1102:../uvc.c      **** 		0, //&Ext1CtlID3,
1103:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1104:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1105:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1106:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1107:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1108:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1109:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1110:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1111:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1112:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1113:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1114:../uvc.c      **** 		0, //&Ext1CtlID15,
1115:../uvc.c      **** 		0
1116:../uvc.c      **** };
1117:../uvc.c      **** 
1118:../uvc.c      **** #endif //end of the new control structure
1119:../uvc.c      **** 
1120:../uvc.c      **** #ifndef CAM720
1121:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1122:../uvc.c      **** #else
1123:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1124:../uvc.c      **** #endif
1125:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1126:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1127:../uvc.c      **** 
1128:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1129:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1130:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1131:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1132:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1133:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1134:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1135:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1136:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1137:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1138:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1139:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1140:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1141:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1142:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1143:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1144:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1145:../uvc.c      **** };
1146:../uvc.c      **** 
1147:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1148:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1149:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1150:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1151:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1152:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1153:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1154:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1155:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1156:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1157:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1158:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1159:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1160:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1161:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1162:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1163:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1164:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1165:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1166:../uvc.c      **** };
1167:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1168:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1169:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1170:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1171:../uvc.c      **** /*
1172:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1173:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1174:../uvc.c      ****  */
1175:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1176:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1177:../uvc.c      **** };
1178:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1179:../uvc.c      **** 		0
1180:../uvc.c      **** };
1181:../uvc.c      **** 
1182:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1183:../uvc.c      **** 
1184:../uvc.c      **** void I2CCmdHandler(){
1185:../uvc.c      **** 	uint8_t buf[2];
1186:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1187:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1188:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1189:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1190:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1191:../uvc.c      **** 	uint8_t i;
1192:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1193:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1194:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1195:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1196:../uvc.c      **** 	{
1197:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1198:../uvc.c      **** 		if(is60Hz==CyFalse)
1199:../uvc.c      **** 			{
1200:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1201:../uvc.c      **** 			}
1202:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1203:../uvc.c      **** 
1204:../uvc.c      **** 	}
1205:../uvc.c      **** 	if(CmdType == 0)//I2C read
1206:../uvc.c      **** 	{
1207:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1208:../uvc.c      **** #if 0 //for debugging
1209:../uvc.c      **** 		/* test still image operation */
1210:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1211:../uvc.c      **** 			snapButFlag = 0; //press
1212:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1213:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1214:../uvc.c      **** 			snapButFlag = 0xf; //release
1215:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1216:../uvc.c      **** 		}
1217:../uvc.c      **** 
1218:../uvc.c      **** 		/* end of the test */
1219:../uvc.c      **** #endif
1220:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1221:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1222:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1223:../uvc.c      **** 				if(CmdDataLen == 2){
1224:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1225:../uvc.c      **** 				}
1226:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1227:../uvc.c      **** 		}else{//not support currently
1228:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1229:../uvc.c      **** 		}
1230:../uvc.c      **** 	}else if(CmdType == 1){
1231:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1232:../uvc.c      **** 			if(CmdRegLen == 2){
1233:../uvc.c      **** 				for(i = 0; i<4; i++)
1234:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1235:../uvc.c      **** 			}
1236:../uvc.c      **** 			else{
1237:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1238:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1239:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1240:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1241:../uvc.c      **** 				}
1242:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1243:../uvc.c      **** 			}
1244:../uvc.c      **** 		}else{//not support currently
1245:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1246:../uvc.c      **** 		}
1247:../uvc.c      **** 
1248:../uvc.c      **** 	}
1249:../uvc.c      **** }
1250:../uvc.c      **** 
1251:../uvc.c      **** /************************************
1252:../uvc.c      ****  * set Iris mode
1253:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1254:../uvc.c      ****  */
1255:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1256:../uvc.c      **** 	uint8_t dataIdx = 0;
1257:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1259:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1260:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1261:../uvc.c      **** }
1262:../uvc.c      **** 
1263:../uvc.c      **** 
1264:../uvc.c      **** 
1265:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1266:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1267:../uvc.c      **** 	uint16_t NumLn;
1268:../uvc.c      **** 	uint16_t fRate, shutTm;
1269:../uvc.c      **** 	uint8_t LnVal;
1270:../uvc.c      **** 	switch (Data){
1271:../uvc.c      **** 	case 1:
1272:../uvc.c      **** 	case 2:
1273:../uvc.c      **** 	case 3:
1274:../uvc.c      **** 	case 4:
1275:../uvc.c      **** 	case 5:
1276:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1277:../uvc.c      **** 		fRate = 30;
1278:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1279:../uvc.c      **** 		if(NumLn > 1944)
1280:../uvc.c      **** 			NumLn =1944;
1281:../uvc.c      **** 		else if(NumLn < 8)
1282:../uvc.c      **** 			NumLn = 8;
1283:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1284:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1285:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1286:../uvc.c      **** 		break;
1287:../uvc.c      **** 	case 6:
1288:../uvc.c      **** 	case 7:
1289:../uvc.c      **** 	case 8:
1290:../uvc.c      **** 	case 9:
1291:../uvc.c      **** 	case 10:
1292:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1293:../uvc.c      **** 		fRate = 30;
1294:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1295:../uvc.c      **** 		if(NumLn > 1944)
1296:../uvc.c      **** 			NumLn =1944;
1297:../uvc.c      **** 		else if(NumLn < 8)
1298:../uvc.c      **** 			NumLn = 8;
1299:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1300:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1301:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1302:../uvc.c      **** 		break;
1303:../uvc.c      **** 	case 0: //auto
1304:../uvc.c      **** 	default:
1305:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1306:../uvc.c      **** 		LnVal = 1;
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	}
1309:../uvc.c      **** 	return LnVal;
1310:../uvc.c      **** }
1311:../uvc.c      **** 
1312:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1313:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1314:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1315:../uvc.c      ****     uint16_t readCount;
1316:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1317:../uvc.c      ****     uint8_t devAdd;
1318:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1319:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1320:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1321:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1322:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1323:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1324:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1325:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1326:../uvc.c      ****     }else{
1327:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1328:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1329:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1330:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1331:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1332:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1333:../uvc.c      ****     }
1334:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1335:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1336:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1337:../uvc.c      **** #endif
1338:../uvc.c      ****     reqData = bRequest;
1339:../uvc.c      ****     /*
1340:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1341:../uvc.c      ****      */
1342:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1343:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1344:../uvc.c      ****     	//goto EndofSet;
1345:../uvc.c      ****     //}
1346:../uvc.c      ****     switch (bRequest)
1347:../uvc.c      **** 		 {
1348:../uvc.c      **** 
1349:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1350:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1351:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1352:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1353:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1354:../uvc.c      **** 			  break;
1355:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1356:../uvc.c      **** 
1357:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1358:../uvc.c      **** 				 switch(CtrlID)
1359:../uvc.c      **** 				 {
1360:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1361:../uvc.c      **** 						 if(curFlag[CtrlID]){
1362:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1363:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1364:../uvc.c      **** 						 }else{
1365:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1366:../uvc.c      **** 							if(Data0&0x80)
1367:../uvc.c      **** 								glEp0Buffer[0] = 1;
1368:../uvc.c      **** 							else
1369:../uvc.c      **** 								glEp0Buffer[0] = 0;
1370:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1371:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1372:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1373:../uvc.c      **** 						 }
1374:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1375:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1376:../uvc.c      **** 						 break;
1377:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1378:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1379:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1380:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1381:../uvc.c      **** 			 	 		 }else{
1382:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1383:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
1384:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1385:../uvc.c      **** 
1386:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1387:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1388:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1389:../uvc.c      **** 			 	 		 }
1390:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1391:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1392:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1393:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1394:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1
1395:../uvc.c      **** 						 break;
1396:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1397:../uvc.c      **** #if 0 //not be used
1398:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1399:../uvc.c      **** 
1400:../uvc.c      **** 						 if(CamMode == 1){//720p
1401:../uvc.c      **** 							if(sendData >= 3){
1402:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1403:../uvc.c      **** 								sendData = 0; //set back to default
1404:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1405:../uvc.c      **** 							}
1406:../uvc.c      **** 							sendData += 4;
1407:../uvc.c      **** 						 }
1408:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1409:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1410:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1411:../uvc.c      **** #endif
1412:../uvc.c      **** 						 break;
1413:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1414:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1415:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1416:../uvc.c      **** 				 		 }
1417:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1418:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1419:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1420:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1421:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1422:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1423:../uvc.c      **** 	#endif
1424:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1425:../uvc.c      **** 				 		 {
1426:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1427:../uvc.c      **** 				 		 }
1428:../uvc.c      **** 				 		 break;
1429:../uvc.c      **** 				 		 case Ext1BLCRangeCtlID4:
1430:../uvc.c      **** /*			 	 		 if(curFlag[CtrlID]){
1431:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1432:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1433:../uvc.c      **** 			 	 		 }else{
1434:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1435:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1436:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1437:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1438:../uvc.c      **** 			 	 		 }
1439:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1440:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1441:../uvc.c      **** 						 break;
1442:../uvc.c      **** 						 */
1443:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1444:../uvc.c      **** 			 	 		 /*
1445:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
1446:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
1447:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1448:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1449:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1450:../uvc.c      **** 			 	 		 }else{
1451:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1452:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
1453:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1454:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1455:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1456:../uvc.c      **** 			 	 		 }
1457:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1458:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1459:../uvc.c      **** 			 	 		 break;
1460:../uvc.c      **** 			 	 		 */
1461:../uvc.c      **** 				 	 case ExtShutCtlID0:
1462:../uvc.c      **** 				 		 /*
1463:../uvc.c      **** 					     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1464:../uvc.c      **** 					     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1465:../uvc.c      **** 					     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1466:../uvc.c      **** 
1467:../uvc.c      **** 						 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1468:../uvc.c      **** 								 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1469:../uvc.c      **** 						 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1470:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1471:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1472:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1473:../uvc.c      **** 			 	 		 }else{
1474:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1475:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1476:../uvc.c      **** 			 	 			Data1 = (Data0&0x70)>>4;
1477:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data1;
1478:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1479:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1480:../uvc.c      **** 							CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
1481:../uvc.c      **** 
1482:../uvc.c      **** 			 	 		 }
1483:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1484:../uvc.c      **** 						 sendData1 = Data1;//glEp0Buffer[1];
1485:../uvc.c      **** 						 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, sen
1486:../uvc.c      **** 				 		 break;
1487:../uvc.c      **** 				 		 */
1488:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1489:../uvc.c      **** 				 		 /*
1490:../uvc.c      **** 					     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1491:../uvc.c      **** 					     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1492:../uvc.c      **** 					     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1493:../uvc.c      **** 
1494:../uvc.c      **** 						 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1495:../uvc.c      **** 								 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1496:../uvc.c      **** 						 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1497:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1498:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1499:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1500:../uvc.c      **** 			 	 		 }else{
1501:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1502:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1503:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1504:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1505:../uvc.c      **** 			 	 		 }
1506:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1507:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1508:../uvc.c      **** 				 		 break;
1509:../uvc.c      **** 				 		 */
1510:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1511:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1512:../uvc.c      **** 			 	 		 /*
1513:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1514:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1515:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1516:../uvc.c      **** 			 	 		 }else{
1517:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1518:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1519:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1520:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1521:../uvc.c      **** 			 	 		 }
1522:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1523:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1524:../uvc.c      **** 						 break;
1525:../uvc.c      **** 						 */
1526:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1527:../uvc.c      **** 			 	 		 /*
1528:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1529:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1530:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1531:../uvc.c      **** 			 	 		 }else{
1532:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1533:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1534:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1535:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1536:../uvc.c      **** 			 	 		 }
1537:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1538:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1539:../uvc.c      **** 						 break;
1540:../uvc.c      **** 						 */
1541:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1542:../uvc.c      **** 			 	 		 /*
1543:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1544:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1545:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1546:../uvc.c      **** 			 	 		 }else{
1547:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1548:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1549:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1550:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1551:../uvc.c      **** 			 	 		 }
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1553:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1554:../uvc.c      **** 						 break;
1555:../uvc.c      **** 						 */
1556:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1557:../uvc.c      **** 			 	 		 /*
1558:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1559:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1560:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1561:../uvc.c      **** 			 	 		 }else{
1562:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1563:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1564:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1565:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1566:../uvc.c      **** 			 	 		 }
1567:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1568:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1569:../uvc.c      **** 						 break;
1570:../uvc.c      **** 						 */
1571:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1572:../uvc.c      **** 			 	 		 /*
1573:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1574:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1575:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1576:../uvc.c      **** 			 	 		 }else{
1577:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1578:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1579:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1580:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1581:../uvc.c      **** 			 	 		 }
1582:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1583:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1584:../uvc.c      **** 						 break;
1585:../uvc.c      **** 						 */
1586:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1587:../uvc.c      **** 			 	 		 /*
1588:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1589:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1590:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1591:../uvc.c      **** 			 	 		 }else{
1592:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1593:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1594:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1595:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1596:../uvc.c      **** 			 	 		 }
1597:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1598:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1599:../uvc.c      **** 						 break;
1600:../uvc.c      **** 						 */
1601:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1602:../uvc.c      **** 			 	 		 /*
1603:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1604:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1605:../uvc.c      **** 							 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1606:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;//ext_control array;
1607:../uvc.c      **** 							 glEp0Buffer[3] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1608:../uvc.c      **** 			 	 		 }else{
1609:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1610:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1611:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1612:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1613:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1614:../uvc.c      **** 			 	 		 }
1615:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1616:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1617:../uvc.c      **** 						 break;
1618:../uvc.c      **** 						 */
1619:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1620:../uvc.c      **** 			 	 		 /*
1621:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1622:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1623:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1624:../uvc.c      **** 			 	 		 }else{
1625:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1626:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1627:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1628:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1629:../uvc.c      **** 			 	 		 }
1630:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1631:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1632:../uvc.c      **** 						 break;
1633:../uvc.c      **** 			 	 		  */
1634:../uvc.c      **** 					 case ExtExRefCtlID10:
1635:../uvc.c      **** 			 	 	 default:
1636:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1637:../uvc.c      **** 			 	 			 if(Len == 2)
1638:../uvc.c      **** 			 	 			 {
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1641:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1642:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1643:../uvc.c      **** 			 	 			 }else if(Len == 4){
1644:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1645:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1646:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1647:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1648:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1649:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1650:../uvc.c      **** 			 	 			 }
1651:../uvc.c      **** 			 	 		 }else{
1652:../uvc.c      **** 			 	 			 if(Len == 2)
1653:../uvc.c      **** 			 	 			 {
1654:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1655:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1656:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1657:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1658:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1659:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1660:../uvc.c      **** 			 	 			 }else if(Len == 4){
1661:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1662:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1663:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1664:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1665:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1666:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1667:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1668:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1669:../uvc.c      **** 			 	 			 }
1670:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1671:../uvc.c      **** 			 	 		 }
1672:../uvc.c      **** 			 	 		 break;
1673:../uvc.c      **** 			 	 }
1674:../uvc.c      **** 		 	 }
1675:../uvc.c      **** 		 	 else{
1676:../uvc.c      **** 				 switch(CtrlID)
1677:../uvc.c      **** 				 {
1678:../uvc.c      **** 					 case BrgtCtlID1:
1679:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1680:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1681:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1682:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1683:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1684:../uvc.c      **** 						 }else{
1685:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1686:../uvc.c      **** 						 }
1687:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1688:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1689:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1690:../uvc.c      **** 						 */
1691:../uvc.c      **** 						 if(curFlag[CtrlID]){
1692:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1693:../uvc.c      **** 						 }else{
1694:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1695:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1696:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1697:../uvc.c      **** 						 }
1698:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1699:../uvc.c      **** 						  if(Data0&0x80){
1700:../uvc.c      **** 							  Data0 = ~Data0;
1701:../uvc.c      **** 						  }else{
1702:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1703:../uvc.c      **** 						  }
1704:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1705:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1706:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1707:../uvc.c      **** 						 break;
1708:../uvc.c      **** 					 case HueCtlID5:
1709:../uvc.c      **** 						 if(curFlag[CtrlID]){
1710:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1711:../uvc.c      **** 						 }else{
1712:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1713:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1714:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1715:../uvc.c      **** 						 }
1716:../uvc.c      **** 
1717:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1718:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1719:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1720:../uvc.c      **** 						 break;
1721:../uvc.c      **** 					 case MFreqCtlID4:
1722:../uvc.c      **** 
1723:../uvc.c      **** 						 if(curFlag[CtrlID]){
1724:../uvc.c      **** 
1725:../uvc.c      **** 							 if(is60Hz)
1726:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1727:../uvc.c      **** 							 else
1728:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1729:../uvc.c      **** 
1730:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1731:../uvc.c      **** 						 }else{
1732:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1733:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1734:../uvc.c      **** 							glEp0Buffer[0]++;
1735:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1736:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1737:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1738:../uvc.c      **** 						 }
1739:../uvc.c      **** 
1740:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1741:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1742:../uvc.c      **** 						 break;
1743:../uvc.c      **** 					 case WBTLevCtlID11:
1744:../uvc.c      **** 						 if(curFlag[CtrlID]){
1745:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1746:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1747:../uvc.c      **** 						 }else{
1748:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1749:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1750:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1751:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1752:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1753:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1754:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1755:../uvc.c      **** 						 }
1756:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1757:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1758:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1759:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1760:../uvc.c      **** 						 break;
1761:../uvc.c      **** 					 case BLCCtlID0:
1762:../uvc.c      **** 						 /*
1763:../uvc.c      **** 						 if(curFlag[CtrlID]){
1764:../uvc.c      **** 							 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1765:../uvc.c      **** 							 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1766:../uvc.c      **** 						 }else{
1767:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1768:../uvc.c      **** 							glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1769:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1770:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1771:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1772:../uvc.c      **** 						 }
1773:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1774:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1775:../uvc.c      **** 						 break;
1776:../uvc.c      **** 						 */
1777:../uvc.c      **** 					 case ShapCtlID7:
1778:../uvc.c      **** 						 /*
1779:../uvc.c      **** 						 if(curFlag[CtrlID]){
1780:../uvc.c      **** 							 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1781:../uvc.c      **** 							 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1782:../uvc.c      **** 						 }else{
1783:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1784:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1785:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1786:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1787:../uvc.c      **** 						 }
1788:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1789:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1790:../uvc.c      **** 						 break;
1791:../uvc.c      **** 						 */
1792:../uvc.c      **** 					 case ConsCtlID2:
1793:../uvc.c      **** 						 /*
1794:../uvc.c      **** 						 if(curFlag[CtrlID]){
1795:../uvc.c      **** 							 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1796:../uvc.c      **** 							 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1797:../uvc.c      **** 						 }else{
1798:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1799:../uvc.c      **** 							CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1800:../uvc.c      **** 							glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1801:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1802:../uvc.c      **** 						 }
1803:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1804:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1805:../uvc.c      **** 						 break;
1806:../uvc.c      **** 						 */
1807:../uvc.c      **** 					 case WBTMdCtlID9:
1808:../uvc.c      **** 						 /*
1809:../uvc.c      **** 						 if(curFlag[CtrlID]){
1810:../uvc.c      **** 							 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1811:../uvc.c      **** 							 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1812:../uvc.c      **** 							 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1813:../uvc.c      **** 						 }else{
1814:../uvc.c      **** 							glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1815:../uvc.c      **** 							CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1816:../uvc.c      **** 							glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1817:../uvc.c      **** 							glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1818:../uvc.c      **** 
1819:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1820:../uvc.c      **** 						 }
1821:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1822:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1823:../uvc.c      **** 						 break;
1824:../uvc.c      **** 						 */
1825:../uvc.c      **** 					 case SaturCtlID6:
1826:../uvc.c      **** 					 default:
1827:../uvc.c      **** 						 if(curFlag[CtrlID]){
1828:../uvc.c      **** 			 	 			 if(Len == 2)
1829:../uvc.c      **** 			 	 			 {
1830:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1831:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1832:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1833:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1834:../uvc.c      **** 			 	 			 }else if(Len == 4){
1835:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1836:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1837:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1838:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1839:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1840:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1841:../uvc.c      **** 			 	 			 }
1842:../uvc.c      **** 			 	 		 }else{
1843:../uvc.c      **** 			 	 			 if(Len == 2)
1844:../uvc.c      **** 			 	 			 {
1845:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1846:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1847:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1848:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1849:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1850:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1851:../uvc.c      **** 			 	 			 }else if(Len == 4){
1852:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1853:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1854:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1855:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1856:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1857:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1858:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1859:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1860:../uvc.c      **** 			 	 			 }
1861:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1862:../uvc.c      **** 			 	 		 }
1863:../uvc.c      **** 						 break;
1864:../uvc.c      **** 				 }
1865:../uvc.c      **** 		 	 }
1866:../uvc.c      **** 
1867:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1868:../uvc.c      **** 
1869:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1870:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1871:../uvc.c      **** //#endif
1872:../uvc.c      **** 			  break;
1873:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1874:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1875:../uvc.c      **** 		 		 if(Len == 2){
1876:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1877:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1878:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1879:../uvc.c      **** 		 		 }else //if(Len == 4)
1880:../uvc.c      **** 		 		 {
1881:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1882:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1883:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1884:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1885:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1886:../uvc.c      **** 				 }
1887:../uvc.c      **** 			 }else{
1888:../uvc.c      **** 			 	 if(Len ==2){
1889:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1890:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1891:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1892:../uvc.c      **** 				 }else{
1893:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1894:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1895:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1896:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1897:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1898:../uvc.c      **** 				 }
1899:../uvc.c      **** 			 }
1900:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1901:../uvc.c      **** 		 	 if(Len == 2){
1902:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1903:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1904:../uvc.c      **** 		 	 }else{
1905:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1906:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1907:../uvc.c      **** 			  }
1908:../uvc.c      **** 			  break;
1909:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1910:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1911:../uvc.c      **** 		 		 if(Len == 2){
1912:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1913:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1914:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1915:../uvc.c      **** 		 		 }else //if(Len == 4)
1916:../uvc.c      **** 		 		 {
1917:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1918:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1919:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1920:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1921:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1922:../uvc.c      **** 				 }
1923:../uvc.c      **** 			 }else{
1924:../uvc.c      **** 			 	 if(Len ==2){
1925:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1926:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1927:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1928:../uvc.c      **** 				 }else{
1929:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1930:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1931:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1932:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1933:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1934:../uvc.c      **** 				 }
1935:../uvc.c      **** 			 }
1936:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1937:../uvc.c      **** 				  if(Len == 2){
1938:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1939:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1940:../uvc.c      **** 				  }else{
1941:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1942:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1943:../uvc.c      **** 				  }
1944:../uvc.c      **** 				  break;
1945:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1946:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1947:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1948:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1949:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1950:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1951:../uvc.c      **** 		 	 }
1952:../uvc.c      **** 		 	 else{
1953:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1954:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1955:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1956:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1957:../uvc.c      **** 		 	 }
1958:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1959:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1960:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1961:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1962:../uvc.c      **** 			  break;
1963:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1964:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1965:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1966:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1967:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1968:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1969:../uvc.c      **** 		 	 }
1970:../uvc.c      **** 		 	 else{
1971:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1972:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1973:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1974:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1975:../uvc.c      **** 		 	 }
1976:../uvc.c      **** 		 	 Len = 1;
1977:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1978:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1979:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1980:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1981:../uvc.c      **** 		 	 break;
1982:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1983:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1984:../uvc.c      **** 		 		 if(Len == 2){
1985:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1986:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1987:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1988:../uvc.c      **** 		 		 }else //if(Len == 4)
1989:../uvc.c      **** 		 		 {
1990:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1991:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1992:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1993:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1994:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1995:../uvc.c      **** 				 }
1996:../uvc.c      **** 			 }else{
1997:../uvc.c      **** 			 	 if(Len ==2){
1998:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1999:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
2000:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
2001:../uvc.c      **** 				 }else{
2002:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
2003:../uvc.c      **** 					 glEp0Buffer[1] = 0;
2004:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
2005:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2006:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
2007:../uvc.c      **** 				 }
2008:../uvc.c      **** 			 }
2009:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2010:../uvc.c      **** 		 	 if(Len == 2){
2011:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
2012:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
2013:../uvc.c      **** 		 	 }else{
2014:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
2015:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
2016:../uvc.c      **** 		 	 }
2017:../uvc.c      **** 		 	 break;
2018:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2019:../uvc.c      **** 
2020:../uvc.c      ****  // set request control will be removed.
2021:../uvc.c      **** /*********************************************************/
2022:../uvc.c      **** #if 0 //old implementation
2023:../uvc.c      **** 
2024:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2025:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2026:../uvc.c      **** 			  getData = glEp0Buffer[0];
2027:../uvc.c      **** 			  getData1 = glEp0Buffer[2];
2028:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2029:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, glE
2030:../uvc.c      **** #endif
2031:../uvc.c      **** 			  switch(CtrlID)
2032:../uvc.c      **** 				 {
2033:../uvc.c      **** 					 case ExtShutCtlID0:
2034:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2035:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
2036:../uvc.c      **** 						 //devAdd = EXTShutter.DeviceAdd;
2037:../uvc.c      **** 						 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
2038:../uvc.c      **** #if 1	// register setting directly
2039:../uvc.c      **** 					     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vie
2040:../uvc.c      **** 					     {
2041:../uvc.c      **** 					    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
2042:../uvc.c      **** 					    	 dataIdx = 0;
2043:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2044:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
2045:../uvc.c      **** 							 dataIdx++;
2046:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2047:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2048:../uvc.c      **** 					     }
2049:../uvc.c      **** 					     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
2050:../uvc.c      **** 					    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
2051:../uvc.c      **** 					     break;
2052:../uvc.c      **** #else	// old fashion
2053:../uvc.c      **** 						 if(Data0 == 0){//set exposure mode auto
2054:../uvc.c      **** 							 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
2055:../uvc.c      **** 								 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
2056:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
2057:../uvc.c      **** 								 }else{
2058:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
2059:../uvc.c      **** 								 }
2060:../uvc.c      **** 							 }
2061:../uvc.c      **** 						 }else{
2062:../uvc.c      **** 							 Data1 = Data0 - 1;
2063:../uvc.c      **** 							 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
2064:../uvc.c      **** 								 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
2065:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
2066:../uvc.c      **** 								 }else{
2067:../uvc.c      **** 									 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
2068:../uvc.c      **** 								 }
2069:../uvc.c      **** 							 }
2070:../uvc.c      **** 							 if(Data1 < 8){
2071:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
2072:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
2073:../uvc.c      **** 							 }else{
2074:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
2075:../uvc.c      **** 								 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
2076:../uvc.c      **** 							 }
2077:../uvc.c      **** 						 }
2078:../uvc.c      **** 						 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
2079:../uvc.c      **** 						 dataIdx = 0;
2080:../uvc.c      **** 						 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
2081:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2082:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
2083:../uvc.c      **** 						 if(AxMode){
2084:../uvc.c      **** 							 dataIdx++;
2085:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
2086:../uvc.c      **** 							 dataIdx++;
2087:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustmen
2088:../uvc.c      **** 						 }
2089:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2090:../uvc.c      **** 						 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlPa
2091:../uvc.c      **** 						 break;
2092:../uvc.c      **** #endif
2093:../uvc.c      **** 					 case ExtAexModCtlID9://exposure&AGC 4bytes standard operation!!!
2094:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2095:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2096:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2097:../uvc.c      **** 					     dataIdx = 0;
2098:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2099:../uvc.c      **** 						 if(EXTAexModGainlev.UVCCurVLo != getData)
2100:../uvc.c      **** 						 {
2101:../uvc.c      **** 							 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlP
2102:../uvc.c      **** 							 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2103:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2104:../uvc.c      **** 							 /*
2105:../uvc.c      **** 							 dataIdx++;
2106:../uvc.c      **** 							 if(getData == 1 || getData == 3){
2107:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shut
2108:../uvc.c      **** 								 dataIdx++;
2109:../uvc.c      **** 							 }else{
2110:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
2111:../uvc.c      **** 								 dataIdx++;
2112:../uvc.c      **** 							 }
2113:../uvc.c      **** 							 */
2114:../uvc.c      **** 						 }
2115:../uvc.c      **** 						 if(EXTAexModGainlev.UVCCurVHi != getData1){
2116:../uvc.c      **** 							 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
2117:../uvc.c      **** 							 if(getData == 2 || getData == 3){
2118:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
2119:../uvc.c      **** 							 }
2120:../uvc.c      **** 						 }
2121:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2122:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2123:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2124:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getDa
2125:../uvc.c      **** 						 break;
2126:../uvc.c      **** 
2127:../uvc.c      **** 					 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
2128:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2129:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2130:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2131:../uvc.c      **** 					     dataIdx = 0;
2132:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2133:../uvc.c      **** 						 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2134:../uvc.c      **** 						 {
2135:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2136:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2137:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2138:../uvc.c      **** 							 dataIdx++;
2139:../uvc.c      **** 						 }
2140:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
2141:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
2142:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
2143:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
2144:../uvc.c      **** 								 dataIdx++;
2145:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
2146:../uvc.c      **** 							 }
2147:../uvc.c      **** 						 }
2148:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2149:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2150:../uvc.c      **** 						 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2151:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, get
2152:../uvc.c      **** 						 break;
2153:../uvc.c      **** 
2154:../uvc.c      **** 						 /* the exposure hysteresis to gamma correction */
2155:../uvc.c      **** 					 case Ext1ExHysterCtlID7:    // exposure hysteresis level (5MP b/w)
2156:../uvc.c      **** 					 case Ext1ExCtrlSpeedCtlID8:    // exposure control speed level (5MP b/w)
2157:../uvc.c      **** 					 case Ext1EnhanceModeCtlID9:    // edge enhancement mode (5MP b/w)
2158:../uvc.c      **** 					 case Ext1EnhanceGainCtlID10:    // edge enhancement gain level (5MP b/w)
2159:../uvc.c      **** 					 case Ext1GammaCorCtlID14:   // Gamma correction (5MP b/w)
2160:../uvc.c      **** 
2161:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2162:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2163:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2164:../uvc.c      **** 					     dataIdx = 0;
2165:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2166:../uvc.c      **** 						 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2167:../uvc.c      **** 						 {
2168:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2169:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2170:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2171:../uvc.c      **** 							 dataIdx++;
2172:../uvc.c      **** 						 }
2173:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
2174:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
2175:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
2176:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
2177:../uvc.c      **** 								 //dataIdx++;
2178:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //shutter level
2179:../uvc.c      **** 							 }
2180:../uvc.c      **** 						 }
2181:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2182:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2183:../uvc.c      **** 						 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2184:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, get
2185:../uvc.c      **** 						 break;
2186:../uvc.c      **** 
2187:../uvc.c      **** 					 case Ext1EnhanceStarEndCtlID11: // edge enhancement start/end level (5MP b/w) 4bytes
2188:../uvc.c      **** 					 case Ext12DNRGainEnblCtlID12:  // 2D NR gain enable/gain level (5MP b/w) 4bytes
2189:../uvc.c      **** 					 case Ext12DNRGainStarEndCtlID13:  // 2D NR gain start/end level (5MP b/w) 4bytes
2190:../uvc.c      **** 					     //RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2191:../uvc.c      **** 					     //RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2192:../uvc.c      **** 					     //devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
2193:../uvc.c      **** 					     dataIdx = 0;
2194:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2195:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
2196:../uvc.c      **** 						 {
2197:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC win
2198:../uvc.c      **** 							 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
2200:../uvc.c      **** 							 /*
2201:../uvc.c      **** 							 dataIdx++;
2202:../uvc.c      **** 							 if(getData == 1 || getData == 3){
2203:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shut
2204:../uvc.c      **** 								 dataIdx++;
2205:../uvc.c      **** 							 }else{
2206:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
2207:../uvc.c      **** 								 dataIdx++;
2208:../uvc.c      **** 							 }
2209:../uvc.c      **** 							 */
2210:../uvc.c      **** 						 }
2211:../uvc.c      **** 						 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != getData1){
2212:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
2213:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
2214:../uvc.c      **** 						 }
2215:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2216:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2217:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2218:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, EXTShutter.U
2219:../uvc.c      **** 						 break;
2220:../uvc.c      **** 
2221:../uvc.c      **** 					 case ExtCamMCtlID12:
2222:../uvc.c      **** 						 dataIdx = 0;
2223:../uvc.c      **** 						 if(Data0 <= 3){
2224:../uvc.c      **** 							 CamMode = 0; //set 1080p flag
2225:../uvc.c      **** 							 Data1 = Data0;
2226:../uvc.c      **** 						 }else{
2227:../uvc.c      **** 							 CamMode = 1; //set 720p flag
2228:../uvc.c      **** 							 Data1 = Data0-4;
2229:../uvc.c      **** 						 }
2230:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2231:../uvc.c      **** 						 CtrlParArry[BLCIndex][13] = Data1;
2232:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2233:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2234:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2235:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2236:../uvc.c      **** 						 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParArr
2237:../uvc.c      **** 						 break;
2238:../uvc.c      **** 					 case ExtSensorParCtlID14://TODO
2239:../uvc.c      **** 						 dataIdx = 0;
2240:../uvc.c      **** 						 if(Data0 == 0){ //set default sensor parameters.
2241:../uvc.c      **** 							 Data0 = 1;
2242:../uvc.c      **** 						 }else{ //save current sensor parameters.
2243:../uvc.c      **** 							 Data0 = 0;
2244:../uvc.c      **** 						 }
2245:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2246:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2247:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2248:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2249:../uvc.c      **** 						 break;
2250:../uvc.c      **** 					 case ExtI2CCtlID15:
2251:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
2252:../uvc.c      **** 				 			I2CCMDArry[idx] = glEp0Buffer[idx];
2253:../uvc.c      **** 				 		 }
2254:../uvc.c      **** 				 		I2CCmdHandler();
2255:../uvc.c      **** 						 break;
2256:../uvc.c      **** 					 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (0
2257:../uvc.c      **** 					     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
2258:../uvc.c      **** 					     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
2259:../uvc.c      **** 						 devAdd = EXTBLCWinPos.DeviceAdd;
2260:../uvc.c      **** 
2261:../uvc.c      **** 						 dataIdx = 0;
2262:../uvc.c      **** #if 0 //seperate version
2263:../uvc.c      **** 						 getData = Data0&0xF; //get LSB H-Pos.
2264:../uvc.c      **** 						 getData1 = Data0>>4; //get MSB V-Pos.
2265:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2266:../uvc.c      **** 						 if(getData1&0x8){//enable BLD window
2267:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
2268:../uvc.c      **** 						 }else{ //disable BLD window
2269:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
2270:../uvc.c      **** 						 }
2271:../uvc.c      **** 						 getData1 = getData1&0x7; //mask bit7 ~ bit3/
2272:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
2273:../uvc.c      **** 						 dataIdx++;
2274:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
2275:../uvc.c      **** 						 dataIdx++;
2276:../uvc.c      **** 						 getData = Data1&0xf; //get LSB H-size.
2277:../uvc.c      **** 						 getData1 = Data1>>4; //get MSB V-size.
2278:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
2279:../uvc.c      **** 						 dataIdx++;
2280:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2281:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2282:../uvc.c      **** #else //combination version
2283:../uvc.c      **** 						 //Data0 = Data0&0x7F; //mask window show flag bit.
2284:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2285:../uvc.c      **** 					     /* end test */
2286:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2287:../uvc.c      **** 						 dataIdx++;
2288:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2289:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2290:../uvc.c      **** 						 getData1 = Data1;
2291:../uvc.c      **** #endif
2292:../uvc.c      **** 						 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
2293:../uvc.c      **** 						 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2294:../uvc.c      **** 						 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2295:../uvc.c      **** 						 break;
2296:../uvc.c      **** 					 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
2297:../uvc.c      **** 					     //RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
2298:../uvc.c      **** 					     //RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
2299:../uvc.c      **** 						 //devAdd = EXTBLCWeight.DeviceAdd;
2300:../uvc.c      **** 
2301:../uvc.c      **** 						 dataIdx = 0;
2302:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2303:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
2304:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2305:../uvc.c      **** 						 EXTBLCWeight.UVCCurVLo = Data0;
2306:../uvc.c      **** 						 EXTBLCWeight.AvailableF = CyTrue;
2307:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][13] = Data0;
2308:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2309:../uvc.c      **** 						 break;
2310:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
2311:../uvc.c      **** 						 dataIdx = 0;
2312:../uvc.c      **** 						 ExUCtrlParArry[locCtrlID][13] = Data0;
2313:../uvc.c      **** 						 if(Data0 == 1){
2314:../uvc.c      **** 							 Data0 = PUCBLC.UVCCurVLo|0x80;
2315:../uvc.c      **** 						 }else{
2316:../uvc.c      **** 							 Data0 = PUCBLC.UVCCurVLo&0x7f;
2317:../uvc.c      **** 						 }
2318:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2319:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
2320:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2321:../uvc.c      **** 						 //ExUCtrlParArry[locCtrlID][13] = Data0;
2322:../uvc.c      **** 						 ExUCtrlParArry[locCtrlID][16] = CyTrue;
2323:../uvc.c      **** 						 break;
2324:../uvc.c      **** 			  	  	 case BrgtCtlID1:
2325:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
2326:../uvc.c      **** 						 dataIdx = 0;
2327:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2328:../uvc.c      **** 						  /****** double check the register0 Data1 ******/
2329:../uvc.c      **** 						  if(Data0&0x80){
2330:../uvc.c      **** 							  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2331:../uvc.c      **** 						  }else{
2332:../uvc.c      **** 							  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2333:../uvc.c      **** 						  }
2334:../uvc.c      **** 						 Data1 |= ~0x03;
2335:../uvc.c      **** 						 Data1 &= 0xC7;
2336:../uvc.c      **** 					  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2337:../uvc.c      **** 					  	 dataIdx++;
2338:../uvc.c      **** 
2339:../uvc.c      **** 						 Data0 = (Data0 << 2);
2340:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2341:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2342:../uvc.c      **** 
2343:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2344:../uvc.c      **** 						 CtrlParArry[CtrlID][14] = Data1;
2345:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2346:../uvc.c      **** #endif
2347:../uvc.c      **** 						 dataIdx = 0;
2348:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2349:../uvc.c      **** 						  /****** double check the register0 Data1 ******/
2350:../uvc.c      **** 						  if(Data0&0x80){
2351:../uvc.c      **** 							  Data0 = Data0 - 0x80;
2352:../uvc.c      **** 						  }else{
2353:../uvc.c      **** 							  Data0 = ~Data0;
2354:../uvc.c      **** 						  }
2355:../uvc.c      **** 					  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2356:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2357:../uvc.c      **** 
2358:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2359:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2360:../uvc.c      **** 
2361:../uvc.c      **** 
2362:../uvc.c      **** 						 break;
2363:../uvc.c      **** 					 case HueCtlID5:  //mapping to hue control registers
2364:../uvc.c      **** 						 dataIdx = 0;
2365:../uvc.c      **** 
2366:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2367:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2368:../uvc.c      **** 						 dataIdx++;
2369:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2370:../uvc.c      **** 						 dataIdx++;
2371:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2372:../uvc.c      **** 						 dataIdx++;
2373:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2374:../uvc.c      **** 						 dataIdx++;
2375:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2376:../uvc.c      **** 						 dataIdx++;
2377:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2378:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2379:../uvc.c      **** 
2380:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
2381:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2382:../uvc.c      **** 						 break;
2383:../uvc.c      **** 					 case SaturCtlID6:
2384:../uvc.c      **** 						 dataIdx = 0;
2385:../uvc.c      **** 						 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
2386:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2387:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2388:../uvc.c      **** 						 dataIdx++;
2389:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
2390:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2391:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2392:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2393:../uvc.c      **** 						 break;
2394:../uvc.c      **** 
2395:../uvc.c      **** 					 case WBTLevCtlID11:
2396:../uvc.c      **** 						 Data0 = glEp0Buffer[0]; //blue
2397:../uvc.c      **** 						 Data1 = glEp0Buffer[2]; //red
2398:../uvc.c      **** 						 dataIdx = 0;
2399:../uvc.c      **** 
2400:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2401:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2402:../uvc.c      **** 						 dataIdx++;
2403:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2404:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2405:../uvc.c      **** 
2406:../uvc.c      **** 						 WBMenuCmpArry[0] = Data0;//using for blue part
2407:../uvc.c      **** 						 WBMenuCmpArry[2] = Data1;//using for red part
2408:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2409:../uvc.c      **** 						 break;
2410:../uvc.c      **** 					 case MFreqCtlID4:
2411:../uvc.c      **** 						 dataIdx = 0;
2412:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2413:../uvc.c      **** 						 Data0 = Data0 - 1;
2414:../uvc.c      **** 						 is60Hz = Data0;
2415:../uvc.c      **** 						 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2416:../uvc.c      **** 						 {
2417:../uvc.c      **** 							 Data0 = 0;  // 50Hz (PAL)
2418:../uvc.c      **** 							 is60Hz = CyFalse;
2419:../uvc.c      **** 						 }
2420:../uvc.c      **** 						 else if(Data0 >2)
2421:../uvc.c      **** 						 {
2422:../uvc.c      **** 							 Data0 = 1;  // 60Hz (NTSC)
2423:../uvc.c      **** 							 is60Hz = CyTrue;
2424:../uvc.c      **** 						 }
2425:../uvc.c      **** 						 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2426:../uvc.c      **** 						 if (gpif_initialized == CyTrue)
2427:../uvc.c      **** 						 {
2428:../uvc.c      **** 							 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2429:../uvc.c      **** 		                       switch (setRes)
2430:../uvc.c      **** 		                         {
2431:../uvc.c      **** 		                         	case 1: //1944
2432:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_W
2433:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2434:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz?
2435:../uvc.c      **** 		                         		break;
2436:../uvc.c      **** 		                         	case 2: //1080
2437:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_W
2438:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2439:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz?
2440:../uvc.c      **** 		                         		break;
2441:../uvc.c      **** 		                         	case 3: //720
2442:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2
2443:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2444:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60H
2445:../uvc.c      **** 		                         		break;
2446:../uvc.c      **** 		                         	case 4: //VGA
2447:../uvc.c      **** 		                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2
2448:../uvc.c      **** 		                         		CyU3PThreadSleep(500);
2449:../uvc.c      **** 		                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60H
2450:../uvc.c      **** 		                         	default:
2451:../uvc.c      **** 		                         		break;
2452:../uvc.c      **** 		                         }
2453:../uvc.c      **** 							 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2454:../uvc.c      **** 						 }
2455:../uvc.c      **** 
2456:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2457:../uvc.c      **** 						 break;
2458:../uvc.c      **** 				 	 case BLCCtlID0:
2459:../uvc.c      **** 					     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2460:../uvc.c      **** 					     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2461:../uvc.c      **** 					     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
2462:../uvc.c      **** 					     dataIdx = 0;
2463:../uvc.c      **** 
2464:../uvc.c      **** 						 //CtrlParArry[CtrlID][13] = Data0;
2465:../uvc.c      **** 						 //CtrlParArry[CtrlID][16] = CyTrue;
2466:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2467:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2468:../uvc.c      **** 
2469:../uvc.c      **** 						 if(CamMode == 1) //mode 720p
2470:../uvc.c      **** 						 {
2471:../uvc.c      **** 							 if(Data0 < 3){
2472:../uvc.c      **** 				 				 Data0 += 4;
2473:../uvc.c      **** 				 			 }else{
2474:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, g
2475:../uvc.c      **** 								Data0 = 4; //set to default.
2476:../uvc.c      **** 				 			 }
2477:../uvc.c      **** 				 		 }
2478:../uvc.c      **** 						 //CtrlParArry[CamModeIndex][13] = Data0;
2479:../uvc.c      **** 						 dataIdx = 0;
2480:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2481:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2482:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2483:../uvc.c      **** 
2484:../uvc.c      **** 				 		 break;
2485:../uvc.c      **** 				 	 case ShapCtlID7:
2486:../uvc.c      **** 					     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
2487:../uvc.c      **** 					     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
2488:../uvc.c      **** 					     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
2489:../uvc.c      **** 					     dataIdx = 0;
2490:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2491:../uvc.c      **** 						 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2492:../uvc.c      **** 						 if(Data0 != 0){
2493:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2494:../uvc.c      **** #ifdef COLOR
2495:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement value
2496:../uvc.c      **** #else
2497:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2498:../uvc.c      **** 							 dataIdx++;
2499:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement value
2500:../uvc.c      **** #endif
2501:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2502:../uvc.c      **** 						 }else{
2503:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2504:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2505:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2506:../uvc.c      **** 
2507:../uvc.c      **** 						 }
2508:../uvc.c      **** 						 break;
2509:../uvc.c      **** 					 case ExtExRefCtlID10:
2510:../uvc.c      **** 					 case ConsCtlID2:
2511:../uvc.c      **** 						 dataIdx = 0;
2512:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2513:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2514:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2515:../uvc.c      **** 
2516:../uvc.c      **** 						 CtrlParArry[ConsCtlID2][13] = Data0;
2517:../uvc.c      **** 						 CtrlParArry[ConsCtlID2][16] = CyTrue;
2518:../uvc.c      **** 						 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same control
2519:../uvc.c      **** 						 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
2520:../uvc.c      **** 
2521:../uvc.c      **** 						 break;
2522:../uvc.c      **** 					 default:
2523:../uvc.c      **** 						 dataIdx = 0;
2524:../uvc.c      **** 
2525:../uvc.c      **** 						 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2526:../uvc.c      **** 						 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2527:../uvc.c      **** 						 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2528:../uvc.c      **** 
2529:../uvc.c      **** 						 CtrlParArry[CtrlID][13] = Data0;
2530:../uvc.c      **** 						 CtrlParArry[CtrlID][16] = CyTrue;
2531:../uvc.c      **** 						 break;
2532:../uvc.c      **** 				 }
2533:../uvc.c      **** 
2534:../uvc.c      **** #endif
2535:../uvc.c      **** /*********************************************************/
2536:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2537:../uvc.c      **** 				  glEp0Buffer, &readCount);
2538:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
2539:../uvc.c      **** 			   {
2540:../uvc.c      **** 				 if(Len == 2){
2541:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
2542:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
2543:../uvc.c      **** 				 }else{
2544:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
2545:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
2546:../uvc.c      **** 				 }
2547:../uvc.c      **** 				 dataIdx = 0;
2548:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
2549:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
2550:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
2551:../uvc.c      **** 					 switch(CtrlID)
2552:../uvc.c      **** 					 {
2553:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
2554:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
2555:../uvc.c      **** 							 if(Data0 == 1){
2556:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
2557:../uvc.c      **** 							 }else{
2558:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
2559:../uvc.c      **** 							 }
2560:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2561:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
2562:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2563:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2564:../uvc.c      **** 							 break;
2565:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
2566:../uvc.c      **** 	#if 0 // not be used
2567:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
2568:../uvc.c      **** 
2569:../uvc.c      **** 							 if(CamMode == 1){//720p
2570:../uvc.c      **** 								if(sendData >= 3){
2571:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2572:../uvc.c      **** 									sendData = 0; //set back to default
2573:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
2574:../uvc.c      **** 								}
2575:../uvc.c      **** 								sendData += 4;
2576:../uvc.c      **** 							 }
2577:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2578:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
2579:../uvc.c      **** 							 glEp0Buffer[1] = 0;
2580:../uvc.c      **** 	#endif
2581:../uvc.c      **** 							 break;
2582:../uvc.c      **** 					 	 case ExtI2CCtlID15:
2583:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
2584:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
2585:../uvc.c      **** 					 		 }
2586:../uvc.c      **** 					 		 I2CCmdHandler();
2587:../uvc.c      **** 							 break;
2588:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
2589:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2590:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2591:../uvc.c      **** 							 {
2592:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wind
2593:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
2594:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2595:../uvc.c      **** 							 }
2596:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2597:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2598:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
2599:../uvc.c      **** 									 dataIdx++;
2600:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
2601:../uvc.c      **** 								 }
2602:../uvc.c      **** 							 }
2603:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2604:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2605:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2606:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
2607:../uvc.c      **** 							 break;
2608:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
2609:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
2610:../uvc.c      **** 	#if 1	// register setting directly
2611:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vi
2612:../uvc.c      **** 						     {
2613:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
2614:../uvc.c      **** 						    	 dataIdx = 0;
2615:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2616:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
2617:../uvc.c      **** 								 dataIdx++;
2618:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2619:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2620:../uvc.c      **** 						     }
2621:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
2622:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
2623:../uvc.c      **** 						     break;
2624:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
2625:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2626:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
2627:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2628:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
2629:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
2630:../uvc.c      **** 									 dataIdx++;
2631:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
2632:../uvc.c      **** 								 }
2633:../uvc.c      **** 							 }
2634:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
2635:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2636:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
2637:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
2638:../uvc.c      **** 							 break;
2639:../uvc.c      **** 
2640:../uvc.c      **** 	#else	// old fashion
2641:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
2642:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
2643:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
2644:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
2645:../uvc.c      **** 									 }else{
2646:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
2647:../uvc.c      **** 									 }
2648:../uvc.c      **** 								 }
2649:../uvc.c      **** 							 }else{
2650:../uvc.c      **** 								 Data1 = Data0 - 1;
2651:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
2652:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
2653:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
2654:../uvc.c      **** 									 }else{
2655:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
2656:../uvc.c      **** 									 }
2657:../uvc.c      **** 								 }
2658:../uvc.c      **** 								 if(Data1 < 8){
2659:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
2660:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
2661:../uvc.c      **** 								 }else{
2662:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
2663:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
2664:../uvc.c      **** 								 }
2665:../uvc.c      **** 							 }
2666:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
2667:../uvc.c      **** 							 dataIdx = 0;
2668:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
2669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2670:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
2671:../uvc.c      **** 							 if(AxMode){
2672:../uvc.c      **** 								 dataIdx++;
2673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
2674:../uvc.c      **** 								 dataIdx++;
2675:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
2676:../uvc.c      **** 							 }
2677:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2678:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
2679:../uvc.c      **** 							 break;
2680:../uvc.c      **** 	#endif
2681:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
2682:../uvc.c      **** 	#if 0 //seperate version
2683:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
2684:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
2685:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2686:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
2687:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
2688:../uvc.c      **** 							 }else{ //disable BLD window
2689:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
2690:../uvc.c      **** 							 }
2691:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
2692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
2693:../uvc.c      **** 							 dataIdx++;
2694:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
2695:../uvc.c      **** 							 dataIdx++;
2696:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
2697:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
2698:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
2699:../uvc.c      **** 							 dataIdx++;
2700:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2701:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2702:../uvc.c      **** 	#else //combination version
2703:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2704:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2705:../uvc.c      **** 						     /* end test */
2706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2707:../uvc.c      **** 							 dataIdx++;
2708:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2709:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2710:../uvc.c      **** 							 getData1 = Data1;
2711:../uvc.c      **** 	#endif
2712:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2713:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2714:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2715:../uvc.c      **** 							 break;
2716:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2717:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2718:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2719:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2720:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2721:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2722:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2723:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2724:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2725:../uvc.c      **** 						 case ExtExRefCtlID10:
2726:../uvc.c      **** 				 	 	 default:
2727:../uvc.c      **** 				 	 			 if(Len == 2)
2728:../uvc.c      **** 				 	 			 {
2729:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2730:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2731:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2732:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2734:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2735:../uvc.c      **** 									 }
2736:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2737:../uvc.c      **** 				 	 			 }else if(Len == 4){
2738:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2739:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2740:../uvc.c      **** 									 {
2741:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2742:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2743:../uvc.c      **** 										 dataIdx++;
2744:../uvc.c      **** 									 }
2745:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2746:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2747:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2748:../uvc.c      **** 									 }
2749:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2750:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2751:../uvc.c      **** 
2752:../uvc.c      **** 				 	 			 }
2753:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2754:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2755:../uvc.c      **** 				 	 			 break;
2756:../uvc.c      **** 					 }
2757:../uvc.c      **** 			 	 }
2758:../uvc.c      **** 			 	 else{
2759:../uvc.c      **** 					 switch(CtrlID)
2760:../uvc.c      **** 					 {
2761:../uvc.c      **** 						 case BrgtCtlID1:
2762:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2763:../uvc.c      **** 								 dataIdx = 0;
2764:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2765:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2766:../uvc.c      **** 								  if(Data0&0x80){
2767:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2768:../uvc.c      **** 								  }else{
2769:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2770:../uvc.c      **** 								  }
2771:../uvc.c      **** 								 Data1 |= ~0x03;
2772:../uvc.c      **** 								 Data1 &= 0xC7;
2773:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2774:../uvc.c      **** 							  	 dataIdx++;
2775:../uvc.c      **** 
2776:../uvc.c      **** 								 Data0 = (Data0 << 2);
2777:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2778:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2779:../uvc.c      **** 
2780:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2781:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2782:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2783:../uvc.c      **** 	#endif
2784:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2785:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2786:../uvc.c      **** 								  if(Data0&0x80){
2787:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2788:../uvc.c      **** 								  }else{
2789:../uvc.c      **** 									  Data0 = ~Data0;
2790:../uvc.c      **** 								  }
2791:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2792:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2793:../uvc.c      **** 
2794:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2795:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2796:../uvc.c      **** 							 break;
2797:../uvc.c      **** 						 case HueCtlID5://not being used
2798:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2800:../uvc.c      **** 							 dataIdx++;
2801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2802:../uvc.c      **** 							 dataIdx++;
2803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2804:../uvc.c      **** 							 dataIdx++;
2805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2806:../uvc.c      **** 							 dataIdx++;
2807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2808:../uvc.c      **** 							 dataIdx++;
2809:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2810:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2811:../uvc.c      **** 
2812:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2813:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2814:../uvc.c      **** 							 break;
2815:../uvc.c      **** 						 case MFreqCtlID4:
2816:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2817:../uvc.c      **** 							 Data0 = Data0 - 1;
2818:../uvc.c      **** 							 is60Hz = Data0;
2819:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2820:../uvc.c      **** 							 {
2821:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
2822:../uvc.c      **** 								 is60Hz = CyFalse;
2823:../uvc.c      **** 							 }
2824:../uvc.c      **** 							 else if(Data0 >2)
2825:../uvc.c      **** 							 {
2826:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
2827:../uvc.c      **** 								 is60Hz = CyTrue;
2828:../uvc.c      **** 							 }
2829:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2830:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2831:../uvc.c      **** 							 {
2832:../uvc.c      **** 			                       switch (setRes)
2833:../uvc.c      **** 			                         {
2834:../uvc.c      **** 			                         	case 1: //1944
2835:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2836:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2837:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2838:../uvc.c      **** 			                         		break;
2839:../uvc.c      **** 			                         	case 2: //1080
2840:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2841:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2842:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2843:../uvc.c      **** 			                         		break;
2844:../uvc.c      **** 			                         	case 3: //720
2845:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2846:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2847:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2848:../uvc.c      **** 			                         		break;
2849:../uvc.c      **** 			                         	case 4: //VGA
2850:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2851:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2852:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2853:../uvc.c      **** 			                         	default:
2854:../uvc.c      **** 			                         		break;
2855:../uvc.c      **** 			                         }
2856:../uvc.c      **** 							 }
2857:../uvc.c      **** 
2858:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2859:../uvc.c      **** 							 break;
2860:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2861:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2862:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2863:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2864:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2865:../uvc.c      **** 							 dataIdx++;
2866:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2867:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2868:../uvc.c      **** 
2869:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2870:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2871:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2872:../uvc.c      **** 							 break;
2873:../uvc.c      **** 						 case BLCCtlID0:
2874:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2875:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2876:../uvc.c      **** 							 {
2877:../uvc.c      **** 								 if(Data0 < 3){
2878:../uvc.c      **** 					 				 Data0 += 4;
2879:../uvc.c      **** 					 			 }else{
2880:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2881:../uvc.c      **** 									Data0 = 4; //set to default.
2882:../uvc.c      **** 					 			 }
2883:../uvc.c      **** 					 		 }
2884:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2885:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2886:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2887:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2888:../uvc.c      **** 					 		 break;
2889:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2890:../uvc.c      **** 
2891:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2892:../uvc.c      **** 							 if(Data0 != 0){
2893:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2894:../uvc.c      **** 	#ifdef COLOR
2895:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2896:../uvc.c      **** 	#else
2897:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2898:../uvc.c      **** 								 dataIdx++;
2899:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2900:../uvc.c      **** 	#endif
2901:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2902:../uvc.c      **** 							 }else{
2903:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2904:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2905:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2906:../uvc.c      **** 							 }
2907:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2908:../uvc.c      **** 							 break;
2909:../uvc.c      **** 						 case ConsCtlID2:
2910:../uvc.c      **** 						 case WBTMdCtlID9:
2911:../uvc.c      **** 						 case SaturCtlID6:
2912:../uvc.c      **** 						 default:
2913:../uvc.c      **** 			 	 			 if(Len == 2)
2914:../uvc.c      **** 			 	 			 {
2915:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2916:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2917:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2918:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2919:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2920:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2921:../uvc.c      **** 								 }
2922:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2923:../uvc.c      **** 			 	 			 }else if(Len == 4){
2924:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2925:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2926:../uvc.c      **** 								 {
2927:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2928:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2929:../uvc.c      **** 									 dataIdx++;
2930:../uvc.c      **** 								 }
2931:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2932:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2933:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2934:../uvc.c      **** 								 }
2935:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2936:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2937:../uvc.c      **** 
2938:../uvc.c      **** 			 	 			 }
2939:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2940:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2941:../uvc.c      **** 			 	 			 break;
2942:../uvc.c      **** 					 }
2943:../uvc.c      **** 			 	 }
2944:../uvc.c      **** 			   }else{
2945:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2946:../uvc.c      **** 			   }
2947:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2948:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2949:../uvc.c      **** #endif
2950:../uvc.c      **** 
2951:../uvc.c      **** 			  break;
2952:../uvc.c      **** 		  default:
2953:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2954:../uvc.c      **** 			  break;
2955:../uvc.c      **** 		 }
2956:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2957:../uvc.c      **** }
2958:../uvc.c      **** /************** CT control requests handler *************************/
2959:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2960:../uvc.c      **** 
2961:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2962:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2963:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2964:../uvc.c      ****     uint16_t readCount;
2965:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2966:../uvc.c      ****     uint16_t diff, value, diffRd;
2967:../uvc.c      ****     uint8_t i, shutter, index;
2968:../uvc.c      ****     diff = 0xffff;
2969:../uvc.c      ****     shutter = 1;
2970:../uvc.c      ****     index = 1;
2971:../uvc.c      **** 
2972:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2973:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2974:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2975:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2976:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2977:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2978:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2979:../uvc.c      **** #endif
2980:../uvc.c      ****     reqData = bRequest;
2981:../uvc.c      **** 
2982:../uvc.c      ****     switch (bRequest)
2983:../uvc.c      **** 		 {
2984:../uvc.c      **** 
2985:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2986:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2987:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2988:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2989:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2990:../uvc.c      **** 			  break;
2991:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2992:../uvc.c      **** 
2993:../uvc.c      **** 			 switch(CtrlID)
2994:../uvc.c      **** 			 {
2995:../uvc.c      **** 				 default:
2996:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2997:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2998:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2999:../uvc.c      **** 					 glEp0Buffer[3] = 0;
3000:../uvc.c      **** 					 sendData = glEp0Buffer[0];
3001:../uvc.c      **** 					 break;
3002:../uvc.c      **** 			 }
3003:../uvc.c      **** 
3004:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3005:../uvc.c      **** 
3006:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3007:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
3008:../uvc.c      **** #endif
3009:../uvc.c      **** 			  break;
3010:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
3011:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
3012:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
3013:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
3014:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3015:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3016:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3017:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3018:../uvc.c      **** 			  break;
3019:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
3020:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
3021:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
3022:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
3023:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3024:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3025:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3026:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3027:../uvc.c      **** 			  break;
3028:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
3029:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
3030:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
3031:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
3032:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3033:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3034:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3035:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3036:../uvc.c      **** 			  break;
3037:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
3038:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
3039:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3040:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3041:../uvc.c      **** 			  Len = 1;
3042:../uvc.c      **** 			  break;
3043:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
3044:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
3045:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
3046:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
3047:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
3048:../uvc.c      **** 			  glEp0Buffer[3] = 0;
3049:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
3050:../uvc.c      **** 			  sendData = glEp0Buffer[0];
3051:../uvc.c      **** 			  break;
3052:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
3053:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3054:../uvc.c      **** 			  glEp0Buffer, &readCount);
3055:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
3056:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
3057:../uvc.c      **** 			  value = Data1;
3058:../uvc.c      **** 
3059:../uvc.c      **** 			  switch(CtrlID)
3060:../uvc.c      **** 			  {
3061:../uvc.c      **** 		  	      case AutoExMCtlID1:
3062:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
3063:../uvc.c      **** 
3064:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
3065:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
3066:../uvc.c      **** 				    getData = glEp0Buffer[0];
3067:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
3068:../uvc.c      **** 		  		    switch (getData){
3069:../uvc.c      **** 						case 1:
3070:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
3071:../uvc.c      **** 							break;
3072:../uvc.c      **** 						case 2:
3073:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3074:../uvc.c      **** 							dataIdx = 0;
3075:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3076:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3077:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3078:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
3079:../uvc.c      **** 
3080:../uvc.c      **** 							break;
3081:../uvc.c      **** 						case 4:
3082:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
3083:../uvc.c      **** 							break;
3084:../uvc.c      **** 						case 8:
3085:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3086:../uvc.c      **** 			  		    	dataIdx = 0;
3087:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3088:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3089:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3090:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
3091:../uvc.c      **** 							break;
3092:../uvc.c      **** 		  		    }
3093:../uvc.c      **** #if 0
3094:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
3095:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
3096:../uvc.c      **** 						  dataIdx = 0;
3097:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3098:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
3099:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3100:../uvc.c      **** 		  		    }
3101:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
3102:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
3103:../uvc.c      **** 		  		    }
3104:../uvc.c      **** #endif
3105:../uvc.c      **** 				    break;
3106:../uvc.c      **** 
3107:../uvc.c      **** 			  	  case ExTmACtlID3:
3108:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
3109:../uvc.c      **** 
3110:../uvc.c      **** 					  value = (value << 8)|Data0;
3111:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
3112:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
3113:../uvc.c      **** 					  {
3114:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
3115:../uvc.c      **** 						  {
3116:../uvc.c      **** 							if(value > ShutValueArry[i]){
3117:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
3118:../uvc.c      **** 							}else{
3119:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
3120:../uvc.c      **** 							}
3121:../uvc.c      **** 							  if(diff > diffRd){
3122:../uvc.c      **** 								  diff = diffRd;
3123:../uvc.c      **** 								  index = i;
3124:../uvc.c      **** 							  }
3125:../uvc.c      **** 						  }
3126:../uvc.c      **** 						  shutter = shutter+index;
3127:../uvc.c      **** 
3128:../uvc.c      **** 						  dataIdx = 0;
3129:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3130:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
3131:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3132:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
3133:../uvc.c      **** 
3134:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
3135:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
3136:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
3137:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
3138:../uvc.c      **** 					  }else{
3139:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
3140:../uvc.c      **** 					  }
3141:../uvc.c      **** 					  getData = glEp0Buffer[0];
3142:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3143:../uvc.c      **** 					  break;
3144:../uvc.c      **** 			  	  case IriACtlID7:
3145:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
3146:../uvc.c      **** 					  {
3147:../uvc.c      **** 							 dataIdx = 0;
3148:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3149:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
3150:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3151:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
3152:../uvc.c      **** 
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
3154:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
3155:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
3156:../uvc.c      **** 					  }else{
3157:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
3158:../uvc.c      **** 					  }
3159:../uvc.c      **** 					  getData = glEp0Buffer[0];
3160:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3161:../uvc.c      **** 
3162:../uvc.c      **** 					  break;
3163:../uvc.c      **** 			  	  case ZmOpRCtlID10:
3164:../uvc.c      **** 					  getData = glEp0Buffer[0];
3165:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
3166:../uvc.c      **** #if 1
3167:../uvc.c      **** 					  dataIdx = 0;
3168:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3169:../uvc.c      **** 					  if(getData == 1)
3170:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
3171:../uvc.c      **** 					  else if(getData == 0xff)
3172:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
3173:../uvc.c      **** 					  else
3174:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
3175:../uvc.c      **** 					  //dataIdx++;
3176:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
3177:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3178:../uvc.c      **** #endif
3179:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
3180:../uvc.c      **** 					  break;
3181:../uvc.c      **** 
3182:../uvc.c      **** 			  	  default:
3183:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
3184:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
3185:../uvc.c      **** 			  		 break;
3186:../uvc.c      **** 			  }
3187:../uvc.c      **** 			  break;
3188:../uvc.c      **** 		  default:
3189:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
3190:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
3191:../uvc.c      **** 			  break;
3192:../uvc.c      **** 		 }
3193:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
3194:../uvc.c      **** 
3195:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
3196:../uvc.c      **** }
3197:../uvc.c      **** 
3198:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
3199:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
3200:../uvc.c      **** {
3201:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
3202:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3203:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
3204:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
3205:../uvc.c      **** 
3206:../uvc.c      ****     CtrlID = BrgtCtlID1;
3207:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
3208:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3209:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
3210:../uvc.c      ****     Data1 = Data0;
3211:../uvc.c      **** 
3212:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3213:../uvc.c      ****     if(Data1&0x80){
3214:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
3215:../uvc.c      ****     }else{
3216:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
3217:../uvc.c      ****     }
3218:../uvc.c      ****     Data0 = (Data0 << 2);
3219:../uvc.c      **** 
3220:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
3221:../uvc.c      **** 
3222:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
3223:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
3224:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3225:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
3226:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
3227:../uvc.c      **** 
3228:../uvc.c      ****     CtrlID = ConsCtlID2;
3229:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3230:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3231:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3232:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
3233:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3234:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
3235:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3236:../uvc.c      **** 
3237:../uvc.c      ****     CtrlID = HueCtlID5;
3238:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3239:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3240:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3241:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
3244:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
3245:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
3246:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
3247:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
3248:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
3249:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
3250:../uvc.c      **** 
3251:../uvc.c      ****     CtrlID = SaturCtlID6;
3252:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3253:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3254:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
3255:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
3256:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
3257:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3258:../uvc.c      **** 
3259:../uvc.c      ****     CtrlID = ShapCtlID7;
3260:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
3261:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
3262:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
3263:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
3264:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
3265:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
3266:../uvc.c      **** 
3267:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3268:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
3269:../uvc.c      **** 	return;
3270:../uvc.c      **** }
3271:../uvc.c      **** 
3272:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
3273:../uvc.c      **** void
3274:../uvc.c      **** CyFxUVCAddHeader (
3275:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
3276:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
3277:../uvc.c      ****         )
3278:../uvc.c      **** {
3279:../uvc.c      ****     /* Copy header to buffer */
3280:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3281:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
3282:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
3283:../uvc.c      **** 
3284:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
3285:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
3286:../uvc.c      ****     {
3287:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
3288:../uvc.c      ****     }
3289:../uvc.c      **** }
3290:../uvc.c      **** 
3291:../uvc.c      **** 
3292:../uvc.c      **** /* Application Error Handler */
3293:../uvc.c      **** void
3294:../uvc.c      **** CyFxAppErrorHandler (
3295:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
3296:../uvc.c      ****         )
3297:../uvc.c      **** {
3298:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
3299:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
3300:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
3301:../uvc.c      **** 
3302:../uvc.c      ****        This function can be modified to take additional error handling actions such
3303:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
3304:../uvc.c      ****      */
3305:../uvc.c      ****     for (;;)
3306:../uvc.c      ****     {
3307:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
3308:../uvc.c      ****         CyU3PThreadSleep (1000);
3309:../uvc.c      ****     }
3310:../uvc.c      **** }
3311:../uvc.c      **** 
3312:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
3313:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
3314:../uvc.c      ****  */
3315:../uvc.c      **** static void
3316:../uvc.c      **** CyFxUVCApplnAbortHandler (
3317:../uvc.c      ****         void)
3318:../uvc.c      **** {
3319:../uvc.c      **** 	uint32_t flag;
3320:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
3321:../uvc.c      **** 	{
3322:../uvc.c      ****         /* Clear the Video Stream Request Event */
3323:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
3324:../uvc.c      **** 
3325:../uvc.c      ****         /* Set Video Stream Abort Event */
3326:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
3327:../uvc.c      **** 	}
3328:../uvc.c      **** }
3329:../uvc.c      **** 
3330:../uvc.c      **** /* This is the Callback function to handle the USB Events */
3331:../uvc.c      **** static void
3332:../uvc.c      **** CyFxUVCApplnUSBEventCB (
3333:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
3334:../uvc.c      ****         uint16_t             evdata  /* Event data */
3335:../uvc.c      ****         )
3336:../uvc.c      **** {
3337:../uvc.c      ****     switch (evtype)
3338:../uvc.c      ****     {
3339:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
3340:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
3341:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3342:../uvc.c      ****             gpif_initialized = 0;
3343:../uvc.c      ****             streamingStarted = CyFalse;
3344:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3345:../uvc.c      ****             break;
3346:../uvc.c      **** 
3347:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
3348:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
3349:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3350:../uvc.c      ****             gpif_initialized = 0;
3351:../uvc.c      ****             streamingStarted = CyFalse;
3352:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3353:../uvc.c      ****             break;
3354:../uvc.c      **** 
3355:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
3356:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
3357:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
3358:../uvc.c      ****             gpif_initialized = 0;
3359:../uvc.c      ****             isUsbConnected = CyFalse;
3360:../uvc.c      ****             streamingStarted = CyFalse;
3361:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
3362:../uvc.c      ****             break;
3363:../uvc.c      **** 
3364:../uvc.c      **** #ifdef BACKFLOW_DETECT
3365:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
3366:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
3367:../uvc.c      ****             break;
3368:../uvc.c      **** #endif
3369:../uvc.c      **** 
3370:../uvc.c      ****         default:
3371:../uvc.c      ****             break;
3372:../uvc.c      ****     }
3373:../uvc.c      **** }
3374:../uvc.c      **** 
3375:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
3376:../uvc.c      **** static CyBool_t
3377:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
3378:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
3379:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
3380:../uvc.c      ****         )
3381:../uvc.c      **** {
3382:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
3383:../uvc.c      ****     uint32_t status;
3384:../uvc.c      **** 
3385:../uvc.c      ****     /* Obtain Request Type and Request */
3386:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
3387:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
3388:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
3389:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
3390:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
3391:../uvc.c      **** 
3392:../uvc.c      ****     /* Check for UVC Class Requests */
3393:../uvc.c      ****     switch (bmReqType)
3394:../uvc.c      ****     {
3395:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
3396:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
3397:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
3398:../uvc.c      ****             switch (wIndex & 0xFF)
3399:../uvc.c      ****             {
3400:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
3401:../uvc.c      ****                     {
3402:../uvc.c      ****                         uvcHandleReq = CyTrue;
3403:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
3404:../uvc.c      ****                                 CYU3P_EVENT_OR);
3405:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
3406:../uvc.c      ****                         {
3407:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
3408:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
3409:../uvc.c      ****                         }
3410:../uvc.c      ****                     }
3411:../uvc.c      ****                     break;
3412:../uvc.c      **** 
3413:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
3414:../uvc.c      ****                     {
3415:../uvc.c      ****                         uvcHandleReq = CyTrue;
3416:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
3417:../uvc.c      ****                                 CYU3P_EVENT_OR);
3418:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
3419:../uvc.c      ****                         {
3420:../uvc.c      ****                             /* Error handling */
3421:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
3422:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
3423:../uvc.c      ****                         }
3424:../uvc.c      ****                     }
3425:../uvc.c      ****                     break;
3426:../uvc.c      **** 
3427:../uvc.c      ****                 default:
3428:../uvc.c      ****                     break;
3429:../uvc.c      ****             }
3430:../uvc.c      ****             break;
3431:../uvc.c      **** 
3432:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
3433:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
3434:../uvc.c      ****             {
3435:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
3436:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
3437:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
3438:../uvc.c      ****                 {
3439:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
3440:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
3441:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
3442:../uvc.c      ****                     gpif_initialized = 0;
3443:../uvc.c      ****                     streamingStarted = CyFalse;
3444:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
3445:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3446:../uvc.c      ****                     CyU3PBusyWait (100);
3447:../uvc.c      **** 
3448:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
3449:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3450:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3451:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3452:../uvc.c      ****                     CyU3PBusyWait (100);
3453:../uvc.c      **** 
3454:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
3455:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3456:../uvc.c      ****                     uvcHandleReq = CyTrue;
3457:../uvc.c      ****                     /* Complete Control request handshake */
3458:../uvc.c      ****                     CyU3PUsbAckSetup ();
3459:../uvc.c      ****                     /* Indicate stop streaming to main thread */
3460:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
3461:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
3462:../uvc.c      **** 
3463:../uvc.c      ****                 }
3464:../uvc.c      ****             }
3465:../uvc.c      ****             break;
3466:../uvc.c      **** 
3467:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
3468:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
3469:../uvc.c      ****             {
3470:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
3471:../uvc.c      ****                 {
3472:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
3473:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
3474:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
3475:../uvc.c      ****                 	 * has started. */
3476:../uvc.c      ****                     if (streamingStarted == CyTrue)
3477:../uvc.c      ****                     {
3478:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
3479:../uvc.c      **** 
3480:../uvc.c      ****                         /* Disable the GPIF state machine. */
3481:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
3482:../uvc.c      ****                         gpif_initialized = 0;
3483:../uvc.c      ****                         streamingStarted = CyFalse;
3484:../uvc.c      **** 
3485:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
3486:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
3487:../uvc.c      ****                         CyU3PBusyWait (100);
3488:../uvc.c      **** 
3489:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
3490:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3491:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3492:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
3493:../uvc.c      ****                         CyU3PBusyWait (100);
3494:../uvc.c      **** 
3495:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
3496:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
3497:../uvc.c      **** 
3498:../uvc.c      ****                         uvcHandleReq = CyTrue;
3499:../uvc.c      ****                         /* Complete Control request handshake */
3500:../uvc.c      ****                         CyU3PUsbAckSetup ();
3501:../uvc.c      ****                         /* Indicate stop streaming to main thread */
3502:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
3503:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
3504:../uvc.c      ****                     }
3505:../uvc.c      ****                     else
3506:../uvc.c      ****                     {
3507:../uvc.c      ****                         uvcHandleReq = CyTrue;
3508:../uvc.c      ****                         CyU3PUsbAckSetup ();
3509:../uvc.c      ****                     }
3510:../uvc.c      ****                 }
3511:../uvc.c      ****             }
3512:../uvc.c      ****             break;
3513:../uvc.c      **** 
3514:../uvc.c      ****         default:
3515:../uvc.c      ****             break;
3516:../uvc.c      ****     }
3517:../uvc.c      **** 
3518:../uvc.c      ****     /* Return status of request handling to the USB driver */
3519:../uvc.c      ****     return uvcHandleReq;
3520:../uvc.c      **** }
3521:../uvc.c      **** 
3522:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
3523:../uvc.c      **** 
3524:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
3525:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
3526:../uvc.c      ****  */
3527:../uvc.c      **** void
3528:../uvc.c      **** CyFxUvcApplnDmaCallback (
3529:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
3530:../uvc.c      ****         CyU3PDmaCbType_t      type,
3531:../uvc.c      ****         CyU3PDmaCBInput_t    *input
3532:../uvc.c      ****         )
3533:../uvc.c      **** {
3534:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
3535:../uvc.c      **** #if 1
3536:../uvc.c      ****     CyU3PReturnStatus_t status;
3537:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
3538:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
3539:../uvc.c      **** 
3540:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3541:../uvc.c      ****     {
3542:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
3543:../uvc.c      ****             {
3544:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
3545:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
3546:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3547:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
3548:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3549:../uvc.c      ****                 	stiflag = 0x03;
3550:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
3551:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3552:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3553:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
3554:../uvc.c      ****                 }
3555:../uvc.c      **** #endif
3556:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
3557:../uvc.c      ****                 fb++;
3558:../uvc.c      ****             }
3559:../uvc.c      ****             else
3560:../uvc.c      ****             {
3561:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
3562:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
3563:../uvc.c      ****                 pb++;
3564:../uvc.c      ****                 pbc = input->buffer_p.count;
3565:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
3566:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
3567:../uvc.c      ****                 //lineCount = 0; //res test
3568:../uvc.c      **** #if 1   //remove the still flag clearing here
3569:../uvc.c      ****                 if(stiflag == 0x0F){
3570:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3571:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3572:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
3573:../uvc.c      ****                 	stiflag = 0xAA;
3574:../uvc.c      ****                 }
3575:../uvc.c      **** #endif
3576:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
3577:../uvc.c      ****             }
3578:../uvc.c      **** 
3579:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
3580:../uvc.c      ****             prodCount++;
3581:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3582:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
3583:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
3584:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
3585:../uvc.c      ****             {
3586:../uvc.c      ****                 prodCount--;
3587:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
3588:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
3589:../uvc.c      ****             }
3590:../uvc.c      ****     }
3591:../uvc.c      **** #endif
3592:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
3593:../uvc.c      ****     {
3594:../uvc.c      ****         consCount++;
3595:../uvc.c      ****         streamingStarted = CyTrue;
3596:../uvc.c      ****     }
3597:../uvc.c      **** }
3598:../uvc.c      **** 
3599:../uvc.c      **** /*
3600:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
3601:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
3602:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
3603:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
3604:../uvc.c      ****  * to commit the buffer.
3605:../uvc.c      ****  */
3606:../uvc.c      **** static uint8_t
3607:../uvc.c      **** CyFxUvcAppCommitEOF (
3608:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
3609:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
3610:../uvc.c      ****         )
3611:../uvc.c      **** {
3612:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3613:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
3614:../uvc.c      **** 
3615:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
3616:../uvc.c      **** 
3617:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3618:../uvc.c      ****     {
3619:../uvc.c      ****         switch (stateId)
3620:../uvc.c      ****         {
3621:../uvc.c      **** 
3622:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
3623:../uvc.c      ****             case FULL_BUF_IN_SCK1:
3624:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3625:../uvc.c      ****                 break;
3626:../uvc.c      **** 
3627:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
3628:../uvc.c      ****                 socket = 0;
3629:../uvc.c      ****                 break;
3630:../uvc.c      **** 
3631:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
3632:../uvc.c      ****                 socket = 1;
3633:../uvc.c      ****                 break;
3634:../uvc.c      **** 
3635:../uvc.c      ****             default:
3636:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3637:../uvc.c      ****                 /* Unexpected current state. Return error. */
3638:../uvc.c      ****             	//lineCount++;
3639:../uvc.c      ****             	return 1;
3640:../uvc.c      ****         }
3641:../uvc.c      ****     }
3642:../uvc.c      **** 
3643:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3644:../uvc.c      ****     {
3645:../uvc.c      ****         switch (stateId)
3646:../uvc.c      ****         {
3647:../uvc.c      **** #ifndef CAM720
3648:../uvc.c      **** #ifdef GPIFIIM
3649:../uvc.c      ****             case 13:
3650:../uvc.c      ****             case 24:
3651:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3652:../uvc.c      ****                 break;
3653:../uvc.c      **** 
3654:../uvc.c      ****             case 8:
3655:../uvc.c      ****                 socket = 0;
3656:../uvc.c      ****                 break;
3657:../uvc.c      **** 
3658:../uvc.c      ****             case 20:
3659:../uvc.c      ****                 socket = 1;
3660:../uvc.c      ****                 break;
3661:../uvc.c      **** #else
3662:../uvc.c      ****             case 11:
3663:../uvc.c      ****             case 18:
3664:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3665:../uvc.c      ****                 break;
3666:../uvc.c      **** 
3667:../uvc.c      ****             case 8:
3668:../uvc.c      ****                 socket = 0;
3669:../uvc.c      ****                 break;
3670:../uvc.c      **** 
3671:../uvc.c      ****             case 15:
3672:../uvc.c      ****                 socket = 1;
3673:../uvc.c      ****                 break;
3674:../uvc.c      **** #endif
3675:../uvc.c      **** #else
3676:../uvc.c      ****             case 11:
3677:../uvc.c      ****             case 18:
3678:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3679:../uvc.c      ****                 break;
3680:../uvc.c      **** 
3681:../uvc.c      ****             case 8:
3682:../uvc.c      ****                 socket = 0;
3683:../uvc.c      ****                 break;
3684:../uvc.c      **** 
3685:../uvc.c      ****             case 15:
3686:../uvc.c      ****                 socket = 1;
3687:../uvc.c      ****                 break;
3688:../uvc.c      **** 
3689:../uvc.c      **** #endif
3690:../uvc.c      ****              default:
3691:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3692:../uvc.c      ****                 /* Unexpected current state. Return error. */
3693:../uvc.c      ****                return 1;
3694:../uvc.c      ****         }
3695:../uvc.c      ****     }
3696:../uvc.c      **** 
3697:../uvc.c      ****     if (socket != 0xFF)
3698:../uvc.c      ****     {
3699:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3700:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3701:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3702:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3703:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3704:../uvc.c      ****         {
3705:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3706:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3707:../uvc.c      ****         }
3708:../uvc.c      ****     }
3709:../uvc.c      **** 
3710:../uvc.c      ****     return 0;
3711:../uvc.c      **** }
3712:../uvc.c      **** 
3713:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3714:../uvc.c      **** void
3715:../uvc.c      **** CyFxGpifCB (
3716:../uvc.c      ****         CyU3PGpifEventType event,
3717:../uvc.c      ****         uint8_t currentState
3718:../uvc.c      ****         )
3719:../uvc.c      **** {
3720:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3721:../uvc.c      ****     {
3722:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3723:../uvc.c      ****     	           in the UVC implementation. */
3724:../uvc.c      ****     	//hitFV = CyTrue;
3725:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3726:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3727:../uvc.c      ****     }
3728:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3729:../uvc.c      **** }
3730:../uvc.c      **** 
3731:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3732:../uvc.c      **** static void
3733:../uvc.c      **** CyFxUVCApplnDebugInit (
3734:../uvc.c      ****         void)
3735:../uvc.c      **** {
3736:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3737:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3738:../uvc.c      **** 
3739:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3740:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3742:../uvc.c      ****     {
3743:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3744:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3745:../uvc.c      ****     }
3746:../uvc.c      **** 
3747:../uvc.c      ****     /* Set UART Configuration */
3748:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3749:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3750:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3751:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3752:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3753:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3754:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3755:../uvc.c      **** 
3756:../uvc.c      ****     /* Set the UART configuration */
3757:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3758:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3759:../uvc.c      ****     {
3760:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3761:../uvc.c      ****     }
3762:../uvc.c      **** 
3763:../uvc.c      ****     /* Set the UART transfer */
3764:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3765:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3766:../uvc.c      ****     {
3767:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3768:../uvc.c      ****     }
3769:../uvc.c      **** 
3770:../uvc.c      ****     /* Initialize the Debug logger module. */
3771:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3772:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3773:../uvc.c      ****     {
3774:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3775:../uvc.c      ****     }
3776:../uvc.c      **** 
3777:../uvc.c      ****     /* Disable log message headers. */
3778:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3779:../uvc.c      **** }
3780:../uvc.c      **** 
3781:../uvc.c      **** /* I2C initialization. */
3782:../uvc.c      **** static void
3783:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3784:../uvc.c      **** {
3785:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3786:../uvc.c      ****     CyU3PReturnStatus_t status;
3787:../uvc.c      **** 
3788:../uvc.c      ****     status = CyU3PI2cInit ();
3789:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3790:../uvc.c      ****     {
3791:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3792:../uvc.c      ****         CyFxAppErrorHandler (status);
3793:../uvc.c      ****     }
3794:../uvc.c      **** 
3795:../uvc.c      ****     /*  Set I2C Configuration */
3796:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3797:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3798:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3799:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3800:../uvc.c      **** 
3801:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3802:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3803:../uvc.c      ****     {
3804:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3805:../uvc.c      ****         CyFxAppErrorHandler (status);
3806:../uvc.c      ****     }
3807:../uvc.c      **** }
3808:../uvc.c      **** 
3809:../uvc.c      **** #ifdef BACKFLOW_DETECT
3810:../uvc.c      **** static void CyFxUvcAppPibCallback (
3811:../uvc.c      ****         CyU3PPibIntrType cbType,
3812:../uvc.c      ****         uint16_t cbArg)
3813:../uvc.c      **** {
3814:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3815:../uvc.c      ****     {
3816:../uvc.c      ****         if (!back_flow_detected)
3817:../uvc.c      ****         {
3818:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3819:../uvc.c      ****             back_flow_detected = 1;
3820:../uvc.c      ****         }
3821:../uvc.c      ****     }
3822:../uvc.c      **** }
3823:../uvc.c      **** #endif
3824:../uvc.c      **** 
3825:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3826:../uvc.c      **** static void
3827:../uvc.c      **** CyFxUvcAppDebugCallback (
3828:../uvc.c      ****         CyU3PDmaChannel   *handle,
3829:../uvc.c      ****         CyU3PDmaCbType_t   type,
3830:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3831:../uvc.c      **** {
3832:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3833:../uvc.c      ****     {
3834:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3835:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3836:../uvc.c      ****     }
3837:../uvc.c      **** }
3838:../uvc.c      **** #endif
3839:../uvc.c      **** 
3840:../uvc.c      **** #if 0
3841:../uvc.c      **** static void CyFxAppIntEpCb(
3842:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3843:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3844:../uvc.c      **** 		uint8_t  ebNum)
3845:../uvc.c      **** 		{
3846:../uvc.c      **** 			//CyBool_t value;
3847:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3848:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3849:../uvc.c      **** 
3850:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3851:../uvc.c      **** 		}
3852:../uvc.c      **** #endif
3853:../uvc.c      **** 
3854:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3855:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3856:../uvc.c      ****    configures the DMA module for the UVC Application */
3857:../uvc.c      **** static void
3858:../uvc.c      **** CyFxUVCApplnInit (void)
3859:../uvc.c      **** {
3860:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3861:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3862:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3863:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3864:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3865:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3866:../uvc.c      **** 
3867:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3868:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3869:../uvc.c      **** 
3870:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3871:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3872:../uvc.c      **** #endif
3873:../uvc.c      **** 
3874:../uvc.c      ****     /* Create UVC event group */
3875:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3876:../uvc.c      ****     if (apiRetStatus != 0)
3877:../uvc.c      ****     {
3878:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3879:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3880:../uvc.c      ****     }
3881:../uvc.c      **** 
3882:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3883:../uvc.c      ****     CyFxUvcAppPTZInit ();
3884:../uvc.c      **** #endif
3885:../uvc.c      **** 
3886:../uvc.c      ****     isUsbConnected = CyFalse;
3887:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3888:../uvc.c      **** 
3889:../uvc.c      ****     /* Init the GPIO module */
3890:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3891:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3892:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3893:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3894:../uvc.c      ****     gpioClock.halfDiv    = 0;
3895:../uvc.c      **** 
3896:../uvc.c      ****     /* Initialize Gpio interface */
3897:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3898:../uvc.c      ****     if (apiRetStatus != 0)
3899:../uvc.c      ****     {
3900:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3901:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3902:../uvc.c      ****     }
3903:../uvc.c      **** 
3904:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3905:../uvc.c      ****      * must use GpioOverride to configure it */
3906:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3907:../uvc.c      ****     if (apiRetStatus != 0)
3908:../uvc.c      ****     {
3909:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3910:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3911:../uvc.c      ****     }
3912:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3913:../uvc.c      ****     if (apiRetStatus != 0)
3914:../uvc.c      ****     {
3915:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3917:../uvc.c      ****     }
3918:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3919:../uvc.c      ****     if (apiRetStatus != 0)
3920:../uvc.c      ****     {
3921:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3922:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3923:../uvc.c      ****     }
3924:../uvc.c      **** 
3925:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3926:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3927:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3928:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3929:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3930:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3931:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3932:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3933:../uvc.c      ****     {
3934:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3935:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3936:../uvc.c      ****     }
3937:../uvc.c      **** 
3938:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3939:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3940:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3941:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3942:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3943:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3944:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3945:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3946:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3947:../uvc.c      ****     {
3948:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3950:../uvc.c      ****     }
3951:../uvc.c      **** 
3952:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3953:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3954:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3955:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3956:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3957:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3958:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3959:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3960:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3961:../uvc.c      ****     {
3962:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3963:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3964:../uvc.c      ****     }
3965:../uvc.c      **** 
3966:../uvc.c      ****     /* Initialize the P-port. */
3967:../uvc.c      ****     pibclock.clkDiv      = 2;
3968:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3969:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3970:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3971:../uvc.c      **** 
3972:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3973:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3974:../uvc.c      ****     {
3975:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3976:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3977:../uvc.c      ****     }
3978:../uvc.c      **** 
3979:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3980:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3981:../uvc.c      **** 
3982:../uvc.c      **** #ifdef BACKFLOW_DETECT
3983:../uvc.c      ****     back_flow_detected = 0;
3984:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3985:../uvc.c      **** #endif
3986:../uvc.c      **** 
3987:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3988:../uvc.c      ****     SensorReset ();
3989:../uvc.c      ****     CyU3PThreadSleep(5000);
3990:../uvc.c      ****     //SensorInit ();
3991:../uvc.c      **** 
3992:../uvc.c      ****     /* USB initialization. */
3993:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3994:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3995:../uvc.c      ****     {
3996:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3997:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3998:../uvc.c      ****     }
3999:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
4000:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
4001:../uvc.c      **** 
4002:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
4003:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
4004:../uvc.c      **** 
4005:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
4006:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
4007:../uvc.c      **** 
4008:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
4009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
4010:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
4011:../uvc.c      **** 
4012:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
4013:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
4014:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
4015:../uvc.c      **** 
4016:../uvc.c      ****     /* Configuration descriptors. */
4017:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
4018:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
4019:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
4020:../uvc.c      **** 
4021:../uvc.c      ****     /* String Descriptors */
4022:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
4023:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
4024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
4025:../uvc.c      **** 
4026:../uvc.c      ****     /* Configure the status interrupt endpoint.
4027:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
4028:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
4029:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
4030:../uvc.c      ****      */
4031:../uvc.c      ****     endPointConfig.enable   = 1;
4032:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
4033:../uvc.c      ****     endPointConfig.pcktSize = 64;
4034:../uvc.c      ****     endPointConfig.isoPkts  = 0;
4035:../uvc.c      ****     endPointConfig.streams  = 0;
4036:../uvc.c      ****     endPointConfig.burstLen = 1;
4037:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
4038:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4039:../uvc.c      ****     {
4040:../uvc.c      ****         /* Error Handling */
4041:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
4042:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4043:../uvc.c      ****     }
4044:../uvc.c      **** 
4045:../uvc.c      ****     /* create a DMA for interrupt endpoint */
4046:../uvc.c      ****     dmaInterConfig.size           = 1024;
4047:../uvc.c      ****     dmaInterConfig.count          = 1;
4048:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
4049:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
4050:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
4051:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
4052:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
4053:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
4054:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4055:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
4056:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
4057:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
4058:../uvc.c      ****             &dmaInterConfig);
4059:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4060:../uvc.c      ****     {
4061:../uvc.c      ****         /* Error handling */
4062:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
4063:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4064:../uvc.c      ****     }
4065:../uvc.c      **** 
4066:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
4067:../uvc.c      ****     if (glInterStaBuffer == 0)
4068:../uvc.c      ****     {
4069:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
4070:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
4071:../uvc.c      ****     }
4072:../uvc.c      **** 
4073:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
4074:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
4075:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
4076:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
4077:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
4078:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
4079:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
4080:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
4081:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
4082:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
4083:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
4084:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
4085:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4086:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
4087:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
4088:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
4089:../uvc.c      ****             &dmaMultiConfig);
4090:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4091:../uvc.c      ****     {
4092:../uvc.c      ****         /* Error handling */
4093:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
4094:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4095:../uvc.c      ****     }
4096:../uvc.c      **** 
4097:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4098:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
4099:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
4100:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
4101:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
4102:../uvc.c      ****      */
4103:../uvc.c      **** 
4104:../uvc.c      ****     endPointConfig.enable   = 1;
4105:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
4106:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
4107:../uvc.c      ****     endPointConfig.isoPkts  = 0;
4108:../uvc.c      ****     endPointConfig.streams  = 0;
4109:../uvc.c      ****     endPointConfig.burstLen = 1;
4110:../uvc.c      **** 
4111:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
4112:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4113:../uvc.c      ****     {
4114:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
4115:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4116:../uvc.c      ****     }
4117:../uvc.c      **** 
4118:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
4119:../uvc.c      **** 
4120:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
4121:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4122:../uvc.c      ****     {
4123:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
4124:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4125:../uvc.c      ****     }
4126:../uvc.c      **** 
4127:../uvc.c      ****     channelConfig.size           = 1024;
4128:../uvc.c      ****     channelConfig.count          = 1;
4129:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
4130:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
4131:../uvc.c      ****     channelConfig.prodAvailCount = 0;
4132:../uvc.c      ****     channelConfig.prodHeader     = 0;
4133:../uvc.c      ****     channelConfig.prodFooter     = 0;
4134:../uvc.c      ****     channelConfig.consHeader     = 0;
4135:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4136:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
4137:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
4138:../uvc.c      **** 
4139:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
4140:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4141:../uvc.c      ****     {
4142:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
4143:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4144:../uvc.c      ****     }
4145:../uvc.c      **** 
4146:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
4147:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4148:../uvc.c      ****     {
4149:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
4150:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4151:../uvc.c      ****     }
4152:../uvc.c      **** 
4153:../uvc.c      ****     channelConfig.size           = 1024;
4154:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
4155:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
4156:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
4157:../uvc.c      ****     channelConfig.prodAvailCount = 0;
4158:../uvc.c      ****     channelConfig.prodHeader     = 0;
4159:../uvc.c      ****     channelConfig.prodFooter     = 0;
4160:../uvc.c      ****     channelConfig.consHeader     = 0;
4161:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
4162:../uvc.c      ****     channelConfig.notification   = 0;
4163:../uvc.c      ****     channelConfig.cb             = 0;
4164:../uvc.c      **** 
4165:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
4166:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4167:../uvc.c      ****     {
4168:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
4169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4170:../uvc.c      ****     }
4171:../uvc.c      **** 
4172:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
4173:../uvc.c      ****     if (glDebugRspBuffer == 0)
4174:../uvc.c      ****     {
4175:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
4176:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
4177:../uvc.c      ****     }
4178:../uvc.c      **** #endif
4179:../uvc.c      **** 
4180:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
4181:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
4182:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4183:../uvc.c      ****     {
4184:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
4185:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4186:../uvc.c      ****     }
4187:../uvc.c      **** 
4188:../uvc.c      ****     CyU3PBusyWait(100);
4189:../uvc.c      **** 
4190:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
4191:../uvc.c      **** 
4192:../uvc.c      ****     endPointConfig.enable   = 1;
4193:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
4194:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
4195:../uvc.c      ****     {
4196:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
4197:../uvc.c      ****     	endPointConfig.burstLen = 16;
4198:../uvc.c      ****     }
4199:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
4200:../uvc.c      ****     {
4201:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
4202:../uvc.c      ****     	endPointConfig.burstLen = 1;
4203:../uvc.c      ****     }
4204:../uvc.c      ****     endPointConfig.streams  = 0;
4205:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
4206:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4207:../uvc.c      ****     {
4208:../uvc.c      ****         /* Error Handling */
4209:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
4210:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4211:../uvc.c      ****     }
4212:../uvc.c      **** #if 0    //for still image method 3 using
4213:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
4214:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4215:../uvc.c      ****     {
4216:../uvc.c      ****         /* Error Handling */
4217:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
4218:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4219:../uvc.c      ****     }
4220:../uvc.c      **** #endif
4221:../uvc.c      **** 
4222:../uvc.c      **** }
4223:../uvc.c      **** 
4224:../uvc.c      **** /*
4225:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
4226:../uvc.c      ****  * streaming session is started.
4227:../uvc.c      ****  */
4228:../uvc.c      **** static void
4229:../uvc.c      **** CyFxUvcAppGpifInit (
4230:../uvc.c      ****         void)
4231:../uvc.c      **** {
4232:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
4233:../uvc.c      **** 
4234:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
4235:../uvc.c      ****     {
4236:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
4237:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
4238:../uvc.c      ****     }
4239:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
4240:../uvc.c      ****     {
4241:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
4242:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
4243:../uvc.c      ****     }
4244:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4245:../uvc.c      ****     {
4246:../uvc.c      ****         /* Error Handling */
4247:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
4248:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4249:../uvc.c      ****     }
4250:../uvc.c      **** 
4251:../uvc.c      ****     /* Start the state machine from the designated start state. */
4252:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
4253:../uvc.c      ****     {
4254:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
4255:../uvc.c      ****     }
4256:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
4257:../uvc.c      ****     {
4258:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
4259:../uvc.c      ****     }
4260:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
4261:../uvc.c      ****     {
4262:../uvc.c      ****         /* Error Handling */
4263:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
4264:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
4265:../uvc.c      ****     }
4266:../uvc.c      **** }
4267:../uvc.c      **** 
4268:../uvc.c      **** /*
4269:../uvc.c      ****  * Entry function for the UVC Application Thread
4270:../uvc.c      ****  */
4271:../uvc.c      **** 
4272:../uvc.c      **** uint32_t posTick;
4273:../uvc.c      **** CyU3PTimer I2CCmdTimer;
4274:../uvc.c      **** 
4275:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 4275 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
4276:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 4276 0
  28 0000 28209FE5 		ldr	r2, .L2
4275:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 4275 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 4276 0
  36 0008 002092E5 		ldr	r2, [r2]
4275:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 4275 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 4276 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
4277:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 4277 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
4278:../uvc.c      **** }
  49              		.loc 1 4278 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
4277:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 4277 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
4279:../uvc.c      **** 
4280:../uvc.c      **** 
4281:../uvc.c      **** void
4282:../uvc.c      **** UVCAppThread_Entry (
4283:../uvc.c      ****         uint32_t input)
4284:../uvc.c      **** {
4285:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
4286:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
4287:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
4288:../uvc.c      ****     uint8_t i = 0;
4289:../uvc.c      ****     uint32_t flag;
4290:../uvc.c      ****     uint32_t prinflag = 0;
4291:../uvc.c      **** static uint8_t IMcount = 0;
4292:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
4293:../uvc.c      ****     uint32_t frameCnt = 0;
4294:../uvc.c      **** #endif
4295:../uvc.c      ****     /* Initialize the Uart Debug Module */
4296:../uvc.c      ****     CyFxUVCApplnDebugInit ();
4297:../uvc.c      **** 
4298:../uvc.c      ****     /* Initialize the I2C interface */
4299:../uvc.c      **** 	while (i++ < 6){
4300:../uvc.c      **** 		CyU3PThreadSleep(500);
4301:../uvc.c      **** 	}
4302:../uvc.c      **** 
4303:../uvc.c      ****     CyFxUVCApplnI2CInit ();
4304:../uvc.c      **** 
4305:../uvc.c      ****     /* Initialize the UVC Application */
4306:../uvc.c      ****     CyFxUVCApplnInit ();
4307:../uvc.c      ****     /*
4308:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
4309:../uvc.c      **** 
4310:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
4311:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
4312:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
4313:../uvc.c      **** 
4314:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
4315:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
4316:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
4317:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
4318:../uvc.c      **** 
4319:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
4320:../uvc.c      ****        of handling the abort request.
4321:../uvc.c      ****      */
4322:../uvc.c      **** 
4323:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
4324:../uvc.c      ****     //CyU3PThreadSleep(1000);
4325:../uvc.c      **** 
4326:../uvc.c      ****     for (;;)
4327:../uvc.c      ****     {
4328:../uvc.c      ****         /* Waiting for the Video Stream Event */
4329:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
4330:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
4331:../uvc.c      ****         {
4332:../uvc.c      **** #if 0 //test for new firmware no video bring up
4333:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
4334:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
4335:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
4336:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
4337:../uvc.c      ****             {
4338:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
4339:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
4340:../uvc.c      ****                 {
4341:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
4342:../uvc.c      **** #ifdef  USB_LOWRES_IMG
4343:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
4344:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
4345:../uvc.c      **** #endif
4346:../uvc.c      **** #endif
4347:../uvc.c      ****                     }
4348:../uvc.c      ****                 else
4349:../uvc.c      ****                 {
4350:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
4351:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
4352:../uvc.c      **** #ifdef USB_LOWRES_IMG
4353:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
4354:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4355:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
4356:../uvc.c      **** #endif
4357:../uvc.c      **** #endif
4358:../uvc.c      ****                 }
4359:../uvc.c      **** 
4360:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
4361:../uvc.c      ****                 prodCount++;
4362:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
4363:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
4364:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
4365:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4366:../uvc.c      ****                 {
4367:../uvc.c      ****                     prodCount--;
4368:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
4369:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
4370:../uvc.c      ****                 }
4371:../uvc.c      ****             }
4372:../uvc.c      **** #endif
4373:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
4374:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
4375:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
4376:../uvc.c      ****             {
4377:../uvc.c      ****             	if(0&&(prinflag == 0)){
4378:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
4379:../uvc.c      ****             		prinflag = 1;
4380:../uvc.c      ****             	}
4381:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
4382:../uvc.c      ****             	fb=0;
4383:../uvc.c      ****             	pb=0;
4384:../uvc.c      ****             	pbc=0;
4385:../uvc.c      ****                 prodCount = 0;
4386:../uvc.c      ****                 consCount = 0;
4387:../uvc.c      ****                 hitFV     = CyFalse;
4388:../uvc.c      **** 
4389:../uvc.c      **** #ifdef BACKFLOW_DETECT
4390:../uvc.c      ****                 back_flow_detected = 0;
4391:../uvc.c      **** #endif
4392:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
4393:../uvc.c      ****                 frameCnt++;
4394:../uvc.c      **** #endif
4395:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
4396:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
4397:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
4398:../uvc.c      ****                 //}
4399:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
4400:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
4401:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
4402:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
4403:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4404:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
4405:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
4406:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
4407:../uvc.c      ****                      	//CyU3PThreadSleep(100);
4408:../uvc.c      ****                 		stiflag = 0xFF;
4409:../uvc.c      ****                 		IMcount = 0;
4410:../uvc.c      ****                 	}
4411:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
4412:../uvc.c      **** 
4413:../uvc.c      ****                  		if(IMcount++ >= 0x3){
4414:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
4415:../uvc.c      ****                 		stiflag = 0x0F;
4416:../uvc.c      ****                 		IMcount = 0;
4417:../uvc.c      ****                 		}
4418:../uvc.c      ****                  		/*if(IMcount > 0x4){
4419:../uvc.c      ****                 			stiflag = 0x0F;
4420:../uvc.c      ****                 			IMcount = 0;
4421:../uvc.c      ****                 		}*/
4422:../uvc.c      **** 
4423:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
4424:../uvc.c      ****                     //CyU3PThreadSleep(400);
4425:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
4426:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
4427:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
4428:../uvc.c      **** 
4429:../uvc.c      ****                 	if(IMcount++ >= 0x3)
4430:../uvc.c      ****                 	{
4431:../uvc.c      ****                     switch (setRes)
4432:../uvc.c      ****                      {
4433:../uvc.c      ****                  	case 1: //1944
4434:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
4435:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4436:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
4437:../uvc.c      ****                  		break;
4438:../uvc.c      ****                  	case 2: //1080
4439:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
4440:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4441:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
4442:../uvc.c      ****                  		break;
4443:../uvc.c      ****                  	case 3: //720
4444:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
4445:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4446:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
4447:../uvc.c      ****                  		break;
4448:../uvc.c      ****                  	case 4: //VGA
4449:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
4450:../uvc.c      ****                  		//CyU3PThreadSleep(100);
4451:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
4452:../uvc.c      ****                  		break;
4453:../uvc.c      ****                  	default:
4454:../uvc.c      ****                  		break;
4455:../uvc.c      ****                      }
4456:../uvc.c      ****                     IMcount = 0;
4457:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
4458:../uvc.c      ****                 	stiflag = 0x0;
4459:../uvc.c      ****                 	}
4460:../uvc.c      ****                 }
4461:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
4462:../uvc.c      ****                 /* Reset the DMA channel. */
4463:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
4464:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4465:../uvc.c      ****                 {
4466:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
4467:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4468:../uvc.c      ****                 }
4469:../uvc.c      **** 
4470:../uvc.c      ****                 /* Start Channel Immediately */
4471:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
4472:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4473:../uvc.c      ****                 {
4474:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
4475:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4476:../uvc.c      ****                 }
4477:../uvc.c      **** 
4478:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
4479:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
4480:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
4481:../uvc.c      ****                 }
4482:../uvc.c      ****         }
4483:../uvc.c      ****         else
4484:../uvc.c      ****         {
4485:../uvc.c      ****             /* If we have a stream abort request pending. */
4486:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
4487:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
4488:../uvc.c      ****             {
4489:../uvc.c      ****                 hitFV     = CyFalse;
4490:../uvc.c      ****                 prodCount = 0;
4491:../uvc.c      ****                 consCount = 0;
4492:../uvc.c      ****                 if(0&&(prinflag == 0)){
4493:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
4494:../uvc.c      ****                 	prinflag = 1;
4495:../uvc.c      ****                 }
4496:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
4497:../uvc.c      ****                 fb=0;
4498:../uvc.c      ****                 pb=0;
4499:../uvc.c      ****                 pbc=0;
4500:../uvc.c      **** 
4501:../uvc.c      ****                 if (!clearFeatureRqtReceived)
4502:../uvc.c      ****                 {
4503:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
4504:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
4505:../uvc.c      ****                     {
4506:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
4507:../uvc.c      ****                     }
4508:../uvc.c      **** 
4509:../uvc.c      ****                     /* Flush the Endpoint memory */
4510:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
4511:../uvc.c      ****                 }
4512:../uvc.c      **** 
4513:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
4514:../uvc.c      ****             }
4515:../uvc.c      ****             else
4516:../uvc.c      ****             {
4517:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
4518:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
4519:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
4520:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
4521:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
4522:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
4523:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4524:../uvc.c      ****                 {
4525:../uvc.c      ****                     /* Error handling */
4526:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
4527:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4528:../uvc.c      ****                 }
4529:../uvc.c      **** 
4530:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
4531:../uvc.c      ****                 if (gpif_initialized == CyFalse)
4532:../uvc.c      ****                 {
4533:../uvc.c      **** #if 0
4534:../uvc.c      ****                 	//for start up of the AF Lens
4535:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
4536:../uvc.c      ****                     CyU3PThreadSleep(500);
4537:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
4538:../uvc.c      ****                     CyU3PThreadSleep(500);
4539:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
4540:../uvc.c      ****                    	CyU3PThreadSleep(300);
4541:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
4542:../uvc.c      ****                     CyU3PThreadSleep(500);
4543:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
4544:../uvc.c      ****                     CyU3PThreadSleep(500);
4545:../uvc.c      **** #endif
4546:../uvc.c      **** #if 0
4547:../uvc.c      ****                     switch (setRes)
4548:../uvc.c      ****                     {
4549:../uvc.c      ****                     	case 1: //1944
4550:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4551:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4552:../uvc.c      ****                     		break;
4553:../uvc.c      ****                     	case 2: //1080
4554:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4555:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4556:../uvc.c      ****                     		break;
4557:../uvc.c      ****                     	case 3: //720
4558:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
4559:../uvc.c      ****                     		CyU3PThreadSleep(1000);
4560:../uvc.c      ****                     		break;
4561:../uvc.c      ****                     	default:
4562:../uvc.c      ****                     		break;
4563:../uvc.c      ****                     }
4564:../uvc.c      **** #endif
4565:../uvc.c      ****                     CyFxUvcAppGpifInit ();
4566:../uvc.c      **** 
4567:../uvc.c      ****                     gpif_initialized = CyTrue;
4568:../uvc.c      ****                     CyU3PThreadSleep(200);
4569:../uvc.c      ****                     
4570:../uvc.c      ****                 }
4571:../uvc.c      ****                 else
4572:../uvc.c      ****                 {
4573:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
4574:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
4575:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
4576:../uvc.c      ****                 }
4577:../uvc.c      ****             }
4578:../uvc.c      ****         }
4579:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
4580:../uvc.c      **** 
4581:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
4582:../uvc.c      ****         CyU3PThreadRelinquish ();
4583:../uvc.c      ****     }
4584:../uvc.c      **** }
4585:../uvc.c      **** 
4586:../uvc.c      **** /*
4587:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
4588:../uvc.c      ****  */
4589:../uvc.c      **** 
4590:../uvc.c      **** static void
4591:../uvc.c      **** UVCHandleProcessingUnitRqts (
4592:../uvc.c      ****         void)
4593:../uvc.c      **** {
4594:../uvc.c      ****     uint8_t CtrlAdd;
4595:../uvc.c      **** #ifdef DbgInfo
4596:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4597:../uvc.c      **** #endif
4598:../uvc.c      ****     switch (wValue)
4599:../uvc.c      ****     {
4600:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
4601:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
4602:../uvc.c      ****     		ControlHandle(BLCCtlID0);
4603:../uvc.c      ****     		break;
4604:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
4605:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
4606:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
4607:../uvc.c      ****     		break;
4608:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
4609:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
4610:../uvc.c      **** 			ControlHandle(ConsCtlID2);
4611:../uvc.c      **** 			break;
4612:../uvc.c      **** 
4613:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
4614:../uvc.c      **** 
4615:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
4616:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
4617:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
4618:../uvc.c      ****       		break;
4619:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
4620:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
4621:../uvc.c      ****      		ControlHandle(HueCtlID5);
4622:../uvc.c      ****      		break;
4623:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
4624:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
4625:../uvc.c      ****           		ControlHandle(SaturCtlID6);
4626:../uvc.c      ****           		break;
4627:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
4628:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
4629:../uvc.c      ****           		ControlHandle(ShapCtlID7);
4630:../uvc.c      ****           		break;
4631:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
4632:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
4633:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
4634:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
4635:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
4636:../uvc.c      ****     		break;
4637:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
4638:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
4639:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
4640:../uvc.c      ****     		break;
4641:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
4642:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
4643:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
4644:../uvc.c      ****     		break;
4645:../uvc.c      **** 
4646:../uvc.c      ****         default:
4647:../uvc.c      ****             /*
4648:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4649:../uvc.c      ****              * other controls.
4650:../uvc.c      ****              */
4651:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4652:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4653:../uvc.c      ****             break;
4654:../uvc.c      ****     }
4655:../uvc.c      **** }
4656:../uvc.c      **** 
4657:../uvc.c      **** /*
4658:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
4659:../uvc.c      ****  */
4660:../uvc.c      **** static void
4661:../uvc.c      **** UVCHandleCameraTerminalRqts (
4662:../uvc.c      ****         void)
4663:../uvc.c      **** {
4664:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4665:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4666:../uvc.c      ****     uint16_t readCount;
4667:../uvc.c      ****     uint16_t zoomVal;
4668:../uvc.c      ****     int32_t  panVal, tiltVal;
4669:../uvc.c      ****     CyBool_t sendData = CyFalse;
4670:../uvc.c      **** #endif
4671:../uvc.c      ****     uint8_t CtrlAdd;
4672:../uvc.c      **** 
4673:../uvc.c      ****     switch (wValue)
4674:../uvc.c      ****     {
4675:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
4676:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
4677:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
4678:../uvc.c      ****     		break;
4679:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
4680:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
4681:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
4682:../uvc.c      ****     		break;
4683:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
4684:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
4685:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
4686:../uvc.c      **** 			break;
4687:../uvc.c      **** 
4688:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4689:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4690:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4691:../uvc.c      **** 			break;
4692:../uvc.c      **** 
4693:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4694:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4695:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4696:../uvc.c      ****       		break;
4697:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4698:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4699:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4700:../uvc.c      ****      		break;
4701:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4702:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4703:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4704:../uvc.c      ****           		break;
4705:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4706:../uvc.c      ****           		break;
4707:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4708:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4709:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4710:../uvc.c      ****      		break;
4711:../uvc.c      **** 
4712:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4713:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4714:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4715:../uvc.c      ****     		break;
4716:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4717:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4718:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4719:../uvc.c      ****     		break;
4720:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4721:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4722:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4723:../uvc.c      ****     		break;
4724:../uvc.c      **** 
4725:../uvc.c      ****         default:
4726:../uvc.c      ****             /*
4727:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4728:../uvc.c      ****              * other controls.
4729:../uvc.c      ****              */
4730:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4731:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4732:../uvc.c      ****             break;
4733:../uvc.c      ****     }
4734:../uvc.c      **** 
4735:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4736:../uvc.c      ****     switch (wValue)
4737:../uvc.c      ****     {
4738:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4739:../uvc.c      ****             switch (bRequest)
4740:../uvc.c      ****             {
4741:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4742:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4743:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4744:../uvc.c      ****                     break;
4745:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4746:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4747:../uvc.c      ****                     sendData = CyTrue;
4748:../uvc.c      ****                     break;
4749:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4750:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4751:../uvc.c      ****                     sendData = CyTrue;
4752:../uvc.c      ****                     break;
4753:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4754:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4755:../uvc.c      ****                     sendData = CyTrue;
4756:../uvc.c      ****                     break;
4757:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4758:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4759:../uvc.c      ****                     sendData = CyTrue;
4760:../uvc.c      ****                     break;
4761:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4762:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4763:../uvc.c      ****                     sendData = CyTrue;
4764:../uvc.c      ****                     break;
4765:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4766:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4767:../uvc.c      ****                             glEp0Buffer, &readCount);
4768:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4769:../uvc.c      ****                     {
4770:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4771:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4772:../uvc.c      ****                     }
4773:../uvc.c      ****                     break;
4774:../uvc.c      ****                 default:
4775:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4776:../uvc.c      ****                     break;
4777:../uvc.c      ****             }
4778:../uvc.c      **** 
4779:../uvc.c      ****             if (sendData)
4780:../uvc.c      ****             {
4781:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4782:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4783:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4784:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4785:../uvc.c      ****             }
4786:../uvc.c      ****             break;
4787:../uvc.c      **** 
4788:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4789:../uvc.c      ****             switch (bRequest)
4790:../uvc.c      ****             {
4791:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4792:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4793:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4794:../uvc.c      ****                     break;
4795:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4796:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4797:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4798:../uvc.c      ****                     sendData = CyTrue;
4799:../uvc.c      ****                     break;
4800:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4801:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4802:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4803:../uvc.c      ****                     sendData = CyTrue;
4804:../uvc.c      ****                     break;
4805:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4806:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4807:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4808:../uvc.c      ****                     sendData = CyTrue;
4809:../uvc.c      ****                     break;
4810:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4811:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4812:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4813:../uvc.c      ****                     sendData = CyTrue;
4814:../uvc.c      ****                     break;
4815:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4816:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4817:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4818:../uvc.c      ****                     sendData = CyTrue;
4819:../uvc.c      ****                     break;
4820:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4821:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4822:../uvc.c      ****                             glEp0Buffer, &readCount);
4823:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4824:../uvc.c      ****                     {
4825:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4826:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4827:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4828:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4829:../uvc.c      **** 
4830:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4831:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4832:../uvc.c      ****                     }
4833:../uvc.c      ****                     break;
4834:../uvc.c      ****                 default:
4835:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4836:../uvc.c      ****                     break;
4837:../uvc.c      ****             }
4838:../uvc.c      **** 
4839:../uvc.c      ****             if (sendData)
4840:../uvc.c      ****             {
4841:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4842:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4843:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4844:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4845:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4846:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4847:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4848:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4849:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4850:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4851:../uvc.c      ****             }
4852:../uvc.c      ****             break;
4853:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4854:../uvc.c      ****         default:
4855:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4856:../uvc.c      ****             break;
4857:../uvc.c      ****     }
4858:../uvc.c      **** #endif
4859:../uvc.c      **** }
4860:../uvc.c      **** 
4861:../uvc.c      **** /*
4862:../uvc.c      ****  * Handler for UVC Interface control requests.
4863:../uvc.c      ****  */
4864:../uvc.c      **** static void
4865:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4866:../uvc.c      ****         void)
4867:../uvc.c      **** {
4868:../uvc.c      **** 
4869:../uvc.c      ****     switch (wValue)
4870:../uvc.c      ****     {
4871:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4872:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4873:../uvc.c      ****     		break;
4874:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4875:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4876:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4877:../uvc.c      ****     		break;
4878:../uvc.c      ****     	default:
4879:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4880:../uvc.c      ****      		break;
4881:../uvc.c      ****     }
4882:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4883:../uvc.c      **** 
4884:../uvc.c      **** }
4885:../uvc.c      **** 
4886:../uvc.c      **** /*
4887:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4888:../uvc.c      ****  */
4889:../uvc.c      **** static void
4890:../uvc.c      **** UVCHandleExtensionUnitRqts (
4891:../uvc.c      ****         void)
4892:../uvc.c      **** {
4893:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4894:../uvc.c      **** 
4895:../uvc.c      **** #ifdef DbgInfo
4896:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4897:../uvc.c      **** #endif
4898:../uvc.c      ****     switch (wValue)
4899:../uvc.c      ****     {
4900:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4901:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4902:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4903:../uvc.c      ****     		break;
4904:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4905:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4906:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4907:../uvc.c      ****     		break;
4908:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4909:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4910:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4911:../uvc.c      ****      		break;
4912:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4913:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4914:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4915:../uvc.c      ****     		break;
4916:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4917:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4918:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4919:../uvc.c      ****     		break;
4920:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4921:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4922:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4923:../uvc.c      ****      		break;
4924:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4925:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4926:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4927:../uvc.c      ****     		break;
4928:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4929:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4930:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4931:../uvc.c      ****     		break;
4932:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4933:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4934:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4935:../uvc.c      ****      		break;
4936:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4937:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4938:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4939:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4940:../uvc.c      ****     		}else/* no support for 1080p camera */
4941:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4942:../uvc.c      ****     		break;
4943:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4944:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4945:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4946:../uvc.c      ****     		break;
4947:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4948:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4949:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4950:../uvc.c      ****     		break;
4951:../uvc.c      **** 
4952:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4953:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4954:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4955:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4956:../uvc.c      ****     		break;
4957:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4958:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4959:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4960:../uvc.c      ****     		//break;
4961:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4962:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4963:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4964:../uvc.c      ****     		break;
4965:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4966:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4967:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4968:../uvc.c      ****     		break;
4969:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4970:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4971:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4972:../uvc.c      ****     		break;
4973:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4974:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4975:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4976:../uvc.c      ****     		break;
4977:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4978:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4979:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4980:../uvc.c      ****     		break;
4981:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4982:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4983:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4984:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4985:../uvc.c      ****     		break;
4986:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4987:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4988:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4989:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4990:../uvc.c      ****     		break;
4991:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4992:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4993:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4994:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4995:../uvc.c      ****     		break;
4996:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4997:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4998:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4999:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
5000:../uvc.c      ****    		break;
5001:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
5002:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
5003:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
5004:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
5005:../uvc.c      ****     		break;
5006:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
5007:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
5008:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
5009:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
5010:../uvc.c      ****     		break;
5011:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
5012:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
5013:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
5014:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
5015:../uvc.c      ****     		break;
5016:../uvc.c      **** 
5017:../uvc.c      ****    	default:
5018:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
5019:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
5020:../uvc.c      ****     		break;
5021:../uvc.c      ****     }
5022:../uvc.c      **** 
5023:../uvc.c      **** }
5024:../uvc.c      **** 
5025:../uvc.c      **** /*
5026:../uvc.c      ****  * Handler for the video streaming control requests.
5027:../uvc.c      ****  */
5028:../uvc.c      **** static void
5029:../uvc.c      **** UVCHandleVideoStreamingRqts (
5030:../uvc.c      ****         void)
5031:../uvc.c      **** {
  67              		.loc 1 5031 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
5032:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
5033:../uvc.c      ****     uint16_t readCount;
5034:../uvc.c      **** 
5035:../uvc.c      ****     switch (wValue)
  72              		.loc 1 5035 0
  73 003c A8369FE5 		ldr	r3, .L133
5031:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 5031 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 5035 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
5031:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 5031 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 5035 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
5036:../uvc.c      ****     {
5037:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
5038:../uvc.c      ****             switch (bRequest)
5039:../uvc.c      ****             {
5040:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
5041:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
5042:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5043:../uvc.c      ****                     break;
5044:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
5045:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5046:../uvc.c      ****                     glEp0Buffer[1] = 0;
5047:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5048:../uvc.c      ****                     break;
5049:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
5050:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
5051:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
5052:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
5053:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
5054:../uvc.c      ****                     {
5055:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
5056:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
5057:../uvc.c      **** 
5058:../uvc.c      ****                     }
5059:../uvc.c      ****                     else
5060:../uvc.c      ****                     {
5061:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
5062:../uvc.c      ****                     }
5063:../uvc.c      ****                     break;
5064:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
5065:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5066:../uvc.c      ****                             glCommitCtrl, &readCount);
5067:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
5068:../uvc.c      ****                     {
5069:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5070:../uvc.c      ****                         {
5071:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
5072:../uvc.c      ****                                active data structure. */
5073:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
5074:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
5075:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
5076:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
5077:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
5078:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
5079:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
5080:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
5081:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
5082:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
5083:../uvc.c      **** #if 0
5084:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
5085:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
5086:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
5087:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
5088:../uvc.c      **** #endif
5089:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
5090:../uvc.c      ****                        }
5091:../uvc.c      ****                     }
5092:../uvc.c      ****                     break;
5093:../uvc.c      ****                 default:
5094:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5095:../uvc.c      ****                     break;
5096:../uvc.c      ****             }
5097:../uvc.c      ****             break;
5098:../uvc.c      **** 
5099:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
5100:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 5100 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
5101:../uvc.c      ****             {
5102:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
5103:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
5104:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5105:../uvc.c      ****                     break;
5106:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
5107:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5108:../uvc.c      ****                     glEp0Buffer[1] = 0;
5109:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5110:../uvc.c      ****                     break;
5111:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
5112:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
5113:../uvc.c      ****                     {
5114:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
5115:../uvc.c      ****                     }
5116:../uvc.c      ****                     else
5117:../uvc.c      ****                     {
5118:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
5119:../uvc.c      ****                     }
5120:../uvc.c      ****                     break;
5121:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
5122:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
5123:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
5124:../uvc.c      ****                        */
5125:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5126:../uvc.c      ****                             glCommitCtrl, &readCount);
5127:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
5128:../uvc.c      ****                     {
5129:../uvc.c      ****                         switch (glCommitCtrl[3])
5130:../uvc.c      ****                          {
5131:../uvc.c      ****                          	case 1: //1944
5132:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
5133:../uvc.c      ****                          		CyU3PThreadSleep(500);
5134:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
5135:../uvc.c      ****                          		break;
5136:../uvc.c      ****                          	case 2: //1080
5137:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
5138:../uvc.c      ****                          		CyU3PThreadSleep(500);
5139:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
5140:../uvc.c      ****                          		break;
5141:../uvc.c      ****                          	case 3: //720
5142:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
5143:../uvc.c      ****                          		CyU3PThreadSleep(500);
5144:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
5145:../uvc.c      ****                          		break;
5146:../uvc.c      ****                          	case 4: //VGA
5147:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
5148:../uvc.c      ****                          		CyU3PThreadSleep(500);
5149:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
5150:../uvc.c      ****                          		break;
5151:../uvc.c      ****                          	default:
5152:../uvc.c      ****                          		break;
5153:../uvc.c      ****                          }
5154:../uvc.c      ****                         setRes = glCommitCtrl[3];
5155:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
5156:../uvc.c      **** 
5157:../uvc.c      **** #if 0
5158:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
5159:../uvc.c      ****                         {
5160:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
5161:../uvc.c      ****                         }
5162:../uvc.c      ****                         else
5163:../uvc.c      ****                         {
5164:../uvc.c      ****                             SensorScaling_VGA ();
5165:../uvc.c      ****                         }
5166:../uvc.c      **** #endif
5167:../uvc.c      ****                         /* We can start streaming video now. */
5168:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
5169:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
5170:../uvc.c      ****                         {
5171:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
5172:../uvc.c      ****                         }
5173:../uvc.c      ****                     }
5174:../uvc.c      ****                     break;
5175:../uvc.c      **** 
5176:../uvc.c      ****                 default:
5177:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5178:../uvc.c      ****                     break;
5179:../uvc.c      ****             }
5180:../uvc.c      ****             break;
5181:../uvc.c      **** 
5182:../uvc.c      **** /* still image streaming handler */
5183:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
5184:../uvc.c      ****                 switch (bRequest)
5185:../uvc.c      ****                 {
5186:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5187:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
5188:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5189:../uvc.c      ****                         break;
5190:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5191:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5192:../uvc.c      ****                         glEp0Buffer[1] = 0;
5193:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5194:../uvc.c      ****                         break;
5195:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
5196:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
5197:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
5198:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
5199:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5200:../uvc.c      ****                         {
5201:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5202:../uvc.c      ****                         }
5203:../uvc.c      ****                         else
5204:../uvc.c      ****                         {
5205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5206:../uvc.c      ****                         }
5207:../uvc.c      ****                         break;
5208:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5209:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5210:../uvc.c      ****                                 glCommitCtrl, &readCount);
5211:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5212:../uvc.c      ****                         {
5213:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
5214:../uvc.c      ****                             {
5215:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
5216:../uvc.c      ****                                    active data structure. */
5217:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
5218:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
5219:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
5220:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
5221:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
5222:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
5223:../uvc.c      ****                             }
5224:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
5225:../uvc.c      ****                         }
5226:../uvc.c      ****                         break;
5227:../uvc.c      ****                     default:
5228:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5229:../uvc.c      ****                         break;
5230:../uvc.c      ****                 }
5231:../uvc.c      ****                 break;
5232:../uvc.c      **** 
5233:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
5234:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 5234 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
5235:../uvc.c      ****                 {
5236:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5237:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
5238:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
5239:../uvc.c      ****                         break;
5240:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5241:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
5242:../uvc.c      ****                         glEp0Buffer[1] = 0;
5243:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5244:../uvc.c      ****                         break;
5245:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
5246:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5247:../uvc.c      ****                         {
5248:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5249:../uvc.c      ****                         }
5250:../uvc.c      ****                         else
5251:../uvc.c      ****                         {
5252:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
5253:../uvc.c      ****                         }
5254:../uvc.c      ****                         break;
5255:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5256:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
5257:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
5258:../uvc.c      ****                            */
5259:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5260:../uvc.c      ****                                 glCommitCtrl, &readCount);
5261:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5262:../uvc.c      ****                         {
5263:../uvc.c      ****     #if 0
5264:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
5265:../uvc.c      ****                             {
5266:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
5267:../uvc.c      ****                             }
5268:../uvc.c      ****                             else
5269:../uvc.c      ****                             {
5270:../uvc.c      ****                                 SensorScaling_VGA ();
5271:../uvc.c      ****                             }
5272:../uvc.c      ****                             /* We can start streaming video now. */
5273:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
5274:../uvc.c      **** 
5275:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
5276:../uvc.c      ****                             {
5277:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
5278:../uvc.c      ****                             }
5279:../uvc.c      **** 	#endif
5280:../uvc.c      ****                            switch (glCommitCtrl[1])
5281:../uvc.c      ****                              {
5282:../uvc.c      ****                              	case 4: //1944
5283:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
5284:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5285:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
5286:../uvc.c      ****                              		break;
5287:../uvc.c      ****                              	case 3: //1080
5288:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
5289:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5290:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
5291:../uvc.c      ****                              		break;
5292:../uvc.c      ****                              	case 2: //720
5293:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
5294:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5295:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
5296:../uvc.c      ****                              		break;
5297:../uvc.c      ****                             	case 1: //VGA
5298:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
5299:../uvc.c      ****                              		//CyU3PThreadSleep(500);
5300:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
5301:../uvc.c      ****                              		break;
5302:../uvc.c      ****                               	default:
5303:../uvc.c      ****                              		break;
5304:../uvc.c      ****                              }
5305:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
5306:../uvc.c      **** 
5307:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
5308:../uvc.c      **** 
5309:../uvc.c      ****                         }
5310:../uvc.c      ****                         break;
5311:../uvc.c      **** 
5312:../uvc.c      ****                     default:
5313:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5314:../uvc.c      ****                         break;
5315:../uvc.c      ****                 }
5316:../uvc.c      ****                 break;
5317:../uvc.c      **** 
5318:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
5319:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
5320:../uvc.c      ****             	switch (bRequest)
5321:../uvc.c      ****                 {
5322:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
5323:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 5323 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
5324:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 5324 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
5325:../uvc.c      ****                         break;
5326:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
5327:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
5328:../uvc.c      ****                         glEp0Buffer[1] = 0;
5329:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
5330:../uvc.c      ****                         break;
5331:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
5332:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
5333:../uvc.c      ****                         {
5334:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
5335:../uvc.c      ****                         }
5336:../uvc.c      ****                         else
5337:../uvc.c      ****                         {
5338:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
5339:../uvc.c      ****                         }
5340:../uvc.c      ****                         break;
5341:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
5342:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
5343:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
5344:../uvc.c      ****                            */
5345:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
5346:../uvc.c      ****                                 glCommitCtrl, &readCount);
5347:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
5348:../uvc.c      ****                         {
5349:../uvc.c      ****     #if 1
5350:../uvc.c      ****                             /* We can start still streaming video now. */
5351:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
5352:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
5353:../uvc.c      ****                             {
5354:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
5355:../uvc.c      ****                             }
5356:../uvc.c      ****     #endif
5357:../uvc.c      ****                             else{
5358:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
5359:../uvc.c      ****                             //stillcont = 0;
5360:../uvc.c      ****                             }
5361:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
5362:../uvc.c      ****                         }else{
5363:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
5364:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
5365:../uvc.c      ****                         }
5366:../uvc.c      ****                         break;
5367:../uvc.c      **** 
5368:../uvc.c      ****                     default:
5369:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5370:../uvc.c      ****                         break;
5371:../uvc.c      ****                 }
5372:../uvc.c      ****                 break;
5373:../uvc.c      **** 
5374:../uvc.c      ****         default:
5375:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
5376:../uvc.c      ****             break;
5377:../uvc.c      ****     }
5378:../uvc.c      **** }
 117              		.loc 1 5378 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
5035:../uvc.c      ****     {
 122              		.loc 1 5035 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
5320:../uvc.c      ****                 {
 127              		.loc 1 5320 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
5375:../uvc.c      ****             break;
 138              		.loc 1 5375 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 5378 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
5038:../uvc.c      ****             {
 151              		.loc 1 5038 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
5184:../uvc.c      ****                 {
 161              		.loc 1 5184 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
5241:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 5241 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
5328:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 5328 0
 170 0124 0020A0E3 		mov	r2, #0
5329:../uvc.c      ****                         break;
 171              		.loc 1 5329 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
5327:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 5327 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
5328:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 5328 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
5329:../uvc.c      ****                         break;
 178              		.loc 1 5329 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 5378 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
5234:../uvc.c      ****                 {
 186              		.loc 1 5234 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
5259:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 5259 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
5261:../uvc.c      ****                         {
 201              		.loc 1 5261 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
5280:../uvc.c      ****                              {
 204              		.loc 1 5280 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
5184:../uvc.c      ****                 {
 217              		.loc 1 5184 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
5199:../uvc.c      ****                         {
 227              		.loc 1 5199 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
5201:../uvc.c      ****                         }
 229              		.loc 1 5201 0
 230 01c4 0B00A0E3 		mov	r0, #11
5199:../uvc.c      ****                         {
 231              		.loc 1 5199 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
5201:../uvc.c      ****                         }
 234              		.loc 1 5201 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
5205:../uvc.c      ****                         }
 236              		.loc 1 5205 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
5184:../uvc.c      ****                 {
 242              		.loc 1 5184 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
5209:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 5209 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
5211:../uvc.c      ****                         {
 254              		.loc 1 5211 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
5213:../uvc.c      ****                             {
 257              		.loc 1 5213 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
5217:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 5217 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
5218:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 5218 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
5217:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 5217 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
5218:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 5218 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
5224:../uvc.c      ****                         }
 272              		.loc 1 5224 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
5038:../uvc.c      ****             {
 283              		.loc 1 5038 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
5065:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 5065 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
5067:../uvc.c      ****                     {
 295              		.loc 1 5067 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
5069:../uvc.c      ****                         {
 298              		.loc 1 5069 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
5073:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 5073 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
5074:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 5074 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
5075:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 5075 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
5076:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 5076 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
5077:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 5077 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
5078:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 5078 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
5073:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 5073 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
5074:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 5074 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
5075:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 5075 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
5076:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 5076 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
5077:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 5077 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
5078:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 5078 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
5112:../uvc.c      ****                     {
 331              		.loc 1 5112 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
5061:../uvc.c      ****                     }
 337              		.loc 1 5061 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
5320:../uvc.c      ****                 {
 344              		.loc 1 5320 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
5345:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 5345 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
5347:../uvc.c      ****                         {
 354              		.loc 1 5347 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
5351:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 5351 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
5352:../uvc.c      ****                             {
 363              		.loc 1 5352 0
 364 030c 002050E2 		subs	r2, r0, #0
5358:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 5358 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
5352:../uvc.c      ****                             {
 368              		.loc 1 5352 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
5361:../uvc.c      ****                         }else{
 372              		.loc 1 5361 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
5100:../uvc.c      ****             {
 384              		.loc 1 5100 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
5125:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 5125 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
5127:../uvc.c      ****                     {
 394              		.loc 1 5127 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
5129:../uvc.c      ****                          {
 397              		.loc 1 5129 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
5114:../uvc.c      ****                     }
 410              		.loc 1 5114 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
5147:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 5147 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
5148:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 5148 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
5149:../uvc.c      ****                          		break;
 436              		.loc 1 5149 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
5155:../uvc.c      **** 
 451              		.loc 1 5155 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
5154:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 5154 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
5155:../uvc.c      **** 
 457              		.loc 1 5155 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
5168:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 5168 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
5169:../uvc.c      ****                         {
 466              		.loc 1 5169 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
5171:../uvc.c      ****                         }
 469              		.loc 1 5171 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
5288:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 5288 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
5290:../uvc.c      ****                              		break;
 489              		.loc 1 5290 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
5307:../uvc.c      **** 
 501              		.loc 1 5307 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
5305:../uvc.c      **** 
 506              		.loc 1 5305 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
5307:../uvc.c      **** 
 508              		.loc 1 5307 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
5293:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 5293 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
5295:../uvc.c      ****                              		break;
 529              		.loc 1 5295 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
5300:../uvc.c      ****                              		break;
 537              		.loc 1 5300 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
5301:../uvc.c      ****                               	default:
 544              		.loc 1 5301 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
5298:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 5298 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
5300:../uvc.c      ****                              		break;
 562              		.loc 1 5300 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
5142:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 5142 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
5143:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 5143 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
5144:../uvc.c      ****                          		break;
 590              		.loc 1 5144 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
5137:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 5137 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
5138:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 5138 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
5139:../uvc.c      ****                          		break;
 615              		.loc 1 5139 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
5140:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 5140 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
5132:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 5132 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
5133:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 5133 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
5134:../uvc.c      ****                          		break;
 645              		.loc 1 5134 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
5135:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 5135 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
5283:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 5283 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
5285:../uvc.c      ****                              		break;
 671              		.loc 1 5285 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
5286:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 5286 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
5327:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 5327 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
5053:../uvc.c      ****                     {
 691              		.loc 1 5053 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
5055:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 5055 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
5056:../uvc.c      **** 
 701              		.loc 1 5056 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
5363:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 5363 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
5364:../uvc.c      ****                         }
 718              		.loc 1 5364 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
5354:../uvc.c      ****                             }
 727              		.loc 1 5354 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
5129:../uvc.c      ****                          {
 736              		.loc 1 5129 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
5379:../uvc.c      **** 
5380:../uvc.c      **** /*
5381:../uvc.c      ****  * Entry function for the UVC control request processing thread.
5382:../uvc.c      ****  */
5383:../uvc.c      **** void
5384:../uvc.c      **** UVCAppEP0Thread_Entry (
5385:../uvc.c      ****         uint32_t input)
5386:../uvc.c      **** {
5387:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
5388:../uvc.c      ****     uint32_t eventFlag;
5389:../uvc.c      **** 	CyBool_t value;
5390:../uvc.c      **** 	CyBool_t *valueptr = &value;
5391:../uvc.c      **** 
5392:../uvc.c      **** 
5393:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
5394:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5395:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
5396:../uvc.c      **** 
5397:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
5398:../uvc.c      **** #endif
5399:../uvc.c      **** 
5400:../uvc.c      ****     /* for interrupt status test */
5401:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5402:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
5403:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
5404:../uvc.c      **** 
5405:../uvc.c      ****     for (;;)
5406:../uvc.c      ****     {
5407:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
5408:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
5409:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
5410:../uvc.c      ****         {
5411:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
5412:../uvc.c      ****             if (!isUsbConnected)
5413:../uvc.c      ****             {
5414:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
5415:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
5416:../uvc.c      ****                 {
5417:../uvc.c      ****                     isUsbConnected = CyTrue;
5418:../uvc.c      ****                 }
5419:../uvc.c      ****             }
5420:../uvc.c      **** //#ifdef DbgInfo
5421:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
5422:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
5423:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
5424:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
5425:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
5426:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
5427:../uvc.c      **** //#endif
5428:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
5429:../uvc.c      ****             {
5430:../uvc.c      ****             	switch ((wIndex >> 8))
5431:../uvc.c      ****                 {
5432:../uvc.c      **** 
5433:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
5434:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
5435:../uvc.c      ****                         break;
5436:../uvc.c      **** 
5437:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
5438:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
5439:../uvc.c      ****                         break;
5440:../uvc.c      **** 
5441:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
5442:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
5443:../uvc.c      ****                         break;
5444:../uvc.c      **** 
5445:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
5446:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
5447:../uvc.c      ****                         break;
5448:../uvc.c      **** 
5449:../uvc.c      ****                     default:
5450:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
5451:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
5452:../uvc.c      ****                         break;
5453:../uvc.c      ****                 }
5454:../uvc.c      ****             }
5455:../uvc.c      **** 
5456:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
5457:../uvc.c      ****             {
5458:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
5459:../uvc.c      **** 
5460:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
5461:../uvc.c      ****                 {
5462:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
5463:../uvc.c      ****                 }
5464:../uvc.c      ****                 else
5465:../uvc.c      ****                 {
5466:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
5467:../uvc.c      ****                 }
5468:../uvc.c      ****             }
5469:../uvc.c      **** 
5470:../uvc.c      ****             /* handle interrupt status event */
5471:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
5472:../uvc.c      ****             {
5473:../uvc.c      **** 
5474:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
5475:../uvc.c      ****             	/** preparing interrupt status data **/
5476:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
5477:../uvc.c      **** 
5478:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5479:../uvc.c      **** 
5480:../uvc.c      **** #if 0 //for real button
5481:../uvc.c      **** 				if(value&&(!snapButFlag)){
5482:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5483:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5484:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5485:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5486:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
5487:../uvc.c      **** 
5488:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5489:../uvc.c      **** 					interStabuf.size   = 1024;
5490:../uvc.c      **** 					interStabuf.status = 0;
5491:../uvc.c      **** 
5492:../uvc.c      **** 					interStabuf.count = 4;
5493:../uvc.c      **** 
5494:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5495:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5496:../uvc.c      **** 
5497:../uvc.c      **** 					/** send a interrupt status data **/
5498:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5499:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5500:../uvc.c      **** 					{
5501:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5502:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5503:../uvc.c      **** 					}
5504:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
5505:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
5506:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5507:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5508:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5509:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5510:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
5511:../uvc.c      **** 
5512:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5513:../uvc.c      **** 					interStabuf.size   = 1024;
5514:../uvc.c      **** 					interStabuf.status = 0;
5515:../uvc.c      **** 
5516:../uvc.c      **** 					interStabuf.count = 4;
5517:../uvc.c      **** 
5518:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5519:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5520:../uvc.c      **** 
5521:../uvc.c      **** 					/** send a interrupt status data **/
5522:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5523:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5524:../uvc.c      **** 					{
5525:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5526:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5527:../uvc.c      **** 					}
5528:../uvc.c      **** 
5529:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
5530:../uvc.c      **** 					stiflag = 0xFF;
5531:../uvc.c      **** 				}
5532:../uvc.c      **** #else			//for botton simulation
5533:../uvc.c      **** 				if(snapButFlag == 0x0f){
5534:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5535:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5536:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5537:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5538:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
5539:../uvc.c      **** 
5540:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5541:../uvc.c      **** 					interStabuf.size   = 1024;
5542:../uvc.c      **** 					interStabuf.status = 0;
5543:../uvc.c      **** 
5544:../uvc.c      **** 					interStabuf.count = 4;
5545:../uvc.c      **** 
5546:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5547:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5548:../uvc.c      **** 
5549:../uvc.c      **** 					/** send a interrupt status data **/
5550:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5551:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
5552:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5553:../uvc.c      **** 					{
5554:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5555:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5556:../uvc.c      **** 					}
5557:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
5558:../uvc.c      **** 
5559:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
5560:../uvc.c      **** 				}else if(!snapButFlag){
5561:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
5562:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
5563:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
5564:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
5565:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
5566:../uvc.c      **** 
5567:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
5568:../uvc.c      **** 					interStabuf.size   = 1024;
5569:../uvc.c      **** 					interStabuf.status = 0;
5570:../uvc.c      **** 
5571:../uvc.c      **** 					interStabuf.count = 4;
5572:../uvc.c      **** 
5573:../uvc.c      **** 					/** wait unitll the responses has gone out **/
5574:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
5575:../uvc.c      **** 
5576:../uvc.c      **** 					/** send a interrupt status data **/
5577:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
5578:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
5579:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
5580:../uvc.c      **** 					{
5581:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
5582:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
5583:../uvc.c      **** 					}
5584:../uvc.c      **** 
5585:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
5586:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
5587:../uvc.c      **** 				}
5588:../uvc.c      **** #endif
5589:../uvc.c      **** 
5590:../uvc.c      ****             }
5591:../uvc.c      **** 
5592:../uvc.c      **** 
5593:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
5594:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
5595:../uvc.c      ****             {
5596:../uvc.c      ****                 /* Get the command buffer */
5597:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
5598:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5599:../uvc.c      ****                 {
5600:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
5601:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5602:../uvc.c      ****                 }
5603:../uvc.c      **** 
5604:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
5605:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
5606:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
5607:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
5608:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
5609:../uvc.c      ****                  * register value high byte and register value low byte.
5610:../uvc.c      ****                  */
5611:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
5612:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
5613:../uvc.c      ****                 {
5614:../uvc.c      ****                     if (dmaInfo.count == 3)
5615:../uvc.c      ****                     {
5616:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
5617:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
5618:../uvc.c      ****                         dmaInfo.count = 3;
5619:../uvc.c      ****                     }
5620:../uvc.c      ****                     else if (dmaInfo.count == 4)
5621:../uvc.c      ****                     {
5622:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
5623:../uvc.c      ****                         {
5624:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
5625:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
5626:../uvc.c      ****                         }
5627:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
5628:../uvc.c      ****                     }
5629:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
5630:../uvc.c      ****                 }
5631:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
5632:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
5633:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
5634:../uvc.c      ****                  */
5635:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
5636:../uvc.c      ****                 {
5637:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
5638:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
5639:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
5640:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
5641:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
5642:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
5643:../uvc.c      ****                         	break;
5644:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
5645:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
5646:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
5647:../uvc.c      ****                         	break;*/
5648:../uvc.c      ****                     dmaInfo.count -= 2;
5649:../uvc.c      ****                 }
5650:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
5651:../uvc.c      ****                 else
5652:../uvc.c      ****                 {
5653:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
5654:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
5655:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
5656:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
5657:../uvc.c      ****                 }
5658:../uvc.c      **** 
5659:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
5660:../uvc.c      ****                 dmaInfo.size   = 1024;
5661:../uvc.c      ****                 dmaInfo.status = 0;
5662:../uvc.c      **** 
5663:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
5664:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
5665:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5666:../uvc.c      ****                 {
5667:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
5668:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5669:../uvc.c      ****                 }
5670:../uvc.c      **** 
5671:../uvc.c      ****                 /* Wait until the response has gone out. */
5672:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
5673:../uvc.c      **** 
5674:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
5675:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5676:../uvc.c      ****                 {
5677:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
5678:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5679:../uvc.c      ****                 }
5680:../uvc.c      ****             }
5681:../uvc.c      **** #endif
5682:../uvc.c      ****         }
5683:../uvc.c      ****         /* Allow other ready threads to run. */
5684:../uvc.c      ****         CyU3PThreadRelinquish ();
5685:../uvc.c      ****     }
5686:../uvc.c      **** }
5687:../uvc.c      **** 
5688:../uvc.c      **** /*
5689:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5690:../uvc.c      ****  * added 10/2013
5691:../uvc.c      ****  */
5692:../uvc.c      **** /*
5693:../uvc.c      **** static uint8_t timeDelay[64] = {
5694:../uvc.c      **** 
5695:../uvc.c      **** };
5696:../uvc.c      **** */
5697:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5697 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5698:../uvc.c      **** 
5699:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5700:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5701:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5702:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5703:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5704:../uvc.c      **** 	uint32_t flag = 0;
5705:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5706:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5707:../uvc.c      **** 	uint8_t i;
5708:../uvc.c      **** 	uint16_t delaytime;
5709:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5710:../uvc.c      **** 
5711:../uvc.c      **** #if 0 //for test the command queue
5712:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5713:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5714:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5715:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5716:../uvc.c      **** 		lcCmdDes += 1;
5717:../uvc.c      **** 	}
5718:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5719:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5720:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5721:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5722:../uvc.c      **** 		lcCmdDes += 1;
5723:../uvc.c      **** 	}
5724:../uvc.c      **** 
5725:../uvc.c      **** #endif
5726:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5727:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5727 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5697:../uvc.c      **** 
 786              		.loc 1 5697 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5704:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5704 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5727 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5704:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5704 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5727 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5728:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5728 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5729:../uvc.c      **** 	CyU3PThreadSleep(50);
5730:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5731:../uvc.c      **** 
5732:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5732 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5728:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5728 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5729:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5729 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5730:../uvc.c      **** 
 823              		.loc 1 5730 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5732 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5733:../uvc.c      ****         /* Allow other ready threads to run. */
5734:../uvc.c      **** 
5735:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5735 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5732:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5732 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5736:../uvc.c      **** 	}
5737:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5737 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5738:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5739:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5740:../uvc.c      **** 	//CyU3PThreadSleep(100);
5741:../uvc.c      **** 	//SetCurCmd();
5742:../uvc.c      **** 	/*********** the loop of the thread ***********/
5743:../uvc.c      **** 	for(;;){
5744:../uvc.c      **** 
5745:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5745 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5746:../uvc.c      **** /*  // for test GPIO output
5747:../uvc.c      **** 		if(trigger)
5748:../uvc.c      **** 		{
5749:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5750:../uvc.c      **** 			{
5751:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5752:../uvc.c      **** 			}
5753:../uvc.c      **** 
5754:../uvc.c      **** 		}else{
5755:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5756:../uvc.c      **** 			{
5757:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5758:../uvc.c      **** 			}
5759:../uvc.c      **** 
5760:../uvc.c      **** 		}
5761:../uvc.c      **** */
5762:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5762 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5763:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5764:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5765:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5766:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5767:../uvc.c      **** 				i = 0;
5768:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5768 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5769:../uvc.c      **** 					i++;
5770:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5771:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5772:../uvc.c      **** 				}
5773:../uvc.c      **** #if 0
5774:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5775:../uvc.c      **** 				i = lcStaDes->curNum;
5776:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5777:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5778:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5779:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5780:../uvc.c      **** 
5781:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5782:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5783:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5784:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5785:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5786:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5787:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5788:../uvc.c      **** #endif
5789:../uvc.c      **** 				//}
5790:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5791:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5792:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5793:../uvc.c      **** 				/* setting delay */
5794:../uvc.c      **** 				delaytime = 300;
5795:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5796:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5797:../uvc.c      **** 			} //end of the if condition statment
5798:../uvc.c      **** #endif
5799:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5799 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5800:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5801:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5801 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5802:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5802 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5803:../uvc.c      **** 
5804:../uvc.c      **** 				/*
5805:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5806:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5807:../uvc.c      **** 				*/
5808:../uvc.c      **** 
5809:../uvc.c      **** 				/* find a available command */
5810:../uvc.c      **** 				i = 0;
5811:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5811 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5811 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5812:../uvc.c      **** 					i++;
5813:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5813 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5811:../uvc.c      **** 					i++;
 905              		.loc 1 5811 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5814:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5815:../uvc.c      **** 				}
5816:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5817:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5818:../uvc.c      **** 					i = lcCmdDes->curNum;
5819:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5820:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5821:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5822:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5823:../uvc.c      **** #if 1
5824:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5824 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5819:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5819 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5820:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5820 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5821:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5821 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5822:../uvc.c      **** #if 1
 927              		.loc 1 5822 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5824 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5825:../uvc.c      **** 						case 0x20:
5826:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5827:../uvc.c      **** 							delaytime = 500;
5828:../uvc.c      **** 							break;
5829:../uvc.c      **** 						case 0x21:
5830:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5831:../uvc.c      **** 							delaytime = 500;
5832:../uvc.c      **** 							break;
5833:../uvc.c      **** 						case 0x22:
5834:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5835:../uvc.c      **** 							delaytime = 300;
5836:../uvc.c      **** 							break;
5837:../uvc.c      **** 						case 0x23:
5838:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5838 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5839:../uvc.c      **** 							delaytime = 300;
5840:../uvc.c      **** 							break;
 945              		.loc 1 5840 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5841:../uvc.c      **** 						default:
5842:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5843:../uvc.c      **** 							break;
5844:../uvc.c      **** 					}
5845:../uvc.c      **** #endif
5846:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5847:../uvc.c      **** 					/** timer's ticket modify **/
5848:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5849:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5849 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5850:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5850 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5851:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5852:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5853:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5854:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5855:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5856:../uvc.c      **** #endif
5857:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5857 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5858:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5859:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5860:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5861:../uvc.c      **** 						}else{
5862:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5863:../uvc.c      **** 						}
5864:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5865:../uvc.c      **** 					}else{
5866:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5866 0
 964 08d4 013083E2 		add	r3, r3, #1
5867:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5867 0
 966 08d8 0F20A0E3 		mov	r2, #15
5866:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5866 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5867 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5868:../uvc.c      **** 					}
5869:../uvc.c      **** 				}else{
5870:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5871:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5872:../uvc.c      **** 				}
5873:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5873 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5874:../uvc.c      **** 			}
5875:../uvc.c      **** /*
5876:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5877:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5878:../uvc.c      **** */
5879:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5880:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5881:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5882:../uvc.c      **** #endif
5883:../uvc.c      **** 
5884:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5885:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5886:../uvc.c      **** #if 0
5887:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5888:../uvc.c      **** 
5889:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5890:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5891:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5892:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5893:../uvc.c      **** 			    i = 0;
5894:../uvc.c      **** 				 switch(cmdCopyIdx)
5895:../uvc.c      **** 				 {
5896:../uvc.c      **** 					 case BrgtCtlID1:
5897:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5898:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5899:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5901:../uvc.c      **** 							 i++;
5902:../uvc.c      **** 						 }
5903:../uvc.c      **** 						 else{
5904:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5905:../uvc.c      **** 						 }
5906:../uvc.c      **** 
5907:../uvc.c      **** 						 CyU3PBusyWait(500);
5908:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5909:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5910:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5911:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5912:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5913:../uvc.c      **** 						 }
5914:../uvc.c      **** 						 else{
5915:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5916:../uvc.c      **** 						 }
5917:../uvc.c      **** 						 break;
5918:../uvc.c      **** 					 case HueCtlID5:
5919:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5920:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5921:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5922:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5923:../uvc.c      **** 						 }
5924:../uvc.c      **** 						 else{
5925:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5926:../uvc.c      **** 						 }
5927:../uvc.c      **** 						 break;
5928:../uvc.c      **** 					 case SaturCtlID6:
5929:../uvc.c      **** 					 case WBTLevCtlID10:
5930:../uvc.c      **** 					 default:
5931:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5932:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5933:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5934:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5935:../uvc.c      **** 						 }
5936:../uvc.c      **** 						 else{
5937:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5938:../uvc.c      **** 						 }
5939:../uvc.c      **** 						 break;
5940:../uvc.c      **** 				 }
5941:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5942:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5943:../uvc.c      **** 			}
5944:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5945:../uvc.c      **** #endif
5946:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5947:../uvc.c      **** 		/* Allow other ready threads to run. */
5948:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5949:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5949 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5950:../uvc.c      **** 		}
 980              		.loc 1 5950 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5830:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5830 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5832:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5832 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5826:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5826 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5828:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5828 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5870:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5870 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5871:../uvc.c      **** 				}
 1010              		.loc 1 5871 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5859:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5859 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5858:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5858 0
 1020 0934 0020A0E3 		mov	r2, #0
5859:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5859 0
 1022 0938 230053E3 		cmp	r3, #35
5860:../uvc.c      **** 						}else{
 1023              		.loc 1 5860 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5862:../uvc.c      **** 						}
 1026              		.loc 1 5862 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5860:../uvc.c      **** 						}else{
 1028              		.loc 1 5860 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5862:../uvc.c      **** 						}
 1030              		.loc 1 5862 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5860:../uvc.c      **** 						}else{
 1032              		.loc 1 5860 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5862:../uvc.c      **** 						}
 1034              		.loc 1 5862 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5864:../uvc.c      **** 					}else{
 1036              		.loc 1 5864 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5858:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5858 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5864:../uvc.c      **** 					}else{
 1040              		.loc 1 5864 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5842:../uvc.c      **** 							break;
 1045              		.loc 1 5842 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5843:../uvc.c      **** 					}
 1049              		.loc 1 5843 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
3533:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 3533 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
3540:../uvc.c      ****     {
 1075              		.loc 1 3540 0
 1076 0994 080051E3 		cmp	r1, #8
3533:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 3533 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
3540:../uvc.c      ****     {
 1089              		.loc 1 3540 0
 1090 09a4 0B00000A 		beq	.L174
3592:../uvc.c      ****     {
 1091              		.loc 1 3592 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
3594:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 3594 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
3595:../uvc.c      ****     }
 1096              		.loc 1 3595 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
3594:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 3594 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
3595:../uvc.c      ****     }
 1102              		.loc 1 3595 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
3594:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 3594 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
3597:../uvc.c      **** 
 1111              		.loc 1 3597 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
3542:../uvc.c      ****             {
 1117              		.loc 1 3542 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
3556:../uvc.c      ****                 fb++;
 1121              		.loc 1 3556 0
 1122 09e0 006095E5 		ldr	r6, [r5]
3542:../uvc.c      ****             {
 1123              		.loc 1 3542 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
3280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 3280 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
3542:../uvc.c      ****             {
 1132              		.loc 1 3542 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
3280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 3280 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
3281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 3281 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
3282:../uvc.c      **** 
 1147              		.loc 1 3282 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
3287:../uvc.c      ****     }
 1151              		.loc 1 3287 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
3563:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 3563 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
3287:../uvc.c      ****     }
 1159              		.loc 1 3287 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
3569:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 3569 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
3563:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 3563 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
3564:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 3564 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
3563:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 3563 0
 1171 0a2c 012082E2 		add	r2, r2, #1
3569:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 3569 0
 1173 0a30 0F0051E3 		cmp	r1, #15
3563:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 3563 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
3564:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 3564 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
3281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 3281 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
3569:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 3569 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
3576:../uvc.c      ****             }
 1187              		.loc 1 3576 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 3580 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
3581:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 3581 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 3580 0
 1196 0a54 013082E2 		add	r3, r2, #1
3581:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 3581 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 3580 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
3581:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 3581 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 3580 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
3581:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 3581 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 3580 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
3581:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 3581 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
3580:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 3580 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
3584:../uvc.c      ****             {
 1215              		.loc 1 3584 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
3586:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 3586 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
3587:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 3587 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
3586:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 3586 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
3587:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 3587 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
3280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 3280 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
3557:../uvc.c      ****             }
 1246              		.loc 1 3557 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
3280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 3280 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
3556:../uvc.c      ****                 fb++;
 1255              		.loc 1 3556 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
3281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 3281 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
3282:../uvc.c      **** 
 1266              		.loc 1 3282 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
3557:../uvc.c      ****             }
 1272              		.loc 1 3557 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
3570:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 3570 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
3571:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 3571 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
3572:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 3572 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
3571:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 3571 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
3572:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 3572 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
3573:../uvc.c      ****                 }
 1295              		.loc 1 3573 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
3336:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 3336 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
3337:../uvc.c      ****     {
 1322              		.loc 1 3337 0
 1323 0b40 020050E3 		cmp	r0, #2
3336:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 3336 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
3337:../uvc.c      ****     {
 1336              		.loc 1 3337 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
3373:../uvc.c      **** 
 1344              		.loc 1 3373 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
3356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 3356 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
3358:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 3358 0
 1356 0b74 40519FE5 		ldr	r5, .L188
3356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 3356 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
3357:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 3357 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
3358:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 3358 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
3320:../uvc.c      **** 	{
 1372              		.loc 1 3320 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
3358:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 3358 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
3359:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 3359 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
3360:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 3360 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
3320:../uvc.c      **** 	{
 1388              		.loc 1 3320 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
3323:../uvc.c      **** 
 1395              		.loc 1 3323 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
3326:../uvc.c      **** 	}
 1401              		.loc 1 3326 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
3340:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 3340 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
3342:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 3342 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
3341:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 3341 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
3342:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 3342 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
3320:../uvc.c      **** 	{
 1433              		.loc 1 3320 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
3342:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 3342 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
3343:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 3343 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
3320:../uvc.c      **** 	{
 1447              		.loc 1 3320 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
3323:../uvc.c      **** 
 1454              		.loc 1 3323 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
3326:../uvc.c      **** 	}
 1460              		.loc 1 3326 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
3348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 3348 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
3350:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 3350 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
3348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 3348 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
3349:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 3349 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
3350:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 3350 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
3320:../uvc.c      **** 	{
 1493              		.loc 1 3320 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
3350:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 3350 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
3351:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 3351 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
3320:../uvc.c      **** 	{
 1507              		.loc 1 3320 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
3323:../uvc.c      **** 
 1514              		.loc 1 3323 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
3326:../uvc.c      **** 	}
 1520              		.loc 1 3326 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
3381:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 3381 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
3390:../uvc.c      **** 
 1560              		.loc 1 3390 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
3387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 3387 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
3389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 3389 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
3386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 3386 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
3388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 3388 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
3389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 3389 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
3386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 3386 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
3387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 3387 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
3389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 3389 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
3390:../uvc.c      **** 
 1579              		.loc 1 3390 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
3388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 3388 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
3393:../uvc.c      ****     {
 1584              		.loc 1 3393 0
 1585 0d00 020054E3 		cmp	r4, #2
3381:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 3381 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
3387:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 3387 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
3389:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 3389 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
3390:../uvc.c      **** 
 1594              		.loc 1 3390 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
3386:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 3386 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
3388:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 3388 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
3393:../uvc.c      ****     {
 1600              		.loc 1 3393 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
3382:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 3382 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
3520:../uvc.c      **** 
 1612              		.loc 1 3520 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
3393:../uvc.c      ****     {
 1618              		.loc 1 3393 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
3433:../uvc.c      ****             {
 1621              		.loc 1 3433 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
3437:../uvc.c      ****                 {
 1624              		.loc 1 3437 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
3437:../uvc.c      ****                 {
 1627              		.loc 1 3437 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
3442:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 3442 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
3440:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 3440 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
3441:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 3441 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
3445:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 3445 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
3442:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 3442 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
3443:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 3443 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
3445:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 3445 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
3446:../uvc.c      **** 
 1652              		.loc 1 3446 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
3449:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 3449 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
3450:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 3450 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
3451:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 3451 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
3452:../uvc.c      **** 
 1669              		.loc 1 3452 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
3455:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 3455 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
3458:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 3458 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
3320:../uvc.c      **** 	{
 1684              		.loc 1 3320 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
3460:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 3460 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
3320:../uvc.c      **** 	{
 1696              		.loc 1 3320 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
3323:../uvc.c      **** 
 1703              		.loc 1 3323 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
3326:../uvc.c      **** 	}
 1709              		.loc 1 3326 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
3398:../uvc.c      ****             {
 1722              		.loc 1 3398 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
3416:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 3416 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
3418:../uvc.c      ****                         {
 1736              		.loc 1 3418 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
3402:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 3402 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
3520:../uvc.c      **** 
 1744              		.loc 1 3520 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
3468:../uvc.c      ****             {
 1750              		.loc 1 3468 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
3470:../uvc.c      ****                 {
 1753              		.loc 1 3470 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
3476:../uvc.c      ****                     {
 1756              		.loc 1 3476 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
3508:../uvc.c      ****                     }
 1762              		.loc 1 3508 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
3507:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 3507 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
3403:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 3403 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
3405:../uvc.c      ****                         {
 1777              		.loc 1 3405 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
3407:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 3407 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
3408:../uvc.c      ****                         }
 1786              		.loc 1 3408 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
3421:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 3421 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
3422:../uvc.c      ****                         }
 1801              		.loc 1 3422 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
3415:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 3415 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
3478:../uvc.c      **** 
 1812              		.loc 1 3478 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
3481:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 3481 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
3482:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 3482 0
 1823 0ee8 0050A0E3 		mov	r5, #0
3486:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 3486 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
3482:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 3482 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
3483:../uvc.c      **** 
 1829              		.loc 1 3483 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
3486:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 3486 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
3487:../uvc.c      **** 
 1834              		.loc 1 3487 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
3490:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 3490 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
3491:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 3491 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
3492:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 3492 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
3493:../uvc.c      **** 
 1851              		.loc 1 3493 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
3496:../uvc.c      **** 
 1855              		.loc 1 3496 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
3500:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 3500 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
3320:../uvc.c      **** 	{
 1866              		.loc 1 3320 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
3502:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 3502 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
3320:../uvc.c      **** 	{
 1878              		.loc 1 3320 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
3323:../uvc.c      **** 
 1885              		.loc 1 3323 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
3326:../uvc.c      **** 	}
 1891              		.loc 1 3326 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1184:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1184 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1187:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1187 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1184:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1184 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1192:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1192 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1187:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1187 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1188:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1188 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1189:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1189 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1192:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1192 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1195:../uvc.c      **** 	{
 1980              		.loc 1 1195 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1205:../uvc.c      **** 	{
 1985              		.loc 1 1205 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1230:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1230 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1249:../uvc.c      **** 
 1993              		.loc 1 1249 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1232:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1232 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1237:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1237 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1237:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1237 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1242:../uvc.c      **** 			}
 2018              		.loc 1 1242 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1249:../uvc.c      **** 
 2025              		.loc 1 1249 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1221:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1221 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1207:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1207 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1221:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1221 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1207:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1207 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1221:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1221 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1222:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1222 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1223:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1223 0
 2051 10c4 020056E3 		cmp	r6, #2
1222:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1222 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1224:../uvc.c      **** 				}
 2054              		.loc 1 1224 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1207:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1207 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1224:../uvc.c      **** 				}
 2058              		.loc 1 1224 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1226:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1226 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1249:../uvc.c      **** 
 2063              		.loc 1 1249 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1195:../uvc.c      **** 	{
 2069              		.loc 1 1195 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1197:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1197 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1198:../uvc.c      **** 			{
 2081              		.loc 1 1198 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1202:../uvc.c      **** 
 2083              		.loc 1 1202 0
 2084 1114 0400A0E3 		mov	r0, #4
1198:../uvc.c      **** 			{
 2085              		.loc 1 1198 0
 2086 1118 000051E3 		cmp	r1, #0
1200:../uvc.c      **** 			}
 2087              		.loc 1 1200 0
 2088 111c 80208203 		orreq	r2, r2, #128
1202:../uvc.c      **** 
 2089              		.loc 1 1202 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1200:../uvc.c      **** 			}
 2092              		.loc 1 1200 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1202:../uvc.c      **** 
 2094              		.loc 1 1202 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1232:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1232 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1234:../uvc.c      **** 			}
 2103              		.loc 1 1234 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1233:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1233 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1237:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1237 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1238:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1238 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1239:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1239 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1240:../uvc.c      **** 				}
 2142              		.loc 1 1240 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1255:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1255 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1255:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1255 0
 2180 11d8 0040A0E1 		mov	r4, r0
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1258 0
 2182 11dc 0060A0E3 		mov	r6, #0
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1257 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1258 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1259:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1259 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1260:../uvc.c      **** }
 2213              		.loc 1 1260 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1261:../uvc.c      **** 
 2215              		.loc 1 1261 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1260:../uvc.c      **** }
 2220              		.loc 1 1260 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1265:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1265 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1270:../uvc.c      **** 	case 1:
 2236              		.loc 1 1270 0
 2237 1248 013040E2 		sub	r3, r0, #1
1265:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1265 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1270:../uvc.c      **** 	case 1:
 2249              		.loc 1 1270 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1292:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1292 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1294:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1294 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1295:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1295 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1294:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1294 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1295:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1295 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1297:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1297 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1300:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1300 0
 2298 12d8 0150A0E3 		mov	r5, #1
1301:../uvc.c      **** 		break;
 2299              		.loc 1 1301 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1300:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1300 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1301:../uvc.c      **** 		break;
 2305              		.loc 1 1301 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1310:../uvc.c      **** 
 2310              		.loc 1 1310 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1276:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1276 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1278:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1278 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1279:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1279 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1278:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1278 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1279:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1279 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1306:../uvc.c      **** 		break;
 2345              		.loc 1 1306 0
 2346 133c 0140A0E3 		mov	r4, #1
1305:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1305 0
 2348 1340 0030A0E3 		mov	r3, #0
1310:../uvc.c      **** 
 2349              		.loc 1 1310 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1305:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1305 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1310:../uvc.c      **** 
 2355              		.loc 1 1310 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1312:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1312 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 24
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1320 0
 2399 137c D87F9FE5 		ldr	r7, .L467
1319:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1319 0
 2401 1380 0F0050E3 		cmp	r0, #15
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1320 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1327 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1312:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1312 0
 2408 1390 2CD04DE2 		sub	sp, sp, #44
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 80
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1327 0
 2412 1394 00A0D3E5 		ldrb	r10, [r3]	@ zero_extendqisi2
1328:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1328 0
 2414 1398 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
1329:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1329 0
 2416 139c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
1330:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1330 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1338:../uvc.c      ****     /*
 2419              		.loc 1 1338 0
 2420 13a4 B43F9FE5 		ldr	r3, .L467+4
1312:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2421              		.loc 1 1312 0
 2422 13a8 0050A0E1 		mov	r5, r0
1338:../uvc.c      ****     /*
 2423              		.loc 1 1338 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2425              		.loc 1 1327 0
 2426 13b0 FFA00AE2 		and	r10, r10, #255
 2427              	.LVL269:
1346:../uvc.c      **** 		 {
 2428              		.loc 1 1346 0
 2429 13b4 830056E3 		cmp	r6, #131
1328:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2430              		.loc 1 1328 0
 2431 13b8 FFB00CE2 		and	fp, ip, #255
 2432              	.LVL270:
1329:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2433              		.loc 1 1329 0
 2434 13bc FF9009E2 		and	r9, r9, #255
 2435              	.LVL271:
1330:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2436              		.loc 1 1330 0
 2437 13c0 FF8008E2 		and	r8, r8, #255
 2438              	.LVL272:
1346:../uvc.c      **** 		 {
 2439              		.loc 1 1346 0
 2440 13c4 A300000A 		beq	.L275
 2441 13c8 1500009A 		bls	.L449
 2442 13cc 850056E3 		cmp	r6, #133
 2443 13d0 9400000A 		beq	.L280
 2444 13d4 AE00003A 		bcc	.L281
 2445 13d8 860056E3 		cmp	r6, #134
 2446 13dc 5900000A 		beq	.L282
 2447 13e0 870056E3 		cmp	r6, #135
 2448 13e4 8600001A 		bne	.L274
1983:../uvc.c      **** 		 		 if(Len == 2){
 2449              		.loc 1 1983 0
 2450 13e8 0F0050E3 		cmp	r0, #15
1985:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2451              		.loc 1 1985 0
 2452 13ec 005187E0 		add	r5, r7, r0, asl #2
1983:../uvc.c      **** 		 		 if(Len == 2){
 2453              		.loc 1 1983 0
 2454 13f0 B500009A 		bls	.L342
1984:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2455              		.loc 1 1984 0
 2456 13f4 020058E3 		cmp	r8, #2
 2457 13f8 0201000A 		beq	.L450
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2458              		.loc 1 1990 0
 2459 13fc 202015E5 		ldr	r2, [r5, #-32]
 2460 1400 5C4F9FE5 		ldr	r4, .L467+8
 2461 1404 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2462              		.loc 1 1991 0
 2463 1408 0030A0E3 		mov	r3, #0
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2464              		.loc 1 1990 0
 2465 140c 2810C4E5 		strb	r1, [r4, #40]
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2466              		.loc 1 1991 0
 2467 1410 2930C4E5 		strb	r3, [r4, #41]
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2468              		.loc 1 1992 0
 2469 1414 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1993:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2470              		.loc 1 1993 0
 2471 1418 2B30C4E5 		strb	r3, [r4, #43]
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2472              		.loc 1 1992 0
 2473 141c 2A20C4E5 		strb	r2, [r4, #42]
 2474 1420 D90000EA 		b	.L345
 2475              	.L449:
1346:../uvc.c      **** 		 {
 2476              		.loc 1 1346 0
 2477 1424 810056E3 		cmp	r6, #129
 2478 1428 6100000A 		beq	.L277
 2479 142c 3600008A 		bhi	.L278
 2480 1430 010056E3 		cmp	r6, #1
 2481 1434 7200001A 		bne	.L274
2536:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2482              		.loc 1 2536 0
 2483 1438 244F9FE5 		ldr	r4, .L467+8
 2484 143c 26208DE2 		add	r2, sp, #38
 2485 1440 2000A0E3 		mov	r0, #32
 2486              	.LVL273:
 2487 1444 281084E2 		add	r1, r4, #40
 2488 1448 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2489              	.LVL274:
2538:../uvc.c      **** 			   {
 2490              		.loc 1 2538 0
 2491 144c 002050E2 		subs	r2, r0, #0
 2492 1450 8103001A 		bne	.L347
2540:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2493              		.loc 1 2540 0
 2494 1454 020058E3 		cmp	r8, #2
2541:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2495              		.loc 1 2541 0
 2496 1458 2800D405 		ldreqb	r0, [r4, #40]	@ zero_extendqisi2
 2497              	.LVL275:
2542:../uvc.c      **** 				 }else{
 2498              		.loc 1 2542 0
 2499 145c 2910D405 		ldreqb	r1, [r4, #41]	@ zero_extendqisi2
2544:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2500              		.loc 1 2544 0
 2501 1460 2820D415 		ldrneb	r2, [r4, #40]	@ zero_extendqisi2
 2502              	.LVL276:
2545:../uvc.c      **** 				 }
 2503              		.loc 1 2545 0
 2504 1464 2A30D415 		ldrneb	r3, [r4, #42]	@ zero_extendqisi2
2541:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2505              		.loc 1 2541 0
 2506 1468 18008D05 		streq	r0, [sp, #24]
 2507              	.LVL277:
2542:../uvc.c      **** 				 }else{
 2508              		.loc 1 2542 0
 2509 146c 1C108D05 		streq	r1, [sp, #28]
 2510              	.LVL278:
2544:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2511              		.loc 1 2544 0
 2512 1470 18208D15 		strne	r2, [sp, #24]
 2513              	.LVL279:
2545:../uvc.c      **** 				 }
 2514              		.loc 1 2545 0
 2515 1474 1C308D15 		strne	r3, [sp, #28]
 2516              	.LVL280:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 2517              		.loc 1 2548 0
 2518 1478 00B08DE5 		str	fp, [sp]
 2519 147c 04908DE5 		str	r9, [sp, #4]
 2520 1480 08808DE5 		str	r8, [sp, #8]
 2521 1484 0400A0E3 		mov	r0, #4
 2522 1488 D81E9FE5 		ldr	r1, .L467+12
 2523 148c 0520A0E1 		mov	r2, r5
 2524 1490 0A30A0E1 		mov	r3, r10
 2525 1494 FEFFFFEB 		bl	CyU3PDebugPrint
 2526              	.LVL281:
2550:../uvc.c      **** 					 switch(CtrlID)
 2527              		.loc 1 2550 0
 2528 1498 0F0055E3 		cmp	r5, #15
 2529 149c C200009A 		bls	.L350
2551:../uvc.c      **** 					 {
 2530              		.loc 1 2551 0
 2531 14a0 103045E2 		sub	r3, r5, #16
 2532 14a4 160053E3 		cmp	r3, #22
 2533 14a8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2534 14ac 630300EA 		b	.L351
 2535              	.L353:
 2536 14b0 F0200000 		.word	.L352
 2537 14b4 40220000 		.word	.L351
 2538 14b8 40220000 		.word	.L351
 2539 14bc 40220000 		.word	.L351
 2540 14c0 40220000 		.word	.L351
 2541 14c4 40220000 		.word	.L351
 2542 14c8 40220000 		.word	.L351
 2543 14cc 40220000 		.word	.L351
 2544 14d0 40220000 		.word	.L351
 2545 14d4 50200000 		.word	.L354
 2546 14d8 40220000 		.word	.L351
 2547 14dc C01F0000 		.word	.L355
 2548 14e0 E0210000 		.word	.L356
 2549 14e4 40220000 		.word	.L351
 2550 14e8 40220000 		.word	.L351
 2551 14ec B0210000 		.word	.L357
 2552 14f0 40220000 		.word	.L351
 2553 14f4 40220000 		.word	.L351
 2554 14f8 40220000 		.word	.L351
 2555 14fc 40220000 		.word	.L351
 2556 1500 341F0000 		.word	.L358
 2557 1504 40220000 		.word	.L351
 2558 1508 BC1E0000 		.word	.L359
 2559              	.LVL282:
 2560              	.L278:
1874:../uvc.c      **** 		 		 if(Len == 2){
 2561              		.loc 1 1874 0
 2562 150c 0F0050E3 		cmp	r0, #15
1876:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2563              		.loc 1 1876 0
 2564 1510 005187E0 		add	r5, r7, r0, asl #2
1874:../uvc.c      **** 		 		 if(Len == 2){
 2565              		.loc 1 1874 0
 2566 1514 8700009A 		bls	.L328
1875:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2567              		.loc 1 1875 0
 2568 1518 020058E3 		cmp	r8, #2
 2569 151c B100000A 		beq	.L451
1881:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2570              		.loc 1 1881 0
 2571 1520 202015E5 		ldr	r2, [r5, #-32]
 2572 1524 384E9FE5 		ldr	r4, .L467+8
 2573 1528 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1882:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2574              		.loc 1 1882 0
 2575 152c 0030A0E3 		mov	r3, #0
1881:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2576              		.loc 1 1881 0
 2577 1530 2810C4E5 		strb	r1, [r4, #40]
1882:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2578              		.loc 1 1882 0
 2579 1534 2930C4E5 		strb	r3, [r4, #41]
1883:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2580              		.loc 1 1883 0
 2581 1538 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1884:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2582              		.loc 1 1884 0
 2583 153c 2B30C4E5 		strb	r3, [r4, #43]
1883:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2584              		.loc 1 1883 0
 2585 1540 2A20C4E5 		strb	r2, [r4, #42]
 2586 1544 900000EA 		b	.L345
 2587              	.L282:
 2588              	.LVL283:
1964:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2589              		.loc 1 1964 0
 2590 1548 0F0050E3 		cmp	r0, #15
1965:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2591              		.loc 1 1965 0
 2592 154c 005187E0 		add	r5, r7, r0, asl #2
 2593 1550 20301585 		ldrhi	r3, [r5, #-32]
1971:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2594              		.loc 1 1971 0
 2595 1554 20319595 		ldrls	r3, [r5, #288]
 2596 1558 044E9FE5 		ldr	r4, .L467+8
 2597 155c 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1977:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2598              		.loc 1 1977 0
 2599 1560 0100A0E3 		mov	r0, #1
 2600              	.LVL284:
1972:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2601              		.loc 1 1972 0
 2602 1564 0030A0E3 		mov	r3, #0
1971:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2603              		.loc 1 1971 0
 2604 1568 2820C4E5 		strb	r2, [r4, #40]
1972:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2605              		.loc 1 1972 0
 2606 156c 2930C4E5 		strb	r3, [r4, #41]
1973:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2607              		.loc 1 1973 0
 2608 1570 2A30C4E5 		strb	r3, [r4, #42]
1974:../uvc.c      **** 		 	 }
 2609              		.loc 1 1974 0
 2610 1574 2B30C4E5 		strb	r3, [r4, #43]
 2611              	.LVL285:
 2612              	.L443:
1936:../uvc.c      **** 				  if(Len == 2){
 2613              		.loc 1 1936 0
 2614 1578 EC1D9FE5 		ldr	r1, .L467+16
 2615 157c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2616              	.LVL286:
 2617 1580 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2618              	.LVL287:
 2619 1584 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2620 1588 0090A0E3 		mov	r9, #0
 2621              	.LVL288:
 2622 158c 0950A0E1 		mov	r5, r9
 2623              	.LVL289:
 2624              	.L284:
2956:../uvc.c      **** }
 2625              		.loc 1 2956 0
 2626 1590 20048DE8 		stmia	sp, {r5, r10}
 2627 1594 D41D9FE5 		ldr	r1, .L467+20
 2628 1598 08708DE5 		str	r7, [sp, #8]
 2629 159c 0620A0E1 		mov	r2, r6
 2630 15a0 0930A0E1 		mov	r3, r9
 2631 15a4 0400A0E3 		mov	r0, #4
 2632 15a8 FEFFFFEB 		bl	CyU3PDebugPrint
 2633              	.LVL290:
2957:../uvc.c      **** /************** CT control requests handler *************************/
 2634              		.loc 1 2957 0
 2635 15ac 2CD08DE2 		add	sp, sp, #44
 2636              		@ sp needed
 2637 15b0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2638              	.LVL291:
 2639              	.L277:
1357:../uvc.c      **** 				 switch(CtrlID)
 2640              		.loc 1 1357 0
 2641 15b4 0F0050E3 		cmp	r0, #15
 2642 15b8 4E00009A 		bls	.L285
1358:../uvc.c      **** 				 {
 2643              		.loc 1 1358 0
 2644 15bc 193040E2 		sub	r3, r0, #25
 2645 15c0 0D0053E3 		cmp	r3, #13
 2646 15c4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2647 15c8 250200EA 		b	.L286
 2648              	.L288:
 2649 15cc 081A0000 		.word	.L287
 2650 15d0 641E0000 		.word	.L286
 2651 15d4 641E0000 		.word	.L286
 2652 15d8 641A0000 		.word	.L289
 2653 15dc 641E0000 		.word	.L286
 2654 15e0 641E0000 		.word	.L286
 2655 15e4 BC190000 		.word	.L290
 2656 15e8 641E0000 		.word	.L286
 2657 15ec 641E0000 		.word	.L286
 2658 15f0 641E0000 		.word	.L286
 2659 15f4 641E0000 		.word	.L286
 2660 15f8 641E0000 		.word	.L286
 2661 15fc 641E0000 		.word	.L286
 2662 1600 18190000 		.word	.L291
 2663              	.L274:
2953:../uvc.c      **** 			  break;
 2664              		.loc 1 2953 0
 2665 1604 0000A0E3 		mov	r0, #0
 2666              	.LVL292:
 2667 1608 0020A0E1 		mov	r2, r0
 2668 160c 0110A0E3 		mov	r1, #1
2954:../uvc.c      **** 		 }
 2669              		.loc 1 2954 0
 2670 1610 FF70A0E3 		mov	r7, #255
 2671 1614 0090A0E3 		mov	r9, #0
 2672              	.LVL293:
2953:../uvc.c      **** 			  break;
 2673              		.loc 1 2953 0
 2674 1618 FEFFFFEB 		bl	CyU3PUsbStall
 2675              	.LVL294:
2954:../uvc.c      **** 		 }
 2676              		.loc 1 2954 0
 2677 161c 07A0A0E1 		mov	r10, r7
 2678              	.LVL295:
 2679 1620 0950A0E1 		mov	r5, r9
 2680 1624 D9FFFFEA 		b	.L284
 2681              	.LVL296:
 2682              	.L280:
1350:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2683              		.loc 1 1350 0
 2684 1628 344D9FE5 		ldr	r4, .L467+8
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2685              		.loc 1 1351 0
 2686 162c 0030A0E3 		mov	r3, #0
 2687 1630 0390A0E1 		mov	r9, r3
 2688              	.LVL297:
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2689              		.loc 1 1352 0
 2690 1634 281084E2 		add	r1, r4, #40
 2691 1638 0200A0E3 		mov	r0, #2
 2692              	.LVL298:
1350:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2693              		.loc 1 1350 0
 2694 163c 2880C4E5 		strb	r8, [r4, #40]
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2695              		.loc 1 1351 0
 2696 1640 2930C4E5 		strb	r3, [r4, #41]
 2697 1644 0950A0E1 		mov	r5, r9
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2698              		.loc 1 1352 0
 2699 1648 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2700              	.LVL299:
1354:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2701              		.loc 1 1354 0
 2702 164c FF70A0E3 		mov	r7, #255
 2703 1650 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2704              	.LVL300:
 2705 1654 CDFFFFEA 		b	.L284
 2706              	.LVL301:
 2707              	.L275:
1910:../uvc.c      **** 		 		 if(Len == 2){
 2708              		.loc 1 1910 0
 2709 1658 0F0050E3 		cmp	r0, #15
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2710              		.loc 1 1912 0
 2711 165c 005187E0 		add	r5, r7, r0, asl #2
1910:../uvc.c      **** 		 		 if(Len == 2){
 2712              		.loc 1 1910 0
 2713 1660 3F00009A 		bls	.L333
1911:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2714              		.loc 1 1911 0
 2715 1664 020058E3 		cmp	r8, #2
 2716 1668 7200000A 		beq	.L452
1917:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2717              		.loc 1 1917 0
 2718 166c 202015E5 		ldr	r2, [r5, #-32]
 2719 1670 EC4C9FE5 		ldr	r4, .L467+8
 2720 1674 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1918:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2721              		.loc 1 1918 0
 2722 1678 0030A0E3 		mov	r3, #0
1917:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2723              		.loc 1 1917 0
 2724 167c 2810C4E5 		strb	r1, [r4, #40]
1918:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2725              		.loc 1 1918 0
 2726 1680 2930C4E5 		strb	r3, [r4, #41]
1919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2727              		.loc 1 1919 0
 2728 1684 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1920:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2729              		.loc 1 1920 0
 2730 1688 2B30C4E5 		strb	r3, [r4, #43]
1919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2731              		.loc 1 1919 0
 2732 168c 2A20C4E5 		strb	r2, [r4, #42]
 2733 1690 3D0000EA 		b	.L345
 2734              	.L281:
1946:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2735              		.loc 1 1946 0
 2736 1694 0F0050E3 		cmp	r0, #15
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2737              		.loc 1 1947 0
 2738 1698 005187E0 		add	r5, r7, r0, asl #2
 2739 169c 20201585 		ldrhi	r2, [r5, #-32]
1953:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2740              		.loc 1 1953 0
 2741 16a0 20219595 		ldrls	r2, [r5, #288]
 2742 16a4 B84C9FE5 		ldr	r4, .L467+8
 2743 16a8 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1955:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2744              		.loc 1 1955 0
 2745 16ac 0030A0E3 		mov	r3, #0
1953:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2746              		.loc 1 1953 0
 2747 16b0 2810C4E5 		strb	r1, [r4, #40]
1954:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2748              		.loc 1 1954 0
 2749 16b4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2750              		.loc 1 1958 0
 2751 16b8 0800A0E1 		mov	r0, r8
 2752              	.LVL302:
1955:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2753              		.loc 1 1955 0
 2754 16bc 2A30C4E5 		strb	r3, [r4, #42]
1954:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2755              		.loc 1 1954 0
 2756 16c0 2920C4E5 		strb	r2, [r4, #41]
1956:../uvc.c      **** 		 	 }
 2757              		.loc 1 1956 0
 2758 16c4 2B30C4E5 		strb	r3, [r4, #43]
 2759 16c8 AAFFFFEA 		b	.L443
 2760              	.LVL303:
 2761              	.L342:
1997:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2762              		.loc 1 1997 0
 2763 16cc 020058E3 		cmp	r8, #2
1998:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2764              		.loc 1 1998 0
 2765 16d0 203195E5 		ldr	r3, [r5, #288]
 2766 16d4 884C9FE5 		ldr	r4, .L467+8
1997:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2767              		.loc 1 1997 0
 2768 16d8 5100000A 		beq	.L453
2002:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2769              		.loc 1 2002 0
 2770 16dc 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
2005:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2771              		.loc 1 2005 0
 2772 16e0 0020A0E3 		mov	r2, #0
2002:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2773              		.loc 1 2002 0
 2774 16e4 2810C4E5 		strb	r1, [r4, #40]
2004:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2775              		.loc 1 2004 0
 2776 16e8 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
2005:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2777              		.loc 1 2005 0
 2778 16ec 2B20C4E5 		strb	r2, [r4, #43]
2004:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2779              		.loc 1 2004 0
 2780 16f0 2930C4E5 		strb	r3, [r4, #41]
 2781 16f4 240000EA 		b	.L345
 2782              	.L285:
1676:../uvc.c      **** 				 {
 2783              		.loc 1 1676 0
 2784 16f8 013040E2 		sub	r3, r0, #1
1827:../uvc.c      **** 			 	 			 if(Len == 2)
 2785              		.loc 1 1827 0
 2786 16fc 604C9FE5 		ldr	r4, .L467+8
1676:../uvc.c      **** 				 {
 2787              		.loc 1 1676 0
 2788 1700 0A0053E3 		cmp	r3, #10
 2789 1704 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2790 1708 C90100EA 		b	.L306
 2791              	.L308:
 2792 170c 78190000 		.word	.L307
 2793 1710 341E0000 		.word	.L306
 2794 1714 341E0000 		.word	.L306
 2795 1718 4C190000 		.word	.L309
 2796 171c E0180000 		.word	.L310
 2797 1720 341E0000 		.word	.L306
 2798 1724 341E0000 		.word	.L306
 2799 1728 341E0000 		.word	.L306
 2800 172c 341E0000 		.word	.L306
 2801 1730 341E0000 		.word	.L306
 2802 1734 7C180000 		.word	.L311
 2803              	.L328:
1888:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2804              		.loc 1 1888 0
 2805 1738 020058E3 		cmp	r8, #2
1889:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2806              		.loc 1 1889 0
 2807 173c 203195E5 		ldr	r3, [r5, #288]
 2808 1740 1C4C9FE5 		ldr	r4, .L467+8
1888:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2809              		.loc 1 1888 0
 2810 1744 4700000A 		beq	.L454
1893:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2811              		.loc 1 1893 0
 2812 1748 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1896:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2813              		.loc 1 1896 0
 2814 174c 0020A0E3 		mov	r2, #0
1893:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2815              		.loc 1 1893 0
 2816 1750 2810C4E5 		strb	r1, [r4, #40]
1895:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2817              		.loc 1 1895 0
 2818 1754 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1896:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2819              		.loc 1 1896 0
 2820 1758 2B20C4E5 		strb	r2, [r4, #43]
1895:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2821              		.loc 1 1895 0
 2822 175c 2930C4E5 		strb	r3, [r4, #41]
 2823 1760 090000EA 		b	.L345
 2824              	.L333:
1924:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2825              		.loc 1 1924 0
 2826 1764 020058E3 		cmp	r8, #2
1925:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2827              		.loc 1 1925 0
 2828 1768 203195E5 		ldr	r3, [r5, #288]
 2829 176c F04B9FE5 		ldr	r4, .L467+8
1924:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2830              		.loc 1 1924 0
 2831 1770 3700000A 		beq	.L455
1929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2832              		.loc 1 1929 0
 2833 1774 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1932:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2834              		.loc 1 1932 0
 2835 1778 0020A0E3 		mov	r2, #0
1929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2836              		.loc 1 1929 0
 2837 177c 2810C4E5 		strb	r1, [r4, #40]
1931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2838              		.loc 1 1931 0
 2839 1780 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1932:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2840              		.loc 1 1932 0
 2841 1784 2B20C4E5 		strb	r2, [r4, #43]
1931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2842              		.loc 1 1931 0
 2843 1788 2930C4E5 		strb	r3, [r4, #41]
 2844              	.L345:
2009:../uvc.c      **** 		 	 if(Len == 2){
 2845              		.loc 1 2009 0
 2846 178c 0800A0E1 		mov	r0, r8
 2847              	.LVL304:
 2848 1790 D41B9FE5 		ldr	r1, .L467+16
 2849 1794 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2850              	.LVL305:
 2851 1798 0090A0E3 		mov	r9, #0
 2852              	.LVL306:
 2853 179c 0950A0E1 		mov	r5, r9
 2854 17a0 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2855              	.LVL307:
 2856 17a4 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2857 17a8 78FFFFEA 		b	.L284
 2858              	.LVL308:
 2859              	.L350:
2759:../uvc.c      **** 					 {
 2860              		.loc 1 2759 0
 2861 17ac 0B0055E3 		cmp	r5, #11
 2862 17b0 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2863 17b4 8E0200EA 		b	.L379
 2864              	.L381:
 2865 17b8 D01D0000 		.word	.L380
 2866 17bc 581D0000 		.word	.L382
 2867 17c0 F4210000 		.word	.L379
 2868 17c4 F4210000 		.word	.L379
 2869 17c8 F01C0000 		.word	.L383
 2870 17cc 9C1B0000 		.word	.L384
 2871 17d0 F4210000 		.word	.L379
 2872 17d4 0C1B0000 		.word	.L385
 2873 17d8 F4210000 		.word	.L379
 2874 17dc F4210000 		.word	.L379
 2875 17e0 F4210000 		.word	.L379
 2876 17e4 781A0000 		.word	.L386
 2877              	.LVL309:
 2878              	.L451:
1876:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2879              		.loc 1 1876 0
 2880 17e8 203015E5 		ldr	r3, [r5, #-32]
 2881 17ec 704B9FE5 		ldr	r4, .L467+8
 2882 17f0 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2883 17f4 2820C4E5 		strb	r2, [r4, #40]
1877:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2884              		.loc 1 1877 0
 2885 17f8 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2886 17fc 2930C4E5 		strb	r3, [r4, #41]
 2887              	.L335:
1936:../uvc.c      **** 				  if(Len == 2){
 2888              		.loc 1 1936 0
 2889 1800 0200A0E3 		mov	r0, #2
 2890              	.LVL310:
 2891 1804 5BFFFFEA 		b	.L443
 2892              	.LVL311:
 2893              	.L450:
1985:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2894              		.loc 1 1985 0
 2895 1808 203015E5 		ldr	r3, [r5, #-32]
 2896 180c 504B9FE5 		ldr	r4, .L467+8
 2897 1810 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2898 1814 2820C4E5 		strb	r2, [r4, #40]
1986:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2899              		.loc 1 1986 0
 2900 1818 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2901 181c 2930C4E5 		strb	r3, [r4, #41]
 2902 1820 F6FFFFEA 		b	.L335
 2903              	.L453:
1998:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2904              		.loc 1 1998 0
 2905 1824 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2906 1828 2820C4E5 		strb	r2, [r4, #40]
1999:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2907              		.loc 1 1999 0
 2908 182c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2909 1830 2930C4E5 		strb	r3, [r4, #41]
 2910 1834 F1FFFFEA 		b	.L335
 2911              	.L452:
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2912              		.loc 1 1912 0
 2913 1838 203015E5 		ldr	r3, [r5, #-32]
 2914 183c 204B9FE5 		ldr	r4, .L467+8
 2915 1840 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2916 1844 2820C4E5 		strb	r2, [r4, #40]
1913:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2917              		.loc 1 1913 0
 2918 1848 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2919 184c 2930C4E5 		strb	r3, [r4, #41]
 2920 1850 EAFFFFEA 		b	.L335
 2921              	.L455:
1925:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2922              		.loc 1 1925 0
 2923 1854 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2924 1858 2820C4E5 		strb	r2, [r4, #40]
1926:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2925              		.loc 1 1926 0
 2926 185c 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2927 1860 2930C4E5 		strb	r3, [r4, #41]
 2928 1864 E5FFFFEA 		b	.L335
 2929              	.L454:
1889:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2930              		.loc 1 1889 0
 2931 1868 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2932 186c 2820C4E5 		strb	r2, [r4, #40]
1890:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2933              		.loc 1 1890 0
 2934 1870 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2935 1874 2930C4E5 		strb	r3, [r4, #41]
 2936 1878 E0FFFFEA 		b	.L335
 2937              	.L311:
1744:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2938              		.loc 1 1744 0
 2939 187c AB30D4E5 		ldrb	r3, [r4, #171]	@ zero_extendqisi2
 2940 1880 000053E3 		cmp	r3, #0
 2941 1884 9202000A 		beq	.L321
1745:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2942              		.loc 1 1745 0
 2943 1888 0C3B9FE5 		ldr	r3, .L467+64
 2944 188c 5CA5D3E5 		ldrb	r10, [r3, #1372]	@ zero_extendqisi2
 2945              	.LVL312:
1746:../uvc.c      **** 						 }else{
 2946              		.loc 1 1746 0
 2947 1890 5E75D3E5 		ldrb	r7, [r3, #1374]	@ zero_extendqisi2
1745:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2948              		.loc 1 1745 0
 2949 1894 28A0C4E5 		strb	r10, [r4, #40]
1746:../uvc.c      **** 						 }else{
 2950              		.loc 1 1746 0
 2951 1898 2A70C4E5 		strb	r7, [r4, #42]
 2952              	.LVL313:
 2953              	.L322:
1756:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2954              		.loc 1 1756 0
 2955 189c 0030A0E3 		mov	r3, #0
 2956 18a0 0290A0E1 		mov	r9, r2
 2957              	.LVL314:
 2958 18a4 2930C4E5 		strb	r3, [r4, #41]
1757:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2959              		.loc 1 1757 0
 2960 18a8 2B30C4E5 		strb	r3, [r4, #43]
 2961              	.LVL315:
 2962              	.L292:
1867:../uvc.c      **** 
 2963              		.loc 1 1867 0
 2964 18ac B81A9FE5 		ldr	r1, .L467+16
 2965 18b0 0800A0E1 		mov	r0, r8
 2966 18b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2967              	.LVL316:
1870:../uvc.c      **** //#endif
 2968              		.loc 1 1870 0
 2969 18b8 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2970 18bc 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 2971 18c0 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 2972 18c4 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 2973 18c8 03018DE8 		stmia	sp, {r0, r1, r8}
 2974 18cc A01A9FE5 		ldr	r1, .L467+24
 2975 18d0 0400A0E3 		mov	r0, #4
 2976 18d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2977              	.LVL317:
 2978 18d8 18509DE5 		ldr	r5, [sp, #24]
1872:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 2979              		.loc 1 1872 0
 2980 18dc 2BFFFFEA 		b	.L284
 2981              	.LVL318:
 2982              	.L310:
1709:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
 2983              		.loc 1 1709 0
 2984 18e0 A530D4E5 		ldrb	r3, [r4, #165]	@ zero_extendqisi2
 2985 18e4 000053E3 		cmp	r3, #0
 2986 18e8 C002000A 		beq	.L316
1710:../uvc.c      **** 						 }else{
 2987              		.loc 1 1710 0
 2988 18ec A83A9FE5 		ldr	r3, .L467+64
 2989 18f0 4195D3E5 		ldrb	r9, [r3, #1345]	@ zero_extendqisi2
 2990              	.LVL319:
 2991 18f4 FF0009E2 		and	r0, r9, #255
 2992              	.LVL320:
 2993              	.L317:
1717:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 2994              		.loc 1 1717 0
 2995 18f8 80A040E2 		sub	r10, r0, #128
 2996              	.LVL321:
 2997 18fc FFA00AE2 		and	r10, r10, #255
1718:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2998              		.loc 1 1718 0
 2999 1900 0030A0E3 		mov	r3, #0
1717:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3000              		.loc 1 1717 0
 3001 1904 28A0C4E5 		strb	r10, [r4, #40]
 3002 1908 0090A0E1 		mov	r9, r0
1718:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3003              		.loc 1 1718 0
 3004 190c 2930C4E5 		strb	r3, [r4, #41]
 3005              	.LVL322:
1720:../uvc.c      **** 					 case MFreqCtlID4:
 3006              		.loc 1 1720 0
 3007 1910 FF70A0E3 		mov	r7, #255
 3008 1914 E4FFFFEA 		b	.L292
 3009              	.LVL323:
 3010              	.L291:
1361:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
 3011              		.loc 1 1361 0
 3012 1918 444A9FE5 		ldr	r4, .L467+8
 3013 191c C650D4E5 		ldrb	r5, [r4, #198]	@ zero_extendqisi2
 3014 1920 000055E3 		cmp	r5, #0
 3015 1924 7E02000A 		beq	.L296
1362:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3016              		.loc 1 1362 0
 3017 1928 6C3A9FE5 		ldr	r3, .L467+64
 3018 192c 05A5D3E5 		ldrb	r10, [r3, #1285]	@ zero_extendqisi2
 3019              	.LVL324:
1363:../uvc.c      **** 						 }else{
 3020              		.loc 1 1363 0
 3021 1930 0675D3E5 		ldrb	r7, [r3, #1286]	@ zero_extendqisi2
1362:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3022              		.loc 1 1362 0
 3023 1934 FFA00AE2 		and	r10, r10, #255
1363:../uvc.c      **** 						 }else{
 3024              		.loc 1 1363 0
 3025 1938 FF7007E2 		and	r7, r7, #255
1362:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3026              		.loc 1 1362 0
 3027 193c 28A0C4E5 		strb	r10, [r4, #40]
1363:../uvc.c      **** 						 }else{
 3028              		.loc 1 1363 0
 3029 1940 2970C4E5 		strb	r7, [r4, #41]
 3030              	.LVL325:
 3031              	.L320:
 3032 1944 0290A0E1 		mov	r9, r2
 3033              	.LVL326:
1742:../uvc.c      **** 					 case WBTLevCtlID11:
 3034              		.loc 1 1742 0
 3035 1948 D7FFFFEA 		b	.L292
 3036              	.LVL327:
 3037              	.L309:
1723:../uvc.c      **** 
 3038              		.loc 1 1723 0
 3039 194c A430D4E5 		ldrb	r3, [r4, #164]	@ zero_extendqisi2
 3040 1950 000053E3 		cmp	r3, #0
 3041 1954 9302000A 		beq	.L318
1725:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3042              		.loc 1 1725 0
 3043 1958 6C3094E5 		ldr	r3, [r4, #108]
1730:../uvc.c      **** 						 }else{
 3044              		.loc 1 1730 0
 3045 195c 0070A0E3 		mov	r7, #0
1725:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3046              		.loc 1 1725 0
 3047 1960 000053E3 		cmp	r3, #0
 3048 1964 02A0A013 		movne	r10, #2
 3049              	.LVL328:
 3050 1968 01A0A003 		moveq	r10, #1
 3051 196c 28A0C4E5 		strb	r10, [r4, #40]
1730:../uvc.c      **** 						 }else{
 3052              		.loc 1 1730 0
 3053 1970 2970C4E5 		strb	r7, [r4, #41]
 3054 1974 F2FFFFEA 		b	.L320
 3055              	.LVL329:
 3056              	.L307:
1691:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
 3057              		.loc 1 1691 0
 3058 1978 A130D4E5 		ldrb	r3, [r4, #161]	@ zero_extendqisi2
 3059 197c 000053E3 		cmp	r3, #0
 3060 1980 A202000A 		beq	.L312
1692:../uvc.c      **** 						 }else{
 3061              		.loc 1 1692 0
 3062 1984 103A9FE5 		ldr	r3, .L467+64
 3063 1988 2D05D3E5 		ldrb	r0, [r3, #1325]	@ zero_extendqisi2
 3064              	.LVL330:
 3065 198c FF0000E2 		and	r0, r0, #255
 3066              	.LVL331:
 3067              	.L313:
1699:../uvc.c      **** 							  Data0 = ~Data0;
 3068              		.loc 1 1699 0
 3069 1990 800010E3 		tst	r0, #128
1700:../uvc.c      **** 						  }else{
 3070              		.loc 1 1700 0
 3071 1994 0030E011 		mvnne	r3, r0
1702:../uvc.c      **** 						  }
 3072              		.loc 1 1702 0
 3073 1998 80304002 		subeq	r3, r0, #128
 3074 199c FF3003E2 		and	r3, r3, #255
 3075              	.LVL332:
1705:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3076              		.loc 1 1705 0
 3077 19a0 0020A0E3 		mov	r2, #0
 3078 19a4 0390A0E1 		mov	r9, r3
 3079              	.LVL333:
1704:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3080              		.loc 1 1704 0
 3081 19a8 2830C4E5 		strb	r3, [r4, #40]
1707:../uvc.c      **** 					 case HueCtlID5:
 3082              		.loc 1 1707 0
 3083 19ac 03A0A0E1 		mov	r10, r3
 3084              	.LVL334:
1705:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3085              		.loc 1 1705 0
 3086 19b0 2920C4E5 		strb	r2, [r4, #41]
 3087              	.LVL335:
1707:../uvc.c      **** 					 case HueCtlID5:
 3088              		.loc 1 1707 0
 3089 19b4 FF70A0E3 		mov	r7, #255
 3090 19b8 BBFFFFEA 		b	.L292
 3091              	.LVL336:
 3092              	.L290:
1414:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3093              		.loc 1 1414 0 discriminator 1
 3094 19bc 000058E3 		cmp	r8, #0
 3095 19c0 0300000A 		beq	.L300
 3096 19c4 A0099FE5 		ldr	r0, .L467+16
 3097              	.LVL337:
 3098 19c8 0820A0E1 		mov	r2, r8
 3099 19cc 6C1080E2 		add	r1, r0, #108
 3100 19d0 FEFFFFEB 		bl	memcpy
 3101              	.LVL338:
 3102              	.L300:
1417:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3103              		.loc 1 1417 0
 3104 19d4 88499FE5 		ldr	r4, .L467+8
1424:../uvc.c      **** 				 		 {
 3105              		.loc 1 1424 0
 3106 19d8 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1417:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3107              		.loc 1 1417 0
 3108 19dc 31A0D4E5 		ldrb	r10, [r4, #49]	@ zero_extendqisi2
 3109              	.LVL339:
1424:../uvc.c      **** 				 		 {
 3110              		.loc 1 1424 0
 3111 19e0 FF0053E3 		cmp	r3, #255
1418:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3112              		.loc 1 1418 0
 3113 19e4 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3114              	.LVL340:
1424:../uvc.c      **** 				 		 {
 3115              		.loc 1 1424 0
 3116 19e8 2C02000A 		beq	.L439
1426:../uvc.c      **** 				 		 }
 3117              		.loc 1 1426 0
 3118 19ec 0400A0E3 		mov	r0, #4
 3119 19f0 80199FE5 		ldr	r1, .L467+28
 3120 19f4 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3121 19f8 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3122 19fc FEFFFFEB 		bl	CyU3PDebugPrint
 3123              	.LVL341:
 3124 1a00 0090A0E3 		mov	r9, #0
 3125              	.LVL342:
 3126 1a04 A8FFFFEA 		b	.L292
 3127              	.LVL343:
 3128              	.L287:
1378:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3129              		.loc 1 1378 0
 3130 1a08 54499FE5 		ldr	r4, .L467+8
 3131 1a0c B930D4E5 		ldrb	r3, [r4, #185]	@ zero_extendqisi2
 3132 1a10 000053E3 		cmp	r3, #0
 3133 1a14 8502000A 		beq	.L298
1379:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3134              		.loc 1 1379 0
 3135 1a18 7C399FE5 		ldr	r3, .L467+64
 3136 1a1c 19A5D3E5 		ldrb	r10, [r3, #1305]	@ zero_extendqisi2
 3137              	.LVL344:
1380:../uvc.c      **** 			 	 		 }else{
 3138              		.loc 1 1380 0
 3139 1a20 1A75D3E5 		ldrb	r7, [r3, #1306]	@ zero_extendqisi2
1379:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3140              		.loc 1 1379 0
 3141 1a24 FFA00AE2 		and	r10, r10, #255
1380:../uvc.c      **** 			 	 		 }else{
 3142              		.loc 1 1380 0
 3143 1a28 FF7007E2 		and	r7, r7, #255
1379:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3144              		.loc 1 1379 0
 3145 1a2c 28A0C4E5 		strb	r10, [r4, #40]
1380:../uvc.c      **** 			 	 		 }else{
 3146              		.loc 1 1380 0
 3147 1a30 2A70C4E5 		strb	r7, [r4, #42]
 3148              	.LVL345:
 3149              	.L299:
1390:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3150              		.loc 1 1390 0
 3151 1a34 00C0A0E3 		mov	ip, #0
1394:../uvc.c      **** 						 break;
 3152              		.loc 1 1394 0
 3153 1a38 00708DE5 		str	r7, [sp]
 3154 1a3c 04C08DE5 		str	ip, [sp, #4]
 3155 1a40 0A20A0E1 		mov	r2, r10
 3156 1a44 0C30A0E1 		mov	r3, ip
 3157 1a48 2C199FE5 		ldr	r1, .L467+32
1390:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3158              		.loc 1 1390 0
 3159 1a4c 29C0C4E5 		strb	ip, [r4, #41]
1391:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3160              		.loc 1 1391 0
 3161 1a50 2BC0C4E5 		strb	ip, [r4, #43]
 3162              	.LVL346:
1394:../uvc.c      **** 						 break;
 3163              		.loc 1 1394 0
 3164 1a54 0400A0E3 		mov	r0, #4
 3165 1a58 0C90A0E1 		mov	r9, ip
 3166              	.LVL347:
 3167 1a5c FEFFFFEB 		bl	CyU3PDebugPrint
 3168              	.LVL348:
1395:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3169              		.loc 1 1395 0
 3170 1a60 91FFFFEA 		b	.L292
 3171              	.LVL349:
 3172              	.L289:
1358:../uvc.c      **** 				 {
 3173              		.loc 1 1358 0
 3174 1a64 FF70A0E3 		mov	r7, #255
 3175 1a68 07A0A0E1 		mov	r10, r7
 3176              	.LVL350:
 3177 1a6c 0090A0E3 		mov	r9, #0
 3178              	.LVL351:
 3179 1a70 EC489FE5 		ldr	r4, .L467+8
 3180 1a74 8CFFFFEA 		b	.L292
 3181              	.LVL352:
 3182              	.L386:
2863:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3183              		.loc 1 2863 0
 3184 1a78 24499FE5 		ldr	r4, .L467+72
 3185 1a7c 0010E0E3 		mvn	r1, #0
 3186 1a80 1C0094E5 		ldr	r0, [r4, #28]
 3187 1a84 FEFFFFEB 		bl	_txe_mutex_get
 3188              	.LVL353:
2864:../uvc.c      **** 							 dataIdx++;
 3189              		.loc 1 2864 0
 3190 1a88 18209DE5 		ldr	r2, [sp, #24]
 3191 1a8c 0030A0E3 		mov	r3, #0
 3192 1a90 00208DE5 		str	r2, [sp]
 3193 1a94 04308DE5 		str	r3, [sp, #4]
 3194 1a98 0A20A0E1 		mov	r2, r10
 3195 1a9c 0930A0E1 		mov	r3, r9
 3196 1aa0 0B10A0E3 		mov	r1, #11
 3197 1aa4 0400A0E1 		mov	r0, r4
 3198 1aa8 FEFFFFEB 		bl	cmdSet
 3199              	.LVL354:
2866:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3200              		.loc 1 2866 0
 3201 1aac 1C309DE5 		ldr	r3, [sp, #28]
 3202 1ab0 0180A0E3 		mov	r8, #1
 3203              	.LVL355:
 3204 1ab4 0B20A0E1 		mov	r2, fp
 3205 1ab8 0B10A0E3 		mov	r1, #11
 3206 1abc 00308DE5 		str	r3, [sp]
 3207 1ac0 0400A0E1 		mov	r0, r4
 3208 1ac4 0930A0E1 		mov	r3, r9
 3209 1ac8 04808DE5 		str	r8, [sp, #4]
 3210 1acc FEFFFFEB 		bl	cmdSet
 3211              	.LVL356:
2871:../uvc.c      **** 							 break;
 3212              		.loc 1 2871 0
 3213 1ad0 055187E0 		add	r5, r7, r5, asl #2
2867:../uvc.c      **** 
 3214              		.loc 1 2867 0
 3215 1ad4 1C0094E5 		ldr	r0, [r4, #28]
 3216 1ad8 FEFFFFEB 		bl	_txe_mutex_put
 3217              	.LVL357:
2871:../uvc.c      **** 							 break;
 3218              		.loc 1 2871 0
 3219 1adc 202195E5 		ldr	r2, [r5, #288]
2869:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3220              		.loc 1 2869 0
 3221 1ae0 B4389FE5 		ldr	r3, .L467+64
 3222 1ae4 18009DE5 		ldr	r0, [sp, #24]
2870:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3223              		.loc 1 2870 0
 3224 1ae8 1C109DE5 		ldr	r1, [sp, #28]
2872:../uvc.c      **** 						 case BLCCtlID0:
 3225              		.loc 1 2872 0
 3226 1aec FF70A0E3 		mov	r7, #255
2871:../uvc.c      **** 							 break;
 3227              		.loc 1 2871 0
 3228 1af0 1180C2E5 		strb	r8, [r2, #17]
2869:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3229              		.loc 1 2869 0
 3230 1af4 5C05C3E5 		strb	r0, [r3, #1372]
2870:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3231              		.loc 1 2870 0
 3232 1af8 5E15C3E5 		strb	r1, [r3, #1374]
 3233 1afc 0090A0E1 		mov	r9, r0
 3234              	.LVL358:
 3235 1b00 0150A0E1 		mov	r5, r1
2872:../uvc.c      **** 						 case BLCCtlID0:
 3236              		.loc 1 2872 0
 3237 1b04 07A0A0E1 		mov	r10, r7
 3238              	.LVL359:
 3239 1b08 A0FEFFEA 		b	.L284
 3240              	.LVL360:
 3241              	.L385:
2892:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3242              		.loc 1 2892 0
 3243 1b0c 18009DE5 		ldr	r0, [sp, #24]
2891:../uvc.c      **** 							 if(Data0 != 0){
 3244              		.loc 1 2891 0
 3245 1b10 055187E0 		add	r5, r7, r5, asl #2
 3246 1b14 204195E5 		ldr	r4, [r5, #288]
2893:../uvc.c      **** 	#ifdef COLOR
 3247              		.loc 1 2893 0
 3248 1b18 84589FE5 		ldr	r5, .L467+72
2892:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3249              		.loc 1 2892 0
 3250 1b1c 000050E3 		cmp	r0, #0
2891:../uvc.c      **** 							 if(Data0 != 0){
 3251              		.loc 1 2891 0
 3252 1b20 0D00C4E5 		strb	r0, [r4, #13]
2893:../uvc.c      **** 	#ifdef COLOR
 3253              		.loc 1 2893 0
 3254 1b24 0010E0E3 		mvn	r1, #0
 3255 1b28 1C0095E5 		ldr	r0, [r5, #28]
2892:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3256              		.loc 1 2892 0
 3257 1b2c 5002000A 		beq	.L404
2893:../uvc.c      **** 	#ifdef COLOR
 3258              		.loc 1 2893 0
 3259 1b30 FEFFFFEB 		bl	_txe_mutex_get
 3260              	.LVL361:
2897:../uvc.c      **** 								 dataIdx++;
 3261              		.loc 1 2897 0
 3262 1b34 0170A0E3 		mov	r7, #1
 3263 1b38 0030A0E3 		mov	r3, #0
 3264 1b3c 0A20A0E1 		mov	r2, r10
 3265 1b40 04308DE5 		str	r3, [sp, #4]
 3266 1b44 0710A0E3 		mov	r1, #7
 3267 1b48 0500A0E1 		mov	r0, r5
 3268 1b4c 00708DE5 		str	r7, [sp]
 3269 1b50 0930A0E1 		mov	r3, r9
 3270 1b54 FEFFFFEB 		bl	cmdSet
 3271              	.LVL362:
2899:../uvc.c      **** 	#endif
 3272              		.loc 1 2899 0
 3273 1b58 18109DE5 		ldr	r1, [sp, #24]
 3274 1b5c 0B20A0E1 		mov	r2, fp
 3275 1b60 04708DE5 		str	r7, [sp, #4]
 3276 1b64 00108DE5 		str	r1, [sp]
 3277              	.LVL363:
 3278              	.L442:
2904:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3279              		.loc 1 2904 0
 3280 1b68 0930A0E1 		mov	r3, r9
 3281 1b6c 0500A0E1 		mov	r0, r5
 3282 1b70 0710A0E3 		mov	r1, #7
 3283 1b74 FEFFFFEB 		bl	cmdSet
 3284              	.LVL364:
2905:../uvc.c      **** 							 }
 3285              		.loc 1 2905 0
 3286 1b78 1C0095E5 		ldr	r0, [r5, #28]
 3287 1b7c FEFFFFEB 		bl	_txe_mutex_put
 3288              	.LVL365:
2908:../uvc.c      **** 						 case ConsCtlID2:
 3289              		.loc 1 2908 0
 3290 1b80 FF70A0E3 		mov	r7, #255
2907:../uvc.c      **** 							 break;
 3291              		.loc 1 2907 0
 3292 1b84 0130A0E3 		mov	r3, #1
 3293 1b88 18909DE5 		ldr	r9, [sp, #24]
 3294              	.LVL366:
 3295 1b8c 1C509DE5 		ldr	r5, [sp, #28]
2908:../uvc.c      **** 						 case ConsCtlID2:
 3296              		.loc 1 2908 0
 3297 1b90 07A0A0E1 		mov	r10, r7
 3298              	.LVL367:
2907:../uvc.c      **** 							 break;
 3299              		.loc 1 2907 0
 3300 1b94 1130C4E5 		strb	r3, [r4, #17]
 3301              	.LVL368:
2908:../uvc.c      **** 						 case ConsCtlID2:
 3302              		.loc 1 2908 0
 3303 1b98 7CFEFFEA 		b	.L284
 3304              	.LVL369:
 3305              	.L384:
2798:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3306              		.loc 1 2798 0
 3307 1b9c 00889FE5 		ldr	r8, .L467+72
 3308              	.LVL370:
 3309 1ba0 0010E0E3 		mvn	r1, #0
 3310 1ba4 1C0098E5 		ldr	r0, [r8, #28]
 3311 1ba8 FEFFFFEB 		bl	_txe_mutex_get
 3312              	.LVL371:
2799:../uvc.c      **** 							 dataIdx++;
 3313              		.loc 1 2799 0
 3314 1bac 18209DE5 		ldr	r2, [sp, #24]
 3315 1bb0 0030A0E3 		mov	r3, #0
 3316 1bb4 801042E2 		sub	r1, r2, #128
 3317 1bb8 FF1001E2 		and	r1, r1, #255
 3318 1bbc 0A20A0E1 		mov	r2, r10
 3319 1bc0 00108DE5 		str	r1, [sp]
 3320 1bc4 04308DE5 		str	r3, [sp, #4]
 3321 1bc8 0510A0E3 		mov	r1, #5
 3322 1bcc 0930A0E1 		mov	r3, r9
 3323 1bd0 0800A0E1 		mov	r0, r8
 3324 1bd4 FEFFFFEB 		bl	cmdSet
 3325              	.LVL372:
2801:../uvc.c      **** 							 dataIdx++;
 3326              		.loc 1 2801 0
 3327 1bd8 18009DE5 		ldr	r0, [sp, #24]
 3328 1bdc 01C0A0E3 		mov	ip, #1
 3329 1be0 763040E2 		sub	r3, r0, #118
 3330 1be4 FF3003E2 		and	r3, r3, #255
 3331 1be8 04C08DE5 		str	ip, [sp, #4]
 3332 1bec 00308DE5 		str	r3, [sp]
 3333 1bf0 0510A0E3 		mov	r1, #5
 3334 1bf4 0930A0E1 		mov	r3, r9
 3335 1bf8 DC20A0E3 		mov	r2, #220
 3336 1bfc 0800A0E1 		mov	r0, r8
 3337 1c00 14C08DE5 		str	ip, [sp, #20]
 3338 1c04 FEFFFFEB 		bl	cmdSet
 3339              	.LVL373:
2803:../uvc.c      **** 							 dataIdx++;
 3340              		.loc 1 2803 0
 3341 1c08 18109DE5 		ldr	r1, [sp, #24]
 3342 1c0c 0230A0E3 		mov	r3, #2
 3343 1c10 7E2081E2 		add	r2, r1, #126
 3344 1c14 FF2002E2 		and	r2, r2, #255
 3345 1c18 00208DE5 		str	r2, [sp]
 3346 1c1c 04308DE5 		str	r3, [sp, #4]
 3347 1c20 0510A0E3 		mov	r1, #5
 3348 1c24 0930A0E1 		mov	r3, r9
 3349 1c28 DE20A0E3 		mov	r2, #222
 3350 1c2c 0800A0E1 		mov	r0, r8
 3351 1c30 FEFFFFEB 		bl	cmdSet
 3352              	.LVL374:
2805:../uvc.c      **** 							 dataIdx++;
 3353              		.loc 1 2805 0
 3354 1c34 18309DE5 		ldr	r3, [sp, #24]
 3355 1c38 0510A0E3 		mov	r1, #5
 3356 1c3c 722083E2 		add	r2, r3, #114
 3357 1c40 FF2002E2 		and	r2, r2, #255
 3358 1c44 0330A0E3 		mov	r3, #3
 3359 1c48 00208DE5 		str	r2, [sp]
 3360 1c4c 04308DE5 		str	r3, [sp, #4]
 3361 1c50 E020A0E3 		mov	r2, #224
 3362 1c54 0930A0E1 		mov	r3, r9
 3363 1c58 0800A0E1 		mov	r0, r8
 3364 1c5c FEFFFFEB 		bl	cmdSet
 3365              	.LVL375:
2807:../uvc.c      **** 							 dataIdx++;
 3366              		.loc 1 2807 0
 3367 1c60 18009DE5 		ldr	r0, [sp, #24]
 3368 1c64 0430A0E3 		mov	r3, #4
 3369 1c68 6F2040E2 		sub	r2, r0, #111
 3370 1c6c FF2002E2 		and	r2, r2, #255
 3371 1c70 00208DE5 		str	r2, [sp]
 3372 1c74 04308DE5 		str	r3, [sp, #4]
 3373 1c78 0510A0E3 		mov	r1, #5
 3374 1c7c 0930A0E1 		mov	r3, r9
 3375 1c80 DD20A0E3 		mov	r2, #221
 3376 1c84 0800A0E1 		mov	r0, r8
 3377 1c88 FEFFFFEB 		bl	cmdSet
 3378              	.LVL376:
2809:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3379              		.loc 1 2809 0
 3380 1c8c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3381 1c90 0510A0E3 		mov	r1, #5
 3382 1c94 7F0080E2 		add	r0, r0, #127
 3383 1c98 FF0000E2 		and	r0, r0, #255
 3384 1c9c 0930A0E1 		mov	r3, r9
 3385 1ca0 0B20A0E1 		mov	r2, fp
 3386 1ca4 00008DE5 		str	r0, [sp]
 3387 1ca8 04108DE5 		str	r1, [sp, #4]
 3388 1cac 0800A0E1 		mov	r0, r8
 3389 1cb0 FEFFFFEB 		bl	cmdSet
 3390              	.LVL377:
2810:../uvc.c      **** 
 3391              		.loc 1 2810 0
 3392 1cb4 1C0098E5 		ldr	r0, [r8, #28]
 3393 1cb8 FEFFFFEB 		bl	_txe_mutex_put
 3394              	.LVL378:
2812:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3395              		.loc 1 2812 0
 3396 1cbc 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3397 1cc0 055187E0 		add	r5, r7, r5, asl #2
 3398 1cc4 203195E5 		ldr	r3, [r5, #288]
 3399 1cc8 802042E2 		sub	r2, r2, #128
 3400 1ccc FF2002E2 		and	r2, r2, #255
 3401 1cd0 0D20C3E5 		strb	r2, [r3, #13]
2813:../uvc.c      **** 							 break;
 3402              		.loc 1 2813 0
 3403 1cd4 14C09DE5 		ldr	ip, [sp, #20]
2814:../uvc.c      **** 						 case MFreqCtlID4:
 3404              		.loc 1 2814 0
 3405 1cd8 FF70A0E3 		mov	r7, #255
 3406 1cdc 1C509DE5 		ldr	r5, [sp, #28]
 3407 1ce0 18909DE5 		ldr	r9, [sp, #24]
 3408              	.LVL379:
 3409 1ce4 07A0A0E1 		mov	r10, r7
 3410              	.LVL380:
2813:../uvc.c      **** 							 break;
 3411              		.loc 1 2813 0
 3412 1ce8 11C0C3E5 		strb	ip, [r3, #17]
2814:../uvc.c      **** 						 case MFreqCtlID4:
 3413              		.loc 1 2814 0
 3414 1cec 27FEFFEA 		b	.L284
 3415              	.LVL381:
 3416              	.L383:
2817:../uvc.c      **** 							 is60Hz = Data0;
 3417              		.loc 1 2817 0
 3418 1cf0 18109DE5 		ldr	r1, [sp, #24]
2816:../uvc.c      **** 							 Data0 = Data0 - 1;
 3419              		.loc 1 2816 0
 3420 1cf4 055187E0 		add	r5, r7, r5, asl #2
 3421 1cf8 208195E5 		ldr	r8, [r5, #288]
 3422              	.LVL382:
2817:../uvc.c      **** 							 is60Hz = Data0;
 3423              		.loc 1 2817 0
 3424 1cfc 019041E2 		sub	r9, r1, #1
 3425              	.LVL383:
 3426 1d00 FF9009E2 		and	r9, r9, #255
 3427              	.LVL384:
2818:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3428              		.loc 1 2818 0
 3429 1d04 58369FE5 		ldr	r3, .L467+8
2824:../uvc.c      **** 							 {
 3430              		.loc 1 2824 0
 3431 1d08 020059E3 		cmp	r9, #2
2816:../uvc.c      **** 							 Data0 = Data0 - 1;
 3432              		.loc 1 2816 0
 3433 1d0c 0D10C8E5 		strb	r1, [r8, #13]
2818:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3434              		.loc 1 2818 0
 3435 1d10 6C9084E5 		str	r9, [r4, #108]
 3436              	.LVL385:
2827:../uvc.c      **** 							 }
 3437              		.loc 1 2827 0
 3438 1d14 0190A083 		movhi	r9, #1
 3439 1d18 6C908385 		strhi	r9, [r3, #108]
 3440              	.LVL386:
2829:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3441              		.loc 1 2829 0
 3442 1d1c 0920A0E1 		mov	r2, r9
 3443 1d20 6C3094E5 		ldr	r3, [r4, #108]
 3444 1d24 0400A0E3 		mov	r0, #4
 3445 1d28 50169FE5 		ldr	r1, .L467+36
 3446 1d2c FEFFFFEB 		bl	CyU3PDebugPrint
 3447              	.LVL387:
2830:../uvc.c      **** 							 {
 3448              		.loc 1 2830 0
 3449 1d30 883094E5 		ldr	r3, [r4, #136]
2829:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3450              		.loc 1 2829 0
 3451 1d34 28269FE5 		ldr	r2, .L467+8
2830:../uvc.c      **** 							 {
 3452              		.loc 1 2830 0
 3453 1d38 010053E3 		cmp	r3, #1
 3454 1d3c E101000A 		beq	.L456
 3455              	.L390:
2858:../uvc.c      **** 							 break;
 3456              		.loc 1 2858 0
 3457 1d40 0130A0E3 		mov	r3, #1
2859:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3458              		.loc 1 2859 0
 3459 1d44 FF70A0E3 		mov	r7, #255
 3460 1d48 1C509DE5 		ldr	r5, [sp, #28]
2858:../uvc.c      **** 							 break;
 3461              		.loc 1 2858 0
 3462 1d4c 1130C8E5 		strb	r3, [r8, #17]
2859:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3463              		.loc 1 2859 0
 3464 1d50 07A0A0E1 		mov	r10, r7
 3465              	.LVL388:
 3466 1d54 0DFEFFEA 		b	.L284
 3467              	.LVL389:
 3468              	.L382:
2784:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3469              		.loc 1 2784 0
 3470 1d58 44469FE5 		ldr	r4, .L467+72
 3471 1d5c 0010E0E3 		mvn	r1, #0
 3472 1d60 1C0094E5 		ldr	r0, [r4, #28]
 3473 1d64 FEFFFFEB 		bl	_txe_mutex_get
 3474              	.LVL390:
2786:../uvc.c      **** 									  Data0 = Data0 - 0x80;
 3475              		.loc 1 2786 0
 3476 1d68 18309DE5 		ldr	r3, [sp, #24]
2791:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3477              		.loc 1 2791 0
 3478 1d6c 0010A0E3 		mov	r1, #0
2786:../uvc.c      **** 									  Data0 = Data0 - 0x80;
 3479              		.loc 1 2786 0
 3480 1d70 800013E3 		tst	r3, #128
 3481 1d74 0300A001 		moveq	r0, r3
2787:../uvc.c      **** 								  }else{
 3482              		.loc 1 2787 0
 3483 1d78 80804312 		subne	r8, r3, #128
 3484              	.LVL391:
2791:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3485              		.loc 1 2791 0
 3486 1d7c 0B20A0E1 		mov	r2, fp
 3487 1d80 0930A0E1 		mov	r3, r9
 3488 1d84 04108DE5 		str	r1, [sp, #4]
 3489 1d88 0110A0E3 		mov	r1, #1
2794:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3490              		.loc 1 2794 0
 3491 1d8c 055187E0 		add	r5, r7, r5, asl #2
2796:../uvc.c      **** 						 case HueCtlID5://not being used
 3492              		.loc 1 2796 0
 3493 1d90 FF70A0E3 		mov	r7, #255
 3494 1d94 07A0A0E1 		mov	r10, r7
 3495              	.LVL392:
2789:../uvc.c      **** 								  }
 3496              		.loc 1 2789 0
 3497 1d98 0080E001 		mvneq	r8, r0
 3498 1d9c FF8008E2 		and	r8, r8, #255
 3499              	.LVL393:
2791:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3500              		.loc 1 2791 0
 3501 1da0 00808DE5 		str	r8, [sp]
 3502 1da4 F8059FE5 		ldr	r0, .L467+72
 3503 1da8 FEFFFFEB 		bl	cmdSet
 3504              	.LVL394:
2792:../uvc.c      **** 
 3505              		.loc 1 2792 0
 3506 1dac 1C0094E5 		ldr	r0, [r4, #28]
 3507 1db0 FEFFFFEB 		bl	_txe_mutex_put
 3508              	.LVL395:
2794:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3509              		.loc 1 2794 0
 3510 1db4 203195E5 		ldr	r3, [r5, #288]
2795:../uvc.c      **** 							 break;
 3511              		.loc 1 2795 0
 3512 1db8 0120A0E3 		mov	r2, #1
2794:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3513              		.loc 1 2794 0
 3514 1dbc 0D80C3E5 		strb	r8, [r3, #13]
 3515 1dc0 1C509DE5 		ldr	r5, [sp, #28]
 3516 1dc4 0890A0E1 		mov	r9, r8
 3517              	.LVL396:
2795:../uvc.c      **** 							 break;
 3518              		.loc 1 2795 0
 3519 1dc8 1120C3E5 		strb	r2, [r3, #17]
2796:../uvc.c      **** 						 case HueCtlID5://not being used
 3520              		.loc 1 2796 0
 3521 1dcc EFFDFFEA 		b	.L284
 3522              	.LVL397:
 3523              	.L380:
2874:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3524              		.loc 1 2874 0
 3525 1dd0 055187E0 		add	r5, r7, r5, asl #2
 3526 1dd4 204195E5 		ldr	r4, [r5, #288]
 3527 1dd8 18209DE5 		ldr	r2, [sp, #24]
2884:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3528              		.loc 1 2884 0
 3529 1ddc C0559FE5 		ldr	r5, .L467+72
2874:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3530              		.loc 1 2874 0
 3531 1de0 0D20C4E5 		strb	r2, [r4, #13]
2884:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3532              		.loc 1 2884 0
 3533 1de4 0010E0E3 		mvn	r1, #0
 3534 1de8 1C0095E5 		ldr	r0, [r5, #28]
 3535 1dec FEFFFFEB 		bl	_txe_mutex_get
 3536              	.LVL398:
2885:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3537              		.loc 1 2885 0
 3538 1df0 18309DE5 		ldr	r3, [sp, #24]
 3539 1df4 0010A0E3 		mov	r1, #0
 3540 1df8 0A20A0E1 		mov	r2, r10
 3541 1dfc 00308DE5 		str	r3, [sp]
 3542 1e00 0500A0E1 		mov	r0, r5
 3543 1e04 0930A0E1 		mov	r3, r9
 3544 1e08 04108DE5 		str	r1, [sp, #4]
 3545 1e0c FEFFFFEB 		bl	cmdSet
 3546              	.LVL399:
2886:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3547              		.loc 1 2886 0
 3548 1e10 1C0095E5 		ldr	r0, [r5, #28]
 3549 1e14 FEFFFFEB 		bl	_txe_mutex_put
 3550              	.LVL400:
2888:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3551              		.loc 1 2888 0
 3552 1e18 FF70A0E3 		mov	r7, #255
2887:../uvc.c      **** 					 		 break;
 3553              		.loc 1 2887 0
 3554 1e1c 0130A0E3 		mov	r3, #1
 3555 1e20 1C509DE5 		ldr	r5, [sp, #28]
 3556 1e24 18909DE5 		ldr	r9, [sp, #24]
 3557              	.LVL401:
2888:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3558              		.loc 1 2888 0
 3559 1e28 07A0A0E1 		mov	r10, r7
 3560              	.LVL402:
2887:../uvc.c      **** 					 		 break;
 3561              		.loc 1 2887 0
 3562 1e2c 1130C4E5 		strb	r3, [r4, #17]
 3563              	.LVL403:
2888:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3564              		.loc 1 2888 0
 3565 1e30 D6FDFFEA 		b	.L284
 3566              	.LVL404:
 3567              	.L306:
1827:../uvc.c      **** 			 	 			 if(Len == 2)
 3568              		.loc 1 1827 0
 3569 1e34 003084E0 		add	r3, r4, r0
 3570 1e38 A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3571 1e3c 000053E3 		cmp	r3, #0
 3572 1e40 1801000A 		beq	.L323
1828:../uvc.c      **** 			 	 			 {
 3573              		.loc 1 1828 0
 3574 1e44 020058E3 		cmp	r8, #2
 3575 1e48 2A02000A 		beq	.L457
1834:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3576              		.loc 1 1834 0
 3577 1e4c 040058E3 		cmp	r8, #4
 3578 1e50 4E02000A 		beq	.L458
 3579              	.L325:
1720:../uvc.c      **** 					 case MFreqCtlID4:
 3580              		.loc 1 1720 0
 3581 1e54 FF70A0E3 		mov	r7, #255
 3582 1e58 07A0A0E1 		mov	r10, r7
 3583              	.LVL405:
 3584 1e5c 0090A0E3 		mov	r9, #0
 3585              	.LVL406:
 3586 1e60 91FEFFEA 		b	.L292
 3587              	.LVL407:
 3588              	.L286:
1636:../uvc.c      **** 			 	 			 if(Len == 2)
 3589              		.loc 1 1636 0
 3590 1e64 F8449FE5 		ldr	r4, .L467+8
 3591 1e68 003084E0 		add	r3, r4, r0
 3592 1e6c A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3593 1e70 000053E3 		cmp	r3, #0
 3594 1e74 0001000A 		beq	.L301
1637:../uvc.c      **** 			 	 			 {
 3595              		.loc 1 1637 0
 3596 1e78 020058E3 		cmp	r8, #2
 3597 1e7c 2702000A 		beq	.L459
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3598              		.loc 1 1643 0
 3599 1e80 040058E3 		cmp	r8, #4
 3600 1e84 F2FFFF1A 		bne	.L325
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3601              		.loc 1 1644 0
 3602 1e88 005187E0 		add	r5, r7, r0, asl #2
 3603 1e8c 202015E5 		ldr	r2, [r5, #-32]
 3604              	.L438:
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3605              		.loc 1 1835 0
 3606 1e90 0DA0D2E5 		ldrb	r10, [r2, #13]	@ zero_extendqisi2
 3607              	.LVL408:
1836:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3608              		.loc 1 1836 0
 3609 1e94 0030A0E3 		mov	r3, #0
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3610              		.loc 1 1835 0
 3611 1e98 FFA00AE2 		and	r10, r10, #255
1836:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3612              		.loc 1 1836 0
 3613 1e9c 2930C4E5 		strb	r3, [r4, #41]
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3614              		.loc 1 1835 0
 3615 1ea0 28A0C4E5 		strb	r10, [r4, #40]
1837:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3616              		.loc 1 1837 0
 3617 1ea4 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3618 1ea8 0390A0E1 		mov	r9, r3
 3619              	.LVL409:
 3620 1eac FF7007E2 		and	r7, r7, #255
 3621 1eb0 2A70C4E5 		strb	r7, [r4, #42]
1838:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3622              		.loc 1 1838 0
 3623 1eb4 2B30C4E5 		strb	r3, [r4, #43]
 3624              	.LVL410:
 3625 1eb8 7BFEFFEA 		b	.L292
 3626              	.LVL411:
 3627              	.L359:
2554:../uvc.c      **** 							 if(Data0 == 1){
 3628              		.loc 1 2554 0
 3629 1ebc 033187E0 		add	r3, r7, r3, asl #2
 3630 1ec0 204093E5 		ldr	r4, [r3, #32]
2555:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3631              		.loc 1 2555 0
 3632 1ec4 18009DE5 		ldr	r0, [sp, #24]
2556:../uvc.c      **** 							 }else{
 3633              		.loc 1 2556 0
 3634 1ec8 CC349FE5 		ldr	r3, .L467+64
2560:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3635              		.loc 1 2560 0
 3636 1ecc D0549FE5 		ldr	r5, .L467+72
2554:../uvc.c      **** 							 if(Data0 == 1){
 3637              		.loc 1 2554 0
 3638 1ed0 0D00C4E5 		strb	r0, [r4, #13]
2556:../uvc.c      **** 							 }else{
 3639              		.loc 1 2556 0
 3640 1ed4 6DB5D3E5 		ldrb	fp, [r3, #1389]	@ zero_extendqisi2
 3641              	.LVL412:
2555:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3642              		.loc 1 2555 0
 3643 1ed8 010050E3 		cmp	r0, #1
2560:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3644              		.loc 1 2560 0
 3645 1edc 0010E0E3 		mvn	r1, #0
 3646 1ee0 1C0095E5 		ldr	r0, [r5, #28]
2556:../uvc.c      **** 							 }else{
 3647              		.loc 1 2556 0
 3648 1ee4 80B08B03 		orreq	fp, fp, #128
 3649              	.LVL413:
2558:../uvc.c      **** 							 }
 3650              		.loc 1 2558 0
 3651 1ee8 7FB00B12 		andne	fp, fp, #127
 3652              	.LVL414:
2560:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3653              		.loc 1 2560 0
 3654 1eec FEFFFFEB 		bl	_txe_mutex_get
 3655              	.LVL415:
2561:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3656              		.loc 1 2561 0
 3657 1ef0 0010A0E3 		mov	r1, #0
 3658 1ef4 0930A0E1 		mov	r3, r9
 3659 1ef8 0A20A0E1 		mov	r2, r10
 3660 1efc 0500A0E1 		mov	r0, r5
 3661 1f00 04108DE5 		str	r1, [sp, #4]
 3662 1f04 00B08DE5 		str	fp, [sp]
 3663 1f08 2610A0E3 		mov	r1, #38
 3664 1f0c FEFFFFEB 		bl	cmdSet
 3665              	.LVL416:
2562:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3666              		.loc 1 2562 0
 3667 1f10 1C0095E5 		ldr	r0, [r5, #28]
 3668 1f14 FEFFFFEB 		bl	_txe_mutex_put
 3669              	.LVL417:
2564:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3670              		.loc 1 2564 0
 3671 1f18 FF70A0E3 		mov	r7, #255
2563:../uvc.c      **** 							 break;
 3672              		.loc 1 2563 0
 3673 1f1c 0130A0E3 		mov	r3, #1
 3674 1f20 1C509DE5 		ldr	r5, [sp, #28]
 3675 1f24 0B90A0E1 		mov	r9, fp
 3676              	.LVL418:
 3677 1f28 1130C4E5 		strb	r3, [r4, #17]
 3678              	.LVL419:
2564:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3679              		.loc 1 2564 0
 3680 1f2c 07A0A0E1 		mov	r10, r7
 3681              	.LVL420:
 3682 1f30 96FDFFEA 		b	.L284
 3683              	.LVL421:
 3684              	.L358:
2704:../uvc.c      **** 						     /* end test */
 3685              		.loc 1 2704 0
 3686 1f34 68549FE5 		ldr	r5, .L467+72
 3687 1f38 0010E0E3 		mvn	r1, #0
 3688 1f3c 1C0095E5 		ldr	r0, [r5, #28]
 3689 1f40 FEFFFFEB 		bl	_txe_mutex_get
 3690              	.LVL422:
2706:../uvc.c      **** 							 dataIdx++;
 3691              		.loc 1 2706 0
 3692 1f44 18009DE5 		ldr	r0, [sp, #24]
 3693 1f48 0030A0E3 		mov	r3, #0
 3694 1f4c 0A20A0E1 		mov	r2, r10
 3695 1f50 00008DE5 		str	r0, [sp]
 3696 1f54 04308DE5 		str	r3, [sp, #4]
 3697 1f58 0500A0E1 		mov	r0, r5
 3698 1f5c 0930A0E1 		mov	r3, r9
 3699 1f60 2410A0E3 		mov	r1, #36
 3700 1f64 FEFFFFEB 		bl	cmdSet
 3701              	.LVL423:
2708:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3702              		.loc 1 2708 0
 3703 1f68 1C109DE5 		ldr	r1, [sp, #28]
 3704 1f6c 0140A0E3 		mov	r4, #1
 3705 1f70 0930A0E1 		mov	r3, r9
 3706 1f74 0B20A0E1 		mov	r2, fp
 3707 1f78 00108DE5 		str	r1, [sp]
 3708 1f7c 0500A0E1 		mov	r0, r5
 3709 1f80 2410A0E3 		mov	r1, #36
 3710 1f84 04408DE5 		str	r4, [sp, #4]
 3711 1f88 FEFFFFEB 		bl	cmdSet
 3712              	.LVL424:
2709:../uvc.c      **** 							 getData1 = Data1;
 3713              		.loc 1 2709 0
 3714 1f8c 1C0095E5 		ldr	r0, [r5, #28]
 3715 1f90 FEFFFFEB 		bl	_txe_mutex_put
 3716              	.LVL425:
2712:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3717              		.loc 1 2712 0
 3718 1f94 00349FE5 		ldr	r3, .L467+64
 3719 1f98 18209DE5 		ldr	r2, [sp, #24]
2713:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3720              		.loc 1 2713 0
 3721 1f9c 1C009DE5 		ldr	r0, [sp, #28]
2715:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3722              		.loc 1 2715 0
 3723 1fa0 FF70A0E3 		mov	r7, #255
2712:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3724              		.loc 1 2712 0
 3725 1fa4 A925C3E5 		strb	r2, [r3, #1449]
 3726 1fa8 0290A0E1 		mov	r9, r2
 3727              	.LVL426:
2713:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3728              		.loc 1 2713 0
 3729 1fac AA05C3E5 		strb	r0, [r3, #1450]
 3730 1fb0 0050A0E1 		mov	r5, r0
2714:../uvc.c      **** 							 break;
 3731              		.loc 1 2714 0
 3732 1fb4 AD45C3E5 		strb	r4, [r3, #1453]
2715:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3733              		.loc 1 2715 0
 3734 1fb8 07A0A0E1 		mov	r10, r7
 3735              	.LVL427:
 3736 1fbc 73FDFFEA 		b	.L284
 3737              	.LVL428:
 3738              	.L355:
2625:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3739              		.loc 1 2625 0
 3740 1fc0 DC439FE5 		ldr	r4, .L467+72
 3741 1fc4 0010E0E3 		mvn	r1, #0
 3742 1fc8 1C0094E5 		ldr	r0, [r4, #28]
 3743 1fcc 14308DE5 		str	r3, [sp, #20]
 3744 1fd0 FEFFFFEB 		bl	_txe_mutex_get
 3745              	.LVL429:
2626:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3746              		.loc 1 2626 0
 3747 1fd4 14309DE5 		ldr	r3, [sp, #20]
 3748 1fd8 18009DE5 		ldr	r0, [sp, #24]
 3749 1fdc 033187E0 		add	r3, r7, r3, asl #2
 3750 1fe0 203093E5 		ldr	r3, [r3, #32]
 3751 1fe4 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 3752 1fe8 000052E1 		cmp	r2, r0
 3753 1fec A8539F05 		ldreq	r5, .L467+64
 3754 1ff0 0700000A 		beq	.L370
2628:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3755              		.loc 1 2628 0
 3756 1ff4 A0539FE5 		ldr	r5, .L467+64
2627:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3757              		.loc 1 2627 0
 3758 1ff8 0D00C3E5 		strb	r0, [r3, #13]
2628:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3759              		.loc 1 2628 0
 3760 1ffc 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3761 2000 010053E3 		cmp	r3, #1
 3762 2004 8E01000A 		beq	.L371
2628:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3763              		.loc 1 2628 0 is_stmt 0 discriminator 1
 3764 2008 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3765 200c 030053E3 		cmp	r3, #3
 3766 2010 8B01000A 		beq	.L371
 3767              	.LVL430:
 3768              	.L370:
2635:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3769              		.loc 1 2635 0 is_stmt 1
 3770 2014 1C0094E5 		ldr	r0, [r4, #28]
 3771 2018 FEFFFFEB 		bl	_txe_mutex_put
 3772              	.LVL431:
2637:../uvc.c      **** 							 break;
 3773              		.loc 1 2637 0
 3774 201c 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
 3775 2020 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3776 2024 9515D5E5 		ldrb	r1, [r5, #1429]	@ zero_extendqisi2
2636:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3777              		.loc 1 2636 0
 3778 2028 FF70A0E3 		mov	r7, #255
 3779 202c 82008DE8 		stmia	sp, {r1, r7}
 3780 2030 4C139FE5 		ldr	r1, .L467+40
 3781 2034 08708DE5 		str	r7, [sp, #8]
 3782 2038 0400A0E3 		mov	r0, #4
 3783 203c FEFFFFEB 		bl	CyU3PDebugPrint
 3784              	.LVL432:
2638:../uvc.c      **** 
 3785              		.loc 1 2638 0
 3786 2040 07A0A0E1 		mov	r10, r7
 3787              	.LVL433:
 3788 2044 18909DE5 		ldr	r9, [sp, #24]
 3789              	.LVL434:
 3790 2048 1C509DE5 		ldr	r5, [sp, #28]
 3791 204c 4FFDFFEA 		b	.L284
 3792              	.LVL435:
 3793              	.L354:
2589:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 3794              		.loc 1 2589 0
 3795 2050 4C439FE5 		ldr	r4, .L467+72
 3796 2054 0010E0E3 		mvn	r1, #0
 3797 2058 1C0094E5 		ldr	r0, [r4, #28]
 3798 205c 14308DE5 		str	r3, [sp, #20]
 3799 2060 FEFFFFEB 		bl	_txe_mutex_get
 3800              	.LVL436:
2590:../uvc.c      **** 							 {
 3801              		.loc 1 2590 0
 3802 2064 14309DE5 		ldr	r3, [sp, #20]
 3803 2068 18109DE5 		ldr	r1, [sp, #24]
 3804 206c 033187E0 		add	r3, r7, r3, asl #2
 3805 2070 207093E5 		ldr	r7, [r3, #32]
 3806 2074 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3807 2078 010053E1 		cmp	r3, r1
 3808 207c 0201001A 		bne	.L434
 3809 2080 14539FE5 		ldr	r5, .L467+64
 3810              	.L364:
2596:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3811              		.loc 1 2596 0
 3812 2084 0E30D7E5 		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3813 2088 1C209DE5 		ldr	r2, [sp, #28]
 3814 208c 020053E1 		cmp	r3, r2
 3815 2090 0500000A 		beq	.L366
2598:../uvc.c      **** 									 dataIdx++;
 3816              		.loc 1 2598 0
 3817 2094 18009DE5 		ldr	r0, [sp, #24]
2597:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 3818              		.loc 1 2597 0
 3819 2098 0E20C7E5 		strb	r2, [r7, #14]
2598:../uvc.c      **** 									 dataIdx++;
 3820              		.loc 1 2598 0
 3821 209c 023040E2 		sub	r3, r0, #2
 3822 20a0 FF3003E2 		and	r3, r3, #255
 3823 20a4 010053E3 		cmp	r3, #1
 3824 20a8 ED01009A 		bls	.L460
 3825              	.LVL437:
 3826              	.L366:
2603:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3827              		.loc 1 2603 0
 3828 20ac 0130A0E3 		mov	r3, #1
 3829 20b0 1130C7E5 		strb	r3, [r7, #17]
2604:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3830              		.loc 1 2604 0
 3831 20b4 1C0094E5 		ldr	r0, [r4, #28]
 3832 20b8 FEFFFFEB 		bl	_txe_mutex_put
 3833              	.LVL438:
2606:../uvc.c      **** 							 break;
 3834              		.loc 1 2606 0
 3835 20bc 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
2605:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3836              		.loc 1 2605 0
 3837 20c0 18909DE5 		ldr	r9, [sp, #24]
 3838              	.LVL439:
2606:../uvc.c      **** 							 break;
 3839              		.loc 1 2606 0
 3840 20c4 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3841 20c8 8115D5E5 		ldrb	r1, [r5, #1409]	@ zero_extendqisi2
2605:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3842              		.loc 1 2605 0
 3843 20cc FF70A0E3 		mov	r7, #255
 3844 20d0 02028DE8 		stmia	sp, {r1, r9}
 3845 20d4 AC129FE5 		ldr	r1, .L467+44
 3846 20d8 08708DE5 		str	r7, [sp, #8]
 3847 20dc 0400A0E3 		mov	r0, #4
 3848 20e0 FEFFFFEB 		bl	CyU3PDebugPrint
 3849              	.LVL440:
2607:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 3850              		.loc 1 2607 0
 3851 20e4 07A0A0E1 		mov	r10, r7
 3852              	.LVL441:
 3853 20e8 1C509DE5 		ldr	r5, [sp, #28]
 3854 20ec 27FDFFEA 		b	.L284
 3855              	.LVL442:
 3856              	.L352:
2609:../uvc.c      **** 	#if 1	// register setting directly
 3857              		.loc 1 2609 0
 3858 20f0 033187E0 		add	r3, r7, r3, asl #2
 3859 20f4 203093E5 		ldr	r3, [r3, #32]
2611:../uvc.c      **** 						     {
 3860              		.loc 1 2611 0
 3861 20f8 9C529FE5 		ldr	r5, .L467+64
2609:../uvc.c      **** 	#if 1	// register setting directly
 3862              		.loc 1 2609 0
 3863 20fc 18109DE5 		ldr	r1, [sp, #24]
 3864 2100 0D10C3E5 		strb	r1, [r3, #13]
2611:../uvc.c      **** 						     {
 3865              		.loc 1 2611 0
 3866 2104 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3867 2108 030013E3 		tst	r3, #3
 3868 210c 1A00000A 		beq	.L368
2613:../uvc.c      **** 						    	 dataIdx = 0;
 3869              		.loc 1 2613 0
 3870 2110 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
2615:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3871              		.loc 1 2615 0
 3872 2114 88429FE5 		ldr	r4, .L467+72
2613:../uvc.c      **** 						    	 dataIdx = 0;
 3873              		.loc 1 2613 0
 3874 2118 013283E1 		orr	r3, r3, r1, asl #4
 3875 211c FF3003E2 		and	r3, r3, #255
2615:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3876              		.loc 1 2615 0
 3877 2120 0010E0E3 		mvn	r1, #0
 3878 2124 1C0094E5 		ldr	r0, [r4, #28]
2613:../uvc.c      **** 						    	 dataIdx = 0;
 3879              		.loc 1 2613 0
 3880 2128 18308DE5 		str	r3, [sp, #24]
 3881              	.LVL443:
2615:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3882              		.loc 1 2615 0
 3883 212c FEFFFFEB 		bl	_txe_mutex_get
 3884              	.LVL444:
2616:../uvc.c      **** 								 dataIdx++;
 3885              		.loc 1 2616 0
 3886 2130 0030A0E3 		mov	r3, #0
 3887 2134 0B20A0E1 		mov	r2, fp
 3888 2138 00308DE5 		str	r3, [sp]
 3889 213c 04308DE5 		str	r3, [sp, #4]
 3890 2140 1010A0E3 		mov	r1, #16
 3891 2144 0930A0E1 		mov	r3, r9
 3892 2148 0400A0E1 		mov	r0, r4
 3893 214c FEFFFFEB 		bl	cmdSet
 3894              	.LVL445:
2618:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3895              		.loc 1 2618 0
 3896 2150 18209DE5 		ldr	r2, [sp, #24]
 3897 2154 0110A0E3 		mov	r1, #1
 3898 2158 00208DE5 		str	r2, [sp]
 3899 215c 04108DE5 		str	r1, [sp, #4]
 3900 2160 0A20A0E1 		mov	r2, r10
 3901 2164 0930A0E1 		mov	r3, r9
 3902 2168 0400A0E1 		mov	r0, r4
 3903 216c 1010A0E3 		mov	r1, #16
 3904 2170 FEFFFFEB 		bl	cmdSet
 3905              	.LVL446:
2619:../uvc.c      **** 						     }
 3906              		.loc 1 2619 0
 3907 2174 1C0094E5 		ldr	r0, [r4, #28]
 3908 2178 FEFFFFEB 		bl	_txe_mutex_put
 3909              	.LVL447:
 3910              	.L368:
2622:../uvc.c      **** 						     break;
 3911              		.loc 1 2622 0
 3912 217c 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
2621:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3913              		.loc 1 2621 0
 3914 2180 18909DE5 		ldr	r9, [sp, #24]
 3915              	.LVL448:
2622:../uvc.c      **** 						     break;
 3916              		.loc 1 2622 0
 3917 2184 8135D5E5 		ldrb	r3, [r5, #1409]	@ zero_extendqisi2
2621:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3918              		.loc 1 2621 0
 3919 2188 1C509DE5 		ldr	r5, [sp, #28]
 3920 218c 0C008DE8 		stmia	sp, {r2, r3}
 3921 2190 F4119FE5 		ldr	r1, .L467+48
 3922 2194 0520A0E1 		mov	r2, r5
 3923 2198 0930A0E1 		mov	r3, r9
 3924 219c 0400A0E3 		mov	r0, #4
2623:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 3925              		.loc 1 2623 0
 3926 21a0 FF70A0E3 		mov	r7, #255
2621:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3927              		.loc 1 2621 0
 3928 21a4 FEFFFFEB 		bl	CyU3PDebugPrint
 3929              	.LVL449:
2623:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 3930              		.loc 1 2623 0
 3931 21a8 07A0A0E1 		mov	r10, r7
 3932              	.LVL450:
 3933 21ac F7FCFFEA 		b	.L284
 3934              	.LVL451:
 3935              	.L357:
2583:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 3936              		.loc 1 2583 0 discriminator 1
 3937 21b0 000058E3 		cmp	r8, #0
 3938 21b4 0300000A 		beq	.L363
 3939 21b8 D0019FE5 		ldr	r0, .L467+52
 3940 21bc 0820A0E1 		mov	r2, r8
 3941 21c0 6C1040E2 		sub	r1, r0, #108
 3942 21c4 FEFFFFEB 		bl	memcpy
 3943              	.LVL452:
 3944              	.L363:
2587:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 3945              		.loc 1 2587 0
 3946 21c8 FF70A0E3 		mov	r7, #255
2586:../uvc.c      **** 							 break;
 3947              		.loc 1 2586 0
 3948 21cc FEFFFFEB 		bl	I2CCmdHandler
 3949              	.LVL453:
2587:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 3950              		.loc 1 2587 0
 3951 21d0 07A0A0E1 		mov	r10, r7
 3952              	.LVL454:
 3953 21d4 18909DE5 		ldr	r9, [sp, #24]
 3954              	.LVL455:
 3955 21d8 1C509DE5 		ldr	r5, [sp, #28]
 3956 21dc EBFCFFEA 		b	.L284
 3957              	.LVL456:
 3958              	.L356:
2551:../uvc.c      **** 					 {
 3959              		.loc 1 2551 0
 3960 21e0 FF70A0E3 		mov	r7, #255
 3961 21e4 18909DE5 		ldr	r9, [sp, #24]
 3962              	.LVL457:
 3963 21e8 1C509DE5 		ldr	r5, [sp, #28]
 3964 21ec 07A0A0E1 		mov	r10, r7
 3965              	.LVL458:
 3966 21f0 E6FCFFEA 		b	.L284
 3967              	.LVL459:
 3968              	.L379:
2913:../uvc.c      **** 			 	 			 {
 3969              		.loc 1 2913 0
 3970 21f4 020058E3 		cmp	r8, #2
 3971 21f8 2301000A 		beq	.L461
2923:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3972              		.loc 1 2923 0
 3973 21fc 040058E3 		cmp	r8, #4
 3974 2200 6501000A 		beq	.L409
 3975 2204 055187E0 		add	r5, r7, r5, asl #2
 3976 2208 207195E5 		ldr	r7, [r5, #288]
 3977              	.LVL460:
 3978              	.L408:
2940:../uvc.c      **** 			 	 			 break;
 3979              		.loc 1 2940 0
 3980 220c 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
2939:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3981              		.loc 1 2939 0
 3982 2210 18909DE5 		ldr	r9, [sp, #24]
 3983              	.LVL461:
2940:../uvc.c      **** 			 	 			 break;
 3984              		.loc 1 2940 0
 3985 2214 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
2939:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3986              		.loc 1 2939 0
 3987 2218 1C509DE5 		ldr	r5, [sp, #28]
 3988 221c 0C018DE8 		stmia	sp, {r2, r3, r8}
 3989 2220 6C119FE5 		ldr	r1, .L467+56
 3990 2224 0920A0E1 		mov	r2, r9
 3991 2228 0530A0E1 		mov	r3, r5
 3992 222c 0400A0E3 		mov	r0, #4
2941:../uvc.c      **** 					 }
 3993              		.loc 1 2941 0
 3994 2230 FF70A0E3 		mov	r7, #255
2939:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3995              		.loc 1 2939 0
 3996 2234 FEFFFFEB 		bl	CyU3PDebugPrint
 3997              	.LVL462:
2941:../uvc.c      **** 					 }
 3998              		.loc 1 2941 0
 3999 2238 07A0A0E1 		mov	r10, r7
 4000              	.LVL463:
 4001 223c D3FCFFEA 		b	.L284
 4002              	.LVL464:
 4003              	.L351:
2727:../uvc.c      **** 				 	 			 {
 4004              		.loc 1 2727 0
 4005 2240 020058E3 		cmp	r8, #2
 4006 2244 3801000A 		beq	.L462
2737:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 4007              		.loc 1 2737 0
 4008 2248 040058E3 		cmp	r8, #4
 4009 224c 8D01000A 		beq	.L376
 4010 2250 033187E0 		add	r3, r7, r3, asl #2
 4011 2254 207093E5 		ldr	r7, [r3, #32]
 4012 2258 EBFFFFEA 		b	.L408
 4013              	.LVL465:
 4014              	.L347:
2945:../uvc.c      **** 			   }
 4015              		.loc 1 2945 0
 4016 225c 0400A0E3 		mov	r0, #4
 4017              	.LVL466:
 4018 2260 30119FE5 		ldr	r1, .L467+60
 4019 2264 FEFFFFEB 		bl	CyU3PDebugPrint
 4020              	.LVL467:
 4021 2268 FF70A0E3 		mov	r7, #255
 4022 226c 0090A0E3 		mov	r9, #0
 4023              	.LVL468:
 4024 2270 07A0A0E1 		mov	r10, r7
 4025              	.LVL469:
 4026 2274 0950A0E1 		mov	r5, r9
 4027 2278 C4FCFFEA 		b	.L284
 4028              	.LVL470:
 4029              	.L301:
1652:../uvc.c      **** 			 	 			 {
 4030              		.loc 1 1652 0
 4031 227c 020058E3 		cmp	r8, #2
 4032 2280 8901000A 		beq	.L463
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4033              		.loc 1 1660 0
 4034 2284 040058E3 		cmp	r8, #4
 4035 2288 FF70A013 		movne	r7, #255
 4036 228c 07A0A011 		movne	r10, r7
 4037              	.LVL471:
 4038 2290 A701000A 		beq	.L464
 4039              	.LVL472:
 4040              	.L305:
1670:../uvc.c      **** 			 	 		 }
 4041              		.loc 1 1670 0
 4042 2294 055084E0 		add	r5, r4, r5
 4043 2298 0130A0E3 		mov	r3, #1
 4044 229c A030C5E5 		strb	r3, [r5, #160]
 4045              	.L439:
 4046 22a0 0090A0E3 		mov	r9, #0
 4047              	.LVL473:
 4048 22a4 80FDFFEA 		b	.L292
 4049              	.LVL474:
 4050              	.L323:
1843:../uvc.c      **** 			 	 			 {
 4051              		.loc 1 1843 0
 4052 22a8 020058E3 		cmp	r8, #2
 4053 22ac 5E01000A 		beq	.L465
1851:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4054              		.loc 1 1851 0
 4055 22b0 040058E3 		cmp	r8, #4
 4056 22b4 FF70A013 		movne	r7, #255
 4057 22b8 07A0A011 		movne	r10, r7
 4058              	.LVL475:
 4059 22bc 8801000A 		beq	.L466
 4060              	.LVL476:
 4061              	.L327:
1861:../uvc.c      **** 			 	 		 }
 4062              		.loc 1 1861 0
 4063 22c0 055084E0 		add	r5, r4, r5
 4064 22c4 0130A0E3 		mov	r3, #1
 4065 22c8 0090A0E3 		mov	r9, #0
 4066              	.LVL477:
 4067 22cc A030C5E5 		strb	r3, [r5, #160]
 4068 22d0 75FDFFEA 		b	.L292
 4069              	.LVL478:
 4070              	.L321:
1748:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4071              		.loc 1 1748 0
 4072 22d4 0A00A0E1 		mov	r0, r10
 4073              	.LVL479:
 4074 22d8 0910A0E1 		mov	r1, r9
 4075 22dc FEFFFFEB 		bl	SensorGetControl
 4076              	.LVL480:
1749:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4077              		.loc 1 1749 0
 4078 22e0 0910A0E1 		mov	r1, r9
1748:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4079              		.loc 1 1748 0
 4080 22e4 0020A0E1 		mov	r2, r0
 4081              	.LVL481:
1749:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4082              		.loc 1 1749 0
 4083 22e8 0B00A0E1 		mov	r0, fp
 4084              	.LVL482:
 4085 22ec 14208DE5 		str	r2, [sp, #20]
 4086 22f0 FEFFFFEB 		bl	SensorGetControl
 4087              	.LVL483:
1754:../uvc.c      **** 						 }
 4088              		.loc 1 1754 0
 4089 22f4 14209DE5 		ldr	r2, [sp, #20]
1751:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4090              		.loc 1 1751 0
 4091 22f8 9C309FE5 		ldr	r3, .L467+64
1754:../uvc.c      **** 						 }
 4092              		.loc 1 1754 0
 4093 22fc 0110A0E3 		mov	r1, #1
 4094 2300 02A0A0E1 		mov	r10, r2
 4095              	.LVL484:
1750:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4096              		.loc 1 1750 0
 4097 2304 2820C4E5 		strb	r2, [r4, #40]
1751:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4098              		.loc 1 1751 0
 4099 2308 5C25C3E5 		strb	r2, [r3, #1372]
1754:../uvc.c      **** 						 }
 4100              		.loc 1 1754 0
 4101 230c AB10C4E5 		strb	r1, [r4, #171]
1749:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4102              		.loc 1 1749 0
 4103 2310 18008DE5 		str	r0, [sp, #24]
 4104              	.LVL485:
1754:../uvc.c      **** 						 }
 4105              		.loc 1 1754 0
 4106 2314 0070A0E1 		mov	r7, r0
1752:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4107              		.loc 1 1752 0
 4108 2318 2A00C4E5 		strb	r0, [r4, #42]
1753:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4109              		.loc 1 1753 0
 4110 231c 5E05C3E5 		strb	r0, [r3, #1374]
 4111 2320 5DFDFFEA 		b	.L322
 4112              	.LVL486:
 4113              	.L296:
1365:../uvc.c      **** 							if(Data0&0x80)
 4114              		.loc 1 1365 0
 4115 2324 0A00A0E1 		mov	r0, r10
 4116              	.LVL487:
 4117 2328 0910A0E1 		mov	r1, r9
 4118 232c FEFFFFEB 		bl	SensorGetControl
 4119              	.LVL488:
1370:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4120              		.loc 1 1370 0
 4121 2330 64109FE5 		ldr	r1, .L467+64
1372:../uvc.c      **** 						 }
 4122              		.loc 1 1372 0
 4123 2334 0130A0E3 		mov	r3, #1
 4124 2338 0570A0E1 		mov	r7, r5
1371:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4125              		.loc 1 1371 0
 4126 233c 2950C4E5 		strb	r5, [r4, #41]
1372:../uvc.c      **** 						 }
 4127              		.loc 1 1372 0
 4128 2340 C630C4E5 		strb	r3, [r4, #198]
1366:../uvc.c      **** 								glEp0Buffer[0] = 1;
 4129              		.loc 1 1366 0
 4130 2344 FFA000E2 		and	r10, r0, #255
 4131              	.LVL489:
1367:../uvc.c      **** 							else
 4132              		.loc 1 1367 0
 4133 2348 AAA3A0E1 		mov	r10, r10, lsr #7
1365:../uvc.c      **** 							if(Data0&0x80)
 4134              		.loc 1 1365 0
 4135 234c 0020A0E1 		mov	r2, r0
 4136              	.LVL490:
 4137 2350 28A0C4E5 		strb	r10, [r4, #40]
1370:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4138              		.loc 1 1370 0
 4139 2354 05A5C1E5 		strb	r10, [r1, #1285]
 4140 2358 79FDFFEA 		b	.L320
 4141              	.L468:
 4142              		.align	2
 4143              	.L467:
 4144 235c 00000000 		.word	.LANCHOR2
 4145 2360 00000000 		.word	bRequest
 4146 2364 00000000 		.word	.LANCHOR0
 4147 2368 68040000 		.word	.LC27
 4148 236c 28000000 		.word	.LANCHOR0+40
 4149 2370 14060000 		.word	.LC35
 4150 2374 38040000 		.word	.LC26
 4151 2378 FC030000 		.word	.LC25
 4152 237c D4030000 		.word	.LC24
 4153 2380 A0050000 		.word	.LC32
 4154 2384 14050000 		.word	.LC30
 4155 2388 B4040000 		.word	.LC28
 4156 238c E8040000 		.word	.LC29
 4157 2390 94000000 		.word	.LANCHOR0+148
 4158 2394 4C050000 		.word	.LC31
 4159 2398 E4050000 		.word	.LC34
 4160 239c 00000000 		.word	.LANCHOR1
 4161 23a0 C0050000 		.word	.LC33
 4162 23a4 00000000 		.word	cmdQu
 4163              	.LVL491:
 4164              	.L318:
1732:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4165              		.loc 1 1732 0
 4166 23a8 0910A0E1 		mov	r1, r9
 4167 23ac 0100A0E3 		mov	r0, #1
 4168              	.LVL492:
 4169 23b0 FEFFFFEB 		bl	SensorGetControl
 4170              	.LVL493:
1735:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4171              		.loc 1 1735 0
 4172 23b4 20101FE5 		ldr	r1, .L467+64
1733:../uvc.c      **** 							glEp0Buffer[0]++;
 4173              		.loc 1 1733 0
 4174 23b8 A033A0E1 		mov	r3, r0, lsr #7
1734:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4175              		.loc 1 1734 0
 4176 23bc 013083E2 		add	r3, r3, #1
 4177 23c0 FF3003E2 		and	r3, r3, #255
1735:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4178              		.loc 1 1735 0
 4179 23c4 5535C1E5 		strb	r3, [r1, #1365]
1736:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4180              		.loc 1 1736 0
 4181 23c8 5615D1E5 		ldrb	r1, [r1, #1366]	@ zero_extendqisi2
1732:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4182              		.loc 1 1732 0
 4183 23cc 0020A0E1 		mov	r2, r0
 4184              	.LVL494:
1736:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4185              		.loc 1 1736 0
 4186 23d0 FF1001E2 		and	r1, r1, #255
1737:../uvc.c      **** 						 }
 4187              		.loc 1 1737 0
 4188 23d4 0100A0E3 		mov	r0, #1
 4189              	.LVL495:
 4190 23d8 03A0A0E1 		mov	r10, r3
 4191              	.LVL496:
 4192 23dc 0170A0E1 		mov	r7, r1
1734:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4193              		.loc 1 1734 0
 4194 23e0 2830C4E5 		strb	r3, [r4, #40]
1736:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4195              		.loc 1 1736 0
 4196 23e4 2910C4E5 		strb	r1, [r4, #41]
1737:../uvc.c      **** 						 }
 4197              		.loc 1 1737 0
 4198 23e8 A400C4E5 		strb	r0, [r4, #164]
 4199 23ec 54FDFFEA 		b	.L320
 4200              	.LVL497:
 4201              	.L316:
1712:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4202              		.loc 1 1712 0
 4203 23f0 0A00A0E1 		mov	r0, r10
 4204              	.LVL498:
 4205 23f4 0910A0E1 		mov	r1, r9
 4206 23f8 FEFFFFEB 		bl	SensorGetControl
 4207              	.LVL499:
1713:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4208              		.loc 1 1713 0
 4209 23fc 68201FE5 		ldr	r2, .L467+64
1714:../uvc.c      **** 						 }
 4210              		.loc 1 1714 0
 4211 2400 0130A0E3 		mov	r3, #1
 4212 2404 A530C4E5 		strb	r3, [r4, #165]
1713:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4213              		.loc 1 1713 0
 4214 2408 4105C2E5 		strb	r0, [r2, #1345]
 4215 240c 39FDFFEA 		b	.L317
 4216              	.LVL500:
 4217              	.L312:
1694:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4218              		.loc 1 1694 0
 4219 2410 0A00A0E1 		mov	r0, r10
 4220              	.LVL501:
 4221 2414 0910A0E1 		mov	r1, r9
 4222 2418 FEFFFFEB 		bl	SensorGetControl
 4223              	.LVL502:
1695:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4224              		.loc 1 1695 0
 4225 241c 88201FE5 		ldr	r2, .L467+64
1696:../uvc.c      **** 						 }
 4226              		.loc 1 1696 0
 4227 2420 0130A0E3 		mov	r3, #1
 4228 2424 A130C4E5 		strb	r3, [r4, #161]
1695:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4229              		.loc 1 1695 0
 4230 2428 2D05C2E5 		strb	r0, [r2, #1325]
 4231 242c 57FDFFEA 		b	.L313
 4232              	.LVL503:
 4233              	.L298:
1382:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4234              		.loc 1 1382 0
 4235 2430 0A00A0E1 		mov	r0, r10
 4236              	.LVL504:
 4237 2434 0910A0E1 		mov	r1, r9
 4238 2438 FEFFFFEB 		bl	SensorGetControl
 4239              	.LVL505:
1384:../uvc.c      **** 
 4240              		.loc 1 1384 0
 4241 243c A8501FE5 		ldr	r5, .L467+64
1386:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4242              		.loc 1 1386 0
 4243 2440 0910A0E1 		mov	r1, r9
1383:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4244              		.loc 1 1383 0
 4245 2444 033000E2 		and	r3, r0, #3
1386:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4246              		.loc 1 1386 0
 4247 2448 0B00A0E1 		mov	r0, fp
1383:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4248              		.loc 1 1383 0
 4249 244c 2830C4E5 		strb	r3, [r4, #40]
1384:../uvc.c      **** 
 4250              		.loc 1 1384 0
 4251 2450 1935C5E5 		strb	r3, [r5, #1305]
1386:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4252              		.loc 1 1386 0
 4253 2454 FEFFFFEB 		bl	SensorGetControl
 4254              	.LVL506:
1388:../uvc.c      **** 			 	 		 }
 4255              		.loc 1 1388 0
 4256 2458 0130A0E3 		mov	r3, #1
 4257 245c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4258              	.LVL507:
 4259 2460 B930C4E5 		strb	r3, [r4, #185]
 4260 2464 0070A0E1 		mov	r7, r0
1386:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4261              		.loc 1 1386 0
 4262 2468 2A00C4E5 		strb	r0, [r4, #42]
1387:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4263              		.loc 1 1387 0
 4264 246c 1A05C5E5 		strb	r0, [r5, #1306]
 4265 2470 6FFDFFEA 		b	.L299
 4266              	.LVL508:
 4267              	.L404:
2903:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4268              		.loc 1 2903 0
 4269 2474 FEFFFFEB 		bl	_txe_mutex_get
 4270              	.LVL509:
2904:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4271              		.loc 1 2904 0
 4272 2478 18209DE5 		ldr	r2, [sp, #24]
 4273 247c 00208DE5 		str	r2, [sp]
 4274 2480 04208DE5 		str	r2, [sp, #4]
 4275 2484 0A20A0E1 		mov	r2, r10
 4276 2488 B6FDFFEA 		b	.L442
 4277              	.L434:
2593:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4278              		.loc 1 2593 0
 4279 248c F8501FE5 		ldr	r5, .L467+64
2592:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4280              		.loc 1 2592 0
 4281 2490 0D10C7E5 		strb	r1, [r7, #13]
2593:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4282              		.loc 1 2593 0
 4283 2494 8125D5E5 		ldrb	r2, [r5, #1409]	@ zero_extendqisi2
2594:../uvc.c      **** 							 }
 4284              		.loc 1 2594 0
 4285 2498 0030A0E3 		mov	r3, #0
2593:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4286              		.loc 1 2593 0
 4287 249c 022281E1 		orr	r2, r1, r2, asl #4
 4288 24a0 FF2002E2 		and	r2, r2, #255
 4289 24a4 18208DE5 		str	r2, [sp, #24]
 4290              	.LVL510:
2594:../uvc.c      **** 							 }
 4291              		.loc 1 2594 0
 4292 24a8 18109DE5 		ldr	r1, [sp, #24]
 4293 24ac 0A20A0E1 		mov	r2, r10
 4294 24b0 0A008DE8 		stmia	sp, {r1, r3}
 4295 24b4 0400A0E1 		mov	r0, r4
 4296 24b8 1910A0E3 		mov	r1, #25
 4297 24bc 0930A0E1 		mov	r3, r9
 4298 24c0 FEFFFFEB 		bl	cmdSet
 4299              	.LVL511:
 4300 24c4 EEFEFFEA 		b	.L364
 4301              	.LVL512:
 4302              	.L456:
2832:../uvc.c      **** 			                         {
 4303              		.loc 1 2832 0
 4304 24c8 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4305 24cc 013043E2 		sub	r3, r3, #1
 4306 24d0 030053E3 		cmp	r3, #3
 4307 24d4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4308 24d8 18FEFFEA 		b	.L390
 4309              	.L392:
 4310 24dc F8250000 		.word	.L391
 4311 24e0 AC250000 		.word	.L393
 4312 24e4 4C250000 		.word	.L394
 4313 24e8 EC240000 		.word	.L395
 4314              	.L395:
2850:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4315              		.loc 1 2850 0
 4316 24ec 58511FE5 		ldr	r5, .L467+64
 4317 24f0 6C2094E5 		ldr	r2, [r4, #108]
 4318 24f4 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4319 24f8 000052E3 		cmp	r2, #0
 4320 24fc B020A003 		moveq	r2, #176
 4321 2500 3020A013 		movne	r2, #48
 4322 2504 032082E1 		orr	r2, r2, r3
 4323 2508 3010A0E3 		mov	r1, #48
 4324 250c 5230A0E3 		mov	r3, #82
 4325 2510 0100A0E3 		mov	r0, #1
 4326 2514 FEFFFFEB 		bl	SensorSetIrisControl
 4327              	.LVL513:
2851:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4328              		.loc 1 2851 0
 4329 2518 7D0FA0E3 		mov	r0, #500
 4330 251c FEFFFFEB 		bl	_tx_thread_sleep
 4331              	.LVL514:
2852:../uvc.c      **** 			                         	default:
 4332              		.loc 1 2852 0
 4333 2520 6C1094E5 		ldr	r1, [r4, #108]
 4334 2524 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4335 2528 000051E3 		cmp	r1, #0
 4336 252c B010A003 		moveq	r1, #176
 4337 2530 3010A013 		movne	r1, #48
 4338 2534 022081E1 		orr	r2, r1, r2
 4339 2538 6C3094E5 		ldr	r3, [r4, #108]
 4340 253c A4111FE5 		ldr	r1, .L467+68
 4341 2540 0400A0E3 		mov	r0, #4
 4342 2544 FEFFFFEB 		bl	CyU3PDebugPrint
 4343              	.LVL515:
 4344 2548 FCFDFFEA 		b	.L390
 4345              	.L394:
2845:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4346              		.loc 1 2845 0
 4347 254c B8511FE5 		ldr	r5, .L467+64
 4348 2550 6C2094E5 		ldr	r2, [r4, #108]
 4349 2554 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4350 2558 000052E3 		cmp	r2, #0
 4351 255c 8020A003 		moveq	r2, #128
 4352 2560 0020A013 		movne	r2, #0
 4353 2564 032082E1 		orr	r2, r2, r3
 4354 2568 3010A0E3 		mov	r1, #48
 4355 256c 5230A0E3 		mov	r3, #82
 4356 2570 0100A0E3 		mov	r0, #1
 4357 2574 FEFFFFEB 		bl	SensorSetIrisControl
 4358              	.LVL516:
2846:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4359              		.loc 1 2846 0
 4360 2578 7D0FA0E3 		mov	r0, #500
 4361 257c FEFFFFEB 		bl	_tx_thread_sleep
 4362              	.LVL517:
2847:../uvc.c      **** 			                         		break;
 4363              		.loc 1 2847 0
 4364 2580 6C1094E5 		ldr	r1, [r4, #108]
 4365 2584 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4366 2588 000051E3 		cmp	r1, #0
 4367 258c 8010A003 		moveq	r1, #128
 4368 2590 0010A013 		movne	r1, #0
 4369 2594 022081E1 		orr	r2, r1, r2
 4370 2598 6C3094E5 		ldr	r3, [r4, #108]
 4371 259c 04121FE5 		ldr	r1, .L467+68
 4372 25a0 0400A0E3 		mov	r0, #4
 4373 25a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4374              	.LVL518:
2848:../uvc.c      **** 			                         	case 4: //VGA
 4375              		.loc 1 2848 0
 4376 25a8 E4FDFFEA 		b	.L390
 4377              	.L393:
2840:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4378              		.loc 1 2840 0
 4379 25ac 6C2094E5 		ldr	r2, [r4, #108]
 4380 25b0 3010A0E3 		mov	r1, #48
 4381 25b4 000052E3 		cmp	r2, #0
 4382 25b8 9220A003 		moveq	r2, #146
 4383 25bc 1220A013 		movne	r2, #18
 4384 25c0 5230A0E3 		mov	r3, #82
 4385 25c4 0100A0E3 		mov	r0, #1
 4386 25c8 FEFFFFEB 		bl	SensorSetIrisControl
 4387              	.LVL519:
2841:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4388              		.loc 1 2841 0
 4389 25cc 7D0FA0E3 		mov	r0, #500
 4390 25d0 FEFFFFEB 		bl	_tx_thread_sleep
 4391              	.LVL520:
2842:../uvc.c      **** 			                         		break;
 4392              		.loc 1 2842 0
 4393 25d4 6C2094E5 		ldr	r2, [r4, #108]
 4394 25d8 40121FE5 		ldr	r1, .L467+68
 4395 25dc 000052E3 		cmp	r2, #0
 4396 25e0 6C3094E5 		ldr	r3, [r4, #108]
 4397 25e4 9220A003 		moveq	r2, #146
 4398 25e8 1220A013 		movne	r2, #18
 4399 25ec 0400A0E3 		mov	r0, #4
 4400 25f0 FEFFFFEB 		bl	CyU3PDebugPrint
 4401              	.LVL521:
2843:../uvc.c      **** 			                         	case 3: //720
 4402              		.loc 1 2843 0
 4403 25f4 D1FDFFEA 		b	.L390
 4404              	.L391:
2835:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4405              		.loc 1 2835 0
 4406 25f8 6C2094E5 		ldr	r2, [r4, #108]
 4407 25fc 3010A0E3 		mov	r1, #48
 4408 2600 000052E3 		cmp	r2, #0
 4409 2604 A220A003 		moveq	r2, #162
 4410 2608 2220A013 		movne	r2, #34
 4411 260c 5230A0E3 		mov	r3, #82
 4412 2610 0100A0E3 		mov	r0, #1
 4413 2614 FEFFFFEB 		bl	SensorSetIrisControl
 4414              	.LVL522:
2836:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4415              		.loc 1 2836 0
 4416 2618 7D0FA0E3 		mov	r0, #500
 4417 261c FEFFFFEB 		bl	_tx_thread_sleep
 4418              	.LVL523:
2837:../uvc.c      **** 			                         		break;
 4419              		.loc 1 2837 0
 4420 2620 6C2094E5 		ldr	r2, [r4, #108]
 4421 2624 8C121FE5 		ldr	r1, .L467+68
 4422 2628 000052E3 		cmp	r2, #0
 4423 262c 6C3094E5 		ldr	r3, [r4, #108]
 4424 2630 A220A003 		moveq	r2, #162
 4425 2634 2220A013 		movne	r2, #34
 4426 2638 0400A0E3 		mov	r0, #4
 4427 263c FEFFFFEB 		bl	CyU3PDebugPrint
 4428              	.LVL524:
2838:../uvc.c      **** 			                         	case 2: //1080
 4429              		.loc 1 2838 0
 4430 2640 BEFDFFEA 		b	.L390
 4431              	.LVL525:
 4432              	.L371:
2629:../uvc.c      **** 									 dataIdx++;
 4433              		.loc 1 2629 0
 4434 2644 8010A0E3 		mov	r1, #128
 4435 2648 0030A0E3 		mov	r3, #0
 4436 264c 0A008DE8 		stmia	sp, {r1, r3}
 4437 2650 B4021FE5 		ldr	r0, .L467+72
 4438 2654 0A20A0E1 		mov	r2, r10
 4439 2658 0930A0E1 		mov	r3, r9
 4440 265c 1B10A0E3 		mov	r1, #27
 4441 2660 FEFFFFEB 		bl	cmdSet
 4442              	.LVL526:
2631:../uvc.c      **** 								 }
 4443              		.loc 1 2631 0
 4444 2664 18209DE5 		ldr	r2, [sp, #24]
 4445 2668 0110A0E3 		mov	r1, #1
 4446 266c 00208DE5 		str	r2, [sp]
 4447 2670 04108DE5 		str	r1, [sp, #4]
 4448 2674 0B20A0E1 		mov	r2, fp
 4449 2678 0930A0E1 		mov	r3, r9
 4450 267c 1B10A0E3 		mov	r1, #27
 4451 2680 E4021FE5 		ldr	r0, .L467+72
 4452 2684 FEFFFFEB 		bl	cmdSet
 4453              	.LVL527:
 4454 2688 61FEFFEA 		b	.L370
 4455              	.LVL528:
 4456              	.L461:
2915:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4457              		.loc 1 2915 0
 4458 268c 057187E0 		add	r7, r7, r5, asl #2
 4459 2690 207197E5 		ldr	r7, [r7, #288]
 4460 2694 18009DE5 		ldr	r0, [sp, #24]
 4461 2698 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4462 269c 000053E1 		cmp	r3, r0
 4463 26a0 1100000A 		beq	.L407
2916:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4464              		.loc 1 2916 0
 4465 26a4 08431FE5 		ldr	r4, .L467+72
 4466 26a8 0010E0E3 		mvn	r1, #0
 4467 26ac 1C0094E5 		ldr	r0, [r4, #28]
 4468 26b0 FEFFFFEB 		bl	_txe_mutex_get
 4469              	.LVL529:
2917:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4470              		.loc 1 2917 0
 4471 26b4 18109DE5 		ldr	r1, [sp, #24]
 4472 26b8 00B0A0E3 		mov	fp, #0
 4473              	.LVL530:
 4474 26bc 0A20A0E1 		mov	r2, r10
 4475 26c0 00108DE5 		str	r1, [sp]
 4476 26c4 0930A0E1 		mov	r3, r9
 4477 26c8 0510A0E1 		mov	r1, r5
 4478 26cc 0400A0E1 		mov	r0, r4
 4479 26d0 04B08DE5 		str	fp, [sp, #4]
 4480 26d4 FEFFFFEB 		bl	cmdSet
 4481              	.LVL531:
2918:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4482              		.loc 1 2918 0
 4483 26d8 1C0094E5 		ldr	r0, [r4, #28]
 4484 26dc FEFFFFEB 		bl	_txe_mutex_put
 4485              	.LVL532:
2919:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4486              		.loc 1 2919 0
 4487 26e0 18209DE5 		ldr	r2, [sp, #24]
 4488 26e4 0D20C7E5 		strb	r2, [r7, #13]
2920:../uvc.c      **** 								 }
 4489              		.loc 1 2920 0
 4490 26e8 0EB0C7E5 		strb	fp, [r7, #14]
 4491              	.LVL533:
 4492              	.L407:
2922:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4493              		.loc 1 2922 0
 4494 26ec 0130A0E3 		mov	r3, #1
 4495 26f0 1130C7E5 		strb	r3, [r7, #17]
 4496 26f4 C4FEFFEA 		b	.L408
 4497              	.LVL534:
 4498              	.L457:
1830:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4499              		.loc 1 1830 0
 4500 26f8 005187E0 		add	r5, r7, r0, asl #2
 4501 26fc 203195E5 		ldr	r3, [r5, #288]
 4502              	.L437:
 4503 2700 0DA0D3E5 		ldrb	r10, [r3, #13]	@ zero_extendqisi2
 4504              	.LVL535:
 4505 2704 0090A0E3 		mov	r9, #0
 4506              	.LVL536:
 4507 2708 FFA00AE2 		and	r10, r10, #255
 4508 270c 28A0C4E5 		strb	r10, [r4, #40]
1831:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4509              		.loc 1 1831 0
 4510 2710 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4511 2714 FF7007E2 		and	r7, r7, #255
 4512 2718 2970C4E5 		strb	r7, [r4, #41]
 4513              	.LVL537:
 4514 271c 62FCFFEA 		b	.L292
 4515              	.LVL538:
 4516              	.L459:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4517              		.loc 1 1639 0
 4518 2720 005187E0 		add	r5, r7, r0, asl #2
 4519 2724 203015E5 		ldr	r3, [r5, #-32]
 4520 2728 F4FFFFEA 		b	.L437
 4521              	.LVL539:
 4522              	.L462:
2729:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4523              		.loc 1 2729 0
 4524 272c 033187E0 		add	r3, r7, r3, asl #2
 4525 2730 207093E5 		ldr	r7, [r3, #32]
 4526 2734 18109DE5 		ldr	r1, [sp, #24]
 4527 2738 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4528 273c 010053E1 		cmp	r3, r1
 4529 2740 E9FFFF0A 		beq	.L407
2730:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4530              		.loc 1 2730 0
 4531 2744 A8431FE5 		ldr	r4, .L467+72
 4532 2748 0010E0E3 		mvn	r1, #0
 4533 274c 1C0094E5 		ldr	r0, [r4, #28]
 4534 2750 FEFFFFEB 		bl	_txe_mutex_get
 4535              	.LVL540:
2731:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4536              		.loc 1 2731 0
 4537 2754 18209DE5 		ldr	r2, [sp, #24]
 4538 2758 00B0A0E3 		mov	fp, #0
 4539              	.LVL541:
 4540 275c 0930A0E1 		mov	r3, r9
 4541 2760 00208DE5 		str	r2, [sp]
 4542 2764 0510A0E1 		mov	r1, r5
 4543 2768 0A20A0E1 		mov	r2, r10
 4544 276c 0400A0E1 		mov	r0, r4
 4545 2770 04B08DE5 		str	fp, [sp, #4]
 4546 2774 FEFFFFEB 		bl	cmdSet
 4547              	.LVL542:
2732:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4548              		.loc 1 2732 0
 4549 2778 1C0094E5 		ldr	r0, [r4, #28]
 4550 277c FEFFFFEB 		bl	_txe_mutex_put
 4551              	.LVL543:
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 4552              		.loc 1 2733 0
 4553 2780 18309DE5 		ldr	r3, [sp, #24]
 4554 2784 0D30C7E5 		strb	r3, [r7, #13]
2734:../uvc.c      **** 									 }
 4555              		.loc 1 2734 0
 4556 2788 0EB0C7E5 		strb	fp, [r7, #14]
 4557              	.LVL544:
 4558 278c D6FFFFEA 		b	.L407
 4559              	.LVL545:
 4560              	.L458:
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4561              		.loc 1 1835 0
 4562 2790 005187E0 		add	r5, r7, r0, asl #2
 4563 2794 202195E5 		ldr	r2, [r5, #288]
 4564 2798 BCFDFFEA 		b	.L438
 4565              	.LVL546:
 4566              	.L409:
2924:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4567              		.loc 1 2924 0
 4568 279c 00441FE5 		ldr	r4, .L467+72
 4569 27a0 0010E0E3 		mvn	r1, #0
 4570 27a4 1C0094E5 		ldr	r0, [r4, #28]
 4571 27a8 FEFFFFEB 		bl	_txe_mutex_get
 4572              	.LVL547:
2925:../uvc.c      **** 								 {
 4573              		.loc 1 2925 0
 4574 27ac 057187E0 		add	r7, r7, r5, asl #2
 4575 27b0 207197E5 		ldr	r7, [r7, #288]
 4576              	.L448:
 4577 27b4 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4578 27b8 18009DE5 		ldr	r0, [sp, #24]
 4579 27bc 000053E1 		cmp	r3, r0
2928:../uvc.c      **** 									 dataIdx++;
 4580              		.loc 1 2928 0
 4581 27c0 0030A0E3 		mov	r3, #0
2925:../uvc.c      **** 								 {
 4582              		.loc 1 2925 0
 4583 27c4 0700000A 		beq	.L410
2927:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4584              		.loc 1 2927 0
 4585 27c8 0D00C7E5 		strb	r0, [r7, #13]
 4586              	.LVL548:
2928:../uvc.c      **** 									 dataIdx++;
 4587              		.loc 1 2928 0
 4588 27cc 0A20A0E1 		mov	r2, r10
 4589 27d0 09008DE8 		stmia	sp, {r0, r3}
 4590 27d4 0510A0E1 		mov	r1, r5
 4591 27d8 0930A0E1 		mov	r3, r9
 4592 27dc 0400A0E1 		mov	r0, r4
 4593 27e0 FEFFFFEB 		bl	cmdSet
 4594              	.LVL549:
2929:../uvc.c      **** 								 }
 4595              		.loc 1 2929 0
 4596 27e4 0130A0E3 		mov	r3, #1
 4597              	.LVL550:
 4598              	.L410:
2931:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4599              		.loc 1 2931 0
 4600 27e8 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4601 27ec 1C109DE5 		ldr	r1, [sp, #28]
 4602 27f0 010052E1 		cmp	r2, r1
 4603 27f4 0700000A 		beq	.L411
2932:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4604              		.loc 1 2932 0
 4605 27f8 0E10C7E5 		strb	r1, [r7, #14]
2933:../uvc.c      **** 								 }
 4606              		.loc 1 2933 0
 4607 27fc 1C209DE5 		ldr	r2, [sp, #28]
 4608 2800 0510A0E1 		mov	r1, r5
 4609 2804 0C008DE8 		stmia	sp, {r2, r3}
 4610 2808 6C041FE5 		ldr	r0, .L467+72
 4611 280c 0B20A0E1 		mov	r2, fp
 4612 2810 0930A0E1 		mov	r3, r9
 4613              	.LVL551:
 4614 2814 FEFFFFEB 		bl	cmdSet
 4615              	.LVL552:
 4616              	.L411:
2935:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4617              		.loc 1 2935 0
 4618 2818 0130A0E3 		mov	r3, #1
 4619 281c 1130C7E5 		strb	r3, [r7, #17]
2936:../uvc.c      **** 
 4620              		.loc 1 2936 0
 4621 2820 1C0094E5 		ldr	r0, [r4, #28]
 4622 2824 FEFFFFEB 		bl	_txe_mutex_put
 4623              	.LVL553:
 4624 2828 77FEFFEA 		b	.L408
 4625              	.LVL554:
 4626              	.L465:
1845:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4627              		.loc 1 1845 0
 4628 282c 0B00A0E1 		mov	r0, fp
 4629              	.LVL555:
 4630 2830 0910A0E1 		mov	r1, r9
 4631 2834 14308DE5 		str	r3, [sp, #20]
 4632 2838 FEFFFFEB 		bl	SensorGetControl
 4633              	.LVL556:
1846:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4634              		.loc 1 1846 0
 4635 283c 057187E0 		add	r7, r7, r5, asl #2
 4636 2840 202197E5 		ldr	r2, [r7, #288]
1845:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4637              		.loc 1 1845 0
 4638 2844 2800C4E5 		strb	r0, [r4, #40]
1846:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4639              		.loc 1 1846 0
 4640 2848 0D00C2E5 		strb	r0, [r2, #13]
 4641 284c 14309DE5 		ldr	r3, [sp, #20]
 4642 2850 00A0A0E1 		mov	r10, r0
 4643              	.LVL557:
1847:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4644              		.loc 1 1847 0
 4645 2854 2930C4E5 		strb	r3, [r4, #41]
 4646 2858 0370A0E1 		mov	r7, r3
1848:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4647              		.loc 1 1848 0
 4648 285c 0E30C2E5 		strb	r3, [r2, #14]
 4649              	.LVL558:
 4650 2860 96FEFFEA 		b	.L327
 4651              	.LVL559:
 4652              	.L460:
2600:../uvc.c      **** 								 }
 4653              		.loc 1 2600 0
 4654 2864 0110A0E3 		mov	r1, #1
 4655 2868 00208DE5 		str	r2, [sp]
 4656 286c 04108DE5 		str	r1, [sp, #4]
 4657 2870 0B20A0E1 		mov	r2, fp
 4658 2874 0930A0E1 		mov	r3, r9
 4659 2878 1910A0E3 		mov	r1, #25
 4660 287c E0041FE5 		ldr	r0, .L467+72
 4661 2880 FEFFFFEB 		bl	cmdSet
 4662              	.LVL560:
 4663 2884 08FEFFEA 		b	.L366
 4664              	.LVL561:
 4665              	.L376:
2738:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4666              		.loc 1 2738 0
 4667 2888 EC441FE5 		ldr	r4, .L467+72
 4668 288c 0010E0E3 		mvn	r1, #0
 4669 2890 1C0094E5 		ldr	r0, [r4, #28]
 4670 2894 14308DE5 		str	r3, [sp, #20]
 4671 2898 FEFFFFEB 		bl	_txe_mutex_get
 4672              	.LVL562:
2739:../uvc.c      **** 									 {
 4673              		.loc 1 2739 0
 4674 289c 14309DE5 		ldr	r3, [sp, #20]
 4675 28a0 033187E0 		add	r3, r7, r3, asl #2
 4676 28a4 207093E5 		ldr	r7, [r3, #32]
 4677 28a8 C1FFFFEA 		b	.L448
 4678              	.LVL563:
 4679              	.L463:
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4680              		.loc 1 1654 0
 4681 28ac 0B00A0E1 		mov	r0, fp
 4682              	.LVL564:
 4683 28b0 0910A0E1 		mov	r1, r9
 4684 28b4 14308DE5 		str	r3, [sp, #20]
 4685 28b8 FEFFFFEB 		bl	SensorGetControl
 4686              	.LVL565:
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4687              		.loc 1 1655 0
 4688 28bc 057187E0 		add	r7, r7, r5, asl #2
 4689 28c0 202017E5 		ldr	r2, [r7, #-32]
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4690              		.loc 1 1654 0
 4691 28c4 2800C4E5 		strb	r0, [r4, #40]
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4692              		.loc 1 1655 0
 4693 28c8 0D00C2E5 		strb	r0, [r2, #13]
 4694 28cc 14309DE5 		ldr	r3, [sp, #20]
 4695 28d0 00A0A0E1 		mov	r10, r0
 4696              	.LVL566:
1656:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 4697              		.loc 1 1656 0
 4698 28d4 2930C4E5 		strb	r3, [r4, #41]
 4699 28d8 0370A0E1 		mov	r7, r3
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4700              		.loc 1 1657 0
 4701 28dc 0E30C2E5 		strb	r3, [r2, #14]
 4702              	.LVL567:
 4703 28e0 6BFEFFEA 		b	.L305
 4704              	.LVL568:
 4705              	.L466:
1852:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4706              		.loc 1 1852 0
 4707 28e4 0B00A0E1 		mov	r0, fp
 4708              	.LVL569:
 4709 28e8 0910A0E1 		mov	r1, r9
 4710 28ec 14308DE5 		str	r3, [sp, #20]
 4711 28f0 FEFFFFEB 		bl	SensorGetControl
 4712              	.LVL570:
1853:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4713              		.loc 1 1853 0
 4714 28f4 057187E0 		add	r7, r7, r5, asl #2
 4715 28f8 20B197E5 		ldr	fp, [r7, #288]
 4716              	.LVL571:
1852:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4717              		.loc 1 1852 0
 4718 28fc 0010A0E1 		mov	r1, r0
 4719 2900 2800C4E5 		strb	r0, [r4, #40]
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4720              		.loc 1 1854 0
 4721 2904 0A00A0E1 		mov	r0, r10
1853:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4722              		.loc 1 1853 0
 4723 2908 0D10CBE5 		strb	r1, [fp, #13]
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4724              		.loc 1 1854 0
 4725 290c 0910A0E1 		mov	r1, r9
 4726 2910 FEFFFFEB 		bl	SensorGetControl
 4727              	.LVL572:
 4728 2914 2A00C4E5 		strb	r0, [r4, #42]
1855:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4729              		.loc 1 1855 0
 4730 2918 0E00CBE5 		strb	r0, [fp, #14]
1856:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4731              		.loc 1 1856 0
 4732 291c 14309DE5 		ldr	r3, [sp, #20]
 4733 2920 0070A0E1 		mov	r7, r0
 4734 2924 2930C4E5 		strb	r3, [r4, #41]
1857:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4735              		.loc 1 1857 0
 4736 2928 2B30C4E5 		strb	r3, [r4, #43]
 4737              	.LVL573:
 4738 292c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4739 2930 62FEFFEA 		b	.L327
 4740              	.LVL574:
 4741              	.L464:
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4742              		.loc 1 1661 0
 4743 2934 0B00A0E1 		mov	r0, fp
 4744              	.LVL575:
 4745 2938 0910A0E1 		mov	r1, r9
 4746 293c 14308DE5 		str	r3, [sp, #20]
 4747 2940 FEFFFFEB 		bl	SensorGetControl
 4748              	.LVL576:
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4749              		.loc 1 1662 0
 4750 2944 057187E0 		add	r7, r7, r5, asl #2
 4751 2948 20B017E5 		ldr	fp, [r7, #-32]
 4752              	.LVL577:
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4753              		.loc 1 1661 0
 4754 294c 0010A0E1 		mov	r1, r0
 4755 2950 2800C4E5 		strb	r0, [r4, #40]
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4756              		.loc 1 1663 0
 4757 2954 0A00A0E1 		mov	r0, r10
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4758              		.loc 1 1662 0
 4759 2958 0D10CBE5 		strb	r1, [fp, #13]
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4760              		.loc 1 1663 0
 4761 295c 0910A0E1 		mov	r1, r9
 4762 2960 FEFFFFEB 		bl	SensorGetControl
 4763              	.LVL578:
 4764 2964 2A00C4E5 		strb	r0, [r4, #42]
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4765              		.loc 1 1664 0
 4766 2968 0E00CBE5 		strb	r0, [fp, #14]
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4767              		.loc 1 1665 0
 4768 296c 14309DE5 		ldr	r3, [sp, #20]
 4769 2970 0070A0E1 		mov	r7, r0
 4770 2974 2930C4E5 		strb	r3, [r4, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4771              		.loc 1 1666 0
 4772 2978 2B30C4E5 		strb	r3, [r4, #43]
 4773              	.LVL579:
 4774 297c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4775 2980 43FEFFEA 		b	.L305
 4776              		.cfi_endproc
 4777              	.LFE3:
 4779              		.align	2
 4780              		.global	CTControlHandle
 4782              	CTControlHandle:
 4783              	.LFB4:
2961:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4784              		.loc 1 2961 0
 4785              		.cfi_startproc
 4786              		@ args = 0, pretend = 0, frame = 24
 4787              		@ frame_needed = 0, uses_anonymous_args = 0
 4788              	.LVL580:
 4789 2984 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4790              	.LCFI19:
 4791              		.cfi_def_cfa_offset 36
 4792              		.cfi_offset 4, -36
 4793              		.cfi_offset 5, -32
 4794              		.cfi_offset 6, -28
 4795              		.cfi_offset 7, -24
 4796              		.cfi_offset 8, -20
 4797              		.cfi_offset 9, -16
 4798              		.cfi_offset 10, -12
 4799              		.cfi_offset 11, -8
 4800              		.cfi_offset 14, -4
2980:../uvc.c      **** 
 4801              		.loc 1 2980 0
 4802 2988 28B89FE5 		ldr	fp, .L507
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4803              		.loc 1 2972 0
 4804 298c 28389FE5 		ldr	r3, .L507+4
2980:../uvc.c      **** 
 4805              		.loc 1 2980 0
 4806 2990 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4807              		.loc 1 2972 0
 4808 2994 8080A0E1 		mov	r8, r0, asl #1
 4809 2998 002088E0 		add	r2, r8, r0
 4810 299c 822183E0 		add	r2, r3, r2, asl #3
2982:../uvc.c      **** 		 {
 4811              		.loc 1 2982 0
 4812 29a0 830055E3 		cmp	r5, #131
2961:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4813              		.loc 1 2961 0
 4814 29a4 34D04DE2 		sub	sp, sp, #52
 4815              	.LCFI20:
 4816              		.cfi_def_cfa_offset 88
2961:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4817              		.loc 1 2961 0
 4818 29a8 0060A0E1 		mov	r6, r0
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4819              		.loc 1 2972 0
 4820 29ac BF95D2E5 		ldrb	r9, [r2, #1471]	@ zero_extendqisi2
 4821              	.LVL581:
2973:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4822              		.loc 1 2973 0
 4823 29b0 B0A5D2E5 		ldrb	r10, [r2, #1456]	@ zero_extendqisi2
 4824              	.LVL582:
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4825              		.loc 1 2975 0
 4826 29b4 B275D2E5 		ldrb	r7, [r2, #1458]	@ zero_extendqisi2
 4827              	.LVL583:
2982:../uvc.c      **** 		 {
 4828              		.loc 1 2982 0
 4829 29b8 8000000A 		beq	.L471
 4830 29bc 2600009A 		bls	.L505
 4831 29c0 850055E3 		cmp	r5, #133
 4832 29c4 7200000A 		beq	.L476
 4833 29c8 5000003A 		bcc	.L477
 4834 29cc 860055E3 		cmp	r5, #134
 4835 29d0 4300000A 		beq	.L478
 4836 29d4 870055E3 		cmp	r5, #135
 4837 29d8 5F00001A 		bne	.L470
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4838              		.loc 1 3044 0
 4839 29dc BBC5D2E5 		ldrb	ip, [r2, #1467]	@ zero_extendqisi2
 4840 29e0 D8479FE5 		ldr	r4, .L507+8
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4841              		.loc 1 3045 0
 4842 29e4 BC25D2E5 		ldrb	r2, [r2, #1468]	@ zero_extendqisi2
 4843              	.LVL584:
 4844              	.L504:
3022:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4845              		.loc 1 3022 0
 4846 29e8 0A1056E2 		subs	r1, r6, #10
 4847 29ec 006071E2 		rsbs	r6, r1, #0
 4848 29f0 0160B6E0 		adcs	r6, r6, r1
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4849              		.loc 1 3024 0
 4850 29f4 0030A0E3 		mov	r3, #0
 4851              	.LVL585:
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4852              		.loc 1 3025 0
 4853 29f8 281084E2 		add	r1, r4, #40
 4854 29fc 0700A0E1 		mov	r0, r7
 4855              	.LVL586:
3022:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4856              		.loc 1 3022 0
 4857 2a00 2A60C4E5 		strb	r6, [r4, #42]
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4858              		.loc 1 3020 0
 4859 2a04 28C0C4E5 		strb	ip, [r4, #40]
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4860              		.loc 1 3021 0
 4861 2a08 2920C4E5 		strb	r2, [r4, #41]
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4862              		.loc 1 3024 0
 4863 2a0c 2B30C4E5 		strb	r3, [r4, #43]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4864              		.loc 1 3025 0
 4865 2a10 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4866              	.LVL587:
 4867 2a14 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
3027:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4868              		.loc 1 3027 0
 4869 2a18 FF80A0E3 		mov	r8, #255
 4870 2a1c 0860A0E1 		mov	r6, r8
 4871              	.LVL588:
 4872              	.L480:
3195:../uvc.c      **** }
 4873              		.loc 1 3195 0
 4874 2a20 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4875 2a24 FFC0A0E3 		mov	ip, #255
 4876 2a28 04108DE5 		str	r1, [sp, #4]
 4877 2a2c 10108DE5 		str	r1, [sp, #16]
 4878 2a30 08008DE5 		str	r0, [sp, #8]
 4879 2a34 00808DE5 		str	r8, [sp]
 4880 2a38 14708DE5 		str	r7, [sp, #20]
 4881 2a3c 0520A0E1 		mov	r2, r5
 4882 2a40 0630A0E1 		mov	r3, r6
 4883 2a44 0CC08DE5 		str	ip, [sp, #12]
 4884 2a48 74179FE5 		ldr	r1, .L507+12
 4885 2a4c 0400A0E3 		mov	r0, #4
 4886 2a50 FEFFFFEB 		bl	CyU3PDebugPrint
 4887              	.LVL589:
3196:../uvc.c      **** 
 4888              		.loc 1 3196 0
 4889 2a54 34D08DE2 		add	sp, sp, #52
 4890              		@ sp needed
 4891 2a58 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4892              	.LVL590:
 4893              	.L505:
2982:../uvc.c      **** 		 {
 4894              		.loc 1 2982 0
 4895 2a5c 810055E3 		cmp	r5, #129
 4896 2a60 2E00000A 		beq	.L473
 4897 2a64 1A00008A 		bhi	.L474
 4898 2a68 010055E3 		cmp	r5, #1
 4899 2a6c 3A00001A 		bne	.L470
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4900              		.loc 1 3053 0
 4901 2a70 48479FE5 		ldr	r4, .L507+8
 4902 2a74 2E208DE2 		add	r2, sp, #46
 4903              	.LVL591:
 4904 2a78 2000A0E3 		mov	r0, #32
 4905              	.LVL592:
 4906 2a7c 281084E2 		add	r1, r4, #40
 4907 2a80 18308DE5 		str	r3, [sp, #24]
 4908 2a84 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4909              	.LVL593:
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4910              		.loc 1 3055 0
 4911 2a88 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
3059:../uvc.c      **** 			  {
 4912              		.loc 1 3059 0
 4913 2a8c 012046E2 		sub	r2, r6, #1
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4914              		.loc 1 3055 0
 4915 2a90 1CC08DE5 		str	ip, [sp, #28]
 4916              	.LVL594:
3056:../uvc.c      **** 			  value = Data1;
 4917              		.loc 1 3056 0
 4918 2a94 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
3059:../uvc.c      **** 			  {
 4919              		.loc 1 3059 0
 4920 2a98 18309DE5 		ldr	r3, [sp, #24]
3056:../uvc.c      **** 			  value = Data1;
 4921              		.loc 1 3056 0
 4922 2a9c 20C08DE5 		str	ip, [sp, #32]
 4923              	.LVL595:
3059:../uvc.c      **** 			  {
 4924              		.loc 1 3059 0
 4925 2aa0 090052E3 		cmp	r2, #9
 4926 2aa4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4927 2aa8 1D0100EA 		b	.L481
 4928              	.L483:
 4929 2aac DC2E0000 		.word	.L482
 4930 2ab0 242F0000 		.word	.L481
 4931 2ab4 DC2C0000 		.word	.L484
 4932 2ab8 242F0000 		.word	.L481
 4933 2abc 242F0000 		.word	.L481
 4934 2ac0 242F0000 		.word	.L481
 4935 2ac4 4C2C0000 		.word	.L485
 4936 2ac8 242F0000 		.word	.L481
 4937 2acc 242F0000 		.word	.L481
 4938 2ad0 D02B0000 		.word	.L486
 4939              	.LVL596:
 4940              	.L474:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4941              		.loc 1 3011 0
 4942 2ad4 B3C5D2E5 		ldrb	ip, [r2, #1459]	@ zero_extendqisi2
 4943 2ad8 E0469FE5 		ldr	r4, .L507+8
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4944              		.loc 1 3012 0
 4945 2adc B425D2E5 		ldrb	r2, [r2, #1460]	@ zero_extendqisi2
 4946              	.LVL597:
 4947 2ae0 C0FFFFEA 		b	.L504
 4948              	.LVL598:
 4949              	.L478:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4950              		.loc 1 3038 0
 4951 2ae4 D4469FE5 		ldr	r4, .L507+8
 4952 2ae8 B935D2E5 		ldrb	r3, [r2, #1465]	@ zero_extendqisi2
 4953 2aec 0410A0E1 		mov	r1, r4
 4954 2af0 2830E1E5 		strb	r3, [r1, #40]!
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4955              		.loc 1 3039 0
 4956 2af4 0100A0E3 		mov	r0, #1
 4957              	.LVL599:
3042:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4958              		.loc 1 3042 0
 4959 2af8 FF80A0E3 		mov	r8, #255
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4960              		.loc 1 3039 0
 4961 2afc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4962              	.LVL600:
3042:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4963              		.loc 1 3042 0
 4964 2b00 0860A0E1 		mov	r6, r8
 4965 2b04 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4966 2b08 0170A0E3 		mov	r7, #1
 4967 2b0c C3FFFFEA 		b	.L480
 4968              	.LVL601:
 4969              	.L477:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4970              		.loc 1 3029 0
 4971 2b10 B7C5D2E5 		ldrb	ip, [r2, #1463]	@ zero_extendqisi2
 4972 2b14 A4469FE5 		ldr	r4, .L507+8
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4973              		.loc 1 3030 0
 4974 2b18 B825D2E5 		ldrb	r2, [r2, #1464]	@ zero_extendqisi2
 4975              	.LVL602:
 4976 2b1c B1FFFFEA 		b	.L504
 4977              	.LVL603:
 4978              	.L473:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4979              		.loc 1 2996 0
 4980 2b20 98469FE5 		ldr	r4, .L507+8
 4981 2b24 BD95D2E5 		ldrb	r9, [r2, #1469]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4982              		.loc 1 2997 0
 4983 2b28 BEC5D2E5 		ldrb	ip, [r2, #1470]	@ zero_extendqisi2
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4984              		.loc 1 2998 0
 4985 2b2c 0030A0E3 		mov	r3, #0
3004:../uvc.c      **** 
 4986              		.loc 1 3004 0
 4987 2b30 281084E2 		add	r1, r4, #40
 4988 2b34 0700A0E1 		mov	r0, r7
 4989              	.LVL604:
3009:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4990              		.loc 1 3009 0
 4991 2b38 FF80A0E3 		mov	r8, #255
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4992              		.loc 1 2997 0
 4993 2b3c 29C0C4E5 		strb	ip, [r4, #41]
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4994              		.loc 1 2996 0
 4995 2b40 2890C4E5 		strb	r9, [r4, #40]
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4996              		.loc 1 2998 0
 4997 2b44 2A30C4E5 		strb	r3, [r4, #42]
2999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4998              		.loc 1 2999 0
 4999 2b48 2B30C4E5 		strb	r3, [r4, #43]
 5000              	.LVL605:
3009:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5001              		.loc 1 3009 0
 5002 2b4c 0860A0E1 		mov	r6, r8
 5003              	.LVL606:
3004:../uvc.c      **** 
 5004              		.loc 1 3004 0
 5005 2b50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5006              	.LVL607:
 5007 2b54 0900A0E1 		mov	r0, r9
3009:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5008              		.loc 1 3009 0
 5009 2b58 B0FFFFEA 		b	.L480
 5010              	.LVL608:
 5011              	.L470:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5012              		.loc 1 3189 0
 5013 2b5c 0000A0E3 		mov	r0, #0
 5014              	.LVL609:
 5015 2b60 0020A0E1 		mov	r2, r0
 5016              	.LVL610:
 5017 2b64 0110A0E3 		mov	r1, #1
 5018 2b68 FEFFFFEB 		bl	CyU3PUsbStall
 5019              	.LVL611:
3190:../uvc.c      **** 			  break;
 5020              		.loc 1 3190 0
 5021 2b6c 0620A0E1 		mov	r2, r6
 5022 2b70 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5023 2b74 0400A0E3 		mov	r0, #4
 5024 2b78 48169FE5 		ldr	r1, .L507+16
 5025 2b7c FEFFFFEB 		bl	CyU3PDebugPrint
 5026              	.LVL612:
3191:../uvc.c      **** 		 }
 5027              		.loc 1 3191 0
 5028 2b80 FF00A0E3 		mov	r0, #255
 5029 2b84 34469FE5 		ldr	r4, .L507+8
 5030 2b88 0080A0E1 		mov	r8, r0
 5031 2b8c 0060A0E1 		mov	r6, r0
 5032 2b90 A2FFFFEA 		b	.L480
 5033              	.LVL613:
 5034              	.L476:
2986:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5035              		.loc 1 2986 0
 5036 2b94 24469FE5 		ldr	r4, .L507+8
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5037              		.loc 1 2987 0
 5038 2b98 0030A0E3 		mov	r3, #0
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5039              		.loc 1 2988 0
 5040 2b9c 281084E2 		add	r1, r4, #40
 5041 2ba0 0200A0E3 		mov	r0, #2
 5042              	.LVL614:
2990:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5043              		.loc 1 2990 0
 5044 2ba4 FF80A0E3 		mov	r8, #255
2986:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5045              		.loc 1 2986 0
 5046 2ba8 2870C4E5 		strb	r7, [r4, #40]
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5047              		.loc 1 2987 0
 5048 2bac 2930C4E5 		strb	r3, [r4, #41]
2990:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5049              		.loc 1 2990 0
 5050 2bb0 0860A0E1 		mov	r6, r8
 5051              	.LVL615:
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5052              		.loc 1 2988 0
 5053 2bb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5054              	.LVL616:
 5055 2bb8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2990:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5056              		.loc 1 2990 0
 5057 2bbc 97FFFFEA 		b	.L480
 5058              	.LVL617:
 5059              	.L471:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5060              		.loc 1 3020 0
 5061 2bc0 B5C5D2E5 		ldrb	ip, [r2, #1461]	@ zero_extendqisi2
 5062 2bc4 F4459FE5 		ldr	r4, .L507+8
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5063              		.loc 1 3021 0
 5064 2bc8 B625D2E5 		ldrb	r2, [r2, #1462]	@ zero_extendqisi2
 5065              	.LVL618:
 5066 2bcc 85FFFFEA 		b	.L504
 5067              	.LVL619:
 5068              	.L486:
3168:../uvc.c      **** 					  if(getData == 1)
 5069              		.loc 1 3168 0
 5070 2bd0 F4659FE5 		ldr	r6, .L507+20
 5071 2bd4 0010E0E3 		mvn	r1, #0
 5072 2bd8 1C0096E5 		ldr	r0, [r6, #28]
 5073 2bdc FEFFFFEB 		bl	_txe_mutex_get
 5074              	.LVL620:
3169:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5075              		.loc 1 3169 0
 5076 2be0 1CC09DE5 		ldr	ip, [sp, #28]
 5077 2be4 01005CE3 		cmp	ip, #1
3170:../uvc.c      **** 					  else if(getData == 0xff)
 5078              		.loc 1 3170 0
 5079 2be8 0400A003 		moveq	r0, #4
3169:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5080              		.loc 1 3169 0
 5081 2bec 6901000A 		beq	.L503
3171:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5082              		.loc 1 3171 0
 5083 2bf0 FF005CE3 		cmp	ip, #255
 5084 2bf4 6601000A 		beq	.L506
3174:../uvc.c      **** 					  //dataIdx++;
 5085              		.loc 1 3174 0
 5086 2bf8 0010A0E3 		mov	r1, #0
 5087 2bfc 00108DE5 		str	r1, [sp]
 5088 2c00 04108DE5 		str	r1, [sp, #4]
 5089 2c04 0A20A0E1 		mov	r2, r10
 5090 2c08 0930A0E1 		mov	r3, r9
 5091 2c0c 0600A0E1 		mov	r0, r6
 5092 2c10 2310A0E3 		mov	r1, #35
 5093 2c14 FEFFFFEB 		bl	cmdSet
 5094              	.LVL621:
 5095              	.L498:
3177:../uvc.c      **** #endif
 5096              		.loc 1 3177 0
 5097 2c18 1C0096E5 		ldr	r0, [r6, #28]
 5098 2c1c FEFFFFEB 		bl	_txe_mutex_put
 5099              	.LVL622:
3179:../uvc.c      **** 					  break;
 5100              		.loc 1 3179 0
 5101 2c20 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5102 2c24 1C609DE5 		ldr	r6, [sp, #28]
 5103 2c28 20809DE5 		ldr	r8, [sp, #32]
 5104 2c2c 00108DE5 		str	r1, [sp]
 5105 2c30 0620A0E1 		mov	r2, r6
 5106 2c34 0830A0E1 		mov	r3, r8
 5107 2c38 0400A0E3 		mov	r0, #4
 5108 2c3c 8C159FE5 		ldr	r1, .L507+24
 5109 2c40 FEFFFFEB 		bl	CyU3PDebugPrint
 5110              	.LVL623:
3180:../uvc.c      **** 
 5111              		.loc 1 3180 0
 5112 2c44 FF00A0E3 		mov	r0, #255
 5113 2c48 74FFFFEA 		b	.L480
 5114              	.LVL624:
 5115              	.L485:
3145:../uvc.c      **** 					  {
 5116              		.loc 1 3145 0
 5117 2c4c D505D3E5 		ldrb	r0, [r3, #1493]	@ zero_extendqisi2
 5118 2c50 64C59FE5 		ldr	ip, .L507+4
 5119 2c54 010050E3 		cmp	r0, #1
 5120 2c58 08005013 		cmpne	r0, #8
 5121 2c5c 0000A013 		movne	r0, #0
 5122 2c60 0100A003 		moveq	r0, #1
 5123 2c64 4601001A 		bne	.L495
 5124              	.LVL625:
3148:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5125              		.loc 1 3148 0
 5126 2c68 5CB59FE5 		ldr	fp, .L507+20
 5127 2c6c 0010E0E3 		mvn	r1, #0
 5128 2c70 1C009BE5 		ldr	r0, [fp, #28]
 5129 2c74 18C08DE5 		str	ip, [sp, #24]
 5130 2c78 FEFFFFEB 		bl	_txe_mutex_get
 5131              	.LVL626:
3149:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5132              		.loc 1 3149 0
 5133 2c7c 1C009DE5 		ldr	r0, [sp, #28]
 5134 2c80 0010A0E3 		mov	r1, #0
 5135 2c84 0A20A0E1 		mov	r2, r10
 5136 2c88 0930A0E1 		mov	r3, r9
 5137 2c8c 00008DE5 		str	r0, [sp]
 5138 2c90 04108DE5 		str	r1, [sp, #4]
 5139 2c94 0B00A0E1 		mov	r0, fp
 5140 2c98 2210A0E3 		mov	r1, #34
 5141 2c9c FEFFFFEB 		bl	cmdSet
 5142              	.LVL627:
3150:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5143              		.loc 1 3150 0
 5144 2ca0 1C009BE5 		ldr	r0, [fp, #28]
 5145 2ca4 FEFFFFEB 		bl	_txe_mutex_put
 5146              	.LVL628:
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5147              		.loc 1 3153 0
 5148 2ca8 18C09DE5 		ldr	ip, [sp, #24]
 5149 2cac 1C109DE5 		ldr	r1, [sp, #28]
3154:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5150              		.loc 1 3154 0
 5151 2cb0 20209DE5 		ldr	r2, [sp, #32]
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5152              		.loc 1 3153 0
 5153 2cb4 066088E0 		add	r6, r8, r6
 5154 2cb8 86C18CE0 		add	ip, ip, r6, asl #3
3155:../uvc.c      **** 					  }else{
 5155              		.loc 1 3155 0
 5156 2cbc 0130A0E3 		mov	r3, #1
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5157              		.loc 1 3153 0
 5158 2cc0 BD15CCE5 		strb	r1, [ip, #1469]
3154:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5159              		.loc 1 3154 0
 5160 2cc4 BE25CCE5 		strb	r2, [ip, #1470]
3155:../uvc.c      **** 					  }else{
 5161              		.loc 1 3155 0
 5162 2cc8 C035CCE5 		strb	r3, [ip, #1472]
 5163              	.LVL629:
 5164              	.L496:
 5165 2ccc 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5166 2cd0 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
3162:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5167              		.loc 1 3162 0
 5168 2cd4 FF00A0E3 		mov	r0, #255
 5169 2cd8 50FFFFEA 		b	.L480
 5170              	.LVL630:
 5171              	.L484:
3111:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5172              		.loc 1 3111 0
 5173 2cdc D535D3E5 		ldrb	r3, [r3, #1493]	@ zero_extendqisi2
 5174 2ce0 010053E3 		cmp	r3, #1
 5175 2ce4 04005313 		cmpne	r3, #4
 5176 2ce8 2001001A 		bne	.L493
3110:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5177              		.loc 1 3110 0
 5178 2cec 1CC09DE5 		ldr	ip, [sp, #28]
 5179 2cf0 20009DE5 		ldr	r0, [sp, #32]
 5180 2cf4 00348CE1 		orr	r3, ip, r0, asl #8
3112:../uvc.c      **** 					  {
 5181              		.loc 1 3112 0
 5182 2cf8 F90053E3 		cmp	r3, #249
 5183 2cfc 1B01008A 		bhi	.L493
 5184              	.LVL631:
3117:../uvc.c      **** 							}else{
 5185              		.loc 1 3117 0
 5186 2d00 C80043E2 		sub	r0, r3, #200
 5187 2d04 C80053E3 		cmp	r3, #200
3119:../uvc.c      **** 							}
 5188              		.loc 1 3119 0
 5189 2d08 C82063E2 		rsb	r2, r3, #200
 5190 2d0c C0149FE5 		ldr	r1, .L507+28
 5191 2d10 0208A091 		movls	r0, r2, asl #16
 5192 2d14 0008A081 		movhi	r0, r0, asl #16
 5193 2d18 642063E2 		rsb	r2, r3, #100
 5194 2d1c 640053E3 		cmp	r3, #100
3117:../uvc.c      **** 							}else{
 5195              		.loc 1 3117 0
 5196 2d20 64C043E2 		sub	ip, r3, #100
 5197 2d24 2008A0E1 		mov	r0, r0, lsr #16
 5198 2d28 0C28A081 		movhi	r2, ip, asl #16
 5199 2d2c 0228A091 		movls	r2, r2, asl #16
 5200 2d30 010050E1 		cmp	r0, r1
 5201 2d34 00E0A031 		movcc	lr, r0
 5202 2d38 01E0A021 		movcs	lr, r1
 5203 2d3c 010050E1 		cmp	r0, r1
 5204 2d40 27C043E2 		sub	ip, r3, #39
3119:../uvc.c      **** 							}
 5205              		.loc 1 3119 0
 5206 2d44 271063E2 		rsb	r1, r3, #39
 5207 2d48 00B0A033 		movcc	fp, #0
 5208 2d4c 01B0A023 		movcs	fp, #1
 5209 2d50 270053E3 		cmp	r3, #39
3117:../uvc.c      **** 							}else{
 5210              		.loc 1 3117 0
 5211 2d54 140043E2 		sub	r0, r3, #20
 5212 2d58 01C8A091 		movls	ip, r1, asl #16
 5213 2d5c 2228A0E1 		mov	r2, r2, lsr #16
3119:../uvc.c      **** 							}
 5214              		.loc 1 3119 0
 5215 2d60 141063E2 		rsb	r1, r3, #20
 5216 2d64 0CC8A081 		movhi	ip, ip, asl #16
 5217 2d68 140053E3 		cmp	r3, #20
 5218 2d6c 0018A081 		movhi	r1, r0, asl #16
 5219 2d70 0118A091 		movls	r1, r1, asl #16
 5220 2d74 0E0052E1 		cmp	r2, lr
3117:../uvc.c      **** 							}else{
 5221              		.loc 1 3117 0
 5222 2d78 0A0043E2 		sub	r0, r3, #10
 5223 2d7c 01B0A033 		movcc	fp, #1
 5224 2d80 2CC8A0E1 		mov	ip, ip, lsr #16
 5225 2d84 02005EE1 		cmp	lr, r2
 5226 2d88 0E20A031 		movcc	r2, lr
 5227 2d8c 0A0053E3 		cmp	r3, #10
 5228 2d90 21E8A0E1 		mov	lr, r1, lsr #16
3119:../uvc.c      **** 							}
 5229              		.loc 1 3119 0
 5230 2d94 0A1063E2 		rsb	r1, r3, #10
 5231 2d98 0118A091 		movls	r1, r1, asl #16
 5232 2d9c 0018A081 		movhi	r1, r0, asl #16
 5233 2da0 0C0052E1 		cmp	r2, ip
 5234 2da4 02B0A083 		movhi	fp, #2
 5235 2da8 24B08DE5 		str	fp, [sp, #36]
3117:../uvc.c      **** 							}else{
 5236              		.loc 1 3117 0
 5237 2dac 050043E2 		sub	r0, r3, #5
 5238 2db0 02005CE1 		cmp	ip, r2
 5239 2db4 0C20A031 		movcc	r2, ip
 5240 2db8 21B8A0E1 		mov	fp, r1, lsr #16
3119:../uvc.c      **** 							}
 5241              		.loc 1 3119 0
 5242 2dbc 05C063E2 		rsb	ip, r3, #5
 5243 2dc0 050053E3 		cmp	r3, #5
 5244 2dc4 24109DE5 		ldr	r1, [sp, #36]
 5245 2dc8 00C8A081 		movhi	ip, r0, asl #16
 5246 2dcc 0CC8A091 		movls	ip, ip, asl #16
 5247 2dd0 0E0052E1 		cmp	r2, lr
 5248 2dd4 0310A083 		movhi	r1, #3
 5249 2dd8 24108DE5 		str	r1, [sp, #36]
 5250 2ddc 02005EE1 		cmp	lr, r2
 5251 2de0 0E00A031 		movcc	r0, lr
 5252 2de4 0200A021 		movcs	r0, r2
 5253 2de8 021063E2 		rsb	r1, r3, #2
3117:../uvc.c      **** 							}else{
 5254              		.loc 1 3117 0
 5255 2dec 022043E2 		sub	r2, r3, #2
 5256 2df0 020053E3 		cmp	r3, #2
 5257 2df4 0128A091 		movls	r2, r1, asl #16
 5258 2df8 0228A081 		movhi	r2, r2, asl #16
 5259 2dfc 0B0050E1 		cmp	r0, fp
 5260 2e00 24E09DE5 		ldr	lr, [sp, #36]
 5261 2e04 2CC8A0E1 		mov	ip, ip, lsr #16
 5262 2e08 04E0A083 		movhi	lr, #4
 5263 2e0c 00005BE1 		cmp	fp, r0
 5264 2e10 0B00A031 		movcc	r0, fp
 5265 2e14 00005CE1 		cmp	ip, r0
 5266 2e18 0C10A031 		movcc	r1, ip
 5267 2e1c 0010A021 		movcs	r1, r0
 5268 2e20 0C0050E1 		cmp	r0, ip
 5269 2e24 05E0A083 		movhi	lr, #5
 5270 2e28 01C043E2 		sub	ip, r3, #1
 5271 2e2c 010053E3 		cmp	r3, #1
3119:../uvc.c      **** 							}
 5272              		.loc 1 3119 0
 5273 2e30 010063E2 		rsb	r0, r3, #1
 5274 2e34 0C38A081 		movhi	r3, ip, asl #16
3129:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5275              		.loc 1 3129 0
 5276 2e38 8CC39FE5 		ldr	ip, .L507+20
 5277 2e3c 2228A0E1 		mov	r2, r2, lsr #16
 5278 2e40 0038A091 		movls	r3, r0, asl #16
 5279 2e44 010052E1 		cmp	r2, r1
 5280 2e48 0200A031 		movcc	r0, r2
 5281 2e4c 0100A021 		movcs	r0, r1
 5282 2e50 020051E1 		cmp	r1, r2
 5283 2e54 0E20A091 		movls	r2, lr
 5284 2e58 0620A083 		movhi	r2, #6
 5285              	.LVL632:
 5286 2e5c 0010E0E3 		mvn	r1, #0
 5287              	.LVL633:
 5288 2e60 230850E1 		cmp	r0, r3, lsr #16
 5289 2e64 1C009CE5 		ldr	r0, [ip, #28]
 5290 2e68 02B0A091 		movls	fp, r2
 5291 2e6c 07B0A083 		movhi	fp, #7
 5292              	.LVL634:
 5293 2e70 18C08DE5 		str	ip, [sp, #24]
 5294 2e74 FEFFFFEB 		bl	_txe_mutex_get
 5295              	.LVL635:
3130:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5296              		.loc 1 3130 0
 5297 2e78 18C09DE5 		ldr	ip, [sp, #24]
3126:../uvc.c      **** 
 5298              		.loc 1 3126 0
 5299 2e7c 01B08BE2 		add	fp, fp, #1
 5300              	.LVL636:
3130:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5301              		.loc 1 3130 0
 5302 2e80 0010A0E3 		mov	r1, #0
 5303 2e84 0A20A0E1 		mov	r2, r10
 5304 2e88 0930A0E1 		mov	r3, r9
 5305 2e8c 0C00A0E1 		mov	r0, ip
 5306 2e90 04108DE5 		str	r1, [sp, #4]
 5307 2e94 00B08DE5 		str	fp, [sp]
 5308 2e98 0310A0E3 		mov	r1, #3
 5309 2e9c FEFFFFEB 		bl	cmdSet
 5310              	.LVL637:
3131:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5311              		.loc 1 3131 0
 5312 2ea0 18C09DE5 		ldr	ip, [sp, #24]
 5313 2ea4 1C009CE5 		ldr	r0, [ip, #28]
 5314 2ea8 FEFFFFEB 		bl	_txe_mutex_put
 5315              	.LVL638:
3137:../uvc.c      **** 					  }else{
 5316              		.loc 1 3137 0
 5317 2eac 08C39FE5 		ldr	ip, .L507+4
3134:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5318              		.loc 1 3134 0
 5319 2eb0 04239FE5 		ldr	r2, .L507+4
3137:../uvc.c      **** 					  }else{
 5320              		.loc 1 3137 0
 5321 2eb4 79B3CCE5 		strb	fp, [ip, #889]
3134:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5322              		.loc 1 3134 0
 5323 2eb8 1CC09DE5 		ldr	ip, [sp, #28]
 5324 2ebc 063088E0 		add	r3, r8, r6
 5325 2ec0 833182E0 		add	r3, r2, r3, asl #3
 5326 2ec4 BDC5C3E5 		strb	ip, [r3, #1469]
3135:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5327              		.loc 1 3135 0
 5328 2ec8 20C09DE5 		ldr	ip, [sp, #32]
3136:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5329              		.loc 1 3136 0
 5330 2ecc 0120A0E3 		mov	r2, #1
3135:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5331              		.loc 1 3135 0
 5332 2ed0 BEC5C3E5 		strb	ip, [r3, #1470]
3136:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5333              		.loc 1 3136 0
 5334 2ed4 C025C3E5 		strb	r2, [r3, #1472]
3137:../uvc.c      **** 					  }else{
 5335              		.loc 1 3137 0
 5336 2ed8 7BFFFFEA 		b	.L496
 5337              	.LVL639:
 5338              	.L482:
3068:../uvc.c      **** 						case 1:
 5339              		.loc 1 3068 0
 5340 2edc 1CC09DE5 		ldr	ip, [sp, #28]
3064:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5341              		.loc 1 3064 0
 5342 2ee0 066088E0 		add	r6, r8, r6
 5343 2ee4 866183E0 		add	r6, r3, r6, asl #3
3065:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5344              		.loc 1 3065 0
 5345 2ee8 0110A0E3 		mov	r1, #1
3068:../uvc.c      **** 						case 1:
 5346              		.loc 1 3068 0
 5347 2eec 01204CE2 		sub	r2, ip, #1
3064:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5348              		.loc 1 3064 0
 5349 2ef0 BDC5C6E5 		strb	ip, [r6, #1469]
3065:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5350              		.loc 1 3065 0
 5351 2ef4 C015C6E5 		strb	r1, [r6, #1472]
 5352              	.LVL640:
3068:../uvc.c      **** 						case 1:
 5353              		.loc 1 3068 0
 5354 2ef8 070052E3 		cmp	r2, #7
 5355 2efc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5356 2f00 960000EA 		b	.L487
 5357              	.L489:
 5358 2f04 FC300000 		.word	.L488
 5359 2f08 60300000 		.word	.L490
 5360 2f0c 60310000 		.word	.L487
 5361 2f10 F82F0000 		.word	.L491
 5362 2f14 60310000 		.word	.L487
 5363 2f18 60310000 		.word	.L487
 5364 2f1c 60310000 		.word	.L487
 5365 2f20 582F0000 		.word	.L492
 5366              	.LVL641:
 5367              	.L481:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5368              		.loc 1 3183 0
 5369 2f24 1CC09DE5 		ldr	ip, [sp, #28]
 5370 2f28 068088E0 		add	r8, r8, r6
 5371 2f2c 888183E0 		add	r8, r3, r8, asl #3
3184:../uvc.c      **** 			  		 break;
 5372              		.loc 1 3184 0
 5373 2f30 0620A0E1 		mov	r2, r6
 5374 2f34 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5375 2f38 0400A0E3 		mov	r0, #4
 5376 2f3c 94129FE5 		ldr	r1, .L507+32
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5377              		.loc 1 3183 0
 5378 2f40 BDC5C8E5 		strb	ip, [r8, #1469]
3184:../uvc.c      **** 			  		 break;
 5379              		.loc 1 3184 0
 5380 2f44 FEFFFFEB 		bl	CyU3PDebugPrint
 5381              	.LVL642:
3185:../uvc.c      **** 			  }
 5382              		.loc 1 3185 0
 5383 2f48 FF00A0E3 		mov	r0, #255
 5384 2f4c 0080A0E1 		mov	r8, r0
 5385 2f50 0060A0E1 		mov	r6, r0
 5386 2f54 B1FEFFEA 		b	.L480
 5387              	.LVL643:
 5388              	.L492:
3087:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5389              		.loc 1 3087 0
 5390 2f58 6C629FE5 		ldr	r6, .L507+20
3085:../uvc.c      **** 			  		    	dataIdx = 0;
 5391              		.loc 1 3085 0
 5392 2f5c 0080A0E3 		mov	r8, #0
3087:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5393              		.loc 1 3087 0
 5394 2f60 1C0096E5 		ldr	r0, [r6, #28]
 5395 2f64 0010E0E3 		mvn	r1, #0
3085:../uvc.c      **** 			  		    	dataIdx = 0;
 5396              		.loc 1 3085 0
 5397 2f68 7983C3E5 		strb	r8, [r3, #889]
 5398              	.LVL644:
3087:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5399              		.loc 1 3087 0
 5400 2f6c FEFFFFEB 		bl	_txe_mutex_get
 5401              	.LVL645:
3088:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5402              		.loc 1 3088 0
 5403 2f70 0A20A0E1 		mov	r2, r10
 5404 2f74 0930A0E1 		mov	r3, r9
 5405 2f78 1010A0E3 		mov	r1, #16
 5406 2f7c 00808DE5 		str	r8, [sp]
 5407 2f80 04808DE5 		str	r8, [sp, #4]
 5408 2f84 0600A0E1 		mov	r0, r6
 5409 2f88 FEFFFFEB 		bl	cmdSet
 5410              	.LVL646:
3089:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5411              		.loc 1 3089 0
 5412 2f8c 1C0096E5 		ldr	r0, [r6, #28]
 5413 2f90 FEFFFFEB 		bl	_txe_mutex_put
 5414              	.LVL647:
 5415              	.LBB82:
 5416              	.LBB83:
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5417              		.loc 1 1257 0
 5418 2f94 1C0096E5 		ldr	r0, [r6, #28]
 5419 2f98 0010E0E3 		mvn	r1, #0
 5420 2f9c FEFFFFEB 		bl	_txe_mutex_get
 5421              	.LVL648:
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5422              		.loc 1 1258 0
 5423 2fa0 0130A0E3 		mov	r3, #1
 5424 2fa4 04808DE5 		str	r8, [sp, #4]
 5425 2fa8 0600A0E1 		mov	r0, r6
 5426 2fac 00308DE5 		str	r3, [sp]
 5427 2fb0 2010A0E3 		mov	r1, #32
 5428 2fb4 2720A0E3 		mov	r2, #39
 5429 2fb8 3030A0E3 		mov	r3, #48
 5430 2fbc FEFFFFEB 		bl	cmdSet
 5431              	.LVL649:
1259:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5432              		.loc 1 1259 0
 5433 2fc0 0230A0E3 		mov	r3, #2
 5434 2fc4 04808DE5 		str	r8, [sp, #4]
 5435 2fc8 0600A0E1 		mov	r0, r6
 5436 2fcc 00308DE5 		str	r3, [sp]
 5437 2fd0 2110A0E3 		mov	r1, #33
 5438 2fd4 2520A0E3 		mov	r2, #37
 5439 2fd8 3030A0E3 		mov	r3, #48
 5440 2fdc FEFFFFEB 		bl	cmdSet
 5441              	.LVL650:
1260:../uvc.c      **** }
 5442              		.loc 1 1260 0
 5443 2fe0 1C0096E5 		ldr	r0, [r6, #28]
 5444 2fe4 FEFFFFEB 		bl	_txe_mutex_put
 5445              	.LVL651:
 5446 2fe8 FF00A0E3 		mov	r0, #255
 5447 2fec 0080A0E1 		mov	r8, r0
 5448 2ff0 0860A0E3 		mov	r6, #8
 5449 2ff4 89FEFFEA 		b	.L480
 5450              	.LVL652:
 5451              	.L491:
 5452              	.LBE83:
 5453              	.LBE82:
 5454              	.LBB84:
 5455              	.LBB85:
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5456              		.loc 1 1257 0
 5457 2ff8 CC619FE5 		ldr	r6, .L507+20
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5458              		.loc 1 1258 0
 5459 2ffc 0080A0E3 		mov	r8, #0
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5460              		.loc 1 1257 0
 5461 3000 0010E0E3 		mvn	r1, #0
 5462 3004 1C0096E5 		ldr	r0, [r6, #28]
 5463 3008 FEFFFFEB 		bl	_txe_mutex_get
 5464              	.LVL653:
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5465              		.loc 1 1258 0
 5466 300c 0600A0E1 		mov	r0, r6
 5467 3010 00808DE5 		str	r8, [sp]
 5468 3014 04808DE5 		str	r8, [sp, #4]
 5469 3018 2010A0E3 		mov	r1, #32
 5470 301c 2720A0E3 		mov	r2, #39
 5471 3020 3030A0E3 		mov	r3, #48
 5472 3024 FEFFFFEB 		bl	cmdSet
 5473              	.LVL654:
1259:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5474              		.loc 1 1259 0
 5475 3028 0130A0E3 		mov	r3, #1
 5476 302c 04808DE5 		str	r8, [sp, #4]
 5477 3030 0600A0E1 		mov	r0, r6
 5478 3034 00308DE5 		str	r3, [sp]
 5479 3038 2110A0E3 		mov	r1, #33
 5480 303c 2520A0E3 		mov	r2, #37
 5481 3040 3030A0E3 		mov	r3, #48
 5482 3044 FEFFFFEB 		bl	cmdSet
 5483              	.LVL655:
1260:../uvc.c      **** }
 5484              		.loc 1 1260 0
 5485 3048 1C0096E5 		ldr	r0, [r6, #28]
 5486 304c FEFFFFEB 		bl	_txe_mutex_put
 5487              	.LVL656:
 5488 3050 FF00A0E3 		mov	r0, #255
 5489 3054 0080A0E1 		mov	r8, r0
 5490 3058 0460A0E3 		mov	r6, #4
 5491 305c 6FFEFFEA 		b	.L480
 5492              	.LVL657:
 5493              	.L490:
 5494              	.LBE85:
 5495              	.LBE84:
3075:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5496              		.loc 1 3075 0
 5497 3060 64619FE5 		ldr	r6, .L507+20
3073:../uvc.c      **** 							dataIdx = 0;
 5498              		.loc 1 3073 0
 5499 3064 0080A0E3 		mov	r8, #0
3075:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5500              		.loc 1 3075 0
 5501 3068 1C0096E5 		ldr	r0, [r6, #28]
 5502 306c 0010E0E3 		mvn	r1, #0
3073:../uvc.c      **** 							dataIdx = 0;
 5503              		.loc 1 3073 0
 5504 3070 7983C3E5 		strb	r8, [r3, #889]
 5505              	.LVL658:
3075:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5506              		.loc 1 3075 0
 5507 3074 FEFFFFEB 		bl	_txe_mutex_get
 5508              	.LVL659:
3076:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5509              		.loc 1 3076 0
 5510 3078 0A20A0E1 		mov	r2, r10
 5511 307c 0930A0E1 		mov	r3, r9
 5512 3080 1010A0E3 		mov	r1, #16
 5513 3084 00808DE5 		str	r8, [sp]
 5514 3088 04808DE5 		str	r8, [sp, #4]
 5515 308c 0600A0E1 		mov	r0, r6
 5516 3090 FEFFFFEB 		bl	cmdSet
 5517              	.LVL660:
3077:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5518              		.loc 1 3077 0
 5519 3094 1C0096E5 		ldr	r0, [r6, #28]
 5520 3098 FEFFFFEB 		bl	_txe_mutex_put
 5521              	.LVL661:
 5522              	.LBB86:
 5523              	.LBB87:
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5524              		.loc 1 1257 0
 5525 309c 1C0096E5 		ldr	r0, [r6, #28]
 5526 30a0 0010E0E3 		mvn	r1, #0
 5527 30a4 FEFFFFEB 		bl	_txe_mutex_get
 5528              	.LVL662:
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5529              		.loc 1 1258 0
 5530 30a8 00808DE5 		str	r8, [sp]
 5531 30ac 04808DE5 		str	r8, [sp, #4]
 5532 30b0 0600A0E1 		mov	r0, r6
 5533 30b4 2010A0E3 		mov	r1, #32
 5534 30b8 2720A0E3 		mov	r2, #39
 5535 30bc 3030A0E3 		mov	r3, #48
 5536 30c0 FEFFFFEB 		bl	cmdSet
 5537              	.LVL663:
1259:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5538              		.loc 1 1259 0
 5539 30c4 0130A0E3 		mov	r3, #1
 5540 30c8 04808DE5 		str	r8, [sp, #4]
 5541 30cc 0600A0E1 		mov	r0, r6
 5542 30d0 00308DE5 		str	r3, [sp]
 5543 30d4 2110A0E3 		mov	r1, #33
 5544 30d8 2520A0E3 		mov	r2, #37
 5545 30dc 3030A0E3 		mov	r3, #48
 5546 30e0 FEFFFFEB 		bl	cmdSet
 5547              	.LVL664:
1260:../uvc.c      **** }
 5548              		.loc 1 1260 0
 5549 30e4 1C0096E5 		ldr	r0, [r6, #28]
 5550 30e8 FEFFFFEB 		bl	_txe_mutex_put
 5551              	.LVL665:
 5552 30ec FF00A0E3 		mov	r0, #255
 5553 30f0 0080A0E1 		mov	r8, r0
 5554 30f4 0260A0E3 		mov	r6, #2
 5555 30f8 48FEFFEA 		b	.L480
 5556              	.LVL666:
 5557              	.L488:
 5558              	.LBE87:
 5559              	.LBE86:
 5560              	.LBB88:
 5561              	.LBB89:
1257:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5562              		.loc 1 1257 0
 5563 30fc C8809FE5 		ldr	r8, .L507+20
 5564 3100 0010E0E3 		mvn	r1, #0
 5565 3104 1C0098E5 		ldr	r0, [r8, #28]
 5566 3108 FEFFFFEB 		bl	_txe_mutex_get
 5567              	.LVL667:
1258:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5568              		.loc 1 1258 0
 5569 310c 0090A0E3 		mov	r9, #0
 5570              	.LVL668:
 5571 3110 0160A0E3 		mov	r6, #1
 5572 3114 0800A0E1 		mov	r0, r8
 5573 3118 2010A0E3 		mov	r1, #32
 5574 311c 2720A0E3 		mov	r2, #39
 5575 3120 3030A0E3 		mov	r3, #48
 5576 3124 40028DE8 		stmia	sp, {r6, r9}
 5577 3128 FEFFFFEB 		bl	cmdSet
 5578              	.LVL669:
1259:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5579              		.loc 1 1259 0
 5580 312c 0230A0E3 		mov	r3, #2
 5581 3130 0800A0E1 		mov	r0, r8
 5582 3134 00308DE5 		str	r3, [sp]
 5583 3138 2110A0E3 		mov	r1, #33
 5584 313c 2520A0E3 		mov	r2, #37
 5585 3140 3030A0E3 		mov	r3, #48
 5586 3144 04908DE5 		str	r9, [sp, #4]
 5587 3148 FEFFFFEB 		bl	cmdSet
 5588              	.LVL670:
1260:../uvc.c      **** }
 5589              		.loc 1 1260 0
 5590 314c 1C0098E5 		ldr	r0, [r8, #28]
 5591 3150 FEFFFFEB 		bl	_txe_mutex_put
 5592              	.LVL671:
 5593 3154 FF00A0E3 		mov	r0, #255
 5594 3158 0080A0E1 		mov	r8, r0
 5595 315c 2FFEFFEA 		b	.L480
 5596              	.LVL672:
 5597              	.L487:
 5598              	.LBE89:
 5599              	.LBE88:
3068:../uvc.c      **** 						case 1:
 5600              		.loc 1 3068 0
 5601 3160 FF00A0E3 		mov	r0, #255
 5602 3164 0C60A0E1 		mov	r6, ip
 5603 3168 0080A0E1 		mov	r8, r0
 5604 316c 2BFEFFEA 		b	.L480
 5605              	.LVL673:
 5606              	.L493:
3139:../uvc.c      **** 					  }
 5607              		.loc 1 3139 0
 5608 3170 0000A0E3 		mov	r0, #0
 5609 3174 0020A0E1 		mov	r2, r0
 5610 3178 0110A0E3 		mov	r1, #1
 5611 317c FEFFFFEB 		bl	CyU3PUsbStall
 5612              	.LVL674:
 5613 3180 D1FEFFEA 		b	.L496
 5614              	.LVL675:
 5615              	.L495:
3157:../uvc.c      **** 					  }
 5616              		.loc 1 3157 0
 5617 3184 0020A0E1 		mov	r2, r0
 5618 3188 0110A0E3 		mov	r1, #1
 5619 318c FEFFFFEB 		bl	CyU3PUsbStall
 5620              	.LVL676:
 5621 3190 CDFEFFEA 		b	.L496
 5622              	.LVL677:
 5623              	.L506:
3172:../uvc.c      **** 					  else
 5624              		.loc 1 3172 0
 5625 3194 0800A0E3 		mov	r0, #8
 5626              	.L503:
 5627 3198 0010A0E3 		mov	r1, #0
 5628 319c 03008DE8 		stmia	sp, {r0, r1}
 5629 31a0 0A20A0E1 		mov	r2, r10
 5630 31a4 0930A0E1 		mov	r3, r9
 5631 31a8 0600A0E1 		mov	r0, r6
 5632 31ac 2310A0E3 		mov	r1, #35
 5633 31b0 FEFFFFEB 		bl	cmdSet
 5634              	.LVL678:
 5635 31b4 97FEFFEA 		b	.L498
 5636              	.L508:
 5637              		.align	2
 5638              	.L507:
 5639 31b8 00000000 		.word	bRequest
 5640 31bc 00000000 		.word	.LANCHOR1
 5641 31c0 00000000 		.word	.LANCHOR0
 5642 31c4 D4060000 		.word	.LC39
 5643 31c8 B0060000 		.word	.LC38
 5644 31cc 00000000 		.word	cmdQu
 5645 31d0 64060000 		.word	.LC36
 5646 31d4 FFFF0000 		.word	65535
 5647 31d8 8C060000 		.word	.LC37
 5648              		.cfi_endproc
 5649              	.LFE4:
 5651              		.align	2
 5652              		.global	CamDefSet
 5654              	CamDefSet:
 5655              	.LFB5:
3200:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5656              		.loc 1 3200 0
 5657              		.cfi_startproc
 5658              		@ args = 0, pretend = 0, frame = 24
 5659              		@ frame_needed = 0, uses_anonymous_args = 0
 5660              	.LVL679:
 5661 31dc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5662              	.LCFI21:
 5663              		.cfi_def_cfa_offset 36
 5664              		.cfi_offset 4, -36
 5665              		.cfi_offset 5, -32
 5666              		.cfi_offset 6, -28
 5667              		.cfi_offset 7, -24
 5668              		.cfi_offset 8, -20
 5669              		.cfi_offset 9, -16
 5670              		.cfi_offset 10, -12
 5671              		.cfi_offset 11, -8
 5672              		.cfi_offset 14, -4
3207:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5673              		.loc 1 3207 0
 5674 31e0 B0429FE5 		ldr	r4, .L512
3212:../uvc.c      ****     if(Data1&0x80){
 5675              		.loc 1 3212 0
 5676 31e4 B0229FE5 		ldr	r2, .L512+4
3209:../uvc.c      ****     Data1 = Data0;
 5677              		.loc 1 3209 0
 5678 31e8 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
3200:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5679              		.loc 1 3200 0
 5680 31ec 2CD04DE2 		sub	sp, sp, #44
 5681              	.LCFI22:
 5682              		.cfi_def_cfa_offset 80
3212:../uvc.c      ****     if(Data1&0x80){
 5683              		.loc 1 3212 0
 5684 31f0 1C0092E5 		ldr	r0, [r2, #28]
 5685 31f4 0010E0E3 		mvn	r1, #0
3214:../uvc.c      ****     }else{
 5686              		.loc 1 3214 0
 5687 31f8 2563A0E1 		mov	r6, r5, lsr #6
3208:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5688              		.loc 1 3208 0
 5689 31fc 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
3207:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5690              		.loc 1 3207 0
 5691 3200 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5692              	.LVL680:
3212:../uvc.c      ****     if(Data1&0x80){
 5693              		.loc 1 3212 0
 5694 3204 FEFFFFEB 		bl	_txe_mutex_get
 5695              	.LVL681:
3213:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5696              		.loc 1 3213 0
 5697 3208 800015E3 		tst	r5, #128
3214:../uvc.c      ****     }else{
 5698              		.loc 1 3214 0
 5699 320c 01600612 		andne	r6, r6, #1
 5700 3210 0660E011 		mvnne	r6, r6
 5701 3214 3B600612 		andne	r6, r6, #59
 5702 3218 0660E011 		mvnne	r6, r6
 5703 321c FF600612 		andne	r6, r6, #255
 5704              	.LVL682:
3216:../uvc.c      ****     }
 5705              		.loc 1 3216 0
 5706 3220 C6608603 		orreq	r6, r6, #198
 5707              	.LVL683:
3220:../uvc.c      **** 
 5708              		.loc 1 3220 0
 5709 3224 0080A0E3 		mov	r8, #0
3218:../uvc.c      **** 
 5710              		.loc 1 3218 0
 5711 3228 0551A0E1 		mov	r5, r5, asl #2
 5712              	.LVL684:
 5713 322c FF5005E2 		and	r5, r5, #255
 5714              	.LVL685:
3223:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5715              		.loc 1 3223 0
 5716 3230 01A0A0E3 		mov	r10, #1
3220:../uvc.c      **** 
 5717              		.loc 1 3220 0
 5718 3234 00608DE5 		str	r6, [sp]
 5719 3238 0920A0E1 		mov	r2, r9
 5720 323c 0730A0E1 		mov	r3, r7
 5721 3240 04808DE5 		str	r8, [sp, #4]
 5722 3244 0110A0E3 		mov	r1, #1
 5723 3248 4C029FE5 		ldr	r0, .L512+4
 5724 324c FEFFFFEB 		bl	cmdSet
 5725              	.LVL686:
3223:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5726              		.loc 1 3223 0
 5727 3250 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5728 3254 0730A0E1 		mov	r3, r7
 5729 3258 0A10A0E1 		mov	r1, r10
 5730 325c 00508DE5 		str	r5, [sp]
 5731 3260 04A08DE5 		str	r10, [sp, #4]
 5732 3264 30029FE5 		ldr	r0, .L512+4
 5733 3268 FEFFFFEB 		bl	cmdSet
 5734              	.LVL687:
3226:../uvc.c      **** 
 5735              		.loc 1 3226 0
 5736 326c 0620A0E1 		mov	r2, r6
 5737 3270 0530A0E1 		mov	r3, r5
 5738 3274 24129FE5 		ldr	r1, .L512+8
 5739 3278 0400A0E3 		mov	r0, #4
3225:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5740              		.loc 1 3225 0
 5741 327c 1262C4E5 		strb	r6, [r4, #530]
3224:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5742              		.loc 1 3224 0
 5743 3280 1152C4E5 		strb	r5, [r4, #529]
3226:../uvc.c      **** 
 5744              		.loc 1 3226 0
 5745 3284 FEFFFFEB 		bl	CyU3PDebugPrint
 5746              	.LVL688:
3231:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5747              		.loc 1 3231 0
 5748 3288 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5749              	.LVL689:
3232:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5750              		.loc 1 3232 0
 5751 328c 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5752 3290 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5753 3294 40018DE8 		stmia	sp, {r6, r8}
 5754 3298 FC019FE5 		ldr	r0, .L512+4
 5755 329c 0210A0E3 		mov	r1, #2
 5756 32a0 FEFFFFEB 		bl	cmdSet
 5757              	.LVL690:
3235:../uvc.c      **** 
 5758              		.loc 1 3235 0
 5759 32a4 0620A0E1 		mov	r2, r6
 5760 32a8 0530A0E1 		mov	r3, r5
 5761 32ac EC119FE5 		ldr	r1, .L512+8
 5762 32b0 0400A0E3 		mov	r0, #4
3233:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5763              		.loc 1 3233 0
 5764 32b4 2952C4E5 		strb	r5, [r4, #553]
3234:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5765              		.loc 1 3234 0
 5766 32b8 6954C4E5 		strb	r5, [r4, #1129]
3235:../uvc.c      **** 
 5767              		.loc 1 3235 0
 5768 32bc FEFFFFEB 		bl	CyU3PDebugPrint
 5769              	.LVL691:
3240:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5770              		.loc 1 3240 0
 5771 32c0 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
3239:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5772              		.loc 1 3239 0
 5773 32c4 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5774              	.LVL692:
3241:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5775              		.loc 1 3241 0
 5776 32c8 80C047E2 		sub	ip, r7, #128
 5777 32cc FF300CE2 		and	r3, ip, #255
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5778              		.loc 1 3242 0
 5779 32d0 76E047E2 		sub	lr, r7, #118
3241:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5780              		.loc 1 3241 0
 5781 32d4 18308DE5 		str	r3, [sp, #24]
 5782 32d8 08018DE8 		stmia	sp, {r3, r8}
 5783 32dc B8019FE5 		ldr	r0, .L512+4
 5784 32e0 0630A0E1 		mov	r3, r6
 5785 32e4 0510A0E3 		mov	r1, #5
 5786 32e8 DF20A0E3 		mov	r2, #223
 5787 32ec 14C08DE5 		str	ip, [sp, #20]
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5788              		.loc 1 3242 0
 5789 32f0 1CE08DE5 		str	lr, [sp, #28]
3241:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5790              		.loc 1 3241 0
 5791 32f4 FEFFFFEB 		bl	cmdSet
 5792              	.LVL693:
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5793              		.loc 1 3242 0
 5794 32f8 1C209DE5 		ldr	r2, [sp, #28]
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5795              		.loc 1 3243 0
 5796 32fc 7EE087E2 		add	lr, r7, #126
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5797              		.loc 1 3242 0
 5798 3300 FF3002E2 		and	r3, r2, #255
 5799 3304 08048DE8 		stmia	sp, {r3, r10}
 5800 3308 8C019FE5 		ldr	r0, .L512+4
 5801 330c 0630A0E1 		mov	r3, r6
 5802 3310 0510A0E3 		mov	r1, #5
 5803 3314 DC20A0E3 		mov	r2, #220
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5804              		.loc 1 3243 0
 5805 3318 20E08DE5 		str	lr, [sp, #32]
3242:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5806              		.loc 1 3242 0
 5807 331c FEFFFFEB 		bl	cmdSet
 5808              	.LVL694:
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5809              		.loc 1 3243 0
 5810 3320 20209DE5 		ldr	r2, [sp, #32]
3244:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5811              		.loc 1 3244 0
 5812 3324 72E087E2 		add	lr, r7, #114
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5813              		.loc 1 3243 0
 5814 3328 FF3002E2 		and	r3, r2, #255
 5815 332c 0220A0E3 		mov	r2, #2
 5816 3330 00308DE5 		str	r3, [sp]
 5817 3334 04208DE5 		str	r2, [sp, #4]
 5818 3338 0630A0E1 		mov	r3, r6
 5819 333c 0510A0E3 		mov	r1, #5
 5820 3340 DE20A0E3 		mov	r2, #222
 5821 3344 50019FE5 		ldr	r0, .L512+4
3244:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5822              		.loc 1 3244 0
 5823 3348 24E08DE5 		str	lr, [sp, #36]
3243:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5824              		.loc 1 3243 0
 5825 334c FEFFFFEB 		bl	cmdSet
 5826              	.LVL695:
3244:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5827              		.loc 1 3244 0
 5828 3350 24209DE5 		ldr	r2, [sp, #36]
3245:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5829              		.loc 1 3245 0
 5830 3354 6FB047E2 		sub	fp, r7, #111
3244:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5831              		.loc 1 3244 0
 5832 3358 FF3002E2 		and	r3, r2, #255
 5833 335c 0320A0E3 		mov	r2, #3
 5834 3360 00308DE5 		str	r3, [sp]
 5835 3364 04208DE5 		str	r2, [sp, #4]
 5836 3368 0630A0E1 		mov	r3, r6
 5837 336c 0510A0E3 		mov	r1, #5
 5838 3370 E020A0E3 		mov	r2, #224
 5839 3374 20019FE5 		ldr	r0, .L512+4
 5840 3378 FEFFFFEB 		bl	cmdSet
 5841              	.LVL696:
3245:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5842              		.loc 1 3245 0
 5843 337c 0490A0E3 		mov	r9, #4
 5844 3380 FF300BE2 		and	r3, fp, #255
3246:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5845              		.loc 1 3246 0
 5846 3384 7F7087E2 		add	r7, r7, #127
 5847              	.LVL697:
3245:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5848              		.loc 1 3245 0
 5849 3388 00308DE5 		str	r3, [sp]
 5850 338c 04908DE5 		str	r9, [sp, #4]
 5851 3390 0630A0E1 		mov	r3, r6
 5852 3394 0510A0E3 		mov	r1, #5
 5853 3398 DD20A0E3 		mov	r2, #221
 5854 339c F8009FE5 		ldr	r0, .L512+4
 5855 33a0 FEFFFFEB 		bl	cmdSet
 5856              	.LVL698:
3246:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5857              		.loc 1 3246 0
 5858 33a4 FF2007E2 		and	r2, r7, #255
 5859 33a8 0510A0E3 		mov	r1, #5
 5860 33ac 0630A0E1 		mov	r3, r6
 5861 33b0 00208DE5 		str	r2, [sp]
 5862 33b4 04108DE5 		str	r1, [sp, #4]
 5863 33b8 E120A0E3 		mov	r2, #225
 5864 33bc D8009FE5 		ldr	r0, .L512+4
 5865 33c0 FEFFFFEB 		bl	cmdSet
 5866              	.LVL699:
3248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5867              		.loc 1 3248 0
 5868 33c4 14C09DE5 		ldr	ip, [sp, #20]
 5869 33c8 24E09DE5 		ldr	lr, [sp, #36]
 5870 33cc 20309DE5 		ldr	r3, [sp, #32]
 5871 33d0 0C20A0E1 		mov	r2, ip
3247:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5872              		.loc 1 3247 0
 5873 33d4 18C09DE5 		ldr	ip, [sp, #24]
3248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5874              		.loc 1 3248 0
 5875 33d8 04E08DE5 		str	lr, [sp, #4]
 5876 33dc 00308DE5 		str	r3, [sp]
 5877 33e0 0C708DE5 		str	r7, [sp, #12]
 5878 33e4 1C309DE5 		ldr	r3, [sp, #28]
 5879 33e8 08B08DE5 		str	fp, [sp, #8]
 5880 33ec 0900A0E1 		mov	r0, r9
 5881 33f0 AC109FE5 		ldr	r1, .L512+12
3247:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5882              		.loc 1 3247 0
 5883 33f4 71C2C4E5 		strb	ip, [r4, #625]
3248:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5884              		.loc 1 3248 0
 5885 33f8 FEFFFFEB 		bl	CyU3PDebugPrint
 5886              	.LVL700:
3253:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5887              		.loc 1 3253 0
 5888 33fc 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5889              	.LVL701:
3252:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5890              		.loc 1 3252 0
 5891 3400 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5892              	.LVL702:
3254:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5893              		.loc 1 3254 0
 5894 3404 00608DE5 		str	r6, [sp]
 5895 3408 0730A0E1 		mov	r3, r7
 5896 340c 04808DE5 		str	r8, [sp, #4]
 5897 3410 0610A0E3 		mov	r1, #6
 5898 3414 8520A0E3 		mov	r2, #133
 5899 3418 7C009FE5 		ldr	r0, .L512+4
 5900 341c FEFFFFEB 		bl	cmdSet
 5901              	.LVL703:
3255:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5902              		.loc 1 3255 0
 5903 3420 40048DE8 		stmia	sp, {r6, r10}
 5904 3424 70009FE5 		ldr	r0, .L512+4
 5905 3428 0730A0E1 		mov	r3, r7
 5906 342c 0610A0E3 		mov	r1, #6
 5907 3430 8620A0E3 		mov	r2, #134
 5908 3434 FEFFFFEB 		bl	cmdSet
 5909              	.LVL704:
3257:../uvc.c      **** 
 5910              		.loc 1 3257 0
 5911 3438 0620A0E1 		mov	r2, r6
 5912 343c 0530A0E1 		mov	r3, r5
 5913 3440 0900A0E1 		mov	r0, r9
 5914 3444 54109FE5 		ldr	r1, .L512+8
3256:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5915              		.loc 1 3256 0
 5916 3448 8962C4E5 		strb	r6, [r4, #649]
3257:../uvc.c      **** 
 5917              		.loc 1 3257 0
 5918 344c FEFFFFEB 		bl	CyU3PDebugPrint
 5919              	.LVL705:
3262:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5920              		.loc 1 3262 0
 5921 3450 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5922              	.LVL706:
3263:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5923              		.loc 1 3263 0
 5924 3454 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5925 3458 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5926 345c 40018DE8 		stmia	sp, {r6, r8}
 5927 3460 34009FE5 		ldr	r0, .L512+4
 5928 3464 0710A0E3 		mov	r1, #7
 5929 3468 FEFFFFEB 		bl	cmdSet
 5930              	.LVL707:
3265:../uvc.c      **** 
 5931              		.loc 1 3265 0
 5932 346c 0620A0E1 		mov	r2, r6
 5933 3470 0530A0E1 		mov	r3, r5
 5934 3474 0900A0E1 		mov	r0, r9
 5935 3478 20109FE5 		ldr	r1, .L512+8
3264:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5936              		.loc 1 3264 0
 5937 347c A152C4E5 		strb	r5, [r4, #673]
3265:../uvc.c      **** 
 5938              		.loc 1 3265 0
 5939 3480 FEFFFFEB 		bl	CyU3PDebugPrint
 5940              	.LVL708:
3267:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5941              		.loc 1 3267 0
 5942 3484 10209FE5 		ldr	r2, .L512+4
 5943 3488 1C0092E5 		ldr	r0, [r2, #28]
3270:../uvc.c      **** 
 5944              		.loc 1 3270 0
 5945 348c 2CD08DE2 		add	sp, sp, #44
 5946              		@ sp needed
 5947 3490 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5948              	.LVL709:
3267:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5949              		.loc 1 3267 0
 5950 3494 FEFFFFEA 		b	_txe_mutex_put
 5951              	.LVL710:
 5952              	.L513:
 5953              		.align	2
 5954              	.L512:
 5955 3498 00000000 		.word	.LANCHOR1
 5956 349c 00000000 		.word	statQu
 5957 34a0 38070000 		.word	.LC40
 5958 34a4 58070000 		.word	.LC41
 5959              		.cfi_endproc
 5960              	.LFE5:
 5962              		.align	2
 5963              		.global	CyFxUVCAddHeader
 5965              	CyFxUVCAddHeader:
 5966              	.LFB6:
3278:../uvc.c      ****     /* Copy header to buffer */
 5967              		.loc 1 3278 0
 5968              		.cfi_startproc
 5969              		@ args = 0, pretend = 0, frame = 0
 5970              		@ frame_needed = 0, uses_anonymous_args = 0
 5971              	.LVL711:
 5972 34a8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5973              	.LCFI23:
 5974              		.cfi_def_cfa_offset 16
 5975              		.cfi_offset 3, -16
 5976              		.cfi_offset 4, -12
 5977              		.cfi_offset 5, -8
 5978              		.cfi_offset 14, -4
3278:../uvc.c      ****     /* Copy header to buffer */
 5979              		.loc 1 3278 0
 5980 34ac 0040A0E1 		mov	r4, r0
 5981 34b0 0150A0E1 		mov	r5, r1
3280:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5982              		.loc 1 3280 0
 5983 34b4 30009FE5 		ldr	r0, .L519
 5984              	.LVL712:
 5985 34b8 0010E0E3 		mvn	r1, #0
 5986              	.LVL713:
 5987 34bc FEFFFFEB 		bl	_txe_mutex_get
 5988              	.LVL714:
3281:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5989              		.loc 1 3281 0
 5990 34c0 0400A0E1 		mov	r0, r4
 5991 34c4 24109FE5 		ldr	r1, .L519+4
 5992 34c8 0C20A0E3 		mov	r2, #12
 5993 34cc FEFFFFEB 		bl	CyU3PMemCopy
 5994              	.LVL715:
3282:../uvc.c      **** 
 5995              		.loc 1 3282 0
 5996 34d0 14009FE5 		ldr	r0, .L519
 5997 34d4 FEFFFFEB 		bl	_txe_mutex_put
 5998              	.LVL716:
3285:../uvc.c      ****     {
 5999              		.loc 1 3285 0
 6000 34d8 020015E3 		tst	r5, #2
3287:../uvc.c      ****     }
 6001              		.loc 1 3287 0
 6002 34dc 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6003 34e0 02308313 		orrne	r3, r3, #2
 6004 34e4 0130C415 		strneb	r3, [r4, #1]
 6005 34e8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6006              	.L520:
 6007              		.align	2
 6008              	.L519:
 6009 34ec 00000000 		.word	imgHdMux
 6010 34f0 EC040000 		.word	.LANCHOR1+1260
 6011              		.cfi_endproc
 6012              	.LFE6:
 6014              		.align	2
 6015              		.global	CyFxAppErrorHandler
 6017              	CyFxAppErrorHandler:
 6018              	.LFB7:
3297:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6019              		.loc 1 3297 0
 6020              		.cfi_startproc
 6021              		@ Volatile: function does not return.
 6022              		@ args = 0, pretend = 0, frame = 0
 6023              		@ frame_needed = 0, uses_anonymous_args = 0
 6024              	.LVL717:
 6025 34f4 08402DE9 		stmfd	sp!, {r3, lr}
 6026              	.LCFI24:
 6027              		.cfi_def_cfa_offset 8
 6028              		.cfi_offset 3, -8
 6029              		.cfi_offset 14, -4
 6030              	.LVL718:
 6031              	.L522:
3307:../uvc.c      ****         CyU3PThreadSleep (1000);
 6032              		.loc 1 3307 0 discriminator 1
 6033 34f8 10109FE5 		ldr	r1, .L523
 6034 34fc 0400A0E3 		mov	r0, #4
 6035 3500 FEFFFFEB 		bl	CyU3PDebugPrint
 6036              	.LVL719:
3308:../uvc.c      ****     }
 6037              		.loc 1 3308 0 discriminator 1
 6038 3504 FA0FA0E3 		mov	r0, #1000
 6039 3508 FEFFFFEB 		bl	_tx_thread_sleep
 6040              	.LVL720:
 6041 350c F9FFFFEA 		b	.L522
 6042              	.L524:
 6043              		.align	2
 6044              	.L523:
 6045 3510 90070000 		.word	.LC42
 6046              		.cfi_endproc
 6047              	.LFE7:
 6049              		.align	2
 6050              		.global	UVCAppThread_Entry
 6052              	UVCAppThread_Entry:
 6053              	.LFB19:
4284:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6054              		.loc 1 4284 0
 6055              		.cfi_startproc
 6056              		@ args = 0, pretend = 0, frame = 128
 6057              		@ frame_needed = 0, uses_anonymous_args = 0
 6058              	.LVL721:
 6059 3514 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6060              	.LCFI25:
 6061              		.cfi_def_cfa_offset 32
 6062              		.cfi_offset 4, -32
 6063              		.cfi_offset 5, -28
 6064              		.cfi_offset 6, -24
 6065              		.cfi_offset 7, -20
 6066              		.cfi_offset 8, -16
 6067              		.cfi_offset 9, -12
 6068              		.cfi_offset 10, -8
 6069              		.cfi_offset 14, -4
 6070 3518 88D04DE2 		sub	sp, sp, #136
 6071              	.LCFI26:
 6072              		.cfi_def_cfa_offset 168
 6073              	.LBB98:
 6074              	.LBB99:
3740:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6075              		.loc 1 3740 0
 6076 351c FEFFFFEB 		bl	CyU3PUartInit
 6077              	.LVL722:
3741:../uvc.c      ****     {
 6078              		.loc 1 3741 0
 6079 3520 004050E2 		subs	r4, r0, #0
 6080 3524 2902001A 		bne	.L606
3748:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6081              		.loc 1 3748 0
 6082 3528 582A9FE5 		ldr	r2, .L637
3749:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6083              		.loc 1 3749 0
 6084 352c 0130A0E3 		mov	r3, #1
3757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6085              		.loc 1 3757 0
 6086 3530 0410A0E1 		mov	r1, r4
 6087 3534 60008DE2 		add	r0, sp, #96
 6088              	.LVL723:
3750:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6089              		.loc 1 3750 0
 6090 3538 7540CDE5 		strb	r4, [sp, #117]
3752:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6091              		.loc 1 3752 0
 6092 353c 64408DE5 		str	r4, [sp, #100]
3753:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6093              		.loc 1 3753 0
 6094 3540 68408DE5 		str	r4, [sp, #104]
3748:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6095              		.loc 1 3748 0
 6096 3544 70208DE5 		str	r2, [sp, #112]
3749:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6097              		.loc 1 3749 0
 6098 3548 7430CDE5 		strb	r3, [sp, #116]
3751:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6099              		.loc 1 3751 0
 6100 354c 60308DE5 		str	r3, [sp, #96]
3754:../uvc.c      **** 
 6101              		.loc 1 3754 0
 6102 3550 6C308DE5 		str	r3, [sp, #108]
3757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6103              		.loc 1 3757 0
 6104 3554 FEFFFFEB 		bl	CyU3PUartSetConfig
 6105              	.LVL724:
3758:../uvc.c      ****     {
 6106              		.loc 1 3758 0
 6107 3558 000050E3 		cmp	r0, #0
 6108 355c B201001A 		bne	.L605
3764:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6109              		.loc 1 3764 0
 6110 3560 0000E0E3 		mvn	r0, #0
 6111              	.LVL725:
 6112 3564 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6113              	.LVL726:
3765:../uvc.c      ****     {
 6114              		.loc 1 3765 0
 6115 3568 000050E3 		cmp	r0, #0
 6116 356c AE01001A 		bne	.L605
3771:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6117              		.loc 1 3771 0
 6118 3570 0300A0E3 		mov	r0, #3
 6119              	.LVL727:
 6120 3574 0410A0E3 		mov	r1, #4
 6121 3578 FEFFFFEB 		bl	CyU3PDebugInit
 6122              	.LVL728:
3772:../uvc.c      ****     {
 6123              		.loc 1 3772 0
 6124 357c 000050E3 		cmp	r0, #0
 6125 3580 A901001A 		bne	.L605
3778:../uvc.c      **** }
 6126              		.loc 1 3778 0
 6127 3584 FEFFFFEB 		bl	CyU3PDebugPreamble
 6128              	.LVL729:
 6129 3588 0640A0E3 		mov	r4, #6
 6130              	.LVL730:
 6131              	.L531:
 6132              	.LBE99:
 6133              	.LBE98:
4300:../uvc.c      **** 	}
 6134              		.loc 1 4300 0
 6135 358c 7D0FA0E3 		mov	r0, #500
 6136 3590 014044E2 		sub	r4, r4, #1
 6137 3594 FEFFFFEB 		bl	_tx_thread_sleep
 6138              	.LVL731:
4299:../uvc.c      **** 		CyU3PThreadSleep(500);
 6139              		.loc 1 4299 0
 6140 3598 FF4014E2 		ands	r4, r4, #255
 6141 359c FAFFFF1A 		bne	.L531
 6142              	.LBB101:
 6143              	.LBB102:
3788:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6144              		.loc 1 3788 0
 6145 35a0 FEFFFFEB 		bl	CyU3PI2cInit
 6146              	.LVL732:
3789:../uvc.c      ****     {
 6147              		.loc 1 3789 0
 6148 35a4 005050E2 		subs	r5, r0, #0
 6149 35a8 3002001A 		bne	.L607
3796:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6150              		.loc 1 3796 0
 6151 35ac D8299FE5 		ldr	r2, .L637+4
3798:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6152              		.loc 1 3798 0
 6153 35b0 0030E0E3 		mvn	r3, #0
3801:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6154              		.loc 1 3801 0
 6155 35b4 60008DE2 		add	r0, sp, #96
 6156              	.LVL733:
 6157 35b8 0410A0E1 		mov	r1, r4
3797:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6158              		.loc 1 3797 0
 6159 35bc 64408DE5 		str	r4, [sp, #100]
3796:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6160              		.loc 1 3796 0
 6161 35c0 60208DE5 		str	r2, [sp, #96]
3798:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6162              		.loc 1 3798 0
 6163 35c4 68308DE5 		str	r3, [sp, #104]
3799:../uvc.c      **** 
 6164              		.loc 1 3799 0
 6165 35c8 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3801:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6166              		.loc 1 3801 0
 6167 35cc FEFFFFEB 		bl	CyU3PI2cSetConfig
 6168              	.LVL734:
3802:../uvc.c      ****     {
 6169              		.loc 1 3802 0
 6170 35d0 005050E2 		subs	r5, r0, #0
 6171 35d4 2002001A 		bne	.L608
 6172              	.LBE102:
 6173              	.LBE101:
 6174              	.LBB104:
 6175              	.LBB105:
3875:../uvc.c      ****     if (apiRetStatus != 0)
 6176              		.loc 1 3875 0
 6177 35d8 B0799FE5 		ldr	r7, .L637+8
 6178 35dc 0410A0E1 		mov	r1, r4
 6179 35e0 0700A0E1 		mov	r0, r7
 6180              	.LVL735:
 6181 35e4 2820A0E3 		mov	r2, #40
 6182 35e8 FEFFFFEB 		bl	_txe_event_flags_create
 6183              	.LVL736:
3876:../uvc.c      ****     {
 6184              		.loc 1 3876 0
 6185 35ec 005050E2 		subs	r5, r0, #0
 6186              	.LVL737:
 6187 35f0 1302001A 		bne	.L609
3890:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6188              		.loc 1 3890 0
 6189 35f4 0230A0E3 		mov	r3, #2
3893:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6190              		.loc 1 3893 0
 6191 35f8 0320A0E3 		mov	r2, #3
3897:../uvc.c      ****     if (apiRetStatus != 0)
 6192              		.loc 1 3897 0
 6193 35fc 14008DE2 		add	r0, sp, #20
 6194              	.LVL738:
 6195 3600 0410A0E1 		mov	r1, r4
3886:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6196              		.loc 1 3886 0
 6197 3604 8C4087E5 		str	r4, [r7, #140]
3887:../uvc.c      **** 
 6198              		.loc 1 3887 0
 6199 3608 904087E5 		str	r4, [r7, #144]
3892:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6200              		.loc 1 3892 0
 6201 360c 1C40CDE5 		strb	r4, [sp, #28]
3894:../uvc.c      **** 
 6202              		.loc 1 3894 0
 6203 3610 18408DE5 		str	r4, [sp, #24]
3890:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6204              		.loc 1 3890 0
 6205 3614 1430CDE5 		strb	r3, [sp, #20]
3891:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6206              		.loc 1 3891 0
 6207 3618 1530CDE5 		strb	r3, [sp, #21]
3893:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6208              		.loc 1 3893 0
 6209 361c 1D20CDE5 		strb	r2, [sp, #29]
3897:../uvc.c      ****     if (apiRetStatus != 0)
 6210              		.loc 1 3897 0
 6211 3620 FEFFFFEB 		bl	CyU3PGpioInit
 6212              	.LVL739:
3898:../uvc.c      ****     {
 6213              		.loc 1 3898 0
 6214 3624 005050E2 		subs	r5, r0, #0
 6215 3628 FF01001A 		bne	.L610
3906:../uvc.c      ****     if (apiRetStatus != 0)
 6216              		.loc 1 3906 0
 6217 362c 1600A0E3 		mov	r0, #22
 6218              	.LVL740:
 6219 3630 0110A0E3 		mov	r1, #1
 6220 3634 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6221              	.LVL741:
3907:../uvc.c      ****     {
 6222              		.loc 1 3907 0
 6223 3638 005050E2 		subs	r5, r0, #0
 6224 363c 3A02001A 		bne	.L611
3912:../uvc.c      ****     if (apiRetStatus != 0)
 6225              		.loc 1 3912 0
 6226 3640 1400A0E3 		mov	r0, #20
 6227              	.LVL742:
 6228 3644 0110A0E3 		mov	r1, #1
 6229 3648 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6230              	.LVL743:
3913:../uvc.c      ****     {
 6231              		.loc 1 3913 0
 6232 364c 005050E2 		subs	r5, r0, #0
 6233 3650 2F02001A 		bne	.L612
3918:../uvc.c      ****     if (apiRetStatus != 0)
 6234              		.loc 1 3918 0
 6235 3654 1800A0E3 		mov	r0, #24
 6236              	.LVL744:
 6237 3658 0110A0E3 		mov	r1, #1
 6238 365c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6239              	.LVL745:
3919:../uvc.c      ****     {
 6240              		.loc 1 3919 0
 6241 3660 005050E2 		subs	r5, r0, #0
 6242 3664 2402001A 		bne	.L613
3926:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6243              		.loc 1 3926 0
 6244 3668 0150A0E3 		mov	r5, #1
3931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6245              		.loc 1 3931 0
 6246 366c 30108DE2 		add	r1, sp, #48
 6247 3670 1600A0E3 		mov	r0, #22
 6248              	.LVL746:
3929:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6249              		.loc 1 3929 0
 6250 3674 3C408DE5 		str	r4, [sp, #60]
3930:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6251              		.loc 1 3930 0
 6252 3678 4040CDE5 		strb	r4, [sp, #64]
3926:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6253              		.loc 1 3926 0
 6254 367c 30508DE5 		str	r5, [sp, #48]
3927:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6255              		.loc 1 3927 0
 6256 3680 34508DE5 		str	r5, [sp, #52]
3928:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6257              		.loc 1 3928 0
 6258 3684 38508DE5 		str	r5, [sp, #56]
3931:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6259              		.loc 1 3931 0
 6260 3688 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6261              	.LVL747:
3932:../uvc.c      ****     {
 6262              		.loc 1 3932 0
 6263 368c 006050E2 		subs	r6, r0, #0
 6264 3690 1302001A 		bne	.L614
3945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6265              		.loc 1 3945 0
 6266 3694 1400A0E3 		mov	r0, #20
 6267              	.LVL748:
 6268 3698 30108DE2 		add	r1, sp, #48
3943:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6269              		.loc 1 3943 0
 6270 369c 3C408DE5 		str	r4, [sp, #60]
3944:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6271              		.loc 1 3944 0
 6272 36a0 4040CDE5 		strb	r4, [sp, #64]
3940:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6273              		.loc 1 3940 0
 6274 36a4 30508DE5 		str	r5, [sp, #48]
3941:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6275              		.loc 1 3941 0
 6276 36a8 34508DE5 		str	r5, [sp, #52]
3942:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6277              		.loc 1 3942 0
 6278 36ac 38508DE5 		str	r5, [sp, #56]
3945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6279              		.loc 1 3945 0
 6280 36b0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6281              	.LVL749:
3946:../uvc.c      ****     {
 6282              		.loc 1 3946 0
 6283 36b4 004050E2 		subs	r4, r0, #0
 6284 36b8 0302001A 		bne	.L615
3954:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6285              		.loc 1 3954 0
 6286 36bc 0030A0E3 		mov	r3, #0
3959:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6287              		.loc 1 3959 0
 6288 36c0 30108DE2 		add	r1, sp, #48
3957:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6289              		.loc 1 3957 0
 6290 36c4 0150A0E3 		mov	r5, #1
3959:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6291              		.loc 1 3959 0
 6292 36c8 1800A0E3 		mov	r0, #24
 6293              	.LVL750:
3954:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6294              		.loc 1 3954 0
 6295 36cc 30308DE5 		str	r3, [sp, #48]
3955:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6296              		.loc 1 3955 0
 6297 36d0 34308DE5 		str	r3, [sp, #52]
3956:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6298              		.loc 1 3956 0
 6299 36d4 38308DE5 		str	r3, [sp, #56]
3958:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6300              		.loc 1 3958 0
 6301 36d8 4030CDE5 		strb	r3, [sp, #64]
3957:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6302              		.loc 1 3957 0
 6303 36dc 3C508DE5 		str	r5, [sp, #60]
3959:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6304              		.loc 1 3959 0
 6305 36e0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6306              	.LVL751:
3960:../uvc.c      ****     {
 6307              		.loc 1 3960 0
 6308 36e4 004050E2 		subs	r4, r0, #0
 6309 36e8 F101001A 		bne	.L616
3967:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6310              		.loc 1 3967 0
 6311 36ec 0260A0E3 		mov	r6, #2
3968:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6312              		.loc 1 3968 0
 6313 36f0 0380A0E3 		mov	r8, #3
3972:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6314              		.loc 1 3972 0
 6315 36f4 0500A0E1 		mov	r0, r5
 6316              	.LVL752:
 6317 36f8 20108DE2 		add	r1, sp, #32
3969:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6318              		.loc 1 3969 0
 6319 36fc 28408DE5 		str	r4, [sp, #40]
3970:../uvc.c      **** 
 6320              		.loc 1 3970 0
 6321 3700 24408DE5 		str	r4, [sp, #36]
3967:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6322              		.loc 1 3967 0
 6323 3704 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3968:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6324              		.loc 1 3968 0
 6325 3708 2C80CDE5 		strb	r8, [sp, #44]
3972:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6326              		.loc 1 3972 0
 6327 370c FEFFFFEB 		bl	CyU3PPibInit
 6328              	.LVL753:
3973:../uvc.c      ****     {
 6329              		.loc 1 3973 0
 6330 3710 004050E2 		subs	r4, r0, #0
 6331 3714 E001001A 		bne	.L617
3980:../uvc.c      **** 
 6332              		.loc 1 3980 0
 6333 3718 74089FE5 		ldr	r0, .L637+12
 6334              	.LVL754:
 6335 371c FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6336              	.LVL755:
3988:../uvc.c      ****     CyU3PThreadSleep(5000);
 6337              		.loc 1 3988 0
 6338 3720 FEFFFFEB 		bl	SensorReset
 6339              	.LVL756:
3989:../uvc.c      ****     //SensorInit ();
 6340              		.loc 1 3989 0
 6341 3724 6C089FE5 		ldr	r0, .L637+16
 6342 3728 FEFFFFEB 		bl	_tx_thread_sleep
 6343              	.LVL757:
3993:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6344              		.loc 1 3993 0
 6345 372c FEFFFFEB 		bl	CyU3PUsbStart
 6346              	.LVL758:
3994:../uvc.c      ****     {
 6347              		.loc 1 3994 0
 6348 3730 004050E2 		subs	r4, r0, #0
 6349 3734 D201001A 		bne	.L618
4000:../uvc.c      **** 
 6350              		.loc 1 4000 0
 6351 3738 0410A0E1 		mov	r1, r4
 6352 373c 58089FE5 		ldr	r0, .L637+20
 6353              	.LVL759:
 6354 3740 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6355              	.LVL760:
4003:../uvc.c      **** 
 6356              		.loc 1 4003 0
 6357 3744 54089FE5 		ldr	r0, .L637+24
 6358 3748 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6359              	.LVL761:
4009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6360              		.loc 1 4009 0
 6361 374c 0410A0E1 		mov	r1, r4
 6362 3750 4C289FE5 		ldr	r2, .L637+28
 6363 3754 0500A0E1 		mov	r0, r5
 6364 3758 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6365              	.LVL762:
4010:../uvc.c      **** 
 6366              		.loc 1 4010 0
 6367 375c 0410A0E1 		mov	r1, r4
 6368 3760 0400A0E1 		mov	r0, r4
 6369 3764 3C289FE5 		ldr	r2, .L637+32
 6370 3768 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6371              	.LVL763:
4013:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6372              		.loc 1 4013 0
 6373 376c 0410A0E1 		mov	r1, r4
 6374 3770 34289FE5 		ldr	r2, .L637+36
 6375 3774 0600A0E1 		mov	r0, r6
 6376 3778 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6377              	.LVL764:
4014:../uvc.c      **** 
 6378              		.loc 1 4014 0
 6379 377c 0410A0E1 		mov	r1, r4
 6380 3780 28289FE5 		ldr	r2, .L637+40
 6381 3784 0700A0E3 		mov	r0, #7
 6382 3788 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6383              	.LVL765:
4017:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6384              		.loc 1 4017 0
 6385 378c 0410A0E1 		mov	r1, r4
 6386 3790 1C289FE5 		ldr	r2, .L637+44
 6387 3794 0400A0E3 		mov	r0, #4
 6388 3798 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6389              	.LVL766:
4018:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6390              		.loc 1 4018 0
 6391 379c 0410A0E1 		mov	r1, r4
 6392 37a0 10289FE5 		ldr	r2, .L637+48
 6393 37a4 0800A0E1 		mov	r0, r8
 6394 37a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6395              	.LVL767:
4019:../uvc.c      **** 
 6396              		.loc 1 4019 0
 6397 37ac 0410A0E1 		mov	r1, r4
 6398 37b0 04289FE5 		ldr	r2, .L637+52
 6399 37b4 0600A0E3 		mov	r0, #6
 6400 37b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6401              	.LVL768:
4022:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6402              		.loc 1 4022 0
 6403 37bc 0410A0E1 		mov	r1, r4
 6404 37c0 F8279FE5 		ldr	r2, .L637+56
 6405 37c4 0500A0E3 		mov	r0, #5
 6406 37c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6407              	.LVL769:
4023:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6408              		.loc 1 4023 0
 6409 37cc 0510A0E1 		mov	r1, r5
 6410 37d0 EC279FE5 		ldr	r2, .L637+60
 6411 37d4 0500A0E3 		mov	r0, #5
 6412 37d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6413              	.LVL770:
4024:../uvc.c      **** 
 6414              		.loc 1 4024 0
 6415 37dc 0610A0E1 		mov	r1, r6
 6416 37e0 E0279FE5 		ldr	r2, .L637+64
 6417 37e4 0500A0E3 		mov	r0, #5
 6418 37e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6419              	.LVL771:
4033:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6420              		.loc 1 4033 0
 6421 37ec 4030A0E3 		mov	r3, #64
4037:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6422              		.loc 1 4037 0
 6423 37f0 08108DE2 		add	r1, sp, #8
 6424 37f4 8200A0E3 		mov	r0, #130
4034:../uvc.c      ****     endPointConfig.streams  = 0;
 6425              		.loc 1 4034 0
 6426 37f8 1340CDE5 		strb	r4, [sp, #19]
4035:../uvc.c      ****     endPointConfig.burstLen = 1;
 6427              		.loc 1 4035 0
 6428 37fc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
4031:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6429              		.loc 1 4031 0
 6430 3800 08508DE5 		str	r5, [sp, #8]
4032:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6431              		.loc 1 4032 0
 6432 3804 0C80CDE5 		strb	r8, [sp, #12]
4036:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6433              		.loc 1 4036 0
 6434 3808 1250CDE5 		strb	r5, [sp, #18]
4033:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6435              		.loc 1 4033 0
 6436 380c B031CDE1 		strh	r3, [sp, #16]	@ movhi
4037:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6437              		.loc 1 4037 0
 6438 3810 FEFFFFEB 		bl	CyU3PSetEpConfig
 6439              	.LVL772:
4038:../uvc.c      ****     {
 6440              		.loc 1 4038 0
 6441 3814 004050E2 		subs	r4, r0, #0
4041:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6442              		.loc 1 4041 0
 6443 3818 0400A013 		movne	r0, #4
 6444              	.LVL773:
4038:../uvc.c      ****     {
 6445              		.loc 1 4038 0
 6446 381c 7101001A 		bne	.L603
4046:../uvc.c      ****     dmaInterConfig.count          = 1;
 6447              		.loc 1 4046 0
 6448 3820 A4C79FE5 		ldr	ip, .L637+68
 6449 3824 413BA0E3 		mov	r3, #66560
4055:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6450              		.loc 1 4055 0
 6451 3828 1080A0E3 		mov	r8, #16
4057:../uvc.c      ****             &dmaInterConfig);
 6452              		.loc 1 4057 0
 6453 382c 9C079FE5 		ldr	r0, .L637+72
 6454 3830 0410A0E3 		mov	r1, #4
 6455 3834 44208DE2 		add	r2, sp, #68
4046:../uvc.c      ****     dmaInterConfig.count          = 1;
 6456              		.loc 1 4046 0
 6457 3838 4C408DE5 		str	r4, [sp, #76]
 6458 383c 50408DE5 		str	r4, [sp, #80]
4054:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6459              		.loc 1 4054 0
 6460 3840 5440CDE5 		strb	r4, [sp, #84]
4056:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6461              		.loc 1 4056 0
 6462 3844 5C408DE5 		str	r4, [sp, #92]
4046:../uvc.c      ****     dmaInterConfig.count          = 1;
 6463              		.loc 1 4046 0
 6464 3848 48C08DE5 		str	ip, [sp, #72]
 6465 384c 44308DE5 		str	r3, [sp, #68]
4055:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6466              		.loc 1 4055 0
 6467 3850 58808DE5 		str	r8, [sp, #88]
4057:../uvc.c      ****             &dmaInterConfig);
 6468              		.loc 1 4057 0
 6469 3854 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6470              	.LVL774:
4059:../uvc.c      ****     {
 6471              		.loc 1 4059 0
 6472 3858 004050E2 		subs	r4, r0, #0
 6473 385c BE01001A 		bne	.L619
4066:../uvc.c      ****     if (glInterStaBuffer == 0)
 6474              		.loc 1 4066 0
 6475 3860 010BA0E3 		mov	r0, #1024
 6476              	.LVL775:
 6477 3864 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6478              	.LVL776:
 6479 3868 64379FE5 		ldr	r3, .L637+76
4067:../uvc.c      ****     {
 6480              		.loc 1 4067 0
 6481 386c 000050E3 		cmp	r0, #0
4066:../uvc.c      ****     if (glInterStaBuffer == 0)
 6482              		.loc 1 4066 0
 6483 3870 000083E5 		str	r0, [r3]
4067:../uvc.c      ****     {
 6484              		.loc 1 4067 0
 6485 3874 BE01000A 		beq	.L620
4074:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6486              		.loc 1 4074 0
 6487 3878 0410A0E1 		mov	r1, r4
 6488 387c 0420A0E1 		mov	r2, r4
 6489 3880 3830A0E3 		mov	r3, #56
 6490 3884 4C079FE5 		ldr	r0, .L637+80
 6491 3888 FEFFFFEB 		bl	_txe_mutex_create
 6492              	.LVL777:
4079:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6493              		.loc 1 4079 0
 6494 388c 48179FE5 		ldr	r1, .L637+84
4080:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6495              		.loc 1 4080 0
 6496 3890 48279FE5 		ldr	r2, .L637+88
4087:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6497              		.loc 1 4087 0
 6498 3894 48A79FE5 		ldr	r10, .L637+92
4076:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6499              		.loc 1 4076 0
 6500 3898 0480A0E3 		mov	r8, #4
4078:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6501              		.loc 1 4078 0
 6502 389c 01ECA0E3 		mov	lr, #256
4082:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6503              		.loc 1 4082 0
 6504 38a0 0CC0A0E3 		mov	ip, #12
4086:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6505              		.loc 1 4086 0
 6506 38a4 1830A0E3 		mov	r3, #24
4079:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6507              		.loc 1 4079 0
 6508 38a8 B816CDE1 		strh	r1, [sp, #104]	@ movhi
4080:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6509              		.loc 1 4080 0
 6510 38ac BE26CDE1 		strh	r2, [sp, #110]	@ movhi
4075:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6511              		.loc 1 4075 0
 6512 38b0 0199A0E3 		mov	r9, #16384
4088:../uvc.c      ****             &dmaMultiConfig);
 6513              		.loc 1 4088 0
 6514 38b4 2C079FE5 		ldr	r0, .L637+96
 6515 38b8 0710A0E3 		mov	r1, #7
 6516 38bc 60208DE2 		add	r2, sp, #96
4081:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6517              		.loc 1 4081 0
 6518 38c0 B647CDE1 		strh	r4, [sp, #118]	@ movhi
4084:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6519              		.loc 1 4084 0
 6520 38c4 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
4085:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6521              		.loc 1 4085 0
 6522 38c8 7E40CDE5 		strb	r4, [sp, #126]
4077:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6523              		.loc 1 4077 0
 6524 38cc B466CDE1 		strh	r6, [sp, #100]	@ movhi
4087:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6525              		.loc 1 4087 0
 6526 38d0 84A08DE5 		str	r10, [sp, #132]
4075:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6527              		.loc 1 4075 0
 6528 38d4 B096CDE1 		strh	r9, [sp, #96]	@ movhi
4076:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6529              		.loc 1 4076 0
 6530 38d8 B286CDE1 		strh	r8, [sp, #98]	@ movhi
4083:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6531              		.loc 1 4083 0
 6532 38dc BA87CDE1 		strh	r8, [sp, #122]	@ movhi
4078:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6533              		.loc 1 4078 0
 6534 38e0 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
4082:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6535              		.loc 1 4082 0
 6536 38e4 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
4086:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6537              		.loc 1 4086 0
 6538 38e8 80308DE5 		str	r3, [sp, #128]
4088:../uvc.c      ****             &dmaMultiConfig);
 6539              		.loc 1 4088 0
 6540 38ec FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6541              	.LVL778:
4090:../uvc.c      ****     {
 6542              		.loc 1 4090 0
 6543 38f0 004050E2 		subs	r4, r0, #0
 6544 38f4 9201001A 		bne	.L621
4181:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6545              		.loc 1 4181 0
 6546 38f8 0500A0E1 		mov	r0, r5
 6547              	.LVL779:
 6548 38fc 0510A0E1 		mov	r1, r5
 6549 3900 FEFFFFEB 		bl	CyU3PConnectState
 6550              	.LVL780:
4182:../uvc.c      ****     {
 6551              		.loc 1 4182 0
 6552 3904 004050E2 		subs	r4, r0, #0
 6553 3908 3B01001A 		bne	.L622
4188:../uvc.c      **** 
 6554              		.loc 1 4188 0
 6555 390c 6400A0E3 		mov	r0, #100
 6556              	.LVL781:
 6557 3910 FEFFFFEB 		bl	CyFx3BusyWait
 6558              	.LVL782:
4190:../uvc.c      **** 
 6559              		.loc 1 4190 0
 6560 3914 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6561              	.LVL783:
4205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6562              		.loc 1 4205 0
 6563 3918 08108DE2 		add	r1, sp, #8
4204:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6564              		.loc 1 4204 0
 6565 391c BE40CDE1 		strh	r4, [sp, #14]	@ movhi
4192:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6566              		.loc 1 4192 0
 6567 3920 08508DE5 		str	r5, [sp, #8]
4193:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6568              		.loc 1 4193 0
 6569 3924 0C60CDE5 		strb	r6, [sp, #12]
4197:../uvc.c      ****     }
 6570              		.loc 1 4197 0
 6571 3928 030050E3 		cmp	r0, #3
4190:../uvc.c      **** 
 6572              		.loc 1 4190 0
 6573 392c 0030A0E1 		mov	r3, r0
4197:../uvc.c      ****     }
 6574              		.loc 1 4197 0
 6575 3930 01C0A013 		movne	ip, #1
 6576 3934 10C0A003 		moveq	ip, #16
 6577 3938 022CA013 		movne	r2, #512
 6578 393c 012BA003 		moveq	r2, #1024
4205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6579              		.loc 1 4205 0
 6580 3940 8300A0E3 		mov	r0, #131
4190:../uvc.c      **** 
 6581              		.loc 1 4190 0
 6582 3944 4830C7E5 		strb	r3, [r7, #72]
 6583 3948 12C0CDE5 		strb	ip, [sp, #18]
 6584 394c B021CDE1 		strh	r2, [sp, #16]	@ movhi
4205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6585              		.loc 1 4205 0
 6586 3950 FEFFFFEB 		bl	CyU3PSetEpConfig
 6587              	.LVL784:
4206:../uvc.c      ****     {
 6588              		.loc 1 4206 0
 6589 3954 004050E2 		subs	r4, r0, #0
 6590              	.LBE105:
 6591              	.LBE104:
4329:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6592              		.loc 1 4329 0
 6593 3958 30469F05 		ldreq	r4, .L637+8
 6594              	.LBB110:
 6595              	.LBB106:
4206:../uvc.c      ****     {
 6596              		.loc 1 4206 0
 6597 395c 0C00000A 		beq	.L582
 6598 3960 1F0100EA 		b	.L636
 6599              	.LVL785:
 6600              	.L625:
 6601              	.LBE106:
 6602              	.LBE110:
4375:../uvc.c      ****             {
 6603              		.loc 1 4375 0
 6604 3964 7C3094E5 		ldr	r3, [r4, #124]
 6605 3968 050053E1 		cmp	r3, r5
 6606 396c 0300000A 		beq	.L552
4375:../uvc.c      ****             {
 6607              		.loc 1 4375 0 is_stmt 0 discriminator 1
 6608 3970 B028D4E1 		ldrh	r2, [r4, #128]
 6609 3974 B238D4E1 		ldrh	r3, [r4, #130]
 6610 3978 030052E1 		cmp	r2, r3
 6611 397c 3B00000A 		beq	.L624
 6612              	.L552:
4579:../uvc.c      **** 
 6613              		.loc 1 4579 0 is_stmt 1
 6614 3980 4010A0E3 		mov	r1, #64
 6615 3984 0020A0E3 		mov	r2, #0
 6616 3988 00069FE5 		ldr	r0, .L637+8
 6617 398c FEFFFFEB 		bl	_txe_event_flags_set
 6618              	.LVL786:
4582:../uvc.c      ****     }
 6619              		.loc 1 4582 0
 6620 3990 FEFFFFEB 		bl	_txe_thread_relinquish
 6621              	.LVL787:
 6622              	.L582:
4329:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6623              		.loc 1 4329 0
 6624 3994 0050A0E3 		mov	r5, #0
 6625 3998 00508DE5 		str	r5, [sp]
 6626 399c EC059FE5 		ldr	r0, .L637+8
 6627 39a0 0110A0E3 		mov	r1, #1
 6628 39a4 0220A0E3 		mov	r2, #2
 6629 39a8 60308DE2 		add	r3, sp, #96
 6630 39ac FEFFFFEB 		bl	_txe_event_flags_get
 6631              	.LVL788:
 6632 39b0 006050E2 		subs	r6, r0, #0
 6633 39b4 EAFFFF0A 		beq	.L625
4486:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6634              		.loc 1 4486 0
 6635 39b8 00508DE5 		str	r5, [sp]
 6636 39bc CC059FE5 		ldr	r0, .L637+8
 6637 39c0 0210A0E3 		mov	r1, #2
 6638 39c4 0320A0E3 		mov	r2, #3
 6639 39c8 60308DE2 		add	r3, sp, #96
 6640 39cc FEFFFFEB 		bl	_txe_event_flags_get
 6641              	.LVL789:
 6642 39d0 000050E3 		cmp	r0, #0
 6643 39d4 0B00001A 		bne	.L574
4501:../uvc.c      ****                 {
 6644              		.loc 1 4501 0
 6645 39d8 903094E5 		ldr	r3, [r4, #144]
4489:../uvc.c      ****                 prodCount = 0;
 6646              		.loc 1 4489 0
 6647 39dc 7C0084E5 		str	r0, [r4, #124]
4501:../uvc.c      ****                 {
 6648              		.loc 1 4501 0
 6649 39e0 000053E3 		cmp	r3, #0
4490:../uvc.c      ****                 consCount = 0;
 6650              		.loc 1 4490 0
 6651 39e4 B008C4E1 		strh	r0, [r4, #128]	@ movhi
4497:../uvc.c      ****                 pb=0;
 6652              		.loc 1 4497 0
 6653 39e8 B407C4E1 		strh	r0, [r4, #116]	@ movhi
4491:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6654              		.loc 1 4491 0
 6655 39ec B208C4E1 		strh	r0, [r4, #130]	@ movhi
4498:../uvc.c      ****                 pbc=0;
 6656              		.loc 1 4498 0
 6657 39f0 B607C4E1 		strh	r0, [r4, #118]	@ movhi
4499:../uvc.c      **** 
 6658              		.loc 1 4499 0
 6659 39f4 B807C4E1 		strh	r0, [r4, #120]	@ movhi
4501:../uvc.c      ****                 {
 6660              		.loc 1 4501 0
 6661 39f8 4600000A 		beq	.L626
 6662              	.L575:
4513:../uvc.c      ****             }
 6663              		.loc 1 4513 0
 6664 39fc 0030A0E3 		mov	r3, #0
 6665 3a00 903087E5 		str	r3, [r7, #144]
 6666 3a04 DDFFFFEA 		b	.L552
 6667              	.L574:
4518:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6668              		.loc 1 4518 0
 6669 3a08 0030E0E3 		mvn	r3, #0
 6670 3a0c 00308DE5 		str	r3, [sp]
 6671 3a10 0110A0E3 		mov	r1, #1
 6672 3a14 0220A0E3 		mov	r2, #2
 6673 3a18 60308DE2 		add	r3, sp, #96
 6674 3a1c 6C059FE5 		ldr	r0, .L637+8
 6675 3a20 FEFFFFEB 		bl	_txe_event_flags_get
 6676              	.LVL790:
4522:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6677              		.loc 1 4522 0
 6678 3a24 0510A0E1 		mov	r1, r5
 6679 3a28 0520A0E1 		mov	r2, r5
 6680 3a2c B4059FE5 		ldr	r0, .L637+96
 6681 3a30 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6682              	.LVL791:
4523:../uvc.c      ****                 {
 6683              		.loc 1 4523 0
 6684 3a34 005050E2 		subs	r5, r0, #0
 6685 3a38 9D00001A 		bne	.L627
4531:../uvc.c      ****                 {
 6686              		.loc 1 4531 0
 6687 3a3c 883094E5 		ldr	r3, [r4, #136]
 6688 3a40 000053E3 		cmp	r3, #0
 6689 3a44 2B00001A 		bne	.L573
 6690              	.LVL792:
 6691              	.LBB111:
 6692              	.LBB112:
4234:../uvc.c      ****     {
 6693              		.loc 1 4234 0
 6694 3a48 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6695 3a4c 030053E3 		cmp	r3, #3
 6696 3a50 5E00000A 		beq	.L628
4239:../uvc.c      ****     {
 6697              		.loc 1 4239 0
 6698 3a54 020053E3 		cmp	r3, #2
 6699 3a58 7400000A 		beq	.L629
 6700              	.LVL793:
 6701              	.L580:
 6702              	.LBE112:
 6703              	.LBE111:
4567:../uvc.c      ****                     CyU3PThreadSleep(200);
 6704              		.loc 1 4567 0
 6705 3a5c 0130A0E3 		mov	r3, #1
4568:../uvc.c      ****                     
 6706              		.loc 1 4568 0
 6707 3a60 C800A0E3 		mov	r0, #200
4567:../uvc.c      ****                     CyU3PThreadSleep(200);
 6708              		.loc 1 4567 0
 6709 3a64 883087E5 		str	r3, [r7, #136]
4568:../uvc.c      ****                     
 6710              		.loc 1 4568 0
 6711 3a68 FEFFFFEB 		bl	_tx_thread_sleep
 6712              	.LVL794:
 6713 3a6c C3FFFFEA 		b	.L552
 6714              	.L624:
4401:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6715              		.loc 1 4401 0
 6716 3a70 74559FE5 		ldr	r5, .L637+100
4400:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6717              		.loc 1 4400 0
 6718 3a74 5C059FE5 		ldr	r0, .L637+80
 6719 3a78 0010E0E3 		mvn	r1, #0
4385:../uvc.c      ****                 consCount = 0;
 6720              		.loc 1 4385 0
 6721 3a7c B068C4E1 		strh	r6, [r4, #128]	@ movhi
4382:../uvc.c      ****             	pb=0;
 6722              		.loc 1 4382 0
 6723 3a80 B467C4E1 		strh	r6, [r4, #116]	@ movhi
4386:../uvc.c      ****                 hitFV     = CyFalse;
 6724              		.loc 1 4386 0
 6725 3a84 B268C4E1 		strh	r6, [r4, #130]	@ movhi
4383:../uvc.c      ****             	pbc=0;
 6726              		.loc 1 4383 0
 6727 3a88 B667C4E1 		strh	r6, [r4, #118]	@ movhi
4384:../uvc.c      ****                 prodCount = 0;
 6728              		.loc 1 4384 0
 6729 3a8c B867C4E1 		strh	r6, [r4, #120]	@ movhi
4387:../uvc.c      **** 
 6730              		.loc 1 4387 0
 6731 3a90 7C6084E5 		str	r6, [r4, #124]
4400:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6732              		.loc 1 4400 0
 6733 3a94 FEFFFFEB 		bl	_txe_mutex_get
 6734              	.LVL795:
4401:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6735              		.loc 1 4401 0
 6736 3a98 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6737 3a9c 013023E2 		eor	r3, r3, #1
 6738 3aa0 ED34C5E5 		strb	r3, [r5, #1261]
4403:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6739              		.loc 1 4403 0
 6740 3aa4 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6741 3aa8 F00053E3 		cmp	r3, #240
 6742 3aac 3B00000A 		beq	.L630
 6743              	.L553:
4411:../uvc.c      **** 
 6744              		.loc 1 4411 0
 6745 3ab0 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6746 3ab4 FF0053E3 		cmp	r3, #255
 6747 3ab8 1D00000A 		beq	.L631
4423:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6748              		.loc 1 4423 0
 6749 3abc 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6750 3ac0 AA0053E3 		cmp	r3, #170
 6751 3ac4 2700000A 		beq	.L632
 6752              	.L554:
4461:../uvc.c      ****                 /* Reset the DMA channel. */
 6753              		.loc 1 4461 0
 6754 3ac8 08059FE5 		ldr	r0, .L637+80
 6755 3acc FEFFFFEB 		bl	_txe_mutex_put
 6756              	.LVL796:
4463:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6757              		.loc 1 4463 0
 6758 3ad0 10059FE5 		ldr	r0, .L637+96
 6759 3ad4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6760              	.LVL797:
4464:../uvc.c      ****                 {
 6761              		.loc 1 4464 0
 6762 3ad8 005050E2 		subs	r5, r0, #0
 6763 3adc 7A00001A 		bne	.L633
4471:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6764              		.loc 1 4471 0
 6765 3ae0 0510A0E1 		mov	r1, r5
 6766 3ae4 0520A0E1 		mov	r2, r5
 6767 3ae8 F8049FE5 		ldr	r0, .L637+96
 6768              	.LVL798:
 6769 3aec FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6770              	.LVL799:
4472:../uvc.c      ****                 {
 6771              		.loc 1 4472 0
 6772 3af0 005050E2 		subs	r5, r0, #0
 6773 3af4 6800001A 		bne	.L634
 6774              	.L573:
4480:../uvc.c      ****                 }
 6775              		.loc 1 4480 0
 6776 3af8 DC049FE5 		ldr	r0, .L637+84
 6777              	.LVL800:
 6778 3afc 0230A0E3 		mov	r3, #2
 6779 3b00 0010A0E3 		mov	r1, #0
 6780 3b04 00308DE5 		str	r3, [sp]
 6781 3b08 0020A0E1 		mov	r2, r0
 6782 3b0c 0130A0E1 		mov	r3, r1
 6783 3b10 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6784              	.LVL801:
 6785 3b14 99FFFFEA 		b	.L552
 6786              	.LVL802:
 6787              	.L626:
4503:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6788              		.loc 1 4503 0
 6789 3b18 C8049FE5 		ldr	r0, .L637+96
 6790 3b1c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6791              	.LVL803:
4504:../uvc.c      ****                     {
 6792              		.loc 1 4504 0
 6793 3b20 000050E3 		cmp	r0, #0
 6794 3b24 4000001A 		bne	.L605
4510:../uvc.c      ****                 }
 6795              		.loc 1 4510 0
 6796 3b28 8300A0E3 		mov	r0, #131
 6797              	.LVL804:
 6798 3b2c FEFFFFEB 		bl	CyU3PUsbFlushEp
 6799              	.LVL805:
 6800 3b30 B1FFFFEA 		b	.L575
 6801              	.L631:
4413:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6802              		.loc 1 4413 0
 6803 3b34 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6804 3b38 020053E3 		cmp	r3, #2
 6805 3b3c 013083E2 		add	r3, r3, #1
 6806 3b40 E030C4E5 		strb	r3, [r4, #224]
 6807 3b44 DFFFFF9A 		bls	.L554
4414:../uvc.c      ****                 		stiflag = 0x0F;
 6808              		.loc 1 4414 0
 6809 3b48 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
4415:../uvc.c      ****                 		IMcount = 0;
 6810              		.loc 1 4415 0
 6811 3b4c 0F30A0E3 		mov	r3, #15
4414:../uvc.c      ****                 		stiflag = 0x0F;
 6812              		.loc 1 4414 0
 6813 3b50 201081E3 		orr	r1, r1, #32
4416:../uvc.c      ****                 		}
 6814              		.loc 1 4416 0
 6815 3b54 0020A0E3 		mov	r2, #0
4414:../uvc.c      ****                 		stiflag = 0x0F;
 6816              		.loc 1 4414 0
 6817 3b58 ED14C5E5 		strb	r1, [r5, #1261]
4416:../uvc.c      ****                 		}
 6818              		.loc 1 4416 0
 6819 3b5c E020C4E5 		strb	r2, [r4, #224]
4415:../uvc.c      ****                 		IMcount = 0;
 6820              		.loc 1 4415 0
 6821 3b60 7230C4E5 		strb	r3, [r4, #114]
 6822 3b64 D7FFFFEA 		b	.L554
 6823              	.L632:
4429:../uvc.c      ****                 	{
 6824              		.loc 1 4429 0
 6825 3b68 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6826 3b6c 020053E3 		cmp	r3, #2
 6827 3b70 013083E2 		add	r3, r3, #1
 6828 3b74 E030C4E5 		strb	r3, [r4, #224]
 6829 3b78 D2FFFF9A 		bls	.L554
4431:../uvc.c      ****                      {
 6830              		.loc 1 4431 0
 6831 3b7c 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6832 3b80 013043E2 		sub	r3, r3, #1
 6833 3b84 030053E3 		cmp	r3, #3
 6834 3b88 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6835 3b8c 3E0000EA 		b	.L558
 6836              	.L560:
 6837 3b90 4C3C0000 		.word	.L559
 6838 3b94 383D0000 		.word	.L561
 6839 3b98 7C3D0000 		.word	.L562
 6840 3b9c E43C0000 		.word	.L563
 6841              	.L630:
4403:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6842              		.loc 1 4403 0 discriminator 1
 6843 3ba0 00608DE5 		str	r6, [sp]
 6844 3ba4 E4039FE5 		ldr	r0, .L637+8
 6845 3ba8 8010A0E3 		mov	r1, #128
 6846 3bac 0320A0E3 		mov	r2, #3
 6847 3bb0 60308DE2 		add	r3, sp, #96
 6848 3bb4 FEFFFFEB 		bl	_txe_event_flags_get
 6849              	.LVL806:
 6850 3bb8 000050E3 		cmp	r0, #0
 6851 3bbc BBFFFF1A 		bne	.L553
4408:../uvc.c      ****                 		IMcount = 0;
 6852              		.loc 1 4408 0
 6853 3bc0 0030E0E3 		mvn	r3, #0
4409:../uvc.c      ****                 	}
 6854              		.loc 1 4409 0
 6855 3bc4 E000C4E5 		strb	r0, [r4, #224]
4408:../uvc.c      ****                 		IMcount = 0;
 6856              		.loc 1 4408 0
 6857 3bc8 7230C4E5 		strb	r3, [r4, #114]
4409:../uvc.c      ****                 	}
 6858              		.loc 1 4409 0
 6859 3bcc BDFFFFEA 		b	.L554
 6860              	.LVL807:
 6861              	.L628:
 6862              	.LBB115:
 6863              	.LBB113:
4236:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6864              		.loc 1 4236 0
 6865 3bd0 18149FE5 		ldr	r1, .L637+104
 6866 3bd4 0100A0E3 		mov	r0, #1
 6867              	.LVL808:
 6868 3bd8 FEFFFFEB 		bl	CyU3PDebugPrint
 6869              	.LVL809:
4237:../uvc.c      ****     }
 6870              		.loc 1 4237 0
 6871 3bdc 10049FE5 		ldr	r0, .L637+108
 6872 3be0 FEFFFFEB 		bl	CyU3PGpifLoad
 6873              	.LVL810:
 6874 3be4 0050A0E1 		mov	r5, r0
 6875              	.LVL811:
 6876              	.L579:
4244:../uvc.c      ****     {
 6877              		.loc 1 4244 0
 6878 3be8 000055E3 		cmp	r5, #0
 6879 3bec 8800001A 		bne	.L635
 6880              	.LVL812:
4256:../uvc.c      ****     {
 6881              		.loc 1 4256 0
 6882 3bf0 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6883 3bf4 023043E2 		sub	r3, r3, #2
 6884 3bf8 FF3003E2 		and	r3, r3, #255
 6885 3bfc 010053E3 		cmp	r3, #1
 6886 3c00 95FFFF8A 		bhi	.L580
4254:../uvc.c      ****     }
 6887              		.loc 1 4254 0
 6888 3c04 0500A0E1 		mov	r0, r5
 6889 3c08 0510A0E1 		mov	r1, r5
 6890 3c0c FEFFFFEB 		bl	CyU3PGpifSMStart
 6891              	.LVL813:
4260:../uvc.c      ****     {
 6892              		.loc 1 4260 0
 6893 3c10 005050E2 		subs	r5, r0, #0
 6894 3c14 90FFFF0A 		beq	.L580
4263:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6895              		.loc 1 4263 0
 6896 3c18 0400A0E3 		mov	r0, #4
 6897              	.LVL814:
 6898 3c1c D4139FE5 		ldr	r1, .L637+112
 6899 3c20 0520A0E1 		mov	r2, r5
 6900 3c24 FEFFFFEB 		bl	CyU3PDebugPrint
 6901              	.LVL815:
4264:../uvc.c      ****     }
 6902              		.loc 1 4264 0
 6903 3c28 0500A0E1 		mov	r0, r5
 6904              	.LVL816:
 6905              	.L605:
4248:../uvc.c      ****     }
 6906              		.loc 1 4248 0
 6907 3c2c FEFFFFEB 		bl	CyFxAppErrorHandler
 6908              	.LVL817:
 6909              	.L629:
4241:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6910              		.loc 1 4241 0
 6911 3c30 C4139FE5 		ldr	r1, .L637+116
 6912 3c34 0100A0E3 		mov	r0, #1
 6913              	.LVL818:
 6914 3c38 FEFFFFEB 		bl	CyU3PDebugPrint
 6915              	.LVL819:
4242:../uvc.c      ****     }
 6916              		.loc 1 4242 0
 6917 3c3c BC039FE5 		ldr	r0, .L637+120
 6918 3c40 FEFFFFEB 		bl	CyU3PGpifLoad
 6919              	.LVL820:
 6920 3c44 0050A0E1 		mov	r5, r0
 6921              	.LVL821:
 6922 3c48 E6FFFFEA 		b	.L579
 6923              	.LVL822:
 6924              	.L559:
 6925              	.LBE113:
 6926              	.LBE115:
4434:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6927              		.loc 1 4434 0
 6928 3c4c 6C2097E5 		ldr	r2, [r7, #108]
 6929 3c50 3010A0E3 		mov	r1, #48
 6930 3c54 000052E3 		cmp	r2, #0
 6931 3c58 A220A003 		moveq	r2, #162
 6932 3c5c 2220A013 		movne	r2, #34
 6933 3c60 5230A0E3 		mov	r3, #82
 6934 3c64 0100A0E3 		mov	r0, #1
 6935 3c68 FEFFFFEB 		bl	SensorSetIrisControl
 6936              	.LVL823:
4436:../uvc.c      ****                  		break;
 6937              		.loc 1 4436 0
 6938 3c6c 6C2097E5 		ldr	r2, [r7, #108]
 6939 3c70 0400A0E3 		mov	r0, #4
 6940 3c74 000052E3 		cmp	r2, #0
 6941 3c78 6C3097E5 		ldr	r3, [r7, #108]
 6942 3c7c A220A003 		moveq	r2, #162
 6943 3c80 2220A013 		movne	r2, #34
 6944 3c84 78139FE5 		ldr	r1, .L637+124
 6945 3c88 FEFFFFEB 		bl	CyU3PDebugPrint
 6946              	.LVL824:
 6947              	.L558:
4456:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6948              		.loc 1 4456 0
 6949 3c8c 0030A0E3 		mov	r3, #0
 6950 3c90 E030C7E5 		strb	r3, [r7, #224]
4458:../uvc.c      ****                 	}
 6951              		.loc 1 4458 0
 6952 3c94 7230C7E5 		strb	r3, [r7, #114]
 6953 3c98 8AFFFFEA 		b	.L554
 6954              	.LVL825:
 6955              	.L634:
4474:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6956              		.loc 1 4474 0
 6957 3c9c 0400A0E3 		mov	r0, #4
 6958              	.LVL826:
 6959 3ca0 60139FE5 		ldr	r1, .L637+128
 6960 3ca4 0520A0E1 		mov	r2, r5
 6961 3ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 6962              	.LVL827:
4475:../uvc.c      ****                 }
 6963              		.loc 1 4475 0
 6964 3cac 0500A0E1 		mov	r0, r5
 6965 3cb0 FEFFFFEB 		bl	CyFxAppErrorHandler
 6966              	.LVL828:
 6967              	.L627:
4526:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6968              		.loc 1 4526 0
 6969 3cb4 0400A0E3 		mov	r0, #4
 6970              	.LVL829:
 6971 3cb8 4C139FE5 		ldr	r1, .L637+132
 6972 3cbc 0520A0E1 		mov	r2, r5
 6973 3cc0 FEFFFFEB 		bl	CyU3PDebugPrint
 6974              	.LVL830:
4527:../uvc.c      ****                 }
 6975              		.loc 1 4527 0
 6976 3cc4 0500A0E1 		mov	r0, r5
 6977 3cc8 FEFFFFEB 		bl	CyFxAppErrorHandler
 6978              	.LVL831:
 6979              	.L633:
4466:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6980              		.loc 1 4466 0
 6981 3ccc 0400A0E3 		mov	r0, #4
 6982              	.LVL832:
 6983 3cd0 38139FE5 		ldr	r1, .L637+136
 6984 3cd4 0520A0E1 		mov	r2, r5
 6985 3cd8 FEFFFFEB 		bl	CyU3PDebugPrint
 6986              	.LVL833:
4467:../uvc.c      ****                 }
 6987              		.loc 1 4467 0
 6988 3cdc 0500A0E1 		mov	r0, r5
 6989 3ce0 FEFFFFEB 		bl	CyFxAppErrorHandler
 6990              	.LVL834:
 6991              	.L563:
4449:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6992              		.loc 1 4449 0
 6993 3ce4 6C2097E5 		ldr	r2, [r7, #108]
 6994 3ce8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6995 3cec 000052E3 		cmp	r2, #0
 6996 3cf0 B020A003 		moveq	r2, #176
 6997 3cf4 3020A013 		movne	r2, #48
 6998 3cf8 032082E1 		orr	r2, r2, r3
 6999 3cfc 3010A0E3 		mov	r1, #48
 7000 3d00 5230A0E3 		mov	r3, #82
 7001 3d04 0100A0E3 		mov	r0, #1
 7002 3d08 FEFFFFEB 		bl	SensorSetIrisControl
 7003              	.LVL835:
4451:../uvc.c      ****                  		break;
 7004              		.loc 1 4451 0
 7005 3d0c 6C1097E5 		ldr	r1, [r7, #108]
 7006 3d10 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7007 3d14 000051E3 		cmp	r1, #0
 7008 3d18 B010A003 		moveq	r1, #176
 7009 3d1c 3010A013 		movne	r1, #48
 7010 3d20 022081E1 		orr	r2, r1, r2
 7011 3d24 6C3097E5 		ldr	r3, [r7, #108]
 7012 3d28 D4129FE5 		ldr	r1, .L637+124
 7013 3d2c 0400A0E3 		mov	r0, #4
 7014 3d30 FEFFFFEB 		bl	CyU3PDebugPrint
 7015              	.LVL836:
4452:../uvc.c      ****                  	default:
 7016              		.loc 1 4452 0
 7017 3d34 D4FFFFEA 		b	.L558
 7018              	.L561:
4439:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7019              		.loc 1 4439 0
 7020 3d38 6C2097E5 		ldr	r2, [r7, #108]
 7021 3d3c 3010A0E3 		mov	r1, #48
 7022 3d40 000052E3 		cmp	r2, #0
 7023 3d44 9220A003 		moveq	r2, #146
 7024 3d48 1220A013 		movne	r2, #18
 7025 3d4c 5230A0E3 		mov	r3, #82
 7026 3d50 0100A0E3 		mov	r0, #1
 7027 3d54 FEFFFFEB 		bl	SensorSetIrisControl
 7028              	.LVL837:
4441:../uvc.c      ****                  		break;
 7029              		.loc 1 4441 0
 7030 3d58 6C2097E5 		ldr	r2, [r7, #108]
 7031 3d5c A0129FE5 		ldr	r1, .L637+124
 7032 3d60 000052E3 		cmp	r2, #0
 7033 3d64 6C3097E5 		ldr	r3, [r7, #108]
 7034 3d68 9220A003 		moveq	r2, #146
 7035 3d6c 1220A013 		movne	r2, #18
 7036 3d70 0400A0E3 		mov	r0, #4
 7037 3d74 FEFFFFEB 		bl	CyU3PDebugPrint
 7038              	.LVL838:
4442:../uvc.c      ****                  	case 3: //720
 7039              		.loc 1 4442 0
 7040 3d78 C3FFFFEA 		b	.L558
 7041              	.L562:
4444:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7042              		.loc 1 4444 0
 7043 3d7c 6C2097E5 		ldr	r2, [r7, #108]
 7044 3d80 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7045 3d84 000052E3 		cmp	r2, #0
 7046 3d88 8020A003 		moveq	r2, #128
 7047 3d8c 0020A013 		movne	r2, #0
 7048 3d90 032082E1 		orr	r2, r2, r3
 7049 3d94 3010A0E3 		mov	r1, #48
 7050 3d98 5230A0E3 		mov	r3, #82
 7051 3d9c 0100A0E3 		mov	r0, #1
 7052 3da0 FEFFFFEB 		bl	SensorSetIrisControl
 7053              	.LVL839:
4446:../uvc.c      ****                  		break;
 7054              		.loc 1 4446 0
 7055 3da4 6C1097E5 		ldr	r1, [r7, #108]
 7056 3da8 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7057 3dac 000051E3 		cmp	r1, #0
 7058 3db0 8010A003 		moveq	r1, #128
 7059 3db4 0010A013 		movne	r1, #0
 7060 3db8 022081E1 		orr	r2, r1, r2
 7061 3dbc 6C3097E5 		ldr	r3, [r7, #108]
 7062 3dc0 3C129FE5 		ldr	r1, .L637+124
 7063 3dc4 0400A0E3 		mov	r0, #4
 7064 3dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 7065              	.LVL840:
4447:../uvc.c      ****                  	case 4: //VGA
 7066              		.loc 1 4447 0
 7067 3dcc AEFFFFEA 		b	.L558
 7068              	.LVL841:
 7069              	.L606:
 7070              	.LBB116:
 7071              	.LBB100:
3743:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7072              		.loc 1 3743 0
 7073 3dd0 0400A0E3 		mov	r0, #4
 7074              	.LVL842:
 7075 3dd4 38129FE5 		ldr	r1, .L637+140
 7076 3dd8 FEFFFFEB 		bl	CyU3PDebugPrint
 7077              	.LVL843:
3744:../uvc.c      ****     }
 7078              		.loc 1 3744 0
 7079 3ddc 0400A0E1 		mov	r0, r4
 7080 3de0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7081              	.LVL844:
 7082              	.L636:
 7083              	.LBE100:
 7084              	.LBE116:
 7085              	.LBB117:
 7086              	.LBB107:
4209:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7087              		.loc 1 4209 0
 7088 3de4 0800A0E1 		mov	r0, r8
 7089              	.LVL845:
 7090              	.L603:
 7091 3de8 28129FE5 		ldr	r1, .L637+144
 7092 3dec 0420A0E1 		mov	r2, r4
 7093 3df0 FEFFFFEB 		bl	CyU3PDebugPrint
 7094              	.LVL846:
4210:../uvc.c      ****     }
 7095              		.loc 1 4210 0
 7096 3df4 0400A0E1 		mov	r0, r4
 7097 3df8 8BFFFFEA 		b	.L605
 7098              	.LVL847:
 7099              	.L622:
4184:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7100              		.loc 1 4184 0
 7101 3dfc 0800A0E1 		mov	r0, r8
 7102              	.LVL848:
 7103 3e00 14129FE5 		ldr	r1, .L637+148
 7104 3e04 0420A0E1 		mov	r2, r4
 7105 3e08 FEFFFFEB 		bl	CyU3PDebugPrint
 7106              	.LVL849:
4185:../uvc.c      ****     }
 7107              		.loc 1 4185 0
 7108 3e0c 0400A0E1 		mov	r0, r4
 7109 3e10 FEFFFFEB 		bl	CyFxAppErrorHandler
 7110              	.LVL850:
 7111              	.L635:
 7112              	.LBE107:
 7113              	.LBE117:
 7114              	.LBB118:
 7115              	.LBB114:
4247:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7116              		.loc 1 4247 0
 7117 3e14 0400A0E3 		mov	r0, #4
 7118              	.LVL851:
 7119 3e18 00129FE5 		ldr	r1, .L637+152
 7120 3e1c 0520A0E1 		mov	r2, r5
 7121 3e20 FEFFFFEB 		bl	CyU3PDebugPrint
 7122              	.LVL852:
4248:../uvc.c      ****     }
 7123              		.loc 1 4248 0
 7124 3e24 0500A0E1 		mov	r0, r5
 7125 3e28 7FFFFFEA 		b	.L605
 7126              	.LVL853:
 7127              	.L610:
 7128              	.LBE114:
 7129              	.LBE118:
 7130              	.LBB119:
 7131              	.LBB108:
3900:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7132              		.loc 1 3900 0
 7133 3e2c 0400A0E3 		mov	r0, #4
 7134              	.LVL854:
 7135 3e30 EC119FE5 		ldr	r1, .L637+156
 7136 3e34 0520A0E1 		mov	r2, r5
 7137 3e38 FEFFFFEB 		bl	CyU3PDebugPrint
 7138              	.LVL855:
3901:../uvc.c      ****     }
 7139              		.loc 1 3901 0
 7140 3e3c 0500A0E1 		mov	r0, r5
 7141 3e40 FEFFFFEB 		bl	CyFxAppErrorHandler
 7142              	.LVL856:
 7143              	.L609:
3878:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7144              		.loc 1 3878 0
 7145 3e44 0400A0E3 		mov	r0, #4
 7146              	.LVL857:
 7147 3e48 D8119FE5 		ldr	r1, .L637+160
 7148 3e4c 0520A0E1 		mov	r2, r5
 7149 3e50 FEFFFFEB 		bl	CyU3PDebugPrint
 7150              	.LVL858:
3879:../uvc.c      ****     }
 7151              		.loc 1 3879 0
 7152 3e54 0500A0E1 		mov	r0, r5
 7153 3e58 FEFFFFEB 		bl	CyFxAppErrorHandler
 7154              	.LVL859:
 7155              	.L608:
 7156              	.LBE108:
 7157              	.LBE119:
 7158              	.LBB120:
 7159              	.LBB103:
3804:../uvc.c      ****         CyFxAppErrorHandler (status);
 7160              		.loc 1 3804 0
 7161 3e5c 0400A0E3 		mov	r0, #4
 7162              	.LVL860:
 7163 3e60 C4119FE5 		ldr	r1, .L637+164
 7164 3e64 FEFFFFEB 		bl	CyU3PDebugPrint
 7165              	.LVL861:
3805:../uvc.c      ****     }
 7166              		.loc 1 3805 0
 7167 3e68 0500A0E1 		mov	r0, r5
 7168 3e6c FEFFFFEB 		bl	CyFxAppErrorHandler
 7169              	.LVL862:
 7170              	.L607:
3791:../uvc.c      ****         CyFxAppErrorHandler (status);
 7171              		.loc 1 3791 0
 7172 3e70 0400A0E3 		mov	r0, #4
 7173              	.LVL863:
 7174 3e74 B4119FE5 		ldr	r1, .L637+168
 7175 3e78 FEFFFFEB 		bl	CyU3PDebugPrint
 7176              	.LVL864:
3792:../uvc.c      ****     }
 7177              		.loc 1 3792 0
 7178 3e7c 0500A0E1 		mov	r0, r5
 7179 3e80 FEFFFFEB 		bl	CyFxAppErrorHandler
 7180              	.LVL865:
 7181              	.L618:
 7182              	.LBE103:
 7183              	.LBE120:
 7184              	.LBB121:
 7185              	.LBB109:
3996:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7186              		.loc 1 3996 0
 7187 3e84 0400A0E3 		mov	r0, #4
 7188              	.LVL866:
 7189 3e88 A4119FE5 		ldr	r1, .L637+172
 7190 3e8c 0420A0E1 		mov	r2, r4
 7191 3e90 FEFFFFEB 		bl	CyU3PDebugPrint
 7192              	.LVL867:
3997:../uvc.c      ****     }
 7193              		.loc 1 3997 0
 7194 3e94 0400A0E1 		mov	r0, r4
 7195 3e98 FEFFFFEB 		bl	CyFxAppErrorHandler
 7196              	.LVL868:
 7197              	.L617:
3975:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7198              		.loc 1 3975 0
 7199 3e9c 0400A0E3 		mov	r0, #4
 7200              	.LVL869:
 7201 3ea0 90119FE5 		ldr	r1, .L637+176
 7202 3ea4 0420A0E1 		mov	r2, r4
 7203 3ea8 FEFFFFEB 		bl	CyU3PDebugPrint
 7204              	.LVL870:
3976:../uvc.c      ****     }
 7205              		.loc 1 3976 0
 7206 3eac 0400A0E1 		mov	r0, r4
 7207 3eb0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7208              	.LVL871:
 7209              	.L616:
3962:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7210              		.loc 1 3962 0
 7211 3eb4 0400A0E3 		mov	r0, #4
 7212              	.LVL872:
 7213 3eb8 7C119FE5 		ldr	r1, .L637+180
 7214 3ebc 0420A0E1 		mov	r2, r4
 7215 3ec0 FEFFFFEB 		bl	CyU3PDebugPrint
 7216              	.LVL873:
3963:../uvc.c      ****     }
 7217              		.loc 1 3963 0
 7218 3ec4 0400A0E1 		mov	r0, r4
 7219 3ec8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7220              	.LVL874:
 7221              	.L615:
3948:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7222              		.loc 1 3948 0
 7223 3ecc 0400A0E3 		mov	r0, #4
 7224              	.LVL875:
 7225 3ed0 68119FE5 		ldr	r1, .L637+184
 7226 3ed4 0420A0E1 		mov	r2, r4
 7227 3ed8 FEFFFFEB 		bl	CyU3PDebugPrint
 7228              	.LVL876:
3949:../uvc.c      ****     }
 7229              		.loc 1 3949 0
 7230 3edc 0400A0E1 		mov	r0, r4
 7231 3ee0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7232              	.LVL877:
 7233              	.L614:
3934:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7234              		.loc 1 3934 0
 7235 3ee4 0400A0E3 		mov	r0, #4
 7236              	.LVL878:
 7237 3ee8 54119FE5 		ldr	r1, .L637+188
 7238 3eec 0620A0E1 		mov	r2, r6
 7239 3ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 7240              	.LVL879:
3935:../uvc.c      ****     }
 7241              		.loc 1 3935 0
 7242 3ef4 0600A0E1 		mov	r0, r6
 7243 3ef8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7244              	.LVL880:
 7245              	.L613:
3921:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7246              		.loc 1 3921 0
 7247 3efc 0400A0E3 		mov	r0, #4
 7248              	.LVL881:
 7249 3f00 40119FE5 		ldr	r1, .L637+192
 7250 3f04 0520A0E1 		mov	r2, r5
 7251 3f08 FEFFFFEB 		bl	CyU3PDebugPrint
 7252              	.LVL882:
3922:../uvc.c      ****     }
 7253              		.loc 1 3922 0
 7254 3f0c 0500A0E1 		mov	r0, r5
 7255 3f10 FEFFFFEB 		bl	CyFxAppErrorHandler
 7256              	.LVL883:
 7257              	.L612:
3915:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7258              		.loc 1 3915 0
 7259 3f14 0400A0E3 		mov	r0, #4
 7260              	.LVL884:
 7261 3f18 2C119FE5 		ldr	r1, .L637+196
 7262 3f1c 0520A0E1 		mov	r2, r5
 7263 3f20 FEFFFFEB 		bl	CyU3PDebugPrint
 7264              	.LVL885:
3916:../uvc.c      ****     }
 7265              		.loc 1 3916 0
 7266 3f24 0500A0E1 		mov	r0, r5
 7267 3f28 FEFFFFEB 		bl	CyFxAppErrorHandler
 7268              	.LVL886:
 7269              	.L611:
3909:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7270              		.loc 1 3909 0
 7271 3f2c 0400A0E3 		mov	r0, #4
 7272              	.LVL887:
 7273 3f30 18119FE5 		ldr	r1, .L637+200
 7274 3f34 0520A0E1 		mov	r2, r5
 7275 3f38 FEFFFFEB 		bl	CyU3PDebugPrint
 7276              	.LVL888:
3910:../uvc.c      ****     }
 7277              		.loc 1 3910 0
 7278 3f3c 0500A0E1 		mov	r0, r5
 7279 3f40 FEFFFFEB 		bl	CyFxAppErrorHandler
 7280              	.LVL889:
 7281              	.L621:
4093:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7282              		.loc 1 4093 0
 7283 3f44 0800A0E1 		mov	r0, r8
 7284              	.LVL890:
 7285 3f48 04119FE5 		ldr	r1, .L637+204
 7286 3f4c 0420A0E1 		mov	r2, r4
 7287 3f50 FEFFFFEB 		bl	CyU3PDebugPrint
 7288              	.LVL891:
4094:../uvc.c      ****     }
 7289              		.loc 1 4094 0
 7290 3f54 0400A0E1 		mov	r0, r4
 7291 3f58 FEFFFFEB 		bl	CyFxAppErrorHandler
 7292              	.LVL892:
 7293              	.L619:
4062:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7294              		.loc 1 4062 0
 7295 3f5c 0400A0E3 		mov	r0, #4
 7296              	.LVL893:
 7297 3f60 F0109FE5 		ldr	r1, .L637+208
 7298 3f64 0420A0E1 		mov	r2, r4
 7299 3f68 FEFFFFEB 		bl	CyU3PDebugPrint
 7300              	.LVL894:
4063:../uvc.c      ****     }
 7301              		.loc 1 4063 0
 7302 3f6c 0400A0E1 		mov	r0, r4
 7303 3f70 FEFFFFEB 		bl	CyFxAppErrorHandler
 7304              	.LVL895:
 7305              	.L620:
4069:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7306              		.loc 1 4069 0
 7307 3f74 0400A0E3 		mov	r0, #4
 7308 3f78 DC109FE5 		ldr	r1, .L637+212
 7309 3f7c FEFFFFEB 		bl	CyU3PDebugPrint
 7310              	.LVL896:
4070:../uvc.c      ****     }
 7311              		.loc 1 4070 0
 7312 3f80 0800A0E1 		mov	r0, r8
 7313 3f84 FEFFFFEB 		bl	CyFxAppErrorHandler
 7314              	.LVL897:
 7315              	.L638:
 7316              		.align	2
 7317              	.L637:
 7318 3f88 00C20100 		.word	115200
 7319 3f8c A0860100 		.word	100000
 7320 3f90 00000000 		.word	.LANCHOR0
 7321 3f94 00000000 		.word	CyFxGpifCB
 7322 3f98 88130000 		.word	5000
 7323 3f9c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7324 3fa0 00000000 		.word	CyFxUVCApplnUSBEventCB
 7325 3fa4 00000000 		.word	CyFxUSBDeviceDscr
 7326 3fa8 00000000 		.word	CyFxUSBDeviceDscrSS
 7327 3fac 00000000 		.word	CyFxUSBDeviceQualDscr
 7328 3fb0 00000000 		.word	CyFxUSBBOSDscr
 7329 3fb4 00000000 		.word	CyFxUSBHSConfigDscr
 7330 3fb8 00000000 		.word	CyFxUSBFSConfigDscr
 7331 3fbc 00000000 		.word	CyFxUSBSSConfigDscr
 7332 3fc0 00000000 		.word	CyFxUSBStringLangIDDscr
 7333 3fc4 00000000 		.word	CyFxUSBManufactureDscr
 7334 3fc8 00000000 		.word	CyFxUSBProductDscr
 7335 3fcc 013F0203 		.word	50478849
 7336 3fd0 00000000 		.word	glChHandleInterStat
 7337 3fd4 00000000 		.word	glInterStaBuffer
 7338 3fd8 00000000 		.word	imgHdMux
 7339 3fdc 01010000 		.word	257
 7340 3fe0 03030000 		.word	771
 7341 3fe4 00000000 		.word	CyFxUvcApplnDmaCallback
 7342 3fe8 00000000 		.word	glChHandleUVCStream
 7343 3fec 00000000 		.word	.LANCHOR1
 7344 3ff0 880B0000 		.word	.LC65
 7345 3ff4 60010000 		.word	.LANCHOR2+352
 7346 3ff8 E00B0000 		.word	.LC68
 7347 3ffc 980B0000 		.word	.LC66
 7348 4000 7C010000 		.word	.LANCHOR2+380
 7349 4004 D00A0000 		.word	.LC61
 7350 4008 200B0000 		.word	.LC63
 7351 400c 540B0000 		.word	.LC64
 7352 4010 F40A0000 		.word	.LC62
 7353 4014 A4070000 		.word	.LC43
 7354 4018 CC090000 		.word	.LC56
 7355 401c A80A0000 		.word	.LC60
 7356 4020 A80B0000 		.word	.LC67
 7357 4024 28080000 		.word	.LC47
 7358 4028 FC070000 		.word	.LC46
 7359 402c E0070000 		.word	.LC45
 7360 4030 C4070000 		.word	.LC44
 7361 4034 9C090000 		.word	.LC55
 7362 4038 6C090000 		.word	.LC54
 7363 403c 34090000 		.word	.LC53
 7364 4040 00090000 		.word	.LC52
 7365 4044 CC080000 		.word	.LC51
 7366 4048 A0080000 		.word	.LC50
 7367 404c 74080000 		.word	.LC49
 7368 4050 4C080000 		.word	.LC48
 7369 4054 780A0000 		.word	.LC59
 7370 4058 000A0000 		.word	.LC57
 7371 405c 400A0000 		.word	.LC58
 7372              	.LBE109:
 7373              	.LBE121:
 7374              		.cfi_endproc
 7375              	.LFE19:
 7377              		.align	2
 7378              		.global	UVCAppEP0Thread_Entry
 7380              	UVCAppEP0Thread_Entry:
 7381              	.LFB25:
5386:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7382              		.loc 1 5386 0
 7383              		.cfi_startproc
 7384              		@ args = 0, pretend = 0, frame = 64
 7385              		@ frame_needed = 0, uses_anonymous_args = 0
 7386              	.LVL898:
 7387 4060 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7388              	.LCFI27:
 7389              		.cfi_def_cfa_offset 36
 7390              		.cfi_offset 4, -36
 7391              		.cfi_offset 5, -32
 7392              		.cfi_offset 6, -28
 7393              		.cfi_offset 7, -24
 7394              		.cfi_offset 8, -20
 7395              		.cfi_offset 9, -16
 7396              		.cfi_offset 10, -12
 7397              		.cfi_offset 11, -8
 7398              		.cfi_offset 14, -4
 7399 4064 A47F9FE5 		ldr	r7, .L1038
 7400 4068 A49F9FE5 		ldr	r9, .L1038+4
 7401 406c A48F9FE5 		ldr	r8, .L1038+8
5460:../uvc.c      ****                 {
 7402              		.loc 1 5460 0
 7403 4070 A4AF9FE5 		ldr	r10, .L1038+12
5386:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7404              		.loc 1 5386 0
 7405 4074 5CD04DE2 		sub	sp, sp, #92
 7406              	.LCFI28:
 7407              		.cfi_def_cfa_offset 128
 7408              	.LVL899:
5408:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7409              		.loc 1 5408 0
 7410 4078 07B0A0E1 		mov	fp, r7
 7411              	.LVL900:
 7412              	.L924:
 7413 407c 0030E0E3 		mvn	r3, #0
 7414 4080 00308DE5 		str	r3, [sp]
 7415 4084 840F9FE5 		ldr	r0, .L1038
 7416 4088 4C10A0E3 		mov	r1, #76
 7417 408c 0120A0E3 		mov	r2, #1
 7418 4090 44308DE2 		add	r3, sp, #68
 7419 4094 FEFFFFEB 		bl	_txe_event_flags_get
 7420              	.LVL901:
 7421 4098 000050E3 		cmp	r0, #0
 7422 409c 3C00001A 		bne	.L641
5412:../uvc.c      ****             {
 7423              		.loc 1 5412 0
 7424 40a0 8C309BE5 		ldr	r3, [fp, #140]
 7425 40a4 000053E3 		cmp	r3, #0
 7426 40a8 7700000A 		beq	.L992
 7427              	.L643:
5421:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7428              		.loc 1 5421 0
 7429 40ac 44309DE5 		ldr	r3, [sp, #68]
 7430 40b0 0C0013E3 		tst	r3, #12
 7431 40b4 5E00001A 		bne	.L993
 7432              	.L645:
5428:../uvc.c      ****             {
 7433              		.loc 1 5428 0
 7434 40b8 040013E3 		tst	r3, #4
 7435 40bc 2000000A 		beq	.L646
5430:../uvc.c      ****                 {
 7436              		.loc 1 5430 0
 7437 40c0 B020DAE1 		ldrh	r2, [r10]
 7438 40c4 2224A0E1 		mov	r2, r2, lsr #8
 7439 40c8 030052E3 		cmp	r2, #3
 7440 40cc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7441 40d0 160000EA 		b	.L647
 7442              	.L649:
 7443 40d4 30410000 		.word	.L647
 7444 40d8 E4400000 		.word	.L650
 7445 40dc 9C410000 		.word	.L651
 7446 40e0 DC410000 		.word	.L652
 7447              	.L650:
 7448              	.LBB168:
 7449              	.LBB169:
4673:../uvc.c      ****     {
 7450              		.loc 1 4673 0
 7451 40e4 844F9FE5 		ldr	r4, .L1038+96
 7452 40e8 B020D4E1 		ldrh	r2, [r4]
 7453 40ec 060C52E3 		cmp	r2, #1536
 7454 40f0 1E02000A 		beq	.L695
 7455 40f4 D000009A 		bls	.L994
 7456 40f8 090C52E3 		cmp	r2, #2304
 7457 40fc 0802000A 		beq	.L703
 7458 4100 FE00009A 		bls	.L995
 7459 4104 0B0C52E3 		cmp	r2, #2816
 7460 4108 3202000A 		beq	.L706
 7461 410c 030B52E3 		cmp	r2, #3072
 7462 4110 6402000A 		beq	.L707
 7463 4114 0A0C52E3 		cmp	r2, #2560
 7464 4118 4802000A 		beq	.L996
 7465              	.L694:
4730:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7466              		.loc 1 4730 0
 7467 411c 343F9FE5 		ldr	r3, .L1038+72
 7468 4120 0400A0E3 		mov	r0, #4
 7469 4124 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7470 4128 F01E9FE5 		ldr	r1, .L1038+16
 7471 412c FEFFFFEB 		bl	CyU3PDebugPrint
 7472              	.LVL902:
 7473              	.L647:
 7474              	.LBE169:
 7475              	.LBE168:
5451:../uvc.c      ****                         break;
 7476              		.loc 1 5451 0
 7477 4130 0000A0E3 		mov	r0, #0
 7478 4134 0020A0E1 		mov	r2, r0
 7479 4138 0110A0E3 		mov	r1, #1
 7480 413c FEFFFFEB 		bl	CyU3PUsbStall
 7481              	.LVL903:
 7482 4140 44309DE5 		ldr	r3, [sp, #68]
 7483              	.L646:
5456:../uvc.c      ****             {
 7484              		.loc 1 5456 0
 7485 4144 080013E3 		tst	r3, #8
 7486 4148 0700000A 		beq	.L918
5460:../uvc.c      ****                 {
 7487              		.loc 1 5460 0
 7488 414c B030DAE1 		ldrh	r3, [r10]
 7489 4150 010053E3 		cmp	r3, #1
 7490 4154 5200000A 		beq	.L919
5462:../uvc.c      ****                 }
 7491              		.loc 1 5462 0
 7492 4158 0000A0E3 		mov	r0, #0
 7493 415c 0020A0E1 		mov	r2, r0
 7494 4160 0110A0E3 		mov	r1, #1
 7495 4164 FEFFFFEB 		bl	CyU3PUsbStall
 7496              	.LVL904:
 7497 4168 44309DE5 		ldr	r3, [sp, #68]
 7498              	.L918:
5471:../uvc.c      ****             {
 7499              		.loc 1 5471 0
 7500 416c 400013E3 		tst	r3, #64
 7501 4170 0700000A 		beq	.L641
5476:../uvc.c      **** 
 7502              		.loc 1 5476 0
 7503 4174 1800A0E3 		mov	r0, #24
 7504 4178 48108DE2 		add	r1, sp, #72
 7505              	.LVL905:
 7506 417c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7507              	.LVL906:
5533:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7508              		.loc 1 5533 0
 7509 4180 6A37D9E5 		ldrb	r3, [r9, #1898]	@ zero_extendqisi2
 7510 4184 0F0053E3 		cmp	r3, #15
 7511 4188 6800000A 		beq	.L997
5560:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7512              		.loc 1 5560 0
 7513 418c 000053E3 		cmp	r3, #0
 7514 4190 4600000A 		beq	.L998
 7515              	.L641:
5684:../uvc.c      ****     }
 7516              		.loc 1 5684 0
 7517 4194 FEFFFFEB 		bl	_txe_thread_relinquish
 7518              	.LVL907:
5685:../uvc.c      **** }
 7519              		.loc 1 5685 0
 7520 4198 B7FFFFEA 		b	.L924
 7521              	.L651:
 7522              	.LBB344:
 7523              	.LBB345:
4598:../uvc.c      ****     {
 7524              		.loc 1 4598 0
 7525 419c CCCE9FE5 		ldr	ip, .L1038+96
 7526 41a0 B020DCE1 		ldrh	r2, [ip]
 7527 41a4 060C52E3 		cmp	r2, #1536
 7528 41a8 3601000A 		beq	.L654
 7529 41ac 9500008A 		bhi	.L655
 7530 41b0 030C52E3 		cmp	r2, #768
 7531 41b4 2F01000A 		beq	.L656
 7532 41b8 C000008A 		bhi	.L657
 7533 41bc 010C52E3 		cmp	r2, #256
 7534 41c0 1C01000A 		beq	.L658
 7535 41c4 020C52E3 		cmp	r2, #512
 7536 41c8 D3FFFF1A 		bne	.L694
 7537              	.LVL908:
4606:../uvc.c      ****     		break;
 7538              		.loc 1 4606 0
 7539 41cc 0100A0E3 		mov	r0, #1
 7540 41d0 FEFFFFEB 		bl	ControlHandle
 7541              	.LVL909:
 7542 41d4 44309DE5 		ldr	r3, [sp, #68]
 7543 41d8 D9FFFFEA 		b	.L646
 7544              	.L652:
 7545              	.LBE345:
 7546              	.LBE344:
 7547              	.LBB376:
 7548              	.LBB377:
4898:../uvc.c      ****     {
 7549              		.loc 1 4898 0
 7550 41dc 8C1E9FE5 		ldr	r1, .L1038+96
 7551 41e0 B030D1E1 		ldrh	r3, [r1]
 7552 41e4 0140A0E1 		mov	r4, r1
 7553 41e8 0D0C53E3 		cmp	r3, #3328
 7554 41ec 4704000A 		beq	.L832
 7555 41f0 6E00008A 		bhi	.L833
 7556 41f4 060C53E3 		cmp	r3, #1536
 7557 41f8 4004000A 		beq	.L834
 7558 41fc 9900009A 		bls	.L999
 7559 4200 090C53E3 		cmp	r3, #2304
 7560 4204 3904000A 		beq	.L842
 7561 4208 5A01009A 		bls	.L1000
 7562 420c 0B0C53E3 		cmp	r3, #2816
 7563 4210 3204000A 		beq	.L846
 7564 4214 030B53E3 		cmp	r3, #3072
 7565 4218 ED03000A 		beq	.L847
 7566 421c 0A0C53E3 		cmp	r3, #2560
 7567 4220 C2FFFF1A 		bne	.L647
 7568              	.LVL910:
4939:../uvc.c      ****     		}else/* no support for 1080p camera */
 7569              		.loc 1 4939 0
 7570 4224 1900A0E3 		mov	r0, #25
 7571 4228 FEFFFFEB 		bl	ControlHandle
 7572              	.LVL911:
 7573 422c 44309DE5 		ldr	r3, [sp, #68]
 7574 4230 C3FFFFEA 		b	.L646
 7575              	.L993:
 7576              	.LBE377:
 7577              	.LBE376:
5422:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7578              		.loc 1 5422 0
 7579 4234 E80D9FE5 		ldr	r0, .L1038+20
 7580 4238 181E9FE5 		ldr	r1, .L1038+72
 7581 423c E42D9FE5 		ldr	r2, .L1038+24
 7582 4240 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7583 4244 244E9FE5 		ldr	r4, .L1038+96
 7584 4248 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7585 424c B010D2E1 		ldrh	r1, [r2]
 7586 4250 B0C0D4E1 		ldrh	ip, [r4]
 7587 4254 00008DE5 		str	r0, [sp]
 7588 4258 B000DAE1 		ldrh	r0, [r10]
 7589 425c 10108DE5 		str	r1, [sp, #16]
 7590 4260 0010A0E3 		mov	r1, #0
 7591 4264 0C008DE5 		str	r0, [sp, #12]
 7592 4268 14108DE5 		str	r1, [sp, #20]
 7593 426c 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 7594 4270 04E08DE5 		str	lr, [sp, #4]
 7595 4274 08C08DE5 		str	ip, [sp, #8]
 7596 4278 0400A0E3 		mov	r0, #4
 7597 427c A81D9FE5 		ldr	r1, .L1038+28
 7598 4280 FEFFFFEB 		bl	CyU3PDebugPrint
 7599              	.LVL912:
 7600 4284 44309DE5 		ldr	r3, [sp, #68]
 7601 4288 8AFFFFEA 		b	.L645
 7602              	.L992:
5414:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7603              		.loc 1 5414 0
 7604 428c FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7605              	.LVL913:
5415:../uvc.c      ****                 {
 7606              		.loc 1 5415 0
 7607 4290 000050E3 		cmp	r0, #0
5417:../uvc.c      ****                 }
 7608              		.loc 1 5417 0
 7609 4294 0130A013 		movne	r3, #1
5414:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7610              		.loc 1 5414 0
 7611 4298 4800CBE5 		strb	r0, [fp, #72]
5417:../uvc.c      ****                 }
 7612              		.loc 1 5417 0
 7613 429c 8C308B15 		strne	r3, [fp, #140]
 7614 42a0 81FFFFEA 		b	.L643
 7615              	.L919:
5466:../uvc.c      ****                 }
 7616              		.loc 1 5466 0
 7617 42a4 64EFFFEB 		bl	UVCHandleVideoStreamingRqts
 7618              	.LVL914:
 7619 42a8 44309DE5 		ldr	r3, [sp, #68]
 7620 42ac AEFFFFEA 		b	.L918
 7621              	.L998:
5562:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7622              		.loc 1 5562 0
 7623 42b0 002098E5 		ldr	r2, [r8]
 7624 42b4 0210A0E3 		mov	r1, #2
 7625 42b8 0010C2E5 		strb	r1, [r2]
5563:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7626              		.loc 1 5563 0
 7627 42bc 002098E5 		ldr	r2, [r8]
 7628 42c0 0140A0E3 		mov	r4, #1
 7629 42c4 0140C2E5 		strb	r4, [r2, #1]
5564:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7630              		.loc 1 5564 0
 7631 42c8 001098E5 		ldr	r1, [r8]
5568:../uvc.c      **** 					interStabuf.status = 0;
 7632              		.loc 1 5568 0
 7633 42cc 012BA0E3 		mov	r2, #1024
5564:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7634              		.loc 1 5564 0
 7635 42d0 0230C1E5 		strb	r3, [r1, #2]
5565:../uvc.c      **** 
 7636              		.loc 1 5565 0
 7637 42d4 001098E5 		ldr	r1, [r8]
5571:../uvc.c      **** 
 7638              		.loc 1 5571 0
 7639 42d8 0450A0E3 		mov	r5, #4
5565:../uvc.c      **** 
 7640              		.loc 1 5565 0
 7641 42dc 0340C1E5 		strb	r4, [r1, #3]
5567:../uvc.c      **** 					interStabuf.size   = 1024;
 7642              		.loc 1 5567 0
 7643 42e0 001098E5 		ldr	r1, [r8]
5574:../uvc.c      **** 
 7644              		.loc 1 5574 0
 7645 42e4 440D9FE5 		ldr	r0, .L1038+32
5567:../uvc.c      **** 					interStabuf.size   = 1024;
 7646              		.loc 1 5567 0
 7647 42e8 4C108DE5 		str	r1, [sp, #76]
5574:../uvc.c      **** 
 7648              		.loc 1 5574 0
 7649 42ec 0010E0E3 		mvn	r1, #0
5569:../uvc.c      **** 
 7650              		.loc 1 5569 0
 7651 42f0 B435CDE1 		strh	r3, [sp, #84]	@ movhi
5568:../uvc.c      **** 					interStabuf.status = 0;
 7652              		.loc 1 5568 0
 7653 42f4 B225CDE1 		strh	r2, [sp, #82]	@ movhi
5571:../uvc.c      **** 
 7654              		.loc 1 5571 0
 7655 42f8 B055CDE1 		strh	r5, [sp, #80]	@ movhi
5574:../uvc.c      **** 
 7656              		.loc 1 5574 0
 7657 42fc FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7658              	.LVL915:
5577:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7659              		.loc 1 5577 0
 7660 4300 280D9FE5 		ldr	r0, .L1038+32
 7661 4304 4C108DE2 		add	r1, sp, #76
 7662 4308 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7663              	.LVL916:
5579:../uvc.c      **** 					{
 7664              		.loc 1 5579 0
 7665 430c 000050E3 		cmp	r0, #0
 7666 4310 0902001A 		bne	.L1001
5585:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7667              		.loc 1 5585 0
 7668 4314 0500A0E3 		mov	r0, #5
 7669              	.LVL917:
 7670 4318 3010A0E3 		mov	r1, #48
 7671 431c 0420A0E1 		mov	r2, r4
 7672 4320 FEFFFFEB 		bl	SensorSetControl
 7673              	.LVL918:
5586:../uvc.c      **** 				}
 7674              		.loc 1 5586 0
 7675 4324 E8EC9FE5 		ldr	lr, .L1038+4
 7676 4328 6A47CEE5 		strb	r4, [lr, #1898]
 7677 432c 98FFFFEA 		b	.L641
 7678              	.L997:
5535:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7679              		.loc 1 5535 0
 7680 4330 003098E5 		ldr	r3, [r8]
 7681 4334 0220A0E3 		mov	r2, #2
 7682 4338 0020C3E5 		strb	r2, [r3]
5536:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7683              		.loc 1 5536 0
 7684 433c 003098E5 		ldr	r3, [r8]
 7685 4340 0140A0E3 		mov	r4, #1
 7686 4344 0140C3E5 		strb	r4, [r3, #1]
5537:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7687              		.loc 1 5537 0
 7688 4348 002098E5 		ldr	r2, [r8]
 7689 434c 0030A0E3 		mov	r3, #0
 7690 4350 0230C2E5 		strb	r3, [r2, #2]
5538:../uvc.c      **** 
 7691              		.loc 1 5538 0
 7692 4354 001098E5 		ldr	r1, [r8]
5541:../uvc.c      **** 					interStabuf.status = 0;
 7693              		.loc 1 5541 0
 7694 4358 012BA0E3 		mov	r2, #1024
5538:../uvc.c      **** 
 7695              		.loc 1 5538 0
 7696 435c 0330C1E5 		strb	r3, [r1, #3]
5540:../uvc.c      **** 					interStabuf.size   = 1024;
 7697              		.loc 1 5540 0
 7698 4360 001098E5 		ldr	r1, [r8]
5544:../uvc.c      **** 
 7699              		.loc 1 5544 0
 7700 4364 0460A0E3 		mov	r6, #4
5540:../uvc.c      **** 					interStabuf.size   = 1024;
 7701              		.loc 1 5540 0
 7702 4368 4C108DE5 		str	r1, [sp, #76]
5547:../uvc.c      **** 
 7703              		.loc 1 5547 0
 7704 436c BC0C9FE5 		ldr	r0, .L1038+32
 7705 4370 0010E0E3 		mvn	r1, #0
5541:../uvc.c      **** 					interStabuf.status = 0;
 7706              		.loc 1 5541 0
 7707 4374 B225CDE1 		strh	r2, [sp, #82]	@ movhi
5542:../uvc.c      **** 
 7708              		.loc 1 5542 0
 7709 4378 B435CDE1 		strh	r3, [sp, #84]	@ movhi
5544:../uvc.c      **** 
 7710              		.loc 1 5544 0
 7711 437c B065CDE1 		strh	r6, [sp, #80]	@ movhi
5547:../uvc.c      **** 
 7712              		.loc 1 5547 0
 7713 4380 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7714              	.LVL919:
5550:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7715              		.loc 1 5550 0
 7716 4384 A40C9FE5 		ldr	r0, .L1038+32
 7717 4388 4C108DE2 		add	r1, sp, #76
 7718 438c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7719              	.LVL920:
5552:../uvc.c      **** 					{
 7720              		.loc 1 5552 0
 7721 4390 002050E2 		subs	r2, r0, #0
 7722 4394 0704001A 		bne	.L1002
5557:../uvc.c      **** 
 7723              		.loc 1 5557 0
 7724 4398 0500A0E3 		mov	r0, #5
 7725              	.LVL921:
 7726 439c 3010A0E3 		mov	r1, #48
 7727 43a0 FEFFFFEB 		bl	SensorSetControl
 7728              	.LVL922:
5559:../uvc.c      **** 				}else if(!snapButFlag){
 7729              		.loc 1 5559 0
 7730 43a4 68CC9FE5 		ldr	ip, .L1038+4
 7731 43a8 6A47CCE5 		strb	r4, [ip, #1898]
 7732 43ac 78FFFFEA 		b	.L641
 7733              	.L833:
 7734              	.LBB431:
 7735              	.LBB418:
4898:../uvc.c      ****     {
 7736              		.loc 1 4898 0
 7737 43b0 050B53E3 		cmp	r3, #5120
 7738 43b4 7C03000A 		beq	.L849
 7739 43b8 3500009A 		bls	.L1003
 7740 43bc 170C53E3 		cmp	r3, #5888
 7741 43c0 9B03000A 		beq	.L857
 7742 43c4 B300009A 		bls	.L1004
 7743 43c8 1A0C53E3 		cmp	r3, #6656
 7744 43cc 8E03000A 		beq	.L861
 7745 43d0 1B0C53E3 		cmp	r3, #6912
 7746 43d4 8203000A 		beq	.L862
 7747 43d8 060B53E3 		cmp	r3, #6144
 7748 43dc 53FFFF1A 		bne	.L647
5003:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7749              		.loc 1 5003 0
 7750 43e0 2B00A0E3 		mov	r0, #43
 7751 43e4 FEFFFFEB 		bl	ControlHandle
 7752              	.LVL923:
5004:../uvc.c      ****     		break;
 7753              		.loc 1 5004 0
 7754 43e8 683C9FE5 		ldr	r3, .L1038+72
 7755 43ec B020D4E1 		ldrh	r2, [r4]
 7756 43f0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7757 43f4 0400A0E3 		mov	r0, #4
 7758 43f8 341C9FE5 		ldr	r1, .L1038+36
 7759 43fc FEFFFFEB 		bl	CyU3PDebugPrint
 7760              	.LVL924:
 7761 4400 44309DE5 		ldr	r3, [sp, #68]
 7762 4404 4EFFFFEA 		b	.L646
 7763              	.L655:
 7764              	.LBE418:
 7765              	.LBE431:
 7766              	.LBB432:
 7767              	.LBB364:
4598:../uvc.c      ****     {
 7768              		.loc 1 4598 0
 7769 4408 0A0C52E3 		cmp	r2, #2560
 7770 440c 5E00000A 		beq	.L661
 7771 4410 3200009A 		bls	.L1005
 7772 4414 0D0C52E3 		cmp	r2, #3328
 7773 4418 5B00000A 		beq	.L661
 7774 441c 0E0C52E3 		cmp	r2, #3584
 7775 4420 5D00000A 		beq	.L665
 7776 4424 030B52E3 		cmp	r2, #3072
 7777 4428 3BFFFF1A 		bne	.L694
 7778              	.LVL925:
4639:../uvc.c      ****     		break;
 7779              		.loc 1 4639 0
 7780 442c 0B00A0E3 		mov	r0, #11
 7781 4430 FEFFFFEB 		bl	ControlHandle
 7782              	.LVL926:
 7783 4434 44309DE5 		ldr	r3, [sp, #68]
 7784 4438 41FFFFEA 		b	.L646
 7785              	.L994:
 7786              	.LBE364:
 7787              	.LBE432:
 7788              	.LBB433:
 7789              	.LBB334:
4673:../uvc.c      ****     {
 7790              		.loc 1 4673 0
 7791 443c 030C52E3 		cmp	r2, #768
 7792 4440 D400000A 		beq	.L697
 7793 4444 3200008A 		bhi	.L698
 7794 4448 010C52E3 		cmp	r2, #256
 7795 444c FC00000A 		beq	.L699
 7796 4450 020C52E3 		cmp	r2, #512
 7797 4454 30FFFF1A 		bne	.L694
 7798              	.LVL927:
4681:../uvc.c      ****     		break;
 7799              		.loc 1 4681 0
 7800 4458 0100A0E3 		mov	r0, #1
 7801 445c FEFFFFEB 		bl	CTControlHandle
 7802              	.LVL928:
 7803 4460 44309DE5 		ldr	r3, [sp, #68]
 7804 4464 36FFFFEA 		b	.L646
 7805              	.L999:
 7806              	.LBE334:
 7807              	.LBE433:
 7808              	.LBB434:
 7809              	.LBB419:
4898:../uvc.c      ****     {
 7810              		.loc 1 4898 0
 7811 4468 030C53E3 		cmp	r3, #768
 7812 446c AF03000A 		beq	.L836
 7813 4470 7800008A 		bhi	.L837
 7814 4474 010C53E3 		cmp	r3, #256
 7815 4478 A803000A 		beq	.L838
 7816 447c 020C53E3 		cmp	r3, #512
 7817 4480 2AFFFF1A 		bne	.L647
 7818              	.LVL929:
4906:../uvc.c      ****     		break;
 7819              		.loc 1 4906 0
 7820 4484 1100A0E3 		mov	r0, #17
 7821 4488 FEFFFFEB 		bl	ControlHandle
 7822              	.LVL930:
 7823 448c 44309DE5 		ldr	r3, [sp, #68]
 7824 4490 2BFFFFEA 		b	.L646
 7825              	.L1003:
4898:../uvc.c      ****     {
 7826              		.loc 1 4898 0
 7827 4494 110C53E3 		cmp	r3, #4352
 7828 4498 A803000A 		beq	.L851
 7829 449c AD00008A 		bhi	.L852
 7830 44a0 0F0C53E3 		cmp	r3, #3840
 7831 44a4 AD03000A 		beq	.L853
 7832 44a8 010A53E3 		cmp	r3, #4096
 7833 44ac 1FFFFF1A 		bne	.L647
 7834              	.LVL931:
4967:../uvc.c      ****     		break;
 7835              		.loc 1 4967 0
 7836 44b0 1F00A0E3 		mov	r0, #31
 7837 44b4 FEFFFFEB 		bl	ControlHandle
 7838              	.LVL932:
 7839 44b8 44309DE5 		ldr	r3, [sp, #68]
 7840 44bc 20FFFFEA 		b	.L646
 7841              	.L657:
 7842              	.LBE419:
 7843              	.LBE434:
 7844              	.LBB435:
 7845              	.LBB365:
4598:../uvc.c      ****     {
 7846              		.loc 1 4598 0
 7847 44c0 010B52E3 		cmp	r2, #1024
 7848 44c4 1EFFFF0A 		beq	.L646
 7849 44c8 050C52E3 		cmp	r2, #1280
 7850 44cc 12FFFF1A 		bne	.L694
 7851              	.LVL933:
4617:../uvc.c      ****       		break;
 7852              		.loc 1 4617 0
 7853 44d0 0400A0E3 		mov	r0, #4
 7854 44d4 FEFFFFEB 		bl	ControlHandle
 7855              	.LVL934:
 7856 44d8 44309DE5 		ldr	r3, [sp, #68]
 7857 44dc 18FFFFEA 		b	.L646
 7858              	.L1005:
4598:../uvc.c      ****     {
 7859              		.loc 1 4598 0
 7860 44e0 070C52E3 		cmp	r2, #1792
 7861 44e4 5700000A 		beq	.L663
 7862 44e8 020B52E3 		cmp	r2, #2048
 7863 44ec 0AFFFF1A 		bne	.L694
 7864              	.LVL935:
4629:../uvc.c      ****           		break;
 7865              		.loc 1 4629 0
 7866 44f0 0700A0E3 		mov	r0, #7
 7867 44f4 FEFFFFEB 		bl	ControlHandle
 7868              	.LVL936:
 7869 44f8 44309DE5 		ldr	r3, [sp, #68]
 7870 44fc 10FFFFEA 		b	.L646
 7871              	.L995:
 7872              	.LBE365:
 7873              	.LBE435:
 7874              	.LBB436:
 7875              	.LBB335:
4673:../uvc.c      ****     {
 7876              		.loc 1 4673 0
 7877 4500 070C52E3 		cmp	r2, #1792
 7878 4504 B400000A 		beq	.L705
 7879 4508 020B52E3 		cmp	r2, #2048
 7880 450c 0CFFFF0A 		beq	.L646
 7881 4510 01FFFFEA 		b	.L694
 7882              	.L698:
 7883 4514 010B52E3 		cmp	r2, #1024
 7884 4518 E300000A 		beq	.L701
 7885 451c 050C52E3 		cmp	r2, #1280
 7886 4520 FDFEFF1A 		bne	.L694
 7887              	.LVL937:
 7888              	.LBB170:
 7889              	.LBB171:
2980:../uvc.c      **** 
 7890              		.loc 1 2980 0
 7891 4524 2C4B9FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 7892              		.loc 1 2975 0
 7893 4528 1266D9E5 		ldrb	r6, [r9, #1554]	@ zero_extendqisi2
 7894              	.LVL938:
2980:../uvc.c      **** 
 7895              		.loc 1 2980 0
 7896 452c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 7897              	.LVL939:
2982:../uvc.c      **** 		 {
 7898              		.loc 1 2982 0
 7899 4530 830055E3 		cmp	r5, #131
 7900 4534 B405000A 		beq	.L747
 7901 4538 2802009A 		bls	.L1006
 7902 453c 850055E3 		cmp	r5, #133
 7903 4540 0403000A 		beq	.L809
 7904 4544 6905003A 		bcc	.L753
 7905 4548 860055E3 		cmp	r5, #134
 7906 454c 1E04000A 		beq	.L754
 7907 4550 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 7908              		.loc 1 3044 0
 7909 4554 1B16D905 		ldreqb	r1, [r9, #1563]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7910              		.loc 1 3045 0
 7911 4558 1C26D905 		ldreqb	r2, [r9, #1564]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 7912              		.loc 1 2982 0
 7913 455c 1301000A 		beq	.L976
 7914              	.L746:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7915              		.loc 1 3189 0
 7916 4560 0000A0E3 		mov	r0, #0
 7917 4564 0020A0E1 		mov	r2, r0
 7918 4568 0110A0E3 		mov	r1, #1
 7919 456c FEFFFFEB 		bl	CyU3PUsbStall
 7920              	.LVL940:
3190:../uvc.c      **** 			  break;
 7921              		.loc 1 3190 0
 7922 4570 0400A0E3 		mov	r0, #4
 7923 4574 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 7924 4578 0020A0E1 		mov	r2, r0
 7925 457c FC1A9FE5 		ldr	r1, .L1038+112
 7926 4580 FEFFFFEB 		bl	CyU3PDebugPrint
 7927              	.LVL941:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7928              		.loc 1 2976 0
 7929 4584 FF40A0E3 		mov	r4, #255
 7930              	.LVL942:
 7931 4588 F90200EA 		b	.L813
 7932              	.LVL943:
 7933              	.L661:
 7934              	.LBE171:
 7935              	.LBE170:
 7936              	.LBE335:
 7937              	.LBE436:
 7938              	.LBB437:
 7939              	.LBB366:
4635:../uvc.c      ****     		break;
 7940              		.loc 1 4635 0
 7941 458c 0900A0E3 		mov	r0, #9
 7942 4590 FEFFFFEB 		bl	ControlHandle
 7943              	.LVL944:
 7944 4594 44309DE5 		ldr	r3, [sp, #68]
 7945 4598 E9FEFFEA 		b	.L646
 7946              	.L665:
 7947              	.LVL945:
 7948              	.LBB346:
 7949              	.LBB347:
1338:../uvc.c      ****     /*
 7950              		.loc 1 1338 0
 7951 459c B43A9FE5 		ldr	r3, .L1038+72
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7952              		.loc 1 1327 0
 7953 45a0 3027D9E5 		ldrb	r2, [r9, #1840]	@ zero_extendqisi2
1338:../uvc.c      ****     /*
 7954              		.loc 1 1338 0
 7955 45a4 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1328:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7956              		.loc 1 1328 0
 7957 45a8 3147D9E5 		ldrb	r4, [r9, #1841]	@ zero_extendqisi2
1329:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7958              		.loc 1 1329 0
 7959 45ac 3F37D9E5 		ldrb	r3, [r9, #1855]	@ zero_extendqisi2
1330:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7960              		.loc 1 1330 0
 7961 45b0 3257D9E5 		ldrb	r5, [r9, #1842]	@ zero_extendqisi2
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7962              		.loc 1 1327 0
 7963 45b4 FF2002E2 		and	r2, r2, #255
1329:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7964              		.loc 1 1329 0
 7965 45b8 FF3003E2 		and	r3, r3, #255
1346:../uvc.c      **** 		 {
 7966              		.loc 1 1346 0
 7967 45bc 830056E3 		cmp	r6, #131
1327:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7968              		.loc 1 1327 0
 7969 45c0 2C208DE5 		str	r2, [sp, #44]
 7970              	.LVL946:
1328:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7971              		.loc 1 1328 0
 7972 45c4 FF4004E2 		and	r4, r4, #255
 7973              	.LVL947:
1329:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7974              		.loc 1 1329 0
 7975 45c8 28308DE5 		str	r3, [sp, #40]
 7976              	.LVL948:
1330:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7977              		.loc 1 1330 0
 7978 45cc FF5005E2 		and	r5, r5, #255
 7979              	.LVL949:
1346:../uvc.c      **** 		 {
 7980              		.loc 1 1346 0
 7981 45d0 BA04000A 		beq	.L668
 7982 45d4 5F01009A 		bls	.L1007
 7983 45d8 850056E3 		cmp	r6, #133
 7984 45dc 9F04000A 		beq	.L673
 7985 45e0 C404003A 		bcc	.L674
 7986 45e4 860056E3 		cmp	r6, #134
 7987 45e8 8F03000A 		beq	.L675
 7988 45ec 870056E3 		cmp	r6, #135
 7989 45f0 A704001A 		bne	.L667
1997:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7990              		.loc 1 1997 0
 7991 45f4 020055E3 		cmp	r5, #2
2002:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7992              		.loc 1 2002 0
 7993 45f8 3BC7D915 		ldrneb	ip, [r9, #1851]	@ zero_extendqisi2
2004:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7994              		.loc 1 2004 0
 7995 45fc 3C27D915 		ldrneb	r2, [r9, #1852]	@ zero_extendqisi2
1997:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7996              		.loc 1 1997 0
 7997 4600 A206000A 		beq	.L1008
 7998              	.L987:
2009:../uvc.c      **** 		 	 if(Len == 2){
 7999              		.loc 1 2009 0
 8000 4604 7C1A9FE5 		ldr	r1, .L1038+120
2005:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8001              		.loc 1 2005 0
 8002 4608 0030A0E3 		mov	r3, #0
2009:../uvc.c      **** 		 	 if(Len == 2){
 8003              		.loc 1 2009 0
 8004 460c 0500A0E1 		mov	r0, r5
2002:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8005              		.loc 1 2002 0
 8006 4610 28C0C7E5 		strb	ip, [r7, #40]
2004:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8007              		.loc 1 2004 0
 8008 4614 2920C7E5 		strb	r2, [r7, #41]
2005:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8009              		.loc 1 2005 0
 8010 4618 2B30C7E5 		strb	r3, [r7, #43]
2015:../uvc.c      **** 		 	 }
 8011              		.loc 1 2015 0
 8012 461c 24308DE5 		str	r3, [sp, #36]
 8013              	.LVL950:
 8014              	.L965:
1900:../uvc.c      **** 		 	 if(Len == 2){
 8015              		.loc 1 1900 0
 8016 4620 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8017              	.LVL951:
1906:../uvc.c      **** 			  }
 8018              		.loc 1 1906 0
 8019 4624 0050A0E3 		mov	r5, #0
 8020              	.LVL952:
1905:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
 8021              		.loc 1 1905 0
 8022 4628 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8023              	.LVL953:
1906:../uvc.c      **** 			  }
 8024              		.loc 1 1906 0
 8025 462c 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 8026              	.LVL954:
 8027 4630 24209DE5 		ldr	r2, [sp, #36]
 8028 4634 710100EA 		b	.L677
 8029              	.LVL955:
 8030              	.L658:
 8031              	.LBE347:
 8032              	.LBE346:
4602:../uvc.c      ****     		break;
 8033              		.loc 1 4602 0
 8034 4638 0000A0E3 		mov	r0, #0
 8035 463c FEFFFFEB 		bl	ControlHandle
 8036              	.LVL956:
 8037 4640 44309DE5 		ldr	r3, [sp, #68]
 8038 4644 BEFEFFEA 		b	.L646
 8039              	.L663:
 8040              	.LVL957:
4625:../uvc.c      ****           		break;
 8041              		.loc 1 4625 0
 8042 4648 0600A0E3 		mov	r0, #6
 8043 464c FEFFFFEB 		bl	ControlHandle
 8044              	.LVL958:
 8045 4650 44309DE5 		ldr	r3, [sp, #68]
 8046 4654 BAFEFFEA 		b	.L646
 8047              	.L837:
 8048              	.LBE366:
 8049              	.LBE437:
 8050              	.LBB438:
 8051              	.LBB420:
4898:../uvc.c      ****     {
 8052              		.loc 1 4898 0
 8053 4658 010B53E3 		cmp	r3, #1024
 8054 465c 4303000A 		beq	.L840
 8055 4660 050C53E3 		cmp	r3, #1280
 8056 4664 B1FEFF1A 		bne	.L647
 8057              	.LVL959:
4918:../uvc.c      ****     		break;
 8058              		.loc 1 4918 0
 8059 4668 1400A0E3 		mov	r0, #20
 8060 466c FEFFFFEB 		bl	ControlHandle
 8061              	.LVL960:
 8062 4670 44309DE5 		ldr	r3, [sp, #68]
 8063 4674 B2FEFFEA 		b	.L646
 8064              	.L656:
 8065              	.LVL961:
 8066              	.LBE420:
 8067              	.LBE438:
 8068              	.LBB439:
 8069              	.LBB367:
4610:../uvc.c      **** 			break;
 8070              		.loc 1 4610 0
 8071 4678 0200A0E3 		mov	r0, #2
 8072 467c FEFFFFEB 		bl	ControlHandle
 8073              	.LVL962:
 8074 4680 44309DE5 		ldr	r3, [sp, #68]
 8075 4684 AEFEFFEA 		b	.L646
 8076              	.L654:
 8077              	.LVL963:
4621:../uvc.c      ****      		break;
 8078              		.loc 1 4621 0
 8079 4688 0500A0E3 		mov	r0, #5
 8080 468c FEFFFFEB 		bl	ControlHandle
 8081              	.LVL964:
 8082 4690 44309DE5 		ldr	r3, [sp, #68]
 8083 4694 AAFEFFEA 		b	.L646
 8084              	.L1004:
 8085              	.LBE367:
 8086              	.LBE439:
 8087              	.LBB440:
 8088              	.LBB421:
4898:../uvc.c      ****     {
 8089              		.loc 1 4898 0
 8090 4698 150C53E3 		cmp	r3, #5376
 8091 469c 3B03000A 		beq	.L859
 8092 46a0 160C53E3 		cmp	r3, #5632
 8093 46a4 A1FEFF1A 		bne	.L647
 8094              	.LVL965:
 8095              	.LBB378:
 8096              	.LBB379:
1338:../uvc.c      ****     /*
 8097              		.loc 1 1338 0
 8098 46a8 A8499FE5 		ldr	r4, .L1038+72
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8099              		.loc 1 1320 0
 8100 46ac 4427D9E5 		ldrb	r2, [r9, #1860]	@ zero_extendqisi2
1338:../uvc.c      ****     /*
 8101              		.loc 1 1338 0
 8102 46b0 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
1321:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8103              		.loc 1 1321 0
 8104 46b4 4557D9E5 		ldrb	r5, [r9, #1861]	@ zero_extendqisi2
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8105              		.loc 1 1322 0
 8106 46b8 5337D9E5 		ldrb	r3, [r9, #1875]	@ zero_extendqisi2
1323:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8107              		.loc 1 1323 0
 8108 46bc 4667D9E5 		ldrb	r6, [r9, #1862]	@ zero_extendqisi2
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8109              		.loc 1 1320 0
 8110 46c0 FF2002E2 		and	r2, r2, #255
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8111              		.loc 1 1322 0
 8112 46c4 FF3003E2 		and	r3, r3, #255
1346:../uvc.c      **** 		 {
 8113              		.loc 1 1346 0
 8114 46c8 83005CE3 		cmp	ip, #131
1338:../uvc.c      ****     /*
 8115              		.loc 1 1338 0
 8116 46cc 28C08DE5 		str	ip, [sp, #40]
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8117              		.loc 1 1320 0
 8118 46d0 34208DE5 		str	r2, [sp, #52]
 8119              	.LVL966:
1321:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8120              		.loc 1 1321 0
 8121 46d4 FF5005E2 		and	r5, r5, #255
 8122              	.LVL967:
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8123              		.loc 1 1322 0
 8124 46d8 2C308DE5 		str	r3, [sp, #44]
 8125              	.LVL968:
1323:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8126              		.loc 1 1323 0
 8127 46dc FF6006E2 		and	r6, r6, #255
 8128              	.LVL969:
1346:../uvc.c      **** 		 {
 8129              		.loc 1 1346 0
 8130 46e0 F903000A 		beq	.L865
 8131 46e4 3304009A 		bls	.L1009
 8132 46e8 28C09DE5 		ldr	ip, [sp, #40]
 8133 46ec 85005CE3 		cmp	ip, #133
 8134 46f0 BC03000A 		beq	.L870
 8135 46f4 BA05003A 		bcc	.L871
 8136 46f8 86005CE3 		cmp	ip, #134
 8137 46fc AF05000A 		beq	.L872
 8138 4700 87005CE3 		cmp	ip, #135
 8139 4704 DE05001A 		bne	.L864
1984:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8140              		.loc 1 1984 0
 8141 4708 020056E3 		cmp	r6, #2
1985:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8142              		.loc 1 1985 0
 8143 470c 4F27D905 		ldreqb	r2, [r9, #1871]	@ zero_extendqisi2
2009:../uvc.c      **** 		 	 if(Len == 2){
 8144              		.loc 1 2009 0
 8145 4710 0600A001 		moveq	r0, r6
1986:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8146              		.loc 1 1986 0
 8147 4714 5037D905 		ldreqb	r3, [r9, #1872]	@ zero_extendqisi2
1984:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8148              		.loc 1 1984 0
 8149 4718 F203000A 		beq	.L979
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8150              		.loc 1 1990 0
 8151 471c 4FC7D9E5 		ldrb	ip, [r9, #1871]	@ zero_extendqisi2
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8152              		.loc 1 1992 0
 8153 4720 5027D9E5 		ldrb	r2, [r9, #1872]	@ zero_extendqisi2
 8154              	.L980:
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8155              		.loc 1 1991 0
 8156 4724 0030A0E3 		mov	r3, #0
2009:../uvc.c      **** 		 	 if(Len == 2){
 8157              		.loc 1 2009 0
 8158 4728 0600A0E1 		mov	r0, r6
 8159 472c 54199FE5 		ldr	r1, .L1038+120
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8160              		.loc 1 1990 0
 8161 4730 28C0C7E5 		strb	ip, [r7, #40]
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8162              		.loc 1 1992 0
 8163 4734 2A20C7E5 		strb	r2, [r7, #42]
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8164              		.loc 1 1991 0
 8165 4738 2930C7E5 		strb	r3, [r7, #41]
1993:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8166              		.loc 1 1993 0
 8167 473c 2B30C7E5 		strb	r3, [r7, #43]
2015:../uvc.c      **** 		 	 }
 8168              		.loc 1 2015 0
 8169 4740 24308DE5 		str	r3, [sp, #36]
 8170 4744 0060A0E3 		mov	r6, #0
 8171              	.LVL970:
2009:../uvc.c      **** 		 	 if(Len == 2){
 8172              		.loc 1 2009 0
 8173 4748 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8174              	.LVL971:
2014:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8175              		.loc 1 2014 0
 8176 474c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8177              	.LVL972:
2015:../uvc.c      **** 		 	 }
 8178              		.loc 1 2015 0
 8179 4750 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 8180              	.LVL973:
 8181 4754 AD0300EA 		b	.L874
 8182              	.LVL974:
 8183              	.L852:
 8184              	.LBE379:
 8185              	.LBE378:
4898:../uvc.c      ****     {
 8186              		.loc 1 4898 0
 8187 4758 120C53E3 		cmp	r3, #4608
 8188 475c 0703000A 		beq	.L855
 8189 4760 130C53E3 		cmp	r3, #4864
 8190 4764 71FEFF1A 		bne	.L647
 8191              	.LVL975:
4979:../uvc.c      ****     		break;
 8192              		.loc 1 4979 0
 8193 4768 2600A0E3 		mov	r0, #38
 8194 476c FEFFFFEB 		bl	ControlHandle
 8195              	.LVL976:
 8196 4770 44309DE5 		ldr	r3, [sp, #68]
 8197 4774 72FEFFEA 		b	.L646
 8198              	.L1000:
4898:../uvc.c      ****     {
 8199              		.loc 1 4898 0
 8200 4778 070C53E3 		cmp	r3, #1792
 8201 477c F302000A 		beq	.L844
 8202 4780 020B53E3 		cmp	r3, #2048
 8203 4784 69FEFF1A 		bne	.L647
 8204              	.LVL977:
4930:../uvc.c      ****     		break;
 8205              		.loc 1 4930 0
 8206 4788 1700A0E3 		mov	r0, #23
 8207 478c FEFFFFEB 		bl	ControlHandle
 8208              	.LVL978:
 8209 4790 44309DE5 		ldr	r3, [sp, #68]
 8210 4794 6AFEFFEA 		b	.L646
 8211              	.L697:
 8212              	.LVL979:
 8213              	.LBE421:
 8214              	.LBE440:
 8215              	.LBB441:
 8216              	.LBB336:
 8217              	.LBB178:
 8218              	.LBB179:
2980:../uvc.c      **** 
 8219              		.loc 1 2980 0
 8220 4798 B8489FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8221              		.loc 1 2975 0
 8222 479c E265D9E5 		ldrb	r6, [r9, #1506]	@ zero_extendqisi2
 8223              	.LVL980:
2980:../uvc.c      **** 
 8224              		.loc 1 2980 0
 8225 47a0 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8226              	.LVL981:
2982:../uvc.c      **** 		 {
 8227              		.loc 1 2982 0
 8228 47a4 830055E3 		cmp	r5, #131
 8229 47a8 2705000A 		beq	.L721
 8230 47ac 1C01009A 		bls	.L1010
 8231 47b0 850055E3 		cmp	r5, #133
 8232 47b4 6702000A 		beq	.L809
 8233 47b8 0005003A 		bcc	.L727
 8234 47bc 860055E3 		cmp	r5, #134
 8235 47c0 4803000A 		beq	.L728
 8236 47c4 870055E3 		cmp	r5, #135
 8237 47c8 2F05001A 		bne	.L720
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8238              		.loc 1 3044 0
 8239 47cc 40C89FE5 		ldr	ip, .L1038+4
 8240 47d0 EB15DCE5 		ldrb	r1, [ip, #1515]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8241              		.loc 1 3045 0
 8242 47d4 EC25DCE5 		ldrb	r2, [ip, #1516]	@ zero_extendqisi2
 8243 47d8 740000EA 		b	.L976
 8244              	.LVL982:
 8245              	.L705:
 8246              	.LBE179:
 8247              	.LBE178:
 8248              	.LBB187:
 8249              	.LBB188:
2980:../uvc.c      **** 
 8250              		.loc 1 2980 0
 8251 47dc 74489FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8252              		.loc 1 2975 0
 8253 47e0 4266D9E5 		ldrb	r6, [r9, #1602]	@ zero_extendqisi2
 8254              	.LVL983:
2980:../uvc.c      **** 
 8255              		.loc 1 2980 0
 8256 47e4 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8257              	.LVL984:
2982:../uvc.c      **** 		 {
 8258              		.loc 1 2982 0
 8259 47e8 830055E3 		cmp	r5, #131
 8260 47ec C904000A 		beq	.L769
 8261 47f0 E201009A 		bls	.L1011
 8262 47f4 850055E3 		cmp	r5, #133
 8263 47f8 5602000A 		beq	.L809
 8264 47fc 2D05003A 		bcc	.L775
 8265 4800 860055E3 		cmp	r5, #134
 8266 4804 6203000A 		beq	.L776
 8267 4808 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8268              		.loc 1 3044 0
 8269 480c 4B16D905 		ldreqb	r1, [r9, #1611]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8270              		.loc 1 3045 0
 8271 4810 4C26D905 		ldreqb	r2, [r9, #1612]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8272              		.loc 1 2982 0
 8273 4814 6500000A 		beq	.L976
 8274              	.L768:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8275              		.loc 1 3189 0
 8276 4818 0000A0E3 		mov	r0, #0
 8277 481c 0020A0E1 		mov	r2, r0
 8278 4820 0110A0E3 		mov	r1, #1
 8279 4824 FEFFFFEB 		bl	CyU3PUsbStall
 8280              	.LVL985:
3190:../uvc.c      **** 			  break;
 8281              		.loc 1 3190 0
 8282 4828 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8283 482c 0400A0E3 		mov	r0, #4
 8284 4830 48189FE5 		ldr	r1, .L1038+112
 8285 4834 0620A0E3 		mov	r2, #6
 8286 4838 FEFFFFEB 		bl	CyU3PDebugPrint
 8287              	.LVL986:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8288              		.loc 1 2976 0
 8289 483c FF40A0E3 		mov	r4, #255
 8290              	.LVL987:
 8291 4840 4B0200EA 		b	.L813
 8292              	.LVL988:
 8293              	.L699:
 8294              	.LBE188:
 8295              	.LBE187:
 8296              	.LBB195:
 8297              	.LBB196:
2980:../uvc.c      **** 
 8298              		.loc 1 2980 0
 8299 4844 0C489FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8300              		.loc 1 2975 0
 8301 4848 B265D9E5 		ldrb	r6, [r9, #1458]	@ zero_extendqisi2
 8302              	.LVL989:
2980:../uvc.c      **** 
 8303              		.loc 1 2980 0
 8304 484c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8305              	.LVL990:
2982:../uvc.c      **** 		 {
 8306              		.loc 1 2982 0
 8307 4850 830055E3 		cmp	r5, #131
 8308 4854 AB04000A 		beq	.L710
 8309 4858 0401009A 		bls	.L1012
 8310 485c 850055E3 		cmp	r5, #133
 8311 4860 3C02000A 		beq	.L809
 8312 4864 1705003A 		bcc	.L716
 8313 4868 860055E3 		cmp	r5, #134
 8314 486c 2603000A 		beq	.L717
 8315 4870 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8316              		.loc 1 3044 0
 8317 4874 BB15D905 		ldreqb	r1, [r9, #1467]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8318              		.loc 1 3045 0
 8319 4878 BC25D905 		ldreqb	r2, [r9, #1468]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8320              		.loc 1 2982 0
 8321 487c 4B00000A 		beq	.L976
 8322              	.L709:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8323              		.loc 1 3189 0
 8324 4880 0000A0E3 		mov	r0, #0
 8325 4884 0020A0E1 		mov	r2, r0
 8326 4888 0110A0E3 		mov	r1, #1
 8327 488c FEFFFFEB 		bl	CyU3PUsbStall
 8328              	.LVL991:
3190:../uvc.c      **** 			  break;
 8329              		.loc 1 3190 0
 8330 4890 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8331 4894 0400A0E3 		mov	r0, #4
 8332 4898 E0179FE5 		ldr	r1, .L1038+112
 8333 489c 0020A0E3 		mov	r2, #0
 8334 48a0 FEFFFFEB 		bl	CyU3PDebugPrint
 8335              	.LVL992:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8336              		.loc 1 2976 0
 8337 48a4 FF40A0E3 		mov	r4, #255
 8338              	.LVL993:
 8339 48a8 310200EA 		b	.L813
 8340              	.LVL994:
 8341              	.L701:
 8342              	.LBE196:
 8343              	.LBE195:
 8344              	.LBB203:
 8345              	.LBB204:
2980:../uvc.c      **** 
 8346              		.loc 1 2980 0
 8347 48ac A4479FE5 		ldr	r4, .L1038+72
2973:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8348              		.loc 1 2973 0
 8349 48b0 F8C5D9E5 		ldrb	ip, [r9, #1528]	@ zero_extendqisi2
2980:../uvc.c      **** 
 8350              		.loc 1 2980 0
 8351 48b4 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8352              		.loc 1 2972 0
 8353 48b8 0736D9E5 		ldrb	r3, [r9, #1543]	@ zero_extendqisi2
 8354              	.LVL995:
2982:../uvc.c      **** 		 {
 8355              		.loc 1 2982 0
 8356 48bc 830055E3 		cmp	r5, #131
2973:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8357              		.loc 1 2973 0
 8358 48c0 24C08DE5 		str	ip, [sp, #36]
 8359              	.LVL996:
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8360              		.loc 1 2975 0
 8361 48c4 FA65D9E5 		ldrb	r6, [r9, #1530]	@ zero_extendqisi2
 8362              	.LVL997:
2982:../uvc.c      **** 		 {
 8363              		.loc 1 2982 0
 8364 48c8 D304000A 		beq	.L732
 8365 48cc F900009A 		bls	.L1013
 8366 48d0 850055E3 		cmp	r5, #133
 8367 48d4 BD02000A 		beq	.L785
 8368 48d8 E704003A 		bcc	.L738
 8369 48dc 860055E3 		cmp	r5, #134
 8370 48e0 0B03000A 		beq	.L739
 8371 48e4 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8372              		.loc 1 3044 0
 8373 48e8 0316D905 		ldreqb	r1, [r9, #1539]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8374              		.loc 1 3045 0
 8375 48ec 0426D905 		ldreqb	r2, [r9, #1540]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8376              		.loc 1 2982 0
 8377 48f0 6E04001A 		bne	.L731
 8378              	.LVL998:
 8379              	.L974:
 8380              	.LBE204:
 8381              	.LBE203:
 8382              	.LBB213:
 8383              	.LBB214:
3023:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8384              		.loc 1 3023 0
 8385 48f4 0030A0E3 		mov	r3, #0
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8386              		.loc 1 3020 0
 8387 48f8 2810C7E5 		strb	r1, [r7, #40]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8388              		.loc 1 3025 0
 8389 48fc 0600A0E1 		mov	r0, r6
 8390 4900 80179FE5 		ldr	r1, .L1038+120
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8391              		.loc 1 3021 0
 8392 4904 2920C7E5 		strb	r2, [r7, #41]
3023:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8393              		.loc 1 3023 0
 8394 4908 2A30C7E5 		strb	r3, [r7, #42]
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8395              		.loc 1 3024 0
 8396 490c 2B30C7E5 		strb	r3, [r7, #43]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8397              		.loc 1 3025 0
 8398 4910 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8399              	.LVL999:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8400              		.loc 1 2976 0
 8401 4914 FF20A0E3 		mov	r2, #255
 8402 4918 0230A0E1 		mov	r3, r2
3026:../uvc.c      **** 			  break;
 8403              		.loc 1 3026 0
 8404 491c 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 8405              	.LVL1000:
 8406 4920 B30200EA 		b	.L789
 8407              	.LVL1001:
 8408              	.L703:
2980:../uvc.c      **** 
 8409              		.loc 1 2980 0
 8410 4924 2C479FE5 		ldr	r4, .L1038+72
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8411              		.loc 1 2972 0
 8412 4928 67C6D9E5 		ldrb	ip, [r9, #1639]	@ zero_extendqisi2
 8413              	.LVL1002:
2980:../uvc.c      **** 
 8414              		.loc 1 2980 0
 8415 492c 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2973:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8416              		.loc 1 2973 0
 8417 4930 5836D9E5 		ldrb	r3, [r9, #1624]	@ zero_extendqisi2
 8418              	.LVL1003:
2982:../uvc.c      **** 		 {
 8419              		.loc 1 2982 0
 8420 4934 830055E3 		cmp	r5, #131
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8421              		.loc 1 2975 0
 8422 4938 5A66D9E5 		ldrb	r6, [r9, #1626]	@ zero_extendqisi2
 8423              	.LVL1004:
2982:../uvc.c      **** 		 {
 8424              		.loc 1 2982 0
 8425 493c C604000A 		beq	.L780
 8426 4940 5D01009A 		bls	.L1014
 8427 4944 850055E3 		cmp	r5, #133
 8428 4948 A002000A 		beq	.L785
 8429 494c AA04003A 		bcc	.L786
 8430 4950 860055E3 		cmp	r5, #134
 8431 4954 F802000A 		beq	.L787
 8432 4958 870055E3 		cmp	r5, #135
 8433 495c 4604001A 		bne	.L779
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8434              		.loc 1 3044 0
 8435 4960 ACC69FE5 		ldr	ip, .L1038+4
 8436 4964 6316DCE5 		ldrb	r1, [ip, #1635]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8437              		.loc 1 3045 0
 8438 4968 6426DCE5 		ldrb	r2, [ip, #1636]	@ zero_extendqisi2
 8439 496c E0FFFFEA 		b	.L974
 8440              	.LVL1005:
 8441              	.L695:
 8442              	.LBE214:
 8443              	.LBE213:
 8444              	.LBB225:
 8445              	.LBB226:
2980:../uvc.c      **** 
 8446              		.loc 1 2980 0
 8447 4970 E0469FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8448              		.loc 1 2975 0
 8449 4974 2A66D9E5 		ldrb	r6, [r9, #1578]	@ zero_extendqisi2
 8450              	.LVL1006:
2980:../uvc.c      **** 
 8451              		.loc 1 2980 0
 8452 4978 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8453              	.LVL1007:
2982:../uvc.c      **** 		 {
 8454              		.loc 1 2982 0
 8455 497c 830055E3 		cmp	r5, #131
 8456 4980 B904000A 		beq	.L758
 8457 4984 3901009A 		bls	.L1015
 8458 4988 850055E3 		cmp	r5, #133
 8459 498c F101000A 		beq	.L809
 8460 4990 2404003A 		bcc	.L764
 8461 4994 860055E3 		cmp	r5, #134
 8462 4998 0D03000A 		beq	.L765
 8463 499c 870055E3 		cmp	r5, #135
 8464 49a0 8A04001A 		bne	.L757
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8465              		.loc 1 3044 0
 8466 49a4 68E69FE5 		ldr	lr, .L1038+4
 8467 49a8 3316DEE5 		ldrb	r1, [lr, #1587]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8468              		.loc 1 3045 0
 8469 49ac 3426DEE5 		ldrb	r2, [lr, #1588]	@ zero_extendqisi2
 8470              	.LVL1008:
 8471              	.L976:
 8472              	.LBE226:
 8473              	.LBE225:
 8474              	.LBB234:
 8475              	.LBB235:
3023:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8476              		.loc 1 3023 0
 8477 49b0 0030A0E3 		mov	r3, #0
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8478              		.loc 1 3020 0
 8479 49b4 2810C7E5 		strb	r1, [r7, #40]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8480              		.loc 1 3025 0
 8481 49b8 0600A0E1 		mov	r0, r6
 8482 49bc C4169FE5 		ldr	r1, .L1038+120
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8483              		.loc 1 3021 0
 8484 49c0 2920C7E5 		strb	r2, [r7, #41]
3023:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8485              		.loc 1 3023 0
 8486 49c4 2A30C7E5 		strb	r3, [r7, #42]
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8487              		.loc 1 3024 0
 8488 49c8 2B30C7E5 		strb	r3, [r7, #43]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8489              		.loc 1 3025 0
 8490 49cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8491              	.LVL1009:
3026:../uvc.c      **** 			  break;
 8492              		.loc 1 3026 0
 8493 49d0 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 8494              	.LVL1010:
 8495 49d4 E60100EA 		b	.L813
 8496              	.LVL1011:
 8497              	.L706:
2980:../uvc.c      **** 
 8498              		.loc 1 2980 0
 8499 49d8 78469FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8500              		.loc 1 2975 0
 8501 49dc 8A66D9E5 		ldrb	r6, [r9, #1674]	@ zero_extendqisi2
 8502              	.LVL1012:
2980:../uvc.c      **** 
 8503              		.loc 1 2980 0
 8504 49e0 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8505              	.LVL1013:
2982:../uvc.c      **** 		 {
 8506              		.loc 1 2982 0
 8507 49e4 830055E3 		cmp	r5, #131
 8508 49e8 9304000A 		beq	.L804
 8509 49ec 0D01009A 		bls	.L1016
 8510 49f0 850055E3 		cmp	r5, #133
 8511 49f4 D701000A 		beq	.L809
 8512 49f8 1B04003A 		bcc	.L810
 8513 49fc 860055E3 		cmp	r5, #134
 8514 4a00 F602000A 		beq	.L811
 8515 4a04 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8516              		.loc 1 3044 0
 8517 4a08 9316D905 		ldreqb	r1, [r9, #1683]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8518              		.loc 1 3045 0
 8519 4a0c 9426D905 		ldreqb	r2, [r9, #1684]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8520              		.loc 1 2982 0
 8521 4a10 E6FFFF0A 		beq	.L976
 8522              	.L803:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8523              		.loc 1 3189 0
 8524 4a14 0000A0E3 		mov	r0, #0
 8525 4a18 0020A0E1 		mov	r2, r0
 8526 4a1c 0110A0E3 		mov	r1, #1
 8527 4a20 FEFFFFEB 		bl	CyU3PUsbStall
 8528              	.LVL1014:
3190:../uvc.c      **** 			  break;
 8529              		.loc 1 3190 0
 8530 4a24 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8531 4a28 0400A0E3 		mov	r0, #4
 8532 4a2c 4C169FE5 		ldr	r1, .L1038+112
 8533 4a30 0920A0E3 		mov	r2, #9
 8534 4a34 FEFFFFEB 		bl	CyU3PDebugPrint
 8535              	.LVL1015:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8536              		.loc 1 2976 0
 8537 4a38 FF40A0E3 		mov	r4, #255
 8538 4a3c CC0100EA 		b	.L813
 8539              	.LVL1016:
 8540              	.L996:
 8541              	.LBE235:
 8542              	.LBE234:
 8543              	.LBB244:
 8544              	.LBB245:
2980:../uvc.c      **** 
 8545              		.loc 1 2980 0
 8546 4a40 10469FE5 		ldr	r4, .L1038+72
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8547              		.loc 1 2975 0
 8548 4a44 7266D9E5 		ldrb	r6, [r9, #1650]	@ zero_extendqisi2
 8549              	.LVL1017:
2980:../uvc.c      **** 
 8550              		.loc 1 2980 0
 8551 4a48 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
 8552              	.LVL1018:
2982:../uvc.c      **** 		 {
 8553              		.loc 1 2982 0
 8554 4a4c 830055E3 		cmp	r5, #131
 8555 4a50 7504000A 		beq	.L793
 8556 4a54 5B01009A 		bls	.L1017
 8557 4a58 850055E3 		cmp	r5, #133
 8558 4a5c BD01000A 		beq	.L809
 8559 4a60 2504003A 		bcc	.L799
 8560 4a64 860055E3 		cmp	r5, #134
 8561 4a68 D502000A 		beq	.L800
 8562 4a6c 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8563              		.loc 1 3044 0
 8564 4a70 7B16D905 		ldreqb	r1, [r9, #1659]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8565              		.loc 1 3045 0
 8566 4a74 7C26D905 		ldreqb	r2, [r9, #1660]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8567              		.loc 1 2982 0
 8568 4a78 CCFFFF0A 		beq	.L976
 8569              	.L792:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8570              		.loc 1 3189 0
 8571 4a7c 0000A0E3 		mov	r0, #0
 8572 4a80 0020A0E1 		mov	r2, r0
 8573 4a84 0110A0E3 		mov	r1, #1
 8574 4a88 FEFFFFEB 		bl	CyU3PUsbStall
 8575              	.LVL1019:
3190:../uvc.c      **** 			  break;
 8576              		.loc 1 3190 0
 8577 4a8c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8578 4a90 0400A0E3 		mov	r0, #4
 8579 4a94 E4159FE5 		ldr	r1, .L1038+112
 8580 4a98 0820A0E3 		mov	r2, #8
 8581 4a9c FEFFFFEB 		bl	CyU3PDebugPrint
 8582              	.LVL1020:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8583              		.loc 1 2976 0
 8584 4aa0 FF40A0E3 		mov	r4, #255
 8585              	.LVL1021:
 8586 4aa4 B20100EA 		b	.L813
 8587              	.LVL1022:
 8588              	.L707:
 8589              	.LBE245:
 8590              	.LBE244:
 8591              	.LBB252:
 8592              	.LBB253:
2980:../uvc.c      **** 
 8593              		.loc 1 2980 0
 8594 4aa8 A8459FE5 		ldr	r4, .L1038+72
2972:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8595              		.loc 1 2972 0
 8596 4aac AFC6D9E5 		ldrb	ip, [r9, #1711]	@ zero_extendqisi2
 8597              	.LVL1023:
2980:../uvc.c      **** 
 8598              		.loc 1 2980 0
 8599 4ab0 0050D4E5 		ldrb	r5, [r4]	@ zero_extendqisi2
2973:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8600              		.loc 1 2973 0
 8601 4ab4 A036D9E5 		ldrb	r3, [r9, #1696]	@ zero_extendqisi2
 8602              	.LVL1024:
2982:../uvc.c      **** 		 {
 8603              		.loc 1 2982 0
 8604 4ab8 830055E3 		cmp	r5, #131
2975:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8605              		.loc 1 2975 0
 8606 4abc A266D9E5 		ldrb	r6, [r9, #1698]	@ zero_extendqisi2
 8607              	.LVL1025:
2982:../uvc.c      **** 		 {
 8608              		.loc 1 2982 0
 8609 4ac0 C703000A 		beq	.L815
 8610 4ac4 7201009A 		bls	.L1018
 8611 4ac8 850055E3 		cmp	r5, #133
 8612 4acc DC03000A 		beq	.L820
 8613 4ad0 D803003A 		bcc	.L821
 8614 4ad4 860055E3 		cmp	r5, #134
 8615 4ad8 AF02000A 		beq	.L822
 8616 4adc 870055E3 		cmp	r5, #135
3044:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8617              		.loc 1 3044 0
 8618 4ae0 AB06D905 		ldreqb	r0, [r9, #1707]	@ zero_extendqisi2
3045:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8619              		.loc 1 3045 0
 8620 4ae4 AC16D905 		ldreqb	r1, [r9, #1708]	@ zero_extendqisi2
2982:../uvc.c      **** 		 {
 8621              		.loc 1 2982 0
 8622 4ae8 C103001A 		bne	.L814
 8623              	.L978:
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8624              		.loc 1 3024 0
 8625 4aec 0030A0E3 		mov	r3, #0
3022:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 8626              		.loc 1 3022 0
 8627 4af0 0120A0E3 		mov	r2, #1
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8628              		.loc 1 3020 0
 8629 4af4 2800C7E5 		strb	r0, [r7, #40]
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8630              		.loc 1 3021 0
 8631 4af8 2910C7E5 		strb	r1, [r7, #41]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8632              		.loc 1 3025 0
 8633 4afc 0600A0E1 		mov	r0, r6
 8634 4b00 80159FE5 		ldr	r1, .L1038+120
3024:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8635              		.loc 1 3024 0
 8636 4b04 2B30C7E5 		strb	r3, [r7, #43]
3022:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 8637              		.loc 1 3022 0
 8638 4b08 2A20C7E5 		strb	r2, [r7, #42]
3025:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8639              		.loc 1 3025 0
 8640 4b0c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8641              	.LVL1026:
3026:../uvc.c      **** 			  break;
 8642              		.loc 1 3026 0
 8643 4b10 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 8644              	.LVL1027:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8645              		.loc 1 2976 0
 8646 4b14 FF40A0E3 		mov	r4, #255
 8647 4b18 24408DE5 		str	r4, [sp, #36]
 8648              	.LVL1028:
 8649              	.L824:
3195:../uvc.c      **** }
 8650              		.loc 1 3195 0
 8651 4b1c 08308DE5 		str	r3, [sp, #8]
 8652 4b20 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 8653 4b24 00408DE5 		str	r4, [sp]
 8654 4b28 FF00A0E3 		mov	r0, #255
 8655 4b2c 14608DE5 		str	r6, [sp, #20]
 8656 4b30 0520A0E1 		mov	r2, r5
 8657 4b34 24309DE5 		ldr	r3, [sp, #36]
 8658              	.LVL1029:
 8659 4b38 330200EA 		b	.L986
 8660              	.LVL1030:
 8661              	.L1001:
 8662 4b3c 0060A0E1 		mov	r6, r0
 8663              	.LBE253:
 8664              	.LBE252:
 8665              	.LBE336:
 8666              	.LBE441:
5581:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8667              		.loc 1 5581 0
 8668 4b40 18159FE5 		ldr	r1, .L1038+80
 8669 4b44 0500A0E1 		mov	r0, r5
 8670              	.LVL1031:
 8671 4b48 0620A0E1 		mov	r2, r6
 8672 4b4c FEFFFFEB 		bl	CyU3PDebugPrint
 8673              	.LVL1032:
5582:../uvc.c      **** 					}
 8674              		.loc 1 5582 0
 8675 4b50 0600A0E1 		mov	r0, r6
 8676 4b54 FEFFFFEB 		bl	CyFxAppErrorHandler
 8677              	.LVL1033:
 8678              	.L1007:
 8679              	.LBB442:
 8680              	.LBB368:
 8681              	.LBB356:
 8682              	.LBB348:
1346:../uvc.c      **** 		 {
 8683              		.loc 1 1346 0
 8684 4b58 810056E3 		cmp	r6, #129
 8685 4b5c 7103000A 		beq	.L670
 8686 4b60 4002008A 		bhi	.L671
 8687 4b64 010056E3 		cmp	r6, #1
 8688 4b68 4903001A 		bne	.L667
2536:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8689              		.loc 1 2536 0
 8690 4b6c 2000A0E3 		mov	r0, #32
 8691 4b70 10159FE5 		ldr	r1, .L1038+120
 8692 4b74 42208DE2 		add	r2, sp, #66
 8693 4b78 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8694              	.LVL1034:
2538:../uvc.c      **** 			   {
 8695              		.loc 1 2538 0
 8696 4b7c 000050E3 		cmp	r0, #0
 8697 4b80 34008DE5 		str	r0, [sp, #52]
 8698 4b84 EC05001A 		bne	.L686
2540:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8699              		.loc 1 2540 0
 8700 4b88 020055E3 		cmp	r5, #2
 8701 4b8c C405000A 		beq	.L1019
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8702              		.loc 1 2548 0
 8703 4b90 28C09DE5 		ldr	ip, [sp, #40]
 8704 4b94 08508DE5 		str	r5, [sp, #8]
 8705 4b98 00408DE5 		str	r4, [sp]
 8706 4b9c 04C08DE5 		str	ip, [sp, #4]
2545:../uvc.c      **** 				 }
 8707              		.loc 1 2545 0
 8708 4ba0 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8709              		.loc 1 2548 0
 8710 4ba4 0400A0E3 		mov	r0, #4
 8711              	.LVL1035:
 8712 4ba8 C8149FE5 		ldr	r1, .L1038+104
 8713 4bac 0E20A0E3 		mov	r2, #14
 8714 4bb0 2C309DE5 		ldr	r3, [sp, #44]
 8715 4bb4 38508DE5 		str	r5, [sp, #56]
2545:../uvc.c      **** 				 }
 8716              		.loc 1 2545 0
 8717 4bb8 24C08DE5 		str	ip, [sp, #36]
2544:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8718              		.loc 1 2544 0
 8719 4bbc 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 8720              	.LVL1036:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8721              		.loc 1 2548 0
 8722 4bc0 FEFFFFEB 		bl	CyU3PDebugPrint
 8723              	.LVL1037:
2923:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 8724              		.loc 1 2923 0
 8725 4bc4 38C09DE5 		ldr	ip, [sp, #56]
 8726 4bc8 04005CE3 		cmp	ip, #4
 8727 4bcc 4105000A 		beq	.L1020
 8728              	.LVL1038:
 8729              	.L691:
2940:../uvc.c      **** 			 	 			 break;
 8730              		.loc 1 2940 0
 8731 4bd0 3E27D9E5 		ldrb	r2, [r9, #1854]	@ zero_extendqisi2
2939:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8732              		.loc 1 2939 0
 8733 4bd4 38C09DE5 		ldr	ip, [sp, #56]
2940:../uvc.c      **** 			 	 			 break;
 8734              		.loc 1 2940 0
 8735 4bd8 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
2939:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8736              		.loc 1 2939 0
 8737 4bdc 0400A0E3 		mov	r0, #4
 8738 4be0 0C108DE8 		stmia	sp, {r2, r3, ip}
 8739 4be4 90149FE5 		ldr	r1, .L1038+108
 8740 4be8 0520A0E1 		mov	r2, r5
 8741 4bec 24309DE5 		ldr	r3, [sp, #36]
 8742 4bf0 FEFFFFEB 		bl	CyU3PDebugPrint
 8743              	.LVL1039:
 8744 4bf4 24209DE5 		ldr	r2, [sp, #36]
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8745              		.loc 1 1334 0
 8746 4bf8 FF40A0E3 		mov	r4, #255
 8747 4bfc 04C0A0E1 		mov	ip, r4
 8748              	.LVL1040:
 8749              	.L677:
2956:../uvc.c      **** }
 8750              		.loc 1 2956 0
 8751 4c00 04108DE8 		stmia	sp, {r2, ip}
 8752 4c04 60149FE5 		ldr	r1, .L1038+92
 8753 4c08 0530A0E1 		mov	r3, r5
 8754 4c0c 08408DE5 		str	r4, [sp, #8]
 8755 4c10 0620A0E1 		mov	r2, r6
 8756 4c14 0400A0E3 		mov	r0, #4
 8757 4c18 FEFFFFEB 		bl	CyU3PDebugPrint
 8758              	.LVL1041:
 8759 4c1c 44309DE5 		ldr	r3, [sp, #68]
 8760 4c20 47FDFFEA 		b	.L646
 8761              	.LVL1042:
 8762              	.L1010:
 8763              	.LBE348:
 8764              	.LBE356:
 8765              	.LBE368:
 8766              	.LBE442:
 8767              	.LBB443:
 8768              	.LBB337:
 8769              	.LBB262:
 8770              	.LBB180:
2982:../uvc.c      **** 		 {
 8771              		.loc 1 2982 0
 8772 4c24 810055E3 		cmp	r5, #129
 8773 4c28 BE03000A 		beq	.L723
 8774 4c2c 1B02008A 		bhi	.L724
 8775 4c30 010055E3 		cmp	r5, #1
 8776 4c34 1404001A 		bne	.L720
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8777              		.loc 1 3053 0
 8778 4c38 48149FE5 		ldr	r1, .L1038+120
 8779 4c3c 42208DE2 		add	r2, sp, #66
 8780 4c40 2000A0E3 		mov	r0, #32
 8781 4c44 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8782              	.LVL1043:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8783              		.loc 1 3183 0
 8784 4c48 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8785 4c4c C0E39FE5 		ldr	lr, .L1038+4
3184:../uvc.c      **** 			  		 break;
 8786              		.loc 1 3184 0
 8787 4c50 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8788 4c54 0400A0E3 		mov	r0, #4
 8789 4c58 D8139FE5 		ldr	r1, .L1038+40
 8790 4c5c 0220A0E3 		mov	r2, #2
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8791              		.loc 1 3183 0
 8792 4c60 EDC5CEE5 		strb	ip, [lr, #1517]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8793              		.loc 1 2976 0
 8794 4c64 FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 8795              		.loc 1 3184 0
 8796 4c68 FEFFFFEB 		bl	CyU3PDebugPrint
 8797              	.LVL1044:
 8798 4c6c 400100EA 		b	.L813
 8799              	.LVL1045:
 8800              	.L1012:
 8801              	.LBE180:
 8802              	.LBE262:
 8803              	.LBB263:
 8804              	.LBB197:
2982:../uvc.c      **** 		 {
 8805              		.loc 1 2982 0
 8806 4c70 810055E3 		cmp	r5, #129
 8807 4c74 C103000A 		beq	.L712
 8808 4c78 1602008A 		bhi	.L713
 8809 4c7c 010055E3 		cmp	r5, #1
 8810 4c80 FEFEFF1A 		bne	.L709
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8811              		.loc 1 3053 0
 8812 4c84 FC139FE5 		ldr	r1, .L1038+120
 8813 4c88 42208DE2 		add	r2, sp, #66
 8814 4c8c 2000A0E3 		mov	r0, #32
 8815 4c90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8816              	.LVL1046:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8817              		.loc 1 3183 0
 8818 4c94 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 8819              		.loc 1 3184 0
 8820 4c98 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8821 4c9c 0400A0E3 		mov	r0, #4
 8822 4ca0 90139FE5 		ldr	r1, .L1038+40
 8823 4ca4 0020A0E3 		mov	r2, #0
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8824              		.loc 1 3183 0
 8825 4ca8 BDC5C9E5 		strb	ip, [r9, #1469]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8826              		.loc 1 2976 0
 8827 4cac FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 8828              		.loc 1 3184 0
 8829 4cb0 FEFFFFEB 		bl	CyU3PDebugPrint
 8830              	.LVL1047:
 8831 4cb4 2E0100EA 		b	.L813
 8832              	.LVL1048:
 8833              	.L1013:
 8834              	.LBE197:
 8835              	.LBE263:
 8836              	.LBB264:
 8837              	.LBB205:
2982:../uvc.c      **** 		 {
 8838              		.loc 1 2982 0
 8839 4cb8 810055E3 		cmp	r5, #129
 8840 4cbc 9D03000A 		beq	.L734
 8841 4cc0 FD01008A 		bhi	.L735
 8842 4cc4 010055E3 		cmp	r5, #1
 8843 4cc8 7803001A 		bne	.L731
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8844              		.loc 1 3053 0
 8845 4ccc 42208DE2 		add	r2, sp, #66
 8846 4cd0 2000A0E3 		mov	r0, #32
 8847 4cd4 AC139FE5 		ldr	r1, .L1038+120
 8848 4cd8 1C308DE5 		str	r3, [sp, #28]
 8849 4cdc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8850              	.LVL1049:
3111:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8851              		.loc 1 3111 0
 8852 4ce0 D525D9E5 		ldrb	r2, [r9, #1493]	@ zero_extendqisi2
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 8853              		.loc 1 3055 0
 8854 4ce4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3056:../uvc.c      **** 			  value = Data1;
 8855              		.loc 1 3056 0
 8856 4ce8 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
3111:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8857              		.loc 1 3111 0
 8858 4cec 010052E3 		cmp	r2, #1
 8859 4cf0 04005213 		cmpne	r2, #4
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 8860              		.loc 1 3055 0
 8861 4cf4 30C08DE5 		str	ip, [sp, #48]
 8862              	.LVL1050:
3056:../uvc.c      **** 			  value = Data1;
 8863              		.loc 1 3056 0
 8864 4cf8 28408DE5 		str	r4, [sp, #40]
 8865              	.LVL1051:
3111:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 8866              		.loc 1 3111 0
 8867 4cfc 1C309DE5 		ldr	r3, [sp, #28]
 8868 4d00 6C02001A 		bne	.L742
3110:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 8869              		.loc 1 3110 0
 8870 4d04 04E48CE1 		orr	lr, ip, r4, asl #8
3112:../uvc.c      **** 					  {
 8871              		.loc 1 3112 0
 8872 4d08 F9005EE3 		cmp	lr, #249
 8873 4d0c 6902008A 		bhi	.L742
 8874 4d10 24C39FE5 		ldr	ip, .L1038+44
 8875 4d14 0020A0E3 		mov	r2, #0
 8876 4d18 0100A0E3 		mov	r0, #1
 8877 4d1c 38308DE5 		str	r3, [sp, #56]
 8878              	.LVL1052:
 8879              	.L744:
3116:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 8880              		.loc 1 3116 0
 8881 4d20 18139FE5 		ldr	r1, .L1038+48
 8882 4d24 8230A0E1 		mov	r3, r2, asl #1
 8883 4d28 B33091E1 		ldrh	r3, [r1, r3]
 8884 4d2c FF4002E2 		and	r4, r2, #255
 8885 4d30 03005EE1 		cmp	lr, r3
3119:../uvc.c      **** 							}
 8886              		.loc 1 3119 0
 8887 4d34 03106EE0 		rsb	r1, lr, r3
 8888 4d38 2C408DE5 		str	r4, [sp, #44]
3117:../uvc.c      **** 							}else{
 8889              		.loc 1 3117 0
 8890 4d3c 0E4063E0 		rsb	r4, r3, lr
 8891 4d40 0438A081 		movhi	r3, r4, asl #16
 8892 4d44 0138A091 		movls	r3, r1, asl #16
 8893 4d48 2C409DE5 		ldr	r4, [sp, #44]
 8894 4d4c 2338A0E1 		mov	r3, r3, lsr #16
 8895 4d50 0C0053E1 		cmp	r3, ip
 8896 4d54 012082E2 		add	r2, r2, #1
 8897 4d58 0400A031 		movcc	r0, r4
 8898              	.LVL1053:
 8899 4d5c 0C0053E1 		cmp	r3, ip
 8900 4d60 03C0A031 		movcc	ip, r3
 8901              	.LVL1054:
3114:../uvc.c      **** 						  {
 8902              		.loc 1 3114 0
 8903 4d64 080052E3 		cmp	r2, #8
 8904 4d68 ECFFFF1A 		bne	.L744
3129:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8905              		.loc 1 3129 0
 8906 4d6c D0429FE5 		ldr	r4, .L1038+52
 8907 4d70 38309DE5 		ldr	r3, [sp, #56]
3126:../uvc.c      **** 
 8908              		.loc 1 3126 0
 8909 4d74 012080E2 		add	r2, r0, #1
 8910 4d78 FF2002E2 		and	r2, r2, #255
3129:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8911              		.loc 1 3129 0
 8912 4d7c 1C0094E5 		ldr	r0, [r4, #28]
 8913              	.LVL1055:
 8914 4d80 0010E0E3 		mvn	r1, #0
3126:../uvc.c      **** 
 8915              		.loc 1 3126 0
 8916 4d84 2C208DE5 		str	r2, [sp, #44]
 8917              	.LVL1056:
3129:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 8918              		.loc 1 3129 0
 8919 4d88 1C308DE5 		str	r3, [sp, #28]
 8920 4d8c FEFFFFEB 		bl	_txe_mutex_get
 8921              	.LVL1057:
3130:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8922              		.loc 1 3130 0
 8923 4d90 2CC09DE5 		ldr	ip, [sp, #44]
 8924 4d94 0010A0E3 		mov	r1, #0
 8925 4d98 00C08DE5 		str	ip, [sp]
 8926 4d9c 1C309DE5 		ldr	r3, [sp, #28]
 8927 4da0 24209DE5 		ldr	r2, [sp, #36]
 8928 4da4 0400A0E1 		mov	r0, r4
 8929 4da8 04108DE5 		str	r1, [sp, #4]
 8930 4dac 0310A0E3 		mov	r1, #3
 8931 4db0 FEFFFFEB 		bl	cmdSet
 8932              	.LVL1058:
3131:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 8933              		.loc 1 3131 0
 8934 4db4 1C0094E5 		ldr	r0, [r4, #28]
 8935 4db8 FEFFFFEB 		bl	_txe_mutex_put
 8936              	.LVL1059:
3137:../uvc.c      **** 					  }else{
 8937              		.loc 1 3137 0
 8938 4dbc 2C409DE5 		ldr	r4, [sp, #44]
3134:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 8939              		.loc 1 3134 0
 8940 4dc0 30C09DE5 		ldr	ip, [sp, #48]
3137:../uvc.c      **** 					  }else{
 8941              		.loc 1 3137 0
 8942 4dc4 7943C9E5 		strb	r4, [r9, #889]
3135:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 8943              		.loc 1 3135 0
 8944 4dc8 28409DE5 		ldr	r4, [sp, #40]
3136:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 8945              		.loc 1 3136 0
 8946 4dcc 0130A0E3 		mov	r3, #1
3134:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 8947              		.loc 1 3134 0
 8948 4dd0 05C6C9E5 		strb	ip, [r9, #1541]
3135:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 8949              		.loc 1 3135 0
 8950 4dd4 0646C9E5 		strb	r4, [r9, #1542]
3136:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 8951              		.loc 1 3136 0
 8952 4dd8 0836C9E5 		strb	r3, [r9, #1544]
 8953 4ddc 630000EA 		b	.L791
 8954              	.LVL1060:
 8955              	.L1006:
 8956              	.LBE205:
 8957              	.LBE264:
 8958              	.LBB265:
 8959              	.LBB172:
2982:../uvc.c      **** 		 {
 8960              		.loc 1 2982 0
 8961 4de0 810055E3 		cmp	r5, #129
 8962 4de4 6103000A 		beq	.L749
 8963 4de8 B701008A 		bhi	.L750
 8964 4dec 010055E3 		cmp	r5, #1
 8965 4df0 DAFDFF1A 		bne	.L746
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8966              		.loc 1 3053 0
 8967 4df4 8C129FE5 		ldr	r1, .L1038+120
 8968 4df8 42208DE2 		add	r2, sp, #66
 8969 4dfc 2000A0E3 		mov	r0, #32
 8970 4e00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8971              	.LVL1061:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8972              		.loc 1 3183 0
 8973 4e04 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 8974              		.loc 1 3184 0
 8975 4e08 0400A0E3 		mov	r0, #4
 8976 4e0c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 8977 4e10 0020A0E1 		mov	r2, r0
 8978 4e14 1C129FE5 		ldr	r1, .L1038+40
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8979              		.loc 1 3183 0
 8980 4e18 1DC6C9E5 		strb	ip, [r9, #1565]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8981              		.loc 1 2976 0
 8982 4e1c FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 8983              		.loc 1 3184 0
 8984 4e20 FEFFFFEB 		bl	CyU3PDebugPrint
 8985              	.LVL1062:
 8986 4e24 D20000EA 		b	.L813
 8987              	.LVL1063:
 8988              	.L1016:
 8989              	.LBE172:
 8990              	.LBE265:
 8991              	.LBB266:
 8992              	.LBB236:
2982:../uvc.c      **** 		 {
 8993              		.loc 1 2982 0
 8994 4e28 810055E3 		cmp	r5, #129
 8995 4e2c E002000A 		beq	.L806
 8996 4e30 CC01008A 		bhi	.L807
 8997 4e34 010055E3 		cmp	r5, #1
 8998 4e38 F5FEFF1A 		bne	.L803
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8999              		.loc 1 3053 0
 9000 4e3c 44129FE5 		ldr	r1, .L1038+120
 9001 4e40 42208DE2 		add	r2, sp, #66
 9002 4e44 2000A0E3 		mov	r0, #32
 9003 4e48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9004              	.LVL1064:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9005              		.loc 1 3183 0
 9006 4e4c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 9007              		.loc 1 3184 0
 9008 4e50 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9009 4e54 0400A0E3 		mov	r0, #4
 9010 4e58 D8119FE5 		ldr	r1, .L1038+40
 9011 4e5c 0920A0E3 		mov	r2, #9
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9012              		.loc 1 3183 0
 9013 4e60 95C6C9E5 		strb	ip, [r9, #1685]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9014              		.loc 1 2976 0
 9015 4e64 FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 9016              		.loc 1 3184 0
 9017 4e68 FEFFFFEB 		bl	CyU3PDebugPrint
 9018              	.LVL1065:
 9019 4e6c C00000EA 		b	.L813
 9020              	.LVL1066:
 9021              	.L1015:
 9022              	.LBE236:
 9023              	.LBE266:
 9024              	.LBB267:
 9025              	.LBB227:
2982:../uvc.c      **** 		 {
 9026              		.loc 1 2982 0
 9027 4e70 810055E3 		cmp	r5, #129
 9028 4e74 4903000A 		beq	.L760
 9029 4e78 BE01008A 		bhi	.L761
 9030 4e7c 010055E3 		cmp	r5, #1
 9031 4e80 5203001A 		bne	.L757
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9032              		.loc 1 3053 0
 9033 4e84 FC119FE5 		ldr	r1, .L1038+120
 9034 4e88 42208DE2 		add	r2, sp, #66
 9035 4e8c 2000A0E3 		mov	r0, #32
 9036 4e90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9037              	.LVL1067:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9038              		.loc 1 3183 0
 9039 4e94 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 9040              		.loc 1 3184 0
 9041 4e98 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9042              		.loc 1 3183 0
 9043 4e9c 70419FE5 		ldr	r4, .L1038+4
3184:../uvc.c      **** 			  		 break;
 9044              		.loc 1 3184 0
 9045 4ea0 0400A0E3 		mov	r0, #4
 9046 4ea4 8C119FE5 		ldr	r1, .L1038+40
 9047 4ea8 0520A0E3 		mov	r2, #5
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9048              		.loc 1 3183 0
 9049 4eac 35C6C4E5 		strb	ip, [r4, #1589]
3184:../uvc.c      **** 			  		 break;
 9050              		.loc 1 3184 0
 9051 4eb0 FEFFFFEB 		bl	CyU3PDebugPrint
 9052              	.LVL1068:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9053              		.loc 1 2976 0
 9054 4eb4 FF40A0E3 		mov	r4, #255
 9055 4eb8 AD0000EA 		b	.L813
 9056              	.LVL1069:
 9057              	.L1014:
 9058              	.LBE227:
 9059              	.LBE267:
 9060              	.LBB268:
 9061              	.LBB215:
2982:../uvc.c      **** 		 {
 9062              		.loc 1 2982 0
 9063 4ebc 810055E3 		cmp	r5, #129
 9064 4ec0 3A03000A 		beq	.L782
 9065 4ec4 A301008A 		bhi	.L783
 9066 4ec8 010055E3 		cmp	r5, #1
 9067 4ecc EA02001A 		bne	.L779
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9068              		.loc 1 3053 0
 9069 4ed0 2000A0E3 		mov	r0, #32
 9070 4ed4 AC119FE5 		ldr	r1, .L1038+120
 9071 4ed8 42208DE2 		add	r2, sp, #66
 9072 4edc 1C308DE5 		str	r3, [sp, #28]
 9073 4ee0 20C08DE5 		str	ip, [sp, #32]
 9074 4ee4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9075              	.LVL1070:
3145:../uvc.c      **** 					  {
 9076              		.loc 1 3145 0
 9077 4ee8 24E19FE5 		ldr	lr, .L1038+4
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9078              		.loc 1 3055 0
 9079 4eec 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
3145:../uvc.c      **** 					  {
 9080              		.loc 1 3145 0
 9081 4ef0 D505DEE5 		ldrb	r0, [lr, #1493]	@ zero_extendqisi2
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9082              		.loc 1 3055 0
 9083 4ef4 24408DE5 		str	r4, [sp, #36]
 9084              	.LVL1071:
3056:../uvc.c      **** 			  value = Data1;
 9085              		.loc 1 3056 0
 9086 4ef8 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
3145:../uvc.c      **** 					  {
 9087              		.loc 1 3145 0
 9088 4efc 010050E3 		cmp	r0, #1
 9089 4f00 08005013 		cmpne	r0, #8
 9090 4f04 0000A013 		movne	r0, #0
 9091 4f08 0100A003 		moveq	r0, #1
3056:../uvc.c      **** 			  value = Data1;
 9092              		.loc 1 3056 0
 9093 4f0c 30408DE5 		str	r4, [sp, #48]
 9094              	.LVL1072:
3145:../uvc.c      **** 					  {
 9095              		.loc 1 3145 0
 9096 4f10 A603001A 		bne	.L790
 9097              	.LVL1073:
3148:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9098              		.loc 1 3148 0
 9099 4f14 28419FE5 		ldr	r4, .L1038+52
 9100 4f18 0010E0E3 		mvn	r1, #0
 9101 4f1c 1C0094E5 		ldr	r0, [r4, #28]
 9102 4f20 FEFFFFEB 		bl	_txe_mutex_get
 9103              	.LVL1074:
3149:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9104              		.loc 1 3149 0
 9105 4f24 20C09DE5 		ldr	ip, [sp, #32]
 9106 4f28 24E09DE5 		ldr	lr, [sp, #36]
 9107 4f2c 1C309DE5 		ldr	r3, [sp, #28]
 9108 4f30 0010A0E3 		mov	r1, #0
 9109 4f34 0320A0E1 		mov	r2, r3
 9110 4f38 00E08DE5 		str	lr, [sp]
 9111 4f3c 0C30A0E1 		mov	r3, ip
 9112 4f40 0400A0E1 		mov	r0, r4
 9113 4f44 04108DE5 		str	r1, [sp, #4]
 9114 4f48 2210A0E3 		mov	r1, #34
 9115 4f4c FEFFFFEB 		bl	cmdSet
 9116              	.LVL1075:
3150:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9117              		.loc 1 3150 0
 9118 4f50 1C0094E5 		ldr	r0, [r4, #28]
 9119 4f54 FEFFFFEB 		bl	_txe_mutex_put
 9120              	.LVL1076:
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9121              		.loc 1 3153 0
 9122 4f58 B4C09FE5 		ldr	ip, .L1038+4
 9123 4f5c 24409DE5 		ldr	r4, [sp, #36]
3155:../uvc.c      **** 					  }else{
 9124              		.loc 1 3155 0
 9125 4f60 6856CCE5 		strb	r5, [ip, #1640]
3153:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9126              		.loc 1 3153 0
 9127 4f64 6546CCE5 		strb	r4, [ip, #1637]
3154:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9128              		.loc 1 3154 0
 9129 4f68 30409DE5 		ldr	r4, [sp, #48]
 9130 4f6c 6646CCE5 		strb	r4, [ip, #1638]
 9131              	.LVL1077:
 9132              	.L791:
3159:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9133              		.loc 1 3159 0
 9134 4f70 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9135              	.LVL1078:
3160:../uvc.c      **** 
 9136              		.loc 1 3160 0
 9137 4f74 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 9138              	.LVL1079:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9139              		.loc 1 2976 0
 9140 4f78 FF40A0E3 		mov	r4, #255
 9141 4f7c 1C0100EA 		b	.L789
 9142              	.LVL1080:
 9143              	.L1011:
 9144              	.LBE215:
 9145              	.LBE268:
 9146              	.LBB269:
 9147              	.LBB189:
2982:../uvc.c      **** 		 {
 9148              		.loc 1 2982 0
 9149 4f80 810055E3 		cmp	r5, #129
 9150 4f84 0103000A 		beq	.L771
 9151 4f88 6E01008A 		bhi	.L772
 9152 4f8c 010055E3 		cmp	r5, #1
 9153 4f90 20FEFF1A 		bne	.L768
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9154              		.loc 1 3053 0
 9155 4f94 EC109FE5 		ldr	r1, .L1038+120
 9156 4f98 42208DE2 		add	r2, sp, #66
 9157 4f9c 2000A0E3 		mov	r0, #32
 9158 4fa0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9159              	.LVL1081:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9160              		.loc 1 3183 0
 9161 4fa4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 9162              		.loc 1 3184 0
 9163 4fa8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9164 4fac 0400A0E3 		mov	r0, #4
 9165 4fb0 80109FE5 		ldr	r1, .L1038+40
 9166 4fb4 0620A0E3 		mov	r2, #6
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9167              		.loc 1 3183 0
 9168 4fb8 4DC6C9E5 		strb	ip, [r9, #1613]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9169              		.loc 1 2976 0
 9170 4fbc FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 9171              		.loc 1 3184 0
 9172 4fc0 FEFFFFEB 		bl	CyU3PDebugPrint
 9173              	.LVL1082:
 9174 4fc4 6A0000EA 		b	.L813
 9175              	.LVL1083:
 9176              	.L1017:
 9177              	.LBE189:
 9178              	.LBE269:
 9179              	.LBB270:
 9180              	.LBB246:
2982:../uvc.c      **** 		 {
 9181              		.loc 1 2982 0
 9182 4fc8 810055E3 		cmp	r5, #129
 9183 4fcc C402000A 		beq	.L795
 9184 4fd0 6C01008A 		bhi	.L796
 9185 4fd4 010055E3 		cmp	r5, #1
 9186 4fd8 A7FEFF1A 		bne	.L792
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9187              		.loc 1 3053 0
 9188 4fdc A4109FE5 		ldr	r1, .L1038+120
 9189 4fe0 42208DE2 		add	r2, sp, #66
 9190 4fe4 2000A0E3 		mov	r0, #32
 9191 4fe8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9192              	.LVL1084:
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9193              		.loc 1 3183 0
 9194 4fec 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
3184:../uvc.c      **** 			  		 break;
 9195              		.loc 1 3184 0
 9196 4ff0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9197 4ff4 0400A0E3 		mov	r0, #4
 9198 4ff8 38109FE5 		ldr	r1, .L1038+40
 9199 4ffc 0820A0E3 		mov	r2, #8
3183:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9200              		.loc 1 3183 0
 9201 5000 7DC6C9E5 		strb	ip, [r9, #1661]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9202              		.loc 1 2976 0
 9203 5004 FF40A0E3 		mov	r4, #255
3184:../uvc.c      **** 			  		 break;
 9204              		.loc 1 3184 0
 9205 5008 FEFFFFEB 		bl	CyU3PDebugPrint
 9206              	.LVL1085:
 9207 500c 580000EA 		b	.L813
 9208              	.L1039:
 9209              		.align	2
 9210              	.L1038:
 9211 5010 00000000 		.word	.LANCHOR0
 9212 5014 00000000 		.word	.LANCHOR1
 9213 5018 00000000 		.word	glInterStaBuffer
 9214 501c 00000000 		.word	wIndex
 9215 5020 940C0000 		.word	.LC70
 9216 5024 00000000 		.word	bmReqType
 9217 5028 00000000 		.word	wLength
 9218 502c 180C0000 		.word	.LC69
 9219 5030 00000000 		.word	glChHandleInterStat
 9220 5034 480D0000 		.word	.LC75
 9221 5038 8C060000 		.word	.LC37
 9222 503c FFFF0000 		.word	65535
 9223 5040 98010000 		.word	.LANCHOR2+408
 9224 5044 00000000 		.word	cmdQu
 9225 5048 64060000 		.word	.LC36
 9226 504c C00C0000 		.word	.LC71
 9227 5050 980D0000 		.word	.LC77
 9228 5054 700D0000 		.word	.LC76
 9229 5058 00000000 		.word	bRequest
 9230 505c E00C0000 		.word	.LC72
 9231 5060 B80D0000 		.word	.LC78
 9232 5064 D4060000 		.word	.LC39
 9233 5068 000D0000 		.word	.LC73
 9234 506c 14060000 		.word	.LC35
 9235 5070 00000000 		.word	wValue
 9236 5074 240D0000 		.word	.LC74
 9237 5078 68040000 		.word	.LC27
 9238 507c 4C050000 		.word	.LC31
 9239 5080 B0060000 		.word	.LC38
 9240 5084 00000000 		.word	.LANCHOR1
 9241 5088 28000000 		.word	.LANCHOR0+40
 9242 508c 38040000 		.word	.LC26
 9243 5090 E4050000 		.word	.LC34
 9244              	.LVL1086:
 9245              	.L1018:
 9246              	.LBE246:
 9247              	.LBE270:
 9248              	.LBB271:
 9249              	.LBB254:
2982:../uvc.c      **** 		 {
 9250              		.loc 1 2982 0
 9251 5094 810055E3 		cmp	r5, #129
 9252 5098 3502000A 		beq	.L817
 9253 509c 0301008A 		bhi	.L818
 9254 50a0 010055E3 		cmp	r5, #1
 9255 50a4 5202001A 		bne	.L814
3168:../uvc.c      **** 					  if(getData == 1)
 9256              		.loc 1 3168 0
 9257 50a8 6C401FE5 		ldr	r4, .L1038+52
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9258              		.loc 1 3053 0
 9259 50ac 2C101FE5 		ldr	r1, .L1038+120
 9260 50b0 42208DE2 		add	r2, sp, #66
 9261 50b4 2000A0E3 		mov	r0, #32
 9262 50b8 1C308DE5 		str	r3, [sp, #28]
 9263 50bc 20C08DE5 		str	ip, [sp, #32]
3168:../uvc.c      **** 					  if(getData == 1)
 9264              		.loc 1 3168 0
 9265 50c0 30408DE5 		str	r4, [sp, #48]
3053:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9266              		.loc 1 3053 0
 9267 50c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9268              	.LVL1087:
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9269              		.loc 1 3055 0
 9270 50c8 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
3168:../uvc.c      **** 					  if(getData == 1)
 9271              		.loc 1 3168 0
 9272 50cc 0010E0E3 		mvn	r1, #0
3055:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9273              		.loc 1 3055 0
 9274 50d0 24408DE5 		str	r4, [sp, #36]
 9275              	.LVL1088:
3168:../uvc.c      **** 					  if(getData == 1)
 9276              		.loc 1 3168 0
 9277 50d4 30409DE5 		ldr	r4, [sp, #48]
 9278 50d8 1C0094E5 		ldr	r0, [r4, #28]
3056:../uvc.c      **** 			  value = Data1;
 9279              		.loc 1 3056 0
 9280 50dc 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 9281              	.LVL1089:
3168:../uvc.c      **** 					  if(getData == 1)
 9282              		.loc 1 3168 0
 9283 50e0 FEFFFFEB 		bl	_txe_mutex_get
 9284              	.LVL1090:
3169:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 9285              		.loc 1 3169 0
 9286 50e4 24E09DE5 		ldr	lr, [sp, #36]
 9287 50e8 1C309DE5 		ldr	r3, [sp, #28]
 9288 50ec 01005EE3 		cmp	lr, #1
 9289 50f0 20C09DE5 		ldr	ip, [sp, #32]
3170:../uvc.c      **** 					  else if(getData == 0xff)
 9290              		.loc 1 3170 0
 9291 50f4 0410A003 		moveq	r1, #4
3169:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 9292              		.loc 1 3169 0
 9293 50f8 ED03000A 		beq	.L977
3171:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 9294              		.loc 1 3171 0
 9295 50fc 24109DE5 		ldr	r1, [sp, #36]
 9296 5100 FF0051E3 		cmp	r1, #255
 9297 5104 E903000A 		beq	.L1021
3174:../uvc.c      **** 					  //dataIdx++;
 9298              		.loc 1 3174 0
 9299 5108 0010A0E3 		mov	r1, #0
 9300 510c 0320A0E1 		mov	r2, r3
 9301 5110 00108DE5 		str	r1, [sp]
 9302 5114 04108DE5 		str	r1, [sp, #4]
 9303 5118 0C30A0E1 		mov	r3, ip
 9304 511c 30009DE5 		ldr	r0, [sp, #48]
 9305 5120 2310A0E3 		mov	r1, #35
 9306 5124 FEFFFFEB 		bl	cmdSet
 9307              	.LVL1091:
 9308              	.L826:
3177:../uvc.c      **** #endif
 9309              		.loc 1 3177 0
 9310 5128 30C09DE5 		ldr	ip, [sp, #48]
 9311 512c 1C009CE5 		ldr	r0, [ip, #28]
 9312 5130 FEFFFFEB 		bl	_txe_mutex_put
 9313              	.LVL1092:
3179:../uvc.c      **** 					  break;
 9314              		.loc 1 3179 0
 9315 5134 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 9316 5138 0400A0E3 		mov	r0, #4
 9317 513c 00308DE5 		str	r3, [sp]
 9318 5140 00111FE5 		ldr	r1, .L1038+56
 9319 5144 0430A0E1 		mov	r3, r4
 9320 5148 24209DE5 		ldr	r2, [sp, #36]
 9321 514c FEFFFFEB 		bl	CyU3PDebugPrint
 9322              	.LVL1093:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9323              		.loc 1 2976 0
 9324 5150 FF30A0E3 		mov	r3, #255
 9325 5154 70FEFFEA 		b	.L824
 9326              	.LVL1094:
 9327              	.L809:
 9328              	.LBE254:
 9329              	.LBE271:
 9330              	.LBB272:
 9331              	.LBB237:
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9332              		.loc 1 2987 0
 9333 5158 0030A0E3 		mov	r3, #0
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9334              		.loc 1 2988 0
 9335 515c 0200A0E3 		mov	r0, #2
 9336 5160 E0101FE5 		ldr	r1, .L1038+120
2986:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9337              		.loc 1 2986 0
 9338 5164 2860C7E5 		strb	r6, [r7, #40]
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9339              		.loc 1 2987 0
 9340 5168 2930C7E5 		strb	r3, [r7, #41]
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9341              		.loc 1 2988 0
 9342 516c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9343              	.LVL1095:
2989:../uvc.c      **** 			  break;
 9344              		.loc 1 2989 0
 9345 5170 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9346              	.LVL1096:
 9347              	.L813:
3195:../uvc.c      **** }
 9348              		.loc 1 3195 0
 9349 5174 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9350 5178 FF30A0E3 		mov	r3, #255
 9351 517c 04108DE5 		str	r1, [sp, #4]
 9352 5180 10108DE5 		str	r1, [sp, #16]
 9353 5184 00308DE5 		str	r3, [sp]
 9354 5188 0C308DE5 		str	r3, [sp, #12]
 9355 518c 08408DE5 		str	r4, [sp, #8]
 9356 5190 14608DE5 		str	r6, [sp, #20]
 9357 5194 0520A0E1 		mov	r2, r5
 9358 5198 0400A0E3 		mov	r0, #4
 9359 519c 40111FE5 		ldr	r1, .L1038+84
 9360 51a0 FEFFFFEB 		bl	CyU3PDebugPrint
 9361              	.LVL1097:
 9362 51a4 44309DE5 		ldr	r3, [sp, #68]
 9363 51a8 E5FBFFEA 		b	.L646
 9364              	.LVL1098:
 9365              	.L849:
 9366              	.LBE237:
 9367              	.LBE272:
 9368              	.LBE337:
 9369              	.LBE443:
 9370              	.LBB444:
 9371              	.LBB422:
4983:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
 9372              		.loc 1 4983 0
 9373 51ac 2700A0E3 		mov	r0, #39
 9374 51b0 FEFFFFEB 		bl	ControlHandle
 9375              	.LVL1099:
4984:../uvc.c      ****     		break;
 9376              		.loc 1 4984 0
 9377 51b4 64311FE5 		ldr	r3, .L1038+72
 9378 51b8 B020D4E1 		ldrh	r2, [r4]
 9379 51bc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9380 51c0 0400A0E3 		mov	r0, #4
 9381 51c4 80111FE5 		ldr	r1, .L1038+60
 9382 51c8 FEFFFFEB 		bl	CyU3PDebugPrint
 9383              	.LVL1100:
 9384 51cc 44309DE5 		ldr	r3, [sp, #68]
 9385 51d0 DBFBFFEA 		b	.L646
 9386              	.L847:
 9387              	.LVL1101:
4949:../uvc.c      ****     		break;
 9388              		.loc 1 4949 0
 9389 51d4 1B00A0E3 		mov	r0, #27
 9390 51d8 FEFFFFEB 		bl	ControlHandle
 9391              	.LVL1102:
 9392 51dc 44309DE5 		ldr	r3, [sp, #68]
 9393 51e0 D7FBFFEA 		b	.L646
 9394              	.L862:
5013:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9395              		.loc 1 5013 0
 9396 51e4 2E00A0E3 		mov	r0, #46
 9397 51e8 FEFFFFEB 		bl	ControlHandle
 9398              	.LVL1103:
5014:../uvc.c      ****     		break;
 9399              		.loc 1 5014 0
 9400 51ec 9C311FE5 		ldr	r3, .L1038+72
 9401 51f0 B020D4E1 		ldrh	r2, [r4]
 9402 51f4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9403 51f8 0400A0E3 		mov	r0, #4
 9404 51fc B4111FE5 		ldr	r1, .L1038+64
 9405 5200 FEFFFFEB 		bl	CyU3PDebugPrint
 9406              	.LVL1104:
 9407 5204 44309DE5 		ldr	r3, [sp, #68]
 9408 5208 CDFBFFEA 		b	.L646
 9409              	.L861:
5008:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 9410              		.loc 1 5008 0
 9411 520c 2D00A0E3 		mov	r0, #45
 9412 5210 FEFFFFEB 		bl	ControlHandle
 9413              	.LVL1105:
5009:../uvc.c      ****     		break;
 9414              		.loc 1 5009 0
 9415 5214 C4311FE5 		ldr	r3, .L1038+72
 9416 5218 B020D4E1 		ldrh	r2, [r4]
 9417 521c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9418 5220 0400A0E3 		mov	r0, #4
 9419 5224 D8111FE5 		ldr	r1, .L1038+68
 9420 5228 FEFFFFEB 		bl	CyU3PDebugPrint
 9421              	.LVL1106:
 9422 522c 44309DE5 		ldr	r3, [sp, #68]
 9423 5230 C3FBFFEA 		b	.L646
 9424              	.L857:
 9425              	.LVL1107:
 9426              	.LBB390:
 9427              	.LBB391:
1338:../uvc.c      ****     /*
 9428              		.loc 1 1338 0
 9429 5234 E4411FE5 		ldr	r4, .L1038+72
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9430              		.loc 1 1320 0
 9431 5238 5827D9E5 		ldrb	r2, [r9, #1880]	@ zero_extendqisi2
1338:../uvc.c      ****     /*
 9432              		.loc 1 1338 0
 9433 523c 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
1321:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9434              		.loc 1 1321 0
 9435 5240 5957D9E5 		ldrb	r5, [r9, #1881]	@ zero_extendqisi2
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9436              		.loc 1 1322 0
 9437 5244 6737D9E5 		ldrb	r3, [r9, #1895]	@ zero_extendqisi2
1323:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9438              		.loc 1 1323 0
 9439 5248 5A67D9E5 		ldrb	r6, [r9, #1882]	@ zero_extendqisi2
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9440              		.loc 1 1320 0
 9441 524c FF2002E2 		and	r2, r2, #255
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9442              		.loc 1 1322 0
 9443 5250 FF3003E2 		and	r3, r3, #255
1346:../uvc.c      **** 		 {
 9444              		.loc 1 1346 0
 9445 5254 83005CE3 		cmp	ip, #131
1338:../uvc.c      ****     /*
 9446              		.loc 1 1338 0
 9447 5258 28C08DE5 		str	ip, [sp, #40]
1320:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9448              		.loc 1 1320 0
 9449 525c 34208DE5 		str	r2, [sp, #52]
 9450              	.LVL1108:
1321:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9451              		.loc 1 1321 0
 9452 5260 FF5005E2 		and	r5, r5, #255
 9453              	.LVL1109:
1322:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9454              		.loc 1 1322 0
 9455 5264 2C308DE5 		str	r3, [sp, #44]
 9456              	.LVL1110:
1323:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9457              		.loc 1 1323 0
 9458 5268 FF6006E2 		and	r6, r6, #255
 9459              	.LVL1111:
1346:../uvc.c      **** 		 {
 9460              		.loc 1 1346 0
 9461 526c A102000A 		beq	.L892
 9462 5270 2601009A 		bls	.L1022
 9463 5274 28C09DE5 		ldr	ip, [sp, #40]
 9464 5278 85005CE3 		cmp	ip, #133
 9465 527c F300000A 		beq	.L897
 9466 5280 EA02003A 		bcc	.L898
 9467 5284 86005CE3 		cmp	ip, #134
 9468 5288 DF02000A 		beq	.L899
 9469 528c 87005CE3 		cmp	ip, #135
 9470 5290 F102001A 		bne	.L891
1984:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9471              		.loc 1 1984 0
 9472 5294 020056E3 		cmp	r6, #2
1985:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9473              		.loc 1 1985 0
 9474 5298 6327D905 		ldreqb	r2, [r9, #1891]	@ zero_extendqisi2
1986:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9475              		.loc 1 1986 0
 9476 529c 6437D905 		ldreqb	r3, [r9, #1892]	@ zero_extendqisi2
1984:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9477              		.loc 1 1984 0
 9478 52a0 9B02000A 		beq	.L985
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9479              		.loc 1 1990 0
 9480 52a4 63C7D9E5 		ldrb	ip, [r9, #1891]	@ zero_extendqisi2
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9481              		.loc 1 1992 0
 9482 52a8 6427D9E5 		ldrb	r2, [r9, #1892]	@ zero_extendqisi2
 9483              	.L983:
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9484              		.loc 1 1991 0
 9485 52ac 0030A0E3 		mov	r3, #0
2009:../uvc.c      **** 		 	 if(Len == 2){
 9486              		.loc 1 2009 0
 9487 52b0 0600A0E1 		mov	r0, r6
 9488 52b4 34121FE5 		ldr	r1, .L1038+120
1990:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9489              		.loc 1 1990 0
 9490 52b8 28C0C7E5 		strb	ip, [r7, #40]
1992:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9491              		.loc 1 1992 0
 9492 52bc 2A20C7E5 		strb	r2, [r7, #42]
1991:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9493              		.loc 1 1991 0
 9494 52c0 2930C7E5 		strb	r3, [r7, #41]
1993:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9495              		.loc 1 1993 0
 9496 52c4 2B30C7E5 		strb	r3, [r7, #43]
2015:../uvc.c      **** 		 	 }
 9497              		.loc 1 2015 0
 9498 52c8 24308DE5 		str	r3, [sp, #36]
 9499 52cc 0060A0E3 		mov	r6, #0
 9500              	.LVL1112:
2009:../uvc.c      **** 		 	 if(Len == 2){
 9501              		.loc 1 2009 0
 9502 52d0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9503              	.LVL1113:
2014:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 9504              		.loc 1 2014 0
 9505 52d4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9506              	.LVL1114:
2015:../uvc.c      **** 		 	 }
 9507              		.loc 1 2015 0
 9508 52d8 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 9509              	.LVL1115:
 9510 52dc E50000EA 		b	.L901
 9511              	.LVL1116:
 9512              	.L846:
 9513              	.LBE391:
 9514              	.LBE390:
4945:../uvc.c      ****     		break;
 9515              		.loc 1 4945 0
 9516 52e0 1A00A0E3 		mov	r0, #26
 9517 52e4 FEFFFFEB 		bl	ControlHandle
 9518              	.LVL1117:
 9519 52e8 44309DE5 		ldr	r3, [sp, #68]
 9520 52ec 94FBFFEA 		b	.L646
 9521              	.L842:
 9522              	.LVL1118:
4934:../uvc.c      ****      		break;
 9523              		.loc 1 4934 0
 9524 52f0 1800A0E3 		mov	r0, #24
 9525 52f4 FEFFFFEB 		bl	ControlHandle
 9526              	.LVL1119:
 9527 52f8 44309DE5 		ldr	r3, [sp, #68]
 9528 52fc 90FBFFEA 		b	.L646
 9529              	.L834:
 9530              	.LVL1120:
4922:../uvc.c      ****      		break;
 9531              		.loc 1 4922 0
 9532 5300 1500A0E3 		mov	r0, #21
 9533 5304 FEFFFFEB 		bl	ControlHandle
 9534              	.LVL1121:
 9535 5308 44309DE5 		ldr	r3, [sp, #68]
 9536 530c 8CFBFFEA 		b	.L646
 9537              	.L832:
 9538              	.LVL1122:
4955:../uvc.c      ****     		break;
 9539              		.loc 1 4955 0
 9540 5310 1C00A0E3 		mov	r0, #28
 9541 5314 FEFFFFEB 		bl	ControlHandle
 9542              	.LVL1123:
 9543 5318 44309DE5 		ldr	r3, [sp, #68]
 9544 531c 88FBFFEA 		b	.L646
 9545              	.L838:
 9546              	.LVL1124:
4902:../uvc.c      ****     		break;
 9547              		.loc 1 4902 0
 9548 5320 1000A0E3 		mov	r0, #16
 9549 5324 FEFFFFEB 		bl	ControlHandle
 9550              	.LVL1125:
 9551 5328 44309DE5 		ldr	r3, [sp, #68]
 9552 532c 84FBFFEA 		b	.L646
 9553              	.L836:
 9554              	.LVL1126:
4910:../uvc.c      ****      		break;
 9555              		.loc 1 4910 0
 9556 5330 1200A0E3 		mov	r0, #18
 9557 5334 FEFFFFEB 		bl	ControlHandle
 9558              	.LVL1127:
 9559 5338 44309DE5 		ldr	r3, [sp, #68]
 9560 533c 80FBFFEA 		b	.L646
 9561              	.L851:
 9562              	.LVL1128:
4971:../uvc.c      ****     		break;
 9563              		.loc 1 4971 0
 9564 5340 2400A0E3 		mov	r0, #36
 9565 5344 FEFFFFEB 		bl	ControlHandle
 9566              	.LVL1129:
 9567 5348 44309DE5 		ldr	r3, [sp, #68]
 9568 534c 7CFBFFEA 		b	.L646
 9569              	.L844:
 9570              	.LVL1130:
4926:../uvc.c      ****     		break;
 9571              		.loc 1 4926 0
 9572 5350 1600A0E3 		mov	r0, #22
 9573 5354 FEFFFFEB 		bl	ControlHandle
 9574              	.LVL1131:
 9575 5358 44309DE5 		ldr	r3, [sp, #68]
 9576 535c 78FBFFEA 		b	.L646
 9577              	.L853:
 9578              	.LVL1132:
4963:../uvc.c      ****     		break;
 9579              		.loc 1 4963 0
 9580 5360 1E00A0E3 		mov	r0, #30
 9581 5364 FEFFFFEB 		bl	ControlHandle
 9582              	.LVL1133:
 9583 5368 44309DE5 		ldr	r3, [sp, #68]
 9584 536c 74FBFFEA 		b	.L646
 9585              	.L840:
 9586              	.LVL1134:
4914:../uvc.c      ****     		break;
 9587              		.loc 1 4914 0
 9588 5370 1300A0E3 		mov	r0, #19
 9589 5374 FEFFFFEB 		bl	ControlHandle
 9590              	.LVL1135:
 9591 5378 44309DE5 		ldr	r3, [sp, #68]
 9592 537c 70FBFFEA 		b	.L646
 9593              	.L855:
 9594              	.LVL1136:
4975:../uvc.c      ****     		break;
 9595              		.loc 1 4975 0
 9596 5380 2500A0E3 		mov	r0, #37
 9597 5384 FEFFFFEB 		bl	ControlHandle
 9598              	.LVL1137:
 9599 5388 44309DE5 		ldr	r3, [sp, #68]
 9600 538c 6CFBFFEA 		b	.L646
 9601              	.L859:
4988:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9602              		.loc 1 4988 0
 9603 5390 2800A0E3 		mov	r0, #40
 9604 5394 FEFFFFEB 		bl	ControlHandle
 9605              	.LVL1138:
4989:../uvc.c      ****     		break;
 9606              		.loc 1 4989 0
 9607 5398 48331FE5 		ldr	r3, .L1038+72
 9608 539c B020D4E1 		ldrh	r2, [r4]
 9609 53a0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9610 53a4 0400A0E3 		mov	r0, #4
 9611 53a8 54131FE5 		ldr	r1, .L1038+76
 9612 53ac FEFFFFEB 		bl	CyU3PDebugPrint
 9613              	.LVL1139:
 9614 53b0 44309DE5 		ldr	r3, [sp, #68]
 9615 53b4 62FBFFEA 		b	.L646
 9616              	.LVL1140:
 9617              	.L1002:
 9618 53b8 0250A0E1 		mov	r5, r2
 9619              	.LBE422:
 9620              	.LBE444:
5554:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9621              		.loc 1 5554 0
 9622 53bc 0600A0E1 		mov	r0, r6
 9623              	.LVL1141:
 9624 53c0 68131FE5 		ldr	r1, .L1038+80
 9625 53c4 FEFFFFEB 		bl	CyU3PDebugPrint
 9626              	.LVL1142:
5555:../uvc.c      **** 					}
 9627              		.loc 1 5555 0
 9628 53c8 0500A0E1 		mov	r0, r5
 9629 53cc FEFFFFEB 		bl	CyFxAppErrorHandler
 9630              	.LVL1143:
 9631              	.L785:
 9632              	.LBB445:
 9633              	.LBB338:
 9634              	.LBB273:
 9635              	.LBB216:
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9636              		.loc 1 2987 0
 9637 53d0 0030A0E3 		mov	r3, #0
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9638              		.loc 1 2988 0
 9639 53d4 0200A0E3 		mov	r0, #2
 9640 53d8 58131FE5 		ldr	r1, .L1038+120
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9641              		.loc 1 2987 0
 9642 53dc 2930C7E5 		strb	r3, [r7, #41]
2986:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9643              		.loc 1 2986 0
 9644 53e0 2860C7E5 		strb	r6, [r7, #40]
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9645              		.loc 1 2988 0
 9646 53e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9647              	.LVL1144:
2989:../uvc.c      **** 			  break;
 9648              		.loc 1 2989 0
 9649 53e8 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9650              	.LVL1145:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9651              		.loc 1 2976 0
 9652 53ec FF20A0E3 		mov	r2, #255
 9653 53f0 0230A0E1 		mov	r3, r2
 9654              	.LVL1146:
 9655              	.L789:
3195:../uvc.c      **** }
 9656              		.loc 1 3195 0
 9657 53f4 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9658 53f8 00208DE5 		str	r2, [sp]
 9659 53fc FF00A0E3 		mov	r0, #255
 9660 5400 0520A0E1 		mov	r2, r5
 9661              	.LVL1147:
 9662 5404 08408DE5 		str	r4, [sp, #8]
 9663 5408 14608DE5 		str	r6, [sp, #20]
 9664              	.LVL1148:
 9665              	.L986:
 9666              	.LBE216:
 9667              	.LBE273:
 9668              	.LBB274:
 9669              	.LBB255:
 9670 540c 04108DE5 		str	r1, [sp, #4]
 9671 5410 10108DE5 		str	r1, [sp, #16]
 9672 5414 0C008DE5 		str	r0, [sp, #12]
 9673 5418 BC131FE5 		ldr	r1, .L1038+84
 9674 541c 0400A0E3 		mov	r0, #4
 9675 5420 FEFFFFEB 		bl	CyU3PDebugPrint
 9676              	.LVL1149:
 9677 5424 44309DE5 		ldr	r3, [sp, #68]
 9678 5428 45FBFFEA 		b	.L646
 9679              	.LVL1150:
 9680              	.L675:
 9681              	.LBE255:
 9682              	.LBE274:
 9683              	.LBE338:
 9684              	.LBE445:
 9685              	.LBB446:
 9686              	.LBB369:
 9687              	.LBB357:
 9688              	.LBB349:
1971:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9689              		.loc 1 1971 0
 9690 542c 3927D9E5 		ldrb	r2, [r9, #1849]	@ zero_extendqisi2
1977:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9691              		.loc 1 1977 0
 9692 5430 B0131FE5 		ldr	r1, .L1038+120
1972:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9693              		.loc 1 1972 0
 9694 5434 0030A0E3 		mov	r3, #0
1977:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9695              		.loc 1 1977 0
 9696 5438 0100A0E3 		mov	r0, #1
1971:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9697              		.loc 1 1971 0
 9698 543c 2820C7E5 		strb	r2, [r7, #40]
1972:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9699              		.loc 1 1972 0
 9700 5440 2930C7E5 		strb	r3, [r7, #41]
1973:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9701              		.loc 1 1973 0
 9702 5444 2A30C7E5 		strb	r3, [r7, #42]
1974:../uvc.c      **** 		 	 }
 9703              		.loc 1 1974 0
 9704 5448 2B30C7E5 		strb	r3, [r7, #43]
 9705              	.LVL1151:
1979:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 9706              		.loc 1 1979 0
 9707 544c 24308DE5 		str	r3, [sp, #36]
 9708              	.LVL1152:
 9709              	.L966:
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9710              		.loc 1 1958 0
 9711 5450 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9712              	.LVL1153:
1960:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9713              		.loc 1 1960 0
 9714 5454 0050A0E3 		mov	r5, #0
1959:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
 9715              		.loc 1 1959 0
 9716 5458 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9717              	.LVL1154:
1960:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9718              		.loc 1 1960 0
 9719 545c 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 9720              	.LVL1155:
 9721 5460 24209DE5 		ldr	r2, [sp, #36]
 9722 5464 E5FDFFEA 		b	.L677
 9723              	.LVL1156:
 9724              	.L671:
1888:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9725              		.loc 1 1888 0
 9726 5468 020055E3 		cmp	r5, #2
1889:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9727              		.loc 1 1889 0
 9728 546c 3327D905 		ldreqb	r2, [r9, #1843]	@ zero_extendqisi2
1890:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9729              		.loc 1 1890 0
 9730 5470 3437D905 		ldreqb	r3, [r9, #1844]	@ zero_extendqisi2
1888:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9731              		.loc 1 1888 0
 9732 5474 1801000A 		beq	.L964
1893:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9733              		.loc 1 1893 0
 9734 5478 33C7D9E5 		ldrb	ip, [r9, #1843]	@ zero_extendqisi2
1895:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9735              		.loc 1 1895 0
 9736 547c 3427D9E5 		ldrb	r2, [r9, #1844]	@ zero_extendqisi2
1896:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9737              		.loc 1 1896 0
 9738 5480 0030A0E3 		mov	r3, #0
1900:../uvc.c      **** 		 	 if(Len == 2){
 9739              		.loc 1 1900 0
 9740 5484 0500A0E1 		mov	r0, r5
 9741 5488 08141FE5 		ldr	r1, .L1038+120
1893:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9742              		.loc 1 1893 0
 9743 548c 28C0C7E5 		strb	ip, [r7, #40]
1895:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9744              		.loc 1 1895 0
 9745 5490 2920C7E5 		strb	r2, [r7, #41]
1896:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9746              		.loc 1 1896 0
 9747 5494 2B30C7E5 		strb	r3, [r7, #43]
1906:../uvc.c      **** 			  }
 9748              		.loc 1 1906 0
 9749 5498 24308DE5 		str	r3, [sp, #36]
 9750 549c 5FFCFFEA 		b	.L965
 9751              	.LVL1157:
 9752              	.L724:
 9753              	.LBE349:
 9754              	.LBE357:
 9755              	.LBE369:
 9756              	.LBE446:
 9757              	.LBB447:
 9758              	.LBB339:
 9759              	.LBB275:
 9760              	.LBB181:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9761              		.loc 1 3011 0
 9762 54a0 24E41FE5 		ldr	lr, .L1038+116
 9763 54a4 E315DEE5 		ldrb	r1, [lr, #1507]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9764              		.loc 1 3012 0
 9765 54a8 E425DEE5 		ldrb	r2, [lr, #1508]	@ zero_extendqisi2
 9766 54ac 3FFDFFEA 		b	.L976
 9767              	.LVL1158:
 9768              	.L818:
 9769              	.LBE181:
 9770              	.LBE275:
 9771              	.LBB276:
 9772              	.LBB256:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9773              		.loc 1 3011 0
 9774 54b0 A306D9E5 		ldrb	r0, [r9, #1699]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9775              		.loc 1 3012 0
 9776 54b4 A416D9E5 		ldrb	r1, [r9, #1700]	@ zero_extendqisi2
 9777 54b8 8BFDFFEA 		b	.L978
 9778              	.LVL1159:
 9779              	.L735:
 9780              	.LBE256:
 9781              	.LBE276:
 9782              	.LBB277:
 9783              	.LBB206:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9784              		.loc 1 3011 0
 9785 54bc 40241FE5 		ldr	r2, .L1038+116
 9786 54c0 FB15D2E5 		ldrb	r1, [r2, #1531]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9787              		.loc 1 3012 0
 9788 54c4 FC25D2E5 		ldrb	r2, [r2, #1532]	@ zero_extendqisi2
 9789 54c8 09FDFFEA 		b	.L974
 9790              	.LVL1160:
 9791              	.L750:
 9792              	.LBE206:
 9793              	.LBE277:
 9794              	.LBB278:
 9795              	.LBB173:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9796              		.loc 1 3011 0
 9797 54cc 1316D9E5 		ldrb	r1, [r9, #1555]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9798              		.loc 1 3012 0
 9799 54d0 1426D9E5 		ldrb	r2, [r9, #1556]	@ zero_extendqisi2
 9800 54d4 35FDFFEA 		b	.L976
 9801              	.LVL1161:
 9802              	.L713:
 9803              	.LBE173:
 9804              	.LBE278:
 9805              	.LBB279:
 9806              	.LBB198:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9807              		.loc 1 3011 0
 9808 54d8 5CE41FE5 		ldr	lr, .L1038+116
 9809 54dc B315DEE5 		ldrb	r1, [lr, #1459]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9810              		.loc 1 3012 0
 9811 54e0 B425DEE5 		ldrb	r2, [lr, #1460]	@ zero_extendqisi2
 9812 54e4 31FDFFEA 		b	.L976
 9813              	.LVL1162:
 9814              	.L728:
 9815              	.LBE198:
 9816              	.LBE279:
 9817              	.LBB280:
 9818              	.LBB182:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9819              		.loc 1 3038 0
 9820 54e8 6C441FE5 		ldr	r4, .L1038+116
 9821 54ec E935D4E5 		ldrb	r3, [r4, #1513]	@ zero_extendqisi2
 9822              	.LVL1163:
 9823              	.L989:
 9824              	.LBE182:
 9825              	.LBE280:
 9826              	.LBB281:
 9827              	.LBB238:
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9828              		.loc 1 3039 0
 9829 54f0 0100A0E3 		mov	r0, #1
 9830 54f4 74141FE5 		ldr	r1, .L1038+120
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9831              		.loc 1 3038 0
 9832 54f8 2830C7E5 		strb	r3, [r7, #40]
3041:../uvc.c      **** 			  break;
 9833              		.loc 1 3041 0
 9834 54fc 0160A0E3 		mov	r6, #1
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9835              		.loc 1 3039 0
 9836 5500 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9837              	.LVL1164:
3040:../uvc.c      **** 			  Len = 1;
 9838              		.loc 1 3040 0
 9839 5504 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9840              	.LVL1165:
 9841 5508 19FFFFEA 		b	.L813
 9842              	.LVL1166:
 9843              	.L717:
 9844              	.LBE238:
 9845              	.LBE281:
 9846              	.LBB282:
 9847              	.LBB199:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9848              		.loc 1 3038 0
 9849 550c B935D9E5 		ldrb	r3, [r9, #1465]	@ zero_extendqisi2
 9850 5510 F6FFFFEA 		b	.L989
 9851              	.LVL1167:
 9852              	.L739:
 9853              	.LBE199:
 9854              	.LBE282:
 9855              	.LBB283:
 9856              	.LBB207:
 9857 5514 0136D9E5 		ldrb	r3, [r9, #1537]	@ zero_extendqisi2
 9858              	.LVL1168:
 9859              	.L990:
 9860              	.LBE207:
 9861              	.LBE283:
 9862              	.LBB284:
 9863              	.LBB217:
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9864              		.loc 1 3039 0
 9865 5518 0100A0E3 		mov	r0, #1
 9866 551c 9C141FE5 		ldr	r1, .L1038+120
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9867              		.loc 1 3038 0
 9868 5520 2830C7E5 		strb	r3, [r7, #40]
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9869              		.loc 1 3039 0
 9870 5524 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9871              	.LVL1169:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9872              		.loc 1 2976 0
 9873 5528 FF20A0E3 		mov	r2, #255
 9874 552c 0230A0E1 		mov	r3, r2
3040:../uvc.c      **** 			  Len = 1;
 9875              		.loc 1 3040 0
 9876 5530 2840D7E5 		ldrb	r4, [r7, #40]	@ zero_extendqisi2
 9877              	.LVL1170:
3041:../uvc.c      **** 			  break;
 9878              		.loc 1 3041 0
 9879 5534 0160A0E3 		mov	r6, #1
 9880 5538 ADFFFFEA 		b	.L789
 9881              	.LVL1171:
 9882              	.L787:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9883              		.loc 1 3038 0
 9884 553c C0441FE5 		ldr	r4, .L1038+116
 9885 5540 6136D4E5 		ldrb	r3, [r4, #1633]	@ zero_extendqisi2
 9886 5544 F3FFFFEA 		b	.L990
 9887              	.LVL1172:
 9888              	.L772:
 9889              	.LBE217:
 9890              	.LBE284:
 9891              	.LBB285:
 9892              	.LBB190:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9893              		.loc 1 3011 0
 9894 5548 CCE41FE5 		ldr	lr, .L1038+116
 9895 554c 4316DEE5 		ldrb	r1, [lr, #1603]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9896              		.loc 1 3012 0
 9897 5550 4426DEE5 		ldrb	r2, [lr, #1604]	@ zero_extendqisi2
 9898 5554 15FDFFEA 		b	.L976
 9899              	.LVL1173:
 9900              	.L783:
 9901              	.LBE190:
 9902              	.LBE285:
 9903              	.LBB286:
 9904              	.LBB218:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9905              		.loc 1 3011 0
 9906 5558 DCE41FE5 		ldr	lr, .L1038+116
 9907 555c 5B16DEE5 		ldrb	r1, [lr, #1627]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9908              		.loc 1 3012 0
 9909 5560 5C26DEE5 		ldrb	r2, [lr, #1628]	@ zero_extendqisi2
 9910 5564 E2FCFFEA 		b	.L974
 9911              	.LVL1174:
 9912              	.L807:
 9913              	.LBE218:
 9914              	.LBE286:
 9915              	.LBB287:
 9916              	.LBB239:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9917              		.loc 1 3011 0
 9918 5568 EC241FE5 		ldr	r2, .L1038+116
 9919 556c 8B16D2E5 		ldrb	r1, [r2, #1675]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9920              		.loc 1 3012 0
 9921 5570 8C26D2E5 		ldrb	r2, [r2, #1676]	@ zero_extendqisi2
 9922 5574 0DFDFFEA 		b	.L976
 9923              	.LVL1175:
 9924              	.L761:
 9925              	.LBE239:
 9926              	.LBE287:
 9927              	.LBB288:
 9928              	.LBB228:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9929              		.loc 1 3011 0
 9930 5578 FC241FE5 		ldr	r2, .L1038+116
 9931 557c 2B16D2E5 		ldrb	r1, [r2, #1579]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9932              		.loc 1 3012 0
 9933 5580 2C26D2E5 		ldrb	r2, [r2, #1580]	@ zero_extendqisi2
 9934 5584 09FDFFEA 		b	.L976
 9935              	.LVL1176:
 9936              	.L796:
 9937              	.LBE228:
 9938              	.LBE288:
 9939              	.LBB289:
 9940              	.LBB247:
3011:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9941              		.loc 1 3011 0
 9942 5588 7316D9E5 		ldrb	r1, [r9, #1651]	@ zero_extendqisi2
3012:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9943              		.loc 1 3012 0
 9944 558c 7426D9E5 		ldrb	r2, [r9, #1652]	@ zero_extendqisi2
 9945 5590 06FDFFEA 		b	.L976
 9946              	.LVL1177:
 9947              	.L776:
 9948              	.LBE247:
 9949              	.LBE289:
 9950              	.LBB290:
 9951              	.LBB191:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9952              		.loc 1 3038 0
 9953 5594 4936D9E5 		ldrb	r3, [r9, #1609]	@ zero_extendqisi2
 9954 5598 D4FFFFEA 		b	.L989
 9955              	.LVL1178:
 9956              	.L822:
 9957              	.LBE191:
 9958              	.LBE290:
 9959              	.LBB291:
 9960              	.LBB257:
 9961 559c A936D9E5 		ldrb	r3, [r9, #1705]	@ zero_extendqisi2
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9962              		.loc 1 3039 0
 9963 55a0 0100A0E3 		mov	r0, #1
 9964 55a4 24151FE5 		ldr	r1, .L1038+120
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9965              		.loc 1 2976 0
 9966 55a8 FF40A0E3 		mov	r4, #255
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9967              		.loc 1 3038 0
 9968 55ac 2830C7E5 		strb	r3, [r7, #40]
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9969              		.loc 1 2976 0
 9970 55b0 24408DE5 		str	r4, [sp, #36]
3041:../uvc.c      **** 			  break;
 9971              		.loc 1 3041 0
 9972 55b4 0160A0E3 		mov	r6, #1
3039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9973              		.loc 1 3039 0
 9974 55b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9975              	.LVL1179:
3040:../uvc.c      **** 			  Len = 1;
 9976              		.loc 1 3040 0
 9977 55bc 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9978              	.LVL1180:
 9979 55c0 55FDFFEA 		b	.L824
 9980              	.LVL1181:
 9981              	.L800:
 9982              	.LBE257:
 9983              	.LBE291:
 9984              	.LBB292:
 9985              	.LBB248:
3038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9986              		.loc 1 3038 0
 9987 55c4 7936D9E5 		ldrb	r3, [r9, #1657]	@ zero_extendqisi2
 9988 55c8 C8FFFFEA 		b	.L989
 9989              	.LVL1182:
 9990              	.L754:
 9991              	.LBE248:
 9992              	.LBE292:
 9993              	.LBB293:
 9994              	.LBB174:
 9995 55cc 1936D9E5 		ldrb	r3, [r9, #1561]	@ zero_extendqisi2
 9996 55d0 C6FFFFEA 		b	.L989
 9997              	.LVL1183:
 9998              	.L765:
 9999              	.LBE174:
 10000              	.LBE293:
 10001              	.LBB294:
 10002              	.LBB229:
 10003 55d4 58C51FE5 		ldr	ip, .L1038+116
 10004 55d8 3136DCE5 		ldrb	r3, [ip, #1585]	@ zero_extendqisi2
 10005 55dc C3FFFFEA 		b	.L989
 10006              	.LVL1184:
 10007              	.L811:
 10008              	.LBE229:
 10009              	.LBE294:
 10010              	.LBB295:
 10011              	.LBB240:
 10012 55e0 9136D9E5 		ldrb	r3, [r9, #1681]	@ zero_extendqisi2
 10013 55e4 C1FFFFEA 		b	.L989
 10014              	.LVL1185:
 10015              	.L870:
 10016              	.LBE240:
 10017              	.LBE295:
 10018              	.LBE339:
 10019              	.LBE447:
 10020              	.LBB448:
 10021              	.LBB423:
 10022              	.LBB400:
 10023              	.LBB380:
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10024              		.loc 1 1351 0
 10025 55e8 0030A0E3 		mov	r3, #0
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10026              		.loc 1 1352 0
 10027 55ec 0200A0E3 		mov	r0, #2
 10028 55f0 70151FE5 		ldr	r1, .L1038+120
1350:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10029              		.loc 1 1350 0
 10030 55f4 2860C7E5 		strb	r6, [r7, #40]
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10031              		.loc 1 1351 0
 10032 55f8 2930C7E5 		strb	r3, [r7, #41]
1353:../uvc.c      **** 			  break;
 10033              		.loc 1 1353 0
 10034 55fc 24308DE5 		str	r3, [sp, #36]
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10035              		.loc 1 1352 0
 10036 5600 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10037              	.LVL1186:
1353:../uvc.c      **** 			  break;
 10038              		.loc 1 1353 0
 10039 5604 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10040              	.LVL1187:
 10041 5608 0060A0E3 		mov	r6, #0
 10042              	.LVL1188:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10043              		.loc 1 1334 0
 10044 560c FF50A0E3 		mov	r5, #255
 10045              	.LVL1189:
 10046              	.L874:
2956:../uvc.c      **** }
 10047              		.loc 1 2956 0
 10048 5610 24209DE5 		ldr	r2, [sp, #36]
 10049 5614 0630A0E1 		mov	r3, r6
 10050 5618 04108DE8 		stmia	sp, {r2, ip}
 10051 561c B8151FE5 		ldr	r1, .L1038+92
 10052 5620 28209DE5 		ldr	r2, [sp, #40]
 10053 5624 08508DE5 		str	r5, [sp, #8]
 10054 5628 0400A0E3 		mov	r0, #4
 10055 562c FEFFFFEB 		bl	CyU3PDebugPrint
 10056              	.LVL1190:
 10057              	.LBE380:
 10058              	.LBE400:
4994:../uvc.c      ****     		break;
 10059              		.loc 1 4994 0
 10060 5630 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10061 5634 CC451FE5 		ldr	r4, .L1038+96
 10062 5638 0400A0E3 		mov	r0, #4
 10063 563c DC151FE5 		ldr	r1, .L1038+88
 10064 5640 B020D4E1 		ldrh	r2, [r4]
 10065 5644 FEFFFFEB 		bl	CyU3PDebugPrint
 10066              	.LVL1191:
 10067 5648 44309DE5 		ldr	r3, [sp, #68]
 10068 564c BCFAFFEA 		b	.L646
 10069              	.LVL1192:
 10070              	.L897:
 10071              	.LBB401:
 10072              	.LBB392:
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10073              		.loc 1 1351 0
 10074 5650 0030A0E3 		mov	r3, #0
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10075              		.loc 1 1352 0
 10076 5654 0200A0E3 		mov	r0, #2
 10077 5658 D8151FE5 		ldr	r1, .L1038+120
1350:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10078              		.loc 1 1350 0
 10079 565c 2860C7E5 		strb	r6, [r7, #40]
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10080              		.loc 1 1351 0
 10081 5660 2930C7E5 		strb	r3, [r7, #41]
1353:../uvc.c      **** 			  break;
 10082              		.loc 1 1353 0
 10083 5664 24308DE5 		str	r3, [sp, #36]
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10084              		.loc 1 1352 0
 10085 5668 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10086              	.LVL1193:
1353:../uvc.c      **** 			  break;
 10087              		.loc 1 1353 0
 10088 566c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10089              	.LVL1194:
 10090 5670 0060A0E3 		mov	r6, #0
 10091              	.LVL1195:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10092              		.loc 1 1334 0
 10093 5674 FF50A0E3 		mov	r5, #255
 10094              	.LVL1196:
 10095              	.L901:
2956:../uvc.c      **** }
 10096              		.loc 1 2956 0
 10097 5678 24209DE5 		ldr	r2, [sp, #36]
 10098 567c 0630A0E1 		mov	r3, r6
 10099 5680 04108DE8 		stmia	sp, {r2, ip}
 10100 5684 20161FE5 		ldr	r1, .L1038+92
 10101 5688 28209DE5 		ldr	r2, [sp, #40]
 10102 568c 08508DE5 		str	r5, [sp, #8]
 10103 5690 0400A0E3 		mov	r0, #4
 10104 5694 FEFFFFEB 		bl	CyU3PDebugPrint
 10105              	.LVL1197:
 10106              	.LBE392:
 10107              	.LBE401:
4999:../uvc.c      ****    		break;
 10108              		.loc 1 4999 0
 10109 5698 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10110 569c 34461FE5 		ldr	r4, .L1038+96
 10111 56a0 0400A0E3 		mov	r0, #4
 10112 56a4 38161FE5 		ldr	r1, .L1038+100
 10113 56a8 B020D4E1 		ldrh	r2, [r4]
 10114 56ac FEFFFFEB 		bl	CyU3PDebugPrint
 10115              	.LVL1198:
 10116 56b0 44309DE5 		ldr	r3, [sp, #68]
 10117 56b4 A2FAFFEA 		b	.L646
 10118              	.LVL1199:
 10119              	.L742:
 10120              	.LBE423:
 10121              	.LBE448:
 10122              	.LBB449:
 10123              	.LBB340:
 10124              	.LBB296:
 10125              	.LBB208:
3139:../uvc.c      **** 					  }
 10126              		.loc 1 3139 0
 10127 56b8 0000A0E3 		mov	r0, #0
 10128 56bc 0020A0E1 		mov	r2, r0
 10129 56c0 0110A0E3 		mov	r1, #1
 10130 56c4 FEFFFFEB 		bl	CyU3PUsbStall
 10131              	.LVL1200:
 10132 56c8 28FEFFEA 		b	.L791
 10133              	.LVL1201:
 10134              	.L865:
 10135              	.LBE208:
 10136              	.LBE296:
 10137              	.LBE340:
 10138              	.LBE449:
 10139              	.LBB450:
 10140              	.LBB424:
 10141              	.LBB402:
 10142              	.LBB381:
1911:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10143              		.loc 1 1911 0
 10144 56cc 020056E3 		cmp	r6, #2
1917:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10145              		.loc 1 1917 0
 10146 56d0 49C7D915 		ldrneb	ip, [r9, #1865]	@ zero_extendqisi2
1919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10147              		.loc 1 1919 0
 10148 56d4 4A27D915 		ldrneb	r2, [r9, #1866]	@ zero_extendqisi2
1911:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10149              		.loc 1 1911 0
 10150 56d8 11FCFF1A 		bne	.L980
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10151              		.loc 1 1912 0
 10152 56dc 4927D9E5 		ldrb	r2, [r9, #1865]	@ zero_extendqisi2
1913:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10153              		.loc 1 1913 0
 10154 56e0 4A37D9E5 		ldrb	r3, [r9, #1866]	@ zero_extendqisi2
1936:../uvc.c      **** 				  if(Len == 2){
 10155              		.loc 1 1936 0
 10156 56e4 0200A0E3 		mov	r0, #2
 10157              	.L979:
 10158 56e8 68161FE5 		ldr	r1, .L1038+120
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10159              		.loc 1 1912 0
 10160 56ec 2820C7E5 		strb	r2, [r7, #40]
1913:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10161              		.loc 1 1913 0
 10162 56f0 2930C7E5 		strb	r3, [r7, #41]
 10163              	.LVL1202:
 10164              	.L981:
1939:../uvc.c      **** 				  }else{
 10165              		.loc 1 1939 0
 10166 56f4 00C0A0E3 		mov	ip, #0
 10167 56f8 24C08DE5 		str	ip, [sp, #36]
 10168 56fc 0060A0E3 		mov	r6, #0
1936:../uvc.c      **** 				  if(Len == 2){
 10169              		.loc 1 1936 0
 10170 5700 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10171              	.LVL1203:
1938:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10172              		.loc 1 1938 0
 10173 5704 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10174              	.LVL1204:
1939:../uvc.c      **** 				  }else{
 10175              		.loc 1 1939 0
 10176 5708 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 10177              	.LVL1205:
 10178 570c BFFFFFEA 		b	.L874
 10179              	.LVL1206:
 10180              	.L1022:
 10181              	.LBE381:
 10182              	.LBE402:
 10183              	.LBB403:
 10184              	.LBB393:
1346:../uvc.c      **** 		 {
 10185              		.loc 1 1346 0
 10186 5710 81005CE3 		cmp	ip, #129
 10187 5714 8901000A 		beq	.L894
 10188 5718 6E01008A 		bhi	.L895
 10189 571c 01005CE3 		cmp	ip, #1
 10190 5720 CD01001A 		bne	.L891
2536:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10191              		.loc 1 2536 0
 10192 5724 2000A0E3 		mov	r0, #32
 10193 5728 A8161FE5 		ldr	r1, .L1038+120
 10194 572c 42208DE2 		add	r2, sp, #66
 10195 5730 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10196              	.LVL1207:
2538:../uvc.c      **** 			   {
 10197              		.loc 1 2538 0
 10198 5734 000050E3 		cmp	r0, #0
 10199 5738 38008DE5 		str	r0, [sp, #56]
 10200 573c 3802001A 		bne	.L910
2540:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10201              		.loc 1 2540 0
 10202 5740 020056E3 		cmp	r6, #2
 10203 5744 B002000A 		beq	.L1023
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10204              		.loc 1 2548 0
 10205 5748 2CC09DE5 		ldr	ip, [sp, #44]
 10206 574c 08608DE5 		str	r6, [sp, #8]
 10207 5750 00508DE5 		str	r5, [sp]
 10208 5754 04C08DE5 		str	ip, [sp, #4]
2545:../uvc.c      **** 				 }
 10209              		.loc 1 2545 0
 10210 5758 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10211              		.loc 1 2548 0
 10212 575c 0400A0E3 		mov	r0, #4
 10213              	.LVL1208:
 10214 5760 F0161FE5 		ldr	r1, .L1038+104
 10215 5764 2A20A0E3 		mov	r2, #42
 10216 5768 34309DE5 		ldr	r3, [sp, #52]
 10217 576c 3C608DE5 		str	r6, [sp, #60]
2545:../uvc.c      **** 				 }
 10218              		.loc 1 2545 0
 10219 5770 24C08DE5 		str	ip, [sp, #36]
2544:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10220              		.loc 1 2544 0
 10221 5774 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 10222              	.LVL1209:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10223              		.loc 1 2548 0
 10224 5778 FEFFFFEB 		bl	CyU3PDebugPrint
 10225              	.LVL1210:
2737:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10226              		.loc 1 2737 0
 10227 577c 3CC09DE5 		ldr	ip, [sp, #60]
 10228 5780 04005CE3 		cmp	ip, #4
 10229 5784 3903000A 		beq	.L1024
 10230              	.LVL1211:
 10231              	.L915:
2754:../uvc.c      **** 				 	 			 break;
 10232              		.loc 1 2754 0
 10233 5788 6627D9E5 		ldrb	r2, [r9, #1894]	@ zero_extendqisi2
2753:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10234              		.loc 1 2753 0
 10235 578c 3CC09DE5 		ldr	ip, [sp, #60]
2754:../uvc.c      **** 				 	 			 break;
 10236              		.loc 1 2754 0
 10237 5790 6537D9E5 		ldrb	r3, [r9, #1893]	@ zero_extendqisi2
2753:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10238              		.loc 1 2753 0
 10239 5794 0400A0E3 		mov	r0, #4
 10240 5798 0C108DE8 		stmia	sp, {r2, r3, ip}
 10241 579c 28171FE5 		ldr	r1, .L1038+108
 10242 57a0 0620A0E1 		mov	r2, r6
 10243 57a4 24309DE5 		ldr	r3, [sp, #36]
 10244 57a8 FEFFFFEB 		bl	CyU3PDebugPrint
 10245              	.LVL1212:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10246              		.loc 1 1334 0
 10247 57ac FF50A0E3 		mov	r5, #255
 10248 57b0 05C0A0E1 		mov	ip, r5
 10249 57b4 AFFFFFEA 		b	.L901
 10250              	.LVL1213:
 10251              	.L1009:
 10252              	.LBE393:
 10253              	.LBE403:
 10254              	.LBB404:
 10255              	.LBB382:
1346:../uvc.c      **** 		 {
 10256              		.loc 1 1346 0
 10257 57b8 81005CE3 		cmp	ip, #129
 10258 57bc DC01000A 		beq	.L867
 10259 57c0 D301008A 		bhi	.L868
 10260 57c4 01005CE3 		cmp	ip, #1
 10261 57c8 AD01001A 		bne	.L864
2536:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10262              		.loc 1 2536 0
 10263 57cc 2000A0E3 		mov	r0, #32
 10264 57d0 50171FE5 		ldr	r1, .L1038+120
 10265 57d4 42208DE2 		add	r2, sp, #66
 10266 57d8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10267              	.LVL1214:
2538:../uvc.c      **** 			   {
 10268              		.loc 1 2538 0
 10269 57dc 000050E3 		cmp	r0, #0
 10270 57e0 38008DE5 		str	r0, [sp, #56]
 10271 57e4 1F02001A 		bne	.L883
2540:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10272              		.loc 1 2540 0
 10273 57e8 020056E3 		cmp	r6, #2
 10274 57ec 6002000A 		beq	.L1025
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10275              		.loc 1 2548 0
 10276 57f0 2CC09DE5 		ldr	ip, [sp, #44]
 10277 57f4 08608DE5 		str	r6, [sp, #8]
 10278 57f8 00508DE5 		str	r5, [sp]
 10279 57fc 04C08DE5 		str	ip, [sp, #4]
2545:../uvc.c      **** 				 }
 10280              		.loc 1 2545 0
 10281 5800 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10282              		.loc 1 2548 0
 10283 5804 0400A0E3 		mov	r0, #4
 10284              	.LVL1215:
 10285 5808 98171FE5 		ldr	r1, .L1038+104
 10286 580c 2920A0E3 		mov	r2, #41
 10287 5810 34309DE5 		ldr	r3, [sp, #52]
 10288 5814 3C608DE5 		str	r6, [sp, #60]
2545:../uvc.c      **** 				 }
 10289              		.loc 1 2545 0
 10290 5818 24C08DE5 		str	ip, [sp, #36]
2544:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10291              		.loc 1 2544 0
 10292 581c 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 10293              	.LVL1216:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10294              		.loc 1 2548 0
 10295 5820 FEFFFFEB 		bl	CyU3PDebugPrint
 10296              	.LVL1217:
2737:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10297              		.loc 1 2737 0
 10298 5824 3CC09DE5 		ldr	ip, [sp, #60]
 10299 5828 04005CE3 		cmp	ip, #4
 10300 582c E802000A 		beq	.L1026
 10301              	.LVL1218:
 10302              	.L888:
2754:../uvc.c      **** 				 	 			 break;
 10303              		.loc 1 2754 0
 10304 5830 5227D9E5 		ldrb	r2, [r9, #1874]	@ zero_extendqisi2
2753:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10305              		.loc 1 2753 0
 10306 5834 3CC09DE5 		ldr	ip, [sp, #60]
2754:../uvc.c      **** 				 	 			 break;
 10307              		.loc 1 2754 0
 10308 5838 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
2753:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10309              		.loc 1 2753 0
 10310 583c 0400A0E3 		mov	r0, #4
 10311 5840 0C108DE8 		stmia	sp, {r2, r3, ip}
 10312 5844 D0171FE5 		ldr	r1, .L1038+108
 10313 5848 0620A0E1 		mov	r2, r6
 10314 584c 24309DE5 		ldr	r3, [sp, #36]
 10315 5850 FEFFFFEB 		bl	CyU3PDebugPrint
 10316              	.LVL1219:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10317              		.loc 1 1334 0
 10318 5854 FF50A0E3 		mov	r5, #255
 10319 5858 05C0A0E1 		mov	ip, r5
 10320 585c 6BFFFFEA 		b	.L874
 10321              	.LVL1220:
 10322              	.L673:
 10323              	.LBE382:
 10324              	.LBE404:
 10325              	.LBE424:
 10326              	.LBE450:
 10327              	.LBB451:
 10328              	.LBB370:
 10329              	.LBB358:
 10330              	.LBB350:
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10331              		.loc 1 1351 0
 10332 5860 0030A0E3 		mov	r3, #0
1353:../uvc.c      **** 			  break;
 10333              		.loc 1 1353 0
 10334 5864 0340A0E1 		mov	r4, r3
 10335              	.LVL1221:
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10336              		.loc 1 1352 0
 10337 5868 0200A0E3 		mov	r0, #2
 10338 586c EC171FE5 		ldr	r1, .L1038+120
1350:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10339              		.loc 1 1350 0
 10340 5870 2850C7E5 		strb	r5, [r7, #40]
1351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10341              		.loc 1 1351 0
 10342 5874 2930C7E5 		strb	r3, [r7, #41]
1353:../uvc.c      **** 			  break;
 10343              		.loc 1 1353 0
 10344 5878 24308DE5 		str	r3, [sp, #36]
 10345 587c 0450A0E1 		mov	r5, r4
 10346              	.LVL1222:
1352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10347              		.loc 1 1352 0
 10348 5880 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10349              	.LVL1223:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10350              		.loc 1 1334 0
 10351 5884 FF40A0E3 		mov	r4, #255
1353:../uvc.c      **** 			  break;
 10352              		.loc 1 1353 0
 10353 5888 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10354              	.LVL1224:
 10355 588c 24209DE5 		ldr	r2, [sp, #36]
 10356 5890 DAFCFFEA 		b	.L677
 10357              	.LVL1225:
 10358              	.L667:
2953:../uvc.c      **** 			  break;
 10359              		.loc 1 2953 0
 10360 5894 0000A0E3 		mov	r0, #0
 10361 5898 0020A0E1 		mov	r2, r0
 10362 589c 0110A0E3 		mov	r1, #1
 10363 58a0 FEFFFFEB 		bl	CyU3PUsbStall
 10364              	.LVL1226:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10365              		.loc 1 1334 0
 10366 58a4 FF40A0E3 		mov	r4, #255
 10367              	.LVL1227:
2953:../uvc.c      **** 			  break;
 10368              		.loc 1 2953 0
 10369 58a8 0010A0E3 		mov	r1, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10370              		.loc 1 1334 0
 10371 58ac 04C0A0E1 		mov	ip, r4
2953:../uvc.c      **** 			  break;
 10372              		.loc 1 2953 0
 10373 58b0 24108DE5 		str	r1, [sp, #36]
 10374 58b4 0150A0E1 		mov	r5, r1
 10375              	.LVL1228:
 10376 58b8 0120A0E1 		mov	r2, r1
 10377 58bc CFFCFFEA 		b	.L677
 10378              	.LVL1229:
 10379              	.L668:
1925:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10380              		.loc 1 1925 0
 10381 58c0 44E81FE5 		ldr	lr, .L1038+116
1924:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10382              		.loc 1 1924 0
 10383 58c4 020055E3 		cmp	r5, #2
1929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10384              		.loc 1 1929 0
 10385 58c8 35C7DE15 		ldrneb	ip, [lr, #1845]	@ zero_extendqisi2
1931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10386              		.loc 1 1931 0
 10387 58cc 3627DE15 		ldrneb	r2, [lr, #1846]	@ zero_extendqisi2
1924:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10388              		.loc 1 1924 0
 10389 58d0 4BFBFF1A 		bne	.L987
1925:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10390              		.loc 1 1925 0
 10391 58d4 3527DEE5 		ldrb	r2, [lr, #1845]	@ zero_extendqisi2
1926:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10392              		.loc 1 1926 0
 10393 58d8 3637DEE5 		ldrb	r3, [lr, #1846]	@ zero_extendqisi2
 10394              	.L964:
1939:../uvc.c      **** 				  }else{
 10395              		.loc 1 1939 0
 10396 58dc 0040A0E3 		mov	r4, #0
 10397              	.LVL1230:
1936:../uvc.c      **** 				  if(Len == 2){
 10398              		.loc 1 1936 0
 10399 58e0 0500A0E1 		mov	r0, r5
 10400 58e4 64181FE5 		ldr	r1, .L1038+120
1925:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10401              		.loc 1 1925 0
 10402 58e8 2820C7E5 		strb	r2, [r7, #40]
1926:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10403              		.loc 1 1926 0
 10404 58ec 2930C7E5 		strb	r3, [r7, #41]
1939:../uvc.c      **** 				  }else{
 10405              		.loc 1 1939 0
 10406 58f0 24408DE5 		str	r4, [sp, #36]
 10407 58f4 D5FEFFEA 		b	.L966
 10408              	.LVL1231:
 10409              	.L674:
1953:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10410              		.loc 1 1953 0
 10411 58f8 37C7D9E5 		ldrb	ip, [r9, #1847]	@ zero_extendqisi2
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10412              		.loc 1 1958 0
 10413 58fc 7C181FE5 		ldr	r1, .L1038+120
1954:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10414              		.loc 1 1954 0
 10415 5900 3827D9E5 		ldrb	r2, [r9, #1848]	@ zero_extendqisi2
1955:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10416              		.loc 1 1955 0
 10417 5904 0030A0E3 		mov	r3, #0
1953:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10418              		.loc 1 1953 0
 10419 5908 28C0C7E5 		strb	ip, [r7, #40]
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10420              		.loc 1 1958 0
 10421 590c 0500A0E1 		mov	r0, r5
1960:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 10422              		.loc 1 1960 0
 10423 5910 03C0A0E1 		mov	ip, r3
1954:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10424              		.loc 1 1954 0
 10425 5914 2920C7E5 		strb	r2, [r7, #41]
1955:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10426              		.loc 1 1955 0
 10427 5918 2A30C7E5 		strb	r3, [r7, #42]
1956:../uvc.c      **** 		 	 }
 10428              		.loc 1 1956 0
 10429 591c 2B30C7E5 		strb	r3, [r7, #43]
 10430              	.LVL1232:
 10431              	.L967:
1960:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 10432              		.loc 1 1960 0
 10433 5920 24C08DE5 		str	ip, [sp, #36]
 10434 5924 C9FEFFEA 		b	.L966
 10435              	.LVL1233:
 10436              	.L670:
1827:../uvc.c      **** 			 	 			 if(Len == 2)
 10437              		.loc 1 1827 0
 10438 5928 AE30D7E5 		ldrb	r3, [r7, #174]	@ zero_extendqisi2
 10439 592c 000053E3 		cmp	r3, #0
 10440 5930 5D01000A 		beq	.L678
1828:../uvc.c      **** 			 	 			 {
 10441              		.loc 1 1828 0
 10442 5934 020055E3 		cmp	r5, #2
 10443 5938 C301000A 		beq	.L1027
1834:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10444              		.loc 1 1834 0
 10445 593c 040055E3 		cmp	r5, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10446              		.loc 1 1334 0
 10447 5940 FF40A013 		movne	r4, #255
 10448              	.LVL1234:
 10449 5944 04C0A011 		movne	ip, r4
1834:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10450              		.loc 1 1834 0
 10451 5948 5F01001A 		bne	.L680
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10452              		.loc 1 1835 0
 10453 594c 3D27D9E5 		ldrb	r2, [r9, #1853]	@ zero_extendqisi2
1837:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10454              		.loc 1 1837 0
 10455 5950 3E47D9E5 		ldrb	r4, [r9, #1854]	@ zero_extendqisi2
1836:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10456              		.loc 1 1836 0
 10457 5954 0030A0E3 		mov	r3, #0
1837:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10458              		.loc 1 1837 0
 10459 5958 FF4004E2 		and	r4, r4, #255
1835:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10460              		.loc 1 1835 0
 10461 595c 2820C7E5 		strb	r2, [r7, #40]
1837:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10462              		.loc 1 1837 0
 10463 5960 2A40C7E5 		strb	r4, [r7, #42]
1839:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10464              		.loc 1 1839 0
 10465 5964 FFC002E2 		and	ip, r2, #255
 10466              	.LVL1235:
1836:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10467              		.loc 1 1836 0
 10468 5968 2930C7E5 		strb	r3, [r7, #41]
1838:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10469              		.loc 1 1838 0
 10470 596c 2B30C7E5 		strb	r3, [r7, #43]
 10471 5970 550100EA 		b	.L680
 10472              	.LVL1236:
 10473              	.L817:
 10474              	.LBE350:
 10475              	.LBE358:
 10476              	.LBE370:
 10477              	.LBE451:
 10478              	.LBB452:
 10479              	.LBB341:
 10480              	.LBB297:
 10481              	.LBB258:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10482              		.loc 1 2996 0
 10483 5974 F8C81FE5 		ldr	ip, .L1038+116
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10484              		.loc 1 2998 0
 10485 5978 0020A0E3 		mov	r2, #0
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10486              		.loc 1 2997 0
 10487 597c AE16DCE5 		ldrb	r1, [ip, #1710]	@ zero_extendqisi2
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10488              		.loc 1 2996 0
 10489 5980 AD36DCE5 		ldrb	r3, [ip, #1709]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10490              		.loc 1 2997 0
 10491 5984 2910C7E5 		strb	r1, [r7, #41]
3004:../uvc.c      **** 
 10492              		.loc 1 3004 0
 10493 5988 0600A0E1 		mov	r0, r6
 10494 598c 0C191FE5 		ldr	r1, .L1038+120
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10495              		.loc 1 2976 0
 10496 5990 FF40A0E3 		mov	r4, #255
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10497              		.loc 1 2996 0
 10498 5994 2830C7E5 		strb	r3, [r7, #40]
3004:../uvc.c      **** 
 10499              		.loc 1 3004 0
 10500 5998 1C308DE5 		str	r3, [sp, #28]
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10501              		.loc 1 2998 0
 10502 599c 2A20C7E5 		strb	r2, [r7, #42]
2999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10503              		.loc 1 2999 0
 10504 59a0 2B20C7E5 		strb	r2, [r7, #43]
 10505              	.LVL1237:
3004:../uvc.c      **** 
 10506              		.loc 1 3004 0
 10507 59a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10508              	.LVL1238:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10509              		.loc 1 2976 0
 10510 59a8 24408DE5 		str	r4, [sp, #36]
 10511 59ac 1C309DE5 		ldr	r3, [sp, #28]
 10512 59b0 59FCFFEA 		b	.L824
 10513              	.LVL1239:
 10514              	.L806:
 10515              	.LBE258:
 10516              	.LBE297:
 10517              	.LBB298:
 10518              	.LBB241:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10519              		.loc 1 2996 0
 10520 59b4 38E91FE5 		ldr	lr, .L1038+116
 10521 59b8 9546DEE5 		ldrb	r4, [lr, #1685]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10522              		.loc 1 2997 0
 10523 59bc 9626DEE5 		ldrb	r2, [lr, #1686]	@ zero_extendqisi2
 10524              	.LVL1240:
 10525              	.L988:
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10526              		.loc 1 2998 0
 10527 59c0 0030A0E3 		mov	r3, #0
3004:../uvc.c      **** 
 10528              		.loc 1 3004 0
 10529 59c4 0600A0E1 		mov	r0, r6
 10530 59c8 48191FE5 		ldr	r1, .L1038+120
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10531              		.loc 1 2996 0
 10532 59cc 2840C7E5 		strb	r4, [r7, #40]
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10533              		.loc 1 2997 0
 10534 59d0 2920C7E5 		strb	r2, [r7, #41]
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10535              		.loc 1 2998 0
 10536 59d4 2A30C7E5 		strb	r3, [r7, #42]
2999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10537              		.loc 1 2999 0
 10538 59d8 2B30C7E5 		strb	r3, [r7, #43]
 10539              	.LVL1241:
3004:../uvc.c      **** 
 10540              		.loc 1 3004 0
 10541 59dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10542              	.LVL1242:
 10543 59e0 E3FDFFEA 		b	.L813
 10544              	.LVL1243:
 10545              	.L815:
 10546              	.LBE241:
 10547              	.LBE298:
 10548              	.LBB299:
 10549              	.LBB259:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10550              		.loc 1 3020 0
 10551 59e4 68E91FE5 		ldr	lr, .L1038+116
 10552 59e8 A506DEE5 		ldrb	r0, [lr, #1701]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10553              		.loc 1 3021 0
 10554 59ec A616DEE5 		ldrb	r1, [lr, #1702]	@ zero_extendqisi2
 10555 59f0 3DFCFFEA 		b	.L978
 10556              	.L814:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10557              		.loc 1 3189 0
 10558 59f4 0000A0E3 		mov	r0, #0
 10559 59f8 0020A0E1 		mov	r2, r0
 10560 59fc 0110A0E3 		mov	r1, #1
 10561 5a00 FEFFFFEB 		bl	CyU3PUsbStall
 10562              	.LVL1244:
3190:../uvc.c      **** 			  break;
 10563              		.loc 1 3190 0
 10564 5a04 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10565 5a08 0400A0E3 		mov	r0, #4
 10566 5a0c 94191FE5 		ldr	r1, .L1038+112
 10567 5a10 0A20A0E3 		mov	r2, #10
 10568 5a14 FEFFFFEB 		bl	CyU3PDebugPrint
 10569              	.LVL1245:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10570              		.loc 1 2976 0
 10571 5a18 FF30A0E3 		mov	r3, #255
 10572 5a1c 0340A0E1 		mov	r4, r3
 10573 5a20 24308DE5 		str	r3, [sp, #36]
 10574 5a24 3CFCFFEA 		b	.L824
 10575              	.LVL1246:
 10576              	.L764:
 10577              	.LBE259:
 10578              	.LBE299:
 10579              	.LBB300:
 10580              	.LBB230:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10581              		.loc 1 3029 0
 10582 5a28 AC491FE5 		ldr	r4, .L1038+116
 10583 5a2c 2F16D4E5 		ldrb	r1, [r4, #1583]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10584              		.loc 1 3030 0
 10585 5a30 3026D4E5 		ldrb	r2, [r4, #1584]	@ zero_extendqisi2
 10586 5a34 DDFBFFEA 		b	.L976
 10587              	.LVL1247:
 10588              	.L821:
 10589              	.LBE230:
 10590              	.LBE300:
 10591              	.LBB301:
 10592              	.LBB260:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10593              		.loc 1 3029 0
 10594 5a38 A706D9E5 		ldrb	r0, [r9, #1703]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10595              		.loc 1 3030 0
 10596 5a3c A816D9E5 		ldrb	r1, [r9, #1704]	@ zero_extendqisi2
 10597 5a40 29FCFFEA 		b	.L978
 10598              	.L820:
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10599              		.loc 1 2987 0
 10600 5a44 0030A0E3 		mov	r3, #0
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10601              		.loc 1 2988 0
 10602 5a48 0200A0E3 		mov	r0, #2
 10603 5a4c CC191FE5 		ldr	r1, .L1038+120
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10604              		.loc 1 2976 0
 10605 5a50 FF40A0E3 		mov	r4, #255
2987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10606              		.loc 1 2987 0
 10607 5a54 2930C7E5 		strb	r3, [r7, #41]
2986:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10608              		.loc 1 2986 0
 10609 5a58 2860C7E5 		strb	r6, [r7, #40]
2988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10610              		.loc 1 2988 0
 10611 5a5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10612              	.LVL1248:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10613              		.loc 1 2976 0
 10614 5a60 24408DE5 		str	r4, [sp, #36]
2989:../uvc.c      **** 			  break;
 10615              		.loc 1 2989 0
 10616 5a64 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 10617              	.LVL1249:
 10618 5a68 2BFCFFEA 		b	.L824
 10619              	.LVL1250:
 10620              	.L810:
 10621              	.LBE260:
 10622              	.LBE301:
 10623              	.LBB302:
 10624              	.LBB242:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10625              		.loc 1 3029 0
 10626 5a6c F0491FE5 		ldr	r4, .L1038+116
 10627 5a70 8F16D4E5 		ldrb	r1, [r4, #1679]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10628              		.loc 1 3030 0
 10629 5a74 9026D4E5 		ldrb	r2, [r4, #1680]	@ zero_extendqisi2
 10630 5a78 CCFBFFEA 		b	.L976
 10631              	.LVL1251:
 10632              	.L779:
 10633              	.LBE242:
 10634              	.LBE302:
 10635              	.LBB303:
 10636              	.LBB219:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10637              		.loc 1 3189 0
 10638 5a7c 0000A0E3 		mov	r0, #0
 10639 5a80 0020A0E1 		mov	r2, r0
 10640 5a84 0110A0E3 		mov	r1, #1
 10641 5a88 FEFFFFEB 		bl	CyU3PUsbStall
 10642              	.LVL1252:
3190:../uvc.c      **** 			  break;
 10643              		.loc 1 3190 0
 10644 5a8c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10645 5a90 0720A0E3 		mov	r2, #7
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10646              		.loc 1 2976 0
 10647 5a94 FF40A0E3 		mov	r4, #255
3190:../uvc.c      **** 			  break;
 10648              		.loc 1 3190 0
 10649 5a98 0400A0E3 		mov	r0, #4
 10650 5a9c 241A1FE5 		ldr	r1, .L1038+112
 10651 5aa0 FEFFFFEB 		bl	CyU3PDebugPrint
 10652              	.LVL1253:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10653              		.loc 1 2976 0
 10654 5aa4 0420A0E1 		mov	r2, r4
 10655 5aa8 0430A0E1 		mov	r3, r4
 10656 5aac 50FEFFEA 		b	.L789
 10657              	.LVL1254:
 10658              	.L731:
 10659              	.LBE219:
 10660              	.LBE303:
 10661              	.LBB304:
 10662              	.LBB209:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10663              		.loc 1 3189 0
 10664 5ab0 0000A0E3 		mov	r0, #0
 10665 5ab4 0020A0E1 		mov	r2, r0
 10666 5ab8 0110A0E3 		mov	r1, #1
 10667 5abc FEFFFFEB 		bl	CyU3PUsbStall
 10668              	.LVL1255:
3190:../uvc.c      **** 			  break;
 10669              		.loc 1 3190 0
 10670 5ac0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10671 5ac4 0320A0E3 		mov	r2, #3
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10672              		.loc 1 2976 0
 10673 5ac8 FF40A0E3 		mov	r4, #255
3190:../uvc.c      **** 			  break;
 10674              		.loc 1 3190 0
 10675 5acc 0400A0E3 		mov	r0, #4
 10676 5ad0 581A1FE5 		ldr	r1, .L1038+112
 10677 5ad4 FEFFFFEB 		bl	CyU3PDebugPrint
 10678              	.LVL1256:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10679              		.loc 1 2976 0
 10680 5ad8 0420A0E1 		mov	r2, r4
 10681 5adc 0430A0E1 		mov	r3, r4
 10682              	.LVL1257:
 10683 5ae0 43FEFFEA 		b	.L789
 10684              	.LVL1258:
 10685              	.L795:
 10686              	.LBE209:
 10687              	.LBE304:
 10688              	.LBB305:
 10689              	.LBB249:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10690              		.loc 1 2996 0
 10691 5ae4 7D46D9E5 		ldrb	r4, [r9, #1661]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10692              		.loc 1 2997 0
 10693 5ae8 7E26D9E5 		ldrb	r2, [r9, #1662]	@ zero_extendqisi2
 10694 5aec B3FFFFEA 		b	.L988
 10695              	.LVL1259:
 10696              	.L753:
 10697              	.LBE249:
 10698              	.LBE305:
 10699              	.LBB306:
 10700              	.LBB175:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10701              		.loc 1 3029 0
 10702 5af0 1716D9E5 		ldrb	r1, [r9, #1559]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10703              		.loc 1 3030 0
 10704 5af4 1826D9E5 		ldrb	r2, [r9, #1560]	@ zero_extendqisi2
 10705 5af8 ACFBFFEA 		b	.L976
 10706              	.LVL1260:
 10707              	.L799:
 10708              	.LBE175:
 10709              	.LBE306:
 10710              	.LBB307:
 10711              	.LBB250:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10712              		.loc 1 3029 0
 10713 5afc 7716D9E5 		ldrb	r1, [r9, #1655]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10714              		.loc 1 3030 0
 10715 5b00 7826D9E5 		ldrb	r2, [r9, #1656]	@ zero_extendqisi2
 10716 5b04 A9FBFFEA 		b	.L976
 10717              	.LVL1261:
 10718              	.L710:
 10719              	.LBE250:
 10720              	.LBE307:
 10721              	.LBB308:
 10722              	.LBB200:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10723              		.loc 1 3020 0
 10724 5b08 8C2A1FE5 		ldr	r2, .L1038+116
 10725 5b0c B515D2E5 		ldrb	r1, [r2, #1461]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10726              		.loc 1 3021 0
 10727 5b10 B625D2E5 		ldrb	r2, [r2, #1462]	@ zero_extendqisi2
 10728 5b14 A5FBFFEA 		b	.L976
 10729              	.LVL1262:
 10730              	.L769:
 10731              	.LBE200:
 10732              	.LBE308:
 10733              	.LBB309:
 10734              	.LBB192:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10735              		.loc 1 3020 0
 10736 5b18 9C2A1FE5 		ldr	r2, .L1038+116
 10737 5b1c 4516D2E5 		ldrb	r1, [r2, #1605]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10738              		.loc 1 3021 0
 10739 5b20 4626D2E5 		ldrb	r2, [r2, #1606]	@ zero_extendqisi2
 10740 5b24 A1FBFFEA 		b	.L976
 10741              	.LVL1263:
 10742              	.L723:
 10743              	.LBE192:
 10744              	.LBE309:
 10745              	.LBB310:
 10746              	.LBB183:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10747              		.loc 1 2996 0
 10748 5b28 ACCA1FE5 		ldr	ip, .L1038+116
 10749 5b2c ED45DCE5 		ldrb	r4, [ip, #1517]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10750              		.loc 1 2997 0
 10751 5b30 EE25DCE5 		ldrb	r2, [ip, #1518]	@ zero_extendqisi2
 10752 5b34 A1FFFFEA 		b	.L988
 10753              	.LVL1264:
 10754              	.L734:
 10755              	.LBE183:
 10756              	.LBE310:
 10757              	.LBB311:
 10758              	.LBB210:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10759              		.loc 1 2996 0
 10760 5b38 BCEA1FE5 		ldr	lr, .L1038+116
 10761 5b3c 0546DEE5 		ldrb	r4, [lr, #1541]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10762              		.loc 1 2997 0
 10763 5b40 0626DEE5 		ldrb	r2, [lr, #1542]	@ zero_extendqisi2
 10764              	.LVL1265:
 10765              	.L991:
 10766              	.LBE210:
 10767              	.LBE311:
 10768              	.LBB312:
 10769              	.LBB220:
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10770              		.loc 1 2998 0
 10771 5b44 0030A0E3 		mov	r3, #0
3004:../uvc.c      **** 
 10772              		.loc 1 3004 0
 10773 5b48 0600A0E1 		mov	r0, r6
 10774 5b4c CC1A1FE5 		ldr	r1, .L1038+120
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10775              		.loc 1 2997 0
 10776 5b50 2920C7E5 		strb	r2, [r7, #41]
2998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10777              		.loc 1 2998 0
 10778 5b54 2A30C7E5 		strb	r3, [r7, #42]
2999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10779              		.loc 1 2999 0
 10780 5b58 2B30C7E5 		strb	r3, [r7, #43]
 10781              	.LVL1266:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10782              		.loc 1 2996 0
 10783 5b5c 2840C7E5 		strb	r4, [r7, #40]
3004:../uvc.c      **** 
 10784              		.loc 1 3004 0
 10785 5b60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10786              	.LVL1267:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10787              		.loc 1 2976 0
 10788 5b64 FF20A0E3 		mov	r2, #255
 10789 5b68 0230A0E1 		mov	r3, r2
 10790 5b6c 20FEFFEA 		b	.L789
 10791              	.LVL1268:
 10792              	.L749:
 10793              	.LBE220:
 10794              	.LBE312:
 10795              	.LBB313:
 10796              	.LBB176:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10797              		.loc 1 2996 0
 10798 5b70 F4CA1FE5 		ldr	ip, .L1038+116
 10799 5b74 1D46DCE5 		ldrb	r4, [ip, #1565]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10800              		.loc 1 2997 0
 10801 5b78 1E26DCE5 		ldrb	r2, [ip, #1566]	@ zero_extendqisi2
 10802 5b7c 8FFFFFEA 		b	.L988
 10803              	.LVL1269:
 10804              	.L712:
 10805              	.LBE176:
 10806              	.LBE313:
 10807              	.LBB314:
 10808              	.LBB201:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10809              		.loc 1 2996 0
 10810 5b80 04CB1FE5 		ldr	ip, .L1038+116
 10811 5b84 BD45DCE5 		ldrb	r4, [ip, #1469]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10812              		.loc 1 2997 0
 10813 5b88 BE25DCE5 		ldrb	r2, [ip, #1470]	@ zero_extendqisi2
 10814 5b8c 8BFFFFEA 		b	.L988
 10815              	.LVL1270:
 10816              	.L771:
 10817              	.LBE201:
 10818              	.LBE314:
 10819              	.LBB315:
 10820              	.LBB193:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10821              		.loc 1 2996 0
 10822 5b90 14CB1FE5 		ldr	ip, .L1038+116
 10823 5b94 4D46DCE5 		ldrb	r4, [ip, #1613]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10824              		.loc 1 2997 0
 10825 5b98 4E26DCE5 		ldrb	r2, [ip, #1614]	@ zero_extendqisi2
 10826 5b9c 87FFFFEA 		b	.L988
 10827              	.LVL1271:
 10828              	.L760:
 10829              	.LBE193:
 10830              	.LBE315:
 10831              	.LBB316:
 10832              	.LBB231:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10833              		.loc 1 2996 0
 10834 5ba0 241B1FE5 		ldr	r1, .L1038+116
 10835 5ba4 3546D1E5 		ldrb	r4, [r1, #1589]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10836              		.loc 1 2997 0
 10837 5ba8 3626D1E5 		ldrb	r2, [r1, #1590]	@ zero_extendqisi2
 10838 5bac 83FFFFEA 		b	.L988
 10839              	.LVL1272:
 10840              	.L782:
 10841              	.LBE231:
 10842              	.LBE316:
 10843              	.LBB317:
 10844              	.LBB221:
2996:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10845              		.loc 1 2996 0
 10846 5bb0 34CB1FE5 		ldr	ip, .L1038+116
 10847 5bb4 6546DCE5 		ldrb	r4, [ip, #1637]	@ zero_extendqisi2
2997:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10848              		.loc 1 2997 0
 10849 5bb8 6626DCE5 		ldrb	r2, [ip, #1638]	@ zero_extendqisi2
 10850 5bbc E0FFFFEA 		b	.L991
 10851              	.LVL1273:
 10852              	.L727:
 10853              	.LBE221:
 10854              	.LBE317:
 10855              	.LBB318:
 10856              	.LBB184:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10857              		.loc 1 3029 0
 10858 5bc0 443B1FE5 		ldr	r3, .L1038+116
 10859 5bc4 E715D3E5 		ldrb	r1, [r3, #1511]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10860              		.loc 1 3030 0
 10861 5bc8 E825D3E5 		ldrb	r2, [r3, #1512]	@ zero_extendqisi2
 10862 5bcc 77FBFFEA 		b	.L976
 10863              	.LVL1274:
 10864              	.L757:
 10865              	.LBE184:
 10866              	.LBE318:
 10867              	.LBB319:
 10868              	.LBB232:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10869              		.loc 1 3189 0
 10870 5bd0 0000A0E3 		mov	r0, #0
 10871 5bd4 0020A0E1 		mov	r2, r0
 10872 5bd8 0110A0E3 		mov	r1, #1
 10873 5bdc FEFFFFEB 		bl	CyU3PUsbStall
 10874              	.LVL1275:
3190:../uvc.c      **** 			  break;
 10875              		.loc 1 3190 0
 10876 5be0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 10877 5be4 0400A0E3 		mov	r0, #4
 10878 5be8 701B1FE5 		ldr	r1, .L1038+112
 10879 5bec 0520A0E3 		mov	r2, #5
 10880 5bf0 FEFFFFEB 		bl	CyU3PDebugPrint
 10881              	.LVL1276:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10882              		.loc 1 2976 0
 10883 5bf4 FF40A0E3 		mov	r4, #255
 10884              	.LVL1277:
 10885 5bf8 5DFDFFEA 		b	.L813
 10886              	.LVL1278:
 10887              	.L786:
 10888              	.LBE232:
 10889              	.LBE319:
 10890              	.LBB320:
 10891              	.LBB222:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10892              		.loc 1 3029 0
 10893 5bfc 803B1FE5 		ldr	r3, .L1038+116
 10894 5c00 5F16D3E5 		ldrb	r1, [r3, #1631]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10895              		.loc 1 3030 0
 10896 5c04 6026D3E5 		ldrb	r2, [r3, #1632]	@ zero_extendqisi2
 10897 5c08 39FBFFEA 		b	.L974
 10898              	.LVL1279:
 10899              	.L747:
 10900              	.LBE222:
 10901              	.LBE320:
 10902              	.LBB321:
 10903              	.LBB177:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10904              		.loc 1 3020 0
 10905 5c0c 90EB1FE5 		ldr	lr, .L1038+116
 10906 5c10 1516DEE5 		ldrb	r1, [lr, #1557]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10907              		.loc 1 3021 0
 10908 5c14 1626DEE5 		ldrb	r2, [lr, #1558]	@ zero_extendqisi2
 10909 5c18 64FBFFEA 		b	.L976
 10910              	.LVL1280:
 10911              	.L732:
 10912              	.LBE177:
 10913              	.LBE321:
 10914              	.LBB322:
 10915              	.LBB211:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10916              		.loc 1 3020 0
 10917 5c1c A03B1FE5 		ldr	r3, .L1038+116
 10918 5c20 FD15D3E5 		ldrb	r1, [r3, #1533]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10919              		.loc 1 3021 0
 10920 5c24 FE25D3E5 		ldrb	r2, [r3, #1534]	@ zero_extendqisi2
 10921 5c28 31FBFFEA 		b	.L974
 10922              	.LVL1281:
 10923              	.L793:
 10924              	.LBE211:
 10925              	.LBE322:
 10926              	.LBB323:
 10927              	.LBB251:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10928              		.loc 1 3020 0
 10929 5c2c B0CB1FE5 		ldr	ip, .L1038+116
 10930 5c30 7516DCE5 		ldrb	r1, [ip, #1653]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10931              		.loc 1 3021 0
 10932 5c34 7626DCE5 		ldrb	r2, [ip, #1654]	@ zero_extendqisi2
 10933 5c38 5CFBFFEA 		b	.L976
 10934              	.LVL1282:
 10935              	.L804:
 10936              	.LBE251:
 10937              	.LBE323:
 10938              	.LBB324:
 10939              	.LBB243:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10940              		.loc 1 3020 0
 10941 5c3c C03B1FE5 		ldr	r3, .L1038+116
 10942 5c40 8D16D3E5 		ldrb	r1, [r3, #1677]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10943              		.loc 1 3021 0
 10944 5c44 8E26D3E5 		ldrb	r2, [r3, #1678]	@ zero_extendqisi2
 10945 5c48 58FBFFEA 		b	.L976
 10946              	.LVL1283:
 10947              	.L721:
 10948              	.LBE243:
 10949              	.LBE324:
 10950              	.LBB325:
 10951              	.LBB185:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10952              		.loc 1 3020 0
 10953 5c4c D02B1FE5 		ldr	r2, .L1038+116
 10954 5c50 E515D2E5 		ldrb	r1, [r2, #1509]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10955              		.loc 1 3021 0
 10956 5c54 E625D2E5 		ldrb	r2, [r2, #1510]	@ zero_extendqisi2
 10957 5c58 54FBFFEA 		b	.L976
 10958              	.LVL1284:
 10959              	.L780:
 10960              	.LBE185:
 10961              	.LBE325:
 10962              	.LBB326:
 10963              	.LBB223:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10964              		.loc 1 3020 0
 10965 5c5c E02B1FE5 		ldr	r2, .L1038+116
 10966 5c60 5D16D2E5 		ldrb	r1, [r2, #1629]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10967              		.loc 1 3021 0
 10968 5c64 5E26D2E5 		ldrb	r2, [r2, #1630]	@ zero_extendqisi2
 10969 5c68 21FBFFEA 		b	.L974
 10970              	.LVL1285:
 10971              	.L758:
 10972              	.LBE223:
 10973              	.LBE326:
 10974              	.LBB327:
 10975              	.LBB233:
3020:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10976              		.loc 1 3020 0
 10977 5c6c F03B1FE5 		ldr	r3, .L1038+116
 10978 5c70 2D16D3E5 		ldrb	r1, [r3, #1581]	@ zero_extendqisi2
3021:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10979              		.loc 1 3021 0
 10980 5c74 2E26D3E5 		ldrb	r2, [r3, #1582]	@ zero_extendqisi2
 10981 5c78 4CFBFFEA 		b	.L976
 10982              	.LVL1286:
 10983              	.L738:
 10984              	.LBE233:
 10985              	.LBE327:
 10986              	.LBB328:
 10987              	.LBB212:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10988              		.loc 1 3029 0
 10989 5c7c 004C1FE5 		ldr	r4, .L1038+116
 10990 5c80 FF15D4E5 		ldrb	r1, [r4, #1535]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10991              		.loc 1 3030 0
 10992 5c84 0026D4E5 		ldrb	r2, [r4, #1536]	@ zero_extendqisi2
 10993 5c88 19FBFFEA 		b	.L974
 10994              	.LVL1287:
 10995              	.L720:
 10996              	.LBE212:
 10997              	.LBE328:
 10998              	.LBB329:
 10999              	.LBB186:
3189:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11000              		.loc 1 3189 0
 11001 5c8c 0000A0E3 		mov	r0, #0
 11002 5c90 0020A0E1 		mov	r2, r0
 11003 5c94 0110A0E3 		mov	r1, #1
 11004 5c98 FEFFFFEB 		bl	CyU3PUsbStall
 11005              	.LVL1288:
3190:../uvc.c      **** 			  break;
 11006              		.loc 1 3190 0
 11007 5c9c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 11008 5ca0 0400A0E3 		mov	r0, #4
 11009 5ca4 2C1C1FE5 		ldr	r1, .L1038+112
 11010 5ca8 0220A0E3 		mov	r2, #2
 11011 5cac FEFFFFEB 		bl	CyU3PDebugPrint
 11012              	.LVL1289:
2976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11013              		.loc 1 2976 0
 11014 5cb0 FF40A0E3 		mov	r4, #255
 11015              	.LVL1290:
 11016 5cb4 2EFDFFEA 		b	.L813
 11017              	.LVL1291:
 11018              	.L775:
 11019              	.LBE186:
 11020              	.LBE329:
 11021              	.LBB330:
 11022              	.LBB194:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11023              		.loc 1 3029 0
 11024 5cb8 3C3C1FE5 		ldr	r3, .L1038+116
 11025 5cbc 4716D3E5 		ldrb	r1, [r3, #1607]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11026              		.loc 1 3030 0
 11027 5cc0 4826D3E5 		ldrb	r2, [r3, #1608]	@ zero_extendqisi2
 11028 5cc4 39FBFFEA 		b	.L976
 11029              	.LVL1292:
 11030              	.L716:
 11031              	.LBE194:
 11032              	.LBE330:
 11033              	.LBB331:
 11034              	.LBB202:
3029:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11035              		.loc 1 3029 0
 11036 5cc8 4C3C1FE5 		ldr	r3, .L1038+116
 11037 5ccc B715D3E5 		ldrb	r1, [r3, #1463]	@ zero_extendqisi2
3030:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11038              		.loc 1 3030 0
 11039 5cd0 B825D3E5 		ldrb	r2, [r3, #1464]	@ zero_extendqisi2
 11040 5cd4 35FBFFEA 		b	.L976
 11041              	.LVL1293:
 11042              	.L895:
 11043              	.LBE202:
 11044              	.LBE331:
 11045              	.LBE341:
 11046              	.LBE452:
 11047              	.LBB453:
 11048              	.LBB425:
 11049              	.LBB405:
 11050              	.LBB394:
1875:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11051              		.loc 1 1875 0
 11052 5cd8 020056E3 		cmp	r6, #2
1876:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11053              		.loc 1 1876 0
 11054 5cdc 5B27D905 		ldreqb	r2, [r9, #1883]	@ zero_extendqisi2
1900:../uvc.c      **** 		 	 if(Len == 2){
 11055              		.loc 1 1900 0
 11056 5ce0 0200A003 		moveq	r0, #2
1877:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11057              		.loc 1 1877 0
 11058 5ce4 5C37D905 		ldreqb	r3, [r9, #1884]	@ zero_extendqisi2
1875:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11059              		.loc 1 1875 0
 11060 5ce8 0A00000A 		beq	.L982
1881:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11061              		.loc 1 1881 0
 11062 5cec 5BC7D9E5 		ldrb	ip, [r9, #1883]	@ zero_extendqisi2
1883:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11063              		.loc 1 1883 0
 11064 5cf0 5C27D9E5 		ldrb	r2, [r9, #1884]	@ zero_extendqisi2
 11065 5cf4 6CFDFFEA 		b	.L983
 11066              	.L892:
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11067              		.loc 1 1912 0
 11068 5cf8 7CEC1FE5 		ldr	lr, .L1038+116
1911:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11069              		.loc 1 1911 0
 11070 5cfc 020056E3 		cmp	r6, #2
1917:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11071              		.loc 1 1917 0
 11072 5d00 5DC7DE15 		ldrneb	ip, [lr, #1885]	@ zero_extendqisi2
1919:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11073              		.loc 1 1919 0
 11074 5d04 5E27DE15 		ldrneb	r2, [lr, #1886]	@ zero_extendqisi2
1911:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11075              		.loc 1 1911 0
 11076 5d08 67FDFF1A 		bne	.L983
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11077              		.loc 1 1912 0
 11078 5d0c 5D27DEE5 		ldrb	r2, [lr, #1885]	@ zero_extendqisi2
1913:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11079              		.loc 1 1913 0
 11080 5d10 5E37DEE5 		ldrb	r3, [lr, #1886]	@ zero_extendqisi2
 11081              	.L985:
1936:../uvc.c      **** 				  if(Len == 2){
 11082              		.loc 1 1936 0
 11083 5d14 0600A0E1 		mov	r0, r6
 11084              	.L982:
 11085 5d18 981C1FE5 		ldr	r1, .L1038+120
1912:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11086              		.loc 1 1912 0
 11087 5d1c 2820C7E5 		strb	r2, [r7, #40]
1913:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11088              		.loc 1 1913 0
 11089 5d20 2930C7E5 		strb	r3, [r7, #41]
 11090              	.LVL1294:
 11091              	.L984:
1939:../uvc.c      **** 				  }else{
 11092              		.loc 1 1939 0
 11093 5d24 00C0A0E3 		mov	ip, #0
 11094 5d28 24C08DE5 		str	ip, [sp, #36]
 11095 5d2c 0060A0E3 		mov	r6, #0
1936:../uvc.c      **** 				  if(Len == 2){
 11096              		.loc 1 1936 0
 11097 5d30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11098              	.LVL1295:
1938:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11099              		.loc 1 1938 0
 11100 5d34 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11101              	.LVL1296:
1939:../uvc.c      **** 				  }else{
 11102              		.loc 1 1939 0
 11103 5d38 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11104              	.LVL1297:
 11105 5d3c 4DFEFFEA 		b	.L901
 11106              	.LVL1298:
 11107              	.L894:
1636:../uvc.c      **** 			 	 			 if(Len == 2)
 11108              		.loc 1 1636 0
 11109 5d40 CA30D7E5 		ldrb	r3, [r7, #202]	@ zero_extendqisi2
 11110 5d44 000053E3 		cmp	r3, #0
 11111 5d48 A500001A 		bne	.L1028
1652:../uvc.c      **** 			 	 			 {
 11112              		.loc 1 1652 0
 11113 5d4c 020056E3 		cmp	r6, #2
 11114 5d50 2A02000A 		beq	.L1029
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11115              		.loc 1 1660 0
 11116 5d54 040056E3 		cmp	r6, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11117              		.loc 1 1334 0
 11118 5d58 FF50A013 		movne	r5, #255
 11119              	.LVL1299:
 11120 5d5c 05C0A011 		movne	ip, r5
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11121              		.loc 1 1660 0
 11122 5d60 1502000A 		beq	.L1030
 11123              	.LVL1300:
 11124              	.L906:
1670:../uvc.c      **** 			 	 		 }
 11125              		.loc 1 1670 0
 11126 5d64 0130A0E3 		mov	r3, #1
 11127 5d68 CA30C7E5 		strb	r3, [r7, #202]
 11128              	.LVL1301:
 11129              	.L904:
1867:../uvc.c      **** 
 11130              		.loc 1 1867 0
 11131 5d6c 0600A0E1 		mov	r0, r6
 11132 5d70 F01C1FE5 		ldr	r1, .L1038+120
 11133 5d74 20C08DE5 		str	ip, [sp, #32]
 11134 5d78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11135              	.LVL1302:
1870:../uvc.c      **** //#endif
 11136              		.loc 1 1870 0
 11137 5d7c 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11138 5d80 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11139 5d84 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11140 5d88 43008DE8 		stmia	sp, {r0, r1, r6}
 11141 5d8c 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11142 5d90 0400A0E3 		mov	r0, #4
 11143 5d94 101D1FE5 		ldr	r1, .L1038+124
 11144 5d98 FEFFFFEB 		bl	CyU3PDebugPrint
 11145              	.LVL1303:
 11146 5d9c 00E0A0E3 		mov	lr, #0
 11147 5da0 24E08DE5 		str	lr, [sp, #36]
 11148 5da4 0E60A0E1 		mov	r6, lr
 11149              	.LVL1304:
 11150 5da8 20C09DE5 		ldr	ip, [sp, #32]
 11151 5dac 31FEFFEA 		b	.L901
 11152              	.LVL1305:
 11153              	.L790:
 11154              	.LBE394:
 11155              	.LBE405:
 11156              	.LBE425:
 11157              	.LBE453:
 11158              	.LBB454:
 11159              	.LBB342:
 11160              	.LBB332:
 11161              	.LBB224:
3157:../uvc.c      **** 					  }
 11162              		.loc 1 3157 0
 11163 5db0 0020A0E1 		mov	r2, r0
 11164 5db4 0510A0E1 		mov	r1, r5
 11165 5db8 FEFFFFEB 		bl	CyU3PUsbStall
 11166              	.LVL1306:
 11167 5dbc 6BFCFFEA 		b	.L791
 11168              	.LVL1307:
 11169              	.L872:
 11170              	.LBE224:
 11171              	.LBE332:
 11172              	.LBE342:
 11173              	.LBE454:
 11174              	.LBB455:
 11175              	.LBB426:
 11176              	.LBB406:
 11177              	.LBB383:
1965:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11178              		.loc 1 1965 0
 11179 5dc0 4D27D9E5 		ldrb	r2, [r9, #1869]	@ zero_extendqisi2
1966:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11180              		.loc 1 1966 0
 11181 5dc4 0030A0E3 		mov	r3, #0
1977:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11182              		.loc 1 1977 0
 11183 5dc8 0100A0E3 		mov	r0, #1
 11184 5dcc 4C1D1FE5 		ldr	r1, .L1038+120
1965:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11185              		.loc 1 1965 0
 11186 5dd0 2820C7E5 		strb	r2, [r7, #40]
1966:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11187              		.loc 1 1966 0
 11188 5dd4 2930C7E5 		strb	r3, [r7, #41]
1967:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11189              		.loc 1 1967 0
 11190 5dd8 2A30C7E5 		strb	r3, [r7, #42]
1968:../uvc.c      **** 		 	 }
 11191              		.loc 1 1968 0
 11192 5ddc 2B30C7E5 		strb	r3, [r7, #43]
 11193              	.LVL1308:
 11194 5de0 43FEFFEA 		b	.L981
 11195              	.LVL1309:
 11196              	.L871:
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11197              		.loc 1 1947 0
 11198 5de4 4BC7D9E5 		ldrb	ip, [r9, #1867]	@ zero_extendqisi2
1948:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11199              		.loc 1 1948 0
 11200 5de8 4C27D9E5 		ldrb	r2, [r9, #1868]	@ zero_extendqisi2
1949:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11201              		.loc 1 1949 0
 11202 5dec 0030A0E3 		mov	r3, #0
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11203              		.loc 1 1958 0
 11204 5df0 0600A0E1 		mov	r0, r6
 11205 5df4 741D1FE5 		ldr	r1, .L1038+120
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11206              		.loc 1 1947 0
 11207 5df8 28C0C7E5 		strb	ip, [r7, #40]
1948:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11208              		.loc 1 1948 0
 11209 5dfc 2920C7E5 		strb	r2, [r7, #41]
1949:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11210              		.loc 1 1949 0
 11211 5e00 2A30C7E5 		strb	r3, [r7, #42]
1950:../uvc.c      **** 		 	 }
 11212              		.loc 1 1950 0
 11213 5e04 2B30C7E5 		strb	r3, [r7, #43]
 11214 5e08 39FEFFEA 		b	.L981
 11215              	.LVL1310:
 11216              	.L899:
 11217              	.LBE383:
 11218              	.LBE406:
 11219              	.LBB407:
 11220              	.LBB395:
1965:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11221              		.loc 1 1965 0
 11222 5e0c 6127D9E5 		ldrb	r2, [r9, #1889]	@ zero_extendqisi2
1966:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11223              		.loc 1 1966 0
 11224 5e10 0030A0E3 		mov	r3, #0
1977:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11225              		.loc 1 1977 0
 11226 5e14 0100A0E3 		mov	r0, #1
 11227 5e18 981D1FE5 		ldr	r1, .L1038+120
1965:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11228              		.loc 1 1965 0
 11229 5e1c 2820C7E5 		strb	r2, [r7, #40]
1966:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11230              		.loc 1 1966 0
 11231 5e20 2930C7E5 		strb	r3, [r7, #41]
1967:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11232              		.loc 1 1967 0
 11233 5e24 2A30C7E5 		strb	r3, [r7, #42]
1968:../uvc.c      **** 		 	 }
 11234              		.loc 1 1968 0
 11235 5e28 2B30C7E5 		strb	r3, [r7, #43]
 11236              	.LVL1311:
 11237 5e2c BCFFFFEA 		b	.L984
 11238              	.LVL1312:
 11239              	.L898:
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11240              		.loc 1 1947 0
 11241 5e30 B4ED1FE5 		ldr	lr, .L1038+116
1949:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11242              		.loc 1 1949 0
 11243 5e34 0030A0E3 		mov	r3, #0
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11244              		.loc 1 1947 0
 11245 5e38 5FC7DEE5 		ldrb	ip, [lr, #1887]	@ zero_extendqisi2
1948:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11246              		.loc 1 1948 0
 11247 5e3c 6027DEE5 		ldrb	r2, [lr, #1888]	@ zero_extendqisi2
1958:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11248              		.loc 1 1958 0
 11249 5e40 0600A0E1 		mov	r0, r6
 11250 5e44 C41D1FE5 		ldr	r1, .L1038+120
1947:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11251              		.loc 1 1947 0
 11252 5e48 28C0C7E5 		strb	ip, [r7, #40]
1948:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11253              		.loc 1 1948 0
 11254 5e4c 2920C7E5 		strb	r2, [r7, #41]
1949:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11255              		.loc 1 1949 0
 11256 5e50 2A30C7E5 		strb	r3, [r7, #42]
1950:../uvc.c      **** 		 	 }
 11257              		.loc 1 1950 0
 11258 5e54 2B30C7E5 		strb	r3, [r7, #43]
 11259 5e58 B1FFFFEA 		b	.L984
 11260              	.L891:
2953:../uvc.c      **** 			  break;
 11261              		.loc 1 2953 0
 11262 5e5c 0000A0E3 		mov	r0, #0
 11263 5e60 0110A0E3 		mov	r1, #1
 11264 5e64 0020A0E1 		mov	r2, r0
 11265 5e68 FEFFFFEB 		bl	CyU3PUsbStall
 11266              	.LVL1313:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11267              		.loc 1 1334 0
 11268 5e6c FF50A0E3 		mov	r5, #255
 11269              	.LVL1314:
2953:../uvc.c      **** 			  break;
 11270              		.loc 1 2953 0
 11271 5e70 0010A0E3 		mov	r1, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11272              		.loc 1 1334 0
 11273 5e74 05C0A0E1 		mov	ip, r5
2953:../uvc.c      **** 			  break;
 11274              		.loc 1 2953 0
 11275 5e78 24108DE5 		str	r1, [sp, #36]
 11276 5e7c 0160A0E1 		mov	r6, r1
 11277              	.LVL1315:
 11278 5e80 FCFDFFEA 		b	.L901
 11279              	.LVL1316:
 11280              	.L864:
 11281              	.LBE395:
 11282              	.LBE407:
 11283              	.LBB408:
 11284              	.LBB384:
 11285 5e84 0000A0E3 		mov	r0, #0
 11286 5e88 0110A0E3 		mov	r1, #1
 11287 5e8c 0020A0E1 		mov	r2, r0
 11288 5e90 FEFFFFEB 		bl	CyU3PUsbStall
 11289              	.LVL1317:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11290              		.loc 1 1334 0
 11291 5e94 FF50A0E3 		mov	r5, #255
 11292              	.LVL1318:
2953:../uvc.c      **** 			  break;
 11293              		.loc 1 2953 0
 11294 5e98 0010A0E3 		mov	r1, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11295              		.loc 1 1334 0
 11296 5e9c 05C0A0E1 		mov	ip, r5
2953:../uvc.c      **** 			  break;
 11297              		.loc 1 2953 0
 11298 5ea0 24108DE5 		str	r1, [sp, #36]
 11299 5ea4 0160A0E1 		mov	r6, r1
 11300              	.LVL1319:
 11301 5ea8 D8FDFFEA 		b	.L874
 11302              	.LVL1320:
 11303              	.L678:
 11304              	.LBE384:
 11305              	.LBE408:
 11306              	.LBE426:
 11307              	.LBE455:
 11308              	.LBB456:
 11309              	.LBB371:
 11310              	.LBB359:
 11311              	.LBB351:
1843:../uvc.c      **** 			 	 			 {
 11312              		.loc 1 1843 0
 11313 5eac 020055E3 		cmp	r5, #2
 11314 5eb0 3D01000A 		beq	.L1031
1851:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11315              		.loc 1 1851 0
 11316 5eb4 040055E3 		cmp	r5, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11317              		.loc 1 1334 0
 11318 5eb8 FF40A013 		movne	r4, #255
 11319              	.LVL1321:
 11320 5ebc 04C0A011 		movne	ip, r4
1851:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11321              		.loc 1 1851 0
 11322 5ec0 2801000A 		beq	.L1032
 11323              	.LVL1322:
 11324              	.L682:
1861:../uvc.c      **** 			 	 		 }
 11325              		.loc 1 1861 0
 11326 5ec4 0130A0E3 		mov	r3, #1
 11327 5ec8 AE30C7E5 		strb	r3, [r7, #174]
 11328              	.LVL1323:
 11329              	.L680:
1867:../uvc.c      **** 
 11330              		.loc 1 1867 0
 11331 5ecc 0500A0E1 		mov	r0, r5
 11332 5ed0 501E1FE5 		ldr	r1, .L1038+120
 11333 5ed4 20C08DE5 		str	ip, [sp, #32]
 11334 5ed8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11335              	.LVL1324:
1870:../uvc.c      **** //#endif
 11336              		.loc 1 1870 0
 11337 5edc 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11338 5ee0 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11339 5ee4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11340 5ee8 23008DE8 		stmia	sp, {r0, r1, r5}
 11341 5eec 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11342 5ef0 0400A0E3 		mov	r0, #4
 11343 5ef4 701E1FE5 		ldr	r1, .L1038+124
 11344 5ef8 FEFFFFEB 		bl	CyU3PDebugPrint
 11345              	.LVL1325:
 11346 5efc 00E0A0E3 		mov	lr, #0
 11347 5f00 24E08DE5 		str	lr, [sp, #36]
 11348 5f04 0E50A0E1 		mov	r5, lr
 11349              	.LVL1326:
 11350 5f08 20C09DE5 		ldr	ip, [sp, #32]
 11351 5f0c 0E20A0E1 		mov	r2, lr
 11352 5f10 3AFBFFEA 		b	.L677
 11353              	.LVL1327:
 11354              	.L868:
 11355              	.LBE351:
 11356              	.LBE359:
 11357              	.LBE371:
 11358              	.LBE456:
 11359              	.LBB457:
 11360              	.LBB427:
 11361              	.LBB409:
 11362              	.LBB385:
1875:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11363              		.loc 1 1875 0
 11364 5f14 020056E3 		cmp	r6, #2
1876:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11365              		.loc 1 1876 0
 11366 5f18 4727D905 		ldreqb	r2, [r9, #1863]	@ zero_extendqisi2
1900:../uvc.c      **** 		 	 if(Len == 2){
 11367              		.loc 1 1900 0
 11368 5f1c 0600A001 		moveq	r0, r6
1877:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11369              		.loc 1 1877 0
 11370 5f20 4837D905 		ldreqb	r3, [r9, #1864]	@ zero_extendqisi2
1875:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11371              		.loc 1 1875 0
 11372 5f24 EFFDFF0A 		beq	.L979
1881:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11373              		.loc 1 1881 0
 11374 5f28 47C7D9E5 		ldrb	ip, [r9, #1863]	@ zero_extendqisi2
1883:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11375              		.loc 1 1883 0
 11376 5f2c 4827D9E5 		ldrb	r2, [r9, #1864]	@ zero_extendqisi2
 11377 5f30 FBF9FFEA 		b	.L980
 11378              	.L867:
1636:../uvc.c      **** 			 	 			 if(Len == 2)
 11379              		.loc 1 1636 0
 11380 5f34 C930D7E5 		ldrb	r3, [r7, #201]	@ zero_extendqisi2
 11381 5f38 000053E3 		cmp	r3, #0
 11382 5f3c 1800001A 		bne	.L1033
1652:../uvc.c      **** 			 	 			 {
 11383              		.loc 1 1652 0
 11384 5f40 020056E3 		cmp	r6, #2
 11385 5f44 8201000A 		beq	.L1034
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11386              		.loc 1 1660 0
 11387 5f48 040056E3 		cmp	r6, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11388              		.loc 1 1334 0
 11389 5f4c FF50A013 		movne	r5, #255
 11390              	.LVL1328:
 11391 5f50 05C0A011 		movne	ip, r5
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11392              		.loc 1 1660 0
 11393 5f54 6C01000A 		beq	.L1035
 11394              	.LVL1329:
 11395              	.L879:
1670:../uvc.c      **** 			 	 		 }
 11396              		.loc 1 1670 0
 11397 5f58 0130A0E3 		mov	r3, #1
 11398 5f5c C930C7E5 		strb	r3, [r7, #201]
 11399              	.LVL1330:
 11400              	.L877:
1867:../uvc.c      **** 
 11401              		.loc 1 1867 0
 11402 5f60 0600A0E1 		mov	r0, r6
 11403 5f64 E41E1FE5 		ldr	r1, .L1038+120
 11404 5f68 20C08DE5 		str	ip, [sp, #32]
 11405 5f6c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11406              	.LVL1331:
1870:../uvc.c      **** //#endif
 11407              		.loc 1 1870 0
 11408 5f70 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11409 5f74 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11410 5f78 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11411 5f7c 43008DE8 		stmia	sp, {r0, r1, r6}
 11412 5f80 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11413 5f84 0400A0E3 		mov	r0, #4
 11414 5f88 041F1FE5 		ldr	r1, .L1038+124
 11415 5f8c FEFFFFEB 		bl	CyU3PDebugPrint
 11416              	.LVL1332:
 11417 5f90 00E0A0E3 		mov	lr, #0
 11418 5f94 24E08DE5 		str	lr, [sp, #36]
 11419 5f98 0E60A0E1 		mov	r6, lr
 11420              	.LVL1333:
 11421 5f9c 20C09DE5 		ldr	ip, [sp, #32]
 11422 5fa0 9AFDFFEA 		b	.L874
 11423              	.LVL1334:
 11424              	.L1033:
1637:../uvc.c      **** 			 	 			 {
 11425              		.loc 1 1637 0
 11426 5fa4 020056E3 		cmp	r6, #2
 11427 5fa8 7501000A 		beq	.L1036
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11428              		.loc 1 1643 0
 11429 5fac 040056E3 		cmp	r6, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11430              		.loc 1 1334 0
 11431 5fb0 FF50A013 		movne	r5, #255
 11432              	.LVL1335:
 11433 5fb4 05C0A011 		movne	ip, r5
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11434              		.loc 1 1643 0
 11435 5fb8 E8FFFF1A 		bne	.L877
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11436              		.loc 1 1644 0
 11437 5fbc 5127D9E5 		ldrb	r2, [r9, #1873]	@ zero_extendqisi2
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11438              		.loc 1 1646 0
 11439 5fc0 5257D9E5 		ldrb	r5, [r9, #1874]	@ zero_extendqisi2
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11440              		.loc 1 1645 0
 11441 5fc4 0030A0E3 		mov	r3, #0
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11442              		.loc 1 1646 0
 11443 5fc8 FF5005E2 		and	r5, r5, #255
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11444              		.loc 1 1644 0
 11445 5fcc 2820CBE5 		strb	r2, [fp, #40]
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11446              		.loc 1 1646 0
 11447 5fd0 2A50CBE5 		strb	r5, [fp, #42]
1648:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11448              		.loc 1 1648 0
 11449 5fd4 FFC002E2 		and	ip, r2, #255
 11450              	.LVL1336:
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11451              		.loc 1 1645 0
 11452 5fd8 2930CBE5 		strb	r3, [fp, #41]
1647:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11453              		.loc 1 1647 0
 11454 5fdc 2B30CBE5 		strb	r3, [fp, #43]
 11455 5fe0 DEFFFFEA 		b	.L877
 11456              	.LVL1337:
 11457              	.L1028:
 11458              	.LBE385:
 11459              	.LBE409:
 11460              	.LBB410:
 11461              	.LBB396:
1637:../uvc.c      **** 			 	 			 {
 11462              		.loc 1 1637 0
 11463 5fe4 020056E3 		cmp	r6, #2
 11464 5fe8 6C01000A 		beq	.L1037
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11465              		.loc 1 1643 0
 11466 5fec 040056E3 		cmp	r6, #4
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11467              		.loc 1 1334 0
 11468 5ff0 FF50A013 		movne	r5, #255
 11469              	.LVL1338:
 11470 5ff4 05C0A011 		movne	ip, r5
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11471              		.loc 1 1643 0
 11472 5ff8 5BFFFF1A 		bne	.L904
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11473              		.loc 1 1644 0
 11474 5ffc 6527D9E5 		ldrb	r2, [r9, #1893]	@ zero_extendqisi2
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11475              		.loc 1 1646 0
 11476 6000 6657D9E5 		ldrb	r5, [r9, #1894]	@ zero_extendqisi2
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11477              		.loc 1 1645 0
 11478 6004 0030A0E3 		mov	r3, #0
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11479              		.loc 1 1646 0
 11480 6008 FF5005E2 		and	r5, r5, #255
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11481              		.loc 1 1644 0
 11482 600c 2820C7E5 		strb	r2, [r7, #40]
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11483              		.loc 1 1646 0
 11484 6010 2A50C7E5 		strb	r5, [r7, #42]
1648:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11485              		.loc 1 1648 0
 11486 6014 FFC002E2 		and	ip, r2, #255
 11487              	.LVL1339:
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11488              		.loc 1 1645 0
 11489 6018 2930C7E5 		strb	r3, [r7, #41]
1647:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11490              		.loc 1 1647 0
 11491 601c 2B30C7E5 		strb	r3, [r7, #43]
 11492 6020 51FFFFEA 		b	.L904
 11493              	.LVL1340:
 11494              	.L910:
2945:../uvc.c      **** 			   }
 11495              		.loc 1 2945 0
 11496 6024 38209DE5 		ldr	r2, [sp, #56]
 11497 6028 0400A0E3 		mov	r0, #4
 11498              	.LVL1341:
 11499 602c A41F1FE5 		ldr	r1, .L1038+128
 11500 6030 FEFFFFEB 		bl	CyU3PDebugPrint
 11501              	.LVL1342:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11502              		.loc 1 1334 0
 11503 6034 FF50A0E3 		mov	r5, #255
 11504              	.LVL1343:
2945:../uvc.c      **** 			   }
 11505              		.loc 1 2945 0
 11506 6038 00E0A0E3 		mov	lr, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11507              		.loc 1 1334 0
 11508 603c 05C0A0E1 		mov	ip, r5
2945:../uvc.c      **** 			   }
 11509              		.loc 1 2945 0
 11510 6040 24E08DE5 		str	lr, [sp, #36]
 11511 6044 0E60A0E1 		mov	r6, lr
 11512              	.LVL1344:
 11513 6048 8AFDFFEA 		b	.L901
 11514              	.LVL1345:
 11515              	.L1027:
 11516              	.LBE396:
 11517              	.LBE410:
 11518              	.LBE427:
 11519              	.LBE457:
 11520              	.LBB458:
 11521              	.LBB372:
 11522              	.LBB360:
 11523              	.LBB352:
1830:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 11524              		.loc 1 1830 0
 11525 604c 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
1831:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11526              		.loc 1 1831 0
 11527 6050 3E47D9E5 		ldrb	r4, [r9, #1854]	@ zero_extendqisi2
 11528              	.LVL1346:
1830:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 11529              		.loc 1 1830 0
 11530 6054 2830C7E5 		strb	r3, [r7, #40]
1831:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11531              		.loc 1 1831 0
 11532 6058 FF4004E2 		and	r4, r4, #255
1832:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 11533              		.loc 1 1832 0
 11534 605c FFC003E2 		and	ip, r3, #255
 11535              	.LVL1347:
1831:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11536              		.loc 1 1831 0
 11537 6060 2940C7E5 		strb	r4, [r7, #41]
 11538 6064 98FFFFEA 		b	.L680
 11539              	.LVL1348:
 11540              	.L883:
 11541              	.LBE352:
 11542              	.LBE360:
 11543              	.LBE372:
 11544              	.LBE458:
 11545              	.LBB459:
 11546              	.LBB428:
 11547              	.LBB411:
 11548              	.LBB386:
2945:../uvc.c      **** 			   }
 11549              		.loc 1 2945 0
 11550 6068 38209DE5 		ldr	r2, [sp, #56]
 11551 606c 0400A0E3 		mov	r0, #4
 11552              	.LVL1349:
 11553 6070 E81F1FE5 		ldr	r1, .L1038+128
 11554 6074 FEFFFFEB 		bl	CyU3PDebugPrint
 11555              	.LVL1350:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11556              		.loc 1 1334 0
 11557 6078 FF50A0E3 		mov	r5, #255
 11558              	.LVL1351:
2945:../uvc.c      **** 			   }
 11559              		.loc 1 2945 0
 11560 607c 00E0A0E3 		mov	lr, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11561              		.loc 1 1334 0
 11562 6080 05C0A0E1 		mov	ip, r5
2945:../uvc.c      **** 			   }
 11563              		.loc 1 2945 0
 11564 6084 24E08DE5 		str	lr, [sp, #36]
 11565 6088 0E60A0E1 		mov	r6, lr
 11566              	.LVL1352:
 11567 608c 5FFDFFEA 		b	.L874
 11568              	.LVL1353:
 11569              	.L1008:
 11570              	.LBE386:
 11571              	.LBE411:
 11572              	.LBE428:
 11573              	.LBE459:
 11574              	.LBB460:
 11575              	.LBB373:
 11576              	.LBB361:
 11577              	.LBB353:
1998:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11578              		.loc 1 1998 0
 11579 6090 3B27D9E5 		ldrb	r2, [r9, #1851]	@ zero_extendqisi2
1999:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11580              		.loc 1 1999 0
 11581 6094 3C37D9E5 		ldrb	r3, [r9, #1852]	@ zero_extendqisi2
2009:../uvc.c      **** 		 	 if(Len == 2){
 11582              		.loc 1 2009 0
 11583 6098 0500A0E1 		mov	r0, r5
 11584 609c 84159FE5 		ldr	r1, .L1040
1998:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11585              		.loc 1 1998 0
 11586 60a0 2820C7E5 		strb	r2, [r7, #40]
1999:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11587              		.loc 1 1999 0
 11588 60a4 2930C7E5 		strb	r3, [r7, #41]
2012:../uvc.c      **** 		 	 }else{
 11589              		.loc 1 2012 0
 11590 60a8 00C0A0E3 		mov	ip, #0
 11591 60ac 1BFEFFEA 		b	.L967
 11592              	.LVL1354:
 11593              	.L1021:
 11594              	.LBE353:
 11595              	.LBE361:
 11596              	.LBE373:
 11597              	.LBE460:
 11598              	.LBB461:
 11599              	.LBB343:
 11600              	.LBB333:
 11601              	.LBB261:
3172:../uvc.c      **** 					  else
 11602              		.loc 1 3172 0
 11603 60b0 0810A0E3 		mov	r1, #8
 11604              	.L977:
 11605 60b4 0000A0E3 		mov	r0, #0
 11606 60b8 0320A0E1 		mov	r2, r3
 11607 60bc 00108DE5 		str	r1, [sp]
 11608 60c0 04008DE5 		str	r0, [sp, #4]
 11609 60c4 0C30A0E1 		mov	r3, ip
 11610 60c8 30009DE5 		ldr	r0, [sp, #48]
 11611 60cc 2310A0E3 		mov	r1, #35
 11612 60d0 FEFFFFEB 		bl	cmdSet
 11613              	.LVL1355:
 11614 60d4 13FCFFEA 		b	.L826
 11615              	.LVL1356:
 11616              	.L1020:
 11617              	.LBE261:
 11618              	.LBE333:
 11619              	.LBE343:
 11620              	.LBE461:
 11621              	.LBB462:
 11622              	.LBB374:
 11623              	.LBB362:
 11624              	.LBB354:
2924:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 11625              		.loc 1 2924 0
 11626 60d8 4CC59FE5 		ldr	ip, .L1040+4
 11627 60dc 0010E0E3 		mvn	r1, #0
 11628 60e0 1C009CE5 		ldr	r0, [ip, #28]
 11629 60e4 30C08DE5 		str	ip, [sp, #48]
 11630 60e8 FEFFFFEB 		bl	_txe_mutex_get
 11631              	.LVL1357:
2925:../uvc.c      **** 								 {
 11632              		.loc 1 2925 0
 11633 60ec 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
 11634 60f0 030055E1 		cmp	r5, r3
2547:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 11635              		.loc 1 2547 0
 11636 60f4 34309D05 		ldreq	r3, [sp, #52]
2925:../uvc.c      **** 								 {
 11637              		.loc 1 2925 0
 11638 60f8 0A00000A 		beq	.L692
2928:../uvc.c      **** 									 dataIdx++;
 11639              		.loc 1 2928 0
 11640 60fc 34C09DE5 		ldr	ip, [sp, #52]
2927:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11641              		.loc 1 2927 0
 11642 6100 28E59FE5 		ldr	lr, .L1040+8
2928:../uvc.c      **** 									 dataIdx++;
 11643              		.loc 1 2928 0
 11644 6104 00508DE5 		str	r5, [sp]
 11645 6108 04C08DE5 		str	ip, [sp, #4]
 11646 610c 28309DE5 		ldr	r3, [sp, #40]
 11647 6110 2C209DE5 		ldr	r2, [sp, #44]
 11648 6114 30009DE5 		ldr	r0, [sp, #48]
 11649 6118 0E10A0E3 		mov	r1, #14
2927:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11650              		.loc 1 2927 0
 11651 611c 3D57CEE5 		strb	r5, [lr, #1853]
2928:../uvc.c      **** 									 dataIdx++;
 11652              		.loc 1 2928 0
 11653 6120 FEFFFFEB 		bl	cmdSet
 11654              	.LVL1358:
2929:../uvc.c      **** 								 }
 11655              		.loc 1 2929 0
 11656 6124 0630A0E1 		mov	r3, r6
 11657              	.LVL1359:
 11658              	.L692:
2931:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11659              		.loc 1 2931 0
 11660 6128 3E27D9E5 		ldrb	r2, [r9, #1854]	@ zero_extendqisi2
 11661 612c 24C09DE5 		ldr	ip, [sp, #36]
 11662 6130 02005CE1 		cmp	ip, r2
 11663 6134 0800000A 		beq	.L693
2932:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11664              		.loc 1 2932 0
 11665 6138 F0E49FE5 		ldr	lr, .L1040+8
2933:../uvc.c      **** 								 }
 11666              		.loc 1 2933 0
 11667 613c 04308DE5 		str	r3, [sp, #4]
 11668 6140 00C08DE5 		str	ip, [sp]
 11669 6144 0420A0E1 		mov	r2, r4
 11670 6148 28309DE5 		ldr	r3, [sp, #40]
 11671              	.LVL1360:
 11672 614c D8049FE5 		ldr	r0, .L1040+4
 11673 6150 0E10A0E3 		mov	r1, #14
2932:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11674              		.loc 1 2932 0
 11675 6154 3EC7CEE5 		strb	ip, [lr, #1854]
2933:../uvc.c      **** 								 }
 11676              		.loc 1 2933 0
 11677 6158 FEFFFFEB 		bl	cmdSet
 11678              	.LVL1361:
 11679              	.L693:
2936:../uvc.c      **** 
 11680              		.loc 1 2936 0
 11681 615c 30409DE5 		ldr	r4, [sp, #48]
 11682              	.LVL1362:
2935:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11683              		.loc 1 2935 0
 11684 6160 0130A0E3 		mov	r3, #1
2936:../uvc.c      **** 
 11685              		.loc 1 2936 0
 11686 6164 1C0094E5 		ldr	r0, [r4, #28]
2935:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11687              		.loc 1 2935 0
 11688 6168 4137C9E5 		strb	r3, [r9, #1857]
2936:../uvc.c      **** 
 11689              		.loc 1 2936 0
 11690 616c FEFFFFEB 		bl	_txe_mutex_put
 11691              	.LVL1363:
 11692 6170 96FAFFEA 		b	.L691
 11693              	.LVL1364:
 11694              	.L1025:
 11695              	.LBE354:
 11696              	.LBE362:
 11697              	.LBE374:
 11698              	.LBE462:
 11699              	.LBB463:
 11700              	.LBB429:
 11701              	.LBB412:
 11702              	.LBB387:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11703              		.loc 1 2548 0
 11704 6174 2CC09DE5 		ldr	ip, [sp, #44]
 11705 6178 00508DE5 		str	r5, [sp]
 11706 617c 04C08DE5 		str	ip, [sp, #4]
 11707 6180 08608DE5 		str	r6, [sp, #8]
2542:../uvc.c      **** 				 }else{
 11708              		.loc 1 2542 0
 11709 6184 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11710              		.loc 1 2548 0
 11711 6188 34309DE5 		ldr	r3, [sp, #52]
 11712 618c 0400A0E3 		mov	r0, #4
 11713              	.LVL1365:
 11714 6190 9C149FE5 		ldr	r1, .L1040+12
 11715 6194 2920A0E3 		mov	r2, #41
2541:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11716              		.loc 1 2541 0
 11717 6198 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 11718              	.LVL1366:
2542:../uvc.c      **** 				 }else{
 11719              		.loc 1 2542 0
 11720 619c 24C08DE5 		str	ip, [sp, #36]
 11721              	.LVL1367:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11722              		.loc 1 2548 0
 11723 61a0 FEFFFFEB 		bl	CyU3PDebugPrint
 11724              	.LVL1368:
2729:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11725              		.loc 1 2729 0
 11726 61a4 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
 11727 61a8 030056E1 		cmp	r6, r3
 11728 61ac 1100000A 		beq	.L886
2730:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11729              		.loc 1 2730 0
 11730 61b0 74549FE5 		ldr	r5, .L1040+4
 11731              	.LVL1369:
 11732 61b4 0010E0E3 		mvn	r1, #0
 11733 61b8 1C0095E5 		ldr	r0, [r5, #28]
 11734 61bc FEFFFFEB 		bl	_txe_mutex_get
 11735              	.LVL1370:
2731:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11736              		.loc 1 2731 0
 11737 61c0 38C09DE5 		ldr	ip, [sp, #56]
 11738 61c4 34209DE5 		ldr	r2, [sp, #52]
 11739 61c8 04C08DE5 		str	ip, [sp, #4]
 11740 61cc 2C309DE5 		ldr	r3, [sp, #44]
 11741 61d0 2910A0E3 		mov	r1, #41
 11742 61d4 00608DE5 		str	r6, [sp]
 11743 61d8 0500A0E1 		mov	r0, r5
 11744 61dc FEFFFFEB 		bl	cmdSet
 11745              	.LVL1371:
2732:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11746              		.loc 1 2732 0
 11747 61e0 1C0095E5 		ldr	r0, [r5, #28]
 11748 61e4 FEFFFFEB 		bl	_txe_mutex_put
 11749              	.LVL1372:
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11750              		.loc 1 2733 0
 11751 61e8 40E49FE5 		ldr	lr, .L1040+8
2734:../uvc.c      **** 									 }
 11752              		.loc 1 2734 0
 11753 61ec 38C09DE5 		ldr	ip, [sp, #56]
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11754              		.loc 1 2733 0
 11755 61f0 5167CEE5 		strb	r6, [lr, #1873]
2734:../uvc.c      **** 									 }
 11756              		.loc 1 2734 0
 11757 61f4 52C7CEE5 		strb	ip, [lr, #1874]
 11758              	.L886:
2736:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11759              		.loc 1 2736 0
 11760 61f8 0130A0E3 		mov	r3, #1
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11761              		.loc 1 2548 0
 11762 61fc 02C0A0E3 		mov	ip, #2
2736:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11763              		.loc 1 2736 0
 11764 6200 5537C9E5 		strb	r3, [r9, #1877]
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11765              		.loc 1 2548 0
 11766 6204 3CC08DE5 		str	ip, [sp, #60]
 11767 6208 88FDFFEA 		b	.L888
 11768              	.LVL1373:
 11769              	.L1023:
 11770              	.LBE387:
 11771              	.LBE412:
 11772              	.LBB413:
 11773              	.LBB397:
 11774 620c 2CC09DE5 		ldr	ip, [sp, #44]
 11775 6210 00508DE5 		str	r5, [sp]
 11776 6214 04C08DE5 		str	ip, [sp, #4]
 11777 6218 08608DE5 		str	r6, [sp, #8]
2542:../uvc.c      **** 				 }else{
 11778              		.loc 1 2542 0
 11779 621c 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11780              		.loc 1 2548 0
 11781 6220 34309DE5 		ldr	r3, [sp, #52]
 11782 6224 0400A0E3 		mov	r0, #4
 11783              	.LVL1374:
 11784 6228 04149FE5 		ldr	r1, .L1040+12
 11785 622c 2A20A0E3 		mov	r2, #42
2541:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11786              		.loc 1 2541 0
 11787 6230 2860DBE5 		ldrb	r6, [fp, #40]	@ zero_extendqisi2
 11788              	.LVL1375:
2542:../uvc.c      **** 				 }else{
 11789              		.loc 1 2542 0
 11790 6234 24C08DE5 		str	ip, [sp, #36]
 11791              	.LVL1376:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11792              		.loc 1 2548 0
 11793 6238 FEFFFFEB 		bl	CyU3PDebugPrint
 11794              	.LVL1377:
2729:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11795              		.loc 1 2729 0
 11796 623c 6537D9E5 		ldrb	r3, [r9, #1893]	@ zero_extendqisi2
 11797 6240 030056E1 		cmp	r6, r3
 11798 6244 1100000A 		beq	.L913
2730:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11799              		.loc 1 2730 0
 11800 6248 DC539FE5 		ldr	r5, .L1040+4
 11801              	.LVL1378:
 11802 624c 0010E0E3 		mvn	r1, #0
 11803 6250 1C0095E5 		ldr	r0, [r5, #28]
 11804 6254 FEFFFFEB 		bl	_txe_mutex_get
 11805              	.LVL1379:
2731:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11806              		.loc 1 2731 0
 11807 6258 38C09DE5 		ldr	ip, [sp, #56]
 11808 625c 34209DE5 		ldr	r2, [sp, #52]
 11809 6260 04C08DE5 		str	ip, [sp, #4]
 11810 6264 2C309DE5 		ldr	r3, [sp, #44]
 11811 6268 2A10A0E3 		mov	r1, #42
 11812 626c 00608DE5 		str	r6, [sp]
 11813 6270 0500A0E1 		mov	r0, r5
 11814 6274 FEFFFFEB 		bl	cmdSet
 11815              	.LVL1380:
2732:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11816              		.loc 1 2732 0
 11817 6278 1C0095E5 		ldr	r0, [r5, #28]
 11818 627c FEFFFFEB 		bl	_txe_mutex_put
 11819              	.LVL1381:
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11820              		.loc 1 2733 0
 11821 6280 A8E39FE5 		ldr	lr, .L1040+8
2734:../uvc.c      **** 									 }
 11822              		.loc 1 2734 0
 11823 6284 38C09DE5 		ldr	ip, [sp, #56]
2733:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11824              		.loc 1 2733 0
 11825 6288 6567CEE5 		strb	r6, [lr, #1893]
2734:../uvc.c      **** 									 }
 11826              		.loc 1 2734 0
 11827 628c 66C7CEE5 		strb	ip, [lr, #1894]
 11828              	.L913:
2736:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11829              		.loc 1 2736 0
 11830 6290 0130A0E3 		mov	r3, #1
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11831              		.loc 1 2548 0
 11832 6294 02C0A0E3 		mov	ip, #2
2736:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11833              		.loc 1 2736 0
 11834 6298 6937C9E5 		strb	r3, [r9, #1897]
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11835              		.loc 1 2548 0
 11836 629c 3CC08DE5 		str	ip, [sp, #60]
 11837 62a0 38FDFFEA 		b	.L915
 11838              	.LVL1382:
 11839              	.L1019:
 11840              	.LBE397:
 11841              	.LBE413:
 11842              	.LBE429:
 11843              	.LBE463:
 11844              	.LBB464:
 11845              	.LBB375:
 11846              	.LBB363:
 11847              	.LBB355:
 11848 62a4 28C09DE5 		ldr	ip, [sp, #40]
 11849 62a8 00408DE5 		str	r4, [sp]
 11850 62ac 04C08DE5 		str	ip, [sp, #4]
 11851 62b0 08508DE5 		str	r5, [sp, #8]
2542:../uvc.c      **** 				 }else{
 11852              		.loc 1 2542 0
 11853 62b4 2940DBE5 		ldrb	r4, [fp, #41]	@ zero_extendqisi2
 11854              	.LVL1383:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11855              		.loc 1 2548 0
 11856 62b8 2C309DE5 		ldr	r3, [sp, #44]
 11857 62bc 0400A0E3 		mov	r0, #4
 11858              	.LVL1384:
 11859 62c0 6C139FE5 		ldr	r1, .L1040+12
 11860 62c4 0E20A0E3 		mov	r2, #14
2541:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11861              		.loc 1 2541 0
 11862 62c8 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 11863              	.LVL1385:
2542:../uvc.c      **** 				 }else{
 11864              		.loc 1 2542 0
 11865 62cc 24408DE5 		str	r4, [sp, #36]
 11866              	.LVL1386:
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11867              		.loc 1 2548 0
 11868 62d0 FEFFFFEB 		bl	CyU3PDebugPrint
 11869              	.LVL1387:
2915:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11870              		.loc 1 2915 0
 11871 62d4 3D37D9E5 		ldrb	r3, [r9, #1853]	@ zero_extendqisi2
 11872 62d8 030055E1 		cmp	r5, r3
 11873 62dc 1100000A 		beq	.L689
2916:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11874              		.loc 1 2916 0
 11875 62e0 44439FE5 		ldr	r4, .L1040+4
 11876 62e4 0010E0E3 		mvn	r1, #0
 11877 62e8 1C0094E5 		ldr	r0, [r4, #28]
 11878 62ec FEFFFFEB 		bl	_txe_mutex_get
 11879              	.LVL1388:
2917:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11880              		.loc 1 2917 0
 11881 62f0 34C09DE5 		ldr	ip, [sp, #52]
 11882 62f4 2C209DE5 		ldr	r2, [sp, #44]
 11883 62f8 04C08DE5 		str	ip, [sp, #4]
 11884 62fc 28309DE5 		ldr	r3, [sp, #40]
 11885 6300 0400A0E1 		mov	r0, r4
 11886 6304 0E10A0E3 		mov	r1, #14
 11887 6308 00508DE5 		str	r5, [sp]
 11888 630c FEFFFFEB 		bl	cmdSet
 11889              	.LVL1389:
2918:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11890              		.loc 1 2918 0
 11891 6310 1C0094E5 		ldr	r0, [r4, #28]
 11892 6314 FEFFFFEB 		bl	_txe_mutex_put
 11893              	.LVL1390:
2919:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11894              		.loc 1 2919 0
 11895 6318 10E39FE5 		ldr	lr, .L1040+8
2920:../uvc.c      **** 								 }
 11896              		.loc 1 2920 0
 11897 631c 34409DE5 		ldr	r4, [sp, #52]
2919:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11898              		.loc 1 2919 0
 11899 6320 3D57CEE5 		strb	r5, [lr, #1853]
2920:../uvc.c      **** 								 }
 11900              		.loc 1 2920 0
 11901 6324 3E47CEE5 		strb	r4, [lr, #1854]
 11902              	.L689:
2922:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11903              		.loc 1 2922 0
 11904 6328 0130A0E3 		mov	r3, #1
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11905              		.loc 1 2548 0
 11906 632c 02C0A0E3 		mov	ip, #2
2922:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11907              		.loc 1 2922 0
 11908 6330 4137C9E5 		strb	r3, [r9, #1857]
2548:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11909              		.loc 1 2548 0
 11910 6334 38C08DE5 		str	ip, [sp, #56]
 11911 6338 24FAFFEA 		b	.L691
 11912              	.LVL1391:
 11913              	.L686:
2945:../uvc.c      **** 			   }
 11914              		.loc 1 2945 0
 11915 633c 34209DE5 		ldr	r2, [sp, #52]
 11916 6340 0400A0E3 		mov	r0, #4
 11917              	.LVL1392:
 11918 6344 EC129FE5 		ldr	r1, .L1040+16
 11919 6348 FEFFFFEB 		bl	CyU3PDebugPrint
 11920              	.LVL1393:
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11921              		.loc 1 1334 0
 11922 634c FF40A0E3 		mov	r4, #255
 11923              	.LVL1394:
2945:../uvc.c      **** 			   }
 11924              		.loc 1 2945 0
 11925 6350 00E0A0E3 		mov	lr, #0
1334:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11926              		.loc 1 1334 0
 11927 6354 04C0A0E1 		mov	ip, r4
2945:../uvc.c      **** 			   }
 11928              		.loc 1 2945 0
 11929 6358 24E08DE5 		str	lr, [sp, #36]
 11930 635c 0E50A0E1 		mov	r5, lr
 11931              	.LVL1395:
 11932 6360 0E20A0E1 		mov	r2, lr
 11933 6364 25FAFFEA 		b	.L677
 11934              	.LVL1396:
 11935              	.L1032:
1852:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11936              		.loc 1 1852 0
 11937 6368 0400A0E1 		mov	r0, r4
 11938 636c 28109DE5 		ldr	r1, [sp, #40]
 11939 6370 FEFFFFEB 		bl	SensorGetControl
 11940              	.LVL1397:
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11941              		.loc 1 1854 0
 11942 6374 28109DE5 		ldr	r1, [sp, #40]
1852:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11943              		.loc 1 1852 0
 11944 6378 0030A0E1 		mov	r3, r0
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11945              		.loc 1 1854 0
 11946 637c 2C009DE5 		ldr	r0, [sp, #44]
1852:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11947              		.loc 1 1852 0
 11948 6380 2830C7E5 		strb	r3, [r7, #40]
1853:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11949              		.loc 1 1853 0
 11950 6384 3D37C9E5 		strb	r3, [r9, #1853]
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11951              		.loc 1 1854 0
 11952 6388 FEFFFFEB 		bl	SensorGetControl
 11953              	.LVL1398:
1856:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11954              		.loc 1 1856 0
 11955 638c 0030A0E3 		mov	r3, #0
 11956 6390 2930C7E5 		strb	r3, [r7, #41]
1857:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11957              		.loc 1 1857 0
 11958 6394 2B30C7E5 		strb	r3, [r7, #43]
1858:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11959              		.loc 1 1858 0
 11960 6398 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11961              	.LVL1399:
1854:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 11962              		.loc 1 1854 0
 11963 639c 0040A0E1 		mov	r4, r0
 11964              	.LVL1400:
 11965 63a0 2A00C7E5 		strb	r0, [r7, #42]
1855:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11966              		.loc 1 1855 0
 11967 63a4 3E07C9E5 		strb	r0, [r9, #1854]
 11968 63a8 C5FEFFEA 		b	.L682
 11969              	.LVL1401:
 11970              	.L1031:
1845:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11971              		.loc 1 1845 0
 11972 63ac 0400A0E1 		mov	r0, r4
 11973 63b0 28109DE5 		ldr	r1, [sp, #40]
 11974 63b4 FEFFFFEB 		bl	SensorGetControl
 11975              	.LVL1402:
1847:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11976              		.loc 1 1847 0
 11977 63b8 0040A0E3 		mov	r4, #0
 11978              	.LVL1403:
 11979 63bc 2940C7E5 		strb	r4, [r7, #41]
1846:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11980              		.loc 1 1846 0
 11981 63c0 3D07C9E5 		strb	r0, [r9, #1853]
1845:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11982              		.loc 1 1845 0
 11983 63c4 00C0A0E1 		mov	ip, r0
 11984 63c8 2800C7E5 		strb	r0, [r7, #40]
1848:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11985              		.loc 1 1848 0
 11986 63cc 3E47C9E5 		strb	r4, [r9, #1854]
 11987              	.LVL1404:
 11988 63d0 BBFEFFEA 		b	.L682
 11989              	.LVL1405:
 11990              	.L1026:
 11991              	.LBE355:
 11992              	.LBE363:
 11993              	.LBE375:
 11994              	.LBE464:
 11995              	.LBB465:
 11996              	.LBB430:
 11997              	.LBB414:
 11998              	.LBB388:
2738:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11999              		.loc 1 2738 0
 12000 63d4 50C29FE5 		ldr	ip, .L1040+4
 12001 63d8 0010E0E3 		mvn	r1, #0
 12002 63dc 1C009CE5 		ldr	r0, [ip, #28]
 12003 63e0 30C08DE5 		str	ip, [sp, #48]
 12004 63e4 FEFFFFEB 		bl	_txe_mutex_get
 12005              	.LVL1406:
2739:../uvc.c      **** 									 {
 12006              		.loc 1 2739 0
 12007 63e8 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
 12008 63ec 030056E1 		cmp	r6, r3
2547:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 12009              		.loc 1 2547 0
 12010 63f0 38309D05 		ldreq	r3, [sp, #56]
2739:../uvc.c      **** 									 {
 12011              		.loc 1 2739 0
 12012 63f4 0A00000A 		beq	.L889
2742:../uvc.c      **** 										 dataIdx++;
 12013              		.loc 1 2742 0
 12014 63f8 38C09DE5 		ldr	ip, [sp, #56]
2741:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12015              		.loc 1 2741 0
 12016 63fc 2CE29FE5 		ldr	lr, .L1040+8
2742:../uvc.c      **** 										 dataIdx++;
 12017              		.loc 1 2742 0
 12018 6400 00608DE5 		str	r6, [sp]
 12019 6404 04C08DE5 		str	ip, [sp, #4]
 12020 6408 2C309DE5 		ldr	r3, [sp, #44]
 12021 640c 34209DE5 		ldr	r2, [sp, #52]
 12022 6410 30009DE5 		ldr	r0, [sp, #48]
 12023 6414 2910A0E3 		mov	r1, #41
2741:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12024              		.loc 1 2741 0
 12025 6418 5167CEE5 		strb	r6, [lr, #1873]
2742:../uvc.c      **** 										 dataIdx++;
 12026              		.loc 1 2742 0
 12027 641c FEFFFFEB 		bl	cmdSet
 12028              	.LVL1407:
2743:../uvc.c      **** 									 }
 12029              		.loc 1 2743 0
 12030 6420 28309DE5 		ldr	r3, [sp, #40]
 12031              	.LVL1408:
 12032              	.L889:
2745:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 12033              		.loc 1 2745 0
 12034 6424 5227D9E5 		ldrb	r2, [r9, #1874]	@ zero_extendqisi2
 12035 6428 24C09DE5 		ldr	ip, [sp, #36]
 12036 642c 02005CE1 		cmp	ip, r2
 12037 6430 0800000A 		beq	.L890
2746:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12038              		.loc 1 2746 0
 12039 6434 F4E19FE5 		ldr	lr, .L1040+8
2747:../uvc.c      **** 									 }
 12040              		.loc 1 2747 0
 12041 6438 04308DE5 		str	r3, [sp, #4]
 12042 643c 00C08DE5 		str	ip, [sp]
 12043 6440 0520A0E1 		mov	r2, r5
 12044 6444 2C309DE5 		ldr	r3, [sp, #44]
 12045              	.LVL1409:
 12046 6448 DC019FE5 		ldr	r0, .L1040+4
 12047 644c 2910A0E3 		mov	r1, #41
2746:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12048              		.loc 1 2746 0
 12049 6450 52C7CEE5 		strb	ip, [lr, #1874]
2747:../uvc.c      **** 									 }
 12050              		.loc 1 2747 0
 12051 6454 FEFFFFEB 		bl	cmdSet
 12052              	.LVL1410:
 12053              	.L890:
2750:../uvc.c      **** 
 12054              		.loc 1 2750 0
 12055 6458 30C09DE5 		ldr	ip, [sp, #48]
2749:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12056              		.loc 1 2749 0
 12057 645c 0130A0E3 		mov	r3, #1
2750:../uvc.c      **** 
 12058              		.loc 1 2750 0
 12059 6460 1C009CE5 		ldr	r0, [ip, #28]
2749:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12060              		.loc 1 2749 0
 12061 6464 5537C9E5 		strb	r3, [r9, #1877]
2750:../uvc.c      **** 
 12062              		.loc 1 2750 0
 12063 6468 FEFFFFEB 		bl	_txe_mutex_put
 12064              	.LVL1411:
 12065 646c EFFCFFEA 		b	.L888
 12066              	.LVL1412:
 12067              	.L1024:
 12068              	.LBE388:
 12069              	.LBE414:
 12070              	.LBB415:
 12071              	.LBB398:
2738:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 12072              		.loc 1 2738 0
 12073 6470 B4C19FE5 		ldr	ip, .L1040+4
 12074 6474 0010E0E3 		mvn	r1, #0
 12075 6478 1C009CE5 		ldr	r0, [ip, #28]
 12076 647c 30C08DE5 		str	ip, [sp, #48]
 12077 6480 FEFFFFEB 		bl	_txe_mutex_get
 12078              	.LVL1413:
2739:../uvc.c      **** 									 {
 12079              		.loc 1 2739 0
 12080 6484 6537D9E5 		ldrb	r3, [r9, #1893]	@ zero_extendqisi2
 12081 6488 030056E1 		cmp	r6, r3
2547:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 12082              		.loc 1 2547 0
 12083 648c 38309D05 		ldreq	r3, [sp, #56]
2739:../uvc.c      **** 									 {
 12084              		.loc 1 2739 0
 12085 6490 0A00000A 		beq	.L916
2742:../uvc.c      **** 										 dataIdx++;
 12086              		.loc 1 2742 0
 12087 6494 38C09DE5 		ldr	ip, [sp, #56]
2741:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12088              		.loc 1 2741 0
 12089 6498 90E19FE5 		ldr	lr, .L1040+8
2742:../uvc.c      **** 										 dataIdx++;
 12090              		.loc 1 2742 0
 12091 649c 00608DE5 		str	r6, [sp]
 12092 64a0 04C08DE5 		str	ip, [sp, #4]
 12093 64a4 2C309DE5 		ldr	r3, [sp, #44]
 12094 64a8 34209DE5 		ldr	r2, [sp, #52]
 12095 64ac 30009DE5 		ldr	r0, [sp, #48]
 12096 64b0 2A10A0E3 		mov	r1, #42
2741:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12097              		.loc 1 2741 0
 12098 64b4 6567CEE5 		strb	r6, [lr, #1893]
2742:../uvc.c      **** 										 dataIdx++;
 12099              		.loc 1 2742 0
 12100 64b8 FEFFFFEB 		bl	cmdSet
 12101              	.LVL1414:
2743:../uvc.c      **** 									 }
 12102              		.loc 1 2743 0
 12103 64bc 0130A0E3 		mov	r3, #1
 12104              	.LVL1415:
 12105              	.L916:
2745:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 12106              		.loc 1 2745 0
 12107 64c0 6627D9E5 		ldrb	r2, [r9, #1894]	@ zero_extendqisi2
 12108 64c4 24C09DE5 		ldr	ip, [sp, #36]
 12109 64c8 02005CE1 		cmp	ip, r2
 12110 64cc 0800000A 		beq	.L917
2746:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12111              		.loc 1 2746 0
 12112 64d0 58E19FE5 		ldr	lr, .L1040+8
2747:../uvc.c      **** 									 }
 12113              		.loc 1 2747 0
 12114 64d4 04308DE5 		str	r3, [sp, #4]
 12115 64d8 00C08DE5 		str	ip, [sp]
 12116 64dc 0520A0E1 		mov	r2, r5
 12117 64e0 2C309DE5 		ldr	r3, [sp, #44]
 12118              	.LVL1416:
 12119 64e4 40019FE5 		ldr	r0, .L1040+4
 12120 64e8 2A10A0E3 		mov	r1, #42
2746:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12121              		.loc 1 2746 0
 12122 64ec 66C7CEE5 		strb	ip, [lr, #1894]
2747:../uvc.c      **** 									 }
 12123              		.loc 1 2747 0
 12124 64f0 FEFFFFEB 		bl	cmdSet
 12125              	.LVL1417:
 12126              	.L917:
2750:../uvc.c      **** 
 12127              		.loc 1 2750 0
 12128 64f4 30C09DE5 		ldr	ip, [sp, #48]
2749:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12129              		.loc 1 2749 0
 12130 64f8 0130A0E3 		mov	r3, #1
2750:../uvc.c      **** 
 12131              		.loc 1 2750 0
 12132 64fc 1C009CE5 		ldr	r0, [ip, #28]
2749:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12133              		.loc 1 2749 0
 12134 6500 6937C9E5 		strb	r3, [r9, #1897]
2750:../uvc.c      **** 
 12135              		.loc 1 2750 0
 12136 6504 FEFFFFEB 		bl	_txe_mutex_put
 12137              	.LVL1418:
 12138 6508 9EFCFFEA 		b	.L915
 12139              	.LVL1419:
 12140              	.L1035:
 12141              	.LBE398:
 12142              	.LBE415:
 12143              	.LBB416:
 12144              	.LBB389:
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12145              		.loc 1 1661 0
 12146 650c 0500A0E1 		mov	r0, r5
 12147 6510 2C109DE5 		ldr	r1, [sp, #44]
 12148 6514 1C308DE5 		str	r3, [sp, #28]
 12149 6518 FEFFFFEB 		bl	SensorGetControl
 12150              	.LVL1420:
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12151              		.loc 1 1663 0
 12152 651c 2C109DE5 		ldr	r1, [sp, #44]
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12153              		.loc 1 1661 0
 12154 6520 0020A0E1 		mov	r2, r0
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12155              		.loc 1 1663 0
 12156 6524 34009DE5 		ldr	r0, [sp, #52]
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12157              		.loc 1 1661 0
 12158 6528 2820CBE5 		strb	r2, [fp, #40]
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12159              		.loc 1 1662 0
 12160 652c 5127C9E5 		strb	r2, [r9, #1873]
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12161              		.loc 1 1663 0
 12162 6530 FEFFFFEB 		bl	SensorGetControl
 12163              	.LVL1421:
1667:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12164              		.loc 1 1667 0
 12165 6534 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 12166              	.LVL1422:
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12167              		.loc 1 1663 0
 12168 6538 2A00CBE5 		strb	r0, [fp, #42]
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12169              		.loc 1 1665 0
 12170 653c 1C309DE5 		ldr	r3, [sp, #28]
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12171              		.loc 1 1663 0
 12172 6540 0050A0E1 		mov	r5, r0
 12173              	.LVL1423:
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12174              		.loc 1 1664 0
 12175 6544 5207C9E5 		strb	r0, [r9, #1874]
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12176              		.loc 1 1665 0
 12177 6548 2930CBE5 		strb	r3, [fp, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12178              		.loc 1 1666 0
 12179 654c 2B30CBE5 		strb	r3, [fp, #43]
 12180 6550 80FEFFEA 		b	.L879
 12181              	.LVL1424:
 12182              	.L1034:
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12183              		.loc 1 1654 0
 12184 6554 0500A0E1 		mov	r0, r5
 12185 6558 2C109DE5 		ldr	r1, [sp, #44]
 12186 655c 1C308DE5 		str	r3, [sp, #28]
 12187 6560 FEFFFFEB 		bl	SensorGetControl
 12188              	.LVL1425:
 12189 6564 2800CBE5 		strb	r0, [fp, #40]
1656:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12190              		.loc 1 1656 0
 12191 6568 1C309DE5 		ldr	r3, [sp, #28]
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12192              		.loc 1 1655 0
 12193 656c 5107C9E5 		strb	r0, [r9, #1873]
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12194              		.loc 1 1654 0
 12195 6570 00C0A0E1 		mov	ip, r0
1656:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12196              		.loc 1 1656 0
 12197 6574 2930CBE5 		strb	r3, [fp, #41]
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12198              		.loc 1 1657 0
 12199 6578 5237C9E5 		strb	r3, [r9, #1874]
 12200              	.LVL1426:
1659:../uvc.c      **** 			 	 			 }else if(Len == 4){
 12201              		.loc 1 1659 0
 12202 657c 0350A0E1 		mov	r5, r3
 12203              	.LVL1427:
 12204 6580 74FEFFEA 		b	.L879
 12205              	.LVL1428:
 12206              	.L1036:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12207              		.loc 1 1639 0
 12208 6584 5137D9E5 		ldrb	r3, [r9, #1873]	@ zero_extendqisi2
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12209              		.loc 1 1640 0
 12210 6588 5257D9E5 		ldrb	r5, [r9, #1874]	@ zero_extendqisi2
 12211              	.LVL1429:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12212              		.loc 1 1639 0
 12213 658c 2830CBE5 		strb	r3, [fp, #40]
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12214              		.loc 1 1640 0
 12215 6590 FF5005E2 		and	r5, r5, #255
1641:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12216              		.loc 1 1641 0
 12217 6594 FFC003E2 		and	ip, r3, #255
 12218              	.LVL1430:
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12219              		.loc 1 1640 0
 12220 6598 2950CBE5 		strb	r5, [fp, #41]
 12221 659c 6FFEFFEA 		b	.L877
 12222              	.LVL1431:
 12223              	.L1037:
 12224              	.LBE389:
 12225              	.LBE416:
 12226              	.LBB417:
 12227              	.LBB399:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12228              		.loc 1 1639 0
 12229 65a0 6537D9E5 		ldrb	r3, [r9, #1893]	@ zero_extendqisi2
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12230              		.loc 1 1640 0
 12231 65a4 6657D9E5 		ldrb	r5, [r9, #1894]	@ zero_extendqisi2
 12232              	.LVL1432:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12233              		.loc 1 1639 0
 12234 65a8 2830C7E5 		strb	r3, [r7, #40]
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12235              		.loc 1 1640 0
 12236 65ac FF5005E2 		and	r5, r5, #255
1641:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12237              		.loc 1 1641 0
 12238 65b0 FFC003E2 		and	ip, r3, #255
 12239              	.LVL1433:
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12240              		.loc 1 1640 0
 12241 65b4 2950C7E5 		strb	r5, [r7, #41]
 12242 65b8 EBFDFFEA 		b	.L904
 12243              	.LVL1434:
 12244              	.L1030:
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12245              		.loc 1 1661 0
 12246 65bc 0500A0E1 		mov	r0, r5
 12247 65c0 2C109DE5 		ldr	r1, [sp, #44]
 12248 65c4 FEFFFFEB 		bl	SensorGetControl
 12249              	.LVL1435:
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12250              		.loc 1 1663 0
 12251 65c8 2C109DE5 		ldr	r1, [sp, #44]
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12252              		.loc 1 1661 0
 12253 65cc 0030A0E1 		mov	r3, r0
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12254              		.loc 1 1663 0
 12255 65d0 34009DE5 		ldr	r0, [sp, #52]
1661:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12256              		.loc 1 1661 0
 12257 65d4 2830C7E5 		strb	r3, [r7, #40]
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12258              		.loc 1 1662 0
 12259 65d8 6537C9E5 		strb	r3, [r9, #1893]
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12260              		.loc 1 1663 0
 12261 65dc FEFFFFEB 		bl	SensorGetControl
 12262              	.LVL1436:
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12263              		.loc 1 1665 0
 12264 65e0 0030A0E3 		mov	r3, #0
 12265 65e4 2930C7E5 		strb	r3, [r7, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12266              		.loc 1 1666 0
 12267 65e8 2B30C7E5 		strb	r3, [r7, #43]
1667:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12268              		.loc 1 1667 0
 12269 65ec 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 12270              	.LVL1437:
1663:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12271              		.loc 1 1663 0
 12272 65f0 0050A0E1 		mov	r5, r0
 12273              	.LVL1438:
 12274 65f4 2A00C7E5 		strb	r0, [r7, #42]
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12275              		.loc 1 1664 0
 12276 65f8 6607C9E5 		strb	r0, [r9, #1894]
 12277 65fc D8FDFFEA 		b	.L906
 12278              	.LVL1439:
 12279              	.L1029:
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12280              		.loc 1 1654 0
 12281 6600 0500A0E1 		mov	r0, r5
 12282 6604 2C109DE5 		ldr	r1, [sp, #44]
 12283 6608 FEFFFFEB 		bl	SensorGetControl
 12284              	.LVL1440:
1656:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12285              		.loc 1 1656 0
 12286 660c 0050A0E3 		mov	r5, #0
 12287              	.LVL1441:
 12288 6610 2950C7E5 		strb	r5, [r7, #41]
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12289              		.loc 1 1655 0
 12290 6614 6507C9E5 		strb	r0, [r9, #1893]
1654:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12291              		.loc 1 1654 0
 12292 6618 00C0A0E1 		mov	ip, r0
 12293 661c 2800C7E5 		strb	r0, [r7, #40]
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12294              		.loc 1 1657 0
 12295 6620 6657C9E5 		strb	r5, [r9, #1894]
 12296              	.LVL1442:
 12297 6624 CEFDFFEA 		b	.L906
 12298              	.L1041:
 12299              		.align	2
 12300              	.L1040:
 12301 6628 28000000 		.word	.LANCHOR0+40
 12302 662c 00000000 		.word	cmdQu
 12303 6630 00000000 		.word	.LANCHOR1
 12304 6634 68040000 		.word	.LC27
 12305 6638 E4050000 		.word	.LC34
 12306              	.LBE399:
 12307              	.LBE417:
 12308              	.LBE430:
 12309              	.LBE465:
 12310              		.cfi_endproc
 12311              	.LFE25:
 12313              		.align	2
 12314              		.global	CyFxGpifCB
 12316              	CyFxGpifCB:
 12317              	.LFB13:
3719:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12318              		.loc 1 3719 0
 12319              		.cfi_startproc
 12320              		@ args = 0, pretend = 0, frame = 0
 12321              		@ frame_needed = 0, uses_anonymous_args = 0
3720:../uvc.c      ****     {
 12322              		.loc 1 3720 0
 12323 663c 010050E3 		cmp	r0, #1
3719:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12324              		.loc 1 3719 0
 12325 6640 10402DE9 		stmfd	sp!, {r4, lr}
 12326              	.LCFI29:
 12327              		.cfi_def_cfa_offset 8
 12328              		.cfi_offset 4, -8
 12329              		.cfi_offset 14, -4
3720:../uvc.c      ****     {
 12330              		.loc 1 3720 0
 12331 6644 1080BD18 		ldmnefd	sp!, {r4, pc}
 12332              	.LBB470:
 12333              	.LBB471:
3617:../uvc.c      ****     {
 12334              		.loc 1 3617 0
 12335 6648 C4309FE5 		ldr	r3, .L1059
 12336 664c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12337 6650 030053E3 		cmp	r3, #3
 12338 6654 1000000A 		beq	.L1058
3643:../uvc.c      ****     {
 12339              		.loc 1 3643 0
 12340 6658 020053E3 		cmp	r3, #2
 12341 665c 1080BD18 		ldmnefd	sp!, {r4, pc}
3645:../uvc.c      ****         {
 12342              		.loc 1 3645 0
 12343 6660 083041E2 		sub	r3, r1, #8
 12344 6664 0A0053E3 		cmp	r3, #10
 12345 6668 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12346 666c 200000EA 		b	.L1051
 12347              	.L1053:
 12348 6670 EC660000 		.word	.L1046
 12349 6674 F4660000 		.word	.L1051
 12350 6678 F4660000 		.word	.L1051
 12351 667c BC660000 		.word	.L1042
 12352 6680 F4660000 		.word	.L1051
 12353 6684 F4660000 		.word	.L1051
 12354 6688 F4660000 		.word	.L1051
 12355 668c C0660000 		.word	.L1057
 12356 6690 F4660000 		.word	.L1051
 12357 6694 F4660000 		.word	.L1051
 12358 6698 BC660000 		.word	.L1042
 12359              	.L1058:
3619:../uvc.c      ****         {
 12360              		.loc 1 3619 0
 12361 669c 0B1041E2 		sub	r1, r1, #11
 12362 66a0 030051E3 		cmp	r1, #3
 12363 66a4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12364 66a8 150000EA 		b	.L1045
 12365              	.L1047:
 12366 66ac EC660000 		.word	.L1046
 12367 66b0 C0660000 		.word	.L1057
 12368 66b4 BC660000 		.word	.L1042
 12369 66b8 BC660000 		.word	.L1042
 12370              	.L1042:
 12371 66bc 1080BDE8 		ldmfd	sp!, {r4, pc}
 12372              	.L1057:
3645:../uvc.c      ****         {
 12373              		.loc 1 3645 0
 12374 66c0 0110A0E3 		mov	r1, #1
 12375              	.L1048:
3702:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12376              		.loc 1 3702 0
 12377 66c4 4C009FE5 		ldr	r0, .L1059+4
 12378 66c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3703:../uvc.c      ****         {
 12379              		.loc 1 3703 0
 12380 66cc 004050E2 		subs	r4, r0, #0
 12381 66d0 1080BD08 		ldmeqfd	sp!, {r4, pc}
3705:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12382              		.loc 1 3705 0
 12383 66d4 0400A0E3 		mov	r0, #4
 12384 66d8 3C109FE5 		ldr	r1, .L1059+8
 12385 66dc 0420A0E1 		mov	r2, r4
 12386 66e0 FEFFFFEB 		bl	CyU3PDebugPrint
3706:../uvc.c      ****         }
 12387              		.loc 1 3706 0
 12388 66e4 0400A0E1 		mov	r0, r4
 12389 66e8 FEFFFFEB 		bl	CyFxAppErrorHandler
 12390              	.L1046:
3619:../uvc.c      ****         {
 12391              		.loc 1 3619 0
 12392 66ec 0010A0E3 		mov	r1, #0
 12393 66f0 F3FFFFEA 		b	.L1048
 12394              	.L1051:
3691:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12395              		.loc 1 3691 0
 12396 66f4 0120A0E1 		mov	r2, r1
 12397 66f8 0100A0E3 		mov	r0, #1
 12398 66fc 1C109FE5 		ldr	r1, .L1059+12
 12399 6700 FEFFFFEB 		bl	CyU3PDebugPrint
 12400              	.L1045:
 12401              	.LBE471:
 12402              	.LBE470:
 12403              	.LBB472:
 12404              	.LBB473:
3726:../uvc.c      ****     }
 12405              		.loc 1 3726 0
 12406 6704 0400A0E3 		mov	r0, #4
 12407 6708 14109FE5 		ldr	r1, .L1059+16
 12408              	.LBE473:
 12409              	.LBE472:
3729:../uvc.c      **** 
 12410              		.loc 1 3729 0
 12411 670c 1040BDE8 		ldmfd	sp!, {r4, lr}
 12412              	.LBB475:
 12413              	.LBB474:
3726:../uvc.c      ****     }
 12414              		.loc 1 3726 0
 12415 6710 FEFFFFEA 		b	CyU3PDebugPrint
 12416              	.L1060:
 12417              		.align	2
 12418              	.L1059:
 12419 6714 00000000 		.word	.LANCHOR0
 12420 6718 00000000 		.word	glChHandleUVCStream
 12421 671c 040E0000 		.word	.LC80
 12422 6720 EC0D0000 		.word	.LC79
 12423 6724 340E0000 		.word	.LC81
 12424              	.LBE474:
 12425              	.LBE475:
 12426              		.cfi_endproc
 12427              	.LFE13:
 12429              		.align	2
 12430              		.global	CyFxApplicationDefine
 12432              	CyFxApplicationDefine:
 12433              	.LFB27:
5951:../uvc.c      **** }
5952:../uvc.c      **** 
5953:../uvc.c      **** 
5954:../uvc.c      **** /*
5955:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5956:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5957:../uvc.c      ****  */
5958:../uvc.c      **** void
5959:../uvc.c      **** CyFxApplicationDefine (
5960:../uvc.c      ****         void)
5961:../uvc.c      **** {
 12434              		.loc 1 5961 0
 12435              		.cfi_startproc
 12436              		@ args = 0, pretend = 0, frame = 32
 12437              		@ frame_needed = 0, uses_anonymous_args = 0
 12438              	.LVL1443:
 12439 6728 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12440              	.LCFI30:
 12441              		.cfi_def_cfa_offset 32
 12442              		.cfi_offset 4, -32
 12443              		.cfi_offset 5, -28
 12444              		.cfi_offset 6, -24
 12445              		.cfi_offset 7, -20
 12446              		.cfi_offset 8, -16
 12447              		.cfi_offset 9, -12
 12448              		.cfi_offset 10, -8
 12449              		.cfi_offset 14, -4
5962:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5963:../uvc.c      ****     uint32_t retThrdCreate;
5964:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5965:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5966:../uvc.c      **** 
5967:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5968:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12450              		.loc 1 5968 0
 12451 672c 010AA0E3 		mov	r0, #4096
5961:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12452              		.loc 1 5961 0
 12453 6730 40D04DE2 		sub	sp, sp, #64
 12454              	.LCFI31:
 12455              		.cfi_def_cfa_offset 96
 12456              		.loc 1 5968 0
 12457 6734 FEFFFFEB 		bl	CyU3PMemAlloc
 12458              	.LVL1444:
 12459 6738 0070A0E1 		mov	r7, r0
 12460              	.LVL1445:
5969:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12461              		.loc 1 5969 0
 12462 673c 010AA0E3 		mov	r0, #4096
 12463              	.LVL1446:
 12464 6740 FEFFFFEB 		bl	CyU3PMemAlloc
 12465              	.LVL1447:
 12466 6744 0060A0E1 		mov	r6, r0
 12467              	.LVL1448:
5970:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12468              		.loc 1 5970 0
 12469 6748 010AA0E3 		mov	r0, #4096
 12470              	.LVL1449:
 12471 674c FEFFFFEB 		bl	CyU3PMemAlloc
 12472              	.LVL1450:
5971:../uvc.c      **** 
5972:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12473              		.loc 1 5972 0
 12474 6750 000056E3 		cmp	r6, #0
 12475 6754 00005713 		cmpne	r7, #0
 12476 6758 00A0A013 		movne	r10, #0
 12477 675c 01A0A003 		moveq	r10, #1
5970:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12478              		.loc 1 5970 0
 12479 6760 0090A0E1 		mov	r9, r0
 12480              	.LVL1451:
 12481              		.loc 1 5972 0
 12482 6764 0000001A 		bne	.L1072
 12483              	.LVL1452:
 12484              	.L1062:
 12485              	.L1064:
 12486 6768 FEFFFFEA 		b	.L1064
 12487              	.LVL1453:
 12488              	.L1072:
 12489              		.loc 1 5972 0 is_stmt 0 discriminator 1
 12490 676c 000050E3 		cmp	r0, #0
 12491 6770 FCFFFF0A 		beq	.L1062
 12492              	.LVL1454:
5973:../uvc.c      ****         goto fatalErrorHandler;
5974:../uvc.c      **** 
5975:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5976:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5977:../uvc.c      ****     char *staName = "I2CstaQue";
5978:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12493              		.loc 1 5978 0 is_stmt 1
 12494 6774 F4309FE5 		ldr	r3, .L1073
 12495 6778 20008DE2 		add	r0, sp, #32
 12496              	.LVL1455:
 12497 677c 00308DE5 		str	r3, [sp]
 12498 6780 4010A0E3 		mov	r1, #64
 12499 6784 E8209FE5 		ldr	r2, .L1073+4
 12500 6788 0A30A0E1 		mov	r3, r10
 12501 678c FEFFFFEB 		bl	cmdbufCreate
 12502              	.LVL1456:
 12503 6790 20E08DE2 		add	lr, sp, #32
 12504 6794 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12505 6798 D8C09FE5 		ldr	ip, .L1073+8
5979:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5980:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5981:../uvc.c      **** 
5982:../uvc.c      **** 	/****** initialize command descriptor ***********/
5983:../uvc.c      **** 	cmdquInit(cmdQuptr);
5984:../uvc.c      **** 	cmdquInit(statQuptr);
5985:../uvc.c      **** 
5986:../uvc.c      ****     /* Create the UVC application thread. */
5987:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12506              		.loc 1 5987 0
 12507 679c 0840A0E3 		mov	r4, #8
5978:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12508              		.loc 1 5978 0
 12509 67a0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12510 67a4 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12511              		.loc 1 5987 0
 12512 67a8 0150A0E3 		mov	r5, #1
5978:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12513              		.loc 1 5978 0
 12514 67ac 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5983:../uvc.c      **** 	cmdquInit(statQuptr);
 12515              		.loc 1 5983 0
 12516 67b0 10004CE2 		sub	r0, ip, #16
 12517 67b4 FEFFFFEB 		bl	cmdquInit
 12518              	.LVL1457:
5984:../uvc.c      **** 
 12519              		.loc 1 5984 0
 12520 67b8 BC009FE5 		ldr	r0, .L1073+12
 12521 67bc FEFFFFEB 		bl	cmdquInit
 12522              	.LVL1458:
 12523              		.loc 1 5987 0
 12524 67c0 A880A0E3 		mov	r8, #168
 12525 67c4 012AA0E3 		mov	r2, #4096
 12526 67c8 0A30A0E1 		mov	r3, r10
 12527 67cc 14008DE9 		stmib	sp, {r2, r4}
 12528 67d0 A8009FE5 		ldr	r0, .L1073+16
 12529 67d4 00708DE5 		str	r7, [sp]
 12530 67d8 10A08DE5 		str	r10, [sp, #16]
 12531 67dc 0C408DE5 		str	r4, [sp, #12]
 12532 67e0 14508DE5 		str	r5, [sp, #20]
 12533 67e4 18808DE5 		str	r8, [sp, #24]
 12534 67e8 94109FE5 		ldr	r1, .L1073+20
 12535 67ec 94209FE5 		ldr	r2, .L1073+24
 12536 67f0 FEFFFFEB 		bl	_txe_thread_create
 12537              	.LVL1459:
5988:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5989:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5990:../uvc.c      ****             0,                                          /* No input parameter to thread */
5991:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5992:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5993:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5994:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5995:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5996:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5997:../uvc.c      ****             );
5998:../uvc.c      ****     if (retThrdCreate != 0)
 12538              		.loc 1 5998 0
 12539 67f4 003050E2 		subs	r3, r0, #0
 12540 67f8 DAFFFF1A 		bne	.L1062
5999:../uvc.c      ****     {
6000:../uvc.c      ****         goto fatalErrorHandler;
6001:../uvc.c      ****     }
6002:../uvc.c      **** 
6003:../uvc.c      ****     /* Create the control request handling thread. */
6004:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12541              		.loc 1 6004 0
 12542 67fc 027BA0E3 		mov	r7, #2048
 12543              	.LVL1460:
 12544 6800 10308DE5 		str	r3, [sp, #16]
 12545 6804 00608DE5 		str	r6, [sp]
 12546 6808 08408DE5 		str	r4, [sp, #8]
 12547 680c 0C408DE5 		str	r4, [sp, #12]
 12548 6810 14508DE5 		str	r5, [sp, #20]
 12549 6814 18808DE5 		str	r8, [sp, #24]
 12550 6818 04708DE5 		str	r7, [sp, #4]
 12551 681c 68009FE5 		ldr	r0, .L1073+28
 12552              	.LVL1461:
 12553 6820 68109FE5 		ldr	r1, .L1073+32
 12554 6824 68209FE5 		ldr	r2, .L1073+36
 12555 6828 FEFFFFEB 		bl	_txe_thread_create
 12556              	.LVL1462:
6005:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
6006:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
6007:../uvc.c      ****             0,                                                  /* No input parameter to thread */
6008:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
6009:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
6010:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
6011:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
6012:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
6013:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
6014:../uvc.c      ****             );
6015:../uvc.c      ****     if (retThrdCreate != 0)
 12557              		.loc 1 6015 0
 12558 682c 003050E2 		subs	r3, r0, #0
 12559 6830 CCFFFF1A 		bne	.L1062
6016:../uvc.c      ****     {
6017:../uvc.c      ****         goto fatalErrorHandler;
6018:../uvc.c      ****     }
6019:../uvc.c      **** #if 1
6020:../uvc.c      ****     /* Create the I2C control command handling thread. */
6021:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12560              		.loc 1 6021 0
 12561 6834 00908DE5 		str	r9, [sp]
 12562 6838 04708DE5 		str	r7, [sp, #4]
 12563 683c 08408DE5 		str	r4, [sp, #8]
 12564 6840 0C408DE5 		str	r4, [sp, #12]
 12565 6844 10308DE5 		str	r3, [sp, #16]
 12566 6848 14508DE5 		str	r5, [sp, #20]
 12567 684c 18808DE5 		str	r8, [sp, #24]
 12568 6850 40009FE5 		ldr	r0, .L1073+40
 12569              	.LVL1463:
 12570 6854 40109FE5 		ldr	r1, .L1073+44
 12571 6858 40209FE5 		ldr	r2, .L1073+48
 12572 685c FEFFFFEB 		bl	_txe_thread_create
 12573              	.LVL1464:
6022:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
6023:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
6024:../uvc.c      ****             0,                                          /* No input parameter to thread */
6025:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
6026:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
6027:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
6028:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
6029:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
6030:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
6031:../uvc.c      ****             );
6032:../uvc.c      ****     if (retThrdCreate != 0)
 12574              		.loc 1 6032 0
 12575 6860 000050E3 		cmp	r0, #0
 12576 6864 BFFFFF1A 		bne	.L1062
6033:../uvc.c      ****     {
6034:../uvc.c      ****         goto fatalErrorHandler;
6035:../uvc.c      ****     }
6036:../uvc.c      **** #endif
6037:../uvc.c      **** 
6038:../uvc.c      ****     return;
6039:../uvc.c      **** 
6040:../uvc.c      **** fatalErrorHandler:
6041:../uvc.c      ****     /* Add custom recovery or debug actions here */
6042:../uvc.c      ****     /* Loop indefinitely */
6043:../uvc.c      ****     while (1);
6044:../uvc.c      **** }
 12577              		.loc 1 6044 0
 12578 6868 40D08DE2 		add	sp, sp, #64
 12579              		@ sp needed
 12580 686c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12581              	.LVL1465:
 12582              	.L1074:
 12583              		.align	2
 12584              	.L1073:
 12585 6870 00000000 		.word	cmdQuMux
 12586 6874 4C0E0000 		.word	.LC82
 12587 6878 00000000 		.word	cmdQu
 12588 687c 00000000 		.word	statQu
 12589 6880 E4000000 		.word	.LANCHOR0+228
 12590 6884 580E0000 		.word	.LC83
 12591 6888 00000000 		.word	UVCAppThread_Entry
 12592 688c 8C010000 		.word	.LANCHOR0+396
 12593 6890 6C0E0000 		.word	.LC84
 12594 6894 00000000 		.word	UVCAppEP0Thread_Entry
 12595 6898 34020000 		.word	.LANCHOR0+564
 12596 689c 840E0000 		.word	.LC85
 12597 68a0 00000000 		.word	I2cAppThread_Entry
 12598              		.cfi_endproc
 12599              	.LFE27:
 12601              		.section	.text.startup,"ax",%progbits
 12602              		.align	2
 12603              		.global	main
 12605              	main:
 12606              	.LFB28:
6045:../uvc.c      **** 
6046:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
6047:../uvc.c      ****  * the ThreadX RTOS here.
6048:../uvc.c      ****  */
6049:../uvc.c      **** int
6050:../uvc.c      **** main (
6051:../uvc.c      ****         void)
6052:../uvc.c      **** {
 12607              		.loc 1 6052 0
 12608              		.cfi_startproc
 12609              		@ args = 0, pretend = 0, frame = 56
 12610              		@ frame_needed = 0, uses_anonymous_args = 0
 12611 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12612              	.LCFI32:
 12613              		.cfi_def_cfa_offset 12
 12614              		.cfi_offset 4, -12
 12615              		.cfi_offset 5, -8
 12616              		.cfi_offset 14, -4
 12617 0004 3CD04DE2 		sub	sp, sp, #60
 12618              	.LCFI33:
 12619              		.cfi_def_cfa_offset 72
6053:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
6054:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
6055:../uvc.c      **** 
6056:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
6057:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
6058:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12620              		.loc 1 6058 0
 12621 0008 0230A0E3 		mov	r3, #2
6059:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
6060:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
6061:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12622              		.loc 1 6061 0
 12623 000c 0010A0E3 		mov	r1, #0
6062:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12624              		.loc 1 6062 0
 12625 0010 0320A0E3 		mov	r2, #3
6057:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12626              		.loc 1 6057 0
 12627 0014 0150A0E3 		mov	r5, #1
6063:../uvc.c      **** 
6064:../uvc.c      ****     /* Initialize the device */
6065:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12628              		.loc 1 6065 0
 12629 0018 0D00A0E1 		mov	r0, sp
6057:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12630              		.loc 1 6057 0
 12631 001c 00508DE5 		str	r5, [sp]
6058:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12632              		.loc 1 6058 0
 12633 0020 0430CDE5 		strb	r3, [sp, #4]
6059:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12634              		.loc 1 6059 0
 12635 0024 0530CDE5 		strb	r3, [sp, #5]
6060:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12636              		.loc 1 6060 0
 12637 0028 0630CDE5 		strb	r3, [sp, #6]
6061:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12638              		.loc 1 6061 0
 12639 002c 08108DE5 		str	r1, [sp, #8]
6062:../uvc.c      **** 
 12640              		.loc 1 6062 0
 12641 0030 0C20CDE5 		strb	r2, [sp, #12]
 12642              		.loc 1 6065 0
 12643 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12644              	.LVL1466:
6066:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12645              		.loc 1 6066 0
 12646 0038 004050E2 		subs	r4, r0, #0
 12647 003c 0000000A 		beq	.L1080
 12648              	.L1076:
 12649              	.L1077:
 12650 0040 FEFFFFEA 		b	.L1077
 12651              	.L1080:
6067:../uvc.c      ****     {
6068:../uvc.c      ****         goto handle_fatal_error;
6069:../uvc.c      ****     }
6070:../uvc.c      **** 
6071:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
6072:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12652              		.loc 1 6072 0
 12653 0044 0410A0E1 		mov	r1, r4
 12654 0048 0420A0E1 		mov	r2, r4
 12655 004c 0500A0E1 		mov	r0, r5
 12656              	.LVL1467:
 12657 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12658              	.LVL1468:
6073:../uvc.c      **** 
6074:../uvc.c      ****     /* Configure the IO matrix for the device. */
6075:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
6076:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
6077:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
6078:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
6079:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
6080:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
6081:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
6082:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
6083:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
6084:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
6085:../uvc.c      **** 
6086:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12659              		.loc 1 6086 0
 12660 0054 10008DE2 		add	r0, sp, #16
6076:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12661              		.loc 1 6076 0
 12662 0058 2640CDE5 		strb	r4, [sp, #38]
6077:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12663              		.loc 1 6077 0
 12664 005c 28408DE5 		str	r4, [sp, #40]
6078:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12665              		.loc 1 6078 0
 12666 0060 2C408DE5 		str	r4, [sp, #44]
6079:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12667              		.loc 1 6079 0
 12668 0064 30408DE5 		str	r4, [sp, #48]
6080:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12669              		.loc 1 6080 0
 12670 0068 34408DE5 		str	r4, [sp, #52]
6083:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12671              		.loc 1 6083 0
 12672 006c 1C408DE5 		str	r4, [sp, #28]
6084:../uvc.c      **** 
 12673              		.loc 1 6084 0
 12674 0070 20408DE5 		str	r4, [sp, #32]
6075:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12675              		.loc 1 6075 0
 12676 0074 10508DE5 		str	r5, [sp, #16]
6081:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12677              		.loc 1 6081 0
 12678 0078 14508DE5 		str	r5, [sp, #20]
6082:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12679              		.loc 1 6082 0
 12680 007c 18508DE5 		str	r5, [sp, #24]
 12681              		.loc 1 6086 0
 12682 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12683              	.LVL1469:
6087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12684              		.loc 1 6087 0
 12685 0084 004050E2 		subs	r4, r0, #0
 12686 0088 ECFFFF1A 		bne	.L1076
6088:../uvc.c      ****     {
6089:../uvc.c      ****         goto handle_fatal_error;
6090:../uvc.c      ****     }
6091:../uvc.c      **** 
6092:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
6093:../uvc.c      ****     CyU3PKernelEntry ();
 12687              		.loc 1 6093 0
 12688 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12689              	.LVL1470:
6094:../uvc.c      **** 
6095:../uvc.c      ****     /* Dummy return to make the compiler happy */
6096:../uvc.c      ****     return 0;
6097:../uvc.c      **** 
6098:../uvc.c      **** handle_fatal_error:
6099:../uvc.c      ****     /* Cannot recover from this error. */
6100:../uvc.c      ****     while (1);
6101:../uvc.c      **** }
 12690              		.loc 1 6101 0
 12691 0090 0400A0E1 		mov	r0, r4
 12692 0094 3CD08DE2 		add	sp, sp, #60
 12693              		@ sp needed
 12694 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12695              		.cfi_endproc
 12696              	.LFE28:
 12698              		.comm	I2CCmdTimer,44,4
 12699              		.comm	posTick,4,4
 12700              		.global	glUVCHeader
 12701              		.global	glProbeStilCtrl20
 12702              		.global	glProbeCtrl20
 12703              		.global	glProbeStilCtrl
 12704              		.global	glProbeCtrlFull
 12705              		.global	glProbeCtrl
 12706              		.global	streamingStarted
 12707              		.global	clearFeatureRqtReceived
 12708              		.global	usbSpeed
 12709              		.global	isUsbConnected
 12710              		.global	pbcpbak
 12711              		.global	pbcbak
 12712              		.global	pbbak
 12713              		.global	fbbak
 12714              		.global	pbc
 12715              		.global	pb
 12716              		.global	fb
 12717              		.comm	wLength,2,2
 12718              		.comm	wIndex,2,2
 12719              		.comm	wValue,2,2
 12720              		.comm	bRequest,1,1
 12721              		.comm	bmReqType,1,1
 12722              		.comm	imgHdMux,56,4
 12723              		.comm	timMux,56,4
 12724              		.comm	staQuMux,56,4
 12725              		.comm	cmdQuMux,56,4
 12726              		.comm	statQu,32,4
 12727              		.comm	cmdQu,32,4
 12728              		.global	testSnap
 12729              		.global	snapButFlag
 12730              		.comm	glInterStaBuffer,4,4
 12731              		.comm	glChHandleInterStat,172,4
 12732              		.comm	glChHandleStillStream,232,4
 12733              		.comm	glChHandleUVCStream,232,4
 12734              		.global	CyFxGpifConfig_usb2
 12735              		.global	CyFxGpifRegValue_usb2
 12736              		.global	CyFxGpifWavedataPosition_usb2
 12737              		.global	CyFxGpifWavedata_usb2
 12738              		.global	CyFxGpifTransition_usb2
 12739              		.global	CyFxGpifConfig
 12740              		.global	CyFxGpifRegValue
 12741              		.global	CyFxGpifWavedataPosition
 12742              		.global	CyFxGpifWavedata
 12743              		.global	CyFxGpifTransition
 12744              		.section	.rodata
 12745              		.align	2
 12746              		.set	.LANCHOR2,. + 0
 12749              	ShutSp:
 12750 0000 3582     		.short	-32203
 12751 0002 1B41     		.short	16667
 12752 0004 8D20     		.short	8333
 12753 0006 A00F     		.short	4000
 12754 0008 D007     		.short	2000
 12755 000a E803     		.short	1000
 12756 000c F401     		.short	500
 12757 000e C800     		.short	200
 12758 0010 6400     		.short	100
 12759 0012 0A00     		.short	10
 12760 0014 0000     		.short	0
 12761 0016 00000000 		.space	10
 12761      00000000 
 12761      0000
 12764              	pEXTSenCtrl:
 12765 0020 74050000 		.word	EXTShutter
 12766 0024 D4080000 		.word	EXTSensUp
 12767 0028 C0080000 		.word	EXTMirror
 12768 002c AC080000 		.word	EXT3DnoiseReduceMode
 12769 0030 98080000 		.word	EXT3DNoiseLev
 12770 0034 84080000 		.word	EXTDayNightMode
 12771 0038 70080000 		.word	EXTDayNightdely
 12772 003c 5C080000 		.word	EXTDayNightlev
 12773 0040 48080000 		.word	EXTNightDaylev
 12774 0044 0C050000 		.word	EXTAexModGainlev
 12775 0048 34080000 		.word	EXTExpReflev
 12776 004c 88050000 		.word	EXTShutlev
 12777 0050 20080000 		.word	EXTCamMode
 12778 0054 00000000 		.word	0
 12779 0058 0C080000 		.word	EXTSensorPare
 12780 005c F8070000 		.word	EXTI2Ccmd
 12781 0060 00000000 		.word	0
 12782 0064 00000000 		.word	0
 12783 0068 00000000 		.word	0
 12784 006c 00000000 		.word	0
 12785 0070 9C050000 		.word	EXTBLCWinPos
 12786 0074 E4070000 		.word	EXTBLCWeight
 12787 0078 F8040000 		.word	EXTBLCGrid
 12788 007c D0070000 		.word	EXTExHyster
 12789 0080 BC070000 		.word	EXTExCtrlSped
 12790 0084 44070000 		.word	EXTEnhanceMode
 12791 0088 58070000 		.word	EXTEnhanceGain
 12792 008c A8070000 		.word	EXTEnhanceSTED
 12793 0090 94070000 		.word	EXT2DNRGain
 12794 0094 80070000 		.word	EXT2DNRSTED
 12795 0098 6C070000 		.word	EXTGammaCor
 12796 009c 00000000 		.word	0
 12797 00a0 00000000 		.word	0
 12798 00a4 00000000 		.space	124
 12798      00000000 
 12798      00000000 
 12798      00000000 
 12798      00000000 
 12801              	pPUCSenCtrl:
 12802 0120 60050000 		.word	PUCBLC
 12803 0124 20050000 		.word	PUCBright
 12804 0128 38090000 		.word	PUCContrast
 12805 012c 00000000 		.word	0
 12806 0130 48050000 		.word	PUCPLFreq
 12807 0134 34050000 		.word	PUCHueC
 12808 0138 24090000 		.word	PUCSaturation
 12809 013c 10090000 		.word	PUCSharp
 12810 0140 00000000 		.word	0
 12811 0144 FC080000 		.word	PUCWBMd
 12812 0148 00000000 		.word	0
 12813 014c E8080000 		.word	PUCWBLC
 12814 0150 00000000 		.word	0
 12815 0154 00000000 		.word	0
 12816 0158 30070000 		.word	PUCDZoom
 12817 015c 00000000 		.word	0
 12820              	CyFxGpifConfig:
 12821 0160 0F00     		.short	15
 12822 0162 0000     		.space	2
 12823 0164 00000000 		.word	CyFxGpifWavedata
 12824 0168 00000000 		.word	CyFxGpifWavedataPosition
 12825 016c 0500     		.short	5
 12826 016e 0000     		.space	2
 12827 0170 00000000 		.word	CyFxGpifTransition
 12828 0174 4C00     		.short	76
 12829 0176 0000     		.space	2
 12830 0178 00000000 		.word	CyFxGpifRegValue
 12833              	CyFxGpifConfig_usb2:
 12834 017c 9300     		.short	147
 12835 017e 0000     		.space	2
 12836 0180 00000000 		.word	CyFxGpifWavedata_usb2
 12837 0184 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12838 0188 0800     		.short	8
 12839 018a 0000     		.space	2
 12840 018c 00000000 		.word	CyFxGpifTransition_usb2
 12841 0190 4C00     		.short	76
 12842 0192 0000     		.space	2
 12843 0194 00000000 		.word	CyFxGpifRegValue_usb2
 12846              	ShutValueArry:
 12847 0198 C800     		.short	200
 12848 019a 6400     		.short	100
 12849 019c 2700     		.short	39
 12850 019e 1400     		.short	20
 12851 01a0 0A00     		.short	10
 12852 01a2 0500     		.short	5
 12853 01a4 0200     		.short	2
 12854 01a6 0100     		.short	1
 12855              		.data
 12856              		.align	2
 12857              		.set	.LANCHOR1,. + 0
 12860              	glProbeCtrlFull:
 12861 0000 00       		.byte	0
 12862 0001 00       		.byte	0
 12863 0002 01       		.byte	1
 12864 0003 01       		.byte	1
 12865 0004 15       		.byte	21
 12866 0005 16       		.byte	22
 12867 0006 05       		.byte	5
 12868 0007 00       		.byte	0
 12869 0008 00       		.byte	0
 12870 0009 00       		.byte	0
 12871 000a 00       		.byte	0
 12872 000b 00       		.byte	0
 12873 000c 00       		.byte	0
 12874 000d 00       		.byte	0
 12875 000e 00       		.byte	0
 12876 000f 00       		.byte	0
 12877 0010 00       		.byte	0
 12878 0011 00       		.byte	0
 12879 0012 00       		.byte	0
 12880 0013 C6       		.byte	-58
 12881 0014 99       		.byte	-103
 12882 0015 00       		.byte	0
 12883 0016 00       		.byte	0
 12884 0017 40       		.byte	64
 12885 0018 00       		.byte	0
 12886 0019 00       		.byte	0
 12887 001a 0000     		.space	2
 12890              	glProbeCtrl20:
 12891 001c 00       		.byte	0
 12892 001d 00       		.byte	0
 12893 001e 01       		.byte	1
 12894 001f 01       		.byte	1
 12895 0020 80       		.byte	-128
 12896 0021 1A       		.byte	26
 12897 0022 06       		.byte	6
 12898 0023 00       		.byte	0
 12899 0024 00       		.byte	0
 12900 0025 00       		.byte	0
 12901 0026 00       		.byte	0
 12902 0027 00       		.byte	0
 12903 0028 00       		.byte	0
 12904 0029 00       		.byte	0
 12905 002a 00       		.byte	0
 12906 002b 00       		.byte	0
 12907 002c 00       		.byte	0
 12908 002d 00       		.byte	0
 12909 002e 00       		.byte	0
 12910 002f D2       		.byte	-46
 12911 0030 0F       		.byte	15
 12912 0031 00       		.byte	0
 12913 0032 00       		.byte	0
 12914 0033 40       		.byte	64
 12915 0034 00       		.byte	0
 12916 0035 00       		.byte	0
 12917 0036 0000     		.space	2
 12920              	glProbeCtrl:
 12921 0038 00       		.byte	0
 12922 0039 00       		.byte	0
 12923 003a 01       		.byte	1
 12924 003b 01       		.byte	1
 12925 003c 15       		.byte	21
 12926 003d 16       		.byte	22
 12927 003e 05       		.byte	5
 12928 003f 00       		.byte	0
 12929 0040 00       		.byte	0
 12930 0041 00       		.byte	0
 12931 0042 00       		.byte	0
 12932 0043 00       		.byte	0
 12933 0044 00       		.byte	0
 12934 0045 00       		.byte	0
 12935 0046 00       		.byte	0
 12936 0047 00       		.byte	0
 12937 0048 00       		.byte	0
 12938 0049 00       		.byte	0
 12939 004a 00       		.byte	0
 12940 004b 48       		.byte	72
 12941 004c 3F       		.byte	63
 12942 004d 00       		.byte	0
 12943 004e 00       		.byte	0
 12944 004f 40       		.byte	64
 12945 0050 00       		.byte	0
 12946 0051 00       		.byte	0
 12949              	ROIMode:
 12950 0052 01       		.byte	1
 12951 0053 00       		.space	1
 12954              	glProbeStilCtrl:
 12955 0054 01       		.byte	1
 12956 0055 02       		.byte	2
 12957 0056 00       		.byte	0
 12958 0057 00       		.byte	0
 12959 0058 C6       		.byte	-58
 12960 0059 99       		.byte	-103
 12961 005a 00       		.byte	0
 12962 005b 00       		.byte	0
 12963 005c 40       		.byte	64
 12964 005d 00       		.byte	0
 12965 005e 00       		.byte	0
 12966 005f 00       		.space	1
 12969              	glProbeStilCtrl20:
 12970 0060 01       		.byte	1
 12971 0061 01       		.byte	1
 12972 0062 00       		.byte	0
 12973 0063 00       		.byte	0
 12974 0064 D2       		.byte	-46
 12975 0065 0F       		.byte	15
 12976 0066 00       		.byte	0
 12977 0067 00       		.byte	0
 12978 0068 40       		.byte	64
 12979 0069 00       		.byte	0
 12980 006a 00       		.byte	0
 12981 006b 00       		.space	1
 12984              	ExUCtrlParArry:
 12985 006c 00       		.byte	0
 12986 006d 00       		.byte	0
 12987 006e 04       		.byte	4
 12988 006f 01       		.byte	1
 12989 0070 00       		.byte	0
 12990 0071 38       		.byte	56
 12991 0072 01       		.byte	1
 12992 0073 01       		.byte	1
 12993 0074 00       		.byte	0
 12994 0075 03       		.byte	3
 12995 0076 00       		.byte	0
 12996 0077 4E       		.byte	78
 12997 0078 00       		.byte	0
 12998 0079 4E       		.byte	78
 12999 007a 00       		.byte	0
 13000 007b 30       		.byte	48
 13001 007c 01       		.byte	1
 13002 007d 00       		.byte	0
 13003 007e 00       		.byte	0
 13004 007f 00000000 		.space	5
 13004      00
 13005 0084 00       		.byte	0
 13006 0085 00       		.byte	0
 13007 0086 01       		.byte	1
 13008 0087 00       		.byte	0
 13009 0088 00       		.byte	0
 13010 0089 00       		.byte	0
 13011 008a 00       		.byte	0
 13012 008b 01       		.byte	1
 13013 008c 00       		.byte	0
 13014 008d 03       		.byte	3
 13015 008e 00       		.byte	0
 13016 008f 00       		.byte	0
 13017 0090 00       		.byte	0
 13018 0091 00       		.byte	0
 13019 0092 00       		.byte	0
 13020 0093 30       		.byte	48
 13021 0094 01       		.byte	1
 13022 0095 00       		.byte	0
 13023 0096 00       		.byte	0
 13024 0097 00000000 		.space	5
 13024      00
 13025 009c 00       		.byte	0
 13026 009d 00       		.byte	0
 13027 009e 02       		.byte	2
 13028 009f 00       		.byte	0
 13029 00a0 00       		.byte	0
 13030 00a1 FF       		.byte	-1
 13031 00a2 00       		.byte	0
 13032 00a3 01       		.byte	1
 13033 00a4 00       		.byte	0
 13034 00a5 03       		.byte	3
 13035 00a6 00       		.byte	0
 13036 00a7 01       		.byte	1
 13037 00a8 00       		.byte	0
 13038 00a9 00       		.byte	0
 13039 00aa 00       		.byte	0
 13040 00ab 30       		.byte	48
 13041 00ac 01       		.byte	1
 13042 00ad 01       		.byte	1
 13043 00ae 00       		.byte	0
 13044 00af 00000000 		.space	5
 13044      00
 13045 00b4 00       		.byte	0
 13046 00b5 00       		.byte	0
 13047 00b6 02       		.byte	2
 13048 00b7 00       		.byte	0
 13049 00b8 00       		.byte	0
 13050 00b9 00       		.byte	0
 13051 00ba 00       		.byte	0
 13052 00bb 00       		.byte	0
 13053 00bc 00       		.byte	0
 13054 00bd 03       		.byte	3
 13055 00be 00       		.byte	0
 13056 00bf 00       		.byte	0
 13057 00c0 00       		.byte	0
 13058 00c1 00       		.byte	0
 13059 00c2 00       		.byte	0
 13060 00c3 30       		.byte	48
 13061 00c4 01       		.byte	1
 13062 00c5 01       		.byte	1
 13063 00c6 00       		.byte	0
 13064 00c7 00000000 		.space	5
 13064      00
 13065 00cc 13       		.byte	19
 13066 00cd 14       		.byte	20
 13067 00ce 02       		.byte	2
 13068 00cf 00       		.byte	0
 13069 00d0 00       		.byte	0
 13070 00d1 FF       		.byte	-1
 13071 00d2 FF       		.byte	-1
 13072 00d3 01       		.byte	1
 13073 00d4 00       		.byte	0
 13074 00d5 03       		.byte	3
 13075 00d6 00       		.byte	0
 13076 00d7 66       		.byte	102
 13077 00d8 66       		.byte	102
 13078 00d9 66       		.byte	102
 13079 00da 66       		.byte	102
 13080 00db 30       		.byte	48
 13081 00dc 01       		.byte	1
 13082 00dd 00       		.byte	0
 13083 00de 00       		.byte	0
 13084 00df 00000000 		.space	5
 13084      00
 13085 00e4 11       		.byte	17
 13086 00e5 00       		.byte	0
 13087 00e6 02       		.byte	2
 13088 00e7 01       		.byte	1
 13089 00e8 00       		.byte	0
 13090 00e9 03       		.byte	3
 13091 00ea 00       		.byte	0
 13092 00eb 01       		.byte	1
 13093 00ec 00       		.byte	0
 13094 00ed 03       		.byte	3
 13095 00ee 00       		.byte	0
 13096 00ef 80       		.byte	-128
 13097 00f0 00       		.byte	0
 13098 00f1 80       		.byte	-128
 13099 00f2 00       		.byte	0
 13100 00f3 30       		.byte	48
 13101 00f4 01       		.byte	1
 13102 00f5 01       		.byte	1
 13103 00f6 00       		.byte	0
 13104 00f7 00000000 		.space	5
 13104      00
 13105 00fc 10       		.byte	16
 13106 00fd 00       		.byte	0
 13107 00fe 01       		.byte	1
 13108 00ff 01       		.byte	1
 13109 0100 00       		.byte	0
 13110 0101 02       		.byte	2
 13111 0102 00       		.byte	0
 13112 0103 01       		.byte	1
 13113 0104 00       		.byte	0
 13114 0105 03       		.byte	3
 13115 0106 00       		.byte	0
 13116 0107 00       		.byte	0
 13117 0108 00       		.byte	0
 13118 0109 00       		.byte	0
 13119 010a 00       		.byte	0
 13120 010b 30       		.byte	48
 13121 010c 01       		.byte	1
 13122 010d 01       		.byte	1
 13123 010e 00       		.byte	0
 13124 010f 00000000 		.space	5
 13124      00
 13125 0114 00       		.byte	0
 13126 0115 00       		.byte	0
 13127 0116 04       		.byte	4
 13128 0117 01       		.byte	1
 13129 0118 00       		.byte	0
 13130 0119 38       		.byte	56
 13131 011a 01       		.byte	1
 13132 011b 01       		.byte	1
 13133 011c 00       		.byte	0
 13134 011d 03       		.byte	3
 13135 011e 00       		.byte	0
 13136 011f 4E       		.byte	78
 13137 0120 00       		.byte	0
 13138 0121 4E       		.byte	78
 13139 0122 00       		.byte	0
 13140 0123 30       		.byte	48
 13141 0124 01       		.byte	1
 13142 0125 00       		.byte	0
 13143 0126 00       		.byte	0
 13144 0127 00000000 		.space	5
 13144      00
 13145 012c 00       		.byte	0
 13146 012d 00       		.byte	0
 13147 012e 01       		.byte	1
 13148 012f 00       		.byte	0
 13149 0130 00       		.byte	0
 13150 0131 00       		.byte	0
 13151 0132 00       		.byte	0
 13152 0133 01       		.byte	1
 13153 0134 00       		.byte	0
 13154 0135 03       		.byte	3
 13155 0136 00       		.byte	0
 13156 0137 00       		.byte	0
 13157 0138 00       		.byte	0
 13158 0139 00       		.byte	0
 13159 013a 00       		.byte	0
 13160 013b 30       		.byte	48
 13161 013c 01       		.byte	1
 13162 013d 00       		.byte	0
 13163 013e 00       		.byte	0
 13164 013f 00000000 		.space	5
 13164      00
 13165 0144 00       		.byte	0
 13166 0145 00       		.byte	0
 13167 0146 02       		.byte	2
 13168 0147 00       		.byte	0
 13169 0148 00       		.byte	0
 13170 0149 05       		.byte	5
 13171 014a 00       		.byte	0
 13172 014b 01       		.byte	1
 13173 014c 00       		.byte	0
 13174 014d 03       		.byte	3
 13175 014e 00       		.byte	0
 13176 014f 00       		.byte	0
 13177 0150 00       		.byte	0
 13178 0151 00       		.byte	0
 13179 0152 00       		.byte	0
 13180 0153 30       		.byte	48
 13181 0154 01       		.byte	1
 13182 0155 00       		.byte	0
 13183 0156 00       		.byte	0
 13184 0157 00000000 		.space	5
 13184      00
 13185 015c 00       		.byte	0
 13186 015d 00       		.byte	0
 13187 015e 03       		.byte	3
 13188 015f 00       		.byte	0
 13189 0160 00       		.byte	0
 13190 0161 0A       		.byte	10
 13191 0162 00       		.byte	0
 13192 0163 01       		.byte	1
 13193 0164 00       		.byte	0
 13194 0165 03       		.byte	3
 13195 0166 00       		.byte	0
 13196 0167 00       		.byte	0
 13197 0168 00       		.byte	0
 13198 0169 00       		.byte	0
 13199 016a 00       		.byte	0
 13200 016b 30       		.byte	48
 13201 016c 01       		.byte	1
 13202 016d 00       		.byte	0
 13203 016e 00       		.byte	0
 13204 016f 00000000 		.space	5
 13204      00
 13205 0174 00       		.byte	0
 13206 0175 00       		.byte	0
 13207 0176 02       		.byte	2
 13208 0177 00       		.byte	0
 13209 0178 00       		.byte	0
 13210 0179 40       		.byte	64
 13211 017a 00       		.byte	0
 13212 017b 01       		.byte	1
 13213 017c 00       		.byte	0
 13214 017d 03       		.byte	3
 13215 017e 00       		.byte	0
 13216 017f 0F       		.byte	15
 13217 0180 11       		.byte	17
 13218 0181 00       		.byte	0
 13219 0182 00       		.byte	0
 13220 0183 30       		.byte	48
 13221 0184 01       		.byte	1
 13222 0185 00       		.byte	0
 13223 0186 00       		.byte	0
 13224 0187 00000000 		.space	5
 13224      00
 13225 018c 00       		.byte	0
 13226 018d 00       		.byte	0
 13227 018e 02       		.byte	2
 13228 018f 00       		.byte	0
 13229 0190 00       		.byte	0
 13230 0191 64       		.byte	100
 13231 0192 00       		.byte	0
 13232 0193 01       		.byte	1
 13233 0194 00       		.byte	0
 13234 0195 03       		.byte	3
 13235 0196 00       		.byte	0
 13236 0197 00       		.byte	0
 13237 0198 00       		.byte	0
 13238 0199 00       		.byte	0
 13239 019a 00       		.byte	0
 13240 019b 30       		.byte	48
 13241 019c 01       		.byte	1
 13242 019d 00       		.byte	0
 13243 019e 00       		.byte	0
 13244 019f 00000000 		.space	5
 13244      00
 13245 01a4 00       		.byte	0
 13246 01a5 00       		.byte	0
 13247 01a6 02       		.byte	2
 13248 01a7 00       		.byte	0
 13249 01a8 00       		.byte	0
 13250 01a9 64       		.byte	100
 13251 01aa 00       		.byte	0
 13252 01ab 01       		.byte	1
 13253 01ac 00       		.byte	0
 13254 01ad 03       		.byte	3
 13255 01ae 00       		.byte	0
 13256 01af 00       		.byte	0
 13257 01b0 00       		.byte	0
 13258 01b1 00       		.byte	0
 13259 01b2 00       		.byte	0
 13260 01b3 30       		.byte	48
 13261 01b4 01       		.byte	1
 13262 01b5 00       		.byte	0
 13263 01b6 00       		.byte	0
 13264 01b7 00000000 		.space	5
 13264      00
 13265 01bc 00       		.byte	0
 13266 01bd 00       		.byte	0
 13267 01be 02       		.byte	2
 13268 01bf 00       		.byte	0
 13269 01c0 00       		.byte	0
 13270 01c1 64       		.byte	100
 13271 01c2 00       		.byte	0
 13272 01c3 01       		.byte	1
 13273 01c4 00       		.byte	0
 13274 01c5 03       		.byte	3
 13275 01c6 00       		.byte	0
 13276 01c7 00       		.byte	0
 13277 01c8 00       		.byte	0
 13278 01c9 00       		.byte	0
 13279 01ca 00       		.byte	0
 13280 01cb 30       		.byte	48
 13281 01cc 01       		.byte	1
 13282 01cd 00       		.byte	0
 13283 01ce 00       		.byte	0
 13284 01cf 00000000 		.space	5
 13284      00
 13285 01d4 00       		.byte	0
 13286 01d5 00       		.byte	0
 13287 01d6 02       		.byte	2
 13288 01d7 00       		.byte	0
 13289 01d8 00       		.byte	0
 13290 01d9 64       		.byte	100
 13291 01da 00       		.byte	0
 13292 01db 01       		.byte	1
 13293 01dc 00       		.byte	0
 13294 01dd 03       		.byte	3
 13295 01de 00       		.byte	0
 13296 01df 00       		.byte	0
 13297 01e0 00       		.byte	0
 13298 01e1 00       		.byte	0
 13299 01e2 00       		.byte	0
 13300 01e3 30       		.byte	48
 13301 01e4 01       		.byte	1
 13302 01e5 00       		.byte	0
 13303 01e6 00       		.byte	0
 13304 01e7 00000000 		.space	5
 13304      00
 13307              	CtrlParArry:
 13308 01ec 10       		.byte	16
 13309 01ed 10       		.byte	16
 13310 01ee 02       		.byte	2
 13311 01ef 00       		.byte	0
 13312 01f0 00       		.byte	0
 13313 01f1 03       		.byte	3
 13314 01f2 00       		.byte	0
 13315 01f3 01       		.byte	1
 13316 01f4 00       		.byte	0
 13317 01f5 03       		.byte	3
 13318 01f6 00       		.byte	0
 13319 01f7 03       		.byte	3
 13320 01f8 00       		.byte	0
 13321 01f9 03       		.byte	3
 13322 01fa 00       		.byte	0
 13323 01fb 30       		.byte	48
 13324 01fc 01       		.byte	1
 13325 01fd 00       		.byte	0
 13326 01fe 00       		.byte	0
 13327 01ff 00000000 		.space	5
 13327      00
 13328 0204 15       		.byte	21
 13329 0205 15       		.byte	21
 13330 0206 02       		.byte	2
 13331 0207 00       		.byte	0
 13332 0208 00       		.byte	0
 13333 0209 FF       		.byte	-1
 13334 020a 00       		.byte	0
 13335 020b 01       		.byte	1
 13336 020c 00       		.byte	0
 13337 020d 03       		.byte	3
 13338 020e 00       		.byte	0
 13339 020f 76       		.byte	118
 13340 0210 00       		.byte	0
 13341 0211 76       		.byte	118
 13342 0212 C7       		.byte	-57
 13343 0213 30       		.byte	48
 13344 0214 01       		.byte	1
 13345 0215 01       		.byte	1
 13346 0216 00       		.byte	0
 13347 0217 00000000 		.space	5
 13347      00
 13348 021c 04       		.byte	4
 13349 021d 04       		.byte	4
 13350 021e 02       		.byte	2
 13351 021f 00       		.byte	0
 13352 0220 00       		.byte	0
 13353 0221 FF       		.byte	-1
 13354 0222 00       		.byte	0
 13355 0223 01       		.byte	1
 13356 0224 00       		.byte	0
 13357 0225 03       		.byte	3
 13358 0226 00       		.byte	0
 13359 0227 70       		.byte	112
 13360 0228 00       		.byte	0
 13361 0229 70       		.byte	112
 13362 022a 00       		.byte	0
 13363 022b 30       		.byte	48
 13364 022c 01       		.byte	1
 13365 022d 01       		.byte	1
 13366 022e 00       		.byte	0
 13367 022f 00000000 		.space	5
 13367      00
 13368 0234 00       		.byte	0
 13369 0235 00       		.byte	0
 13370 0236 02       		.byte	2
 13371 0237 00       		.byte	0
 13372 0238 00       		.byte	0
 13373 0239 64       		.byte	100
 13374 023a 00       		.byte	0
 13375 023b 01       		.byte	1
 13376 023c 00       		.byte	0
 13377 023d 03       		.byte	3
 13378 023e 00       		.byte	0
 13379 023f 00       		.byte	0
 13380 0240 00       		.byte	0
 13381 0241 00       		.byte	0
 13382 0242 00       		.byte	0
 13383 0243 30       		.byte	48
 13384 0244 01       		.byte	1
 13385 0245 00       		.byte	0
 13386 0246 00       		.byte	0
 13387 0247 00000000 		.space	5
 13387      00
 13388 024c 07       		.byte	7
 13389 024d 07       		.byte	7
 13390 024e 02       		.byte	2
 13391 024f 00       		.byte	0
 13392 0250 00       		.byte	0
 13393 0251 01       		.byte	1
 13394 0252 00       		.byte	0
 13395 0253 01       		.byte	1
 13396 0254 00       		.byte	0
 13397 0255 03       		.byte	3
 13398 0256 00       		.byte	0
 13399 0257 01       		.byte	1
 13400 0258 00       		.byte	0
 13401 0259 01       		.byte	1
 13402 025a 00       		.byte	0
 13403 025b 30       		.byte	48
 13404 025c 01       		.byte	1
 13405 025d 00       		.byte	0
 13406 025e 00       		.byte	0
 13407 025f 00000000 		.space	5
 13407      00
 13408 0264 DF       		.byte	-33
 13409 0265 E1       		.byte	-31
 13410 0266 02       		.byte	2
 13411 0267 00       		.byte	0
 13412 0268 00       		.byte	0
 13413 0269 FF       		.byte	-1
 13414 026a 00       		.byte	0
 13415 026b 01       		.byte	1
 13416 026c 00       		.byte	0
 13417 026d 03       		.byte	3
 13418 026e 00       		.byte	0
 13419 026f 80       		.byte	-128
 13420 0270 00       		.byte	0
 13421 0271 00       		.byte	0
 13422 0272 00       		.byte	0
 13423 0273 C6       		.byte	-58
 13424 0274 01       		.byte	1
 13425 0275 01       		.byte	1
 13426 0276 00       		.byte	0
 13427 0277 00000000 		.space	5
 13427      00
 13428 027c 85       		.byte	-123
 13429 027d 86       		.byte	-122
 13430 027e 02       		.byte	2
 13431 027f 00       		.byte	0
 13432 0280 00       		.byte	0
 13433 0281 64       		.byte	100
 13434 0282 00       		.byte	0
 13435 0283 01       		.byte	1
 13436 0284 00       		.byte	0
 13437 0285 03       		.byte	3
 13438 0286 00       		.byte	0
 13439 0287 32       		.byte	50
 13440 0288 00       		.byte	0
 13441 0289 32       		.byte	50
 13442 028a 00       		.byte	0
 13443 028b F2       		.byte	-14
 13444 028c 01       		.byte	1
 13445 028d 01       		.byte	1
 13446 028e 00       		.byte	0
 13447 028f 00000000 		.space	5
 13447      00
 13448 0294 06       		.byte	6
 13449 0295 07       		.byte	7
 13450 0296 02       		.byte	2
 13451 0297 00       		.byte	0
 13452 0298 00       		.byte	0
 13453 0299 FF       		.byte	-1
 13454 029a 00       		.byte	0
 13455 029b 01       		.byte	1
 13456 029c 00       		.byte	0
 13457 029d 03       		.byte	3
 13458 029e 00       		.byte	0
 13459 029f 20       		.byte	32
 13460 02a0 00       		.byte	0
 13461 02a1 20       		.byte	32
 13462 02a2 00       		.byte	0
 13463 02a3 30       		.byte	48
 13464 02a4 01       		.byte	1
 13465 02a5 01       		.byte	1
 13466 02a6 00       		.byte	0
 13467 02a7 00000000 		.space	5
 13467      00
 13468 02ac 00       		.byte	0
 13469 02ad 00       		.byte	0
 13470 02ae 02       		.byte	2
 13471 02af 00       		.byte	0
 13472 02b0 00       		.byte	0
 13473 02b1 64       		.byte	100
 13474 02b2 00       		.byte	0
 13475 02b3 01       		.byte	1
 13476 02b4 00       		.byte	0
 13477 02b5 03       		.byte	3
 13478 02b6 00       		.byte	0
 13479 02b7 00       		.byte	0
 13480 02b8 00       		.byte	0
 13481 02b9 00       		.byte	0
 13482 02ba 00       		.byte	0
 13483 02bb 30       		.byte	48
 13484 02bc 01       		.byte	1
 13485 02bd 00       		.byte	0
 13486 02be 00       		.byte	0
 13487 02bf 00000000 		.space	5
 13487      00
 13488 02c4 08       		.byte	8
 13489 02c5 08       		.byte	8
 13490 02c6 02       		.byte	2
 13491 02c7 00       		.byte	0
 13492 02c8 00       		.byte	0
 13493 02c9 05       		.byte	5
 13494 02ca 00       		.byte	0
 13495 02cb 01       		.byte	1
 13496 02cc 00       		.byte	0
 13497 02cd 03       		.byte	3
 13498 02ce 00       		.byte	0
 13499 02cf 00       		.byte	0
 13500 02d0 00       		.byte	0
 13501 02d1 00       		.byte	0
 13502 02d2 00       		.byte	0
 13503 02d3 30       		.byte	48
 13504 02d4 01       		.byte	1
 13505 02d5 00       		.byte	0
 13506 02d6 00       		.byte	0
 13507 02d7 00000000 		.space	5
 13507      00
 13508 02dc 00       		.byte	0
 13509 02dd 00       		.byte	0
 13510 02de 02       		.byte	2
 13511 02df 00       		.byte	0
 13512 02e0 00       		.byte	0
 13513 02e1 40       		.byte	64
 13514 02e2 00       		.byte	0
 13515 02e3 01       		.byte	1
 13516 02e4 00       		.byte	0
 13517 02e5 03       		.byte	3
 13518 02e6 00       		.byte	0
 13519 02e7 00       		.byte	0
 13520 02e8 00       		.byte	0
 13521 02e9 00       		.byte	0
 13522 02ea 00       		.byte	0
 13523 02eb 30       		.byte	48
 13524 02ec 01       		.byte	1
 13525 02ed 00       		.byte	0
 13526 02ee 00       		.byte	0
 13527 02ef 00000000 		.space	5
 13527      00
 13528 02f4 09       		.byte	9
 13529 02f5 0A       		.byte	10
 13530 02f6 04       		.byte	4
 13531 02f7 00       		.byte	0
 13532 02f8 00       		.byte	0
 13533 02f9 40       		.byte	64
 13534 02fa 00       		.byte	0
 13535 02fb 01       		.byte	1
 13536 02fc 00       		.byte	0
 13537 02fd 03       		.byte	3
 13538 02fe 00       		.byte	0
 13539 02ff 20       		.byte	32
 13540 0300 38       		.byte	56
 13541 0301 20       		.byte	32
 13542 0302 38       		.byte	56
 13543 0303 30       		.byte	48
 13544 0304 01       		.byte	1
 13545 0305 00       		.byte	0
 13546 0306 00       		.byte	0
 13547 0307 00000000 		.space	5
 13547      00
 13548 030c 00       		.byte	0
 13549 030d 00       		.byte	0
 13550 030e 02       		.byte	2
 13551 030f 00       		.byte	0
 13552 0310 00       		.byte	0
 13553 0311 64       		.byte	100
 13554 0312 00       		.byte	0
 13555 0313 01       		.byte	1
 13556 0314 00       		.byte	0
 13557 0315 03       		.byte	3
 13558 0316 00       		.byte	0
 13559 0317 00       		.byte	0
 13560 0318 00       		.byte	0
 13561 0319 00       		.byte	0
 13562 031a 00       		.byte	0
 13563 031b 30       		.byte	48
 13564 031c 01       		.byte	1
 13565 031d 00       		.byte	0
 13566 031e 00       		.byte	0
 13567 031f 00000000 		.space	5
 13567      00
 13568 0324 00       		.byte	0
 13569 0325 00       		.byte	0
 13570 0326 02       		.byte	2
 13571 0327 00       		.byte	0
 13572 0328 00       		.byte	0
 13573 0329 64       		.byte	100
 13574 032a 00       		.byte	0
 13575 032b 01       		.byte	1
 13576 032c 00       		.byte	0
 13577 032d 03       		.byte	3
 13578 032e 00       		.byte	0
 13579 032f 00       		.byte	0
 13580 0330 00       		.byte	0
 13581 0331 00       		.byte	0
 13582 0332 00       		.byte	0
 13583 0333 30       		.byte	48
 13584 0334 01       		.byte	1
 13585 0335 00       		.byte	0
 13586 0336 00       		.byte	0
 13587 0337 00000000 		.space	5
 13587      00
 13588 033c 2A       		.byte	42
 13589 033d 2A       		.byte	42
 13590 033e 02       		.byte	2
 13591 033f 00       		.byte	0
 13592 0340 00       		.byte	0
 13593 0341 1B       		.byte	27
 13594 0342 00       		.byte	0
 13595 0343 01       		.byte	1
 13596 0344 00       		.byte	0
 13597 0345 03       		.byte	3
 13598 0346 00       		.byte	0
 13599 0347 00       		.byte	0
 13600 0348 00       		.byte	0
 13601 0349 00       		.byte	0
 13602 034a 00       		.byte	0
 13603 034b 30       		.byte	48
 13604 034c 01       		.byte	1
 13605 034d 00       		.byte	0
 13606 034e 00       		.byte	0
 13607 034f 00000000 		.space	5
 13607      00
 13608 0354 00       		.byte	0
 13609 0355 00       		.byte	0
 13610 0356 02       		.byte	2
 13611 0357 00       		.byte	0
 13612 0358 00       		.byte	0
 13613 0359 64       		.byte	100
 13614 035a 00       		.byte	0
 13615 035b 01       		.byte	1
 13616 035c 00       		.byte	0
 13617 035d 03       		.byte	3
 13618 035e 00       		.byte	0
 13619 035f 00       		.byte	0
 13620 0360 00       		.byte	0
 13621 0361 00       		.byte	0
 13622 0362 00       		.byte	0
 13623 0363 30       		.byte	48
 13624 0364 01       		.byte	1
 13625 0365 00       		.byte	0
 13626 0366 00       		.byte	0
 13627 0367 00000000 		.space	5
 13627      00
 13628 036c 00       		.byte	0
 13629 036d 00       		.byte	0
 13630 036e 02       		.byte	2
 13631 036f 00       		.byte	0
 13632 0370 00       		.byte	0
 13633 0371 12       		.byte	18
 13634 0372 00       		.byte	0
 13635 0373 01       		.byte	1
 13636 0374 00       		.byte	0
 13637 0375 03       		.byte	3
 13638 0376 00       		.byte	0
 13639 0377 00       		.byte	0
 13640 0378 00       		.byte	0
 13641 0379 00       		.byte	0
 13642 037a 00       		.byte	0
 13643 037b 30       		.byte	48
 13644 037c 01       		.byte	1
 13645 037d 00       		.byte	0
 13646 037e 00       		.byte	0
 13647 037f 00000000 		.space	5
 13647      00
 13648 0384 01       		.byte	1
 13649 0385 01       		.byte	1
 13650 0386 02       		.byte	2
 13651 0387 00       		.byte	0
 13652 0388 00       		.byte	0
 13653 0389 09       		.byte	9
 13654 038a 00       		.byte	0
 13655 038b 01       		.byte	1
 13656 038c 00       		.byte	0
 13657 038d 03       		.byte	3
 13658 038e 00       		.byte	0
 13659 038f 00       		.byte	0
 13660 0390 00       		.byte	0
 13661 0391 01       		.byte	1
 13662 0392 00       		.byte	0
 13663 0393 30       		.byte	48
 13664 0394 01       		.byte	1
 13665 0395 00       		.byte	0
 13666 0396 00       		.byte	0
 13667 0397 00000000 		.space	5
 13667      00
 13668 039c 05       		.byte	5
 13669 039d 05       		.byte	5
 13670 039e 02       		.byte	2
 13671 039f 00       		.byte	0
 13672 03a0 00       		.byte	0
 13673 03a1 03       		.byte	3
 13674 03a2 00       		.byte	0
 13675 03a3 01       		.byte	1
 13676 03a4 00       		.byte	0
 13677 03a5 03       		.byte	3
 13678 03a6 00       		.byte	0
 13679 03a7 00       		.byte	0
 13680 03a8 00       		.byte	0
 13681 03a9 00       		.byte	0
 13682 03aa 00       		.byte	0
 13683 03ab 30       		.byte	48
 13684 03ac 01       		.byte	1
 13685 03ad 00       		.byte	0
 13686 03ae 00       		.byte	0
 13687 03af 00000000 		.space	5
 13687      00
 13688 03b4 18       		.byte	24
 13689 03b5 18       		.byte	24
 13690 03b6 02       		.byte	2
 13691 03b7 00       		.byte	0
 13692 03b8 00       		.byte	0
 13693 03b9 01       		.byte	1
 13694 03ba 00       		.byte	0
 13695 03bb 01       		.byte	1
 13696 03bc 00       		.byte	0
 13697 03bd 03       		.byte	3
 13698 03be 00       		.byte	0
 13699 03bf 00       		.byte	0
 13700 03c0 00       		.byte	0
 13701 03c1 00       		.byte	0
 13702 03c2 00       		.byte	0
 13703 03c3 30       		.byte	48
 13704 03c4 01       		.byte	1
 13705 03c5 00       		.byte	0
 13706 03c6 00       		.byte	0
 13707 03c7 00000000 		.space	5
 13707      00
 13708 03cc 19       		.byte	25
 13709 03cd 19       		.byte	25
 13710 03ce 01       		.byte	1
 13711 03cf 00       		.byte	0
 13712 03d0 00       		.byte	0
 13713 03d1 40       		.byte	64
 13714 03d2 00       		.byte	0
 13715 03d3 01       		.byte	1
 13716 03d4 00       		.byte	0
 13717 03d5 03       		.byte	3
 13718 03d6 00       		.byte	0
 13719 03d7 20       		.byte	32
 13720 03d8 00       		.byte	0
 13721 03d9 20       		.byte	32
 13722 03da 00       		.byte	0
 13723 03db 30       		.byte	48
 13724 03dc 01       		.byte	1
 13725 03dd 00       		.byte	0
 13726 03de 00       		.byte	0
 13727 03df 00000000 		.space	5
 13727      00
 13728 03e4 20       		.byte	32
 13729 03e5 20       		.byte	32
 13730 03e6 02       		.byte	2
 13731 03e7 00       		.byte	0
 13732 03e8 00       		.byte	0
 13733 03e9 02       		.byte	2
 13734 03ea 00       		.byte	0
 13735 03eb 01       		.byte	1
 13736 03ec 00       		.byte	0
 13737 03ed 03       		.byte	3
 13738 03ee 00       		.byte	0
 13739 03ef 00       		.byte	0
 13740 03f0 00       		.byte	0
 13741 03f1 00       		.byte	0
 13742 03f2 00       		.byte	0
 13743 03f3 30       		.byte	48
 13744 03f4 01       		.byte	1
 13745 03f5 00       		.byte	0
 13746 03f6 00       		.byte	0
 13747 03f7 00000000 		.space	5
 13747      00
 13748 03fc 22       		.byte	34
 13749 03fd 22       		.byte	34
 13750 03fe 02       		.byte	2
 13751 03ff 00       		.byte	0
 13752 0400 00       		.byte	0
 13753 0401 3F       		.byte	63
 13754 0402 00       		.byte	0
 13755 0403 01       		.byte	1
 13756 0404 00       		.byte	0
 13757 0405 03       		.byte	3
 13758 0406 00       		.byte	0
 13759 0407 00       		.byte	0
 13760 0408 00       		.byte	0
 13761 0409 00       		.byte	0
 13762 040a 00       		.byte	0
 13763 040b 30       		.byte	48
 13764 040c 01       		.byte	1
 13765 040d 00       		.byte	0
 13766 040e 00       		.byte	0
 13767 040f 00000000 		.space	5
 13767      00
 13768 0414 23       		.byte	35
 13769 0415 23       		.byte	35
 13770 0416 02       		.byte	2
 13771 0417 00       		.byte	0
 13772 0418 00       		.byte	0
 13773 0419 64       		.byte	100
 13774 041a 00       		.byte	0
 13775 041b 01       		.byte	1
 13776 041c 00       		.byte	0
 13777 041d 03       		.byte	3
 13778 041e 00       		.byte	0
 13779 041f 10       		.byte	16
 13780 0420 00       		.byte	0
 13781 0421 10       		.byte	16
 13782 0422 00       		.byte	0
 13783 0423 30       		.byte	48
 13784 0424 01       		.byte	1
 13785 0425 00       		.byte	0
 13786 0426 00       		.byte	0
 13787 0427 00000000 		.space	5
 13787      00
 13788 042c 24       		.byte	36
 13789 042d 24       		.byte	36
 13790 042e 02       		.byte	2
 13791 042f 00       		.byte	0
 13792 0430 00       		.byte	0
 13793 0431 64       		.byte	100
 13794 0432 00       		.byte	0
 13795 0433 01       		.byte	1
 13796 0434 00       		.byte	0
 13797 0435 03       		.byte	3
 13798 0436 00       		.byte	0
 13799 0437 10       		.byte	16
 13800 0438 00       		.byte	0
 13801 0439 10       		.byte	16
 13802 043a 00       		.byte	0
 13803 043b 30       		.byte	48
 13804 043c 01       		.byte	1
 13805 043d 00       		.byte	0
 13806 043e 00       		.byte	0
 13807 043f 00000000 		.space	5
 13807      00
 13808 0444 00       		.byte	0
 13809 0445 03       		.byte	3
 13810 0446 04       		.byte	4
 13811 0447 00       		.byte	0
 13812 0448 00       		.byte	0
 13813 0449 7F       		.byte	127
 13814 044a 00       		.byte	0
 13815 044b 01       		.byte	1
 13816 044c 00       		.byte	0
 13817 044d 03       		.byte	3
 13818 044e 00       		.byte	0
 13819 044f 00       		.byte	0
 13820 0450 20       		.byte	32
 13821 0451 00       		.byte	0
 13822 0452 20       		.byte	32
 13823 0453 30       		.byte	48
 13824 0454 01       		.byte	1
 13825 0455 00       		.byte	0
 13826 0456 00       		.byte	0
 13827 0457 00000000 		.space	5
 13827      00
 13828 045c 04       		.byte	4
 13829 045d 04       		.byte	4
 13830 045e 02       		.byte	2
 13831 045f 00       		.byte	0
 13832 0460 00       		.byte	0
 13833 0461 FF       		.byte	-1
 13834 0462 00       		.byte	0
 13835 0463 01       		.byte	1
 13836 0464 00       		.byte	0
 13837 0465 03       		.byte	3
 13838 0466 00       		.byte	0
 13839 0467 60       		.byte	96
 13840 0468 00       		.byte	0
 13841 0469 60       		.byte	96
 13842 046a 00       		.byte	0
 13843 046b 30       		.byte	48
 13844 046c 01       		.byte	1
 13845 046d 00       		.byte	0
 13846 046e 00       		.byte	0
 13847 046f 00000000 		.space	5
 13847      00
 13848 0474 00       		.byte	0
 13849 0475 00       		.byte	0
 13850 0476 02       		.byte	2
 13851 0477 00       		.byte	0
 13852 0478 00       		.byte	0
 13853 0479 19       		.byte	25
 13854 047a 00       		.byte	0
 13855 047b 01       		.byte	1
 13856 047c 00       		.byte	0
 13857 047d 03       		.byte	3
 13858 047e 00       		.byte	0
 13859 047f 00       		.byte	0
 13860 0480 00       		.byte	0
 13861 0481 00       		.byte	0
 13862 0482 00       		.byte	0
 13863 0483 30       		.byte	48
 13864 0484 01       		.byte	1
 13865 0485 00       		.byte	0
 13866 0486 00       		.byte	0
 13867 0487 00000000 		.space	5
 13867      00
 13868 048c 10       		.byte	16
 13869 048d 10       		.byte	16
 13870 048e 02       		.byte	2
 13871 048f 00       		.byte	0
 13872 0490 00       		.byte	0
 13873 0491 06       		.byte	6
 13874 0492 00       		.byte	0
 13875 0493 01       		.byte	1
 13876 0494 00       		.byte	0
 13877 0495 03       		.byte	3
 13878 0496 00       		.byte	0
 13879 0497 03       		.byte	3
 13880 0498 00       		.byte	0
 13881 0499 03       		.byte	3
 13882 049a 00       		.byte	0
 13883 049b 30       		.byte	48
 13884 049c 01       		.byte	1
 13885 049d 00       		.byte	0
 13886 049e 00       		.byte	0
 13887 049f 00000000 		.space	5
 13887      00
 13888 04a4 00       		.byte	0
 13889 04a5 00       		.byte	0
 13890 04a6 02       		.byte	2
 13891 04a7 00       		.byte	0
 13892 04a8 00       		.byte	0
 13893 04a9 03       		.byte	3
 13894 04aa 00       		.byte	0
 13895 04ab 01       		.byte	1
 13896 04ac 00       		.byte	0
 13897 04ad 03       		.byte	3
 13898 04ae 00       		.byte	0
 13899 04af 00       		.byte	0
 13900 04b0 00       		.byte	0
 13901 04b1 00       		.byte	0
 13902 04b2 00       		.byte	0
 13903 04b3 30       		.byte	48
 13904 04b4 01       		.byte	1
 13905 04b5 00       		.byte	0
 13906 04b6 00       		.byte	0
 13907 04b7 00000000 		.space	5
 13907      00
 13908 04bc 50       		.byte	80
 13909 04bd 50       		.byte	80
 13910 04be 01       		.byte	1
 13911 04bf 00       		.byte	0
 13912 04c0 00       		.byte	0
 13913 04c1 03       		.byte	3
 13914 04c2 00       		.byte	0
 13915 04c3 01       		.byte	1
 13916 04c4 00       		.byte	0
 13917 04c5 03       		.byte	3
 13918 04c6 00       		.byte	0
 13919 04c7 00       		.byte	0
 13920 04c8 00       		.byte	0
 13921 04c9 00       		.byte	0
 13922 04ca 00       		.byte	0
 13923 04cb 30       		.byte	48
 13924 04cc 01       		.byte	1
 13925 04cd 00       		.byte	0
 13926 04ce 00       		.byte	0
 13927 04cf 00000000 		.space	5
 13927      00
 13928 04d4 00       		.byte	0
 13929 04d5 00       		.byte	0
 13930 04d6 0B       		.byte	11
 13931 04d7 00       		.byte	0
 13932 04d8 00       		.byte	0
 13933 04d9 FF       		.byte	-1
 13934 04da FF       		.byte	-1
 13935 04db 01       		.byte	1
 13936 04dc 00       		.byte	0
 13937 04dd 03       		.byte	3
 13938 04de 00       		.byte	0
 13939 04df 00       		.byte	0
 13940 04e0 00       		.byte	0
 13941 04e1 00       		.byte	0
 13942 04e2 00       		.byte	0
 13943 04e3 00       		.byte	0
 13944 04e4 01       		.byte	1
 13945 04e5 00       		.byte	0
 13946 04e6 00       		.byte	0
 13947 04e7 00000000 		.space	5
 13947      00
 13950              	glUVCHeader:
 13951 04ec 0C       		.byte	12
 13952 04ed 8C       		.byte	-116
 13953 04ee 00       		.byte	0
 13954 04ef 00       		.byte	0
 13955 04f0 00       		.byte	0
 13956 04f1 00       		.byte	0
 13957 04f2 00       		.byte	0
 13958 04f3 00       		.byte	0
 13959 04f4 00       		.byte	0
 13960 04f5 00       		.byte	0
 13961 04f6 00       		.byte	0
 13962 04f7 00       		.byte	0
 13965              	EXTBLCGrid:
 13966 04f8 10       		.byte	16
 13967 04f9 10       		.byte	16
 13968 04fa 02       		.byte	2
 13969 04fb 01       		.byte	1
 13970 04fc 00       		.byte	0
 13971 04fd 02       		.byte	2
 13972 04fe 00       		.byte	0
 13973 04ff 01       		.byte	1
 13974 0500 00       		.byte	0
 13975 0501 03       		.byte	3
 13976 0502 00       		.byte	0
 13977 0503 00       		.byte	0
 13978 0504 00       		.byte	0
 13979 0505 00       		.byte	0
 13980 0506 00       		.byte	0
 13981 0507 30       		.byte	48
 13982 0508 01       		.byte	1
 13983 0509 00       		.byte	0
 13984 050a 0000     		.space	2
 13987              	EXTAexModGainlev:
 13988 050c 00       		.byte	0
 13989 050d 03       		.byte	3
 13990 050e 04       		.byte	4
 13991 050f 00       		.byte	0
 13992 0510 00       		.byte	0
 13993 0511 7F       		.byte	127
 13994 0512 00       		.byte	0
 13995 0513 01       		.byte	1
 13996 0514 00       		.byte	0
 13997 0515 03       		.byte	3
 13998 0516 00       		.byte	0
 13999 0517 00       		.byte	0
 14000 0518 3F       		.byte	63
 14001 0519 00       		.byte	0
 14002 051a 3F       		.byte	63
 14003 051b 30       		.byte	48
 14004 051c 01       		.byte	1
 14005 051d 00       		.byte	0
 14006 051e 0000     		.space	2
 14009              	PUCBright:
 14010 0520 15       		.byte	21
 14011 0521 15       		.byte	21
 14012 0522 02       		.byte	2
 14013 0523 00       		.byte	0
 14014 0524 00       		.byte	0
 14015 0525 FF       		.byte	-1
 14016 0526 00       		.byte	0
 14017 0527 01       		.byte	1
 14018 0528 00       		.byte	0
 14019 0529 03       		.byte	3
 14020 052a 00       		.byte	0
 14021 052b 76       		.byte	118
 14022 052c 00       		.byte	0
 14023 052d 76       		.byte	118
 14024 052e 77       		.byte	119
 14025 052f 30       		.byte	48
 14026 0530 01       		.byte	1
 14027 0531 00       		.byte	0
 14028 0532 0000     		.space	2
 14031              	PUCHueC:
 14032 0534 DF       		.byte	-33
 14033 0535 E1       		.byte	-31
 14034 0536 02       		.byte	2
 14035 0537 00       		.byte	0
 14036 0538 00       		.byte	0
 14037 0539 FF       		.byte	-1
 14038 053a 00       		.byte	0
 14039 053b 01       		.byte	1
 14040 053c 00       		.byte	0
 14041 053d 03       		.byte	3
 14042 053e 00       		.byte	0
 14043 053f 80       		.byte	-128
 14044 0540 00       		.byte	0
 14045 0541 00       		.byte	0
 14046 0542 00       		.byte	0
 14047 0543 30       		.byte	48
 14048 0544 01       		.byte	1
 14049 0545 00       		.byte	0
 14050 0546 0000     		.space	2
 14053              	PUCPLFreq:
 14054 0548 07       		.byte	7
 14055 0549 07       		.byte	7
 14056 054a 02       		.byte	2
 14057 054b 00       		.byte	0
 14058 054c 00       		.byte	0
 14059 054d 01       		.byte	1
 14060 054e 00       		.byte	0
 14061 054f 01       		.byte	1
 14062 0550 00       		.byte	0
 14063 0551 03       		.byte	3
 14064 0552 00       		.byte	0
 14065 0553 01       		.byte	1
 14066 0554 00       		.byte	0
 14067 0555 01       		.byte	1
 14068 0556 00       		.byte	0
 14069 0557 30       		.byte	48
 14070 0558 01       		.byte	1
 14071 0559 00       		.byte	0
 14072 055a 0000     		.space	2
 14075              	WBMenuCmpArry:
 14076 055c 20       		.byte	32
 14077 055d 0F       		.byte	15
 14078 055e 38       		.byte	56
 14079 055f F0       		.byte	-16
 14082              	PUCBLC:
 14083 0560 10       		.byte	16
 14084 0561 11       		.byte	17
 14085 0562 02       		.byte	2
 14086 0563 00       		.byte	0
 14087 0564 00       		.byte	0
 14088 0565 03       		.byte	3
 14089 0566 00       		.byte	0
 14090 0567 01       		.byte	1
 14091 0568 00       		.byte	0
 14092 0569 03       		.byte	3
 14093 056a 00       		.byte	0
 14094 056b 03       		.byte	3
 14095 056c 00       		.byte	0
 14096 056d 03       		.byte	3
 14097 056e 00       		.byte	0
 14098 056f 30       		.byte	48
 14099 0570 01       		.byte	1
 14100 0571 00       		.byte	0
 14101 0572 0000     		.space	2
 14104              	EXTShutter:
 14105 0574 00       		.byte	0
 14106 0575 02       		.byte	2
 14107 0576 02       		.byte	2
 14108 0577 00       		.byte	0
 14109 0578 00       		.byte	0
 14110 0579 08       		.byte	8
 14111 057a 00       		.byte	0
 14112 057b 01       		.byte	1
 14113 057c 00       		.byte	0
 14114 057d 03       		.byte	3
 14115 057e 00       		.byte	0
 14116 057f 00       		.byte	0
 14117 0580 00       		.byte	0
 14118 0581 00       		.byte	0
 14119 0582 00       		.byte	0
 14120 0583 30       		.byte	48
 14121 0584 01       		.byte	1
 14122 0585 00       		.byte	0
 14123 0586 0000     		.space	2
 14126              	EXTShutlev:
 14127 0588 02       		.byte	2
 14128 0589 12       		.byte	18
 14129 058a 02       		.byte	2
 14130 058b 00       		.byte	0
 14131 058c 00       		.byte	0
 14132 058d FF       		.byte	-1
 14133 058e 7F       		.byte	127
 14134 058f 01       		.byte	1
 14135 0590 00       		.byte	0
 14136 0591 03       		.byte	3
 14137 0592 00       		.byte	0
 14138 0593 3F       		.byte	63
 14139 0594 00       		.byte	0
 14140 0595 3F       		.byte	63
 14141 0596 00       		.byte	0
 14142 0597 30       		.byte	48
 14143 0598 01       		.byte	1
 14144 0599 00       		.byte	0
 14145 059a 0000     		.space	2
 14148              	EXTBLCWinPos:
 14149 059c 14       		.byte	20
 14150 059d 13       		.byte	19
 14151 059e 02       		.byte	2
 14152 059f 00       		.byte	0
 14153 05a0 00       		.byte	0
 14154 05a1 FF       		.byte	-1
 14155 05a2 FF       		.byte	-1
 14156 05a3 01       		.byte	1
 14157 05a4 00       		.byte	0
 14158 05a5 03       		.byte	3
 14159 05a6 00       		.byte	0
 14160 05a7 66       		.byte	102
 14161 05a8 66       		.byte	102
 14162 05a9 66       		.byte	102
 14163 05aa 66       		.byte	102
 14164 05ab 30       		.byte	48
 14165 05ac 01       		.byte	1
 14166 05ad 00       		.byte	0
 14167 05ae 0000     		.space	2
 14170              	CTCtrlParArry:
 14171 05b0 00       		.byte	0
 14172 05b1 00       		.byte	0
 14173 05b2 01       		.byte	1
 14174 05b3 00       		.byte	0
 14175 05b4 00       		.byte	0
 14176 05b5 03       		.byte	3
 14177 05b6 00       		.byte	0
 14178 05b7 01       		.byte	1
 14179 05b8 00       		.byte	0
 14180 05b9 03       		.byte	3
 14181 05ba 00       		.byte	0
 14182 05bb 03       		.byte	3
 14183 05bc 00       		.byte	0
 14184 05bd 03       		.byte	3
 14185 05be 00       		.byte	0
 14186 05bf 30       		.byte	48
 14187 05c0 01       		.byte	1
 14188 05c1 00       		.byte	0
 14189 05c2 00       		.byte	0
 14190 05c3 00000000 		.space	5
 14190      00
 14191 05c8 00       		.byte	0
 14192 05c9 00       		.byte	0
 14193 05ca 01       		.byte	1
 14194 05cb 01       		.byte	1
 14195 05cc 00       		.byte	0
 14196 05cd 0F       		.byte	15
 14197 05ce 00       		.byte	0
 14198 05cf 0F       		.byte	15
 14199 05d0 00       		.byte	0
 14200 05d1 03       		.byte	3
 14201 05d2 00       		.byte	0
 14202 05d3 02       		.byte	2
 14203 05d4 00       		.byte	0
 14204 05d5 02       		.byte	2
 14205 05d6 00       		.byte	0
 14206 05d7 30       		.byte	48
 14207 05d8 01       		.byte	1
 14208 05d9 01       		.byte	1
 14209 05da 00       		.byte	0
 14210 05db 00000000 		.space	5
 14210      00
 14211 05e0 02       		.byte	2
 14212 05e1 00       		.byte	0
 14213 05e2 01       		.byte	1
 14214 05e3 00       		.byte	0
 14215 05e4 00       		.byte	0
 14216 05e5 01       		.byte	1
 14217 05e6 00       		.byte	0
 14218 05e7 01       		.byte	1
 14219 05e8 00       		.byte	0
 14220 05e9 03       		.byte	3
 14221 05ea 00       		.byte	0
 14222 05eb 00       		.byte	0
 14223 05ec 00       		.byte	0
 14224 05ed 00       		.byte	0
 14225 05ee 00       		.byte	0
 14226 05ef 30       		.byte	48
 14227 05f0 01       		.byte	1
 14228 05f1 01       		.byte	1
 14229 05f2 00       		.byte	0
 14230 05f3 00000000 		.space	5
 14230      00
 14231 05f8 00       		.byte	0
 14232 05f9 00       		.byte	0
 14233 05fa 04       		.byte	4
 14234 05fb 01       		.byte	1
 14235 05fc 00       		.byte	0
 14236 05fd 38       		.byte	56
 14237 05fe 01       		.byte	1
 14238 05ff 01       		.byte	1
 14239 0600 00       		.byte	0
 14240 0601 03       		.byte	3
 14241 0602 00       		.byte	0
 14242 0603 4E       		.byte	78
 14243 0604 00       		.byte	0
 14244 0605 4E       		.byte	78
 14245 0606 00       		.byte	0
 14246 0607 30       		.byte	48
 14247 0608 01       		.byte	1
 14248 0609 00       		.byte	0
 14249 060a 00       		.byte	0
 14250 060b 00000000 		.space	5
 14250      00
 14251 0610 04       		.byte	4
 14252 0611 00       		.byte	0
 14253 0612 01       		.byte	1
 14254 0613 00       		.byte	0
 14255 0614 00       		.byte	0
 14256 0615 00       		.byte	0
 14257 0616 00       		.byte	0
 14258 0617 01       		.byte	1
 14259 0618 00       		.byte	0
 14260 0619 03       		.byte	3
 14261 061a 00       		.byte	0
 14262 061b 00       		.byte	0
 14263 061c 00       		.byte	0
 14264 061d 00       		.byte	0
 14265 061e 00       		.byte	0
 14266 061f 30       		.byte	48
 14267 0620 01       		.byte	1
 14268 0621 00       		.byte	0
 14269 0622 00       		.byte	0
 14270 0623 00000000 		.space	5
 14270      00
 14271 0628 05       		.byte	5
 14272 0629 00       		.byte	0
 14273 062a 02       		.byte	2
 14274 062b 00       		.byte	0
 14275 062c 00       		.byte	0
 14276 062d FF       		.byte	-1
 14277 062e 00       		.byte	0
 14278 062f 01       		.byte	1
 14279 0630 00       		.byte	0
 14280 0631 03       		.byte	3
 14281 0632 00       		.byte	0
 14282 0633 01       		.byte	1
 14283 0634 00       		.byte	0
 14284 0635 00       		.byte	0
 14285 0636 00       		.byte	0
 14286 0637 30       		.byte	48
 14287 0638 01       		.byte	1
 14288 0639 01       		.byte	1
 14289 063a 00       		.byte	0
 14290 063b 00000000 		.space	5
 14290      00
 14291 0640 06       		.byte	6
 14292 0641 00       		.byte	0
 14293 0642 02       		.byte	2
 14294 0643 00       		.byte	0
 14295 0644 00       		.byte	0
 14296 0645 00       		.byte	0
 14297 0646 00       		.byte	0
 14298 0647 00       		.byte	0
 14299 0648 00       		.byte	0
 14300 0649 03       		.byte	3
 14301 064a 00       		.byte	0
 14302 064b 00       		.byte	0
 14303 064c 00       		.byte	0
 14304 064d 00       		.byte	0
 14305 064e 00       		.byte	0
 14306 064f 30       		.byte	48
 14307 0650 01       		.byte	1
 14308 0651 01       		.byte	1
 14309 0652 00       		.byte	0
 14310 0653 00000000 		.space	5
 14310      00
 14311 0658 23       		.byte	35
 14312 0659 00       		.byte	0
 14313 065a 02       		.byte	2
 14314 065b 00       		.byte	0
 14315 065c 00       		.byte	0
 14316 065d 30       		.byte	48
 14317 065e 00       		.byte	0
 14318 065f 01       		.byte	1
 14319 0660 00       		.byte	0
 14320 0661 03       		.byte	3
 14321 0662 0A       		.byte	10
 14322 0663 00       		.byte	0
 14323 0664 00       		.byte	0
 14324 0665 0A       		.byte	10
 14325 0666 00       		.byte	0
 14326 0667 30       		.byte	48
 14327 0668 01       		.byte	1
 14328 0669 01       		.byte	1
 14329 066a 00       		.byte	0
 14330 066b 00000000 		.space	5
 14330      00
 14331 0670 08       		.byte	8
 14332 0671 00       		.byte	0
 14333 0672 01       		.byte	1
 14334 0673 00       		.byte	0
 14335 0674 00       		.byte	0
 14336 0675 7F       		.byte	127
 14337 0676 00       		.byte	0
 14338 0677 01       		.byte	1
 14339 0678 00       		.byte	0
 14340 0679 03       		.byte	3
 14341 067a 00       		.byte	0
 14342 067b 00       		.byte	0
 14343 067c 00       		.byte	0
 14344 067d 00       		.byte	0
 14345 067e 00       		.byte	0
 14346 067f 30       		.byte	48
 14347 0680 01       		.byte	1
 14348 0681 00       		.byte	0
 14349 0682 00       		.byte	0
 14350 0683 00000000 		.space	5
 14350      00
 14351 0688 09       		.byte	9
 14352 0689 00       		.byte	0
 14353 068a 02       		.byte	2
 14354 068b 00       		.byte	0
 14355 068c 00       		.byte	0
 14356 068d 05       		.byte	5
 14357 068e 00       		.byte	0
 14358 068f 01       		.byte	1
 14359 0690 00       		.byte	0
 14360 0691 03       		.byte	3
 14361 0692 00       		.byte	0
 14362 0693 00       		.byte	0
 14363 0694 00       		.byte	0
 14364 0695 00       		.byte	0
 14365 0696 00       		.byte	0
 14366 0697 30       		.byte	48
 14367 0698 01       		.byte	1
 14368 0699 00       		.byte	0
 14369 069a 00       		.byte	0
 14370 069b 00000000 		.space	5
 14370      00
 14371 06a0 10       		.byte	16
 14372 06a1 00       		.byte	0
 14373 06a2 03       		.byte	3
 14374 06a3 00       		.byte	0
 14375 06a4 00       		.byte	0
 14376 06a5 00       		.byte	0
 14377 06a6 00       		.byte	0
 14378 06a7 00       		.byte	0
 14379 06a8 00       		.byte	0
 14380 06a9 03       		.byte	3
 14381 06aa 00       		.byte	0
 14382 06ab 00       		.byte	0
 14383 06ac 00       		.byte	0
 14384 06ad 00       		.byte	0
 14385 06ae 00       		.byte	0
 14386 06af 30       		.byte	48
 14387 06b0 01       		.byte	1
 14388 06b1 00       		.byte	0
 14389 06b2 00       		.byte	0
 14390 06b3 00000000 		.space	5
 14390      00
 14391 06b8 00       		.byte	0
 14392 06b9 00       		.byte	0
 14393 06ba 02       		.byte	2
 14394 06bb 00       		.byte	0
 14395 06bc 00       		.byte	0
 14396 06bd 40       		.byte	64
 14397 06be 00       		.byte	0
 14398 06bf 01       		.byte	1
 14399 06c0 00       		.byte	0
 14400 06c1 03       		.byte	3
 14401 06c2 00       		.byte	0
 14402 06c3 0F       		.byte	15
 14403 06c4 11       		.byte	17
 14404 06c5 00       		.byte	0
 14405 06c6 00       		.byte	0
 14406 06c7 30       		.byte	48
 14407 06c8 01       		.byte	1
 14408 06c9 00       		.byte	0
 14409 06ca 00       		.byte	0
 14410 06cb 00000000 		.space	5
 14410      00
 14411 06d0 00       		.byte	0
 14412 06d1 00       		.byte	0
 14413 06d2 02       		.byte	2
 14414 06d3 00       		.byte	0
 14415 06d4 00       		.byte	0
 14416 06d5 64       		.byte	100
 14417 06d6 00       		.byte	0
 14418 06d7 01       		.byte	1
 14419 06d8 00       		.byte	0
 14420 06d9 03       		.byte	3
 14421 06da 00       		.byte	0
 14422 06db 00       		.byte	0
 14423 06dc 00       		.byte	0
 14424 06dd 00       		.byte	0
 14425 06de 00       		.byte	0
 14426 06df 30       		.byte	48
 14427 06e0 01       		.byte	1
 14428 06e1 00       		.byte	0
 14429 06e2 00       		.byte	0
 14430 06e3 00000000 		.space	5
 14430      00
 14431 06e8 00       		.byte	0
 14432 06e9 00       		.byte	0
 14433 06ea 02       		.byte	2
 14434 06eb 00       		.byte	0
 14435 06ec 00       		.byte	0
 14436 06ed 64       		.byte	100
 14437 06ee 00       		.byte	0
 14438 06ef 01       		.byte	1
 14439 06f0 00       		.byte	0
 14440 06f1 03       		.byte	3
 14441 06f2 00       		.byte	0
 14442 06f3 00       		.byte	0
 14443 06f4 00       		.byte	0
 14444 06f5 00       		.byte	0
 14445 06f6 00       		.byte	0
 14446 06f7 30       		.byte	48
 14447 06f8 01       		.byte	1
 14448 06f9 00       		.byte	0
 14449 06fa 00       		.byte	0
 14450 06fb 00000000 		.space	5
 14450      00
 14451 0700 00       		.byte	0
 14452 0701 00       		.byte	0
 14453 0702 02       		.byte	2
 14454 0703 00       		.byte	0
 14455 0704 00       		.byte	0
 14456 0705 64       		.byte	100
 14457 0706 00       		.byte	0
 14458 0707 01       		.byte	1
 14459 0708 00       		.byte	0
 14460 0709 03       		.byte	3
 14461 070a 00       		.byte	0
 14462 070b 00       		.byte	0
 14463 070c 00       		.byte	0
 14464 070d 00       		.byte	0
 14465 070e 00       		.byte	0
 14466 070f 30       		.byte	48
 14467 0710 01       		.byte	1
 14468 0711 00       		.byte	0
 14469 0712 00       		.byte	0
 14470 0713 00000000 		.space	5
 14470      00
 14471 0718 00       		.byte	0
 14472 0719 00       		.byte	0
 14473 071a 02       		.byte	2
 14474 071b 00       		.byte	0
 14475 071c 00       		.byte	0
 14476 071d 64       		.byte	100
 14477 071e 00       		.byte	0
 14478 071f 01       		.byte	1
 14479 0720 00       		.byte	0
 14480 0721 03       		.byte	3
 14481 0722 00       		.byte	0
 14482 0723 00       		.byte	0
 14483 0724 00       		.byte	0
 14484 0725 00       		.byte	0
 14485 0726 00       		.byte	0
 14486 0727 30       		.byte	48
 14487 0728 01       		.byte	1
 14488 0729 00       		.byte	0
 14489 072a 00       		.byte	0
 14490 072b 00000000 		.space	5
 14490      00
 14493              	PUCDZoom:
 14494 0730 2A       		.byte	42
 14495 0731 2A       		.byte	42
 14496 0732 02       		.byte	2
 14497 0733 00       		.byte	0
 14498 0734 00       		.byte	0
 14499 0735 1B       		.byte	27
 14500 0736 00       		.byte	0
 14501 0737 01       		.byte	1
 14502 0738 00       		.byte	0
 14503 0739 03       		.byte	3
 14504 073a 00       		.byte	0
 14505 073b 00       		.byte	0
 14506 073c 00       		.byte	0
 14507 073d 00       		.byte	0
 14508 073e 00       		.byte	0
 14509 073f 30       		.byte	48
 14510 0740 01       		.byte	1
 14511 0741 00       		.byte	0
 14512 0742 0000     		.space	2
 14515              	EXTEnhanceMode:
 14516 0744 06       		.byte	6
 14517 0745 06       		.byte	6
 14518 0746 02       		.byte	2
 14519 0747 00       		.byte	0
 14520 0748 00       		.byte	0
 14521 0749 FF       		.byte	-1
 14522 074a 00       		.byte	0
 14523 074b 01       		.byte	1
 14524 074c 00       		.byte	0
 14525 074d 03       		.byte	3
 14526 074e 00       		.byte	0
 14527 074f 80       		.byte	-128
 14528 0750 00       		.byte	0
 14529 0751 80       		.byte	-128
 14530 0752 00       		.byte	0
 14531 0753 30       		.byte	48
 14532 0754 01       		.byte	1
 14533 0755 00       		.byte	0
 14534 0756 0000     		.space	2
 14537              	EXTEnhanceGain:
 14538 0758 07       		.byte	7
 14539 0759 07       		.byte	7
 14540 075a 02       		.byte	2
 14541 075b 00       		.byte	0
 14542 075c 00       		.byte	0
 14543 075d FF       		.byte	-1
 14544 075e 00       		.byte	0
 14545 075f 01       		.byte	1
 14546 0760 00       		.byte	0
 14547 0761 03       		.byte	3
 14548 0762 00       		.byte	0
 14549 0763 80       		.byte	-128
 14550 0764 00       		.byte	0
 14551 0765 80       		.byte	-128
 14552 0766 00       		.byte	0
 14553 0767 30       		.byte	48
 14554 0768 01       		.byte	1
 14555 0769 00       		.byte	0
 14558              	snapButFlag:
 14559 076a 01       		.byte	1
 14560 076b 00       		.space	1
 14563              	EXTGammaCor:
 14564 076c 17       		.byte	23
 14565 076d 17       		.byte	23
 14566 076e 02       		.byte	2
 14567 076f 00       		.byte	0
 14568 0770 00       		.byte	0
 14569 0771 10       		.byte	16
 14570 0772 00       		.byte	0
 14571 0773 01       		.byte	1
 14572 0774 00       		.byte	0
 14573 0775 03       		.byte	3
 14574 0776 00       		.byte	0
 14575 0777 00       		.byte	0
 14576 0778 00       		.byte	0
 14577 0779 00       		.byte	0
 14578 077a 00       		.byte	0
 14579 077b 30       		.byte	48
 14580 077c 01       		.byte	1
 14581 077d 00       		.byte	0
 14582 077e 0000     		.space	2
 14585              	EXT2DNRSTED:
 14586 0780 1A       		.byte	26
 14587 0781 1B       		.byte	27
 14588 0782 04       		.byte	4
 14589 0783 00       		.byte	0
 14590 0784 00       		.byte	0
 14591 0785 FF       		.byte	-1
 14592 0786 00       		.byte	0
 14593 0787 01       		.byte	1
 14594 0788 00       		.byte	0
 14595 0789 03       		.byte	3
 14596 078a 00       		.byte	0
 14597 078b 80       		.byte	-128
 14598 078c 00       		.byte	0
 14599 078d 80       		.byte	-128
 14600 078e 00       		.byte	0
 14601 078f 30       		.byte	48
 14602 0790 01       		.byte	1
 14603 0791 00       		.byte	0
 14604 0792 0000     		.space	2
 14607              	EXT2DNRGain:
 14608 0794 18       		.byte	24
 14609 0795 19       		.byte	25
 14610 0796 02       		.byte	2
 14611 0797 00       		.byte	0
 14612 0798 00       		.byte	0
 14613 0799 FF       		.byte	-1
 14614 079a 00       		.byte	0
 14615 079b 01       		.byte	1
 14616 079c 00       		.byte	0
 14617 079d 03       		.byte	3
 14618 079e 00       		.byte	0
 14619 079f 80       		.byte	-128
 14620 07a0 00       		.byte	0
 14621 07a1 80       		.byte	-128
 14622 07a2 00       		.byte	0
 14623 07a3 30       		.byte	48
 14624 07a4 01       		.byte	1
 14625 07a5 00       		.byte	0
 14626 07a6 0000     		.space	2
 14629              	EXTEnhanceSTED:
 14630 07a8 08       		.byte	8
 14631 07a9 09       		.byte	9
 14632 07aa 04       		.byte	4
 14633 07ab 00       		.byte	0
 14634 07ac 00       		.byte	0
 14635 07ad FF       		.byte	-1
 14636 07ae 00       		.byte	0
 14637 07af 01       		.byte	1
 14638 07b0 00       		.byte	0
 14639 07b1 03       		.byte	3
 14640 07b2 00       		.byte	0
 14641 07b3 80       		.byte	-128
 14642 07b4 00       		.byte	0
 14643 07b5 80       		.byte	-128
 14644 07b6 00       		.byte	0
 14645 07b7 30       		.byte	48
 14646 07b8 01       		.byte	1
 14647 07b9 00       		.byte	0
 14648 07ba 0000     		.space	2
 14651              	EXTExCtrlSped:
 14652 07bc F8       		.byte	-8
 14653 07bd F8       		.byte	-8
 14654 07be 02       		.byte	2
 14655 07bf 00       		.byte	0
 14656 07c0 00       		.byte	0
 14657 07c1 FF       		.byte	-1
 14658 07c2 00       		.byte	0
 14659 07c3 01       		.byte	1
 14660 07c4 00       		.byte	0
 14661 07c5 03       		.byte	3
 14662 07c6 00       		.byte	0
 14663 07c7 80       		.byte	-128
 14664 07c8 00       		.byte	0
 14665 07c9 80       		.byte	-128
 14666 07ca 00       		.byte	0
 14667 07cb 30       		.byte	48
 14668 07cc 01       		.byte	1
 14669 07cd 00       		.byte	0
 14670 07ce 0000     		.space	2
 14673              	EXTExHyster:
 14674 07d0 0B       		.byte	11
 14675 07d1 0B       		.byte	11
 14676 07d2 02       		.byte	2
 14677 07d3 00       		.byte	0
 14678 07d4 00       		.byte	0
 14679 07d5 FF       		.byte	-1
 14680 07d6 00       		.byte	0
 14681 07d7 01       		.byte	1
 14682 07d8 00       		.byte	0
 14683 07d9 03       		.byte	3
 14684 07da 00       		.byte	0
 14685 07db 80       		.byte	-128
 14686 07dc 00       		.byte	0
 14687 07dd 80       		.byte	-128
 14688 07de 00       		.byte	0
 14689 07df 30       		.byte	48
 14690 07e0 01       		.byte	1
 14691 07e1 00       		.byte	0
 14692 07e2 0000     		.space	2
 14695              	EXTBLCWeight:
 14696 07e4 11       		.byte	17
 14697 07e5 11       		.byte	17
 14698 07e6 02       		.byte	2
 14699 07e7 00       		.byte	0
 14700 07e8 00       		.byte	0
 14701 07e9 FF       		.byte	-1
 14702 07ea 00       		.byte	0
 14703 07eb 01       		.byte	1
 14704 07ec 00       		.byte	0
 14705 07ed 03       		.byte	3
 14706 07ee 00       		.byte	0
 14707 07ef 80       		.byte	-128
 14708 07f0 00       		.byte	0
 14709 07f1 80       		.byte	-128
 14710 07f2 00       		.byte	0
 14711 07f3 30       		.byte	48
 14712 07f4 01       		.byte	1
 14713 07f5 00       		.byte	0
 14714 07f6 0000     		.space	2
 14717              	EXTI2Ccmd:
 14718 07f8 00       		.byte	0
 14719 07f9 00       		.byte	0
 14720 07fa 0B       		.byte	11
 14721 07fb 00       		.byte	0
 14722 07fc 00       		.byte	0
 14723 07fd FF       		.byte	-1
 14724 07fe FF       		.byte	-1
 14725 07ff 01       		.byte	1
 14726 0800 00       		.byte	0
 14727 0801 03       		.byte	3
 14728 0802 00       		.byte	0
 14729 0803 00       		.byte	0
 14730 0804 00       		.byte	0
 14731 0805 00       		.byte	0
 14732 0806 00       		.byte	0
 14733 0807 00       		.byte	0
 14734 0808 01       		.byte	1
 14735 0809 00       		.byte	0
 14736 080a 0000     		.space	2
 14739              	EXTSensorPare:
 14740 080c 50       		.byte	80
 14741 080d 50       		.byte	80
 14742 080e 02       		.byte	2
 14743 080f 00       		.byte	0
 14744 0810 00       		.byte	0
 14745 0811 03       		.byte	3
 14746 0812 00       		.byte	0
 14747 0813 01       		.byte	1
 14748 0814 00       		.byte	0
 14749 0815 03       		.byte	3
 14750 0816 00       		.byte	0
 14751 0817 00       		.byte	0
 14752 0818 00       		.byte	0
 14753 0819 00       		.byte	0
 14754 081a 00       		.byte	0
 14755 081b 30       		.byte	48
 14756 081c 01       		.byte	1
 14757 081d 00       		.byte	0
 14758 081e 0000     		.space	2
 14761              	EXTCamMode:
 14762 0820 10       		.byte	16
 14763 0821 10       		.byte	16
 14764 0822 02       		.byte	2
 14765 0823 00       		.byte	0
 14766 0824 00       		.byte	0
 14767 0825 06       		.byte	6
 14768 0826 00       		.byte	0
 14769 0827 01       		.byte	1
 14770 0828 00       		.byte	0
 14771 0829 03       		.byte	3
 14772 082a 00       		.byte	0
 14773 082b 03       		.byte	3
 14774 082c 00       		.byte	0
 14775 082d 03       		.byte	3
 14776 082e 00       		.byte	0
 14777 082f 30       		.byte	48
 14778 0830 01       		.byte	1
 14779 0831 00       		.byte	0
 14780 0832 0000     		.space	2
 14783              	EXTExpReflev:
 14784 0834 04       		.byte	4
 14785 0835 04       		.byte	4
 14786 0836 02       		.byte	2
 14787 0837 00       		.byte	0
 14788 0838 00       		.byte	0
 14789 0839 FF       		.byte	-1
 14790 083a 00       		.byte	0
 14791 083b 01       		.byte	1
 14792 083c 00       		.byte	0
 14793 083d 03       		.byte	3
 14794 083e 00       		.byte	0
 14795 083f 3C       		.byte	60
 14796 0840 00       		.byte	0
 14797 0841 3C       		.byte	60
 14798 0842 00       		.byte	0
 14799 0843 30       		.byte	48
 14800 0844 01       		.byte	1
 14801 0845 00       		.byte	0
 14802 0846 0000     		.space	2
 14805              	EXTNightDaylev:
 14806 0848 24       		.byte	36
 14807 0849 24       		.byte	36
 14808 084a 02       		.byte	2
 14809 084b 00       		.byte	0
 14810 084c 00       		.byte	0
 14811 084d 64       		.byte	100
 14812 084e 00       		.byte	0
 14813 084f 01       		.byte	1
 14814 0850 00       		.byte	0
 14815 0851 03       		.byte	3
 14816 0852 00       		.byte	0
 14817 0853 10       		.byte	16
 14818 0854 00       		.byte	0
 14819 0855 10       		.byte	16
 14820 0856 00       		.byte	0
 14821 0857 30       		.byte	48
 14822 0858 01       		.byte	1
 14823 0859 00       		.byte	0
 14824 085a 0000     		.space	2
 14827              	EXTDayNightlev:
 14828 085c 23       		.byte	35
 14829 085d 23       		.byte	35
 14830 085e 02       		.byte	2
 14831 085f 00       		.byte	0
 14832 0860 00       		.byte	0
 14833 0861 64       		.byte	100
 14834 0862 00       		.byte	0
 14835 0863 01       		.byte	1
 14836 0864 00       		.byte	0
 14837 0865 03       		.byte	3
 14838 0866 00       		.byte	0
 14839 0867 10       		.byte	16
 14840 0868 00       		.byte	0
 14841 0869 10       		.byte	16
 14842 086a 00       		.byte	0
 14843 086b 30       		.byte	48
 14844 086c 01       		.byte	1
 14845 086d 00       		.byte	0
 14846 086e 0000     		.space	2
 14849              	EXTDayNightdely:
 14850 0870 22       		.byte	34
 14851 0871 22       		.byte	34
 14852 0872 02       		.byte	2
 14853 0873 00       		.byte	0
 14854 0874 00       		.byte	0
 14855 0875 3F       		.byte	63
 14856 0876 00       		.byte	0
 14857 0877 01       		.byte	1
 14858 0878 00       		.byte	0
 14859 0879 03       		.byte	3
 14860 087a 00       		.byte	0
 14861 087b 00       		.byte	0
 14862 087c 00       		.byte	0
 14863 087d 00       		.byte	0
 14864 087e 00       		.byte	0
 14865 087f 30       		.byte	48
 14866 0880 01       		.byte	1
 14867 0881 00       		.byte	0
 14868 0882 0000     		.space	2
 14871              	EXTDayNightMode:
 14872 0884 20       		.byte	32
 14873 0885 20       		.byte	32
 14874 0886 02       		.byte	2
 14875 0887 00       		.byte	0
 14876 0888 00       		.byte	0
 14877 0889 02       		.byte	2
 14878 088a 00       		.byte	0
 14879 088b 01       		.byte	1
 14880 088c 00       		.byte	0
 14881 088d 03       		.byte	3
 14882 088e 00       		.byte	0
 14883 088f 00       		.byte	0
 14884 0890 00       		.byte	0
 14885 0891 00       		.byte	0
 14886 0892 00       		.byte	0
 14887 0893 30       		.byte	48
 14888 0894 01       		.byte	1
 14889 0895 00       		.byte	0
 14890 0896 0000     		.space	2
 14893              	EXT3DNoiseLev:
 14894 0898 19       		.byte	25
 14895 0899 19       		.byte	25
 14896 089a 02       		.byte	2
 14897 089b 00       		.byte	0
 14898 089c 00       		.byte	0
 14899 089d 40       		.byte	64
 14900 089e 00       		.byte	0
 14901 089f 01       		.byte	1
 14902 08a0 00       		.byte	0
 14903 08a1 03       		.byte	3
 14904 08a2 00       		.byte	0
 14905 08a3 20       		.byte	32
 14906 08a4 00       		.byte	0
 14907 08a5 20       		.byte	32
 14908 08a6 00       		.byte	0
 14909 08a7 30       		.byte	48
 14910 08a8 01       		.byte	1
 14911 08a9 00       		.byte	0
 14912 08aa 0000     		.space	2
 14915              	EXT3DnoiseReduceMode:
 14916 08ac 18       		.byte	24
 14917 08ad 18       		.byte	24
 14918 08ae 02       		.byte	2
 14919 08af 00       		.byte	0
 14920 08b0 00       		.byte	0
 14921 08b1 01       		.byte	1
 14922 08b2 00       		.byte	0
 14923 08b3 01       		.byte	1
 14924 08b4 00       		.byte	0
 14925 08b5 03       		.byte	3
 14926 08b6 00       		.byte	0
 14927 08b7 00       		.byte	0
 14928 08b8 00       		.byte	0
 14929 08b9 00       		.byte	0
 14930 08ba 00       		.byte	0
 14931 08bb 30       		.byte	48
 14932 08bc 01       		.byte	1
 14933 08bd 00       		.byte	0
 14934 08be 0000     		.space	2
 14937              	EXTMirror:
 14938 08c0 05       		.byte	5
 14939 08c1 05       		.byte	5
 14940 08c2 02       		.byte	2
 14941 08c3 00       		.byte	0
 14942 08c4 00       		.byte	0
 14943 08c5 03       		.byte	3
 14944 08c6 00       		.byte	0
 14945 08c7 01       		.byte	1
 14946 08c8 00       		.byte	0
 14947 08c9 03       		.byte	3
 14948 08ca 00       		.byte	0
 14949 08cb 00       		.byte	0
 14950 08cc 00       		.byte	0
 14951 08cd 00       		.byte	0
 14952 08ce 00       		.byte	0
 14953 08cf 30       		.byte	48
 14954 08d0 01       		.byte	1
 14955 08d1 00       		.byte	0
 14956 08d2 0000     		.space	2
 14959              	EXTSensUp:
 14960 08d4 01       		.byte	1
 14961 08d5 01       		.byte	1
 14962 08d6 02       		.byte	2
 14963 08d7 00       		.byte	0
 14964 08d8 00       		.byte	0
 14965 08d9 09       		.byte	9
 14966 08da 00       		.byte	0
 14967 08db 01       		.byte	1
 14968 08dc 00       		.byte	0
 14969 08dd 03       		.byte	3
 14970 08de 00       		.byte	0
 14971 08df 00       		.byte	0
 14972 08e0 00       		.byte	0
 14973 08e1 01       		.byte	1
 14974 08e2 00       		.byte	0
 14975 08e3 30       		.byte	48
 14976 08e4 01       		.byte	1
 14977 08e5 00       		.byte	0
 14978 08e6 0000     		.space	2
 14981              	PUCWBLC:
 14982 08e8 09       		.byte	9
 14983 08e9 0A       		.byte	10
 14984 08ea 04       		.byte	4
 14985 08eb 00       		.byte	0
 14986 08ec 00       		.byte	0
 14987 08ed 40       		.byte	64
 14988 08ee 00       		.byte	0
 14989 08ef 01       		.byte	1
 14990 08f0 00       		.byte	0
 14991 08f1 03       		.byte	3
 14992 08f2 00       		.byte	0
 14993 08f3 20       		.byte	32
 14994 08f4 00       		.byte	0
 14995 08f5 38       		.byte	56
 14996 08f6 00       		.byte	0
 14997 08f7 30       		.byte	48
 14998 08f8 01       		.byte	1
 14999 08f9 00       		.byte	0
 15000 08fa 0000     		.space	2
 15003              	PUCWBMd:
 15004 08fc 08       		.byte	8
 15005 08fd 08       		.byte	8
 15006 08fe 02       		.byte	2
 15007 08ff 00       		.byte	0
 15008 0900 00       		.byte	0
 15009 0901 05       		.byte	5
 15010 0902 00       		.byte	0
 15011 0903 01       		.byte	1
 15012 0904 00       		.byte	0
 15013 0905 03       		.byte	3
 15014 0906 00       		.byte	0
 15015 0907 00       		.byte	0
 15016 0908 00       		.byte	0
 15017 0909 00       		.byte	0
 15018 090a 00       		.byte	0
 15019 090b 30       		.byte	48
 15020 090c 01       		.byte	1
 15021 090d 00       		.byte	0
 15022 090e 0000     		.space	2
 15025              	PUCSharp:
 15026 0910 06       		.byte	6
 15027 0911 07       		.byte	7
 15028 0912 02       		.byte	2
 15029 0913 00       		.byte	0
 15030 0914 00       		.byte	0
 15031 0915 08       		.byte	8
 15032 0916 00       		.byte	0
 15033 0917 01       		.byte	1
 15034 0918 00       		.byte	0
 15035 0919 03       		.byte	3
 15036 091a 00       		.byte	0
 15037 091b 00       		.byte	0
 15038 091c 00       		.byte	0
 15039 091d 00       		.byte	0
 15040 091e 00       		.byte	0
 15041 091f 30       		.byte	48
 15042 0920 01       		.byte	1
 15043 0921 00       		.byte	0
 15044 0922 0000     		.space	2
 15047              	PUCSaturation:
 15048 0924 85       		.byte	-123
 15049 0925 86       		.byte	-122
 15050 0926 02       		.byte	2
 15051 0927 00       		.byte	0
 15052 0928 00       		.byte	0
 15053 0929 64       		.byte	100
 15054 092a 00       		.byte	0
 15055 092b 01       		.byte	1
 15056 092c 00       		.byte	0
 15057 092d 03       		.byte	3
 15058 092e 00       		.byte	0
 15059 092f 32       		.byte	50
 15060 0930 00       		.byte	0
 15061 0931 32       		.byte	50
 15062 0932 00       		.byte	0
 15063 0933 30       		.byte	48
 15064 0934 01       		.byte	1
 15065 0935 00       		.byte	0
 15066 0936 0000     		.space	2
 15069              	PUCContrast:
 15070 0938 0D       		.byte	13
 15071 0939 0D       		.byte	13
 15072 093a 02       		.byte	2
 15073 093b 00       		.byte	0
 15074 093c 00       		.byte	0
 15075 093d FF       		.byte	-1
 15076 093e 00       		.byte	0
 15077 093f 01       		.byte	1
 15078 0940 00       		.byte	0
 15079 0941 03       		.byte	3
 15080 0942 00       		.byte	0
 15081 0943 70       		.byte	112
 15082 0944 00       		.byte	0
 15083 0945 70       		.byte	112
 15084 0946 00       		.byte	0
 15085 0947 30       		.byte	48
 15086 0948 01       		.byte	1
 15087 0949 00       		.byte	0
 15088 094a 0000     		.space	2
 15091              	CyFxGpifRegValue_usb2:
 15092 094c 08830080 		.word	-2147450104
 15093 0950 67000000 		.word	103
 15094 0954 01000000 		.word	1
 15095 0958 46000000 		.word	70
 15096 095c 00000000 		.word	0
 15097 0960 00000000 		.word	0
 15098 0964 02000000 		.word	2
 15099 0968 82000000 		.word	130
 15100 096c 82070000 		.word	1922
 15101 0970 40040000 		.word	1088
 15102 0974 FCFF0000 		.word	65532
 15103 0978 28000000 		.word	40
 15104 097c 00000000 		.word	0
 15105 0980 00000000 		.word	0
 15106 0984 00000000 		.word	0
 15107 0988 00000000 		.word	0
 15108 098c 01000000 		.word	1
 15109 0990 00000000 		.word	0
 15110 0994 00000000 		.word	0
 15111 0998 00000000 		.word	0
 15112 099c 00000000 		.word	0
 15113 09a0 00000000 		.word	0
 15114 09a4 00000000 		.word	0
 15115 09a8 00000000 		.word	0
 15116 09ac 00000000 		.word	0
 15117 09b0 00000000 		.word	0
 15118 09b4 00000000 		.word	0
 15119 09b8 00000000 		.word	0
 15120 09bc 00000000 		.word	0
 15121 09c0 06000000 		.word	6
 15122 09c4 00000000 		.word	0
 15123 09c8 FFFF0000 		.word	65535
 15124 09cc 09010000 		.word	265
 15125 09d0 00000000 		.word	0
 15126 09d4 F71F0000 		.word	8183
 15127 09d8 00000000 		.word	0
 15128 09dc FFFF0000 		.word	65535
 15129 09e0 09010000 		.word	265
 15130 09e4 00000000 		.word	0
 15131 09e8 F71F0000 		.word	8183
 15132 09ec 00000000 		.word	0
 15133 09f0 00000000 		.word	0
 15134 09f4 00000000 		.word	0
 15135 09f8 00000000 		.word	0
 15136 09fc 00000000 		.word	0
 15137 0a00 00000000 		.word	0
 15138 0a04 00000000 		.word	0
 15139 0a08 00000000 		.word	0
 15140 0a0c 00000000 		.word	0
 15141 0a10 00000000 		.word	0
 15142 0a14 00000000 		.word	0
 15143 0a18 00000000 		.word	0
 15144 0a1c 00000000 		.word	0
 15145 0a20 00000000 		.word	0
 15146 0a24 00000000 		.word	0
 15147 0a28 00000000 		.word	0
 15148 0a2c 00000000 		.word	0
 15149 0a30 00000000 		.word	0
 15150 0a34 00000000 		.word	0
 15151 0a38 00000000 		.word	0
 15152 0a3c 00000000 		.word	0
 15153 0a40 00000000 		.word	0
 15154 0a44 00000000 		.word	0
 15155 0a48 00040180 		.word	-2147417088
 15156 0a4c 01040180 		.word	-2147417087
 15157 0a50 02040180 		.word	-2147417086
 15158 0a54 03040180 		.word	-2147417085
 15159 0a58 00000000 		.word	0
 15160 0a5c 00000000 		.word	0
 15161 0a60 00000000 		.word	0
 15162 0a64 00000000 		.word	0
 15163 0a68 00000000 		.word	0
 15164 0a6c 00000000 		.word	0
 15165 0a70 00000000 		.word	0
 15166 0a74 00000000 		.word	0
 15167 0a78 C1FFFFFF 		.word	-63
 15170              	CyFxGpifWavedataPosition_usb2:
 15171 0a7c 00       		.byte	0
 15172 0a7d 01       		.byte	1
 15173 0a7e 02       		.byte	2
 15174 0a7f 03       		.byte	3
 15175 0a80 04       		.byte	4
 15176 0a81 05       		.byte	5
 15177 0a82 06       		.byte	6
 15178 0a83 07       		.byte	7
 15179 0a84 08       		.byte	8
 15180 0a85 09       		.byte	9
 15181 0a86 0A       		.byte	10
 15182 0a87 08       		.byte	8
 15183 0a88 0B       		.byte	11
 15184 0a89 0C       		.byte	12
 15185 0a8a 0D       		.byte	13
 15186 0a8b 08       		.byte	8
 15187 0a8c 0E       		.byte	14
 15188 0a8d 0F       		.byte	15
 15189 0a8e 08       		.byte	8
 15190 0a8f 08       		.byte	8
 15191 0a90 08       		.byte	8
 15192 0a91 08       		.byte	8
 15193 0a92 08       		.byte	8
 15194 0a93 08       		.byte	8
 15195 0a94 08       		.byte	8
 15196 0a95 08       		.byte	8
 15197 0a96 08       		.byte	8
 15198 0a97 08       		.byte	8
 15199 0a98 08       		.byte	8
 15200 0a99 08       		.byte	8
 15201 0a9a 08       		.byte	8
 15202 0a9b 08       		.byte	8
 15203 0a9c 08       		.byte	8
 15204 0a9d 08       		.byte	8
 15205 0a9e 08       		.byte	8
 15206 0a9f 08       		.byte	8
 15207 0aa0 08       		.byte	8
 15208 0aa1 08       		.byte	8
 15209 0aa2 08       		.byte	8
 15210 0aa3 08       		.byte	8
 15211 0aa4 08       		.byte	8
 15212 0aa5 08       		.byte	8
 15213 0aa6 08       		.byte	8
 15214 0aa7 08       		.byte	8
 15215 0aa8 08       		.byte	8
 15216 0aa9 08       		.byte	8
 15217 0aaa 08       		.byte	8
 15218 0aab 08       		.byte	8
 15219 0aac 08       		.byte	8
 15220 0aad 08       		.byte	8
 15221 0aae 08       		.byte	8
 15222 0aaf 08       		.byte	8
 15223 0ab0 08       		.byte	8
 15224 0ab1 08       		.byte	8
 15225 0ab2 08       		.byte	8
 15226 0ab3 08       		.byte	8
 15227 0ab4 08       		.byte	8
 15228 0ab5 08       		.byte	8
 15229 0ab6 08       		.byte	8
 15230 0ab7 08       		.byte	8
 15231 0ab8 08       		.byte	8
 15232 0ab9 08       		.byte	8
 15233 0aba 08       		.byte	8
 15234 0abb 08       		.byte	8
 15235 0abc 08       		.byte	8
 15236 0abd 08       		.byte	8
 15237 0abe 08       		.byte	8
 15238 0abf 08       		.byte	8
 15239 0ac0 08       		.byte	8
 15240 0ac1 08       		.byte	8
 15241 0ac2 08       		.byte	8
 15242 0ac3 08       		.byte	8
 15243 0ac4 08       		.byte	8
 15244 0ac5 08       		.byte	8
 15245 0ac6 08       		.byte	8
 15246 0ac7 08       		.byte	8
 15247 0ac8 08       		.byte	8
 15248 0ac9 08       		.byte	8
 15249 0aca 08       		.byte	8
 15250 0acb 08       		.byte	8
 15251 0acc 08       		.byte	8
 15252 0acd 08       		.byte	8
 15253 0ace 08       		.byte	8
 15254 0acf 08       		.byte	8
 15255 0ad0 08       		.byte	8
 15256 0ad1 08       		.byte	8
 15257 0ad2 08       		.byte	8
 15258 0ad3 08       		.byte	8
 15259 0ad4 08       		.byte	8
 15260 0ad5 08       		.byte	8
 15261 0ad6 08       		.byte	8
 15262 0ad7 08       		.byte	8
 15263 0ad8 08       		.byte	8
 15264 0ad9 08       		.byte	8
 15265 0ada 08       		.byte	8
 15266 0adb 08       		.byte	8
 15267 0adc 08       		.byte	8
 15268 0add 08       		.byte	8
 15269 0ade 08       		.byte	8
 15270 0adf 08       		.byte	8
 15271 0ae0 08       		.byte	8
 15272 0ae1 08       		.byte	8
 15273 0ae2 08       		.byte	8
 15274 0ae3 08       		.byte	8
 15275 0ae4 08       		.byte	8
 15276 0ae5 08       		.byte	8
 15277 0ae6 08       		.byte	8
 15278 0ae7 08       		.byte	8
 15279 0ae8 08       		.byte	8
 15280 0ae9 08       		.byte	8
 15281 0aea 08       		.byte	8
 15282 0aeb 08       		.byte	8
 15283 0aec 08       		.byte	8
 15284 0aed 08       		.byte	8
 15285 0aee 08       		.byte	8
 15286 0aef 08       		.byte	8
 15287 0af0 08       		.byte	8
 15288 0af1 08       		.byte	8
 15289 0af2 08       		.byte	8
 15290 0af3 08       		.byte	8
 15291 0af4 08       		.byte	8
 15292 0af5 08       		.byte	8
 15293 0af6 08       		.byte	8
 15294 0af7 08       		.byte	8
 15295 0af8 08       		.byte	8
 15296 0af9 08       		.byte	8
 15297 0afa 08       		.byte	8
 15298 0afb 08       		.byte	8
 15299 0afc 00       		.byte	0
 15300 0afd 01       		.byte	1
 15301 0afe 02       		.byte	2
 15302 0aff 10       		.byte	16
 15303 0b00 04       		.byte	4
 15304 0b01 05       		.byte	5
 15305 0b02 06       		.byte	6
 15306 0b03 07       		.byte	7
 15307 0b04 08       		.byte	8
 15308 0b05 09       		.byte	9
 15309 0b06 0A       		.byte	10
 15310 0b07 08       		.byte	8
 15311 0b08 11       		.byte	17
 15312 0b09 0C       		.byte	12
 15313 0b0a 0D       		.byte	13
 15314 0b0b 08       		.byte	8
 15315 0b0c 0E       		.byte	14
 15316 0b0d 0F       		.byte	15
 15317 0b0e 08       		.byte	8
 15318 0b0f 00       		.space	1
 15321              	CyFxGpifWavedata_usb2:
 15322 0b10 0181731E 		.word	510886145
 15323 0b14 00000000 		.word	0
 15324 0b18 00000080 		.word	-2147483648
 15325 0b1c 00000000 		.word	0
 15326 0b20 00000000 		.word	0
 15327 0b24 00000000 		.word	0
 15328 0b28 0201703E 		.word	1047527682
 15329 0b2c 00010000 		.word	256
 15330 0b30 A00000C0 		.word	-1073741664
 15331 0b34 00000000 		.word	0
 15332 0b38 00000000 		.word	0
 15333 0b3c 00000000 		.word	0
 15334 0b40 0394731E 		.word	510891011
 15335 0b44 04000020 		.word	536870916
 15336 0b48 60004080 		.word	-2143289248
 15337 0b4c 00000000 		.word	0
 15338 0b50 00000000 		.word	0
 15339 0b54 00000000 		.word	0
 15340 0b58 0620702E 		.word	779100166
 15341 0b5c 0C000000 		.word	12
 15342 0b60 00000080 		.word	-2147483648
 15343 0b64 0620702E 		.word	779100166
 15344 0b68 0C000000 		.word	12
 15345 0b6c 00000080 		.word	-2147483648
 15346 0b70 0394731E 		.word	510891011
 15347 0b74 04000020 		.word	536870916
 15348 0b78 60004080 		.word	-2143289248
 15349 0b7c 0620702E 		.word	779100166
 15350 0b80 0C000000 		.word	12
 15351 0b84 00000080 		.word	-2147483648
 15352 0b88 0C93731E 		.word	510890764
 15353 0b8c 04000024 		.word	603979780
 15354 0b90 90004080 		.word	-2143289200
 15355 0b94 0D20702E 		.word	779100173
 15356 0b98 0C000000 		.word	12
 15357 0b9c 00000080 		.word	-2147483648
 15358 0ba0 0780724E 		.word	1316126727
 15359 0ba4 0A000000 		.word	10
 15360 0ba8 00000080 		.word	-2147483648
 15361 0bac 08000000 		.word	8
 15362 0bb0 00000000 		.word	0
 15363 0bb4 00010080 		.word	-2147483392
 15364 0bb8 0920702E 		.word	779100169
 15365 0bbc 0C010000 		.word	268
 15366 0bc0 00000080 		.word	-2147483648
 15367 0bc4 0A01701E 		.word	510656778
 15368 0bc8 0E000100 		.word	65550
 15369 0bcc 00000080 		.word	-2147483648
 15370 0bd0 00000000 		.word	0
 15371 0bd4 00000000 		.word	0
 15372 0bd8 00000000 		.word	0
 15373 0bdc 00000000 		.word	0
 15374 0be0 00000000 		.word	0
 15375 0be4 00000000 		.word	0
 15376 0be8 0394731E 		.word	510891011
 15377 0bec 04000020 		.word	536870916
 15378 0bf0 60004080 		.word	-2143289248
 15379 0bf4 08000000 		.word	8
 15380 0bf8 00000000 		.word	0
 15381 0bfc 00010080 		.word	-2147483392
 15382 0c00 0B000000 		.word	11
 15383 0c04 00000000 		.word	0
 15384 0c08 00010080 		.word	-2147483392
 15385 0c0c 0C93731E 		.word	510890764
 15386 0c10 04000024 		.word	603979780
 15387 0c14 90004080 		.word	-2143289200
 15388 0c18 0D20702E 		.word	779100173
 15389 0c1c 0C000000 		.word	12
 15390 0c20 00000080 		.word	-2147483648
 15391 0c24 0D20702E 		.word	779100173
 15392 0c28 0C000000 		.word	12
 15393 0c2c 00000080 		.word	-2147483648
 15394 0c30 0E60724E 		.word	1316118542
 15395 0c34 0A000000 		.word	10
 15396 0c38 00000080 		.word	-2147483648
 15397 0c3c 0F000000 		.word	15
 15398 0c40 00000000 		.word	0
 15399 0c44 00010080 		.word	-2147483392
 15400 0c48 1020702E 		.word	779100176
 15401 0c4c 0C010000 		.word	268
 15402 0c50 00000080 		.word	-2147483648
 15403 0c54 1101701E 		.word	510656785
 15404 0c58 0E000100 		.word	65550
 15405 0c5c 00000080 		.word	-2147483648
 15406 0c60 0C93731E 		.word	510890764
 15407 0c64 04000024 		.word	603979780
 15408 0c68 90004080 		.word	-2143289200
 15409 0c6c 0F000000 		.word	15
 15410 0c70 00000000 		.word	0
 15411 0c74 00010080 		.word	-2147483392
 15412 0c78 12000000 		.word	18
 15413 0c7c 00000000 		.word	0
 15414 0c80 00010080 		.word	-2147483392
 15415 0c84 0394731E 		.word	510891011
 15416 0c88 04000020 		.word	536870916
 15417 0c8c 60004080 		.word	-2143289248
 15418 0c90 0480732E 		.word	779321348
 15419 0c94 02010000 		.word	258
 15420 0c98 0000C0C0 		.word	-1061158912
 15421 0c9c 0580732E 		.word	779321349
 15422 0ca0 02010000 		.word	258
 15423 0ca4 0000C0C0 		.word	-1061158912
 15424 0ca8 0580732E 		.word	779321349
 15425 0cac 02010000 		.word	258
 15426 0cb0 0000C0C0 		.word	-1061158912
 15427 0cb4 0480732E 		.word	779321348
 15428 0cb8 02010000 		.word	258
 15429 0cbc 0000C0C0 		.word	-1061158912
 15432              	CyFxGpifTransition_usb2:
 15433 0cc0 0000     		.short	0
 15434 0cc2 5555     		.short	21845
 15435 0cc4 AAAA     		.short	-21846
 15436 0cc6 8888     		.short	-30584
 15437 0cc8 1111     		.short	4369
 15438 0cca 4444     		.short	17476
 15439 0ccc 3333     		.short	13107
 15440 0cce CCCC     		.short	-13108
 15443              	CyFxGpifRegValue:
 15444 0cd0 08830080 		.word	-2147450104
 15445 0cd4 67000000 		.word	103
 15446 0cd8 00000000 		.word	0
 15447 0cdc 46000000 		.word	70
 15448 0ce0 00000000 		.word	0
 15449 0ce4 00000000 		.word	0
 15450 0ce8 02000000 		.word	2
 15451 0cec 82000000 		.word	130
 15452 0cf0 82070000 		.word	1922
 15453 0cf4 40040000 		.word	1088
 15454 0cf8 FCFF0000 		.word	65532
 15455 0cfc 28000000 		.word	40
 15456 0d00 00000000 		.word	0
 15457 0d04 00000000 		.word	0
 15458 0d08 00000000 		.word	0
 15459 0d0c 00000000 		.word	0
 15460 0d10 01000000 		.word	1
 15461 0d14 00000000 		.word	0
 15462 0d18 00000000 		.word	0
 15463 0d1c 00000000 		.word	0
 15464 0d20 00000000 		.word	0
 15465 0d24 00000000 		.word	0
 15466 0d28 00000000 		.word	0
 15467 0d2c 00000000 		.word	0
 15468 0d30 00000000 		.word	0
 15469 0d34 00000000 		.word	0
 15470 0d38 00000000 		.word	0
 15471 0d3c 00000000 		.word	0
 15472 0d40 00000000 		.word	0
 15473 0d44 06000000 		.word	6
 15474 0d48 00000000 		.word	0
 15475 0d4c FFFF0000 		.word	65535
 15476 0d50 09010000 		.word	265
 15477 0d54 00000000 		.word	0
 15478 0d58 F71F0000 		.word	8183
 15479 0d5c 00000000 		.word	0
 15480 0d60 FFFF0000 		.word	65535
 15481 0d64 09010000 		.word	265
 15482 0d68 00000000 		.word	0
 15483 0d6c F71F0000 		.word	8183
 15484 0d70 00000000 		.word	0
 15485 0d74 00000000 		.word	0
 15486 0d78 00000000 		.word	0
 15487 0d7c 00000000 		.word	0
 15488 0d80 00000000 		.word	0
 15489 0d84 00000000 		.word	0
 15490 0d88 00000000 		.word	0
 15491 0d8c 00000000 		.word	0
 15492 0d90 00000000 		.word	0
 15493 0d94 00000000 		.word	0
 15494 0d98 00000000 		.word	0
 15495 0d9c 00000000 		.word	0
 15496 0da0 00000000 		.word	0
 15497 0da4 00000000 		.word	0
 15498 0da8 00000000 		.word	0
 15499 0dac 00000000 		.word	0
 15500 0db0 00000000 		.word	0
 15501 0db4 00000000 		.word	0
 15502 0db8 00000000 		.word	0
 15503 0dbc 00000000 		.word	0
 15504 0dc0 00000000 		.word	0
 15505 0dc4 00000000 		.word	0
 15506 0dc8 00000000 		.word	0
 15507 0dcc 00040180 		.word	-2147417088
 15508 0dd0 01040180 		.word	-2147417087
 15509 0dd4 02040180 		.word	-2147417086
 15510 0dd8 03040180 		.word	-2147417085
 15511 0ddc 00000000 		.word	0
 15512 0de0 00000000 		.word	0
 15513 0de4 00000000 		.word	0
 15514 0de8 00000000 		.word	0
 15515 0dec 00000000 		.word	0
 15516 0df0 00000000 		.word	0
 15517 0df4 00000000 		.word	0
 15518 0df8 00000000 		.word	0
 15519 0dfc C1FFFFFF 		.word	-63
 15522              	CyFxGpifWavedataPosition:
 15523 0e00 00       		.byte	0
 15524 0e01 01       		.byte	1
 15525 0e02 02       		.byte	2
 15526 0e03 03       		.byte	3
 15527 0e04 04       		.byte	4
 15528 0e05 05       		.byte	5
 15529 0e06 06       		.byte	6
 15530 0e07 07       		.byte	7
 15531 0e08 08       		.byte	8
 15532 0e09 09       		.byte	9
 15533 0e0a 0A       		.byte	10
 15534 0e0b 0B       		.byte	11
 15535 0e0c 0B       		.byte	11
 15536 0e0d 0B       		.byte	11
 15537 0e0e 0B       		.byte	11
 15538 0e0f 00       		.space	1
 15541              	CyFxGpifWavedata:
 15542 0e10 0181731E 		.word	510886145
 15543 0e14 00000000 		.word	0
 15544 0e18 00000080 		.word	-2147483648
 15545 0e1c 00000000 		.word	0
 15546 0e20 00000000 		.word	0
 15547 0e24 00000000 		.word	0
 15548 0e28 0201702E 		.word	779092226
 15549 0e2c 00010000 		.word	256
 15550 0e30 A0000080 		.word	-2147483488
 15551 0e34 00000000 		.word	0
 15552 0e38 00000000 		.word	0
 15553 0e3c 00000000 		.word	0
 15554 0e40 0380722E 		.word	779255811
 15555 0e44 02010020 		.word	536871170
 15556 0e48 60000080 		.word	-2147483552
 15557 0e4c 00000000 		.word	0
 15558 0e50 00000000 		.word	0
 15559 0e54 00000000 		.word	0
 15560 0e58 0460722E 		.word	779247620
 15561 0e5c 02010024 		.word	603980034
 15562 0e60 90000080 		.word	-2147483504
 15563 0e64 0594731E 		.word	510891013
 15564 0e68 06000000 		.word	6
 15565 0e6c 00000080 		.word	-2147483648
 15566 0e70 0380722E 		.word	779255811
 15567 0e74 02010020 		.word	536871170
 15568 0e78 60000080 		.word	-2147483552
 15569 0e7c 0693731E 		.word	510890758
 15570 0e80 06000000 		.word	6
 15571 0e84 00000080 		.word	-2147483648
 15572 0e88 0720703E 		.word	1047535623
 15573 0e8c 08010000 		.word	264
 15574 0e90 00000080 		.word	-2147483648
 15575 0e94 0820703E 		.word	1047535624
 15576 0e98 08010000 		.word	264
 15577 0e9c 00000080 		.word	-2147483648
 15578 0ea0 0920703E 		.word	1047535625
 15579 0ea4 08010000 		.word	264
 15580 0ea8 00000080 		.word	-2147483648
 15581 0eac 0A20703E 		.word	1047535626
 15582 0eb0 08010000 		.word	264
 15583 0eb4 00000080 		.word	-2147483648
 15584 0eb8 0380722E 		.word	779255811
 15585 0ebc 02010020 		.word	536871170
 15586 0ec0 60000080 		.word	-2147483552
 15587 0ec4 0B000000 		.word	11
 15588 0ec8 00000000 		.word	0
 15589 0ecc 00010080 		.word	-2147483392
 15590 0ed0 0460722E 		.word	779247620
 15591 0ed4 02010024 		.word	603980034
 15592 0ed8 90000080 		.word	-2147483504
 15593 0edc 0D000000 		.word	13
 15594 0ee0 00000000 		.word	0
 15595 0ee4 00010080 		.word	-2147483392
 15596 0ee8 0460722E 		.word	779247620
 15597 0eec 02010024 		.word	603980034
 15598 0ef0 90000080 		.word	-2147483504
 15599 0ef4 0C000000 		.word	12
 15600 0ef8 00000000 		.word	0
 15601 0efc 00010080 		.word	-2147483392
 15602 0f00 0380722E 		.word	779255811
 15603 0f04 02010020 		.word	536871170
 15604 0f08 60000080 		.word	-2147483552
 15605 0f0c 0E000000 		.word	14
 15606 0f10 00000000 		.word	0
 15607 0f14 00010080 		.word	-2147483392
 15608 0f18 00000000 		.word	0
 15609 0f1c 00000000 		.word	0
 15610 0f20 00000000 		.word	0
 15611 0f24 00000000 		.word	0
 15612 0f28 00000000 		.word	0
 15613 0f2c 00000000 		.word	0
 15616              	CyFxGpifTransition:
 15617 0f30 0000     		.short	0
 15618 0f32 5555     		.short	21845
 15619 0f34 8888     		.short	-30584
 15620 0f36 AAAA     		.short	-21846
 15621 0f38 3333     		.short	13107
 15622 0f3a 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15623              		.align	2
 15624              	.LC0:
 15625 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15625      706F732D 
 15625      74696D65 
 15625      72202564 
 15625      2025640D 
 15626 0016 0000     		.space	2
 15627              	.LC1:
 15628 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15628      6F207374 
 15628      7265616D 
 15628      20474554 
 15628      20726571 
 15629 003d 000000   		.space	3
 15630              	.LC2:
 15631 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15631      74686520 
 15631      76696465 
 15631      6F206D6F 
 15631      64652066 
 15632 0061 000000   		.space	3
 15633              	.LC3:
 15634 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15634      74686520 
 15634      76696465 
 15634      6F206D6F 
 15634      64652066 
 15635 0089 000000   		.space	3
 15636              	.LC4:
 15637 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15637      43595F46 
 15637      585F5556 
 15637      435F5354 
 15637      5245414D 
 15638 00b2 0000     		.space	2
 15639              	.LC5:
 15640 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15640      55564320 
 15640      7374696C 
 15640      6C205072 
 15640      6F622873 
 15641 00df 00       		.space	1
 15642              	.LC6:
 15643 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15643      74686520 
 15643      7374696C 
 15643      6C206D6F 
 15643      64652066 
 15644 0101 000000   		.space	3
 15645              	.LC7:
 15646 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15646      7374696C 
 15646      6C20636F 
 15646      6D6D6974 
 15646      20636F6E 
 15647              	.LC8:
 15648 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15648      43595F46 
 15648      585F5556 
 15648      435F5354 
 15648      494C5F45 
 15649              	.LC9:
 15650 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15650      55564320 
 15650      7374696C 
 15650      6C207472 
 15650      69676765 
 15651 0179 000000   		.space	3
 15652              	.LC10:
 15653 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15653      7374696C 
 15653      6C207472 
 15653      69676765 
 15653      7220636F 
 15654 01a3 00       		.space	1
 15655              	.LC11:
 15656 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15656      7065722D 
 15656      74696D65 
 15656      72202564 
 15656      0D0A00
 15657 01b7 00       		.space	1
 15658              	.LC12:
 15659 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15659      636F6D6D 
 15659      616E6420 
 15659      71756575 
 15659      65206973 
 15660 01db 00       		.space	1
 15661              	.LC13:
 15662 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15662      7220696E 
 15662      206D756C 
 15662      74696368 
 15662      616E6E65 
 15663 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15663      2025782C 
 15663      20646D61 
 15663      446F6E65 
 15663      20256420 
 15664              	.LC14:
 15665 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15665      5420656E 
 15665      636F756E 
 15665      74657265 
 15665      642E2E2E 
 15666              	.LC15:
 15667 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15667      454E4420 
 15667      656E636F 
 15667      756E7465 
 15667      7265642E 
 15668 026a 0000     		.space	2
 15669              	.LC16:
 15670 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15670      64697363 
 15670      6F6E6E65 
 15670      63746564 
 15670      2E2E2E30 
 15671 028b 00       		.space	1
 15672              	.LC17:
 15673 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15673      43595F46 
 15673      585F5556 
 15673      435F5649 
 15673      44454F5F 
 15674 02bf 0A00     		.ascii	"\012\000"
 15675 02c1 000000   		.space	3
 15676              	.LC18:
 15677 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15677      43595F46 
 15677      585F5556 
 15677      435F5649 
 15677      44454F5F 
 15678 02f7 00       		.ascii	"\000"
 15679              	.LC19:
 15680 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15680      726E6174 
 15680      65207365 
 15680      7474696E 
 15680      6720302E 
 15681              	.LC20:
 15682 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15682      72206665 
 15682      61747572 
 15682      65207265 
 15682      71756573 
 15683 0333 00       		.space	1
 15684              	.LC21:
 15685 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15685      49324320 
 15685      636F6D6D 
 15685      616E6420 
 15685      69732030 
 15686 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15686      78257820 
 15686      30782578 
 15686      20307825 
 15686      78203078 
 15687              	.LC22:
 15688 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15688      49324320 
 15688      636F6D6D 
 15688      616E6420 
 15688      73657474 
 15689 03a6 0000     		.space	2
 15690              	.LC23:
 15691 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15691      73687574 
 15691      74657220 
 15691      73657420 
 15691      76616C75 
 15692 03d2 0000     		.space	2
 15693              	.LC24:
 15694 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15694      26414743 
 15694      2073656E 
 15694      7420746F 
 15694      20686F73 
 15695 03fa 0000     		.space	2
 15696              	.LC25:
 15697 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15697      49324320 
 15697      63757272 
 15697      656E7420 
 15697      64617461 
 15698 042f 64202564 		.ascii	"d %d\015\012\000"
 15698      0D0A00
 15699 0436 0000     		.space	2
 15700              	.LC26:
 15701 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 15701      63757272 
 15701      656E7420 
 15701      76616C75 
 15701      65203078 
 15702 0465 000000   		.space	3
 15703              	.LC27:
 15704 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 15704      73657420 
 15704      636F6E74 
 15704      726F6C20 
 15704      6374726C 
 15705 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x\015\012\000"
 15705      443A2030 
 15705      78257820 
 15705      4C656E3A 
 15705      20307825 
 15706 04b3 00       		.space	1
 15707              	.LC28:
 15708 04b4 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15708      26414743 
 15708      20676F74 
 15708      74656E20 
 15708      66726F6D 
 15709 04e5 0A00     		.ascii	"\012\000"
 15710 04e7 00       		.space	1
 15711              	.LC29:
 15712 04e8 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15712      73687574 
 15712      74657226 
 15712      6578706F 
 15712      73757265 
 15713 0513 00       		.space	1
 15714              	.LC30:
 15715 0514 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15715      74657220 
 15715      6C657665 
 15715      6C20676F 
 15715      7474656E 
 15716 0547 25640D0A 		.ascii	"%d\015\012\000"
 15716      00
 15717              	.LC31:
 15718 054c 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 15718      64617461 
 15718      20676574 
 15718      73206672 
 15718      6F6D2068 
 15719 057f 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 15719      78206375 
 15719      7248693A 
 15719      20307825 
 15719      78204C65 
 15720 059d 000000   		.space	3
 15721              	.LC32:
 15722 05a0 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15722      75656E63 
 15722      79207365 
 15722      7474696E 
 15722      67206973 
 15723 05be 0000     		.space	2
 15724              	.LC33:
 15725 05c0 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15725      20746865 
 15725      20766964 
 15725      656F206D 
 15725      6F646520 
 15726 05e2 0000     		.space	2
 15727              	.LC34:
 15728 05e4 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15728      67657420 
 15728      64617461 
 15728      2066726F 
 15728      6D20686F 
 15729 0611 000000   		.space	3
 15730              	.LC35:
 15731 0614 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15731      52657175 
 15731      65737420 
 15731      30782578 
 15731      20706172 
 15732 0647 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15732      6E642074 
 15732      6F20686F 
 15732      73742030 
 15732      78257820 
 15733 0662 0000     		.space	2
 15734              	.LC36:
 15735 0664 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15735      204F7020 
 15735      72656365 
 15735      69766573 
 15735      20284354 
 15736 068b 00       		.space	1
 15737              	.LC37:
 15738 068c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15738      756C7420 
 15738      73656C65 
 15738      63746F72 
 15738      20284354 
 15739 06ae 0000     		.space	2
 15740              	.LC38:
 15741 06b0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15741      756C7420 
 15741      72657175 
 15741      65737420 
 15741      28435429 
 15742 06d1 000000   		.space	3
 15743              	.LC39:
 15744 06d4 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15744      52657175 
 15744      65737420 
 15744      30782578 
 15744      20706172 
 15745 0707 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15745      20307825 
 15745      78202F20 
 15745      73656E64 
 15745      20746F20 
 15746 0734 00       		.ascii	"\000"
 15747 0735 000000   		.space	3
 15748              	.LC40:
 15749 0738 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15749      73657420 
 15749      64656620 
 15749      64617461 
 15749      20307825 
 15750 0757 00       		.space	1
 15751              	.LC41:
 15752 0758 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15752      73657420 
 15752      64656620 
 15752      64617461 
 15752      20307825 
 15753 078b 2E0D0A00 		.ascii	".\015\012\000"
 15754 078f 00       		.space	1
 15755              	.LC42:
 15756 0790 4572726F 		.ascii	"Error handler...\015\012\000"
 15756      72206861 
 15756      6E646C65 
 15756      722E2E2E 
 15756      0D0A00
 15757 07a3 00       		.space	1
 15758              	.LC43:
 15759 07a4 55415254 		.ascii	"UART initialization failed!\012\000"
 15759      20696E69 
 15759      7469616C 
 15759      697A6174 
 15759      696F6E20 
 15760 07c1 000000   		.space	3
 15761              	.LC44:
 15762 07c4 49324320 		.ascii	"I2C initialization failed!\012\000"
 15762      696E6974 
 15762      69616C69 
 15762      7A617469 
 15762      6F6E2066 
 15763              	.LC45:
 15764 07e0 49324320 		.ascii	"I2C configuration failed!\012\000"
 15764      636F6E66 
 15764      69677572 
 15764      6174696F 
 15764      6E206661 
 15765 07fb 00       		.space	1
 15766              	.LC46:
 15767 07fc 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15767      43726561 
 15767      74652045 
 15767      76656E74 
 15767      20666169 
 15768 0826 0000     		.space	2
 15769              	.LC47:
 15770 0828 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15770      20496E69 
 15770      74206661 
 15770      696C6564 
 15770      2C204572 
 15771 084b 00       		.space	1
 15772              	.LC48:
 15773 084c 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15773      204F7665 
 15773      72726964 
 15773      65206661 
 15773      696C6564 
 15774 0873 00       		.space	1
 15775              	.LC49:
 15776 0874 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15776      28323029 
 15776      204F7665 
 15776      72726964 
 15776      65206661 
 15777 089f 00       		.space	1
 15778              	.LC50:
 15779 08a0 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15779      28323429 
 15779      204F7665 
 15779      72726964 
 15779      65206661 
 15780 08cb 00       		.space	1
 15781              	.LC51:
 15782 08cc 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15782      20536574 
 15782      20287265 
 15782      73657420 
 15782      32322920 
 15783 08fe 00       		.ascii	"\000"
 15784 08ff 00       		.space	1
 15785              	.LC52:
 15786 0900 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15786      20536574 
 15786      2028706F 
 15786      77657220 
 15786      32302920 
 15787 0932 00       		.ascii	"\000"
 15788 0933 00       		.space	1
 15789              	.LC53:
 15790 0934 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15790      20536574 
 15790      2028736E 
 15790      61702073 
 15790      686F7420 
 15791 0967 25640A00 		.ascii	"%d\012\000"
 15792 096b 00       		.space	1
 15793              	.LC54:
 15794 096c 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15794      46756E63 
 15794      74696F6E 
 15794      20466169 
 15794      6C656420 
 15795 099b 00       		.space	1
 15796              	.LC55:
 15797 099c 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15797      46756E63 
 15797      74696F6E 
 15797      20466169 
 15797      6C656420 
 15798 09cb 00       		.space	1
 15799              	.LC56:
 15800 09cc 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15800      53657420 
 15800      456E6470 
 15800      6F696E74 
 15800      20636F6E 
 15801 09fc 00       		.ascii	"\000"
 15802 09fd 000000   		.space	3
 15803              	.LC57:
 15804 0a00 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15804      496E7465 
 15804      72727570 
 15804      74205374 
 15804      61747573 
 15805 0a33 20436F64 		.ascii	" Code = %d\012\000"
 15805      65203D20 
 15805      25640A00 
 15806 0a3f 00       		.space	1
 15807              	.LC58:
 15808 0a40 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15808      65642074 
 15808      6F20616C 
 15808      6C6F6361 
 15808      7465206D 
 15809 0a73 65720D0A 		.ascii	"er\015\012\000"
 15809      00
 15810              	.LC59:
 15811 0a78 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15811      4368616E 
 15811      6E656C20 
 15811      43726561 
 15811      74696F6E 
 15812 0aa6 0000     		.space	2
 15813              	.LC60:
 15814 0aa8 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15814      436F6E6E 
 15814      65637420 
 15814      6661696C 
 15814      65642C20 
 15815 0acd 000000   		.space	3
 15816              	.LC61:
 15817 0ad0 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15817      74686520 
 15817      76696465 
 15817      6F206D6F 
 15817      64652066 
 15818 0af2 0000     		.space	2
 15819              	.LC62:
 15820 0af4 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15820      4368616E 
 15820      6E656C20 
 15820      52657365 
 15820      74204661 
 15821 0b1f 00       		.space	1
 15822              	.LC63:
 15823 0b20 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15823      4368616E 
 15823      6E656C20 
 15823      53657420 
 15823      5472616E 
 15824 0b51 00       		.ascii	"\000"
 15825 0b52 0000     		.space	2
 15826              	.LC64:
 15827 0b54 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15827      4368616E 
 15827      6E656C20 
 15827      53657420 
 15827      5472616E 
 15828 0b85 0A00     		.ascii	"\012\000"
 15829 0b87 00       		.space	1
 15830              	.LC65:
 15831 0b88 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15831      75706572 
 15831      20677069 
 15831      6600
 15832 0b96 0000     		.space	2
 15833              	.LC66:
 15834 0b98 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15834      69676820 
 15834      67706966 
 15834      00
 15835 0ba5 000000   		.space	3
 15836              	.LC67:
 15837 0ba8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15837      696E6720 
 15837      47504946 
 15837      20436F6E 
 15837      66696775 
 15838 0bdb 0A00     		.ascii	"\012\000"
 15839 0bdd 000000   		.space	3
 15840              	.LC68:
 15841 0be0 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15841      74696E67 
 15841      20475049 
 15841      46207374 
 15841      61746520 
 15842 0c13 0D0A00   		.ascii	"\015\012\000"
 15843 0c16 0000     		.space	2
 15844              	.LC69:
 15845 0c18 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15845      73706565 
 15845      64203D20 
 15845      25642065 
 15845      76656E66 
 15846 0c48 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15846      71756573 
 15846      74203D20 
 15846      30782578 
 15846      20775661 
 15847 0c78 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15847      203D2030 
 15847      78257820 
 15847      6973666C 
 15847      61672030 
 15848 0c92 0000     		.space	2
 15849              	.LC70:
 15850 0c94 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15850      64656661 
 15850      756C7420 
 15850      73657475 
 15850      70207265 
 15851              	.LC71:
 15852 0cc0 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 15852      68797374 
 15852      65722063 
 15852      6F6D6D61 
 15852      6E642030 
 15853 0cdf 00       		.space	1
 15854              	.LC72:
 15855 0ce0 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 15855      6374726C 
 15855      73706420 
 15855      636F6D6D 
 15855      616E6420 
 15856              	.LC73:
 15857 0d00 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 15857      65646765 
 15857      4D6F6465 
 15857      20636F6D 
 15857      6D616E64 
 15858 0d21 000000   		.space	3
 15859              	.LC74:
 15860 0d24 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 15860      65646765 
 15860      6761696E 
 15860      20636F6D 
 15860      6D616E64 
 15861 0d45 000000   		.space	3
 15862              	.LC75:
 15863 0d48 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 15863      65646765 
 15863      20737461 
 15863      72742F65 
 15863      6E642063 
 15864 0d6f 00       		.space	1
 15865              	.LC76:
 15866 0d70 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 15866      32444E52 
 15866      20737461 
 15866      72742F65 
 15866      6E642063 
 15867 0d97 00       		.space	1
 15868              	.LC77:
 15869 0d98 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 15869      67616D6D 
 15869      6120636F 
 15869      6D6D616E 
 15869      64203078 
 15870 0db6 0000     		.space	2
 15871              	.LC78:
 15872 0db8 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15872      65642074 
 15872      6F207365 
 15872      6E642069 
 15872      6E746572 
 15873 0de9 0A00     		.ascii	"\012\000"
 15874 0deb 00       		.space	1
 15875              	.LC79:
 15876 0dec 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15876      6F6D6D69 
 15876      74656F66 
 15876      20737461 
 15876      7465203D 
 15877              	.LC80:
 15878 0e04 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15878      6E656C20 
 15878      53657420 
 15878      57726170 
 15878      55702066 
 15879 0e31 000000   		.space	3
 15880              	.LC81:
 15881 0e34 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15881      69742045 
 15881      4F462066 
 15881      61696C65 
 15881      64210D0A 
 15882 0e49 000000   		.space	3
 15883              	.LC82:
 15884 0e4c 49324363 		.ascii	"I2CcmdQue\000"
 15884      6D645175 
 15884      6500
 15885 0e56 0000     		.space	2
 15886              	.LC83:
 15887 0e58 33303A55 		.ascii	"30:UVC App Thread\000"
 15887      56432041 
 15887      70702054 
 15887      68726561 
 15887      6400
 15888 0e6a 0000     		.space	2
 15889              	.LC84:
 15890 0e6c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15890      56432041 
 15890      70702045 
 15890      50302054 
 15890      68726561 
 15891 0e82 0000     		.space	2
 15892              	.LC85:
 15893 0e84 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15893      32432041 
 15893      70702043 
 15893      54524C20 
 15893      54687265 
 15894 0e9b 00       		.bss
 15895              		.align	2
 15896              		.set	.LANCHOR0,. + 0
 15899              	glFxUVCEvent:
 15900 0000 00000000 		.space	40
 15900      00000000 
 15900      00000000 
 15900      00000000 
 15900      00000000 
 15903              	glEp0Buffer:
 15904 0028 00000000 		.space	32
 15904      00000000 
 15904      00000000 
 15904      00000000 
 15904      00000000 
 15907              	usbSpeed:
 15908 0048 00       		.space	1
 15909 0049 000000   		.space	3
 15912              	glCommitCtrl:
 15913 004c 00000000 		.space	32
 15913      00000000 
 15913      00000000 
 15913      00000000 
 15913      00000000 
 15916              	is60Hz:
 15917 006c 00000000 		.space	4
 15920              	setRes:
 15921 0070 00       		.space	1
 15924              	setstilRes:
 15925 0071 00       		.space	1
 15928              	stiflag:
 15929 0072 00       		.space	1
 15930 0073 00       		.space	1
 15933              	fb:
 15934 0074 0000     		.space	2
 15937              	pb:
 15938 0076 0000     		.space	2
 15941              	pbc:
 15942 0078 0000     		.space	2
 15943 007a 0000     		.space	2
 15946              	hitFV:
 15947 007c 00000000 		.space	4
 15950              	prodCount:
 15951 0080 0000     		.space	2
 15954              	consCount:
 15955 0082 0000     		.space	2
 15958              	streamingStarted:
 15959 0084 00000000 		.space	4
 15962              	gpif_initialized:
 15963 0088 00000000 		.space	4
 15966              	isUsbConnected:
 15967 008c 00000000 		.space	4
 15970              	clearFeatureRqtReceived:
 15971 0090 00000000 		.space	4
 15974              	I2CCMDArry:
 15975 0094 00000000 		.space	12
 15975      00000000 
 15975      00000000 
 15978              	curFlag:
 15979 00a0 00000000 		.space	64
 15979      00000000 
 15979      00000000 
 15979      00000000 
 15979      00000000 
 15982              	IMcount.8239:
 15983 00e0 00       		.space	1
 15984 00e1 000000   		.space	3
 15987              	uvcAppThread:
 15988 00e4 00000000 		.space	168
 15988      00000000 
 15988      00000000 
 15988      00000000 
 15988      00000000 
 15991              	uvcAppEP0Thread:
 15992 018c 00000000 		.space	168
 15992      00000000 
 15992      00000000 
 15992      00000000 
 15992      00000000 
 15995              	i2cAppThread:
 15996 0234 00000000 		.space	168
 15996      00000000 
 15996      00000000 
 15996      00000000 
 15996      00000000 
 15999              	pbcpbak:
 16000 02dc 0000     		.space	2
 16003              	pbcbak:
 16004 02de 0000     		.space	2
 16007              	pbbak:
 16008 02e0 0000     		.space	2
 16011              	fbbak:
 16012 02e2 0000     		.space	2
 16015              	testSnap:
 16016 02e4 00       		.space	1
 16017 02e5 000000   		.text
 16018              	.Letext0:
 16019              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 16020              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16021              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 16022              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 16023              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 16024              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16025              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16026              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16027              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16028              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16029              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16030              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16031              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16032              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16033              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16034              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16035              		.file 18 "../sensor.h"
 16036              		.file 19 "../cmdqu.h"
 16037              		.file 20 "../uvc.h"
 16038              		.file 21 "../cyfxgpif2config.h"
 16039              		.file 22 "../cyfxgpif2config_usb2_720.h"
 16040              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2536   .text:000014b0 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2562   .text:0000150c $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2649   .text:000015cc $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2665   .text:00001604 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2792   .text:0000170c $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2805   .text:00001738 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2865   .text:000017b8 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:2880   .text:000017e8 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4144   .text:0000235c $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4166   .text:000023a8 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4310   .text:000024dc $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4316   .text:000024ec $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4782   .text:00002984 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4929   .text:00002aac $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:4942   .text:00002ad4 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5358   .text:00002f04 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5369   .text:00002f24 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5639   .text:000031b8 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5651   .text:000031dc $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5654   .text:000031dc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5955   .text:00003498 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5962   .text:000034a8 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:5965   .text:000034a8 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6009   .text:000034ec $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6014   .text:000034f4 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6017   .text:000034f4 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6045   .text:00003510 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6049   .text:00003514 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6052   .text:00003514 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6837   .text:00003b90 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:6843   .text:00003ba0 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:7318   .text:00003f88 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12316  .text:0000663c CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:7377   .text:00004060 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:7380   .text:00004060 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:7443   .text:000040d4 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:7451   .text:000040e4 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:9211   .text:00005010 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:9251   .text:00005094 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12301  .text:00006628 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12313  .text:0000663c $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12348  .text:00006670 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12361  .text:0000669c $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12366  .text:000066ac $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12371  .text:000066bc $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12419  .text:00006714 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12429  .text:00006728 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12432  .text:00006728 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12585  .text:00006870 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12602  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12605  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:13950  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12969  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12890  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12954  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12860  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12920  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15958  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15970  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15907  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15966  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15999  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:16003  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:16007  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:16011  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15941  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15937  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15933  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:16015  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14558  .data:0000076a snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12833  .rodata:0000017c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15091  .data:0000094c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15170  .data:00000a7c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15321  .data:00000b10 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15432  .data:00000cc0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12820  .rodata:00000160 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15443  .data:00000cd0 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15522  .data:00000e00 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15541  .data:00000e10 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15616  .data:00000f30 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12745  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12749  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12764  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14104  .data:00000574 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14959  .data:000008d4 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14937  .data:000008c0 EXTMirror
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14915  .data:000008ac EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14893  .data:00000898 EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14871  .data:00000884 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14849  .data:00000870 EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14827  .data:0000085c EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14805  .data:00000848 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:13987  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14783  .data:00000834 EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14126  .data:00000588 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14761  .data:00000820 EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14739  .data:0000080c EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14717  .data:000007f8 EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14148  .data:0000059c EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14695  .data:000007e4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:13965  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14673  .data:000007d0 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14651  .data:000007bc EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14515  .data:00000744 EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14537  .data:00000758 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14629  .data:000007a8 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14607  .data:00000794 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14585  .data:00000780 EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14563  .data:0000076c EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12801  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14082  .data:00000560 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14009  .data:00000520 PUCBright
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15069  .data:00000938 PUCContrast
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14053  .data:00000548 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14031  .data:00000534 PUCHueC
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15047  .data:00000924 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15025  .data:00000910 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15003  .data:000008fc PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14981  .data:000008e8 PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14493  .data:00000730 PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12846  .rodata:00000198 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12856  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12949  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:12984  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:13307  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14075  .data:0000055c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:14170  .data:000005b0 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15623  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15895  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15899  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15903  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15912  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15916  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15920  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15924  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15928  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15946  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15950  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15954  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15962  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15974  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15978  .bss:000000a0 curFlag
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15982  .bss:000000e0 IMcount.8239
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15987  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15991  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cccbZ7Pm.s:15995  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
