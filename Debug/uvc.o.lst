   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 594:../uvc.c      **** /*
 595:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 596:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 597:../uvc.c      ****  */
 598:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 599:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 600:../uvc.c      **** };
 601:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 602:../uvc.c      **** 		0
 603:../uvc.c      **** };
 604:../uvc.c      **** 
 605:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 606:../uvc.c      **** 
 607:../uvc.c      **** void I2CCmdHandler(){
 608:../uvc.c      **** 	uint8_t buf[2];
 609:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 611:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 612:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 613:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 614:../uvc.c      **** 	uint8_t i;
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 616:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 617:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 619:../uvc.c      **** 	{
 620:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 622:../uvc.c      **** 			{
 623:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 624:../uvc.c      **** 			}
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 626:../uvc.c      **** 
 627:../uvc.c      **** 	}
 628:../uvc.c      **** 	if(CmdType == 0)//I2C read
 629:../uvc.c      **** 	{
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 631:../uvc.c      **** #if 0 //for debugging
 632:../uvc.c      **** 		/* test still image operation */
 633:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 634:../uvc.c      **** 			snapButFlag = 0; //press
 635:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 636:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 637:../uvc.c      **** 			snapButFlag = 0xf; //release
 638:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 639:../uvc.c      **** 		}
 640:../uvc.c      **** 
 641:../uvc.c      **** 		/* end of the test */
 642:../uvc.c      **** #endif
 643:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 646:../uvc.c      **** 				if(CmdDataLen == 2){
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 648:../uvc.c      **** 				}
 649:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 650:../uvc.c      **** 		}else{//not support currently
 651:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 652:../uvc.c      **** 		}
 653:../uvc.c      **** 	}else if(CmdType == 1){
 654:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 655:../uvc.c      **** 			if(CmdRegLen == 2){
 656:../uvc.c      **** 				for(i = 0; i<4; i++)
 657:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 658:../uvc.c      **** 			}
 659:../uvc.c      **** 			else{
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 661:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 662:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 664:../uvc.c      **** 				}
 665:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 		}else{//not support currently
 668:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 669:../uvc.c      **** 		}
 670:../uvc.c      **** 
 671:../uvc.c      **** 	}
 672:../uvc.c      **** }
 673:../uvc.c      **** 
 674:../uvc.c      **** /************************************
 675:../uvc.c      ****  * set Iris mode
 676:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 677:../uvc.c      ****  */
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 679:../uvc.c      **** 	uint8_t dataIdx = 0;
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 684:../uvc.c      **** }
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** 
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 689:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 690:../uvc.c      **** 	uint16_t NumLn;
 691:../uvc.c      **** 	uint16_t fRate, shutTm;
 692:../uvc.c      **** 	uint8_t LnVal;
 693:../uvc.c      **** 	switch (Data){
 694:../uvc.c      **** 	case 1:
 695:../uvc.c      **** 	case 2:
 696:../uvc.c      **** 	case 3:
 697:../uvc.c      **** 	case 4:
 698:../uvc.c      **** 	case 5:
 699:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 700:../uvc.c      **** 		fRate = 30;
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 702:../uvc.c      **** 		if(NumLn > 1944)
 703:../uvc.c      **** 			NumLn =1944;
 704:../uvc.c      **** 		else if(NumLn < 8)
 705:../uvc.c      **** 			NumLn = 8;
 706:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 707:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 708:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 709:../uvc.c      **** 		break;
 710:../uvc.c      **** 	case 6:
 711:../uvc.c      **** 	case 7:
 712:../uvc.c      **** 	case 8:
 713:../uvc.c      **** 	case 9:
 714:../uvc.c      **** 	case 10:
 715:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 716:../uvc.c      **** 		fRate = 30;
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 718:../uvc.c      **** 		if(NumLn > 1944)
 719:../uvc.c      **** 			NumLn =1944;
 720:../uvc.c      **** 		else if(NumLn < 8)
 721:../uvc.c      **** 			NumLn = 8;
 722:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 723:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 724:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 725:../uvc.c      **** 		break;
 726:../uvc.c      **** 	case 0: //auto
 727:../uvc.c      **** 	default:
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 729:../uvc.c      **** 		LnVal = 1;
 730:../uvc.c      **** 		break;
 731:../uvc.c      **** 	}
 732:../uvc.c      **** 	return LnVal;
 733:../uvc.c      **** }
 734:../uvc.c      **** 
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 736:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 737:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 738:../uvc.c      ****     uint16_t readCount;
 739:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 740:../uvc.c      ****     uint8_t devAdd;
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 744:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 745:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 746:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 747:../uvc.c      ****     }else{
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 749:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 750:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 751:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 752:../uvc.c      ****     }
 753:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 754:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 755:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 756:../uvc.c      **** #endif
 757:../uvc.c      ****     reqData = bRequest;
 758:../uvc.c      ****     /*
 759:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 760:../uvc.c      ****      */
 761:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 762:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 763:../uvc.c      ****     	goto EndofSet;
 764:../uvc.c      ****     }
 765:../uvc.c      ****     switch (bRequest)
 766:../uvc.c      **** 		 {
 767:../uvc.c      **** 
 768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 772:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 773:../uvc.c      **** 			  break;
 774:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 775:../uvc.c      **** 
 776:../uvc.c      **** 			 switch(CtrlID)
 777:../uvc.c      **** 			 {
 778:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 779:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 780:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 781:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 782:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 783:../uvc.c      **** 			 	 		 }else{
 784:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 785:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 787:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 788:../uvc.c      **** 			 	 		 }
 789:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 790:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 791:../uvc.c      **** 						 break;
 792:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 793:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 794:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 795:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 796:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 797:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 798:../uvc.c      **** 			 	 		 }else{
 799:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 800:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 801:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 802:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 803:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 804:../uvc.c      **** 			 	 		 }
 805:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 806:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 807:../uvc.c      **** 			 	 		 break;
 808:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 809:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 810:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 811:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 812:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 813:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 814:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 815:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 816:../uvc.c      **** 			 	 		 }else{
 817:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 818:../uvc.c      **** 			 	 			if(Data0&0x80)
 819:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 820:../uvc.c      **** 			 	 			else
 821:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 822:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 823:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 824:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 825:../uvc.c      **** 			 	 		 }
 826:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 827:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 828:../uvc.c      **** 			 	 		 break;
 829:../uvc.c      **** 			 	 }
 830:../uvc.c      **** 			 	 case ExtShutCtlID0:
 831:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 832:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 833:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 834:../uvc.c      **** 
 835:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 836:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 837:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 839:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 840:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 841:../uvc.c      **** 		 	 		 }else{
 842:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 844:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 845:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 846:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 847:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 848:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 849:../uvc.c      **** 
 850:../uvc.c      **** 		 	 		 }
 851:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 852:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 853:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 854:../uvc.c      **** 			 		 break;
 855:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 856:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 857:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 858:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 859:../uvc.c      **** 
 860:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 861:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 862:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 864:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 865:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 866:../uvc.c      **** 		 	 		 }else{
 867:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 868:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 869:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 870:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 871:../uvc.c      **** 		 	 		 }
 872:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 873:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 874:../uvc.c      **** 			 		 break;
 875:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 876:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 877:../uvc.c      **** 
 878:../uvc.c      **** 					 if(CamMode == 1){//720p
 879:../uvc.c      **** 						if(sendData >= 3){
 880:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 881:../uvc.c      **** 							sendData = 0; //set back to default
 882:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 883:../uvc.c      **** 						}
 884:../uvc.c      **** 						sendData += 4;
 885:../uvc.c      **** 					 }
 886:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 887:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 888:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 889:../uvc.c      **** 					 break;
 890:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 891:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 892:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 893:../uvc.c      **** 			 		 }
 894:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 895:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 896:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 897:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 898:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 899:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 900:../uvc.c      **** #endif
 901:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 902:../uvc.c      **** 			 		 {
 903:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 904:../uvc.c      **** 			 		 }
 905:../uvc.c      **** 			 		 break;
 906:../uvc.c      **** 				 case ExtAexModCtlID9:
 907:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 908:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 909:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 910:../uvc.c      **** 
 911:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 912:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 914:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 915:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 916:../uvc.c      **** 		 	 		 }else{
 917:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 919:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 920:../uvc.c      **** 
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 922:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 923:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 924:../uvc.c      **** 		 	 		 }
 925:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 926:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 927:../uvc.c      **** 
 928:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 930:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 932:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 933:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 934:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 935:../uvc.c      **** 					 break;
 936:../uvc.c      **** 
 937:../uvc.c      **** 			 	 case BrgtCtlID1:
 938:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 939:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 940:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 941:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 942:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 943:../uvc.c      **** 					 }else{
 944:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 945:../uvc.c      **** 					 }
 946:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 947:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 948:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 949:../uvc.c      **** 					 */
 950:../uvc.c      **** 
 951:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 952:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 953:../uvc.c      **** 		 	 		 }else{
 954:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 955:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 956:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 957:../uvc.c      **** 		 	 		 }
 958:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
 959:../uvc.c      **** 					  if(Data0&0x80){
 960:../uvc.c      **** 						  Data0 = ~Data0;
 961:../uvc.c      **** 					  }else{
 962:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 963:../uvc.c      **** 					  }
 964:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 966:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 967:../uvc.c      **** 			 		 break;
 968:../uvc.c      **** 				 case HueCtlID5:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 971:../uvc.c      **** 		 	 		 }else{
 972:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 973:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 974:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 975:../uvc.c      **** 		 	 		 }
 976:../uvc.c      **** 
 977:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 978:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 979:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 980:../uvc.c      **** 					 break;
 981:../uvc.c      **** 				 case WBTLevCtlID11:
 982:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 983:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
 984:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 985:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
 986:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 987:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 988:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 989:../uvc.c      **** 		 	 		 }else{
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 991:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 992:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 993:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 994:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 995:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 996:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 997:../uvc.c      **** 		 	 		 }
 998:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 999:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1000:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1001:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1002:../uvc.c      **** 					 break;
1003:../uvc.c      **** 				 case BLCCtlID0:
1004:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1005:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1006:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1007:../uvc.c      **** 		 	 		 }else{
1008:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1009:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1010:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1011:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1015:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1016:../uvc.c      **** 					 break;
1017:../uvc.c      **** 				 case ShapCtlID7:
1018:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1019:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1020:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1021:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1022:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1023:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1024:../uvc.c      **** 		 	 		 }else{
1025:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1026:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1027:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1028:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1029:../uvc.c      **** 		 	 		 }
1030:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1031:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1032:../uvc.c      **** 					 break;
1033:../uvc.c      **** 				 case ExtExRefCtlID10:
1034:../uvc.c      **** 				 case ConsCtlID2:
1035:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1036:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1037:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1038:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1039:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1040:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1041:../uvc.c      **** 		 	 		 }else{
1042:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1043:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1044:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1045:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1046:../uvc.c      **** 		 	 		 }
1047:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1048:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1049:../uvc.c      **** 					 break;
1050:../uvc.c      **** 				 case WBTMdCtlID9:
1051:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1052:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1053:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1054:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1055:../uvc.c      **** 		 	 		 }else{
1056:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1057:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1058:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1059:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1060:../uvc.c      **** 
1061:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1062:../uvc.c      **** 		 	 		 }
1063:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1064:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1065:../uvc.c      **** 					 break;
1066:../uvc.c      **** 				 case MFreqCtlID4:
1067:../uvc.c      **** 
1068:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1069:../uvc.c      **** 
1070:../uvc.c      **** 		 	 			 if(is60Hz)
1071:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1072:../uvc.c      **** 		 	 			 else
1073:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1074:../uvc.c      **** 
1075:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1077:../uvc.c      **** 		 	 		 }else{
1078:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1079:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1080:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1081:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1082:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1084:../uvc.c      **** 		 	 		 }
1085:../uvc.c      **** 
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case SaturCtlID6:
1090:../uvc.c      **** 				 default:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1093:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1094:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1096:../uvc.c      **** 		 	 		 }else{
1097:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1098:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1099:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1101:../uvc.c      **** 		 	 		 }
1102:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1103:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1106:../uvc.c      **** 					 break;
1107:../uvc.c      **** 			 }
1108:../uvc.c      **** 
1109:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1110:../uvc.c      **** 
1111:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1112:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1113:../uvc.c      **** #endif
1114:../uvc.c      **** 			  break;
1115:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1116:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1117:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1118:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1119:../uvc.c      **** 		 	 }
1120:../uvc.c      **** 
1121:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1122:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1123:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1124:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1125:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1126:../uvc.c      **** 			 }else
1127:../uvc.c      **** 			 {
1128:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1129:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1130:../uvc.c      **** 			 }
1131:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1132:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1133:../uvc.c      **** 			  break;
1134:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1135:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1136:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1137:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1138:../uvc.c      **** 		 	 }
1139:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1140:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1141:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1142:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1143:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1144:../uvc.c      **** 			 }else
1145:../uvc.c      **** 			 {
1146:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1147:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1148:../uvc.c      **** 			 }
1149:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1150:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1151:../uvc.c      **** 			  break;
1152:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1153:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1154:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1155:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1156:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1157:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1158:../uvc.c      **** 		 	 }
1159:../uvc.c      **** 		 	 else{
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1161:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1162:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1163:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1164:../uvc.c      **** 		 	 }
1165:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1167:../uvc.c      **** 			  break;
1168:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1169:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1171:../uvc.c      **** 		 	 }
1172:../uvc.c      **** 		 	 else{
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1174:../uvc.c      **** 		 	 }
1175:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1176:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1177:../uvc.c      **** 			  Len = 1;
1178:../uvc.c      **** 			  break;
1179:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1180:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1181:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1182:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1183:../uvc.c      **** 		 	 }
1184:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1185:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1186:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1187:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1188:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1189:../uvc.c      **** 			 }else{
1190:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1191:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1192:../uvc.c      **** 			 }
1193:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1194:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1197:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1198:../uvc.c      **** 				  glEp0Buffer, &readCount);
1199:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1200:../uvc.c      **** 			   {
1201:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1202:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1203:../uvc.c      **** 				  getData = glEp0Buffer[0];
1204:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1205:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1206:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1207:../uvc.c      **** #endif
1208:../uvc.c      **** 				  switch(CtrlID)
1209:../uvc.c      **** 					 {
1210:../uvc.c      **** 						 case ExtShutCtlID0:
1211:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1212:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1213:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1214:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1215:../uvc.c      **** #if 1	// register setting directly
1216:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1217:../uvc.c      **** 						     {
1218:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1219:../uvc.c      **** 						    	 dataIdx = 0;
1220:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1221:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1222:../uvc.c      **** 								 dataIdx++;
1223:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1224:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1225:../uvc.c      **** 						     }
1226:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1227:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1228:../uvc.c      **** 						     break;
1229:../uvc.c      **** #else	// old fashion
1230:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1231:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1232:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1233:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1234:../uvc.c      **** 									 }else{
1235:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1236:../uvc.c      **** 									 }
1237:../uvc.c      **** 								 }
1238:../uvc.c      **** 							 }else{
1239:../uvc.c      **** 								 Data1 = Data0 - 1;
1240:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1241:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1242:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1243:../uvc.c      **** 									 }else{
1244:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1245:../uvc.c      **** 									 }
1246:../uvc.c      **** 								 }
1247:../uvc.c      **** 								 if(Data1 < 8){
1248:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1249:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1250:../uvc.c      **** 								 }else{
1251:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1252:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1253:../uvc.c      **** 								 }
1254:../uvc.c      **** 							 }
1255:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1256:../uvc.c      **** 							 dataIdx = 0;
1257:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1258:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1259:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1260:../uvc.c      **** 							 if(AxMode){
1261:../uvc.c      **** 								 dataIdx++;
1262:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1263:../uvc.c      **** 								 dataIdx++;
1264:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1265:../uvc.c      **** 							 }
1266:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1267:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1268:../uvc.c      **** 							 break;
1269:../uvc.c      **** #endif
1270:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1271:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1272:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1273:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1274:../uvc.c      **** 						     dataIdx = 0;
1275:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1276:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1277:../uvc.c      **** 							 {
1278:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1279:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1280:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1281:../uvc.c      **** 								 /*
1282:../uvc.c      **** 								 dataIdx++;
1283:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1284:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1285:../uvc.c      **** 									 dataIdx++;
1286:../uvc.c      **** 								 }else{
1287:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1288:../uvc.c      **** 									 dataIdx++;
1289:../uvc.c      **** 								 }
1290:../uvc.c      **** 								 */
1291:../uvc.c      **** 							 }
1292:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1293:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1294:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1295:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1296:../uvc.c      **** 								 }
1297:../uvc.c      **** 							 }
1298:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1299:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1301:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1302:../uvc.c      **** 							 break;
1303:../uvc.c      **** 
1304:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1305:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1306:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1307:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1308:../uvc.c      **** 						     dataIdx = 0;
1309:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1310:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1311:../uvc.c      **** 							 {
1312:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1313:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1314:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1315:../uvc.c      **** 								 dataIdx++;
1316:../uvc.c      **** 							 }
1317:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1318:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1319:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1320:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1321:../uvc.c      **** 									 dataIdx++;
1322:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1323:../uvc.c      **** 								 }
1324:../uvc.c      **** 							 }
1325:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1326:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1328:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1329:../uvc.c      **** 							 break;
1330:../uvc.c      **** 						 case ExtCamMCtlID12:
1331:../uvc.c      **** 							 dataIdx = 0;
1332:../uvc.c      **** 							 if(Data0 <= 3){
1333:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1334:../uvc.c      **** 								 Data1 = Data0;
1335:../uvc.c      **** 							 }else{
1336:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1337:../uvc.c      **** 								 Data1 = Data0-4;
1338:../uvc.c      **** 							 }
1339:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1340:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1341:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1342:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1343:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1344:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1345:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1346:../uvc.c      **** 							 break;
1347:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1348:../uvc.c      **** 							 dataIdx = 0;
1349:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1350:../uvc.c      **** 								 Data0 = 1;
1351:../uvc.c      **** 							 }else{ //save current sensor parameters.
1352:../uvc.c      **** 								 Data0 = 0;
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1355:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1356:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1357:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 						 case ExtI2CCtlID15:
1360:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1361:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1362:../uvc.c      **** 					 		 }
1363:../uvc.c      **** 					 		I2CCmdHandler();
1364:../uvc.c      **** 							 break;
1365:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1366:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1367:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1368:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1369:../uvc.c      **** 
1370:../uvc.c      **** 							 dataIdx = 0;
1371:../uvc.c      **** #if 0 //seperate version
1372:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1373:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1374:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1375:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1376:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1377:../uvc.c      **** 							 }else{ //disable BLD window
1378:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1379:../uvc.c      **** 							 }
1380:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1381:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1382:../uvc.c      **** 							 dataIdx++;
1383:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1384:../uvc.c      **** 							 dataIdx++;
1385:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1386:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1387:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1388:../uvc.c      **** 							 dataIdx++;
1389:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1390:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1391:../uvc.c      **** #else //combination version
1392:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1394:../uvc.c      **** 						     /* end test */
1395:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1396:../uvc.c      **** 							 dataIdx++;
1397:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1398:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1399:../uvc.c      **** 							 getData1 = Data1;
1400:../uvc.c      **** #endif
1401:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1402:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1403:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1404:../uvc.c      **** 							 break;
1405:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1406:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1407:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1408:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1409:../uvc.c      **** 
1410:../uvc.c      **** 							 dataIdx = 0;
1411:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1412:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1413:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1414:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1415:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1416:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1417:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1418:../uvc.c      **** 							 break;
1419:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1420:../uvc.c      **** 							 dataIdx = 0;
1421:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1422:../uvc.c      **** 							 if(Data0 == 1){
1423:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1424:../uvc.c      **** 							 }else{
1425:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1426:../uvc.c      **** 							 }
1427:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1428:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1429:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1430:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1431:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1432:../uvc.c      **** 							 break;
1433:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1434:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1435:../uvc.c      **** 							 dataIdx = 0;
1436:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1437:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1438:../uvc.c      **** 							  if(Data0&0x80){
1439:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1440:../uvc.c      **** 							  }else{
1441:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1442:../uvc.c      **** 							  }
1443:../uvc.c      **** 							 Data1 |= ~0x03;
1444:../uvc.c      **** 							 Data1 &= 0xC7;
1445:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1446:../uvc.c      **** 						  	 dataIdx++;
1447:../uvc.c      **** 
1448:../uvc.c      **** 							 Data0 = (Data0 << 2);
1449:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1450:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1451:../uvc.c      **** 
1452:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1453:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1455:../uvc.c      **** #endif
1456:../uvc.c      **** 							 dataIdx = 0;
1457:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1458:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1459:../uvc.c      **** 							  if(Data0&0x80){
1460:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1461:../uvc.c      **** 							  }else{
1462:../uvc.c      **** 								  Data0 = ~Data0;
1463:../uvc.c      **** 							  }
1464:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1466:../uvc.c      **** 
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1468:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1469:../uvc.c      **** 
1470:../uvc.c      **** 
1471:../uvc.c      **** 							 break;
1472:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1473:../uvc.c      **** 							 dataIdx = 0;
1474:../uvc.c      **** 
1475:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1476:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1477:../uvc.c      **** 							 dataIdx++;
1478:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1479:../uvc.c      **** 							 dataIdx++;
1480:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1481:../uvc.c      **** 							 dataIdx++;
1482:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1483:../uvc.c      **** 							 dataIdx++;
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1485:../uvc.c      **** 							 dataIdx++;
1486:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1487:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1488:../uvc.c      **** 
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1490:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1491:../uvc.c      **** 							 break;
1492:../uvc.c      **** 						 case SaturCtlID6:
1493:../uvc.c      **** 							 dataIdx = 0;
1494:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1495:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1496:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1497:../uvc.c      **** 							 dataIdx++;
1498:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1499:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1501:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1502:../uvc.c      **** 							 break;
1503:../uvc.c      **** 
1504:../uvc.c      **** 						 case WBTLevCtlID11:
1505:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1506:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1507:../uvc.c      **** 							 dataIdx = 0;
1508:../uvc.c      **** 
1509:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1510:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1511:../uvc.c      **** 							 dataIdx++;
1512:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1513:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1514:../uvc.c      **** 
1515:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1516:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1517:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1518:../uvc.c      **** 							 break;
1519:../uvc.c      **** 						 case MFreqCtlID4:
1520:../uvc.c      **** 							 dataIdx = 0;
1521:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1522:../uvc.c      **** 							 Data0 = Data0 - 1;
1523:../uvc.c      **** 							 is60Hz = Data0;
1524:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1525:../uvc.c      **** 							 {
1526:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1527:../uvc.c      **** 								 is60Hz = CyFalse;
1528:../uvc.c      **** 							 }
1529:../uvc.c      **** 							 else if(Data0 >2)
1530:../uvc.c      **** 							 {
1531:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1532:../uvc.c      **** 								 is60Hz = CyTrue;
1533:../uvc.c      **** 							 }
1534:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1535:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1536:../uvc.c      **** 							 {
1537:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1538:../uvc.c      **** 			                       switch (setRes)
1539:../uvc.c      **** 			                         {
1540:../uvc.c      **** 			                         	case 1: //1944
1541:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1542:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1543:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1544:../uvc.c      **** 			                         		break;
1545:../uvc.c      **** 			                         	case 2: //1080
1546:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1547:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1548:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1549:../uvc.c      **** 			                         		break;
1550:../uvc.c      **** 			                         	case 3: //720
1551:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1552:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1553:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1554:../uvc.c      **** 			                         		break;
1555:../uvc.c      **** 			                         	case 4: //VGA
1556:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1557:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1558:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1559:../uvc.c      **** 			                         	default:
1560:../uvc.c      **** 			                         		break;
1561:../uvc.c      **** 			                         }
1562:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1563:../uvc.c      **** 							 }
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1566:../uvc.c      **** 							 break;
1567:../uvc.c      **** 					 	 case BLCCtlID0:
1568:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1569:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1570:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1571:../uvc.c      **** 						     dataIdx = 0;
1572:../uvc.c      **** 
1573:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1574:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1575:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1576:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1577:../uvc.c      **** 
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1579:../uvc.c      **** 							 {
1580:../uvc.c      **** 								 if(Data0 < 3){
1581:../uvc.c      **** 					 				 Data0 += 4;
1582:../uvc.c      **** 					 			 }else{
1583:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1584:../uvc.c      **** 									Data0 = 4; //set to default.
1585:../uvc.c      **** 					 			 }
1586:../uvc.c      **** 					 		 }
1587:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1588:../uvc.c      **** 							 dataIdx = 0;
1589:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1590:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1591:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1592:../uvc.c      **** 
1593:../uvc.c      **** 					 		 break;
1594:../uvc.c      **** 					 	 case ShapCtlID7:
1595:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1596:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1597:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1598:../uvc.c      **** 						     dataIdx = 0;
1599:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1600:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1601:../uvc.c      **** 							 if(Data0 != 0){
1602:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1603:../uvc.c      **** #ifdef COLOR
1604:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1605:../uvc.c      **** #else
1606:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1607:../uvc.c      **** 								 dataIdx++;
1608:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1609:../uvc.c      **** #endif
1610:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1611:../uvc.c      **** 							 }else{
1612:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1613:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1614:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1615:../uvc.c      **** 
1616:../uvc.c      **** 							 }
1617:../uvc.c      **** 							 break;
1618:../uvc.c      **** 						 case ExtExRefCtlID10:
1619:../uvc.c      **** 						 case ConsCtlID2:
1620:../uvc.c      **** 							 dataIdx = 0;
1621:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1622:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1623:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1624:../uvc.c      **** 
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1626:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1627:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1628:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1629:../uvc.c      **** 
1630:../uvc.c      **** 							 break;
1631:../uvc.c      **** 						 default:
1632:../uvc.c      **** 							 dataIdx = 0;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1635:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1636:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1637:../uvc.c      **** 
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1640:../uvc.c      **** 							 break;
1641:../uvc.c      **** 					 }
1642:../uvc.c      **** 			   }else{
1643:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1644:../uvc.c      **** 			   }
1645:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1646:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1647:../uvc.c      **** #endif
1648:../uvc.c      **** 
1649:../uvc.c      **** 			  break;
1650:../uvc.c      **** 		  default:
1651:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1652:../uvc.c      **** 			  break;
1653:../uvc.c      **** 		 }
1654:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1655:../uvc.c      **** }
1656:../uvc.c      **** /************** CT control requests handler *************************/
1657:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1658:../uvc.c      **** 
1659:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1660:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1661:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1662:../uvc.c      ****     uint16_t readCount;
1663:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1664:../uvc.c      ****     uint16_t diff, value, diffRd;
1665:../uvc.c      ****     uint8_t i, shutter, index;
1666:../uvc.c      ****     diff = 0xffff;
1667:../uvc.c      ****     shutter = 1;
1668:../uvc.c      ****     index = 1;
1669:../uvc.c      **** 
1670:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1671:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1672:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1673:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1674:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1675:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1676:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1677:../uvc.c      **** #endif
1678:../uvc.c      ****     reqData = bRequest;
1679:../uvc.c      **** 
1680:../uvc.c      ****     switch (bRequest)
1681:../uvc.c      **** 		 {
1682:../uvc.c      **** 
1683:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1684:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1685:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1686:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1687:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1688:../uvc.c      **** 			  break;
1689:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1690:../uvc.c      **** 
1691:../uvc.c      **** 			 switch(CtrlID)
1692:../uvc.c      **** 			 {
1693:../uvc.c      **** 				 default:
1694:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1695:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1696:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1697:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1698:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1699:../uvc.c      **** 					 break;
1700:../uvc.c      **** 			 }
1701:../uvc.c      **** 
1702:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1703:../uvc.c      **** 
1704:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1705:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1706:../uvc.c      **** #endif
1707:../uvc.c      **** 			  break;
1708:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1709:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1710:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1711:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1712:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1713:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1714:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1715:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1716:../uvc.c      **** 			  break;
1717:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1718:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1719:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1720:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1721:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1722:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1723:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1724:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1725:../uvc.c      **** 			  break;
1726:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1727:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1728:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1729:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1730:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1731:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1732:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1733:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1734:../uvc.c      **** 			  break;
1735:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1736:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1737:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1738:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1739:../uvc.c      **** 			  Len = 1;
1740:../uvc.c      **** 			  break;
1741:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1742:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1743:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1744:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1745:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1746:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1747:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1748:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1749:../uvc.c      **** 			  break;
1750:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1751:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1752:../uvc.c      **** 			  glEp0Buffer, &readCount);
1753:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1754:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1755:../uvc.c      **** 			  value = Data1;
1756:../uvc.c      **** 
1757:../uvc.c      **** 			  switch(CtrlID)
1758:../uvc.c      **** 			  {
1759:../uvc.c      **** 		  	      case AutoExMCtlID1:
1760:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1761:../uvc.c      **** 
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1763:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1764:../uvc.c      **** 				    getData = glEp0Buffer[0];
1765:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1766:../uvc.c      **** 		  		    switch (getData){
1767:../uvc.c      **** 						case 1:
1768:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1769:../uvc.c      **** 							break;
1770:../uvc.c      **** 						case 2:
1771:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1772:../uvc.c      **** 							dataIdx = 0;
1773:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1774:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1775:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1776:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1777:../uvc.c      **** 
1778:../uvc.c      **** 							break;
1779:../uvc.c      **** 						case 4:
1780:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1781:../uvc.c      **** 							break;
1782:../uvc.c      **** 						case 8:
1783:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1784:../uvc.c      **** 			  		    	dataIdx = 0;
1785:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1786:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1787:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1788:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1789:../uvc.c      **** 							break;
1790:../uvc.c      **** 		  		    }
1791:../uvc.c      **** #if 0
1792:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1793:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1794:../uvc.c      **** 						  dataIdx = 0;
1795:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1796:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1797:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1798:../uvc.c      **** 		  		    }
1799:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1800:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1801:../uvc.c      **** 		  		    }
1802:../uvc.c      **** #endif
1803:../uvc.c      **** 				    break;
1804:../uvc.c      **** 
1805:../uvc.c      **** 			  	  case ExTmACtlID3:
1806:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1807:../uvc.c      **** 
1808:../uvc.c      **** 					  value = (value << 8)|Data0;
1809:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1810:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1811:../uvc.c      **** 					  {
1812:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1813:../uvc.c      **** 						  {
1814:../uvc.c      **** 							if(value > ShutValueArry[i]){
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1816:../uvc.c      **** 							}else{
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1818:../uvc.c      **** 							}
1819:../uvc.c      **** 							  if(diff > diffRd){
1820:../uvc.c      **** 								  diff = diffRd;
1821:../uvc.c      **** 								  index = i;
1822:../uvc.c      **** 							  }
1823:../uvc.c      **** 						  }
1824:../uvc.c      **** 						  shutter = shutter+index;
1825:../uvc.c      **** 
1826:../uvc.c      **** 						  dataIdx = 0;
1827:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1828:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1829:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1830:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1831:../uvc.c      **** 
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1834:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1835:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1836:../uvc.c      **** 					  }else{
1837:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1838:../uvc.c      **** 					  }
1839:../uvc.c      **** 					  getData = glEp0Buffer[0];
1840:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1841:../uvc.c      **** 					  break;
1842:../uvc.c      **** 			  	  case IriACtlID7:
1843:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1844:../uvc.c      **** 					  {
1845:../uvc.c      **** 							 dataIdx = 0;
1846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1849:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1850:../uvc.c      **** 
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1853:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1854:../uvc.c      **** 					  }else{
1855:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1856:../uvc.c      **** 					  }
1857:../uvc.c      **** 					  getData = glEp0Buffer[0];
1858:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1859:../uvc.c      **** 
1860:../uvc.c      **** 					  break;
1861:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1862:../uvc.c      **** 					  getData = glEp0Buffer[0];
1863:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1864:../uvc.c      **** #if 1
1865:../uvc.c      **** 					  dataIdx = 0;
1866:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1867:../uvc.c      **** 					  if(getData == 1)
1868:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1869:../uvc.c      **** 					  else if(getData == 0xff)
1870:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1871:../uvc.c      **** 					  else
1872:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1873:../uvc.c      **** 					  //dataIdx++;
1874:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1875:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1876:../uvc.c      **** #endif
1877:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1878:../uvc.c      **** 					  break;
1879:../uvc.c      **** 
1880:../uvc.c      **** 			  	  default:
1881:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1882:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1883:../uvc.c      **** 			  		 break;
1884:../uvc.c      **** 			  }
1885:../uvc.c      **** 			  break;
1886:../uvc.c      **** 		  default:
1887:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1888:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1889:../uvc.c      **** 			  break;
1890:../uvc.c      **** 		 }
1891:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1892:../uvc.c      **** 
1893:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1894:../uvc.c      **** }
1895:../uvc.c      **** 
1896:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1897:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1898:../uvc.c      **** {
1899:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1900:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1901:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1902:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1903:../uvc.c      **** 
1904:../uvc.c      ****     CtrlID = BrgtCtlID1;
1905:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1906:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1907:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1908:../uvc.c      ****     Data1 = Data0;
1909:../uvc.c      **** 
1910:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1911:../uvc.c      ****     if(Data1&0x80){
1912:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1913:../uvc.c      ****     }else{
1914:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1915:../uvc.c      ****     }
1916:../uvc.c      ****     Data0 = (Data0 << 2);
1917:../uvc.c      **** 
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1919:../uvc.c      **** 
1920:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1921:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1922:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1923:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1924:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1925:../uvc.c      **** 
1926:../uvc.c      ****     CtrlID = ConsCtlID2;
1927:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1928:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1929:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1930:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1931:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1932:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1933:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1934:../uvc.c      **** 
1935:../uvc.c      ****     CtrlID = HueCtlID5;
1936:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1937:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1938:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1944:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1945:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1946:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1947:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1948:../uvc.c      **** 
1949:../uvc.c      ****     CtrlID = SaturCtlID6;
1950:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1951:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1952:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1953:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1954:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1955:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1956:../uvc.c      **** 
1957:../uvc.c      ****     CtrlID = ShapCtlID7;
1958:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1959:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1960:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1961:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1962:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1963:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1964:../uvc.c      **** 
1965:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
1966:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1967:../uvc.c      **** 	return;
1968:../uvc.c      **** }
1969:../uvc.c      **** 
1970:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1971:../uvc.c      **** void
1972:../uvc.c      **** CyFxUVCAddHeader (
1973:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1974:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1975:../uvc.c      ****         )
1976:../uvc.c      **** {
1977:../uvc.c      ****     /* Copy header to buffer */
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1980:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1981:../uvc.c      **** 
1982:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1983:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1984:../uvc.c      ****     {
1985:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1986:../uvc.c      ****     }
1987:../uvc.c      **** }
1988:../uvc.c      **** 
1989:../uvc.c      **** 
1990:../uvc.c      **** /* Application Error Handler */
1991:../uvc.c      **** void
1992:../uvc.c      **** CyFxAppErrorHandler (
1993:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1994:../uvc.c      ****         )
1995:../uvc.c      **** {
1996:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1997:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1998:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1999:../uvc.c      **** 
2000:../uvc.c      ****        This function can be modified to take additional error handling actions such
2001:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2002:../uvc.c      ****      */
2003:../uvc.c      ****     for (;;)
2004:../uvc.c      ****     {
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
2007:../uvc.c      ****     }
2008:../uvc.c      **** }
2009:../uvc.c      **** 
2010:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2011:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2012:../uvc.c      ****  */
2013:../uvc.c      **** static void
2014:../uvc.c      **** CyFxUVCApplnAbortHandler (
2015:../uvc.c      ****         void)
2016:../uvc.c      **** {
2017:../uvc.c      **** 	uint32_t flag;
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2019:../uvc.c      **** 	{
2020:../uvc.c      ****         /* Clear the Video Stream Request Event */
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2022:../uvc.c      **** 
2023:../uvc.c      ****         /* Set Video Stream Abort Event */
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2025:../uvc.c      **** 	}
2026:../uvc.c      **** }
2027:../uvc.c      **** 
2028:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2029:../uvc.c      **** static void
2030:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2031:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2032:../uvc.c      ****         uint16_t             evdata  /* Event data */
2033:../uvc.c      ****         )
2034:../uvc.c      **** {
2035:../uvc.c      ****     switch (evtype)
2036:../uvc.c      ****     {
2037:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2038:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2039:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2040:../uvc.c      ****             gpif_initialized = 0;
2041:../uvc.c      ****             streamingStarted = CyFalse;
2042:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2043:../uvc.c      ****             break;
2044:../uvc.c      **** 
2045:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2046:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2047:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2048:../uvc.c      ****             gpif_initialized = 0;
2049:../uvc.c      ****             streamingStarted = CyFalse;
2050:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2051:../uvc.c      ****             break;
2052:../uvc.c      **** 
2053:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2054:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2055:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2056:../uvc.c      ****             gpif_initialized = 0;
2057:../uvc.c      ****             isUsbConnected = CyFalse;
2058:../uvc.c      ****             streamingStarted = CyFalse;
2059:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2060:../uvc.c      ****             break;
2061:../uvc.c      **** 
2062:../uvc.c      **** #ifdef BACKFLOW_DETECT
2063:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2064:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2065:../uvc.c      ****             break;
2066:../uvc.c      **** #endif
2067:../uvc.c      **** 
2068:../uvc.c      ****         default:
2069:../uvc.c      ****             break;
2070:../uvc.c      ****     }
2071:../uvc.c      **** }
2072:../uvc.c      **** 
2073:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2074:../uvc.c      **** static CyBool_t
2075:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2076:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2077:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2078:../uvc.c      ****         )
2079:../uvc.c      **** {
2080:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2081:../uvc.c      ****     uint32_t status;
2082:../uvc.c      **** 
2083:../uvc.c      ****     /* Obtain Request Type and Request */
2084:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2086:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2088:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2089:../uvc.c      **** 
2090:../uvc.c      ****     /* Check for UVC Class Requests */
2091:../uvc.c      ****     switch (bmReqType)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2094:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2095:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2096:../uvc.c      ****             switch (wIndex & 0xFF)
2097:../uvc.c      ****             {
2098:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2099:../uvc.c      ****                     {
2100:../uvc.c      ****                         uvcHandleReq = CyTrue;
2101:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2102:../uvc.c      ****                                 CYU3P_EVENT_OR);
2103:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2104:../uvc.c      ****                         {
2105:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2106:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2107:../uvc.c      ****                         }
2108:../uvc.c      ****                     }
2109:../uvc.c      ****                     break;
2110:../uvc.c      **** 
2111:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2112:../uvc.c      ****                     {
2113:../uvc.c      ****                         uvcHandleReq = CyTrue;
2114:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2115:../uvc.c      ****                                 CYU3P_EVENT_OR);
2116:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2117:../uvc.c      ****                         {
2118:../uvc.c      ****                             /* Error handling */
2119:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2120:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2121:../uvc.c      ****                         }
2122:../uvc.c      ****                     }
2123:../uvc.c      ****                     break;
2124:../uvc.c      **** 
2125:../uvc.c      ****                 default:
2126:../uvc.c      ****                     break;
2127:../uvc.c      ****             }
2128:../uvc.c      ****             break;
2129:../uvc.c      **** 
2130:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2131:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2132:../uvc.c      ****             {
2133:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2134:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2135:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2136:../uvc.c      ****                 {
2137:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2138:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2139:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2140:../uvc.c      ****                     gpif_initialized = 0;
2141:../uvc.c      ****                     streamingStarted = CyFalse;
2142:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2143:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2144:../uvc.c      ****                     CyU3PBusyWait (100);
2145:../uvc.c      **** 
2146:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2147:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2148:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2149:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2150:../uvc.c      ****                     CyU3PBusyWait (100);
2151:../uvc.c      **** 
2152:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2153:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2154:../uvc.c      ****                     uvcHandleReq = CyTrue;
2155:../uvc.c      ****                     /* Complete Control request handshake */
2156:../uvc.c      ****                     CyU3PUsbAckSetup ();
2157:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2158:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2159:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2160:../uvc.c      **** 
2161:../uvc.c      ****                 }
2162:../uvc.c      ****             }
2163:../uvc.c      ****             break;
2164:../uvc.c      **** 
2165:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2166:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2167:../uvc.c      ****             {
2168:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2169:../uvc.c      ****                 {
2170:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2171:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2172:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2173:../uvc.c      ****                 	 * has started. */
2174:../uvc.c      ****                     if (streamingStarted == CyTrue)
2175:../uvc.c      ****                     {
2176:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2177:../uvc.c      **** 
2178:../uvc.c      ****                         /* Disable the GPIF state machine. */
2179:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2180:../uvc.c      ****                         gpif_initialized = 0;
2181:../uvc.c      ****                         streamingStarted = CyFalse;
2182:../uvc.c      **** 
2183:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2184:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2185:../uvc.c      ****                         CyU3PBusyWait (100);
2186:../uvc.c      **** 
2187:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2188:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2189:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2190:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2191:../uvc.c      ****                         CyU3PBusyWait (100);
2192:../uvc.c      **** 
2193:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2194:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2195:../uvc.c      **** 
2196:../uvc.c      ****                         uvcHandleReq = CyTrue;
2197:../uvc.c      ****                         /* Complete Control request handshake */
2198:../uvc.c      ****                         CyU3PUsbAckSetup ();
2199:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2200:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2201:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2202:../uvc.c      ****                     }
2203:../uvc.c      ****                     else
2204:../uvc.c      ****                     {
2205:../uvc.c      ****                         uvcHandleReq = CyTrue;
2206:../uvc.c      ****                         CyU3PUsbAckSetup ();
2207:../uvc.c      ****                     }
2208:../uvc.c      ****                 }
2209:../uvc.c      ****             }
2210:../uvc.c      ****             break;
2211:../uvc.c      **** 
2212:../uvc.c      ****         default:
2213:../uvc.c      ****             break;
2214:../uvc.c      ****     }
2215:../uvc.c      **** 
2216:../uvc.c      ****     /* Return status of request handling to the USB driver */
2217:../uvc.c      ****     return uvcHandleReq;
2218:../uvc.c      **** }
2219:../uvc.c      **** 
2220:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2221:../uvc.c      **** 
2222:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2223:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2224:../uvc.c      ****  */
2225:../uvc.c      **** void
2226:../uvc.c      **** CyFxUvcApplnDmaCallback (
2227:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2228:../uvc.c      ****         CyU3PDmaCbType_t      type,
2229:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2230:../uvc.c      ****         )
2231:../uvc.c      **** {
2232:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2233:../uvc.c      **** #if 1
2234:../uvc.c      ****     CyU3PReturnStatus_t status;
2235:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2236:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2237:../uvc.c      **** 
2238:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2239:../uvc.c      ****     {
2240:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2241:../uvc.c      ****             {
2242:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2243:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2244:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2245:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2246:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2247:../uvc.c      ****                 	stiflag = 0x03;
2248:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2249:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2250:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2251:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2252:../uvc.c      ****                 }
2253:../uvc.c      **** #endif
2254:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2255:../uvc.c      ****                 fb++;
2256:../uvc.c      ****             }
2257:../uvc.c      ****             else
2258:../uvc.c      ****             {
2259:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2260:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2261:../uvc.c      ****                 pb++;
2262:../uvc.c      ****                 pbc = input->buffer_p.count;
2263:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2264:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2265:../uvc.c      ****                 //lineCount = 0; //res test
2266:../uvc.c      **** #if 1   //remove the still flag clearing here
2267:../uvc.c      ****                 if(stiflag == 0x0F){
2268:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2269:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2270:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2271:../uvc.c      ****                 	stiflag = 0xAA;
2272:../uvc.c      ****                 }
2273:../uvc.c      **** #endif
2274:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2275:../uvc.c      ****             }
2276:../uvc.c      **** 
2277:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2278:../uvc.c      ****             prodCount++;
2279:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2280:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2281:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2282:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2283:../uvc.c      ****             {
2284:../uvc.c      ****                 prodCount--;
2285:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2286:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2287:../uvc.c      ****             }
2288:../uvc.c      ****     }
2289:../uvc.c      **** #endif
2290:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2291:../uvc.c      ****     {
2292:../uvc.c      ****         consCount++;
2293:../uvc.c      ****         streamingStarted = CyTrue;
2294:../uvc.c      ****     }
2295:../uvc.c      **** }
2296:../uvc.c      **** 
2297:../uvc.c      **** /*
2298:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2299:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2300:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2301:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2302:../uvc.c      ****  * to commit the buffer.
2303:../uvc.c      ****  */
2304:../uvc.c      **** static uint8_t
2305:../uvc.c      **** CyFxUvcAppCommitEOF (
2306:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2307:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2308:../uvc.c      ****         )
2309:../uvc.c      **** {
2310:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2311:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2312:../uvc.c      **** 
2313:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2314:../uvc.c      **** 
2315:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2316:../uvc.c      ****     {
2317:../uvc.c      ****         switch (stateId)
2318:../uvc.c      ****         {
2319:../uvc.c      **** 
2320:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2321:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2322:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2323:../uvc.c      ****                 break;
2324:../uvc.c      **** 
2325:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2326:../uvc.c      ****                 socket = 0;
2327:../uvc.c      ****                 break;
2328:../uvc.c      **** 
2329:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2330:../uvc.c      ****                 socket = 1;
2331:../uvc.c      ****                 break;
2332:../uvc.c      **** 
2333:../uvc.c      ****             default:
2334:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2335:../uvc.c      ****                 /* Unexpected current state. Return error. */
2336:../uvc.c      ****             	//lineCount++;
2337:../uvc.c      ****             	return 1;
2338:../uvc.c      ****         }
2339:../uvc.c      ****     }
2340:../uvc.c      **** 
2341:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2342:../uvc.c      ****     {
2343:../uvc.c      ****         switch (stateId)
2344:../uvc.c      ****         {
2345:../uvc.c      **** #ifndef CAM720
2346:../uvc.c      **** #ifdef GPIFIIM
2347:../uvc.c      ****             case 13:
2348:../uvc.c      ****             case 24:
2349:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2350:../uvc.c      ****                 break;
2351:../uvc.c      **** 
2352:../uvc.c      ****             case 8:
2353:../uvc.c      ****                 socket = 0;
2354:../uvc.c      ****                 break;
2355:../uvc.c      **** 
2356:../uvc.c      ****             case 20:
2357:../uvc.c      ****                 socket = 1;
2358:../uvc.c      ****                 break;
2359:../uvc.c      **** #else
2360:../uvc.c      ****             case 11:
2361:../uvc.c      ****             case 18:
2362:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2363:../uvc.c      ****                 break;
2364:../uvc.c      **** 
2365:../uvc.c      ****             case 8:
2366:../uvc.c      ****                 socket = 0;
2367:../uvc.c      ****                 break;
2368:../uvc.c      **** 
2369:../uvc.c      ****             case 15:
2370:../uvc.c      ****                 socket = 1;
2371:../uvc.c      ****                 break;
2372:../uvc.c      **** #endif
2373:../uvc.c      **** #else
2374:../uvc.c      ****             case 11:
2375:../uvc.c      ****             case 18:
2376:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2377:../uvc.c      ****                 break;
2378:../uvc.c      **** 
2379:../uvc.c      ****             case 8:
2380:../uvc.c      ****                 socket = 0;
2381:../uvc.c      ****                 break;
2382:../uvc.c      **** 
2383:../uvc.c      ****             case 15:
2384:../uvc.c      ****                 socket = 1;
2385:../uvc.c      ****                 break;
2386:../uvc.c      **** 
2387:../uvc.c      **** #endif
2388:../uvc.c      ****              default:
2389:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2390:../uvc.c      ****                 /* Unexpected current state. Return error. */
2391:../uvc.c      ****                return 1;
2392:../uvc.c      ****         }
2393:../uvc.c      ****     }
2394:../uvc.c      **** 
2395:../uvc.c      ****     if (socket != 0xFF)
2396:../uvc.c      ****     {
2397:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2398:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2399:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2400:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2401:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2402:../uvc.c      ****         {
2403:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2404:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2405:../uvc.c      ****         }
2406:../uvc.c      ****     }
2407:../uvc.c      **** 
2408:../uvc.c      ****     return 0;
2409:../uvc.c      **** }
2410:../uvc.c      **** 
2411:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2412:../uvc.c      **** void
2413:../uvc.c      **** CyFxGpifCB (
2414:../uvc.c      ****         CyU3PGpifEventType event,
2415:../uvc.c      ****         uint8_t currentState
2416:../uvc.c      ****         )
2417:../uvc.c      **** {
2418:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2419:../uvc.c      ****     {
2420:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2421:../uvc.c      ****     	           in the UVC implementation. */
2422:../uvc.c      ****     	//hitFV = CyTrue;
2423:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2424:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2425:../uvc.c      ****     }
2426:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2427:../uvc.c      **** }
2428:../uvc.c      **** 
2429:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2430:../uvc.c      **** static void
2431:../uvc.c      **** CyFxUVCApplnDebugInit (
2432:../uvc.c      ****         void)
2433:../uvc.c      **** {
2434:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2435:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2436:../uvc.c      **** 
2437:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2438:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2440:../uvc.c      ****     {
2441:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2443:../uvc.c      ****     }
2444:../uvc.c      **** 
2445:../uvc.c      ****     /* Set UART Configuration */
2446:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2447:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2448:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2449:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2450:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2451:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2452:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2453:../uvc.c      **** 
2454:../uvc.c      ****     /* Set the UART configuration */
2455:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2456:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2457:../uvc.c      ****     {
2458:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2459:../uvc.c      ****     }
2460:../uvc.c      **** 
2461:../uvc.c      ****     /* Set the UART transfer */
2462:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2463:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2464:../uvc.c      ****     {
2465:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2466:../uvc.c      ****     }
2467:../uvc.c      **** 
2468:../uvc.c      ****     /* Initialize the Debug logger module. */
2469:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2470:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2471:../uvc.c      ****     {
2472:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2473:../uvc.c      ****     }
2474:../uvc.c      **** 
2475:../uvc.c      ****     /* Disable log message headers. */
2476:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2477:../uvc.c      **** }
2478:../uvc.c      **** 
2479:../uvc.c      **** /* I2C initialization. */
2480:../uvc.c      **** static void
2481:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2482:../uvc.c      **** {
2483:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2484:../uvc.c      ****     CyU3PReturnStatus_t status;
2485:../uvc.c      **** 
2486:../uvc.c      ****     status = CyU3PI2cInit ();
2487:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2488:../uvc.c      ****     {
2489:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2490:../uvc.c      ****         CyFxAppErrorHandler (status);
2491:../uvc.c      ****     }
2492:../uvc.c      **** 
2493:../uvc.c      ****     /*  Set I2C Configuration */
2494:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2495:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2496:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2497:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2498:../uvc.c      **** 
2499:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2500:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2501:../uvc.c      ****     {
2502:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2503:../uvc.c      ****         CyFxAppErrorHandler (status);
2504:../uvc.c      ****     }
2505:../uvc.c      **** }
2506:../uvc.c      **** 
2507:../uvc.c      **** #ifdef BACKFLOW_DETECT
2508:../uvc.c      **** static void CyFxUvcAppPibCallback (
2509:../uvc.c      ****         CyU3PPibIntrType cbType,
2510:../uvc.c      ****         uint16_t cbArg)
2511:../uvc.c      **** {
2512:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2513:../uvc.c      ****     {
2514:../uvc.c      ****         if (!back_flow_detected)
2515:../uvc.c      ****         {
2516:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2517:../uvc.c      ****             back_flow_detected = 1;
2518:../uvc.c      ****         }
2519:../uvc.c      ****     }
2520:../uvc.c      **** }
2521:../uvc.c      **** #endif
2522:../uvc.c      **** 
2523:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2524:../uvc.c      **** static void
2525:../uvc.c      **** CyFxUvcAppDebugCallback (
2526:../uvc.c      ****         CyU3PDmaChannel   *handle,
2527:../uvc.c      ****         CyU3PDmaCbType_t   type,
2528:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2529:../uvc.c      **** {
2530:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2531:../uvc.c      ****     {
2532:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2533:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2534:../uvc.c      ****     }
2535:../uvc.c      **** }
2536:../uvc.c      **** #endif
2537:../uvc.c      **** 
2538:../uvc.c      **** #if 0
2539:../uvc.c      **** static void CyFxAppIntEpCb(
2540:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2541:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2542:../uvc.c      **** 		uint8_t  ebNum)
2543:../uvc.c      **** 		{
2544:../uvc.c      **** 			//CyBool_t value;
2545:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2546:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2547:../uvc.c      **** 
2548:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2549:../uvc.c      **** 		}
2550:../uvc.c      **** #endif
2551:../uvc.c      **** 
2552:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2553:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2554:../uvc.c      ****    configures the DMA module for the UVC Application */
2555:../uvc.c      **** static void
2556:../uvc.c      **** CyFxUVCApplnInit (void)
2557:../uvc.c      **** {
2558:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2559:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2560:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2561:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2562:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2563:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2564:../uvc.c      **** 
2565:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2566:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2567:../uvc.c      **** 
2568:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2569:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2570:../uvc.c      **** #endif
2571:../uvc.c      **** 
2572:../uvc.c      ****     /* Create UVC event group */
2573:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2574:../uvc.c      ****     if (apiRetStatus != 0)
2575:../uvc.c      ****     {
2576:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2577:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2578:../uvc.c      ****     }
2579:../uvc.c      **** 
2580:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2581:../uvc.c      ****     CyFxUvcAppPTZInit ();
2582:../uvc.c      **** #endif
2583:../uvc.c      **** 
2584:../uvc.c      ****     isUsbConnected = CyFalse;
2585:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2586:../uvc.c      **** 
2587:../uvc.c      ****     /* Init the GPIO module */
2588:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2589:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2590:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2591:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2592:../uvc.c      ****     gpioClock.halfDiv    = 0;
2593:../uvc.c      **** 
2594:../uvc.c      ****     /* Initialize Gpio interface */
2595:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2596:../uvc.c      ****     if (apiRetStatus != 0)
2597:../uvc.c      ****     {
2598:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2599:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2600:../uvc.c      ****     }
2601:../uvc.c      **** 
2602:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2603:../uvc.c      ****      * must use GpioOverride to configure it */
2604:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2605:../uvc.c      ****     if (apiRetStatus != 0)
2606:../uvc.c      ****     {
2607:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2608:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2609:../uvc.c      ****     }
2610:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2611:../uvc.c      ****     if (apiRetStatus != 0)
2612:../uvc.c      ****     {
2613:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2614:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2615:../uvc.c      ****     }
2616:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2617:../uvc.c      ****     if (apiRetStatus != 0)
2618:../uvc.c      ****     {
2619:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2620:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2621:../uvc.c      ****     }
2622:../uvc.c      **** 
2623:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2624:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2625:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2626:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2627:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2628:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2629:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2630:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2631:../uvc.c      ****     {
2632:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2633:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2634:../uvc.c      ****     }
2635:../uvc.c      **** 
2636:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2637:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2638:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2639:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2640:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2641:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2642:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2643:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2644:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2651:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2652:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2653:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2654:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2655:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2656:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2657:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2658:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2659:../uvc.c      ****     {
2660:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2661:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2662:../uvc.c      ****     }
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize the P-port. */
2665:../uvc.c      ****     pibclock.clkDiv      = 2;
2666:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2667:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2668:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2669:../uvc.c      **** 
2670:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2672:../uvc.c      ****     {
2673:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2674:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2675:../uvc.c      ****     }
2676:../uvc.c      **** 
2677:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2678:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2679:../uvc.c      **** 
2680:../uvc.c      **** #ifdef BACKFLOW_DETECT
2681:../uvc.c      ****     back_flow_detected = 0;
2682:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2683:../uvc.c      **** #endif
2684:../uvc.c      **** 
2685:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2686:../uvc.c      ****     SensorReset ();
2687:../uvc.c      ****     CyU3PThreadSleep(5000);
2688:../uvc.c      ****     //SensorInit ();
2689:../uvc.c      **** 
2690:../uvc.c      ****     /* USB initialization. */
2691:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2692:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2693:../uvc.c      ****     {
2694:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2695:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2696:../uvc.c      ****     }
2697:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2698:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2699:../uvc.c      **** 
2700:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2701:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2702:../uvc.c      **** 
2703:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2704:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2707:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2708:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2709:../uvc.c      **** 
2710:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2711:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2712:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2713:../uvc.c      **** 
2714:../uvc.c      ****     /* Configuration descriptors. */
2715:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2716:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2717:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2718:../uvc.c      **** 
2719:../uvc.c      ****     /* String Descriptors */
2720:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2721:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2722:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2723:../uvc.c      **** 
2724:../uvc.c      ****     /* Configure the status interrupt endpoint.
2725:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2726:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2727:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2728:../uvc.c      ****      */
2729:../uvc.c      ****     endPointConfig.enable   = 1;
2730:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2731:../uvc.c      ****     endPointConfig.pcktSize = 64;
2732:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2733:../uvc.c      ****     endPointConfig.streams  = 0;
2734:../uvc.c      ****     endPointConfig.burstLen = 1;
2735:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2736:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2737:../uvc.c      ****     {
2738:../uvc.c      ****         /* Error Handling */
2739:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2740:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2741:../uvc.c      ****     }
2742:../uvc.c      **** 
2743:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2744:../uvc.c      ****     dmaInterConfig.size           = 1024;
2745:../uvc.c      ****     dmaInterConfig.count          = 1;
2746:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2747:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2748:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2749:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2750:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2751:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2752:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2753:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2754:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2755:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2756:../uvc.c      ****             &dmaInterConfig);
2757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2758:../uvc.c      ****     {
2759:../uvc.c      ****         /* Error handling */
2760:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2761:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2762:../uvc.c      ****     }
2763:../uvc.c      **** 
2764:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2765:../uvc.c      ****     if (glInterStaBuffer == 0)
2766:../uvc.c      ****     {
2767:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2768:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2769:../uvc.c      ****     }
2770:../uvc.c      **** 
2771:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2772:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2773:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2774:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2775:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2776:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2777:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2778:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2779:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2780:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2781:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2782:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2783:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2784:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2785:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2786:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2787:../uvc.c      ****             &dmaMultiConfig);
2788:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2789:../uvc.c      ****     {
2790:../uvc.c      ****         /* Error handling */
2791:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2792:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2793:../uvc.c      ****     }
2794:../uvc.c      **** 
2795:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2796:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2797:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2798:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2799:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2800:../uvc.c      ****      */
2801:../uvc.c      **** 
2802:../uvc.c      ****     endPointConfig.enable   = 1;
2803:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2804:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2805:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2806:../uvc.c      ****     endPointConfig.streams  = 0;
2807:../uvc.c      ****     endPointConfig.burstLen = 1;
2808:../uvc.c      **** 
2809:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2810:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2811:../uvc.c      ****     {
2812:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2813:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2814:../uvc.c      ****     }
2815:../uvc.c      **** 
2816:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2817:../uvc.c      **** 
2818:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2819:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2820:../uvc.c      ****     {
2821:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2822:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2823:../uvc.c      ****     }
2824:../uvc.c      **** 
2825:../uvc.c      ****     channelConfig.size           = 1024;
2826:../uvc.c      ****     channelConfig.count          = 1;
2827:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2828:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2829:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2830:../uvc.c      ****     channelConfig.prodHeader     = 0;
2831:../uvc.c      ****     channelConfig.prodFooter     = 0;
2832:../uvc.c      ****     channelConfig.consHeader     = 0;
2833:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2834:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2835:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2836:../uvc.c      **** 
2837:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2838:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2839:../uvc.c      ****     {
2840:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2841:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2842:../uvc.c      ****     }
2843:../uvc.c      **** 
2844:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2845:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2846:../uvc.c      ****     {
2847:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2848:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2849:../uvc.c      ****     }
2850:../uvc.c      **** 
2851:../uvc.c      ****     channelConfig.size           = 1024;
2852:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2853:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2854:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2855:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2856:../uvc.c      ****     channelConfig.prodHeader     = 0;
2857:../uvc.c      ****     channelConfig.prodFooter     = 0;
2858:../uvc.c      ****     channelConfig.consHeader     = 0;
2859:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2860:../uvc.c      ****     channelConfig.notification   = 0;
2861:../uvc.c      ****     channelConfig.cb             = 0;
2862:../uvc.c      **** 
2863:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2864:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2865:../uvc.c      ****     {
2866:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2867:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2868:../uvc.c      ****     }
2869:../uvc.c      **** 
2870:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2871:../uvc.c      ****     if (glDebugRspBuffer == 0)
2872:../uvc.c      ****     {
2873:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2874:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2875:../uvc.c      ****     }
2876:../uvc.c      **** #endif
2877:../uvc.c      **** 
2878:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2879:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PBusyWait(100);
2887:../uvc.c      **** 
2888:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2889:../uvc.c      **** 
2890:../uvc.c      ****     endPointConfig.enable   = 1;
2891:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2892:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2893:../uvc.c      ****     {
2894:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2895:../uvc.c      ****     	endPointConfig.burstLen = 16;
2896:../uvc.c      ****     }
2897:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2898:../uvc.c      ****     {
2899:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2900:../uvc.c      ****     	endPointConfig.burstLen = 1;
2901:../uvc.c      ****     }
2902:../uvc.c      ****     endPointConfig.streams  = 0;
2903:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2904:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2905:../uvc.c      ****     {
2906:../uvc.c      ****         /* Error Handling */
2907:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2909:../uvc.c      ****     }
2910:../uvc.c      **** #if 0    //for still image method 3 using
2911:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2912:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2913:../uvc.c      ****     {
2914:../uvc.c      ****         /* Error Handling */
2915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2917:../uvc.c      ****     }
2918:../uvc.c      **** #endif
2919:../uvc.c      **** 
2920:../uvc.c      **** }
2921:../uvc.c      **** 
2922:../uvc.c      **** /*
2923:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2924:../uvc.c      ****  * streaming session is started.
2925:../uvc.c      ****  */
2926:../uvc.c      **** static void
2927:../uvc.c      **** CyFxUvcAppGpifInit (
2928:../uvc.c      ****         void)
2929:../uvc.c      **** {
2930:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2931:../uvc.c      **** 
2932:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2933:../uvc.c      ****     {
2934:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2935:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2936:../uvc.c      ****     }
2937:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2938:../uvc.c      ****     {
2939:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2940:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2941:../uvc.c      ****     }
2942:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2943:../uvc.c      ****     {
2944:../uvc.c      ****         /* Error Handling */
2945:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2946:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2947:../uvc.c      ****     }
2948:../uvc.c      **** 
2949:../uvc.c      ****     /* Start the state machine from the designated start state. */
2950:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2951:../uvc.c      ****     {
2952:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2953:../uvc.c      ****     }
2954:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2955:../uvc.c      ****     {
2956:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2957:../uvc.c      ****     }
2958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2959:../uvc.c      ****     {
2960:../uvc.c      ****         /* Error Handling */
2961:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2962:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2963:../uvc.c      ****     }
2964:../uvc.c      **** }
2965:../uvc.c      **** 
2966:../uvc.c      **** /*
2967:../uvc.c      ****  * Entry function for the UVC Application Thread
2968:../uvc.c      ****  */
2969:../uvc.c      **** 
2970:../uvc.c      **** uint32_t posTick;
2971:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2972:../uvc.c      **** 
2973:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2974:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2975:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2976:../uvc.c      **** }
2977:../uvc.c      **** 
2978:../uvc.c      **** 
2979:../uvc.c      **** void
2980:../uvc.c      **** UVCAppThread_Entry (
2981:../uvc.c      ****         uint32_t input)
2982:../uvc.c      **** {
2983:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2984:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2985:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2986:../uvc.c      ****     uint8_t i = 0;
2987:../uvc.c      ****     uint32_t flag;
2988:../uvc.c      ****     uint32_t prinflag = 0;
2989:../uvc.c      **** static uint8_t IMcount = 0;
2990:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2991:../uvc.c      ****     uint32_t frameCnt = 0;
2992:../uvc.c      **** #endif
2993:../uvc.c      ****     /* Initialize the Uart Debug Module */
2994:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2995:../uvc.c      **** 
2996:../uvc.c      ****     /* Initialize the I2C interface */
2997:../uvc.c      **** 	while (i++ < 6){
2998:../uvc.c      **** 		CyU3PThreadSleep(500);
2999:../uvc.c      **** 	}
3000:../uvc.c      **** 
3001:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3002:../uvc.c      **** 
3003:../uvc.c      ****     /* Initialize the UVC Application */
3004:../uvc.c      ****     CyFxUVCApplnInit ();
3005:../uvc.c      ****     /*
3006:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3007:../uvc.c      **** 
3008:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3009:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3010:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3011:../uvc.c      **** 
3012:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3013:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3014:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3015:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3016:../uvc.c      **** 
3017:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3018:../uvc.c      ****        of handling the abort request.
3019:../uvc.c      ****      */
3020:../uvc.c      **** 
3021:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3022:../uvc.c      ****     //CyU3PThreadSleep(1000);
3023:../uvc.c      **** 
3024:../uvc.c      ****     for (;;)
3025:../uvc.c      ****     {
3026:../uvc.c      ****         /* Waiting for the Video Stream Event */
3027:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3028:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3029:../uvc.c      ****         {
3030:../uvc.c      **** #if 0 //test for new firmware no video bring up
3031:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3032:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3033:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3034:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3035:../uvc.c      ****             {
3036:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3037:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3038:../uvc.c      ****                 {
3039:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3040:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3041:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3042:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3043:../uvc.c      **** #endif
3044:../uvc.c      **** #endif
3045:../uvc.c      ****                     }
3046:../uvc.c      ****                 else
3047:../uvc.c      ****                 {
3048:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3049:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3050:../uvc.c      **** #ifdef USB_LOWRES_IMG
3051:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3052:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3053:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3054:../uvc.c      **** #endif
3055:../uvc.c      **** #endif
3056:../uvc.c      ****                 }
3057:../uvc.c      **** 
3058:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3059:../uvc.c      ****                 prodCount++;
3060:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3061:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3062:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3063:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3064:../uvc.c      ****                 {
3065:../uvc.c      ****                     prodCount--;
3066:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3067:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3068:../uvc.c      ****                 }
3069:../uvc.c      ****             }
3070:../uvc.c      **** #endif
3071:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3072:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3073:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3074:../uvc.c      ****             {
3075:../uvc.c      ****             	if(0&&(prinflag == 0)){
3076:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3077:../uvc.c      ****             		prinflag = 1;
3078:../uvc.c      ****             	}
3079:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3080:../uvc.c      ****             	fb=0;
3081:../uvc.c      ****             	pb=0;
3082:../uvc.c      ****             	pbc=0;
3083:../uvc.c      ****                 prodCount = 0;
3084:../uvc.c      ****                 consCount = 0;
3085:../uvc.c      ****                 hitFV     = CyFalse;
3086:../uvc.c      **** 
3087:../uvc.c      **** #ifdef BACKFLOW_DETECT
3088:../uvc.c      ****                 back_flow_detected = 0;
3089:../uvc.c      **** #endif
3090:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3091:../uvc.c      ****                 frameCnt++;
3092:../uvc.c      **** #endif
3093:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3094:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3095:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3096:../uvc.c      ****                 //}
3097:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3098:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3099:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3100:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3101:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3102:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3103:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3104:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3105:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3106:../uvc.c      ****                 		stiflag = 0xFF;
3107:../uvc.c      ****                 		IMcount = 0;
3108:../uvc.c      ****                 	}
3109:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3110:../uvc.c      **** 
3111:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3112:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3113:../uvc.c      ****                 		stiflag = 0x0F;
3114:../uvc.c      ****                 		IMcount = 0;
3115:../uvc.c      ****                 		}
3116:../uvc.c      ****                  		/*if(IMcount > 0x4){
3117:../uvc.c      ****                 			stiflag = 0x0F;
3118:../uvc.c      ****                 			IMcount = 0;
3119:../uvc.c      ****                 		}*/
3120:../uvc.c      **** 
3121:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3122:../uvc.c      ****                     //CyU3PThreadSleep(400);
3123:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3124:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3125:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3126:../uvc.c      **** 
3127:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3128:../uvc.c      ****                 	{
3129:../uvc.c      ****                     switch (setRes)
3130:../uvc.c      ****                      {
3131:../uvc.c      ****                  	case 1: //1944
3132:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3133:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3134:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3135:../uvc.c      ****                  		break;
3136:../uvc.c      ****                  	case 2: //1080
3137:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3138:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3139:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3140:../uvc.c      ****                  		break;
3141:../uvc.c      ****                  	case 3: //720
3142:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3143:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3144:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3145:../uvc.c      ****                  		break;
3146:../uvc.c      ****                  	case 4: //VGA
3147:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3148:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3149:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3150:../uvc.c      ****                  		break;
3151:../uvc.c      ****                  	default:
3152:../uvc.c      ****                  		break;
3153:../uvc.c      ****                      }
3154:../uvc.c      ****                     IMcount = 0;
3155:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3156:../uvc.c      ****                 	stiflag = 0x0;
3157:../uvc.c      ****                 	}
3158:../uvc.c      ****                 }
3159:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3160:../uvc.c      ****                 /* Reset the DMA channel. */
3161:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3162:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3163:../uvc.c      ****                 {
3164:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3165:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3166:../uvc.c      ****                 }
3167:../uvc.c      **** 
3168:../uvc.c      ****                 /* Start Channel Immediately */
3169:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3170:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3171:../uvc.c      ****                 {
3172:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3173:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3174:../uvc.c      ****                 }
3175:../uvc.c      **** 
3176:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3177:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3178:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3179:../uvc.c      ****                 }
3180:../uvc.c      ****         }
3181:../uvc.c      ****         else
3182:../uvc.c      ****         {
3183:../uvc.c      ****             /* If we have a stream abort request pending. */
3184:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3185:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3186:../uvc.c      ****             {
3187:../uvc.c      ****                 hitFV     = CyFalse;
3188:../uvc.c      ****                 prodCount = 0;
3189:../uvc.c      ****                 consCount = 0;
3190:../uvc.c      ****                 if(0&&(prinflag == 0)){
3191:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3192:../uvc.c      ****                 	prinflag = 1;
3193:../uvc.c      ****                 }
3194:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3195:../uvc.c      ****                 fb=0;
3196:../uvc.c      ****                 pb=0;
3197:../uvc.c      ****                 pbc=0;
3198:../uvc.c      **** 
3199:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3200:../uvc.c      ****                 {
3201:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3202:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3203:../uvc.c      ****                     {
3204:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3205:../uvc.c      ****                     }
3206:../uvc.c      **** 
3207:../uvc.c      ****                     /* Flush the Endpoint memory */
3208:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3209:../uvc.c      ****                 }
3210:../uvc.c      **** 
3211:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3212:../uvc.c      ****             }
3213:../uvc.c      ****             else
3214:../uvc.c      ****             {
3215:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3216:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3217:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3218:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3219:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3220:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3221:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3222:../uvc.c      ****                 {
3223:../uvc.c      ****                     /* Error handling */
3224:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3225:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3226:../uvc.c      ****                 }
3227:../uvc.c      **** 
3228:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3229:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3230:../uvc.c      ****                 {
3231:../uvc.c      **** #if 0
3232:../uvc.c      ****                 	//for start up of the AF Lens
3233:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3234:../uvc.c      ****                     CyU3PThreadSleep(500);
3235:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3236:../uvc.c      ****                     CyU3PThreadSleep(500);
3237:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3238:../uvc.c      ****                    	CyU3PThreadSleep(300);
3239:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3240:../uvc.c      ****                     CyU3PThreadSleep(500);
3241:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3242:../uvc.c      ****                     CyU3PThreadSleep(500);
3243:../uvc.c      **** #endif
3244:../uvc.c      **** #if 0
3245:../uvc.c      ****                     switch (setRes)
3246:../uvc.c      ****                     {
3247:../uvc.c      ****                     	case 1: //1944
3248:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3249:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3250:../uvc.c      ****                     		break;
3251:../uvc.c      ****                     	case 2: //1080
3252:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3253:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3254:../uvc.c      ****                     		break;
3255:../uvc.c      ****                     	case 3: //720
3256:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3257:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3258:../uvc.c      ****                     		break;
3259:../uvc.c      ****                     	default:
3260:../uvc.c      ****                     		break;
3261:../uvc.c      ****                     }
3262:../uvc.c      **** #endif
3263:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3264:../uvc.c      **** 
3265:../uvc.c      ****                     gpif_initialized = CyTrue;
3266:../uvc.c      ****                     CyU3PThreadSleep(200);
3267:../uvc.c      ****                     
3268:../uvc.c      ****                 }
3269:../uvc.c      ****                 else
3270:../uvc.c      ****                 {
3271:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3272:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3273:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3274:../uvc.c      ****                 }
3275:../uvc.c      ****             }
3276:../uvc.c      ****         }
3277:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3278:../uvc.c      **** 
3279:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3280:../uvc.c      ****         CyU3PThreadRelinquish ();
3281:../uvc.c      ****     }
3282:../uvc.c      **** }
3283:../uvc.c      **** 
3284:../uvc.c      **** /*
3285:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3286:../uvc.c      ****  */
3287:../uvc.c      **** 
3288:../uvc.c      **** static void
3289:../uvc.c      **** UVCHandleProcessingUnitRqts (
3290:../uvc.c      ****         void)
3291:../uvc.c      **** {
3292:../uvc.c      ****     uint8_t CtrlAdd;
3293:../uvc.c      **** #ifdef DbgInfo
3294:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3295:../uvc.c      **** #endif
3296:../uvc.c      ****     switch (wValue)
3297:../uvc.c      ****     {
3298:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3299:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3300:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3301:../uvc.c      ****     		break;
3302:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3303:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3304:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3305:../uvc.c      ****     		break;
3306:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3307:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3308:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3309:../uvc.c      **** 			break;
3310:../uvc.c      **** 
3311:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3312:../uvc.c      **** 
3313:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3314:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3315:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3316:../uvc.c      ****       		break;
3317:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3318:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3319:../uvc.c      ****      		ControlHandle(HueCtlID5);
3320:../uvc.c      ****      		break;
3321:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3322:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3323:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3324:../uvc.c      ****           		break;
3325:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3326:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3327:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3328:../uvc.c      ****           		break;
3329:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3330:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3331:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3332:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3333:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3334:../uvc.c      ****     		break;
3335:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3336:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3337:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3338:../uvc.c      ****     		break;
3339:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3340:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3341:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3342:../uvc.c      ****     		break;
3343:../uvc.c      **** 
3344:../uvc.c      ****         default:
3345:../uvc.c      ****             /*
3346:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3347:../uvc.c      ****              * other controls.
3348:../uvc.c      ****              */
3349:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3350:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3351:../uvc.c      ****             break;
3352:../uvc.c      ****     }
3353:../uvc.c      **** }
3354:../uvc.c      **** 
3355:../uvc.c      **** /*
3356:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3357:../uvc.c      ****  */
3358:../uvc.c      **** static void
3359:../uvc.c      **** UVCHandleCameraTerminalRqts (
3360:../uvc.c      ****         void)
3361:../uvc.c      **** {
3362:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3363:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3364:../uvc.c      ****     uint16_t readCount;
3365:../uvc.c      ****     uint16_t zoomVal;
3366:../uvc.c      ****     int32_t  panVal, tiltVal;
3367:../uvc.c      ****     CyBool_t sendData = CyFalse;
3368:../uvc.c      **** #endif
3369:../uvc.c      ****     uint8_t CtrlAdd;
3370:../uvc.c      **** 
3371:../uvc.c      ****     switch (wValue)
3372:../uvc.c      ****     {
3373:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3374:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3375:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3376:../uvc.c      ****     		break;
3377:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3378:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3379:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3380:../uvc.c      ****     		break;
3381:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3382:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3383:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3384:../uvc.c      **** 			break;
3385:../uvc.c      **** 
3386:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3387:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3388:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3389:../uvc.c      **** 			break;
3390:../uvc.c      **** 
3391:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3392:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3393:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3394:../uvc.c      ****       		break;
3395:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3396:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3397:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3398:../uvc.c      ****      		break;
3399:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3400:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3401:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3402:../uvc.c      ****           		break;
3403:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3404:../uvc.c      ****           		break;
3405:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3406:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3407:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3408:../uvc.c      ****      		break;
3409:../uvc.c      **** 
3410:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3411:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3412:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3413:../uvc.c      ****     		break;
3414:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3415:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3416:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3417:../uvc.c      ****     		break;
3418:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3419:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3420:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3421:../uvc.c      ****     		break;
3422:../uvc.c      **** 
3423:../uvc.c      ****         default:
3424:../uvc.c      ****             /*
3425:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3426:../uvc.c      ****              * other controls.
3427:../uvc.c      ****              */
3428:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3429:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3430:../uvc.c      ****             break;
3431:../uvc.c      ****     }
3432:../uvc.c      **** 
3433:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3434:../uvc.c      ****     switch (wValue)
3435:../uvc.c      ****     {
3436:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3437:../uvc.c      ****             switch (bRequest)
3438:../uvc.c      ****             {
3439:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3440:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3441:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3442:../uvc.c      ****                     break;
3443:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3444:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3445:../uvc.c      ****                     sendData = CyTrue;
3446:../uvc.c      ****                     break;
3447:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3448:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3449:../uvc.c      ****                     sendData = CyTrue;
3450:../uvc.c      ****                     break;
3451:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3452:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3453:../uvc.c      ****                     sendData = CyTrue;
3454:../uvc.c      ****                     break;
3455:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3456:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3457:../uvc.c      ****                     sendData = CyTrue;
3458:../uvc.c      ****                     break;
3459:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3460:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3461:../uvc.c      ****                     sendData = CyTrue;
3462:../uvc.c      ****                     break;
3463:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3464:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3465:../uvc.c      ****                             glEp0Buffer, &readCount);
3466:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3467:../uvc.c      ****                     {
3468:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3469:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3470:../uvc.c      ****                     }
3471:../uvc.c      ****                     break;
3472:../uvc.c      ****                 default:
3473:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3474:../uvc.c      ****                     break;
3475:../uvc.c      ****             }
3476:../uvc.c      **** 
3477:../uvc.c      ****             if (sendData)
3478:../uvc.c      ****             {
3479:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3480:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3481:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3482:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3483:../uvc.c      ****             }
3484:../uvc.c      ****             break;
3485:../uvc.c      **** 
3486:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3487:../uvc.c      ****             switch (bRequest)
3488:../uvc.c      ****             {
3489:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3490:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3491:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3492:../uvc.c      ****                     break;
3493:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3494:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3495:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3496:../uvc.c      ****                     sendData = CyTrue;
3497:../uvc.c      ****                     break;
3498:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3499:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3500:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3501:../uvc.c      ****                     sendData = CyTrue;
3502:../uvc.c      ****                     break;
3503:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3504:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3505:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3506:../uvc.c      ****                     sendData = CyTrue;
3507:../uvc.c      ****                     break;
3508:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3509:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3510:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3511:../uvc.c      ****                     sendData = CyTrue;
3512:../uvc.c      ****                     break;
3513:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3514:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3515:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3516:../uvc.c      ****                     sendData = CyTrue;
3517:../uvc.c      ****                     break;
3518:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3519:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3520:../uvc.c      ****                             glEp0Buffer, &readCount);
3521:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3522:../uvc.c      ****                     {
3523:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3524:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3525:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3526:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3527:../uvc.c      **** 
3528:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3529:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3530:../uvc.c      ****                     }
3531:../uvc.c      ****                     break;
3532:../uvc.c      ****                 default:
3533:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3534:../uvc.c      ****                     break;
3535:../uvc.c      ****             }
3536:../uvc.c      **** 
3537:../uvc.c      ****             if (sendData)
3538:../uvc.c      ****             {
3539:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3540:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3541:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3542:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3543:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3544:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3545:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3546:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3547:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3548:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3549:../uvc.c      ****             }
3550:../uvc.c      ****             break;
3551:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3552:../uvc.c      ****         default:
3553:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3554:../uvc.c      ****             break;
3555:../uvc.c      ****     }
3556:../uvc.c      **** #endif
3557:../uvc.c      **** }
3558:../uvc.c      **** 
3559:../uvc.c      **** /*
3560:../uvc.c      ****  * Handler for UVC Interface control requests.
3561:../uvc.c      ****  */
3562:../uvc.c      **** static void
3563:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3564:../uvc.c      ****         void)
3565:../uvc.c      **** {
3566:../uvc.c      **** 
3567:../uvc.c      ****     switch (wValue)
3568:../uvc.c      ****     {
3569:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3570:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3571:../uvc.c      ****     		break;
3572:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3573:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3574:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3575:../uvc.c      ****     		break;
3576:../uvc.c      ****     	default:
3577:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3578:../uvc.c      ****      		break;
3579:../uvc.c      ****     }
3580:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3581:../uvc.c      **** 
3582:../uvc.c      **** }
3583:../uvc.c      **** 
3584:../uvc.c      **** /*
3585:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3586:../uvc.c      ****  */
3587:../uvc.c      **** static void
3588:../uvc.c      **** UVCHandleExtensionUnitRqts (
3589:../uvc.c      ****         void)
3590:../uvc.c      **** {
3591:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3592:../uvc.c      **** 
3593:../uvc.c      **** #ifdef DbgInfo
3594:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3595:../uvc.c      **** #endif
3596:../uvc.c      ****     switch (wValue)
3597:../uvc.c      ****     {
3598:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3599:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3600:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3601:../uvc.c      ****     		break;
3602:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3603:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3604:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3605:../uvc.c      ****     		break;
3606:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3607:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3608:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3609:../uvc.c      ****      		break;
3610:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3611:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3612:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3613:../uvc.c      ****     		break;
3614:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3615:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3616:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3617:../uvc.c      ****     		break;
3618:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3619:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3620:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3621:../uvc.c      ****      		break;
3622:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3623:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3624:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3625:../uvc.c      ****     		break;
3626:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3627:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3628:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3629:../uvc.c      ****     		break;
3630:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3631:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3632:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3633:../uvc.c      ****      		break;
3634:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3635:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3636:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3637:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3638:../uvc.c      ****     		}else/* no support for 1080p camera */
3639:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3640:../uvc.c      ****     		break;
3641:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3642:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3643:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3644:../uvc.c      ****     		break;
3645:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3646:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3647:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3648:../uvc.c      ****     		break;
3649:../uvc.c      **** 
3650:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3651:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3652:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3653:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3654:../uvc.c      ****     		break;
3655:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3656:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3657:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3658:../uvc.c      ****     		//break;
3659:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3660:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3661:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3662:../uvc.c      ****     		break;
3663:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3664:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3665:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3666:../uvc.c      ****     		break;
3667:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3668:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3669:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3670:../uvc.c      ****     		break;
3671:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3672:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3673:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3674:../uvc.c      ****     		break;
3675:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3676:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3677:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3678:../uvc.c      ****     		break;
3679:../uvc.c      ****    	default:
3680:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3681:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3682:../uvc.c      ****     		break;
3683:../uvc.c      ****     }
3684:../uvc.c      **** 
3685:../uvc.c      **** }
3686:../uvc.c      **** 
3687:../uvc.c      **** /*
3688:../uvc.c      ****  * Handler for the video streaming control requests.
3689:../uvc.c      ****  */
3690:../uvc.c      **** static void
3691:../uvc.c      **** UVCHandleVideoStreamingRqts (
3692:../uvc.c      ****         void)
3693:../uvc.c      **** {
3694:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3695:../uvc.c      ****     uint16_t readCount;
3696:../uvc.c      **** 
3697:../uvc.c      ****     switch (wValue)
3698:../uvc.c      ****     {
3699:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3700:../uvc.c      ****             switch (bRequest)
3701:../uvc.c      ****             {
3702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3703:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3704:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3705:../uvc.c      ****                     break;
3706:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3707:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3708:../uvc.c      ****                     glEp0Buffer[1] = 0;
3709:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3710:../uvc.c      ****                     break;
3711:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3712:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3713:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3714:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3715:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3716:../uvc.c      ****                     {
3717:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3718:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3719:../uvc.c      **** 
3720:../uvc.c      ****                     }
3721:../uvc.c      ****                     else
3722:../uvc.c      ****                     {
3723:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3724:../uvc.c      ****                     }
3725:../uvc.c      ****                     break;
3726:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3727:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3728:../uvc.c      ****                             glCommitCtrl, &readCount);
3729:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3730:../uvc.c      ****                     {
3731:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3732:../uvc.c      ****                         {
3733:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3734:../uvc.c      ****                                active data structure. */
3735:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3736:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3737:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3738:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3739:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3740:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3741:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3742:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3743:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3744:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3745:../uvc.c      **** #if 0
3746:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3747:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3748:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3749:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3750:../uvc.c      **** #endif
3751:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3752:../uvc.c      ****                        }
3753:../uvc.c      ****                     }
3754:../uvc.c      ****                     break;
3755:../uvc.c      ****                 default:
3756:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3757:../uvc.c      ****                     break;
3758:../uvc.c      ****             }
3759:../uvc.c      ****             break;
3760:../uvc.c      **** 
3761:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3762:../uvc.c      ****             switch (bRequest)
3763:../uvc.c      ****             {
3764:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3765:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3766:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3767:../uvc.c      ****                     break;
3768:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3769:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3770:../uvc.c      ****                     glEp0Buffer[1] = 0;
3771:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3772:../uvc.c      ****                     break;
3773:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3774:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3775:../uvc.c      ****                     {
3776:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3777:../uvc.c      ****                     }
3778:../uvc.c      ****                     else
3779:../uvc.c      ****                     {
3780:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3781:../uvc.c      ****                     }
3782:../uvc.c      ****                     break;
3783:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3784:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3785:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3786:../uvc.c      ****                        */
3787:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3788:../uvc.c      ****                             glCommitCtrl, &readCount);
3789:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3790:../uvc.c      ****                     {
3791:../uvc.c      ****                         switch (glCommitCtrl[3])
3792:../uvc.c      ****                          {
3793:../uvc.c      ****                          	case 1: //1944
3794:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3795:../uvc.c      ****                          		CyU3PThreadSleep(500);
3796:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3797:../uvc.c      ****                          		break;
3798:../uvc.c      ****                          	case 2: //1080
3799:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3800:../uvc.c      ****                          		CyU3PThreadSleep(500);
3801:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3802:../uvc.c      ****                          		break;
3803:../uvc.c      ****                          	case 3: //720
3804:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3805:../uvc.c      ****                          		CyU3PThreadSleep(500);
3806:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3807:../uvc.c      ****                          		break;
3808:../uvc.c      ****                          	case 4: //VGA
3809:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3810:../uvc.c      ****                          		CyU3PThreadSleep(500);
3811:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3812:../uvc.c      ****                          		break;
3813:../uvc.c      ****                          	default:
3814:../uvc.c      ****                          		break;
3815:../uvc.c      ****                          }
3816:../uvc.c      ****                         setRes = glCommitCtrl[3];
3817:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3818:../uvc.c      **** 
3819:../uvc.c      **** #if 0
3820:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3821:../uvc.c      ****                         {
3822:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3823:../uvc.c      ****                         }
3824:../uvc.c      ****                         else
3825:../uvc.c      ****                         {
3826:../uvc.c      ****                             SensorScaling_VGA ();
3827:../uvc.c      ****                         }
3828:../uvc.c      **** #endif
3829:../uvc.c      ****                         /* We can start streaming video now. */
3830:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3831:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3832:../uvc.c      ****                         {
3833:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3834:../uvc.c      ****                         }
3835:../uvc.c      ****                     }
3836:../uvc.c      ****                     break;
3837:../uvc.c      **** 
3838:../uvc.c      ****                 default:
3839:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3840:../uvc.c      ****                     break;
3841:../uvc.c      ****             }
3842:../uvc.c      ****             break;
3843:../uvc.c      **** 
3844:../uvc.c      **** /* still image streaming handler */
3845:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3846:../uvc.c      ****                 switch (bRequest)
3847:../uvc.c      ****                 {
3848:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3849:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3850:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3851:../uvc.c      ****                         break;
3852:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3853:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3854:../uvc.c      ****                         glEp0Buffer[1] = 0;
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3856:../uvc.c      ****                         break;
3857:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3858:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3859:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3860:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3861:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3862:../uvc.c      ****                         {
3863:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3864:../uvc.c      ****                         }
3865:../uvc.c      ****                         else
3866:../uvc.c      ****                         {
3867:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3868:../uvc.c      ****                         }
3869:../uvc.c      ****                         break;
3870:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3871:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3872:../uvc.c      ****                                 glCommitCtrl, &readCount);
3873:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3874:../uvc.c      ****                         {
3875:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3876:../uvc.c      ****                             {
3877:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3878:../uvc.c      ****                                    active data structure. */
3879:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3880:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3881:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3882:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3883:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3884:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3885:../uvc.c      ****                             }
3886:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3887:../uvc.c      ****                         }
3888:../uvc.c      ****                         break;
3889:../uvc.c      ****                     default:
3890:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3891:../uvc.c      ****                         break;
3892:../uvc.c      ****                 }
3893:../uvc.c      ****                 break;
3894:../uvc.c      **** 
3895:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3896:../uvc.c      ****                 switch (bRequest)
3897:../uvc.c      ****                 {
3898:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3899:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3900:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3901:../uvc.c      ****                         break;
3902:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3903:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3904:../uvc.c      ****                         glEp0Buffer[1] = 0;
3905:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3906:../uvc.c      ****                         break;
3907:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3908:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3909:../uvc.c      ****                         {
3910:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3911:../uvc.c      ****                         }
3912:../uvc.c      ****                         else
3913:../uvc.c      ****                         {
3914:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3915:../uvc.c      ****                         }
3916:../uvc.c      ****                         break;
3917:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3918:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3919:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3920:../uvc.c      ****                            */
3921:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3922:../uvc.c      ****                                 glCommitCtrl, &readCount);
3923:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3924:../uvc.c      ****                         {
3925:../uvc.c      ****     #if 0
3926:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3927:../uvc.c      ****                             {
3928:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3929:../uvc.c      ****                             }
3930:../uvc.c      ****                             else
3931:../uvc.c      ****                             {
3932:../uvc.c      ****                                 SensorScaling_VGA ();
3933:../uvc.c      ****                             }
3934:../uvc.c      ****                             /* We can start streaming video now. */
3935:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3936:../uvc.c      **** 
3937:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3938:../uvc.c      ****                             {
3939:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3940:../uvc.c      ****                             }
3941:../uvc.c      **** 	#endif
3942:../uvc.c      ****                            switch (glCommitCtrl[1])
3943:../uvc.c      ****                              {
3944:../uvc.c      ****                              	case 4: //1944
3945:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3946:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3947:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3948:../uvc.c      ****                              		break;
3949:../uvc.c      ****                              	case 3: //1080
3950:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3951:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3952:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3953:../uvc.c      ****                              		break;
3954:../uvc.c      ****                              	case 2: //720
3955:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3956:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3957:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3958:../uvc.c      ****                              		break;
3959:../uvc.c      ****                             	case 1: //VGA
3960:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3961:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3962:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3963:../uvc.c      ****                              		break;
3964:../uvc.c      ****                               	default:
3965:../uvc.c      ****                              		break;
3966:../uvc.c      ****                              }
3967:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3968:../uvc.c      **** 
3969:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3970:../uvc.c      **** 
3971:../uvc.c      ****                         }
3972:../uvc.c      ****                         break;
3973:../uvc.c      **** 
3974:../uvc.c      ****                     default:
3975:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3976:../uvc.c      ****                         break;
3977:../uvc.c      ****                 }
3978:../uvc.c      ****                 break;
3979:../uvc.c      **** 
3980:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3981:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3982:../uvc.c      ****             	switch (bRequest)
3983:../uvc.c      ****                 {
3984:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3985:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3986:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3987:../uvc.c      ****                         break;
3988:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3989:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3990:../uvc.c      ****                         glEp0Buffer[1] = 0;
3991:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3992:../uvc.c      ****                         break;
3993:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3994:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3995:../uvc.c      ****                         {
3996:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3997:../uvc.c      ****                         }
3998:../uvc.c      ****                         else
3999:../uvc.c      ****                         {
4000:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4001:../uvc.c      ****                         }
4002:../uvc.c      ****                         break;
4003:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4004:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4005:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4006:../uvc.c      ****                            */
4007:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4008:../uvc.c      ****                                 glCommitCtrl, &readCount);
4009:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4010:../uvc.c      ****                         {
4011:../uvc.c      ****     #if 1
4012:../uvc.c      ****                             /* We can start still streaming video now. */
4013:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4014:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4015:../uvc.c      ****                             {
4016:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4017:../uvc.c      ****                             }
4018:../uvc.c      ****     #endif
4019:../uvc.c      ****                             else{
4020:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4021:../uvc.c      ****                             //stillcont = 0;
4022:../uvc.c      ****                             }
4023:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4024:../uvc.c      ****                         }else{
4025:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4026:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4027:../uvc.c      ****                         }
4028:../uvc.c      ****                         break;
4029:../uvc.c      **** 
4030:../uvc.c      ****                     default:
4031:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4032:../uvc.c      ****                         break;
4033:../uvc.c      ****                 }
4034:../uvc.c      ****                 break;
4035:../uvc.c      **** 
4036:../uvc.c      ****         default:
4037:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4038:../uvc.c      ****             break;
4039:../uvc.c      ****     }
4040:../uvc.c      **** }
4041:../uvc.c      **** 
4042:../uvc.c      **** /*
4043:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4044:../uvc.c      ****  */
4045:../uvc.c      **** void
4046:../uvc.c      **** UVCAppEP0Thread_Entry (
4047:../uvc.c      ****         uint32_t input)
4048:../uvc.c      **** {
4049:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4050:../uvc.c      ****     uint32_t eventFlag;
4051:../uvc.c      **** 	CyBool_t value;
4052:../uvc.c      **** 	CyBool_t *valueptr = &value;
4053:../uvc.c      **** 
4054:../uvc.c      **** 
4055:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4056:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4057:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4058:../uvc.c      **** 
4059:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4060:../uvc.c      **** #endif
4061:../uvc.c      **** 
4062:../uvc.c      ****     /* for interrupt status test */
4063:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4064:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4065:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4066:../uvc.c      **** 
4067:../uvc.c      ****     for (;;)
4068:../uvc.c      ****     {
4069:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4070:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4071:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4072:../uvc.c      ****         {
4073:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4074:../uvc.c      ****             if (!isUsbConnected)
4075:../uvc.c      ****             {
4076:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4077:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4078:../uvc.c      ****                 {
4079:../uvc.c      ****                     isUsbConnected = CyTrue;
4080:../uvc.c      ****                 }
4081:../uvc.c      ****             }
4082:../uvc.c      **** //#ifdef DbgInfo
4083:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4084:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4085:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4086:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4087:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4088:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4089:../uvc.c      **** //#endif
4090:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4091:../uvc.c      ****             {
4092:../uvc.c      ****             	switch ((wIndex >> 8))
4093:../uvc.c      ****                 {
4094:../uvc.c      **** 
4095:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4096:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4097:../uvc.c      ****                         break;
4098:../uvc.c      **** 
4099:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4100:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4101:../uvc.c      ****                         break;
4102:../uvc.c      **** 
4103:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4104:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4105:../uvc.c      ****                         break;
4106:../uvc.c      **** 
4107:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4108:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4109:../uvc.c      ****                         break;
4110:../uvc.c      **** 
4111:../uvc.c      ****                     default:
4112:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4113:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4114:../uvc.c      ****                         break;
4115:../uvc.c      ****                 }
4116:../uvc.c      ****             }
4117:../uvc.c      **** 
4118:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4119:../uvc.c      ****             {
4120:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4121:../uvc.c      **** 
4122:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4123:../uvc.c      ****                 {
4124:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4125:../uvc.c      ****                 }
4126:../uvc.c      ****                 else
4127:../uvc.c      ****                 {
4128:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4129:../uvc.c      ****                 }
4130:../uvc.c      ****             }
4131:../uvc.c      **** 
4132:../uvc.c      ****             /* handle interrupt status event */
4133:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4134:../uvc.c      ****             {
4135:../uvc.c      **** 
4136:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4137:../uvc.c      ****             	/** preparing interrupt status data **/
4138:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4139:../uvc.c      **** 
4140:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4141:../uvc.c      **** 
4142:../uvc.c      **** #if 0 //for real button
4143:../uvc.c      **** 				if(value&&(!snapButFlag)){
4144:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4145:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4146:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4147:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4148:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4149:../uvc.c      **** 
4150:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4151:../uvc.c      **** 					interStabuf.size   = 1024;
4152:../uvc.c      **** 					interStabuf.status = 0;
4153:../uvc.c      **** 
4154:../uvc.c      **** 					interStabuf.count = 4;
4155:../uvc.c      **** 
4156:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4157:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4158:../uvc.c      **** 
4159:../uvc.c      **** 					/** send a interrupt status data **/
4160:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4161:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4162:../uvc.c      **** 					{
4163:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4164:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4165:../uvc.c      **** 					}
4166:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4167:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4168:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4169:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4170:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4171:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4172:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4173:../uvc.c      **** 
4174:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4175:../uvc.c      **** 					interStabuf.size   = 1024;
4176:../uvc.c      **** 					interStabuf.status = 0;
4177:../uvc.c      **** 
4178:../uvc.c      **** 					interStabuf.count = 4;
4179:../uvc.c      **** 
4180:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4181:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4182:../uvc.c      **** 
4183:../uvc.c      **** 					/** send a interrupt status data **/
4184:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4185:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4186:../uvc.c      **** 					{
4187:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4188:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4189:../uvc.c      **** 					}
4190:../uvc.c      **** 
4191:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4192:../uvc.c      **** 					stiflag = 0xFF;
4193:../uvc.c      **** 				}
4194:../uvc.c      **** #else			//for botton simulation
4195:../uvc.c      **** 				if(snapButFlag == 0x0f){
4196:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4197:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4198:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4199:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4200:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4201:../uvc.c      **** 
4202:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4203:../uvc.c      **** 					interStabuf.size   = 1024;
4204:../uvc.c      **** 					interStabuf.status = 0;
4205:../uvc.c      **** 
4206:../uvc.c      **** 					interStabuf.count = 4;
4207:../uvc.c      **** 
4208:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4209:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4210:../uvc.c      **** 
4211:../uvc.c      **** 					/** send a interrupt status data **/
4212:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4213:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4214:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4215:../uvc.c      **** 					{
4216:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4217:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4218:../uvc.c      **** 					}
4219:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4220:../uvc.c      **** 
4221:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4222:../uvc.c      **** 				}else if(!snapButFlag){
4223:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4224:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4225:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4226:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4227:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4228:../uvc.c      **** 
4229:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4230:../uvc.c      **** 					interStabuf.size   = 1024;
4231:../uvc.c      **** 					interStabuf.status = 0;
4232:../uvc.c      **** 
4233:../uvc.c      **** 					interStabuf.count = 4;
4234:../uvc.c      **** 
4235:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4237:../uvc.c      **** 
4238:../uvc.c      **** 					/** send a interrupt status data **/
4239:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4240:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4241:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4242:../uvc.c      **** 					{
4243:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4244:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4245:../uvc.c      **** 					}
4246:../uvc.c      **** 
4247:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4248:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4249:../uvc.c      **** 				}
4250:../uvc.c      **** #endif
4251:../uvc.c      **** 
4252:../uvc.c      ****             }
4253:../uvc.c      **** 
4254:../uvc.c      **** 
4255:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4256:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4257:../uvc.c      ****             {
4258:../uvc.c      ****                 /* Get the command buffer */
4259:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4260:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4261:../uvc.c      ****                 {
4262:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4263:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4264:../uvc.c      ****                 }
4265:../uvc.c      **** 
4266:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4267:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4268:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4269:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4270:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4271:../uvc.c      ****                  * register value high byte and register value low byte.
4272:../uvc.c      ****                  */
4273:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4274:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4275:../uvc.c      ****                 {
4276:../uvc.c      ****                     if (dmaInfo.count == 3)
4277:../uvc.c      ****                     {
4278:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4279:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4280:../uvc.c      ****                         dmaInfo.count = 3;
4281:../uvc.c      ****                     }
4282:../uvc.c      ****                     else if (dmaInfo.count == 4)
4283:../uvc.c      ****                     {
4284:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4285:../uvc.c      ****                         {
4286:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4287:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4288:../uvc.c      ****                         }
4289:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4290:../uvc.c      ****                     }
4291:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4292:../uvc.c      ****                 }
4293:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4294:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4295:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4296:../uvc.c      ****                  */
4297:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4298:../uvc.c      ****                 {
4299:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4300:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4301:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4302:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4303:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4304:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4305:../uvc.c      ****                         	break;
4306:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4307:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4308:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4309:../uvc.c      ****                         	break;*/
4310:../uvc.c      ****                     dmaInfo.count -= 2;
4311:../uvc.c      ****                 }
4312:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4313:../uvc.c      ****                 else
4314:../uvc.c      ****                 {
4315:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4316:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4317:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4318:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4319:../uvc.c      ****                 }
4320:../uvc.c      **** 
4321:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4322:../uvc.c      ****                 dmaInfo.size   = 1024;
4323:../uvc.c      ****                 dmaInfo.status = 0;
4324:../uvc.c      **** 
4325:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4326:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4327:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4328:../uvc.c      ****                 {
4329:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4330:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4331:../uvc.c      ****                 }
4332:../uvc.c      **** 
4333:../uvc.c      ****                 /* Wait until the response has gone out. */
4334:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4335:../uvc.c      **** 
4336:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4337:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4338:../uvc.c      ****                 {
4339:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4340:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4341:../uvc.c      ****                 }
4342:../uvc.c      ****             }
4343:../uvc.c      **** #endif
4344:../uvc.c      ****         }
4345:../uvc.c      ****         /* Allow other ready threads to run. */
4346:../uvc.c      ****         CyU3PThreadRelinquish ();
4347:../uvc.c      ****     }
4348:../uvc.c      **** }
4349:../uvc.c      **** 
4350:../uvc.c      **** /*
4351:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4352:../uvc.c      ****  * added 10/2013
4353:../uvc.c      ****  */
4354:../uvc.c      **** /*
4355:../uvc.c      **** static uint8_t timeDelay[64] = {
4356:../uvc.c      **** 
4357:../uvc.c      **** };
4358:../uvc.c      **** */
4359:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4359 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4360:../uvc.c      **** 
4361:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4362:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4363:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4364:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4365:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4366:../uvc.c      **** 	uint32_t flag = 0;
4367:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4368:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4369:../uvc.c      **** 	uint8_t i;
4370:../uvc.c      **** 	uint16_t delaytime;
4371:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4372:../uvc.c      **** 
4373:../uvc.c      **** #if 0 //for test the command queue
4374:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4375:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4376:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4377:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4378:../uvc.c      **** 		lcCmdDes += 1;
4379:../uvc.c      **** 	}
4380:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4381:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4382:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4383:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4384:../uvc.c      **** 		lcCmdDes += 1;
4385:../uvc.c      **** 	}
4386:../uvc.c      **** 
4387:../uvc.c      **** #endif
4388:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4389:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4389 0
  36 0004 30229FE5 		ldr	r2, .L25
4366:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4366 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4359:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4359 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4389 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 18029FE5 		ldr	r0, .L25+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4366:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4366 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4389 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4390:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4390 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 FC119FE5 		ldr	r1, .L25+8
  71 0044 FC519FE5 		ldr	r5, .L25+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4391:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4391 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4392:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4392 0
  79 005c DC019FE5 		ldr	r0, .L25+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4393:../uvc.c      **** 
4394:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4394 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4395:../uvc.c      ****         /* Allow other ready threads to run. */
4396:../uvc.c      **** 
4397:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4397 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4394:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4394 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4398:../uvc.c      **** 	}
4399:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4399 0
  92 0078 C8019FE5 		ldr	r0, .L25+12
  93 007c C8119FE5 		ldr	r1, .L25+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 B8619FE5 		ldr	r6, .L25+20
  99 0094 B8B19FE5 		ldr	fp, .L25+24
4400:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4401:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4402:../uvc.c      **** 	//CyU3PThreadSleep(100);
4403:../uvc.c      **** 	//SetCurCmd();
4404:../uvc.c      **** 	/*********** the loop of the thread ***********/
4405:../uvc.c      **** 	for(;;){
4406:../uvc.c      **** 
4407:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4407 0
 101 0098 0070E0E3 		mvn	r7, #0
4408:../uvc.c      **** /*  // for test GPIO output
4409:../uvc.c      **** 		if(trigger)
4410:../uvc.c      **** 		{
4411:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4412:../uvc.c      **** 			{
4413:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4414:../uvc.c      **** 			}
4415:../uvc.c      **** 
4416:../uvc.c      **** 		}else{
4417:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4418:../uvc.c      **** 			{
4419:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4420:../uvc.c      **** 			}
4421:../uvc.c      **** 
4422:../uvc.c      **** 		}
4423:../uvc.c      **** */
4424:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4425:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4426:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4427:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4428:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4429:../uvc.c      **** 				i = 0;
4430:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4430 0
 103 009c 0090A0E3 		mov	r9, #0
4431:../uvc.c      **** 					i++;
4432:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4433:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4434:../uvc.c      **** 				}
4435:../uvc.c      **** #if 0
4436:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4437:../uvc.c      **** 				i = lcStaDes->curNum;
4438:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4439:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4440:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4441:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4442:../uvc.c      **** 
4443:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4444:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4445:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4446:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4447:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4448:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4449:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4450:../uvc.c      **** #endif
4451:../uvc.c      **** 				//}
4452:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4453:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4454:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4455:../uvc.c      **** 				/* setting delay */
4456:../uvc.c      **** 				delaytime = 300;
4457:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4458:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4459:../uvc.c      **** 			} //end of the if condition statment
4460:../uvc.c      **** #endif
4461:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4462:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4463:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4464:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4465:../uvc.c      **** 
4466:../uvc.c      **** 				/*
4467:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4468:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4469:../uvc.c      **** 				*/
4470:../uvc.c      **** 
4471:../uvc.c      **** 				/* find a available command */
4472:../uvc.c      **** 				i = 0;
4473:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4474:../uvc.c      **** 					i++;
4475:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4476:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4477:../uvc.c      **** 				}
4478:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4479:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4480:../uvc.c      **** 					i = lcCmdDes->curNum;
4481:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4482:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4483:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4484:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4485:../uvc.c      **** #if 1
4486:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4487:../uvc.c      **** 						case 0x20:
4488:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4489:../uvc.c      **** 							delaytime = 500;
4490:../uvc.c      **** 							break;
4491:../uvc.c      **** 						case 0x21:
4492:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4493:../uvc.c      **** 							delaytime = 500;
4494:../uvc.c      **** 							break;
4495:../uvc.c      **** 						case 0x22:
4496:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4497:../uvc.c      **** 							delaytime = 300;
4498:../uvc.c      **** 							break;
4499:../uvc.c      **** 						case 0x23:
4500:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4501:../uvc.c      **** 							delaytime = 300;
4502:../uvc.c      **** 							break;
4503:../uvc.c      **** 						default:
4504:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4505:../uvc.c      **** 							break;
4506:../uvc.c      **** 					}
4507:../uvc.c      **** #endif
4508:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4509:../uvc.c      **** 					/** timer's ticket modify **/
4510:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4511:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4512:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4513:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4514:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4515:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4516:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4517:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4518:../uvc.c      **** #endif
4519:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4520:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4521:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4522:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4523:../uvc.c      **** 						}else{
4524:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4525:../uvc.c      **** 						}
4526:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4527:../uvc.c      **** 					}else{
4528:../uvc.c      **** 						lcCmdDes->curNum ++;
4529:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4529 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L20:
4407:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4407 0
 108 00a4 14308DE2 		add	r3, sp, #20
 109 00a8 2010A0E3 		mov	r1, #32
 110 00ac 0320A0E3 		mov	r2, #3
 111 00b0 A0019FE5 		ldr	r0, .L25+28
 112 00b4 00708DE5 		str	r7, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4424:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4424 0
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 1C0096E5 		ldr	r0, [r6, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4430:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 119              		.loc 1 4430 0
 120 00c8 101096E5 		ldr	r1, [r6, #16]
 121 00cc 3C3091E5 		ldr	r3, [r1, #60]
 122 00d0 000053E3 		cmp	r3, #0
 123 00d4 0300001A 		bne	.L4
 124              	.LVL4:
 125              	.L5:
4431:../uvc.c      **** 					i++;
 126              		.loc 1 4431 0
 127 00d8 012083E2 		add	r2, r3, #1
 128 00dc FF3002E2 		and	r3, r2, #255
 129              	.LVL5:
4430:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4430 0
 131 00e0 3F0053E3 		cmp	r3, #63
 132 00e4 FBFFFF9A 		bls	.L5
 133              	.LVL6:
 134              	.L4:
4461:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 135              		.loc 1 4461 0
 136 00e8 1C0096E5 		ldr	r0, [r6, #28]
 137 00ec FEFFFFEB 		bl	_txe_mutex_put
 138              	.LVL7:
4463:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 139              		.loc 1 4463 0
 140 00f0 1C0095E5 		ldr	r0, [r5, #28]
 141 00f4 0010E0E3 		mvn	r1, #0
 142 00f8 FEFFFFEB 		bl	_txe_mutex_get
4464:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 143              		.loc 1 4464 0
 144 00fc 104095E5 		ldr	r4, [r5, #16]
 145              	.LVL8:
4473:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 146              		.loc 1 4473 0
 147 0100 3C2094E5 		ldr	r2, [r4, #60]
 148 0104 000052E3 		cmp	r2, #0
 149 0108 0800001A 		bne	.L6
 150 010c 0030A0E3 		mov	r3, #0
 151              	.LVL9:
 152              	.L7:
4475:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 153              		.loc 1 4475 0
 154 0110 344094E5 		ldr	r4, [r4, #52]
 155              	.LVL10:
4474:../uvc.c      **** 					i++;
 156              		.loc 1 4474 0
 157 0114 01A083E2 		add	sl, r3, #1
4473:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 158              		.loc 1 4473 0
 159 0118 3C2094E5 		ldr	r2, [r4, #60]
4474:../uvc.c      **** 					i++;
 160              		.loc 1 4474 0
 161 011c FF300AE2 		and	r3, sl, #255
 162              	.LVL11:
4473:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 163              		.loc 1 4473 0
 164 0120 3F0053E3 		cmp	r3, #63
 165 0124 00005293 		cmpls	r2, #0
 166 0128 F8FFFF0A 		beq	.L7
 167 012c 104085E5 		str	r4, [r5, #16]
 168              	.LVL12:
 169              	.L6:
4479:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 170              		.loc 1 4479 0
 171 0130 000052E3 		cmp	r2, #0
 172 0134 2D00000A 		beq	.L8
 173              	.LVL13:
4481:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 174              		.loc 1 4481 0
 175 0138 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
4486:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 176              		.loc 1 4486 0
 177 013c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4481:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 178              		.loc 1 4481 0
 179 0140 813081E0 		add	r3, r1, r1, asl #1
 180 0144 83E084E0 		add	lr, r4, r3, asl #1
4486:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 181              		.loc 1 4486 0
 182 0148 20C040E2 		sub	ip, r0, #32
4482:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 183              		.loc 1 4482 0
 184 014c 0510DEE5 		ldrb	r1, [lr, #5]	@ zero_extendqisi2
4481:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 185              		.loc 1 4481 0
 186 0150 0400DEE5 		ldrb	r0, [lr, #4]	@ zero_extendqisi2
 187              	.LVL14:
4483:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 188              		.loc 1 4483 0
 189 0154 0620DEE5 		ldrb	r2, [lr, #6]	@ zero_extendqisi2
 190              	.LVL15:
4484:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 191              		.loc 1 4484 0
 192 0158 B8A0DEE1 		ldrh	sl, [lr, #8]
 193              	.LVL16:
4486:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 194              		.loc 1 4486 0
 195 015c 03005CE3 		cmp	ip, #3
 196 0160 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 197 0164 1A0000EA 		b	.L9
 198              	.L14:
 199 0168 E0010000 		.word	.L10
 200 016c C4010000 		.word	.L11
 201 0170 78010000 		.word	.L13
 202 0174 78010000 		.word	.L13
 203              	.LVL17:
 204              	.L13:
4500:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 205              		.loc 1 4500 0
 206 0178 8230A0E3 		mov	r3, #130
 207 017c FEFFFFEB 		bl	SensorSetIrisControl
 208              	.LVL18:
4502:../uvc.c      **** 							break;
 209              		.loc 1 4502 0
 210 0180 4B1FA0E3 		mov	r1, #300
 211              	.LVL19:
 212              	.L15:
4511:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 213              		.loc 1 4511 0
 214 0184 0020A0E3 		mov	r2, #0
 215 0188 B0009FE5 		ldr	r0, .L25+4
 216 018c FEFFFFEB 		bl	_txe_timer_change
4512:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 217              		.loc 1 4512 0
 218 0190 A8009FE5 		ldr	r0, .L25+4
 219 0194 FEFFFFEB 		bl	_txe_timer_activate
 220              	.LVL20:
4519:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 221              		.loc 1 4519 0
 222 0198 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 223 019c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 224 01a0 0A0052E1 		cmp	r2, sl
4528:../uvc.c      **** 						lcCmdDes->curNum ++;
 225              		.loc 1 4528 0
 226 01a4 01A08A12 		addne	sl, sl, #1
 227 01a8 01A0C415 		strneb	sl, [r4, #1]
 228              		.loc 1 4529 0
 229 01ac 3C808415 		strne	r8, [r4, #60]
4519:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 230              		.loc 1 4519 0
 231 01b0 1400000A 		beq	.L24
 232              	.LVL21:
 233              	.L19:
4530:../uvc.c      **** 					}
4531:../uvc.c      **** 				}else{
4532:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4533:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4534:../uvc.c      **** 				}
4535:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 234              		.loc 1 4535 0
 235 01b4 1C0095E5 		ldr	r0, [r5, #28]
 236 01b8 FEFFFFEB 		bl	_txe_mutex_put
 237              	.LVL22:
4536:../uvc.c      **** 			}
4537:../uvc.c      **** /*
4538:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4539:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4540:../uvc.c      **** */
4541:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4542:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4543:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4544:../uvc.c      **** #endif
4545:../uvc.c      **** 
4546:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4547:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4548:../uvc.c      **** #if 0
4549:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4550:../uvc.c      **** 
4551:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4552:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4553:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4554:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4555:../uvc.c      **** 			    i = 0;
4556:../uvc.c      **** 				 switch(cmdCopyIdx)
4557:../uvc.c      **** 				 {
4558:../uvc.c      **** 					 case BrgtCtlID1:
4559:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4560:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4561:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4562:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4563:../uvc.c      **** 							 i++;
4564:../uvc.c      **** 						 }
4565:../uvc.c      **** 						 else{
4566:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4567:../uvc.c      **** 						 }
4568:../uvc.c      **** 
4569:../uvc.c      **** 						 CyU3PBusyWait(500);
4570:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4571:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4572:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4573:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4574:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4575:../uvc.c      **** 						 }
4576:../uvc.c      **** 						 else{
4577:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4578:../uvc.c      **** 						 }
4579:../uvc.c      **** 						 break;
4580:../uvc.c      **** 					 case HueCtlID5:
4581:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4582:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4583:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4584:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4585:../uvc.c      **** 						 }
4586:../uvc.c      **** 						 else{
4587:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4588:../uvc.c      **** 						 }
4589:../uvc.c      **** 						 break;
4590:../uvc.c      **** 					 case SaturCtlID6:
4591:../uvc.c      **** 					 case WBTLevCtlID10:
4592:../uvc.c      **** 					 default:
4593:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4594:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4595:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4596:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4597:../uvc.c      **** 						 }
4598:../uvc.c      **** 						 else{
4599:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4600:../uvc.c      **** 						 }
4601:../uvc.c      **** 						 break;
4602:../uvc.c      **** 				 }
4603:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4604:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4605:../uvc.c      **** 			}
4606:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4607:../uvc.c      **** #endif
4608:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4609:../uvc.c      **** 		/* Allow other ready threads to run. */
4610:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4611:../uvc.c      **** 			CyU3PThreadRelinquish ();
 238              		.loc 1 4611 0
 239 01bc FEFFFFEB 		bl	_txe_thread_relinquish
4612:../uvc.c      **** 		}
 240              		.loc 1 4612 0
 241 01c0 B7FFFFEA 		b	.L20
 242              	.LVL23:
 243              	.L11:
4492:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 244              		.loc 1 4492 0
 245 01c4 5230A0E3 		mov	r3, #82
 246 01c8 FEFFFFEB 		bl	SensorSetIrisControl
 247              	.LVL24:
4494:../uvc.c      **** 							break;
 248              		.loc 1 4494 0
 249 01cc 7D1FA0E3 		mov	r1, #500
 250 01d0 EBFFFFEA 		b	.L15
 251              	.LVL25:
 252              	.L9:
4504:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 253              		.loc 1 4504 0
 254 01d4 FEFFFFEB 		bl	SensorSetControl
 255              	.LVL26:
 256 01d8 0A10A0E1 		mov	r1, sl
4505:../uvc.c      **** 							break;
 257              		.loc 1 4505 0
 258 01dc E8FFFFEA 		b	.L15
 259              	.LVL27:
 260              	.L10:
4488:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 261              		.loc 1 4488 0
 262 01e0 8230A0E3 		mov	r3, #130
 263 01e4 FEFFFFEB 		bl	SensorSetIrisControl
 264              	.LVL28:
4490:../uvc.c      **** 							break;
 265              		.loc 1 4490 0
 266 01e8 7D1FA0E3 		mov	r1, #500
 267 01ec E4FFFFEA 		b	.L15
 268              	.LVL29:
 269              	.L8:
4532:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 270              		.loc 1 4532 0
 271 01f0 FA1FA0E3 		mov	r1, #1000
 272 01f4 44009FE5 		ldr	r0, .L25+4
 273 01f8 FEFFFFEB 		bl	_txe_timer_change
4533:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 274              		.loc 1 4533 0
 275 01fc 3C009FE5 		ldr	r0, .L25+4
 276 0200 FEFFFFEB 		bl	_txe_timer_activate
 277 0204 EAFFFFEA 		b	.L19
 278              	.LVL30:
 279              	.L24:
4521:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 280              		.loc 1 4521 0
 281 0208 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4520:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 282              		.loc 1 4520 0
 283 020c 3C9084E5 		str	r9, [r4, #60]
4521:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 284              		.loc 1 4521 0
 285 0210 23005CE3 		cmp	ip, #35
4522:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 286              		.loc 1 4522 0
 287 0214 24C04C82 		subhi	ip, ip, #36
 288 0218 8CC08C80 		addhi	ip, ip, ip, asl #1
4524:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 289              		.loc 1 4524 0
 290 021c 8CC08C90 		addls	ip, ip, ip, asl #1
4522:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 291              		.loc 1 4522 0
 292 0220 8CC18B80 		addhi	ip, fp, ip, asl #3
4524:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 293              		.loc 1 4524 0
 294 0224 8CC18B90 		addls	ip, fp, ip, asl #3
4522:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 295              		.loc 1 4522 0
 296 0228 1090CC85 		strhib	r9, [ip, #16]
4524:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 297              		.loc 1 4524 0
 298 022c 9091CC95 		strlsb	r9, [ip, #400]
4526:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 299              		.loc 1 4526 0
 300 0230 344094E5 		ldr	r4, [r4, #52]
 301              	.LVL31:
 302 0234 104085E5 		str	r4, [r5, #16]
 303 0238 DDFFFFEA 		b	.L19
 304              	.L26:
 305              		.align	2
 306              	.L25:
 307 023c 00000000 		.word	I2CCmdCb
 308 0240 00000000 		.word	I2CCmdTimer
 309 0244 00000000 		.word	.LC0
 310 0248 00000000 		.word	cmdQu
 311 024c 14000000 		.word	.LC1
 312 0250 00000000 		.word	statQu
 313 0254 00000000 		.word	.LANCHOR1
 314 0258 00000000 		.word	.LANCHOR0
 315              		.cfi_endproc
 316              	.LFE26:
 318              		.align	2
 319              		.global	I2CCmdCb
 321              	I2CCmdCb:
 322              	.LFB18:
2973:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 323              		.loc 1 2973 0
 324              		.cfi_startproc
 325              		@ args = 0, pretend = 0, frame = 0
 326              		@ frame_needed = 0, uses_anonymous_args = 0
 327              	.LVL32:
2974:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 328              		.loc 1 2974 0
 329 025c 28209FE5 		ldr	r2, .L28
2973:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 330              		.loc 1 2973 0
 331 0260 0030A0E1 		mov	r3, r0
 332 0264 10402DE9 		stmfd	sp!, {r4, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 8
2974:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 335              		.loc 1 2974 0
 336 0268 20109FE5 		ldr	r1, .L28+4
 337 026c 002092E5 		ldr	r2, [r2, #0]
 338 0270 0400A0E3 		mov	r0, #4
 339              	.LVL33:
 340              		.cfi_offset 14, -4
 341              		.cfi_offset 4, -8
 342 0274 FEFFFFEB 		bl	CyU3PDebugPrint
 343              	.LVL34:
2975:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 344              		.loc 1 2975 0
 345 0278 14009FE5 		ldr	r0, .L28+8
 346 027c 2010A0E3 		mov	r1, #32
 347 0280 0020A0E3 		mov	r2, #0
2976:../uvc.c      **** }
 348              		.loc 1 2976 0
 349 0284 1040BDE8 		ldmfd	sp!, {r4, lr}
2975:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 350              		.loc 1 2975 0
 351 0288 FEFFFFEA 		b	_txe_event_flags_set
 352              	.L29:
 353              		.align	2
 354              	.L28:
 355 028c 00000000 		.word	posTick
 356 0290 38000000 		.word	.LC2
 357 0294 00000000 		.word	.LANCHOR0
 358              		.cfi_endproc
 359              	.LFE18:
 361              		.align	2
 363              	CyFxUVCApplnUSBEventCB:
 364              	.LFB9:
2034:../uvc.c      **** {
 365              		.loc 1 2034 0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 8
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              	.LVL35:
2035:../uvc.c      ****     switch (evtype)
 370              		.loc 1 2035 0
 371 0298 020050E3 		cmp	r0, #2
2034:../uvc.c      **** {
 372              		.loc 1 2034 0
 373 029c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 374              	.LCFI3:
 375              		.cfi_def_cfa_offset 16
 376 02a0 0130A0E1 		mov	r3, r1
 377 02a4 10D04DE2 		sub	sp, sp, #16
 378              	.LCFI4:
 379              		.cfi_def_cfa_offset 32
2034:../uvc.c      **** {
 380              		.loc 1 2034 0
 381 02a8 0040A0E1 		mov	r4, r0
 382              		.cfi_offset 14, -4
 383              		.cfi_offset 6, -8
 384              		.cfi_offset 5, -12
 385              		.cfi_offset 4, -16
2035:../uvc.c      ****     switch (evtype)
 386              		.loc 1 2035 0
 387 02ac 3600000A 		beq	.L33
 388 02b0 040050E3 		cmp	r0, #4
 389 02b4 1F00000A 		beq	.L34
 390 02b8 010050E3 		cmp	r0, #1
 391 02bc 0100000A 		beq	.L36
 392              	.LVL36:
 393              	.L30:
2071:../uvc.c      **** }
 394              		.loc 1 2071 0
 395 02c0 10D08DE2 		add	sp, sp, #16
 396 02c4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 397              	.LVL37:
 398              	.L36:
2056:../uvc.c      ****             gpif_initialized = 0;
 399              		.loc 1 2056 0
 400 02c8 28519FE5 		ldr	r5, .L37
2054:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 401              		.loc 1 2054 0
 402 02cc 0020A0E1 		mov	r2, r0
 403 02d0 24119FE5 		ldr	r1, .L37+4
 404              	.LVL38:
 405 02d4 0400A0E3 		mov	r0, #4
 406              	.LVL39:
 407 02d8 FEFFFFEB 		bl	CyU3PDebugPrint
2055:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 408              		.loc 1 2055 0
 409 02dc 0400A0E1 		mov	r0, r4
 410 02e0 FEFFFFEB 		bl	CyU3PGpifDisable
2056:../uvc.c      ****             gpif_initialized = 0;
 411              		.loc 1 2056 0
 412 02e4 00C0A0E3 		mov	ip, #0
 413              	.LBB16:
 414              	.LBB17:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 415              		.loc 1 2018 0
 416 02e8 0410A0E1 		mov	r1, r4
 417 02ec 0500A0E1 		mov	r0, r5
 418 02f0 0220A0E3 		mov	r2, #2
 419 02f4 0C308DE2 		add	r3, sp, #12
 420              	.LBE17:
 421              	.LBE16:
2056:../uvc.c      ****             gpif_initialized = 0;
 422              		.loc 1 2056 0
 423 02f8 28C085E5 		str	ip, [r5, #40]
2057:../uvc.c      ****             isUsbConnected = CyFalse;
 424              		.loc 1 2057 0
 425 02fc 30C085E5 		str	ip, [r5, #48]
2058:../uvc.c      ****             streamingStarted = CyFalse;
 426              		.loc 1 2058 0
 427 0300 2CC085E5 		str	ip, [r5, #44]
 428              	.LBB19:
 429              	.LBB18:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 430              		.loc 1 2018 0
 431 0304 00C08DE5 		str	ip, [sp, #0]
 432 0308 FEFFFFEB 		bl	_txe_event_flags_get
 433 030c 004050E2 		subs	r4, r0, #0
 434 0310 EAFFFF1A 		bne	.L30
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 435              		.loc 1 2021 0
 436 0314 0110E0E3 		mvn	r1, #1
 437 0318 0220A0E3 		mov	r2, #2
 438 031c 0500A0E1 		mov	r0, r5
 439              	.L35:
 440 0320 FEFFFFEB 		bl	_txe_event_flags_set
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 441              		.loc 1 2024 0
 442 0324 0500A0E1 		mov	r0, r5
 443 0328 0210A0E3 		mov	r1, #2
 444 032c 0420A0E1 		mov	r2, r4
 445 0330 FEFFFFEB 		bl	_txe_event_flags_set
 446 0334 E1FFFFEA 		b	.L30
 447              	.LVL40:
 448              	.L34:
 449              	.LBE18:
 450              	.LBE19:
2040:../uvc.c      ****             gpif_initialized = 0;
 451              		.loc 1 2040 0
 452 0338 B8509FE5 		ldr	r5, .L37
2038:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 453              		.loc 1 2038 0
 454 033c BC109FE5 		ldr	r1, .L37+8
 455              	.LVL41:
 456 0340 0020A0E1 		mov	r2, r0
 457 0344 FEFFFFEB 		bl	CyU3PDebugPrint
 458              	.LVL42:
2039:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 459              		.loc 1 2039 0
 460 0348 0100A0E3 		mov	r0, #1
 461 034c FEFFFFEB 		bl	CyU3PGpifDisable
2040:../uvc.c      ****             gpif_initialized = 0;
 462              		.loc 1 2040 0
 463 0350 00C0A0E3 		mov	ip, #0
 464              	.LBB20:
 465              	.LBB21:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 466              		.loc 1 2018 0
 467 0354 0110A0E3 		mov	r1, #1
 468 0358 0220A0E3 		mov	r2, #2
 469 035c 0500A0E1 		mov	r0, r5
 470 0360 0C308DE2 		add	r3, sp, #12
 471              	.LBE21:
 472              	.LBE20:
2040:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 2040 0
 474 0364 28C085E5 		str	ip, [r5, #40]
2041:../uvc.c      ****             streamingStarted = CyFalse;
 475              		.loc 1 2041 0
 476 0368 2CC085E5 		str	ip, [r5, #44]
 477              	.LBB23:
 478              	.LBB22:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 479              		.loc 1 2018 0
 480 036c 00C08DE5 		str	ip, [sp, #0]
 481 0370 FEFFFFEB 		bl	_txe_event_flags_get
 482 0374 004050E2 		subs	r4, r0, #0
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 483              		.loc 1 2021 0
 484 0378 0500A001 		moveq	r0, r5
 485 037c 0110E003 		mvneq	r1, #1
 486 0380 0220A003 		moveq	r2, #2
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 487              		.loc 1 2018 0
 488 0384 CDFFFF1A 		bne	.L30
 489 0388 E4FFFFEA 		b	.L35
 490              	.LVL43:
 491              	.L33:
 492              	.LBE22:
 493              	.LBE23:
2048:../uvc.c      ****             gpif_initialized = 0;
 494              		.loc 1 2048 0
 495 038c 64509FE5 		ldr	r5, .L37
2046:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 496              		.loc 1 2046 0
 497 0390 0020A0E1 		mov	r2, r0
 498 0394 68109FE5 		ldr	r1, .L37+12
 499              	.LVL44:
 500 0398 0400A0E3 		mov	r0, #4
 501              	.LVL45:
 502 039c FEFFFFEB 		bl	CyU3PDebugPrint
2047:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 503              		.loc 1 2047 0
 504 03a0 0100A0E3 		mov	r0, #1
 505 03a4 FEFFFFEB 		bl	CyU3PGpifDisable
2048:../uvc.c      ****             gpif_initialized = 0;
 506              		.loc 1 2048 0
 507 03a8 0060A0E3 		mov	r6, #0
 508              	.LBB24:
 509              	.LBB25:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 510              		.loc 1 2018 0
 511 03ac 0500A0E1 		mov	r0, r5
 512 03b0 0110A0E3 		mov	r1, #1
 513 03b4 0420A0E1 		mov	r2, r4
 514 03b8 0C308DE2 		add	r3, sp, #12
 515              	.LBE25:
 516              	.LBE24:
2048:../uvc.c      ****             gpif_initialized = 0;
 517              		.loc 1 2048 0
 518 03bc 286085E5 		str	r6, [r5, #40]
2049:../uvc.c      ****             streamingStarted = CyFalse;
 519              		.loc 1 2049 0
 520 03c0 2C6085E5 		str	r6, [r5, #44]
 521              	.LBB27:
 522              	.LBB26:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 523              		.loc 1 2018 0
 524 03c4 00608DE5 		str	r6, [sp, #0]
 525 03c8 FEFFFFEB 		bl	_txe_event_flags_get
 526 03cc 006050E2 		subs	r6, r0, #0
 527 03d0 BAFFFF1A 		bne	.L30
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 528              		.loc 1 2021 0
 529 03d4 0420A0E1 		mov	r2, r4
 530 03d8 0500A0E1 		mov	r0, r5
 531 03dc 0110E0E3 		mvn	r1, #1
 532 03e0 FEFFFFEB 		bl	_txe_event_flags_set
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 533              		.loc 1 2024 0
 534 03e4 0500A0E1 		mov	r0, r5
 535 03e8 0410A0E1 		mov	r1, r4
 536 03ec 0620A0E1 		mov	r2, r6
 537 03f0 FEFFFFEB 		bl	_txe_event_flags_set
 538 03f4 B1FFFFEA 		b	.L30
 539              	.L38:
 540              		.align	2
 541              	.L37:
 542 03f8 00000000 		.word	.LANCHOR0
 543 03fc 94000000 		.word	.LC5
 544 0400 50000000 		.word	.LC3
 545 0404 70000000 		.word	.LC4
 546              	.LBE26:
 547              	.LBE27:
 548              		.cfi_endproc
 549              	.LFE9:
 551              		.align	2
 552              		.global	CyFxUvcApplnDmaCallback
 554              	CyFxUvcApplnDmaCallback:
 555              	.LFB11:
2231:../uvc.c      **** {
 556              		.loc 1 2231 0
 557              		.cfi_startproc
 558              		@ args = 0, pretend = 0, frame = 0
 559              		@ frame_needed = 0, uses_anonymous_args = 0
 560              	.LVL46:
2238:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 561              		.loc 1 2238 0
 562 0408 080051E3 		cmp	r1, #8
2231:../uvc.c      **** {
 563              		.loc 1 2231 0
 564 040c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 565              	.LCFI5:
 566              		.cfi_def_cfa_offset 20
 567 0410 0250A0E1 		mov	r5, r2
 568              		.cfi_offset 14, -4
 569              		.cfi_offset 7, -8
 570              		.cfi_offset 6, -12
 571              		.cfi_offset 5, -16
 572              		.cfi_offset 4, -20
 573 0414 0CD04DE2 		sub	sp, sp, #12
 574              	.LCFI6:
 575              		.cfi_def_cfa_offset 32
2238:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 576              		.loc 1 2238 0
 577 0418 0B00000A 		beq	.L45
2290:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 578              		.loc 1 2290 0
 579 041c 100051E3 		cmp	r1, #16
 580 0420 0700001A 		bne	.L39
2292:../uvc.c      ****         consCount++;
 581              		.loc 1 2292 0
 582 0424 7C319FE5 		ldr	r3, .L48
2293:../uvc.c      ****         streamingStarted = CyTrue;
 583              		.loc 1 2293 0
 584 0428 0120A0E3 		mov	r2, #1
 585              	.LVL47:
2292:../uvc.c      ****         consCount++;
 586              		.loc 1 2292 0
 587 042c B204D3E1 		ldrh	r0, [r3, #66]
 588              	.LVL48:
2293:../uvc.c      ****         streamingStarted = CyTrue;
 589              		.loc 1 2293 0
 590 0430 2C2083E5 		str	r2, [r3, #44]
2292:../uvc.c      ****         consCount++;
 591              		.loc 1 2292 0
 592 0434 02C080E0 		add	ip, r0, r2
 593 0438 0C18A0E1 		mov	r1, ip, asl #16
 594              	.LVL49:
 595 043c 2128A0E1 		mov	r2, r1, lsr #16
 596 0440 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 597              	.L39:
2295:../uvc.c      **** }
 598              		.loc 1 2295 0
 599 0444 0CD08DE2 		add	sp, sp, #12
 600 0448 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 601              	.LVL50:
 602              	.L45:
2240:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 603              		.loc 1 2240 0
 604 044c B420D2E1 		ldrh	r2, [r2, #4]
 605 0450 54319FE5 		ldr	r3, .L48+4
 606 0454 030052E1 		cmp	r2, r3
 607 0458 3500000A 		beq	.L46
2260:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 608              		.loc 1 2260 0
 609 045c 006095E5 		ldr	r6, [r5, #0]
 610              	.LBB32:
 611              	.LBB34:
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 612              		.loc 1 1979 0
 613 0460 48719FE5 		ldr	r7, .L48+8
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 614              		.loc 1 1978 0
 615 0464 0010E0E3 		mvn	r1, #0
 616              	.LVL51:
 617              	.LBE34:
 618              	.LBE32:
2260:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 619              		.loc 1 2260 0
 620 0468 0C4046E2 		sub	r4, r6, #12
 621              	.LVL52:
 622              	.LBB36:
 623              	.LBB33:
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 624              		.loc 1 1978 0
 625 046c 40019FE5 		ldr	r0, .L48+12
 626              	.LVL53:
 627 0470 FEFFFFEB 		bl	_txe_mutex_get
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 628              		.loc 1 1979 0
 629 0474 0400A0E1 		mov	r0, r4
 630 0478 121D87E2 		add	r1, r7, #1152
 631 047c 0C20A0E3 		mov	r2, #12
 632 0480 FEFFFFEB 		bl	CyU3PMemCopy
1980:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 633              		.loc 1 1980 0
 634 0484 28019FE5 		ldr	r0, .L48+12
 635 0488 FEFFFFEB 		bl	_txe_mutex_put
1985:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 636              		.loc 1 1985 0
 637 048c 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 638              	.LBE33:
 639              	.LBE36:
2261:../uvc.c      ****                 pb++;
 640              		.loc 1 2261 0
 641 0490 10419FE5 		ldr	r4, .L48
 642              	.LVL54:
 643              	.LBB37:
 644              	.LBB35:
1985:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 645              		.loc 1 1985 0
 646 0494 02108CE3 		orr	r1, ip, #2
 647 0498 0B1046E5 		strb	r1, [r6, #-11]
 648              	.LBE35:
 649              	.LBE37:
2261:../uvc.c      ****                 pb++;
 650              		.loc 1 2261 0
 651 049c B603D4E1 		ldrh	r0, [r4, #54]
2267:../uvc.c      ****                 if(stiflag == 0x0F){
 652              		.loc 1 2267 0
 653 04a0 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
2262:../uvc.c      ****                 pbc = input->buffer_p.count;
 654              		.loc 1 2262 0
 655 04a4 B410D5E1 		ldrh	r1, [r5, #4]
2261:../uvc.c      ****                 pb++;
 656              		.loc 1 2261 0
 657 04a8 013080E2 		add	r3, r0, #1
2267:../uvc.c      ****                 if(stiflag == 0x0F){
 658              		.loc 1 2267 0
 659 04ac 0F0052E3 		cmp	r2, #15
2261:../uvc.c      ****                 pb++;
 660              		.loc 1 2261 0
 661 04b0 B633C4E1 		strh	r3, [r4, #54]	@ movhi
2262:../uvc.c      ****                 pbc = input->buffer_p.count;
 662              		.loc 1 2262 0
 663 04b4 B813C4E1 		strh	r1, [r4, #56]	@ movhi
2267:../uvc.c      ****                 if(stiflag == 0x0F){
 664              		.loc 1 2267 0
 665 04b8 2E00000A 		beq	.L47
 666              	.L43:
2274:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 667              		.loc 1 2274 0
 668 04bc 01E0A0E3 		mov	lr, #1
 669 04c0 3CE084E5 		str	lr, [r4, #60]
 670              	.LVL55:
 671              	.L42:
2278:../uvc.c      ****             prodCount++;
 672              		.loc 1 2278 0
 673 04c4 B0E4D4E1 		ldrh	lr, [r4, #64]
2279:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 674              		.loc 1 2279 0
 675 04c8 0C1081E2 		add	r1, r1, #12
2278:../uvc.c      ****             prodCount++;
 676              		.loc 1 2278 0
 677 04cc 01308EE2 		add	r3, lr, #1
 678 04d0 0308A0E1 		mov	r0, r3, asl #16
 679 04d4 20C8A0E1 		mov	ip, r0, lsr #16
2279:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 680              		.loc 1 2279 0
 681 04d8 0128A0E1 		mov	r2, r1, asl #16
 682 04dc 2218A0E1 		mov	r1, r2, lsr #16
 683 04e0 D0009FE5 		ldr	r0, .L48+16
 684 04e4 0020A0E3 		mov	r2, #0
2278:../uvc.c      ****             prodCount++;
 685              		.loc 1 2278 0
 686 04e8 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
2279:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 687              		.loc 1 2279 0
 688 04ec FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 689              	.LVL56:
2278:../uvc.c      ****             prodCount++;
 690              		.loc 1 2278 0
 691 04f0 B0109FE5 		ldr	r1, .L48
2282:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 692              		.loc 1 2282 0
 693 04f4 002050E2 		subs	r2, r0, #0
 694 04f8 D1FFFF0A 		beq	.L39
2284:../uvc.c      ****                 prodCount--;
 695              		.loc 1 2284 0
 696 04fc B004D1E1 		ldrh	r0, [r1, #64]
 697              	.LVL57:
2285:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 698              		.loc 1 2285 0
 699 0500 B430D5E1 		ldrh	r3, [r5, #4]
2284:../uvc.c      ****                 prodCount--;
 700              		.loc 1 2284 0
 701 0504 01E040E2 		sub	lr, r0, #1
 702 0508 0EC8A0E1 		mov	ip, lr, asl #16
 703 050c 2C08A0E1 		mov	r0, ip, lsr #16
 704 0510 B004C1E1 		strh	r0, [r1, #64]	@ movhi
2285:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 705              		.loc 1 2285 0
 706 0514 B0E4D1E1 		ldrh	lr, [r1, #64]
 707 0518 B2C4D1E1 		ldrh	ip, [r1, #66]
 708 051c 0400A0E3 		mov	r0, #4
 709 0520 94109FE5 		ldr	r1, .L48+20
 710 0524 00E08DE5 		str	lr, [sp, #0]
 711 0528 04C08DE5 		str	ip, [sp, #4]
 712 052c FEFFFFEB 		bl	CyU3PDebugPrint
 713              	.LVL58:
 714 0530 C3FFFFEA 		b	.L39
 715              	.LVL59:
 716              	.L46:
2254:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 717              		.loc 1 2254 0
 718 0534 006095E5 		ldr	r6, [r5, #0]
 719              	.LBB38:
 720              	.LBB39:
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 721              		.loc 1 1978 0
 722 0538 0010E0E3 		mvn	r1, #0
 723              	.LVL60:
 724              	.LBE39:
 725              	.LBE38:
2255:../uvc.c      ****                 fb++;
 726              		.loc 1 2255 0
 727 053c 64409FE5 		ldr	r4, .L48
2254:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 728              		.loc 1 2254 0
 729 0540 0C6046E2 		sub	r6, r6, #12
 730              	.LVL61:
 731              	.LBB41:
 732              	.LBB40:
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 733              		.loc 1 1978 0
 734 0544 68009FE5 		ldr	r0, .L48+12
 735              	.LVL62:
 736 0548 FEFFFFEB 		bl	_txe_mutex_get
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 737              		.loc 1 1979 0
 738 054c 6C109FE5 		ldr	r1, .L48+24
 739 0550 0600A0E1 		mov	r0, r6
 740 0554 0C20A0E3 		mov	r2, #12
 741 0558 FEFFFFEB 		bl	CyU3PMemCopy
1980:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 742              		.loc 1 1980 0
 743 055c 50009FE5 		ldr	r0, .L48+12
 744 0560 FEFFFFEB 		bl	_txe_mutex_put
 745              	.LBE40:
 746              	.LBE41:
2255:../uvc.c      ****                 fb++;
 747              		.loc 1 2255 0
 748 0564 B4C3D4E1 		ldrh	ip, [r4, #52]
 749 0568 B410D5E1 		ldrh	r1, [r5, #4]
 750 056c 01008CE2 		add	r0, ip, #1
 751 0570 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 752 0574 D2FFFFEA 		b	.L42
 753              	.LVL63:
 754              	.L47:
2268:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 755              		.loc 1 2268 0
 756 0578 0010E0E3 		mvn	r1, #0
 757 057c 30009FE5 		ldr	r0, .L48+12
 758 0580 FEFFFFEB 		bl	_txe_mutex_get
2269:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 759              		.loc 1 2269 0
 760 0584 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2270:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 761              		.loc 1 2270 0
 762 0588 24009FE5 		ldr	r0, .L48+12
2269:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 763              		.loc 1 2269 0
 764 058c DF2001E2 		and	r2, r1, #223
 765 0590 8124C7E5 		strb	r2, [r7, #1153]
2270:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 766              		.loc 1 2270 0
 767 0594 FEFFFFEB 		bl	_txe_mutex_put
2271:../uvc.c      ****                 	stiflag = 0xAA;
 768              		.loc 1 2271 0
 769 0598 5530E0E3 		mvn	r3, #85
 770 059c 3A30C4E5 		strb	r3, [r4, #58]
 771 05a0 B410D5E1 		ldrh	r1, [r5, #4]
 772 05a4 C4FFFFEA 		b	.L43
 773              	.L49:
 774              		.align	2
 775              	.L48:
 776 05a8 00000000 		.word	.LANCHOR0
 777 05ac F03F0000 		.word	16368
 778 05b0 00000000 		.word	.LANCHOR1
 779 05b4 00000000 		.word	imgHdMux
 780 05b8 00000000 		.word	glChHandleUVCStream
 781 05bc B4000000 		.word	.LC6
 782 05c0 80040000 		.word	.LANCHOR1+1152
 783              		.cfi_endproc
 784              	.LFE11:
 786              		.align	2
 788              	CyFxUVCApplnUSBSetupCB:
 789              	.LFB10:
2079:../uvc.c      **** {
 790              		.loc 1 2079 0
 791              		.cfi_startproc
 792              		@ args = 0, pretend = 0, frame = 8
 793              		@ frame_needed = 0, uses_anonymous_args = 0
 794              	.LVL64:
2084:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 795              		.loc 1 2084 0
 796 05c4 C0329FE5 		ldr	r3, .L75
2079:../uvc.c      **** {
 797              		.loc 1 2079 0
 798 05c8 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 799              	.LCFI7:
 800              		.cfi_def_cfa_offset 24
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 801              		.loc 1 2085 0
 802 05cc BCC29FE5 		ldr	ip, .L75+4
2084:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 803              		.loc 1 2084 0
 804 05d0 FF4000E2 		and	r4, r0, #255
 805              		.cfi_offset 14, -4
 806              		.cfi_offset 8, -8
 807              		.cfi_offset 7, -12
 808              		.cfi_offset 6, -16
 809              		.cfi_offset 5, -20
 810              		.cfi_offset 4, -24
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 811              		.loc 1 2085 0
 812 05d4 FF8C00E2 		and	r8, r0, #65280
2086:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 813              		.loc 1 2086 0
 814 05d8 2078A0E1 		mov	r7, r0, lsr #16
2084:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 815              		.loc 1 2084 0
 816 05dc 0040C3E5 		strb	r4, [r3, #0]
2086:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 817              		.loc 1 2086 0
 818 05e0 AC229FE5 		ldr	r2, .L75+8
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 819              		.loc 1 2087 0
 820 05e4 AC029FE5 		ldr	r0, .L75+12
 821              	.LVL65:
2088:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 822              		.loc 1 2088 0
 823 05e8 AC329FE5 		ldr	r3, .L75+16
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 824              		.loc 1 2087 0
 825 05ec 0158A0E1 		mov	r5, r1, asl #16
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 826              		.loc 1 2085 0
 827 05f0 2884A0E1 		mov	r8, r8, lsr #8
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 828              		.loc 1 2087 0
 829 05f4 2558A0E1 		mov	r5, r5, lsr #16
2088:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 830              		.loc 1 2088 0
 831 05f8 2118A0E1 		mov	r1, r1, lsr #16
 832              	.LVL66:
2091:../uvc.c      ****     switch (bmReqType)
 833              		.loc 1 2091 0
 834 05fc 020054E3 		cmp	r4, #2
2079:../uvc.c      **** {
 835              		.loc 1 2079 0
 836 0600 10D04DE2 		sub	sp, sp, #16
 837              	.LCFI8:
 838              		.cfi_def_cfa_offset 40
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 839              		.loc 1 2085 0
 840 0604 0080CCE5 		strb	r8, [ip, #0]
2086:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 841              		.loc 1 2086 0
 842 0608 B070C2E1 		strh	r7, [r2, #0]	@ movhi
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 843              		.loc 1 2087 0
 844 060c B050C0E1 		strh	r5, [r0, #0]	@ movhi
2088:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 845              		.loc 1 2088 0
 846 0610 B010C3E1 		strh	r1, [r3, #0]	@ movhi
2091:../uvc.c      ****     switch (bmReqType)
 847              		.loc 1 2091 0
 848 0614 4F00000A 		beq	.L53
 849 0618 0600009A 		bls	.L71
 850 061c 210054E3 		cmp	r4, #33
 851 0620 3A00000A 		beq	.L54
 852 0624 A10054E3 		cmp	r4, #161
 853 0628 3800000A 		beq	.L54
 854              	.L68:
2080:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 855              		.loc 1 2080 0
 856 062c 0000A0E3 		mov	r0, #0
 857              	.LVL67:
 858              	.L51:
2218:../uvc.c      **** }
 859              		.loc 1 2218 0
 860 0630 10D08DE2 		add	sp, sp, #16
 861 0634 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 862              	.LVL68:
 863              	.L71:
2091:../uvc.c      ****     switch (bmReqType)
 864              		.loc 1 2091 0
 865 0638 010054E3 		cmp	r4, #1
 866 063c FAFFFF1A 		bne	.L68
2131:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 867              		.loc 1 2131 0
 868 0640 0B0058E3 		cmp	r8, #11
 869 0644 F8FFFF1A 		bne	.L68
2135:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 870              		.loc 1 2135 0
 871 0648 010055E3 		cmp	r5, #1
 872 064c F6FFFF1A 		bne	.L68
2135:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 873              		.loc 1 2135 0 is_stmt 0 discriminator 1
 874 0650 000057E3 		cmp	r7, #0
 875 0654 F4FFFF1A 		bne	.L68
2140:../uvc.c      ****                     gpif_initialized = 0;
 876              		.loc 1 2140 0 is_stmt 1
 877 0658 40429FE5 		ldr	r4, .L75+20
2138:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 878              		.loc 1 2138 0
 879 065c 40129FE5 		ldr	r1, .L75+24
 880 0660 0400A0E3 		mov	r0, #4
 881 0664 FEFFFFEB 		bl	CyU3PDebugPrint
2139:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 882              		.loc 1 2139 0
 883 0668 0500A0E1 		mov	r0, r5
 884 066c FEFFFFEB 		bl	CyU3PGpifDisable
2143:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 885              		.loc 1 2143 0
 886 0670 0510A0E1 		mov	r1, r5
 887 0674 8300A0E3 		mov	r0, #131
2140:../uvc.c      ****                     gpif_initialized = 0;
 888              		.loc 1 2140 0
 889 0678 287084E5 		str	r7, [r4, #40]
2141:../uvc.c      ****                     streamingStarted = CyFalse;
 890              		.loc 1 2141 0
 891 067c 2C7084E5 		str	r7, [r4, #44]
2143:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 892              		.loc 1 2143 0
 893 0680 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2144:../uvc.c      ****                     CyU3PBusyWait (100);
 894              		.loc 1 2144 0
 895 0684 6400A0E3 		mov	r0, #100
 896 0688 FEFFFFEB 		bl	CyU3PBusyWait
2147:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 897              		.loc 1 2147 0
 898 068c 14029FE5 		ldr	r0, .L75+28
 899 0690 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2148:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 900              		.loc 1 2148 0
 901 0694 8300A0E3 		mov	r0, #131
 902 0698 FEFFFFEB 		bl	CyU3PUsbFlushEp
2149:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 903              		.loc 1 2149 0
 904 069c 0710A0E1 		mov	r1, r7
 905 06a0 8300A0E3 		mov	r0, #131
 906 06a4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2150:../uvc.c      ****                     CyU3PBusyWait (100);
 907              		.loc 1 2150 0
 908 06a8 6400A0E3 		mov	r0, #100
 909 06ac FEFFFFEB 		bl	CyU3PBusyWait
2153:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 910              		.loc 1 2153 0
 911 06b0 0710A0E1 		mov	r1, r7
 912 06b4 0520A0E1 		mov	r2, r5
 913 06b8 8300A0E3 		mov	r0, #131
 914 06bc FEFFFFEB 		bl	CyU3PUsbStall
 915              	.LVL69:
2156:../uvc.c      ****                     CyU3PUsbAckSetup ();
 916              		.loc 1 2156 0
 917 06c0 FEFFFFEB 		bl	CyU3PUsbAckSetup
2158:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 918              		.loc 1 2158 0
 919 06c4 445084E5 		str	r5, [r4, #68]
 920              	.LBB46:
 921              	.LBB47:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 922              		.loc 1 2018 0
 923 06c8 0400A0E1 		mov	r0, r4
 924 06cc 0510A0E1 		mov	r1, r5
 925 06d0 0220A0E3 		mov	r2, #2
 926 06d4 0C308DE2 		add	r3, sp, #12
 927 06d8 00708DE5 		str	r7, [sp, #0]
 928 06dc FEFFFFEB 		bl	_txe_event_flags_get
 929 06e0 006050E2 		subs	r6, r0, #0
 930 06e4 2E00001A 		bne	.L66
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 931              		.loc 1 2021 0
 932 06e8 0110E0E3 		mvn	r1, #1
 933 06ec 0220A0E3 		mov	r2, #2
 934 06f0 0400A0E1 		mov	r0, r4
 935 06f4 FEFFFFEB 		bl	_txe_event_flags_set
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 936              		.loc 1 2024 0
 937 06f8 0400A0E1 		mov	r0, r4
 938 06fc 0210A0E3 		mov	r1, #2
 939 0700 0620A0E1 		mov	r2, r6
 940 0704 FEFFFFEB 		bl	_txe_event_flags_set
2154:../uvc.c      ****                     uvcHandleReq = CyTrue;
 941              		.loc 1 2154 0
 942 0708 0500A0E1 		mov	r0, r5
 943 070c C7FFFFEA 		b	.L51
 944              	.LVL70:
 945              	.L54:
 946              	.LBE47:
 947              	.LBE46:
2096:../uvc.c      ****             switch (wIndex & 0xFF)
 948              		.loc 1 2096 0
 949 0710 FF5015E2 		ands	r5, r5, #255
 950 0714 1A00001A 		bne	.L72
 951              	.LVL71:
2101:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 952              		.loc 1 2101 0
 953 0718 0520A0E1 		mov	r2, r5
 954 071c 7C019FE5 		ldr	r0, .L75+20
 955 0720 0410A0E3 		mov	r1, #4
 956 0724 FEFFFFEB 		bl	_txe_event_flags_set
 957              	.LVL72:
2103:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 958              		.loc 1 2103 0
 959 0728 002050E2 		subs	r2, r0, #0
2100:../uvc.c      ****                         uvcHandleReq = CyTrue;
 960              		.loc 1 2100 0
 961 072c 0100A003 		moveq	r0, #1
 962              	.LVL73:
2103:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 963              		.loc 1 2103 0
 964 0730 BEFFFF0A 		beq	.L51
2105:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 965              		.loc 1 2105 0
 966 0734 70119FE5 		ldr	r1, .L75+32
 967 0738 0400A0E3 		mov	r0, #4
 968 073c FEFFFFEB 		bl	CyU3PDebugPrint
 969              	.LVL74:
2106:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 970              		.loc 1 2106 0
 971 0740 0500A0E1 		mov	r0, r5
 972 0744 0110A0E3 		mov	r1, #1
 973 0748 0520A0E1 		mov	r2, r5
 974 074c FEFFFFEB 		bl	CyU3PUsbStall
2100:../uvc.c      ****                         uvcHandleReq = CyTrue;
 975              		.loc 1 2100 0
 976 0750 0100A0E3 		mov	r0, #1
 977 0754 B5FFFFEA 		b	.L51
 978              	.LVL75:
 979              	.L53:
2166:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 980              		.loc 1 2166 0
 981 0758 010058E3 		cmp	r8, #1
 982 075c B2FFFF1A 		bne	.L68
2168:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 983              		.loc 1 2168 0
 984 0760 830055E3 		cmp	r5, #131
 985 0764 B0FFFF1A 		bne	.L68
2174:../uvc.c      ****                     if (streamingStarted == CyTrue)
 986              		.loc 1 2174 0
 987 0768 30719FE5 		ldr	r7, .L75+20
 988 076c 2C6097E5 		ldr	r6, [r7, #44]
 989 0770 010056E3 		cmp	r6, #1
 990 0774 1500000A 		beq	.L73
 991              	.LVL76:
2206:../uvc.c      ****                         CyU3PUsbAckSetup ();
 992              		.loc 1 2206 0
 993 0778 FEFFFFEB 		bl	CyU3PUsbAckSetup
2205:../uvc.c      ****                         uvcHandleReq = CyTrue;
 994              		.loc 1 2205 0
 995 077c 0800A0E1 		mov	r0, r8
 996 0780 AAFFFFEA 		b	.L51
 997              	.LVL77:
 998              	.L72:
2096:../uvc.c      ****             switch (wIndex & 0xFF)
 999              		.loc 1 2096 0
 1000 0784 010055E3 		cmp	r5, #1
 1001 0788 A7FFFF1A 		bne	.L68
 1002              	.LVL78:
2114:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1003              		.loc 1 2114 0
 1004 078c 0020A0E3 		mov	r2, #0
 1005 0790 08019FE5 		ldr	r0, .L75+20
 1006 0794 0810A0E3 		mov	r1, #8
 1007 0798 FEFFFFEB 		bl	_txe_event_flags_set
 1008              	.LVL79:
2116:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1009              		.loc 1 2116 0
 1010 079c 002050E2 		subs	r2, r0, #0
 1011 07a0 0100001A 		bne	.L74
 1012              	.LVL80:
 1013              	.L66:
 1014              	.LBB49:
 1015              	.LBB48:
2154:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1016              		.loc 1 2154 0
 1017 07a4 0500A0E1 		mov	r0, r5
 1018 07a8 A0FFFFEA 		b	.L51
 1019              	.LVL81:
 1020              	.L74:
 1021              	.LBE48:
 1022              	.LBE49:
2119:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1023              		.loc 1 2119 0
 1024 07ac FC109FE5 		ldr	r1, .L75+36
 1025 07b0 0400A0E3 		mov	r0, #4
 1026              	.LVL82:
 1027 07b4 FEFFFFEB 		bl	CyU3PDebugPrint
 1028              	.LVL83:
2120:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1029              		.loc 1 2120 0
 1030 07b8 0000A0E3 		mov	r0, #0
 1031 07bc 0510A0E1 		mov	r1, r5
 1032 07c0 0020A0E1 		mov	r2, r0
 1033 07c4 FEFFFFEB 		bl	CyU3PUsbStall
2113:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1034              		.loc 1 2113 0
 1035 07c8 0500A0E1 		mov	r0, r5
 1036 07cc 97FFFFEA 		b	.L51
 1037              	.LVL84:
 1038              	.L73:
2176:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1039              		.loc 1 2176 0
 1040 07d0 DC109FE5 		ldr	r1, .L75+40
 1041 07d4 0400A0E3 		mov	r0, #4
 1042 07d8 FEFFFFEB 		bl	CyU3PDebugPrint
2180:../uvc.c      ****                         gpif_initialized = 0;
 1043              		.loc 1 2180 0
 1044 07dc 0080A0E3 		mov	r8, #0
2179:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1045              		.loc 1 2179 0
 1046 07e0 0600A0E1 		mov	r0, r6
 1047 07e4 FEFFFFEB 		bl	CyU3PGpifDisable
2184:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1048              		.loc 1 2184 0
 1049 07e8 0610A0E1 		mov	r1, r6
 1050 07ec 0500A0E1 		mov	r0, r5
2180:../uvc.c      ****                         gpif_initialized = 0;
 1051              		.loc 1 2180 0
 1052 07f0 288087E5 		str	r8, [r7, #40]
2181:../uvc.c      ****                         streamingStarted = CyFalse;
 1053              		.loc 1 2181 0
 1054 07f4 2C8087E5 		str	r8, [r7, #44]
2184:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1055              		.loc 1 2184 0
 1056 07f8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2185:../uvc.c      ****                         CyU3PBusyWait (100);
 1057              		.loc 1 2185 0
 1058 07fc 6400A0E3 		mov	r0, #100
 1059 0800 FEFFFFEB 		bl	CyU3PBusyWait
2188:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1060              		.loc 1 2188 0
 1061 0804 9C009FE5 		ldr	r0, .L75+28
 1062 0808 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2189:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1063              		.loc 1 2189 0
 1064 080c 0500A0E1 		mov	r0, r5
 1065 0810 FEFFFFEB 		bl	CyU3PUsbFlushEp
2190:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1066              		.loc 1 2190 0
 1067 0814 0810A0E1 		mov	r1, r8
 1068 0818 0500A0E1 		mov	r0, r5
 1069 081c FEFFFFEB 		bl	CyU3PUsbSetEpNak
2191:../uvc.c      ****                         CyU3PBusyWait (100);
 1070              		.loc 1 2191 0
 1071 0820 6400A0E3 		mov	r0, #100
 1072 0824 FEFFFFEB 		bl	CyU3PBusyWait
2194:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1073              		.loc 1 2194 0
 1074 0828 0810A0E1 		mov	r1, r8
 1075 082c 0620A0E1 		mov	r2, r6
 1076 0830 0500A0E1 		mov	r0, r5
 1077 0834 FEFFFFEB 		bl	CyU3PUsbStall
 1078              	.LVL85:
2198:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1079              		.loc 1 2198 0
 1080 0838 FEFFFFEB 		bl	CyU3PUsbAckSetup
2200:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1081              		.loc 1 2200 0
 1082 083c 446087E5 		str	r6, [r7, #68]
 1083              	.LBB50:
 1084              	.LBB51:
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1085              		.loc 1 2018 0
 1086 0840 0700A0E1 		mov	r0, r7
 1087 0844 0610A0E1 		mov	r1, r6
 1088 0848 0420A0E1 		mov	r2, r4
 1089 084c 0C308DE2 		add	r3, sp, #12
 1090 0850 00808DE5 		str	r8, [sp, #0]
 1091 0854 FEFFFFEB 		bl	_txe_event_flags_get
 1092 0858 005050E2 		subs	r5, r0, #0
2196:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1093              		.loc 1 2196 0
 1094 085c 0600A011 		movne	r0, r6
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1095              		.loc 1 2018 0
 1096 0860 72FFFF1A 		bne	.L51
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1097              		.loc 1 2021 0
 1098 0864 0110E0E3 		mvn	r1, #1
 1099 0868 0420A0E1 		mov	r2, r4
 1100 086c 0700A0E1 		mov	r0, r7
 1101 0870 FEFFFFEB 		bl	_txe_event_flags_set
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1102              		.loc 1 2024 0
 1103 0874 0700A0E1 		mov	r0, r7
 1104 0878 0410A0E1 		mov	r1, r4
 1105 087c 0520A0E1 		mov	r2, r5
 1106 0880 FEFFFFEB 		bl	_txe_event_flags_set
2196:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1107              		.loc 1 2196 0
 1108 0884 0600A0E1 		mov	r0, r6
 1109 0888 68FFFFEA 		b	.L51
 1110              	.L76:
 1111              		.align	2
 1112              	.L75:
 1113 088c 00000000 		.word	bmReqType
 1114 0890 00000000 		.word	bRequest
 1115 0894 00000000 		.word	wValue
 1116 0898 00000000 		.word	wIndex
 1117 089c 00000000 		.word	wLength
 1118 08a0 00000000 		.word	.LANCHOR0
 1119 08a4 6C010000 		.word	.LC9
 1120 08a8 00000000 		.word	glChHandleUVCStream
 1121 08ac 00010000 		.word	.LC7
 1122 08b0 38010000 		.word	.LC8
 1123 08b4 84010000 		.word	.LC10
 1124              	.LBE51:
 1125              	.LBE50:
 1126              		.cfi_endproc
 1127              	.LFE10:
 1129              		.align	2
 1130              		.global	CyFxGpifCB
 1132              	CyFxGpifCB:
 1133              	.LFB13:
2417:../uvc.c      **** {
 1134              		.loc 1 2417 0
 1135              		.cfi_startproc
 1136              		@ args = 0, pretend = 0, frame = 0
 1137              		@ frame_needed = 0, uses_anonymous_args = 0
 1138              	.LVL86:
2418:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1139              		.loc 1 2418 0
 1140 08b8 010050E3 		cmp	r0, #1
2417:../uvc.c      **** {
 1141              		.loc 1 2417 0
 1142 08bc 10402DE9 		stmfd	sp!, {r4, lr}
 1143              	.LCFI9:
 1144              		.cfi_def_cfa_offset 8
2417:../uvc.c      **** {
 1145              		.loc 1 2417 0
 1146 08c0 0120A0E1 		mov	r2, r1
2418:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1147              		.loc 1 2418 0
 1148 08c4 1080BD18 		ldmnefd	sp!, {r4, pc}
 1149              		.cfi_offset 14, -4
 1150              		.cfi_offset 4, -8
 1151              	.LVL87:
 1152              	.LBB56:
 1153              	.LBB57:
2315:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1154              		.loc 1 2315 0
 1155 08c8 CC309FE5 		ldr	r3, .L92
 1156 08cc 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1157 08d0 030053E3 		cmp	r3, #3
 1158 08d4 2100000A 		beq	.L91
2341:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1159              		.loc 1 2341 0
 1160 08d8 020053E3 		cmp	r3, #2
 1161 08dc 1080BD18 		ldmnefd	sp!, {r4, pc}
2343:../uvc.c      ****         switch (stateId)
 1162              		.loc 1 2343 0
 1163 08e0 080041E2 		sub	r0, r1, #8
 1164              	.LVL88:
 1165 08e4 0A0050E3 		cmp	r0, #10
 1166 08e8 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1167 08ec 230000EA 		b	.L84
 1168              	.L86:
 1169 08f0 20090000 		.word	.L81
 1170 08f4 80090000 		.word	.L84
 1171 08f8 80090000 		.word	.L84
 1172 08fc 1C090000 		.word	.L77
 1173 0900 80090000 		.word	.L84
 1174 0904 80090000 		.word	.L84
 1175 0908 80090000 		.word	.L84
 1176 090c 58090000 		.word	.L90
 1177 0910 80090000 		.word	.L84
 1178 0914 80090000 		.word	.L84
 1179 0918 1C090000 		.word	.L77
 1180              	.LVL89:
 1181              	.L77:
 1182 091c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1183              	.LVL90:
 1184              	.L81:
2326:../uvc.c      ****                 socket = 0;
 1185              		.loc 1 2326 0
 1186 0920 0010A0E3 		mov	r1, #0
 1187              	.LVL91:
 1188              	.L82:
2400:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1189              		.loc 1 2400 0
 1190 0924 74009FE5 		ldr	r0, .L92+4
 1191 0928 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1192              	.LVL92:
2401:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1193              		.loc 1 2401 0
 1194 092c 002050E2 		subs	r2, r0, #0
 1195 0930 F9FFFF0A 		beq	.L77
2403:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1196              		.loc 1 2403 0
 1197 0934 0400A0E3 		mov	r0, #4
 1198              	.LVL93:
 1199 0938 64109FE5 		ldr	r1, .L92+8
 1200 093c FEFFFFEB 		bl	CyU3PDebugPrint
 1201              	.LVL94:
 1202              	.L87:
 1203              	.LBB58:
 1204              	.LBB59:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1205              		.loc 1 2005 0
 1206 0940 60109FE5 		ldr	r1, .L92+12
 1207 0944 0400A0E3 		mov	r0, #4
 1208 0948 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 1209              		.loc 1 2006 0
 1210 094c FA0FA0E3 		mov	r0, #1000
 1211 0950 FEFFFFEB 		bl	_tx_thread_sleep
 1212 0954 F9FFFFEA 		b	.L87
 1213              	.LVL95:
 1214              	.L90:
 1215              	.LBE59:
 1216              	.LBE58:
2370:../uvc.c      ****                 socket = 1;
 1217              		.loc 1 2370 0
 1218 0958 0110A0E3 		mov	r1, #1
 1219              	.LVL96:
 1220 095c F0FFFFEA 		b	.L82
 1221              	.LVL97:
 1222              	.L91:
2317:../uvc.c      ****         switch (stateId)
 1223              		.loc 1 2317 0
 1224 0960 0B2041E2 		sub	r2, r1, #11
 1225 0964 030052E3 		cmp	r2, #3
 1226 0968 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1227 096c 060000EA 		b	.L80
 1228              	.L83:
 1229 0970 20090000 		.word	.L81
 1230 0974 58090000 		.word	.L90
 1231 0978 1C090000 		.word	.L77
 1232 097c 1C090000 		.word	.L77
 1233              	.LVL98:
 1234              	.L84:
2389:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1235              		.loc 1 2389 0
 1236 0980 24109FE5 		ldr	r1, .L92+16
 1237              	.LVL99:
 1238 0984 0100A0E3 		mov	r0, #1
 1239 0988 FEFFFFEB 		bl	CyU3PDebugPrint
 1240              	.LVL100:
 1241              	.L80:
 1242              	.LBE57:
 1243              	.LBE56:
2424:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1244              		.loc 1 2424 0
 1245 098c 1C109FE5 		ldr	r1, .L92+20
 1246 0990 0400A0E3 		mov	r0, #4
2427:../uvc.c      **** }
 1247              		.loc 1 2427 0
 1248 0994 1040BDE8 		ldmfd	sp!, {r4, lr}
2424:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1249              		.loc 1 2424 0
 1250 0998 FEFFFFEA 		b	CyU3PDebugPrint
 1251              	.L93:
 1252              		.align	2
 1253              	.L92:
 1254 099c 00000000 		.word	.LANCHOR0
 1255 09a0 00000000 		.word	glChHandleUVCStream
 1256 09a4 C0010000 		.word	.LC12
 1257 09a8 F0010000 		.word	.LC13
 1258 09ac A8010000 		.word	.LC11
 1259 09b0 04020000 		.word	.LC14
 1260              		.cfi_endproc
 1261              	.LFE13:
 1263              		.align	2
 1264              		.global	I2CCmdHandler
 1266              	I2CCmdHandler:
 1267              	.LFB0:
 607:../uvc.c      **** void I2CCmdHandler(){
 1268              		.loc 1 607 0
 1269              		.cfi_startproc
 1270              		@ args = 0, pretend = 0, frame = 16
 1271              		@ frame_needed = 0, uses_anonymous_args = 0
 1272 09b4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1273              	.LCFI10:
 1274              		.cfi_def_cfa_offset 36
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1275              		.loc 1 610 0
 1276 09b8 40429FE5 		ldr	r4, .L109
 1277              		.cfi_offset 14, -4
 1278              		.cfi_offset 11, -8
 1279              		.cfi_offset 10, -12
 1280              		.cfi_offset 9, -16
 1281              		.cfi_offset 8, -20
 1282              		.cfi_offset 7, -24
 1283              		.cfi_offset 6, -28
 1284              		.cfi_offset 5, -32
 1285              		.cfi_offset 4, -36
 607:../uvc.c      **** void I2CCmdHandler(){
 1286              		.loc 1 607 0
 1287 09bc 3CD04DE2 		sub	sp, sp, #60
 1288              	.LCFI11:
 1289              		.cfi_def_cfa_offset 96
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1290              		.loc 1 615 0
 1291 09c0 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1292              		.loc 1 610 0
 1293 09c4 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1294              	.LVL101:
 611:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1295              		.loc 1 611 0
 1296 09c8 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1297              	.LVL102:
 612:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1298              		.loc 1 612 0
 1299 09cc 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1300              	.LVL103:
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1301              		.loc 1 615 0
 1302 09d0 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1303 09d4 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1304 09d8 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1305 09dc 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1306 09e0 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1307 09e4 14208DE5 		str	r2, [sp, #20]
 1308 09e8 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1309 09ec 0730A0E1 		mov	r3, r7
 1310 09f0 1C108DE5 		str	r1, [sp, #28]
 1311 09f4 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1312 09f8 0400A0E3 		mov	r0, #4
 1313 09fc 00129FE5 		ldr	r1, .L109+4
 1314 0a00 0520A0E1 		mov	r2, r5
 1315 0a04 00E08DE5 		str	lr, [sp, #0]
 1316 0a08 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1317 0a0c 0C908DE5 		str	r9, [sp, #12]
 1318 0a10 10B08DE5 		str	fp, [sp, #16]
 1319 0a14 18608DE5 		str	r6, [sp, #24]
 1320 0a18 20C08DE5 		str	ip, [sp, #32]
 1321 0a1c FEFFFFEB 		bl	CyU3PDebugPrint
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1322              		.loc 1 618 0
 1323 0a20 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1324 0a24 520053E3 		cmp	r3, #82
 1325 0a28 2C00000A 		beq	.L105
 1326              	.L95:
 628:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1327              		.loc 1 628 0
 1328 0a2c 000055E3 		cmp	r5, #0
 1329 0a30 1600000A 		beq	.L106
 653:../uvc.c      **** 	}else if(CmdType == 1){
 1330              		.loc 1 653 0
 1331 0a34 010055E3 		cmp	r5, #1
 1332 0a38 0100000A 		beq	.L107
 1333              	.LVL104:
 1334              	.L94:
 672:../uvc.c      **** }
 1335              		.loc 1 672 0
 1336 0a3c 3CD08DE2 		add	sp, sp, #60
 1337 0a40 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1338              	.LVL105:
 1339              	.L107:
 655:../uvc.c      **** 			if(CmdRegLen == 2){
 1340              		.loc 1 655 0
 1341 0a44 020057E3 		cmp	r7, #2
 1342 0a48 3700000A 		beq	.L108
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1343              		.loc 1 660 0
 1344 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1345 0a50 A8319FE5 		ldr	r3, .L109
 1346 0a54 FE1001E2 		and	r1, r1, #254
 1347 0a58 820051E3 		cmp	r1, #130
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1348              		.loc 1 663 0
 1349 0a5c 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1350              	.LVL106:
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1351              		.loc 1 660 0
 1352 0a60 0200001A 		bne	.L104
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1353              		.loc 1 660 0 is_stmt 0 discriminator 1
 1354 0a64 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1355 0a68 300055E3 		cmp	r5, #48
 1356 0a6c 4F00000A 		beq	.L102
 1357              	.L104:
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1358              		.loc 1 663 0 is_stmt 1
 1359 0a70 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1360              	.L103:
 665:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1361              		.loc 1 665 0
 1362 0a74 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1363 0a78 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1364 0a7c FE0002E2 		and	r0, r2, #254
 1365 0a80 0520A0E1 		mov	r2, r5
 1366 0a84 00E08DE5 		str	lr, [sp, #0]
 1367 0a88 FEFFFFEB 		bl	SensorWrite2B
 1368 0a8c EAFFFFEA 		b	.L94
 1369              	.LVL107:
 1370              	.L106:
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1371              		.loc 1 644 0
 1372 0a90 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1373 0a94 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1374              		.loc 1 630 0
 1375 0a98 0FE0A0E3 		mov	lr, #15
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1376              		.loc 1 644 0
 1377 0a9c 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1378 0aa0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1379              		.loc 1 630 0
 1380 0aa4 57E0C4E5 		strb	lr, [r4, #87]
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1381              		.loc 1 644 0
 1382 0aa8 34C08DE2 		add	ip, sp, #52
 1383 0aac 010080E3 		orr	r0, r0, #1
 1384 0ab0 011081E3 		orr	r1, r1, #1
 1385 0ab4 00C08DE5 		str	ip, [sp, #0]
 1386 0ab8 FEFFFFEB 		bl	SensorRead2B
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1387              		.loc 1 645 0
 1388 0abc 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 646:../uvc.c      **** 				if(CmdDataLen == 2){
 1389              		.loc 1 646 0
 1390 0ac0 020056E3 		cmp	r6, #2
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1391              		.loc 1 645 0
 1392 0ac4 5530C4E5 		strb	r3, [r4, #85]
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1393              		.loc 1 647 0
 1394 0ac8 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1395 0acc 2C319F05 		ldreq	r3, .L109
 649:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1396              		.loc 1 649 0
 1397 0ad0 0020E0E3 		mvn	r2, #0
 1398 0ad4 5720C4E5 		strb	r2, [r4, #87]
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1399              		.loc 1 647 0
 1400 0ad8 5600C305 		streqb	r0, [r3, #86]
 1401 0adc D6FFFFEA 		b	.L94
 1402              	.L105:
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1403              		.loc 1 618 0 discriminator 1
 1404 0ae0 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1405 0ae4 300050E3 		cmp	r0, #48
 1406 0ae8 CFFFFF1A 		bne	.L95
 1407 0aec 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1408 0af0 010053E3 		cmp	r3, #1
 1409 0af4 CCFFFF1A 		bne	.L95
 620:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1410              		.loc 1 620 0
 1411 0af8 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1412 0afc 04C19FE5 		ldr	ip, .L109+8
 1413 0b00 031002E2 		and	r1, r2, #3
 1414 0b04 8C14CCE5 		strb	r1, [ip, #1164]
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 1415              		.loc 1 621 0
 1416 0b08 58E094E5 		ldr	lr, [r4, #88]
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1417              		.loc 1 625 0
 1418 0b0c F8109FE5 		ldr	r1, .L109+12
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 1419              		.loc 1 621 0
 1420 0b10 00005EE3 		cmp	lr, #0
 623:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1421              		.loc 1 623 0
 1422 0b14 80208203 		orreq	r2, r2, #128
 1423 0b18 5520C405 		streqb	r2, [r4, #85]
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1424              		.loc 1 625 0
 1425 0b1c 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1426 0b20 0400A0E3 		mov	r0, #4
 1427 0b24 FEFFFFEB 		bl	CyU3PDebugPrint
 1428 0b28 BFFFFFEA 		b	.L95
 1429              	.L108:
 657:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1430              		.loc 1 657 0
 1431 0b2c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1432 0b30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1433 0b34 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1434 0b38 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1435 0b3c 0020A0E3 		mov	r2, #0
 1436 0b40 FE0000E2 		and	r0, r0, #254
 1437 0b44 00E08DE5 		str	lr, [sp, #0]
 1438 0b48 FEFFFFEB 		bl	SensorWrite2B2
 1439 0b4c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1440 0b50 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1441 0b54 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1442 0b58 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1443 0b5c FE0002E2 		and	r0, r2, #254
 1444 0b60 0020A0E3 		mov	r2, #0
 1445 0b64 00C08DE5 		str	ip, [sp, #0]
 1446 0b68 FEFFFFEB 		bl	SensorWrite2B2
 1447              	.LVL108:
 1448 0b6c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1449 0b70 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1450 0b74 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1451 0b78 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1452 0b7c 0020A0E3 		mov	r2, #0
 1453 0b80 FE0000E2 		and	r0, r0, #254
 1454 0b84 00C08DE5 		str	ip, [sp, #0]
 1455 0b88 FEFFFFEB 		bl	SensorWrite2B2
 1456 0b8c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1457 0b90 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1458 0b94 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1459 0b98 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1460 0b9c FE0002E2 		and	r0, r2, #254
 1461 0ba0 0020A0E3 		mov	r2, #0
 1462 0ba4 00C08DE5 		str	ip, [sp, #0]
 1463 0ba8 FEFFFFEB 		bl	SensorWrite2B2
 1464 0bac A2FFFFEA 		b	.L94
 1465              	.LVL109:
 1466              	.L102:
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1467              		.loc 1 660 0 discriminator 1
 1468 0bb0 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1469 0bb4 100053E3 		cmp	r3, #16
 1470 0bb8 ADFFFF1A 		bne	.L103
 661:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1471              		.loc 1 661 0
 1472 0bbc 4C409FE5 		ldr	r4, .L109+16
 1473 0bc0 0010E0E3 		mvn	r1, #0
 1474 0bc4 1C0094E5 		ldr	r0, [r4, #28]
 1475 0bc8 2C308DE5 		str	r3, [sp, #44]
 1476 0bcc FEFFFFEB 		bl	_txe_mutex_get
 662:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1477              		.loc 1 662 0
 1478 0bd0 2C309DE5 		ldr	r3, [sp, #44]
 1479 0bd4 00C0A0E3 		mov	ip, #0
 1480 0bd8 0320A0E1 		mov	r2, r3
 1481 0bdc 0400A0E1 		mov	r0, r4
 1482 0be0 1710A0E3 		mov	r1, #23
 1483 0be4 0530A0E1 		mov	r3, r5
 1484 0be8 00C08DE5 		str	ip, [sp, #0]
 1485 0bec 04C08DE5 		str	ip, [sp, #4]
 1486 0bf0 FEFFFFEB 		bl	cmdSet
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1487              		.loc 1 663 0
 1488 0bf4 1C0094E5 		ldr	r0, [r4, #28]
 1489 0bf8 FEFFFFEB 		bl	_txe_mutex_put
 1490 0bfc 8EFFFFEA 		b	.L94
 1491              	.L110:
 1492              		.align	2
 1493              	.L109:
 1494 0c00 00000000 		.word	.LANCHOR0
 1495 0c04 1C020000 		.word	.LC15
 1496 0c08 00000000 		.word	.LANCHOR1
 1497 0c0c 68020000 		.word	.LC16
 1498 0c10 00000000 		.word	cmdQu
 1499              		.cfi_endproc
 1500              	.LFE0:
 1502              		.align	2
 1503              		.global	setIrisauto
 1505              	setIrisauto:
 1506              	.LFB1:
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1507              		.loc 1 678 0
 1508              		.cfi_startproc
 1509              		@ args = 0, pretend = 0, frame = 0
 1510              		@ frame_needed = 0, uses_anonymous_args = 0
 1511              	.LVL110:
 1512 0c14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1513              	.LCFI12:
 1514              		.cfi_def_cfa_offset 16
 1515 0c18 0160A0E1 		mov	r6, r1
 1516              		.cfi_offset 14, -4
 1517              		.cfi_offset 6, -8
 1518              		.cfi_offset 5, -12
 1519              		.cfi_offset 4, -16
 1520 0c1c 08D04DE2 		sub	sp, sp, #8
 1521              	.LCFI13:
 1522              		.cfi_def_cfa_offset 24
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1523              		.loc 1 678 0
 1524 0c20 0040A0E1 		mov	r4, r0
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1525              		.loc 1 681 0
 1526 0c24 0050A0E3 		mov	r5, #0
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1527              		.loc 1 680 0
 1528 0c28 0010E0E3 		mvn	r1, #0
 1529              	.LVL111:
 1530 0c2c 1C0090E5 		ldr	r0, [r0, #28]
 1531              	.LVL112:
 1532 0c30 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1533              		.loc 1 681 0
 1534 0c34 060065E0 		rsb	r0, r5, r6
 1535 0c38 00C070E2 		rsbs	ip, r0, #0
 1536 0c3c 00C0ACE0 		adc	ip, ip, r0
 1537 0c40 2010A0E3 		mov	r1, #32
 1538 0c44 2720A0E3 		mov	r2, #39
 1539 0c48 3030A0E3 		mov	r3, #48
 1540 0c4c 0400A0E1 		mov	r0, r4
 1541 0c50 00C08DE5 		str	ip, [sp, #0]
 1542 0c54 04508DE5 		str	r5, [sp, #4]
 1543 0c58 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1544              		.loc 1 682 0
 1545 0c5c 050056E1 		cmp	r6, r5
 1546 0c60 0260A003 		moveq	r6, #2
 1547 0c64 0160A013 		movne	r6, #1
 1548 0c68 0400A0E1 		mov	r0, r4
 1549 0c6c 2110A0E3 		mov	r1, #33
 1550 0c70 2520A0E3 		mov	r2, #37
 1551 0c74 3030A0E3 		mov	r3, #48
 1552 0c78 00608DE5 		str	r6, [sp, #0]
 1553 0c7c 04508DE5 		str	r5, [sp, #4]
 1554 0c80 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1555              		.loc 1 683 0
 1556 0c84 1C0094E5 		ldr	r0, [r4, #28]
 684:../uvc.c      **** }
 1557              		.loc 1 684 0
 1558 0c88 08D08DE2 		add	sp, sp, #8
 1559 0c8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1560              		.loc 1 683 0
 1561 0c90 FEFFFFEA 		b	_txe_mutex_put
 1562              		.cfi_endproc
 1563              	.LFE1:
 1565              		.align	2
 1566              		.global	getShutCtrl
 1568              	getShutCtrl:
 1569              	.LFB2:
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1570              		.loc 1 688 0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 0
 1573              		@ frame_needed = 0, uses_anonymous_args = 0
 1574              	.LVL113:
 693:../uvc.c      **** 	switch (Data){
 1575              		.loc 1 693 0
 1576 0c94 013040E2 		sub	r3, r0, #1
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1577              		.loc 1 688 0
 1578 0c98 10402DE9 		stmfd	sp!, {r4, lr}
 1579              	.LCFI14:
 1580              		.cfi_def_cfa_offset 8
 1581 0c9c 08D04DE2 		sub	sp, sp, #8
 1582              	.LCFI15:
 1583              		.cfi_def_cfa_offset 16
 693:../uvc.c      **** 	switch (Data){
 1584              		.loc 1 693 0
 1585 0ca0 090053E3 		cmp	r3, #9
 1586 0ca4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1587 0ca8 380000EA 		b	.L115
 1588              		.cfi_offset 14, -4
 1589              		.cfi_offset 4, -8
 1590              	.L118:
 1591 0cac 440D0000 		.word	.L116
 1592 0cb0 440D0000 		.word	.L116
 1593 0cb4 440D0000 		.word	.L116
 1594 0cb8 440D0000 		.word	.L116
 1595 0cbc 440D0000 		.word	.L116
 1596 0cc0 D40C0000 		.word	.L117
 1597 0cc4 D40C0000 		.word	.L117
 1598 0cc8 D40C0000 		.word	.L117
 1599 0ccc D40C0000 		.word	.L117
 1600 0cd0 D40C0000 		.word	.L117
 1601              	.L117:
 1602              	.LVL114:
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1603              		.loc 1 717 0
 1604 0cd4 ECC09FE5 		ldr	ip, .L127
 715:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1605              		.loc 1 715 0
 1606 0cd8 8330A0E1 		mov	r3, r3, asl #1
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1607              		.loc 1 717 0
 1608 0cdc B3309CE1 		ldrh	r3, [ip, r3]
 1609 0ce0 E4E09FE5 		ldr	lr, .L127+4
 1610 0ce4 032263E0 		rsb	r2, r3, r3, asl #4
 1611 0ce8 8240A0E1 		mov	r4, r2, asl #1
 1612 0cec 94CECEE0 		smull	ip, lr, r4, lr
 1613 0cf0 C4CFA0E1 		mov	ip, r4, asr #31
 1614 0cf4 4E246CE0 		rsb	r2, ip, lr, asr #8
 718:../uvc.c      **** 		if(NumLn > 1944)
 1615              		.loc 1 718 0
 1616 0cf8 D0E09FE5 		ldr	lr, .L127+8
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1617              		.loc 1 717 0
 1618 0cfc 0228A0E1 		mov	r2, r2, asl #16
 1619 0d00 22C8A0E1 		mov	ip, r2, lsr #16
 1620              	.LVL115:
 718:../uvc.c      **** 		if(NumLn > 1944)
 1621              		.loc 1 718 0
 1622 0d04 0E005CE1 		cmp	ip, lr
 1623 0d08 2600008A 		bhi	.L124
 720:../uvc.c      **** 		else if(NumLn < 8)
 1624              		.loc 1 720 0
 1625 0d0c 07005CE3 		cmp	ip, #7
 1626 0d10 2700008A 		bhi	.L126
 1627              	.LVL116:
 1628              	.L125:
 1629 0d14 01C0A0E3 		mov	ip, #1
 1630 0d18 08E0A0E3 		mov	lr, #8
 1631 0d1c 0C40A0E1 		mov	r4, ip
 1632              	.L121:
 1633              	.LVL117:
 723:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1634              		.loc 1 723 0
 1635 0d20 0120A0E3 		mov	r2, #1
 1636 0d24 0020C1E5 		strb	r2, [r1, #0]
 724:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1637              		.loc 1 724 0
 1638 0d28 0020A0E1 		mov	r2, r0
 1639 0d2c A0109FE5 		ldr	r1, .L127+12
 1640              	.LVL118:
 1641 0d30 0400A0E3 		mov	r0, #4
 1642              	.LVL119:
 1643 0d34 00E08DE5 		str	lr, [sp, #0]
 1644 0d38 04C08DE5 		str	ip, [sp, #4]
 1645 0d3c FEFFFFEB 		bl	CyU3PDebugPrint
 725:../uvc.c      **** 		break;
 1646              		.loc 1 725 0
 1647 0d40 150000EA 		b	.L120
 1648              	.LVL120:
 1649              	.L116:
 699:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1650              		.loc 1 699 0
 1651 0d44 7CE09FE5 		ldr	lr, .L127
 1652 0d48 8330A0E1 		mov	r3, r3, asl #1
 1653 0d4c B3309EE1 		ldrh	r3, [lr, r3]
 1654              	.LVL121:
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1655              		.loc 1 701 0
 1656 0d50 80C09FE5 		ldr	ip, .L127+16
 702:../uvc.c      **** 		if(NumLn > 1944)
 1657              		.loc 1 702 0
 1658 0d54 74E09FE5 		ldr	lr, .L127+8
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1659              		.loc 1 701 0
 1660 0d58 932C8CE0 		umull	r2, ip, r3, ip
 1661 0d5c AC24A0E1 		mov	r2, ip, lsr #9
 1662 0d60 024262E0 		rsb	r4, r2, r2, asl #4
 1663 0d64 8448A0E1 		mov	r4, r4, asl #17
 1664 0d68 2428A0E1 		mov	r2, r4, lsr #16
 1665              	.LVL122:
 702:../uvc.c      **** 		if(NumLn > 1944)
 1666              		.loc 1 702 0
 1667 0d6c 0E0052E1 		cmp	r2, lr
 1668 0d70 0C00008A 		bhi	.L124
 704:../uvc.c      **** 		else if(NumLn < 8)
 1669              		.loc 1 704 0
 1670 0d74 070052E3 		cmp	r2, #7
 1671 0d78 E5FFFF9A 		bls	.L125
 1672 0d7c A449A0E1 		mov	r4, r4, lsr #19
 1673 0d80 FF4004E2 		and	r4, r4, #255
 1674 0d84 02E0A0E1 		mov	lr, r2
 1675 0d88 04C0A0E1 		mov	ip, r4
 1676 0d8c E3FFFFEA 		b	.L121
 1677              	.LVL123:
 1678              	.L115:
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1679              		.loc 1 728 0
 1680 0d90 0000A0E3 		mov	r0, #0
 1681              	.LVL124:
 729:../uvc.c      **** 		LnVal = 1;
 1682              		.loc 1 729 0
 1683 0d94 0140A0E3 		mov	r4, #1
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1684              		.loc 1 728 0
 1685 0d98 0000C1E5 		strb	r0, [r1, #0]
 1686              	.LVL125:
 1687              	.L120:
 733:../uvc.c      **** }
 1688              		.loc 1 733 0
 1689 0d9c 0400A0E1 		mov	r0, r4
 1690 0da0 08D08DE2 		add	sp, sp, #8
 1691 0da4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1692              	.LVL126:
 1693              	.L124:
 718:../uvc.c      **** 		if(NumLn > 1944)
 1694              		.loc 1 718 0
 1695 0da8 F3C0A0E3 		mov	ip, #243
 1696 0dac 0C40A0E1 		mov	r4, ip
 1697 0db0 DAFFFFEA 		b	.L121
 1698              	.LVL127:
 1699              	.L126:
 720:../uvc.c      **** 		else if(NumLn < 8)
 1700              		.loc 1 720 0
 1701 0db4 A2E9A0E1 		mov	lr, r2, lsr #19
 1702 0db8 FF400EE2 		and	r4, lr, #255
 1703 0dbc 0CE0A0E1 		mov	lr, ip
 1704 0dc0 04C0A0E1 		mov	ip, r4
 1705              	.LVL128:
 1706 0dc4 D5FFFFEA 		b	.L121
 1707              	.L128:
 1708              		.align	2
 1709              	.L127:
 1710 0dc8 00000000 		.word	.LANCHOR2
 1711 0dcc 817F807F 		.word	2139127681
 1712 0dd0 98070000 		.word	1944
 1713 0dd4 90020000 		.word	.LC17
 1714 0dd8 01FF00FF 		.word	-16711935
 1715              		.cfi_endproc
 1716              	.LFE2:
 1718              		.align	2
 1719              		.global	ControlHandle
 1721              	ControlHandle:
 1722              	.LFB3:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1723              		.loc 1 735 0
 1724              		.cfi_startproc
 1725              		@ args = 0, pretend = 0, frame = 24
 1726              		@ frame_needed = 0, uses_anonymous_args = 0
 1727              	.LVL129:
 1728 0ddc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1729              	.LCFI16:
 1730              		.cfi_def_cfa_offset 36
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1731              		.loc 1 742 0
 1732 0de0 230050E3 		cmp	r0, #35
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1733              		.loc 1 741 0
 1734 0de4 207040E2 		sub	r7, r0, #32
 1735              		.cfi_offset 14, -4
 1736              		.cfi_offset 11, -8
 1737              		.cfi_offset 10, -12
 1738              		.cfi_offset 9, -16
 1739              		.cfi_offset 8, -20
 1740              		.cfi_offset 7, -24
 1741              		.cfi_offset 6, -28
 1742              		.cfi_offset 5, -32
 1743              		.cfi_offset 4, -36
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1744              		.loc 1 735 0
 1745 0de8 2CD04DE2 		sub	sp, sp, #44
 1746              	.LCFI17:
 1747              		.cfi_def_cfa_offset 80
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1748              		.loc 1 735 0
 1749 0dec 0040A0E1 		mov	r4, r0
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1750              		.loc 1 741 0
 1751 0df0 FF7007E2 		and	r7, r7, #255
 1752              	.LVL130:
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1753              		.loc 1 742 0
 1754 0df4 2300009A 		bls	.L130
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1755              		.loc 1 743 0
 1756 0df8 586F9FE5 		ldr	r6, .L311+72
 1757 0dfc 872087E0 		add	r2, r7, r7, asl #1
 1758 0e00 8221A0E1 		mov	r2, r2, asl #3
 1759 0e04 023086E0 		add	r3, r6, r2
 744:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1760              		.loc 1 744 0
 1761 0e08 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 745:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1762              		.loc 1 745 0
 1763 0e0c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 746:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1764              		.loc 1 746 0
 1765 0e10 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 757:../uvc.c      ****     reqData = bRequest;
 1766              		.loc 1 757 0
 1767 0e14 F43E9FE5 		ldr	r3, .L311
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1768              		.loc 1 743 0
 1769 0e18 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1770              	.LVL131:
 757:../uvc.c      ****     reqData = bRequest;
 1771              		.loc 1 757 0
 1772 0e1c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1773              	.LVL132:
 765:../uvc.c      ****     switch (bRequest)
 1774              		.loc 1 765 0
 1775 0e20 830055E3 		cmp	r5, #131
 1776 0e24 2200000A 		beq	.L136
 1777              	.LVL133:
 1778              	.L301:
 1779 0e28 2B00009A 		bls	.L299
 1780 0e2c 850055E3 		cmp	r5, #133
 1781 0e30 8800000A 		beq	.L138
 1782 0e34 7600003A 		bcc	.L137
 1783 0e38 860055E3 		cmp	r5, #134
 1784 0e3c C500000A 		beq	.L139
 1785 0e40 870055E3 		cmp	r5, #135
 1786 0e44 B900000A 		beq	.L300
 1787              	.L132:
1651:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1788              		.loc 1 1651 0
 1789 0e48 0000A0E3 		mov	r0, #0
 1790              	.LVL134:
 1791 0e4c 0110A0E3 		mov	r1, #1
 1792 0e50 0020A0E1 		mov	r2, r0
 1793 0e54 FEFFFFEB 		bl	CyU3PUsbStall
1652:../uvc.c      **** 			  break;
 1794              		.loc 1 1652 0
 1795 0e58 FFA0A0E3 		mov	sl, #255
 1796 0e5c 0A70A0E1 		mov	r7, sl
 1797              	.LVL135:
 1798 0e60 0A40A0E1 		mov	r4, sl
 1799 0e64 0A80A0E1 		mov	r8, sl
 1800              	.LVL136:
 1801              	.L142:
1654:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1802              		.loc 1 1654 0
 1803 0e68 A41E9FE5 		ldr	r1, .L311+4
 1804 0e6c 0520A0E1 		mov	r2, r5
 1805 0e70 0830A0E1 		mov	r3, r8
 1806 0e74 0400A0E3 		mov	r0, #4
 1807 0e78 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 1808 0e7c FEFFFFEB 		bl	CyU3PDebugPrint
1655:../uvc.c      **** }
 1809              		.loc 1 1655 0
 1810 0e80 2CD08DE2 		add	sp, sp, #44
 1811 0e84 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1812              	.LVL137:
 1813              	.L130:
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1814              		.loc 1 748 0
 1815 0e88 C86E9FE5 		ldr	r6, .L311+72
 757:../uvc.c      ****     reqData = bRequest;
 1816              		.loc 1 757 0
 1817 0e8c 7C3E9FE5 		ldr	r3, .L311
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1818              		.loc 1 748 0
 1819 0e90 808080E0 		add	r8, r0, r0, asl #1
 1820 0e94 885186E0 		add	r5, r6, r8, asl #3
 1821 0e98 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 1822              	.LVL138:
 749:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1823              		.loc 1 749 0
 1824 0e9c 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 1825              	.LVL139:
 750:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1826              		.loc 1 750 0
 1827 0ea0 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 1828              	.LVL140:
 751:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1829              		.loc 1 751 0
 1830 0ea4 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 1831              	.LVL141:
 757:../uvc.c      ****     reqData = bRequest;
 1832              		.loc 1 757 0
 1833 0ea8 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1834              	.LVL142:
 765:../uvc.c      ****     switch (bRequest)
 1835              		.loc 1 765 0
 1836 0eac 830055E3 		cmp	r5, #131
 1837 0eb0 DCFFFF1A 		bne	.L301
 1838              	.LVL143:
 1839              	.L136:
1135:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1840              		.loc 1 1135 0
 1841 0eb4 230054E3 		cmp	r4, #35
 1842 0eb8 C400009A 		bls	.L209
1136:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1843              		.loc 1 1136 0
 1844 0ebc 872087E0 		add	r2, r7, r7, asl #1
 1845 0ec0 826186E0 		add	r6, r6, r2, asl #3
 1846 0ec4 909E9FE5 		ldr	r9, .L311+76
 1847 0ec8 0530D6E5 		ldrb	r3, [r6, #5]	@ zero_extendqisi2
1137:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1848              		.loc 1 1137 0
 1849 0ecc 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 1850              	.LVL144:
1136:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1851              		.loc 1 1136 0
 1852 0ed0 5C30C9E5 		strb	r3, [r9, #92]
1137:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1853              		.loc 1 1137 0
 1854 0ed4 5D00C9E5 		strb	r0, [r9, #93]
 1855 0ed8 0B0000EA 		b	.L217
 1856              	.LVL145:
 1857              	.L299:
 765:../uvc.c      ****     switch (bRequest)
 1858              		.loc 1 765 0
 1859 0edc 810055E3 		cmp	r5, #129
 1860 0ee0 6800000A 		beq	.L134
 1861 0ee4 1000009A 		bls	.L302
1116:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1862              		.loc 1 1116 0
 1863 0ee8 230054E3 		cmp	r4, #35
 1864 0eec AB00009A 		bls	.L206
1117:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1865              		.loc 1 1117 0
 1866 0ef0 879087E0 		add	r9, r7, r7, asl #1
 1867 0ef4 896186E0 		add	r6, r6, r9, asl #3
 1868 0ef8 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 1869              	.LVL146:
 1870 0efc 589E9FE5 		ldr	r9, .L311+76
1118:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1871              		.loc 1 1118 0
 1872 0f00 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
1117:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1873              		.loc 1 1117 0
 1874 0f04 5C70C9E5 		strb	r7, [r9, #92]
1118:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1875              		.loc 1 1118 0
 1876 0f08 5DE0C9E5 		strb	lr, [r9, #93]
 1877              	.LVL147:
 1878              	.L217:
1193:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1879              		.loc 1 1193 0
 1880 0f0c 0800A0E1 		mov	r0, r8
1195:../uvc.c      **** 			  break;
 1881              		.loc 1 1195 0
 1882 0f10 FFA0A0E3 		mov	sl, #255
1193:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1883              		.loc 1 1193 0
 1884 0f14 FC1D9FE5 		ldr	r1, .L311+8
 1885 0f18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1886              	.LVL148:
1195:../uvc.c      **** 			  break;
 1887              		.loc 1 1195 0
 1888 0f1c 0A40A0E1 		mov	r4, sl
1193:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1889              		.loc 1 1193 0
 1890 0f20 5C70D9E5 		ldrb	r7, [r9, #92]	@ zero_extendqisi2
1195:../uvc.c      **** 			  break;
 1891              		.loc 1 1195 0
 1892 0f24 0A80A0E1 		mov	r8, sl
 1893 0f28 CEFFFFEA 		b	.L142
 1894              	.LVL149:
 1895              	.L302:
 765:../uvc.c      ****     switch (bRequest)
 1896              		.loc 1 765 0
 1897 0f2c 010055E3 		cmp	r5, #1
 1898 0f30 C4FFFF1A 		bne	.L132
1197:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1899              		.loc 1 1197 0
 1900 0f34 201E9FE5 		ldr	r1, .L311+76
 1901 0f38 26208DE2 		add	r2, sp, #38
 1902 0f3c 2000A0E3 		mov	r0, #32
 1903              	.LVL150:
 1904 0f40 5C1081E2 		add	r1, r1, #92
 1905 0f44 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1906              	.LVL151:
1199:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1907              		.loc 1 1199 0
 1908 0f48 002050E2 		subs	r2, r0, #0
 1909 0f4c 4A04001A 		bne	.L219
1201:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1910              		.loc 1 1201 0
 1911 0f50 04CE9FE5 		ldr	ip, .L311+76
1202:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1912              		.loc 1 1202 0
 1913 0f54 00EE9FE5 		ldr	lr, .L311+76
1201:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1914              		.loc 1 1201 0
 1915 0f58 5C30DCE5 		ldrb	r3, [ip, #92]	@ zero_extendqisi2
1204:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1916              		.loc 1 1204 0
 1917 0f5c 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1918              	.LVL152:
1201:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1919              		.loc 1 1201 0
 1920 0f60 18308DE5 		str	r3, [sp, #24]
 1921              	.LVL153:
1202:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1922              		.loc 1 1202 0
 1923 0f64 5DC0DEE5 		ldrb	ip, [lr, #93]	@ zero_extendqisi2
 1924              	.LVL154:
1204:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1925              		.loc 1 1204 0
 1926 0f68 1C008DE5 		str	r0, [sp, #28]
 1927              	.LVL155:
1208:../uvc.c      **** 				  switch(CtrlID)
 1928              		.loc 1 1208 0
 1929 0f6c 260054E3 		cmp	r4, #38
 1930 0f70 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1931 0f74 790300EA 		b	.L220
 1932              	.L238:
 1933 0f78 A41C0000 		.word	.L221
 1934 0f7c 381C0000 		.word	.L222
 1935 0f80 D81B0000 		.word	.L223
 1936 0f84 601D0000 		.word	.L220
 1937 0f88 741B0000 		.word	.L224
 1938 0f8c 341A0000 		.word	.L225
 1939 0f90 BC190000 		.word	.L226
 1940 0f94 FC1F0000 		.word	.L227
 1941 0f98 601D0000 		.word	.L220
 1942 0f9c 601D0000 		.word	.L220
 1943 0fa0 601D0000 		.word	.L220
 1944 0fa4 781F0000 		.word	.L228
 1945 0fa8 601D0000 		.word	.L220
 1946 0fac 601D0000 		.word	.L220
 1947 0fb0 601D0000 		.word	.L220
 1948 0fb4 601D0000 		.word	.L220
 1949 0fb8 9C1E0000 		.word	.L229
 1950 0fbc 601D0000 		.word	.L220
 1951 0fc0 601D0000 		.word	.L220
 1952 0fc4 601D0000 		.word	.L220
 1953 0fc8 601D0000 		.word	.L220
 1954 0fcc 601D0000 		.word	.L220
 1955 0fd0 601D0000 		.word	.L220
 1956 0fd4 601D0000 		.word	.L220
 1957 0fd8 601D0000 		.word	.L220
 1958 0fdc C81D0000 		.word	.L230
 1959 0fe0 D81B0000 		.word	.L223
 1960 0fe4 98170000 		.word	.L231
 1961 0fe8 10170000 		.word	.L232
 1962 0fec 601D0000 		.word	.L220
 1963 0ff0 B4160000 		.word	.L233
 1964 0ff4 30160000 		.word	.L234
 1965 0ff8 601D0000 		.word	.L220
 1966 0ffc 601D0000 		.word	.L220
 1967 1000 601D0000 		.word	.L220
 1968 1004 601D0000 		.word	.L220
 1969 1008 A0180000 		.word	.L235
 1970 100c 2C180000 		.word	.L236
 1971 1010 3C190000 		.word	.L237
 1972              	.LVL156:
 1973              	.L137:
1153:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1974              		.loc 1 1153 0
 1975 1014 230054E3 		cmp	r4, #35
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1976              		.loc 1 1160 0
 1977 1018 84408490 		addls	r4, r4, r4, asl #1
1154:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1978              		.loc 1 1154 0
 1979 101c 87708780 		addhi	r7, r7, r7, asl #1
 1980              	.LVL157:
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1981              		.loc 1 1160 0
 1982 1020 84618690 		addls	r6, r6, r4, asl #3
1154:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1983              		.loc 1 1154 0
 1984 1024 87618680 		addhi	r6, r6, r7, asl #3
 1985 1028 2C9D9F85 		ldrhi	r9, .L311+76
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1986              		.loc 1 1160 0
 1987 102c 289D9F95 		ldrls	r9, .L311+76
1154:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1988              		.loc 1 1154 0
 1989 1030 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1155:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1990              		.loc 1 1155 0
 1991 1034 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1992              		.loc 1 1160 0
 1993 1038 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1994              		.loc 1 1161 0
 1995 103c 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1162:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1996              		.loc 1 1162 0
 1997 1040 0040A0E3 		mov	r4, #0
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1998              		.loc 1 1160 0
 1999 1044 5C10C9E5 		strb	r1, [r9, #92]
1161:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2000              		.loc 1 1161 0
 2001 1048 5D20C9E5 		strb	r2, [r9, #93]
1162:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2002              		.loc 1 1162 0
 2003 104c 5E40C9E5 		strb	r4, [r9, #94]
1163:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2004              		.loc 1 1163 0
 2005 1050 5F40C9E5 		strb	r4, [r9, #95]
 2006 1054 ACFFFFEA 		b	.L217
 2007              	.LVL158:
 2008              	.L138:
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2009              		.loc 1 769 0
 2010 1058 FC4C9FE5 		ldr	r4, .L311+76
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2011              		.loc 1 770 0
 2012 105c 00A0A0E3 		mov	sl, #0
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2013              		.loc 1 769 0
 2014 1060 5C80C4E5 		strb	r8, [r4, #92]
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2015              		.loc 1 770 0
 2016 1064 5DA0C4E5 		strb	sl, [r4, #93]
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2017              		.loc 1 771 0
 2018 1068 5C1084E2 		add	r1, r4, #92
 773:../uvc.c      **** 			  break;
 2019              		.loc 1 773 0
 2020 106c FFA0A0E3 		mov	sl, #255
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2021              		.loc 1 771 0
 2022 1070 0200A0E3 		mov	r0, #2
 2023              	.LVL159:
 2024 1074 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2025              	.LVL160:
 773:../uvc.c      **** 			  break;
 2026              		.loc 1 773 0
 2027 1078 0A80A0E1 		mov	r8, sl
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2028              		.loc 1 771 0
 2029 107c 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 2030              	.LVL161:
 773:../uvc.c      **** 			  break;
 2031              		.loc 1 773 0
 2032 1080 0A40A0E1 		mov	r4, sl
 2033 1084 77FFFFEA 		b	.L142
 2034              	.LVL162:
 2035              	.L134:
 776:../uvc.c      **** 			 switch(CtrlID)
 2036              		.loc 1 776 0
 2037 1088 260054E3 		cmp	r4, #38
 2038 108c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2039 1090 DB0000EA 		b	.L143
 2040              	.L160:
 2041 1094 60150000 		.word	.L144
 2042 1098 A0140000 		.word	.L145
 2043 109c F4140000 		.word	.L146
 2044 10a0 04140000 		.word	.L143
 2045 10a4 A0130000 		.word	.L147
 2046 10a8 10160000 		.word	.L148
 2047 10ac 04140000 		.word	.L143
 2048 10b0 C8140000 		.word	.L149
 2049 10b4 04140000 		.word	.L143
 2050 10b8 8C150000 		.word	.L150
 2051 10bc 04140000 		.word	.L143
 2052 10c0 D4130000 		.word	.L151
 2053 10c4 04140000 		.word	.L143
 2054 10c8 04140000 		.word	.L143
 2055 10cc 04140000 		.word	.L143
 2056 10d0 04140000 		.word	.L143
 2057 10d4 B4150000 		.word	.L152
 2058 10d8 04140000 		.word	.L143
 2059 10dc 04140000 		.word	.L143
 2060 10e0 04140000 		.word	.L143
 2061 10e4 04140000 		.word	.L143
 2062 10e8 04140000 		.word	.L143
 2063 10ec 04140000 		.word	.L143
 2064 10f0 04140000 		.word	.L143
 2065 10f4 04140000 		.word	.L143
 2066 10f8 34140000 		.word	.L153
 2067 10fc F4140000 		.word	.L146
 2068 1100 1C150000 		.word	.L154
 2069 1104 78130000 		.word	.L155
 2070 1108 04140000 		.word	.L143
 2071 110c 04140000 		.word	.L143
 2072 1110 4C120000 		.word	.L156
 2073 1114 04140000 		.word	.L143
 2074 1118 04140000 		.word	.L143
 2075 111c 04140000 		.word	.L143
 2076 1120 04140000 		.word	.L143
 2077 1124 E8120000 		.word	.L157
 2078 1128 4C130000 		.word	.L158
 2079 112c 28130000 		.word	.L159
 2080              	.L300:
1180:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2081              		.loc 1 1180 0
 2082 1130 230054E3 		cmp	r4, #35
 2083 1134 3100009A 		bls	.L216
1181:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2084              		.loc 1 1181 0
 2085 1138 87A087E0 		add	sl, r7, r7, asl #1
 2086 113c 8A6186E0 		add	r6, r6, sl, asl #3
 2087 1140 149C9FE5 		ldr	r9, .L311+76
 2088 1144 0BC0D6E5 		ldrb	ip, [r6, #11]	@ zero_extendqisi2
1182:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2089              		.loc 1 1182 0
 2090 1148 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
1181:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2091              		.loc 1 1181 0
 2092 114c 5CC0C9E5 		strb	ip, [r9, #92]
1182:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2093              		.loc 1 1182 0
 2094 1150 5D10C9E5 		strb	r1, [r9, #93]
 2095 1154 6CFFFFEA 		b	.L217
 2096              	.L139:
1169:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2097              		.loc 1 1169 0
 2098 1158 230054E3 		cmp	r4, #35
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2099              		.loc 1 1170 0
 2100 115c 87708780 		addhi	r7, r7, r7, asl #1
 2101              	.LVL163:
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2102              		.loc 1 1173 0
 2103 1160 84408490 		addls	r4, r4, r4, asl #1
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2104              		.loc 1 1170 0
 2105 1164 87618680 		addhi	r6, r6, r7, asl #3
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2106              		.loc 1 1173 0
 2107 1168 84618690 		addls	r6, r6, r4, asl #3
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2108              		.loc 1 1170 0
 2109 116c E88B9F85 		ldrhi	r8, .L311+76
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2110              		.loc 1 1173 0
 2111 1170 E48B9F95 		ldrls	r8, .L311+76
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2112              		.loc 1 1170 0
 2113 1174 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2114              		.loc 1 1173 0
 2115 1178 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1178:../uvc.c      **** 			  break;
 2116              		.loc 1 1178 0
 2117 117c FFA0A0E3 		mov	sl, #255
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2118              		.loc 1 1173 0
 2119 1180 5C30C8E5 		strb	r3, [r8, #92]
1175:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2120              		.loc 1 1175 0
 2121 1184 0100A0E3 		mov	r0, #1
 2122              	.LVL164:
 2123 1188 881B9FE5 		ldr	r1, .L311+8
 2124 118c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2125              	.LVL165:
1178:../uvc.c      **** 			  break;
 2126              		.loc 1 1178 0
 2127 1190 0A40A0E1 		mov	r4, sl
1175:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2128              		.loc 1 1175 0
 2129 1194 5C70D8E5 		ldrb	r7, [r8, #92]	@ zero_extendqisi2
1178:../uvc.c      **** 			  break;
 2130              		.loc 1 1178 0
 2131 1198 0A80A0E1 		mov	r8, sl
 2132 119c 31FFFFEA 		b	.L142
 2133              	.LVL166:
 2134              	.L206:
1121:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2135              		.loc 1 1121 0
 2136 11a0 0B0054E3 		cmp	r4, #11
1128:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2137              		.loc 1 1128 0
 2138 11a4 84408410 		addne	r4, r4, r4, asl #1
 2139 11a8 84618610 		addne	r6, r6, r4, asl #3
 2140 11ac A89B9F15 		ldrne	r9, .L311+76
1122:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2141              		.loc 1 1122 0
 2142 11b0 A49B9F05 		ldreq	r9, .L311+76
 2143 11b4 603B9F05 		ldreq	r3, .L311+12
1128:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2144              		.loc 1 1128 0
 2145 11b8 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1129:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2146              		.loc 1 1129 0
 2147 11bc 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1122:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2148              		.loc 1 1122 0
 2149 11c0 5C308905 		streq	r3, [r9, #92]
1128:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2150              		.loc 1 1128 0
 2151 11c4 5C20C915 		strneb	r2, [r9, #92]
1129:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2152              		.loc 1 1129 0
 2153 11c8 5D30C915 		strneb	r3, [r9, #93]
 2154 11cc 4EFFFFEA 		b	.L217
 2155              	.L209:
1139:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2156              		.loc 1 1139 0
 2157 11d0 0B0054E3 		cmp	r4, #11
1146:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2158              		.loc 1 1146 0
 2159 11d4 84408410 		addne	r4, r4, r4, asl #1
 2160 11d8 84618610 		addne	r6, r6, r4, asl #3
 2161 11dc 789B9F15 		ldrne	r9, .L311+76
1140:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2162              		.loc 1 1140 0
 2163 11e0 749B9F05 		ldreq	r9, .L311+76
 2164 11e4 343B9F05 		ldreq	r3, .L311+16
1146:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2165              		.loc 1 1146 0
 2166 11e8 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1147:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2167              		.loc 1 1147 0
 2168 11ec 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1140:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2169              		.loc 1 1140 0
 2170 11f0 5C308905 		streq	r3, [r9, #92]
1146:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2171              		.loc 1 1146 0
 2172 11f4 5C20C915 		strneb	r2, [r9, #92]
1147:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2173              		.loc 1 1147 0
 2174 11f8 5D30C915 		strneb	r3, [r9, #93]
 2175 11fc 42FFFFEA 		b	.L217
 2176              	.L216:
1184:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2177              		.loc 1 1184 0
 2178 1200 0B0054E3 		cmp	r4, #11
 2179 1204 0700000A 		beq	.L303
1190:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2180              		.loc 1 1190 0
 2181 1208 849084E0 		add	r9, r4, r4, asl #1
 2182 120c 896186E0 		add	r6, r6, r9, asl #3
 2183 1210 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2184 1214 409B9FE5 		ldr	r9, .L311+76
1191:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2185              		.loc 1 1191 0
 2186 1218 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1190:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2187              		.loc 1 1190 0
 2188 121c 5C20C9E5 		strb	r2, [r9, #92]
1191:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2189              		.loc 1 1191 0
 2190 1220 5D30C9E5 		strb	r3, [r9, #93]
 2191 1224 38FFFFEA 		b	.L217
 2192              	.L303:
1185:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2193              		.loc 1 1185 0
 2194 1228 2C9B9FE5 		ldr	r9, .L311+76
 2195 122c 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 2196              	.LVL167:
1187:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2197              		.loc 1 1187 0
 2198 1230 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2199              	.LVL168:
1186:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2200              		.loc 1 1186 0
 2201 1234 00E0A0E3 		mov	lr, #0
1185:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2202              		.loc 1 1185 0
 2203 1238 5C00C9E5 		strb	r0, [r9, #92]
1186:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2204              		.loc 1 1186 0
 2205 123c 5DE0C9E5 		strb	lr, [r9, #93]
1187:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2206              		.loc 1 1187 0
 2207 1240 5E70C9E5 		strb	r7, [r9, #94]
1188:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2208              		.loc 1 1188 0
 2209 1244 5FE0C9E5 		strb	lr, [r9, #95]
 2210 1248 2FFFFFEA 		b	.L217
 2211              	.LVL169:
 2212              	.L156:
 891:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2213              		.loc 1 891 0 discriminator 1
 2214 124c 000058E3 		cmp	r8, #0
 2215 1250 EC04000A 		beq	.L295
 889:../uvc.c      **** 					 break;
 2216              		.loc 1 889 0
 2217 1254 28E1A0E1 		mov	lr, r8, lsr #2
 2218 1258 00005EE3 		cmp	lr, #0
 2219 125c 03005813 		cmpne	r8, #3
 2220 1260 0020A083 		movhi	r2, #0
 2221 1264 0120A093 		movls	r2, #1
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2222              		.loc 1 735 0
 2223 1268 0E31A0E1 		mov	r3, lr, asl #2
 889:../uvc.c      **** 					 break;
 2224              		.loc 1 889 0
 2225 126c F004009A 		bls	.L275
 2226 1270 A01A9FE5 		ldr	r1, .L311+8
 2227 1274 100041E2 		sub	r0, r1, #16
 2228              	.LVL170:
 2229              	.L179:
 892:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2230              		.loc 1 892 0 discriminator 2
 2231 1278 044090E4 		ldr	r4, [r0], #4
 2232 127c 01A082E2 		add	sl, r2, #1
 2233 1280 FF200AE2 		and	r2, sl, #255
 2234 1284 0E0052E1 		cmp	r2, lr
 2235 1288 044081E4 		str	r4, [r1], #4
 2236 128c F9FFFF3A 		bcc	.L179
 892:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2237              		.loc 1 892 0 is_stmt 0
 2238 1290 030058E1 		cmp	r8, r3
 2239 1294 C00A9F15 		ldrne	r0, .L311+76
 2240 1298 DA04000A 		beq	.L295
 2241              	.L288:
 2242 129c 03C080E0 		add	ip, r0, r3
 2243 12a0 4CE0DCE5 		ldrb	lr, [ip, #76]	@ zero_extendqisi2
 891:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2244              		.loc 1 891 0 is_stmt 1
 2245 12a4 013083E2 		add	r3, r3, #1
 2246 12a8 FF3003E2 		and	r3, r3, #255
 2247              	.LVL171:
 2248 12ac 030058E1 		cmp	r8, r3
 892:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2249              		.loc 1 892 0
 2250 12b0 5CE0CCE5 		strb	lr, [ip, #92]
 891:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2251              		.loc 1 891 0
 2252 12b4 F8FFFF8A 		bhi	.L288
 2253              	.LVL172:
 2254              	.L162:
 901:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2255              		.loc 1 901 0
 2256 12b8 5710D0E5 		ldrb	r1, [r0, #87]	@ zero_extendqisi2
 894:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2257              		.loc 1 894 0
 2258 12bc 983A9FE5 		ldr	r3, .L311+76
 901:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2259              		.loc 1 901 0
 2260 12c0 FF0051E3 		cmp	r1, #255
 894:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2261              		.loc 1 894 0
 2262 12c4 6570D0E5 		ldrb	r7, [r0, #101]	@ zero_extendqisi2
 2263              	.LVL173:
 895:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2264              		.loc 1 895 0
 2265 12c8 66A0D0E5 		ldrb	sl, [r0, #102]	@ zero_extendqisi2
 2266              	.LVL174:
 901:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2267              		.loc 1 901 0
 2268 12cc 0F00000A 		beq	.L165
 903:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2269              		.loc 1 903 0
 2270 12d0 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2271 12d4 481A9FE5 		ldr	r1, .L311+20
 2272 12d8 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2273 12dc 0400A0E3 		mov	r0, #4
 2274 12e0 FEFFFFEB 		bl	CyU3PDebugPrint
 2275 12e4 090000EA 		b	.L165
 2276              	.LVL175:
 2277              	.L157:
 780:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2278              		.loc 1 780 0
 2279 12e8 6C4A9FE5 		ldr	r4, .L311+76
 2280 12ec A000D4E5 		ldrb	r0, [r4, #160]	@ zero_extendqisi2
 2281              	.LVL176:
 2282 12f0 000050E3 		cmp	r0, #0
 2283 12f4 0004000A 		beq	.L163
 781:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2284              		.loc 1 781 0
 2285 12f8 9DC4D6E5 		ldrb	ip, [r6, #1181]	@ zero_extendqisi2
 782:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2286              		.loc 1 782 0
 2287 12fc 9E14D6E5 		ldrb	r1, [r6, #1182]	@ zero_extendqisi2
 781:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2288              		.loc 1 781 0
 2289 1300 FF700CE2 		and	r7, ip, #255
 2290              	.LVL177:
 782:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2291              		.loc 1 782 0
 2292 1304 FFA001E2 		and	sl, r1, #255
 781:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2293              		.loc 1 781 0
 2294 1308 5C70C4E5 		strb	r7, [r4, #92]
 782:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2295              		.loc 1 782 0
 2296 130c 5DA0C4E5 		strb	sl, [r4, #93]
 2297              	.LVL178:
 2298              	.L165:
1109:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2299              		.loc 1 1109 0
 2300 1310 0800A0E1 		mov	r0, r8
 2301 1314 FC199FE5 		ldr	r1, .L311+8
 2302 1318 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1114:../uvc.c      **** 			  break;
 2303              		.loc 1 1114 0
 2304 131c FF40A0E3 		mov	r4, #255
 2305 1320 0480A0E1 		mov	r8, r4
 2306 1324 CFFEFFEA 		b	.L142
 2307              	.LVL179:
 2308              	.L159:
 813:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2309              		.loc 1 813 0
 2310 1328 2C4A9FE5 		ldr	r4, .L311+76
 2311 132c A2B0D4E5 		ldrb	fp, [r4, #162]	@ zero_extendqisi2
 2312 1330 00005BE3 		cmp	fp, #0
 2313 1334 FF03000A 		beq	.L168
 814:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2314              		.loc 1 814 0
 2315 1338 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2316              	.LVL180:
 815:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2317              		.loc 1 815 0
 2318 133c 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 814:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2319              		.loc 1 814 0
 2320 1340 5C70C4E5 		strb	r7, [r4, #92]
 815:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2321              		.loc 1 815 0
 2322 1344 5DA0C4E5 		strb	sl, [r4, #93]
 2323 1348 F0FFFFEA 		b	.L165
 2324              	.LVL181:
 2325              	.L158:
 795:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2326              		.loc 1 795 0
 2327 134c 084A9FE5 		ldr	r4, .L311+76
 2328 1350 A1E0D4E5 		ldrb	lr, [r4, #161]	@ zero_extendqisi2
 2329 1354 00005EE3 		cmp	lr, #0
 2330 1358 2704000A 		beq	.L166
 796:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2331              		.loc 1 796 0
 2332 135c B1A4D6E5 		ldrb	sl, [r6, #1201]	@ zero_extendqisi2
 797:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2333              		.loc 1 797 0
 2334 1360 B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 796:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2335              		.loc 1 796 0
 2336 1364 FF700AE2 		and	r7, sl, #255
 2337              	.LVL182:
 797:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2338              		.loc 1 797 0
 2339 1368 FFA002E2 		and	sl, r2, #255
 796:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2340              		.loc 1 796 0
 2341 136c 5C70C4E5 		strb	r7, [r4, #92]
 797:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2342              		.loc 1 797 0
 2343 1370 5DA0C4E5 		strb	sl, [r4, #93]
 2344 1374 E5FFFFEA 		b	.L165
 2345              	.LVL183:
 2346              	.L155:
 878:../uvc.c      **** 					 if(CamMode == 1){//720p
 2347              		.loc 1 878 0
 2348 1378 DC499FE5 		ldr	r4, .L311+76
 876:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2349              		.loc 1 876 0
 2350 137c 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2351              	.LVL184:
 878:../uvc.c      **** 					 if(CamMode == 1){//720p
 2352              		.loc 1 878 0
 2353 1380 BC20D4E5 		ldrb	r2, [r4, #188]	@ zero_extendqisi2
 2354 1384 010052E3 		cmp	r2, #1
 2355 1388 9004000A 		beq	.L304
 2356              	.LVL185:
 2357              	.L296:
 978:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2358              		.loc 1 978 0
 2359 138c 0030A0E3 		mov	r3, #0
 977:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2360              		.loc 1 977 0
 2361 1390 5C70C4E5 		strb	r7, [r4, #92]
 978:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2362              		.loc 1 978 0
 2363 1394 5D30C4E5 		strb	r3, [r4, #93]
 2364              	.LVL186:
 753:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2365              		.loc 1 753 0
 2366 1398 FFA0A0E3 		mov	sl, #255
 980:../uvc.c      **** 					 break;
 2367              		.loc 1 980 0
 2368 139c DBFFFFEA 		b	.L165
 2369              	.LVL187:
 2370              	.L147:
1068:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2371              		.loc 1 1068 0
 2372 13a0 B4499FE5 		ldr	r4, .L311+76
 2373 13a4 80E0D4E5 		ldrb	lr, [r4, #128]	@ zero_extendqisi2
 2374 13a8 00005EE3 		cmp	lr, #0
 2375 13ac 4304000A 		beq	.L200
1070:../uvc.c      **** 		 	 			 if(is60Hz)
 2376              		.loc 1 1070 0
 2377 13b0 58C094E5 		ldr	ip, [r4, #88]
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2378              		.loc 1 1076 0
 2379 13b4 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1070:../uvc.c      **** 		 	 			 if(is60Hz)
 2380              		.loc 1 1070 0
 2381 13b8 00005CE3 		cmp	ip, #0
1071:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2382              		.loc 1 1071 0
 2383 13bc 02C0A013 		movne	ip, #2
1073:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
 2384              		.loc 1 1073 0
 2385 13c0 01C0A003 		moveq	ip, #1
 2386 13c4 5CC0C4E5 		strb	ip, [r4, #92]
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2387              		.loc 1 1076 0
 2388 13c8 5DA0C4E5 		strb	sl, [r4, #93]
 2389 13cc 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 2390              	.LVL188:
 2391 13d0 CEFFFFEA 		b	.L165
 2392              	.LVL189:
 2393              	.L151:
 986:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2394              		.loc 1 986 0
 2395 13d4 80499FE5 		ldr	r4, .L311+76
 2396 13d8 8720D4E5 		ldrb	r2, [r4, #135]	@ zero_extendqisi2
 2397 13dc 000052E3 		cmp	r2, #0
 2398 13e0 B603000A 		beq	.L190
 987:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2399              		.loc 1 987 0
 2400 13e4 F474D6E5 		ldrb	r7, [r6, #1268]	@ zero_extendqisi2
 2401              	.LVL190:
 988:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2402              		.loc 1 988 0
 2403 13e8 F6A4D6E5 		ldrb	sl, [r6, #1270]	@ zero_extendqisi2
 987:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2404              		.loc 1 987 0
 2405 13ec 5C70C4E5 		strb	r7, [r4, #92]
 988:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2406              		.loc 1 988 0
 2407 13f0 5EA0C4E5 		strb	sl, [r4, #94]
 2408              	.LVL191:
 2409              	.L191:
 998:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2410              		.loc 1 998 0
 2411 13f4 00E0A0E3 		mov	lr, #0
 2412 13f8 5DE0C4E5 		strb	lr, [r4, #93]
 999:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2413              		.loc 1 999 0
 2414 13fc 5FE0C4E5 		strb	lr, [r4, #95]
 2415              	.LVL192:
1002:../uvc.c      **** 					 break;
 2416              		.loc 1 1002 0
 2417 1400 C2FFFFEA 		b	.L165
 2418              	.LVL193:
 2419              	.L143:
1093:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2420              		.loc 1 1093 0
 2421 1404 50B99FE5 		ldr	fp, .L311+76
 2422 1408 04308BE0 		add	r3, fp, r4
 2423 140c 7C20D3E5 		ldrb	r2, [r3, #124]	@ zero_extendqisi2
 2424 1410 000052E3 		cmp	r2, #0
 2425 1414 0F04000A 		beq	.L204
1094:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2426              		.loc 1 1094 0
 2427 1418 844084E0 		add	r4, r4, r4, asl #1
 2428 141c 846186E0 		add	r6, r6, r4, asl #3
 2429 1420 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2430              	.LVL194:
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2431              		.loc 1 1095 0
 2432 1424 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1094:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2433              		.loc 1 1094 0
 2434 1428 5C70CBE5 		strb	r7, [fp, #92]
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2435              		.loc 1 1095 0
 2436 142c 5DA0CBE5 		strb	sl, [fp, #93]
 2437 1430 B6FFFFEA 		b	.L165
 2438              	.LVL195:
 2439              	.L153:
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2440              		.loc 1 913 0
 2441 1434 20499FE5 		ldr	r4, .L311+76
 907:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2442              		.loc 1 907 0
 2443 1438 E004D6E5 		ldrb	r0, [r6, #1248]	@ zero_extendqisi2
 2444              	.LVL196:
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2445              		.loc 1 913 0
 2446 143c 95A0D4E5 		ldrb	sl, [r4, #149]	@ zero_extendqisi2
 908:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2447              		.loc 1 908 0
 2448 1440 E174D6E5 		ldrb	r7, [r6, #1249]	@ zero_extendqisi2
 2449              	.LVL197:
 909:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2450              		.loc 1 909 0
 2451 1444 EF24D6E5 		ldrb	r2, [r6, #1263]	@ zero_extendqisi2
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2452              		.loc 1 913 0
 2453 1448 00005AE3 		cmp	sl, #0
 907:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2454              		.loc 1 907 0
 2455 144c 04699FE5 		ldr	r6, .L311+72
 908:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2456              		.loc 1 908 0
 2457 1450 FFA007E2 		and	sl, r7, #255
 907:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2458              		.loc 1 907 0
 2459 1454 FF0000E2 		and	r0, r0, #255
 2460              	.LVL198:
 909:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2461              		.loc 1 909 0
 2462 1458 FF7002E2 		and	r7, r2, #255
 2463              	.LVL199:
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2464              		.loc 1 913 0
 2465 145c CF03000A 		beq	.L182
 914:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2466              		.loc 1 914 0
 2467 1460 EDC4D6E5 		ldrb	ip, [r6, #1261]	@ zero_extendqisi2
 915:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2468              		.loc 1 915 0
 2469 1464 EEE4D6E5 		ldrb	lr, [r6, #1262]	@ zero_extendqisi2
 914:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2470              		.loc 1 914 0
 2471 1468 5CC0C4E5 		strb	ip, [r4, #92]
 915:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2472              		.loc 1 915 0
 2473 146c 5EE0C4E5 		strb	lr, [r4, #94]
 2474              	.LVL200:
 2475              	.L183:
 932:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2476              		.loc 1 932 0
 2477 1470 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 2478              	.LVL201:
 933:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2479              		.loc 1 933 0
 2480 1474 5EA0D4E5 		ldrb	sl, [r4, #94]	@ zero_extendqisi2
 2481              	.LVL202:
 929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2482              		.loc 1 929 0
 2483 1478 00E0A0E3 		mov	lr, #0
 2484 147c 5DE0C4E5 		strb	lr, [r4, #93]
 931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2485              		.loc 1 931 0
 2486 1480 5FE0C4E5 		strb	lr, [r4, #95]
 934:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2487              		.loc 1 934 0
 2488 1484 9C189FE5 		ldr	r1, .L311+24
 2489 1488 0720A0E1 		mov	r2, r7
 2490 148c 0E30A0E1 		mov	r3, lr
 2491 1490 0400A0E3 		mov	r0, #4
 2492 1494 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2493 1498 FEFFFFEB 		bl	CyU3PDebugPrint
 935:../uvc.c      **** 					 break;
 2494              		.loc 1 935 0
 2495 149c 9BFFFFEA 		b	.L165
 2496              	.LVL203:
 2497              	.L145:
 951:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2498              		.loc 1 951 0
 2499 14a0 B4489FE5 		ldr	r4, .L311+76
 2500 14a4 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
 2501 14a8 000051E3 		cmp	r1, #0
 952:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2502              		.loc 1 952 0
 2503 14ac A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2504              	.LVL204:
 951:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2505              		.loc 1 951 0
 2506 14b0 1B04000A 		beq	.L305
 2507              	.LVL205:
 2508              	.L185:
 959:../uvc.c      **** 					  if(Data0&0x80){
 2509              		.loc 1 959 0
 2510 14b4 800010E3 		tst	r0, #128
 960:../uvc.c      **** 						  Data0 = ~Data0;
 2511              		.loc 1 960 0
 2512 14b8 0000E011 		mvnne	r0, r0
 2513              	.LVL206:
 962:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2514              		.loc 1 962 0
 2515 14bc 80004002 		subeq	r0, r0, #128
 2516 14c0 FF7000E2 		and	r7, r0, #255
 2517              	.LVL207:
 2518 14c4 B0FFFFEA 		b	.L296
 2519              	.LVL208:
 2520              	.L149:
1021:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2521              		.loc 1 1021 0
 2522 14c8 8C489FE5 		ldr	r4, .L311+76
 2523 14cc 8320D4E5 		ldrb	r2, [r4, #131]	@ zero_extendqisi2
 2524 14d0 000052E3 		cmp	r2, #0
 2525 14d4 A503000A 		beq	.L194
1022:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2526              		.loc 1 1022 0
 2527 14d8 19E5D6E5 		ldrb	lr, [r6, #1305]	@ zero_extendqisi2
1023:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2528              		.loc 1 1023 0
 2529 14dc 1A15D6E5 		ldrb	r1, [r6, #1306]	@ zero_extendqisi2
1022:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2530              		.loc 1 1022 0
 2531 14e0 FF700EE2 		and	r7, lr, #255
 2532              	.LVL209:
1023:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2533              		.loc 1 1023 0
 2534 14e4 FFA001E2 		and	sl, r1, #255
1022:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2535              		.loc 1 1022 0
 2536 14e8 5C70C4E5 		strb	r7, [r4, #92]
1023:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2537              		.loc 1 1023 0
 2538 14ec 5DA0C4E5 		strb	sl, [r4, #93]
 2539 14f0 86FFFFEA 		b	.L165
 2540              	.LVL210:
 2541              	.L146:
1038:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2542              		.loc 1 1038 0
 2543 14f4 60B89FE5 		ldr	fp, .L311+76
 2544 14f8 04408BE0 		add	r4, fp, r4
 2545 14fc 7C70D4E5 		ldrb	r7, [r4, #124]	@ zero_extendqisi2
 2546              	.LVL211:
 2547 1500 000057E3 		cmp	r7, #0
 2548 1504 C803000A 		beq	.L196
1039:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2549              		.loc 1 1039 0
 2550 1508 BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
1040:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2551              		.loc 1 1040 0
 2552 150c BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1039:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2553              		.loc 1 1039 0
 2554 1510 5C70CBE5 		strb	r7, [fp, #92]
1040:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2555              		.loc 1 1040 0
 2556 1514 5DA0CBE5 		strb	sl, [fp, #93]
 2557 1518 7CFFFFEA 		b	.L165
 2558              	.LVL212:
 2559              	.L154:
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2560              		.loc 1 863 0
 2561 151c 38489FE5 		ldr	r4, .L311+76
 856:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2562              		.loc 1 856 0
 2563 1520 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2564              		.loc 1 863 0
 2565 1524 9720D4E5 		ldrb	r2, [r4, #151]	@ zero_extendqisi2
 857:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2566              		.loc 1 857 0
 2567 1528 CDE4D6E5 		ldrb	lr, [r6, #1229]	@ zero_extendqisi2
 858:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2568              		.loc 1 858 0
 2569 152c DB14D6E5 		ldrb	r1, [r6, #1243]	@ zero_extendqisi2
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2570              		.loc 1 863 0
 2571 1530 000052E3 		cmp	r2, #0
 856:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2572              		.loc 1 856 0
 2573 1534 1C689FE5 		ldr	r6, .L311+72
 857:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2574              		.loc 1 857 0
 2575 1538 FF000EE2 		and	r0, lr, #255
 2576              	.LVL213:
 858:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2577              		.loc 1 858 0
 2578 153c FF1001E2 		and	r1, r1, #255
 2579              	.LVL214:
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2580              		.loc 1 863 0
 2581 1540 A303000A 		beq	.L174
 864:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2582              		.loc 1 864 0
 2583 1544 D9A4D6E5 		ldrb	sl, [r6, #1241]	@ zero_extendqisi2
 865:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2584              		.loc 1 865 0
 2585 1548 DA34D6E5 		ldrb	r3, [r6, #1242]	@ zero_extendqisi2
 864:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2586              		.loc 1 864 0
 2587 154c FF700AE2 		and	r7, sl, #255
 2588              	.LVL215:
 865:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2589              		.loc 1 865 0
 2590 1550 FFA003E2 		and	sl, r3, #255
 864:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2591              		.loc 1 864 0
 2592 1554 5C70C4E5 		strb	r7, [r4, #92]
 865:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2593              		.loc 1 865 0
 2594 1558 5DA0C4E5 		strb	sl, [r4, #93]
 2595 155c 6BFFFFEA 		b	.L165
 2596              	.LVL216:
 2597              	.L144:
1004:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2598              		.loc 1 1004 0
 2599 1560 F4479FE5 		ldr	r4, .L311+76
 2600 1564 7C70D4E5 		ldrb	r7, [r4, #124]	@ zero_extendqisi2
 2601              	.LVL217:
 2602 1568 000057E3 		cmp	r7, #0
 2603 156c E003000A 		beq	.L192
1005:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2604              		.loc 1 1005 0
 2605 1570 05A5D6E5 		ldrb	sl, [r6, #1285]	@ zero_extendqisi2
1006:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2606              		.loc 1 1006 0
 2607 1574 06C5D6E5 		ldrb	ip, [r6, #1286]	@ zero_extendqisi2
1005:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2608              		.loc 1 1005 0
 2609 1578 FF700AE2 		and	r7, sl, #255
1006:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2610              		.loc 1 1006 0
 2611 157c FFA00CE2 		and	sl, ip, #255
1005:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2612              		.loc 1 1005 0
 2613 1580 5C70C4E5 		strb	r7, [r4, #92]
1006:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2614              		.loc 1 1006 0
 2615 1584 5DA0C4E5 		strb	sl, [r4, #93]
 2616 1588 60FFFFEA 		b	.L165
 2617              	.LVL218:
 2618              	.L150:
1051:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2619              		.loc 1 1051 0
 2620 158c C8479FE5 		ldr	r4, .L311+76
 2621 1590 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
 2622 1594 000053E3 		cmp	r3, #0
 2623 1598 BD03000A 		beq	.L198
1053:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2624              		.loc 1 1053 0
 2625 159c 6522D6E5 		ldrb	r2, [r6, #613]	@ zero_extendqisi2
1054:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2626              		.loc 1 1054 0
 2627 15a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1053:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2628              		.loc 1 1053 0
 2629 15a4 037002E2 		and	r7, r2, #3
 2630              	.LVL219:
 2631 15a8 5C70C4E5 		strb	r7, [r4, #92]
1054:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2632              		.loc 1 1054 0
 2633 15ac 5DA0C4E5 		strb	sl, [r4, #93]
 2634 15b0 56FFFFEA 		b	.L165
 2635              	.LVL220:
 2636              	.L152:
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2637              		.loc 1 838 0
 2638 15b4 A0479FE5 		ldr	r4, .L311+76
 831:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2639              		.loc 1 831 0
 2640 15b8 B8E4D6E5 		ldrb	lr, [r6, #1208]	@ zero_extendqisi2
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2641              		.loc 1 838 0
 2642 15bc 8C20D4E5 		ldrb	r2, [r4, #140]	@ zero_extendqisi2
 832:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2643              		.loc 1 832 0
 2644 15c0 B934D6E5 		ldrb	r3, [r6, #1209]	@ zero_extendqisi2
 833:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2645              		.loc 1 833 0
 2646 15c4 C774D6E5 		ldrb	r7, [r6, #1223]	@ zero_extendqisi2
 2647              	.LVL221:
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2648              		.loc 1 838 0
 2649 15c8 000052E3 		cmp	r2, #0
 831:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2650              		.loc 1 831 0
 2651 15cc 84679FE5 		ldr	r6, .L311+72
 2652 15d0 FF000EE2 		and	r0, lr, #255
 2653              	.LVL222:
 833:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2654              		.loc 1 833 0
 2655 15d4 FF1007E2 		and	r1, r7, #255
 2656              	.LVL223:
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2657              		.loc 1 838 0
 2658 15d8 D803000A 		beq	.L172
 839:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2659              		.loc 1 839 0
 2660 15dc C5A4D6E5 		ldrb	sl, [r6, #1221]	@ zero_extendqisi2
 840:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2661              		.loc 1 840 0
 2662 15e0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 839:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2663              		.loc 1 839 0
 2664 15e4 FF700AE2 		and	r7, sl, #255
 2665 15e8 5C70C4E5 		strb	r7, [r4, #92]
 840:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2666              		.loc 1 840 0
 2667 15ec 5D30C4E5 		strb	r3, [r4, #93]
 2668              	.LVL224:
 2669              	.L173:
 853:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2670              		.loc 1 853 0
 2671 15f0 34179FE5 		ldr	r1, .L311+28
 2672 15f4 0720A0E1 		mov	r2, r7
 2673 15f8 0730A0E1 		mov	r3, r7
 2674 15fc 0400A0E3 		mov	r0, #4
 2675 1600 00C08DE5 		str	ip, [sp, #0]
 852:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 2676              		.loc 1 852 0
 2677 1604 0CA0A0E1 		mov	sl, ip
 853:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2678              		.loc 1 853 0
 2679 1608 FEFFFFEB 		bl	CyU3PDebugPrint
 2680              	.LVL225:
 854:../uvc.c      **** 			 		 break;
 2681              		.loc 1 854 0
 2682 160c 3FFFFFEA 		b	.L165
 2683              	.LVL226:
 2684              	.L148:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2685              		.loc 1 969 0
 2686 1610 44479FE5 		ldr	r4, .L311+76
 2687 1614 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 2688 1618 00005CE3 		cmp	ip, #0
 970:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2689              		.loc 1 970 0
 2690 161c 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2691              	.LVL227:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2692              		.loc 1 969 0
 2693 1620 B002000A 		beq	.L306
 2694              	.L189:
 2695              	.LVL228:
 977:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2696              		.loc 1 977 0
 2697 1624 800040E2 		sub	r0, r0, #128
 2698              	.LVL229:
 2699 1628 FF7000E2 		and	r7, r0, #255
 2700              	.LVL230:
 2701 162c 56FFFFEA 		b	.L296
 2702              	.LVL231:
 2703              	.L234:
1360:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2704              		.loc 1 1360 0 discriminator 1
 2705 1630 000058E3 		cmp	r8, #0
 2706 1634 1800000A 		beq	.L240
1358:../uvc.c      **** 							 break;
 2707              		.loc 1 1358 0
 2708 1638 28E1A0E1 		mov	lr, r8, lsr #2
 2709 163c 00005EE3 		cmp	lr, #0
 2710 1640 03005813 		cmpne	r8, #3
 2711 1644 0020A083 		movhi	r2, #0
 2712 1648 0120A093 		movls	r2, #1
 2713              	.LVL232:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2714              		.loc 1 735 0
 2715 164c 0E31A0E1 		mov	r3, lr, asl #2
1358:../uvc.c      **** 							 break;
 2716              		.loc 1 1358 0
 2717 1650 FA03009A 		bls	.L277
 2718 1654 D4169FE5 		ldr	r1, .L311+32
 2719 1658 100081E2 		add	r0, r1, #16
 2720              	.LVL233:
 2721              	.L250:
1361:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2722              		.loc 1 1361 0 discriminator 2
 2723 165c 047090E4 		ldr	r7, [r0], #4
 2724 1660 012082E2 		add	r2, r2, #1
 2725 1664 FF2002E2 		and	r2, r2, #255
 2726 1668 02005EE1 		cmp	lr, r2
 2727 166c 047081E4 		str	r7, [r1], #4
 2728 1670 F9FFFF8A 		bhi	.L250
1361:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2729              		.loc 1 1361 0 is_stmt 0
 2730 1674 030058E1 		cmp	r8, r3
 2731 1678 0700000A 		beq	.L240
 2732              	.L289:
 2733 167c D8069FE5 		ldr	r0, .L311+76
 2734 1680 03E080E0 		add	lr, r0, r3
 2735 1684 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
1360:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2736              		.loc 1 1360 0 is_stmt 1
 2737 1688 013083E2 		add	r3, r3, #1
 2738 168c FF3003E2 		and	r3, r3, #255
 2739              	.LVL234:
 2740 1690 030058E1 		cmp	r8, r3
1361:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2741              		.loc 1 1361 0
 2742 1694 4C10CEE5 		strb	r1, [lr, #76]
1360:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2743              		.loc 1 1360 0
 2744 1698 F7FFFF8A 		bhi	.L289
 2745              	.LVL235:
 2746              	.L240:
1364:../uvc.c      **** 							 break;
 2747              		.loc 1 1364 0
 2748 169c FFA0A0E3 		mov	sl, #255
1363:../uvc.c      **** 					 		I2CCmdHandler();
 2749              		.loc 1 1363 0
 2750 16a0 FEFFFFEB 		bl	I2CCmdHandler
 2751              	.LVL236:
1364:../uvc.c      **** 							 break;
 2752              		.loc 1 1364 0
 2753 16a4 0A70A0E1 		mov	r7, sl
1363:../uvc.c      **** 					 		I2CCmdHandler();
 2754              		.loc 1 1363 0
 2755 16a8 18809DE5 		ldr	r8, [sp, #24]
 2756 16ac 1C409DE5 		ldr	r4, [sp, #28]
1364:../uvc.c      **** 							 break;
 2757              		.loc 1 1364 0
 2758 16b0 ECFDFFEA 		b	.L142
 2759              	.LVL237:
 2760              	.L233:
1354:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2761              		.loc 1 1354 0
 2762 16b4 94769FE5 		ldr	r7, .L311+64
 2763              	.LVL238:
 2764 16b8 0010E0E3 		mvn	r1, #0
 2765 16bc 1C0097E5 		ldr	r0, [r7, #28]
 2766 16c0 FEFFFFEB 		bl	_txe_mutex_get
 2767              	.LVL239:
1355:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2768              		.loc 1 1355 0
 2769 16c4 0A20A0E1 		mov	r2, sl
 2770 16c8 18A09DE5 		ldr	sl, [sp, #24]
 2771 16cc 00C0A0E3 		mov	ip, #0
 2772 16d0 01407AE2 		rsbs	r4, sl, #1
 2773 16d4 0040A033 		movcc	r4, #0
 2774 16d8 1E10A0E3 		mov	r1, #30
 2775 16dc 0930A0E1 		mov	r3, r9
 2776 16e0 0700A0E1 		mov	r0, r7
 2777 16e4 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2778 16e8 FEFFFFEB 		bl	cmdSet
1356:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2779              		.loc 1 1356 0
 2780 16ec 1C0097E5 		ldr	r0, [r7, #28]
 2781 16f0 FEFFFFEB 		bl	_txe_mutex_put
1358:../uvc.c      **** 							 break;
 2782              		.loc 1 1358 0
 2783 16f4 FFA0A0E3 		mov	sl, #255
1357:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2784              		.loc 1 1357 0
 2785 16f8 0100A0E3 		mov	r0, #1
 2786 16fc 6004C6E5 		strb	r0, [r6, #1120]
 2787 1700 18809DE5 		ldr	r8, [sp, #24]
 2788 1704 1C409DE5 		ldr	r4, [sp, #28]
1358:../uvc.c      **** 							 break;
 2789              		.loc 1 1358 0
 2790 1708 0A70A0E1 		mov	r7, sl
 2791 170c D5FDFFEA 		b	.L142
 2792              	.LVL240:
 2793              	.L232:
1332:../uvc.c      **** 							 if(Data0 <= 3){
 2794              		.loc 1 1332 0
 2795 1710 030053E3 		cmp	r3, #3
1333:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2796              		.loc 1 1333 0
 2797 1714 40069F95 		ldrls	r0, .L311+76
 2798 1718 03E0A0E1 		mov	lr, r3
 2799              	.LVL241:
 2800 171c 0030A093 		movls	r3, #0
 2801 1720 BC30C095 		strlsb	r3, [r0, #188]
 2802              	.LVL242:
1336:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2803              		.loc 1 1336 0
 2804 1724 30C69F85 		ldrhi	ip, .L311+76
1333:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2805              		.loc 1 1333 0
 2806 1728 0E30A091 		movls	r3, lr
1342:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2807              		.loc 1 1342 0
 2808 172c 1C469FE5 		ldr	r4, .L311+64
 2809 1730 18E09D95 		ldrls	lr, [sp, #24]
1337:../uvc.c      **** 								 Data1 = Data0-4;
 2810              		.loc 1 1337 0
 2811 1734 04304382 		subhi	r3, r3, #4
1336:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2812              		.loc 1 1336 0
 2813 1738 0120A083 		movhi	r2, #1
 2814              	.LVL243:
1340:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2815              		.loc 1 1340 0
 2816 173c 8D31C6E5 		strb	r3, [r6, #397]
1341:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2817              		.loc 1 1341 0
 2818 1740 0130A0E3 		mov	r3, #1
1336:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2819              		.loc 1 1336 0
 2820 1744 BC20CC85 		strhib	r2, [ip, #188]
 2821              	.LVL244:
1342:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2822              		.loc 1 1342 0
 2823 1748 0010E0E3 		mvn	r1, #0
1339:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2824              		.loc 1 1339 0
 2825 174c 2DE4C6E5 		strb	lr, [r6, #1069]
1341:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2826              		.loc 1 1341 0
 2827 1750 3034C6E5 		strb	r3, [r6, #1072]
1342:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2828              		.loc 1 1342 0
 2829 1754 1C0094E5 		ldr	r0, [r4, #28]
 2830 1758 FEFFFFEB 		bl	_txe_mutex_get
1343:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2831              		.loc 1 1343 0
 2832 175c 18809DE5 		ldr	r8, [sp, #24]
 2833 1760 0A20A0E1 		mov	r2, sl
 2834 1764 1C10A0E3 		mov	r1, #28
 2835 1768 0930A0E1 		mov	r3, r9
 2836 176c 0400A0E1 		mov	r0, r4
 2837 1770 00A0A0E3 		mov	sl, #0
 2838 1774 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 2839 1778 FEFFFFEB 		bl	cmdSet
1344:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2840              		.loc 1 1344 0
 2841 177c 1C0094E5 		ldr	r0, [r4, #28]
 2842              	.LVL245:
 2843              	.L298:
1610:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2844              		.loc 1 1610 0
 2845 1780 FFA0A0E3 		mov	sl, #255
 2846 1784 FEFFFFEB 		bl	_txe_mutex_put
 2847 1788 0A70A0E1 		mov	r7, sl
 2848 178c 18809DE5 		ldr	r8, [sp, #24]
 2849 1790 1C409DE5 		ldr	r4, [sp, #28]
 2850 1794 B3FDFFEA 		b	.L142
 2851              	.LVL246:
 2852              	.L231:
1309:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2853              		.loc 1 1309 0
 2854 1798 B0459FE5 		ldr	r4, .L311+64
1305:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2855              		.loc 1 1305 0
 2856 179c CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
1306:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2857              		.loc 1 1306 0
 2858 17a0 CD74D6E5 		ldrb	r7, [r6, #1229]	@ zero_extendqisi2
 2859              	.LVL247:
1307:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2860              		.loc 1 1307 0
 2861 17a4 DBE4D6E5 		ldrb	lr, [r6, #1243]	@ zero_extendqisi2
1309:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2862              		.loc 1 1309 0
 2863 17a8 0010E0E3 		mvn	r1, #0
 2864 17ac 1C0094E5 		ldr	r0, [r4, #28]
1305:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2865              		.loc 1 1305 0
 2866 17b0 FFA003E2 		and	sl, r3, #255
 2867              	.LVL248:
1306:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2868              		.loc 1 1306 0
 2869 17b4 FF8007E2 		and	r8, r7, #255
 2870              	.LVL249:
1307:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2871              		.loc 1 1307 0
 2872 17b8 FF700EE2 		and	r7, lr, #255
 2873              	.LVL250:
1309:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2874              		.loc 1 1309 0
 2875 17bc FEFFFFEB 		bl	_txe_mutex_get
 2876              	.LVL251:
1317:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2877              		.loc 1 1317 0
 2878 17c0 D904D6E5 		ldrb	r0, [r6, #1241]	@ zero_extendqisi2
 2879 17c4 18109DE5 		ldr	r1, [sp, #24]
1305:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2880              		.loc 1 1305 0
 2881 17c8 88359FE5 		ldr	r3, .L311+72
1317:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2882              		.loc 1 1317 0
 2883 17cc 000051E1 		cmp	r1, r0
 2884 17d0 0600000A 		beq	.L245
1318:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 2885              		.loc 1 1318 0
 2886 17d4 D914C3E5 		strb	r1, [r3, #1241]
1319:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2887              		.loc 1 1319 0
 2888 17d8 ED24D3E5 		ldrb	r2, [r3, #1261]	@ zero_extendqisi2
 2889 17dc 010052E3 		cmp	r2, #1
 2890 17e0 6803000A 		beq	.L246
1319:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2891              		.loc 1 1319 0 is_stmt 0 discriminator 1
 2892 17e4 ED14D3E5 		ldrb	r1, [r3, #1261]	@ zero_extendqisi2
 2893 17e8 030051E3 		cmp	r1, #3
 2894 17ec 6503000A 		beq	.L246
 2895              	.LVL252:
 2896              	.L245:
1326:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2897              		.loc 1 1326 0 is_stmt 1
 2898 17f0 1C0094E5 		ldr	r0, [r4, #28]
 2899 17f4 FEFFFFEB 		bl	_txe_mutex_put
1328:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2900              		.loc 1 1328 0
 2901 17f8 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2902              		.loc 1 1327 0
 2903 17fc 18809DE5 		ldr	r8, [sp, #24]
1328:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2904              		.loc 1 1328 0
 2905 1800 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2906              		.loc 1 1327 0
 2907 1804 1C409DE5 		ldr	r4, [sp, #28]
1328:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2908              		.loc 1 1328 0
 2909 1808 D974D6E5 		ldrb	r7, [r6, #1241]	@ zero_extendqisi2
 2910              	.LVL253:
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2911              		.loc 1 1327 0
 2912 180c 0400A0E3 		mov	r0, #4
 2913 1810 1C159FE5 		ldr	r1, .L311+36
1329:../uvc.c      **** 							 break;
 2914              		.loc 1 1329 0
 2915 1814 FFA0A0E3 		mov	sl, #255
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2916              		.loc 1 1327 0
 2917 1818 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 2918 181c 08408DE5 		str	r4, [sp, #8]
1329:../uvc.c      **** 							 break;
 2919              		.loc 1 1329 0
 2920 1820 0A70A0E1 		mov	r7, sl
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2921              		.loc 1 1327 0
 2922 1824 FEFFFFEB 		bl	CyU3PDebugPrint
1329:../uvc.c      **** 							 break;
 2923              		.loc 1 1329 0
 2924 1828 8EFDFFEA 		b	.L142
 2925              	.LVL254:
 2926              	.L236:
1406:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2927              		.loc 1 1406 0
 2928 182c A4C4D6E5 		ldrb	ip, [r6, #1188]	@ zero_extendqisi2
 2929              	.LVL255:
1411:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2930              		.loc 1 1411 0
 2931 1830 18A59FE5 		ldr	sl, .L311+64
1407:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2932              		.loc 1 1407 0
 2933 1834 A534D6E5 		ldrb	r3, [r6, #1189]	@ zero_extendqisi2
1408:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2934              		.loc 1 1408 0
 2935 1838 B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1406:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2936              		.loc 1 1406 0
 2937 183c FF800CE2 		and	r8, ip, #255
 2938              	.LVL256:
1411:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2939              		.loc 1 1411 0
 2940 1840 0010E0E3 		mvn	r1, #0
 2941 1844 1C009AE5 		ldr	r0, [sl, #28]
1408:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2942              		.loc 1 1408 0
 2943 1848 FF400EE2 		and	r4, lr, #255
 2944              	.LVL257:
1411:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2945              		.loc 1 1411 0
 2946 184c FEFFFFEB 		bl	_txe_mutex_get
 2947              	.LVL258:
1412:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2948              		.loc 1 1412 0
 2949 1850 0820A0E1 		mov	r2, r8
 2950 1854 18809DE5 		ldr	r8, [sp, #24]
 2951              	.LVL259:
 2952 1858 0430A0E1 		mov	r3, r4
 2953 185c 2510A0E3 		mov	r1, #37
 2954 1860 0A00A0E1 		mov	r0, sl
 2955 1864 0070A0E3 		mov	r7, #0
 2956              	.LVL260:
 2957 1868 00808DE5 		str	r8, [sp, #0]
 2958 186c 04708DE5 		str	r7, [sp, #4]
 2959 1870 FEFFFFEB 		bl	cmdSet
 2960              	.LVL261:
1413:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2961              		.loc 1 1413 0
 2962 1874 1C009AE5 		ldr	r0, [sl, #28]
 2963 1878 FEFFFFEB 		bl	_txe_mutex_put
1414:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2964              		.loc 1 1414 0
 2965 187c 18409DE5 		ldr	r4, [sp, #24]
 2966              	.LVL262:
1418:../uvc.c      **** 							 break;
 2967              		.loc 1 1418 0
 2968 1880 FFA0A0E3 		mov	sl, #255
1415:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2969              		.loc 1 1415 0
 2970 1884 0100A0E3 		mov	r0, #1
1414:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2971              		.loc 1 1414 0
 2972 1888 B144C6E5 		strb	r4, [r6, #1201]
1415:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2973              		.loc 1 1415 0
 2974 188c 0480A0E1 		mov	r8, r4
 2975 1890 B504C6E5 		strb	r0, [r6, #1205]
 2976 1894 1C409DE5 		ldr	r4, [sp, #28]
1418:../uvc.c      **** 							 break;
 2977              		.loc 1 1418 0
 2978 1898 0A70A0E1 		mov	r7, sl
 2979 189c 71FDFFEA 		b	.L142
 2980              	.LVL263:
 2981              	.L235:
1366:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2982              		.loc 1 1366 0
 2983 18a0 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2984              		.loc 1 1393 0
 2985 18a4 A4449FE5 		ldr	r4, .L311+64
1367:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2986              		.loc 1 1367 0
 2987 18a8 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 2988              	.LVL264:
1368:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2989              		.loc 1 1368 0
 2990 18ac 9F14D6E5 		ldrb	r1, [r6, #1183]	@ zero_extendqisi2
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2991              		.loc 1 1393 0
 2992 18b0 1C0094E5 		ldr	r0, [r4, #28]
1368:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2993              		.loc 1 1368 0
 2994 18b4 FF7001E2 		and	r7, r1, #255
 2995              	.LVL265:
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2996              		.loc 1 1393 0
 2997 18b8 0010E0E3 		mvn	r1, #0
1366:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2998              		.loc 1 1366 0
 2999 18bc FF9003E2 		and	r9, r3, #255
 3000              	.LVL266:
1367:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3001              		.loc 1 1367 0
 3002 18c0 FF8002E2 		and	r8, r2, #255
 3003              	.LVL267:
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3004              		.loc 1 1393 0
 3005 18c4 14C08DE5 		str	ip, [sp, #20]
 3006 18c8 FEFFFFEB 		bl	_txe_mutex_get
 3007              	.LVL268:
1395:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3008              		.loc 1 1395 0
 3009 18cc 18C09DE5 		ldr	ip, [sp, #24]
 3010 18d0 00E0A0E3 		mov	lr, #0
 3011 18d4 0920A0E1 		mov	r2, r9
 3012 18d8 0730A0E1 		mov	r3, r7
 3013 18dc 2410A0E3 		mov	r1, #36
 3014 18e0 0400A0E1 		mov	r0, r4
 3015 18e4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3016 18e8 FEFFFFEB 		bl	cmdSet
 3017              	.LVL269:
1397:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 3018              		.loc 1 1397 0
 3019 18ec 14A09DE5 		ldr	sl, [sp, #20]
 3020 18f0 0820A0E1 		mov	r2, r8
 3021 18f4 0730A0E1 		mov	r3, r7
 3022 18f8 0190A0E3 		mov	r9, #1
 3023              	.LVL270:
 3024 18fc 2410A0E3 		mov	r1, #36
 3025 1900 0400A0E1 		mov	r0, r4
 3026 1904 00A08DE5 		str	sl, [sp, #0]
 3027 1908 04908DE5 		str	r9, [sp, #4]
 3028 190c FEFFFFEB 		bl	cmdSet
1398:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3029              		.loc 1 1398 0
 3030 1910 1C0094E5 		ldr	r0, [r4, #28]
 3031 1914 FEFFFFEB 		bl	_txe_mutex_put
 3032              	.LVL271:
1401:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3033              		.loc 1 1401 0
 3034 1918 18809DE5 		ldr	r8, [sp, #24]
 3035              	.LVL272:
1404:../uvc.c      **** 							 break;
 3036              		.loc 1 1404 0
 3037 191c FFA0A0E3 		mov	sl, #255
1401:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3038              		.loc 1 1401 0
 3039 1920 9D84C6E5 		strb	r8, [r6, #1181]
1402:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3040              		.loc 1 1402 0
 3041 1924 14C09DE5 		ldr	ip, [sp, #20]
1404:../uvc.c      **** 							 break;
 3042              		.loc 1 1404 0
 3043 1928 0A70A0E1 		mov	r7, sl
 3044              	.LVL273:
1402:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3045              		.loc 1 1402 0
 3046 192c 9EC4C6E5 		strb	ip, [r6, #1182]
1403:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3047              		.loc 1 1403 0
 3048 1930 0C40A0E1 		mov	r4, ip
 3049 1934 A194C6E5 		strb	r9, [r6, #1185]
1404:../uvc.c      **** 							 break;
 3050              		.loc 1 1404 0
 3051 1938 4AFDFFEA 		b	.L142
 3052              	.LVL274:
 3053              	.L237:
1421:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3054              		.loc 1 1421 0
 3055 193c 8780A0E1 		mov	r8, r7, asl #1
 3056 1940 10B49FE5 		ldr	fp, .L311+72
 3057 1944 07C088E0 		add	ip, r8, r7
 3058              	.LVL275:
 3059 1948 8CE186E0 		add	lr, r6, ip, asl #3
1427:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3060              		.loc 1 1427 0
 3061 194c FC439FE5 		ldr	r4, .L311+64
1421:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3062              		.loc 1 1421 0
 3063 1950 0D30CEE5 		strb	r3, [lr, #13]
1423:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3064              		.loc 1 1423 0
 3065 1954 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1422:../uvc.c      **** 							 if(Data0 == 1){
 3066              		.loc 1 1422 0
 3067 1958 010053E3 		cmp	r3, #1
1427:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3068              		.loc 1 1427 0
 3069 195c 0010E0E3 		mvn	r1, #0
 3070 1960 1C0094E5 		ldr	r0, [r4, #28]
1423:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3071              		.loc 1 1423 0
 3072 1964 80B08B03 		orreq	fp, fp, #128
 3073              	.LVL276:
1425:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 3074              		.loc 1 1425 0
 3075 1968 7FB00B12 		andne	fp, fp, #127
 3076              	.LVL277:
1427:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3077              		.loc 1 1427 0
 3078 196c FEFFFFEB 		bl	_txe_mutex_get
 3079              	.LVL278:
1428:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3080              		.loc 1 1428 0
 3081 1970 0A20A0E1 		mov	r2, sl
 3082 1974 2610A0E3 		mov	r1, #38
 3083 1978 0930A0E1 		mov	r3, r9
 3084 197c 0400A0E1 		mov	r0, r4
 3085 1980 00A0A0E3 		mov	sl, #0
 3086 1984 04A08DE5 		str	sl, [sp, #4]
 3087 1988 00B08DE5 		str	fp, [sp, #0]
 3088 198c FEFFFFEB 		bl	cmdSet
1429:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3089              		.loc 1 1429 0
 3090 1990 1C0094E5 		ldr	r0, [r4, #28]
 3091 1994 FEFFFFEB 		bl	_txe_mutex_put
1431:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3092              		.loc 1 1431 0
 3093 1998 071088E0 		add	r1, r8, r7
 3094 199c 816186E0 		add	r6, r6, r1, asl #3
1432:../uvc.c      **** 							 break;
 3095              		.loc 1 1432 0
 3096 19a0 FFA0A0E3 		mov	sl, #255
1431:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3097              		.loc 1 1431 0
 3098 19a4 0120A0E3 		mov	r2, #1
 3099 19a8 1020C6E5 		strb	r2, [r6, #16]
 3100 19ac 18809DE5 		ldr	r8, [sp, #24]
 3101 19b0 1C409DE5 		ldr	r4, [sp, #28]
1432:../uvc.c      **** 							 break;
 3102              		.loc 1 1432 0
 3103 19b4 0A70A0E1 		mov	r7, sl
 3104              	.LVL279:
 3105 19b8 2AFDFFEA 		b	.L142
 3106              	.LVL280:
 3107              	.L226:
1495:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3108              		.loc 1 1495 0
 3109 19bc 8C439FE5 		ldr	r4, .L311+64
 3110 19c0 0010E0E3 		mvn	r1, #0
 3111 19c4 1C0094E5 		ldr	r0, [r4, #28]
 3112 19c8 FEFFFFEB 		bl	_txe_mutex_get
 3113              	.LVL281:
1496:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3114              		.loc 1 1496 0
 3115 19cc 18C09DE5 		ldr	ip, [sp, #24]
 3116 19d0 00E0A0E3 		mov	lr, #0
 3117 19d4 0A20A0E1 		mov	r2, sl
 3118 19d8 0610A0E3 		mov	r1, #6
 3119 19dc 0930A0E1 		mov	r3, r9
 3120 19e0 0400A0E1 		mov	r0, r4
 3121 19e4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3122 19e8 FEFFFFEB 		bl	cmdSet
 3123              	.LVL282:
1498:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3124              		.loc 1 1498 0
 3125 19ec 18A09DE5 		ldr	sl, [sp, #24]
 3126 19f0 0170A0E3 		mov	r7, #1
 3127              	.LVL283:
 3128 19f4 0610A0E3 		mov	r1, #6
 3129 19f8 0B20A0E1 		mov	r2, fp
 3130 19fc 0930A0E1 		mov	r3, r9
 3131 1a00 0400A0E1 		mov	r0, r4
 3132 1a04 00A08DE5 		str	sl, [sp, #0]
 3133 1a08 04708DE5 		str	r7, [sp, #4]
 3134 1a0c FEFFFFEB 		bl	cmdSet
1499:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3135              		.loc 1 1499 0
 3136 1a10 1C0094E5 		ldr	r0, [r4, #28]
 3137 1a14 FEFFFFEB 		bl	_txe_mutex_put
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3138              		.loc 1 1500 0
 3139 1a18 18809DE5 		ldr	r8, [sp, #24]
1502:../uvc.c      **** 							 break;
 3140              		.loc 1 1502 0
 3141 1a1c FFA0A0E3 		mov	sl, #255
1501:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3142              		.loc 1 1501 0
 3143 1a20 2072C6E5 		strb	r7, [r6, #544]
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3144              		.loc 1 1500 0
 3145 1a24 1D82C6E5 		strb	r8, [r6, #541]
1501:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3146              		.loc 1 1501 0
 3147 1a28 1C409DE5 		ldr	r4, [sp, #28]
1502:../uvc.c      **** 							 break;
 3148              		.loc 1 1502 0
 3149 1a2c 0A70A0E1 		mov	r7, sl
 3150 1a30 0CFDFFEA 		b	.L142
 3151              	.LVL284:
 3152              	.L225:
1475:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3153              		.loc 1 1475 0
 3154 1a34 14839FE5 		ldr	r8, .L311+64
 3155 1a38 0010E0E3 		mvn	r1, #0
 3156 1a3c 1C0098E5 		ldr	r0, [r8, #28]
 3157 1a40 FEFFFFEB 		bl	_txe_mutex_get
 3158              	.LVL285:
1476:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3159              		.loc 1 1476 0
 3160 1a44 18209DE5 		ldr	r2, [sp, #24]
 3161 1a48 00C0A0E3 		mov	ip, #0
 3162 1a4c 803042E2 		sub	r3, r2, #128
 3163 1a50 FF4003E2 		and	r4, r3, #255
 3164 1a54 0A20A0E1 		mov	r2, sl
 3165 1a58 0510A0E3 		mov	r1, #5
 3166 1a5c 0930A0E1 		mov	r3, r9
 3167 1a60 0800A0E1 		mov	r0, r8
 3168 1a64 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3169 1a68 FEFFFFEB 		bl	cmdSet
 3170              	.LVL286:
1478:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3171              		.loc 1 1478 0
 3172 1a6c 18A09DE5 		ldr	sl, [sp, #24]
 3173 1a70 0510A0E3 		mov	r1, #5
 3174 1a74 76704AE2 		sub	r7, sl, #118
 3175              	.LVL287:
 3176 1a78 FFE007E2 		and	lr, r7, #255
 3177 1a7c DC20A0E3 		mov	r2, #220
 3178 1a80 0170A0E3 		mov	r7, #1
 3179 1a84 0930A0E1 		mov	r3, r9
 3180 1a88 0800A0E1 		mov	r0, r8
 3181 1a8c 00E08DE5 		str	lr, [sp, #0]
 3182 1a90 04708DE5 		str	r7, [sp, #4]
 3183 1a94 FEFFFFEB 		bl	cmdSet
 3184              	.LVL288:
1480:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3185              		.loc 1 1480 0
 3186 1a98 18009DE5 		ldr	r0, [sp, #24]
 3187 1a9c 02C0A0E3 		mov	ip, #2
 3188 1aa0 7E1080E2 		add	r1, r0, #126
 3189 1aa4 FF4001E2 		and	r4, r1, #255
 3190 1aa8 DE20A0E3 		mov	r2, #222
 3191 1aac 0510A0E3 		mov	r1, #5
 3192 1ab0 0930A0E1 		mov	r3, r9
 3193 1ab4 0800A0E1 		mov	r0, r8
 3194 1ab8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3195 1abc FEFFFFEB 		bl	cmdSet
 3196              	.LVL289:
1482:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3197              		.loc 1 1482 0
 3198 1ac0 18209DE5 		ldr	r2, [sp, #24]
 3199 1ac4 0510A0E3 		mov	r1, #5
 3200 1ac8 723082E2 		add	r3, r2, #114
 3201 1acc FFA003E2 		and	sl, r3, #255
 3202 1ad0 E020A0E3 		mov	r2, #224
 3203 1ad4 0930A0E1 		mov	r3, r9
 3204 1ad8 0800A0E1 		mov	r0, r8
 3205 1adc 0340A0E3 		mov	r4, #3
 3206 1ae0 00A08DE5 		str	sl, [sp, #0]
 3207 1ae4 04408DE5 		str	r4, [sp, #4]
 3208 1ae8 FEFFFFEB 		bl	cmdSet
 3209              	.LVL290:
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3210              		.loc 1 1484 0
 3211 1aec 18009DE5 		ldr	r0, [sp, #24]
 3212 1af0 DD20A0E3 		mov	r2, #221
 3213 1af4 6F1040E2 		sub	r1, r0, #111
 3214 1af8 FFC001E2 		and	ip, r1, #255
 3215 1afc 0930A0E1 		mov	r3, r9
 3216 1b00 0510A0E3 		mov	r1, #5
 3217 1b04 0800A0E1 		mov	r0, r8
 3218 1b08 04A0A0E3 		mov	sl, #4
 3219 1b0c 00C08DE5 		str	ip, [sp, #0]
 3220 1b10 04A08DE5 		str	sl, [sp, #4]
 3221 1b14 FEFFFFEB 		bl	cmdSet
 3222              	.LVL291:
1486:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3223              		.loc 1 1486 0
 3224 1b18 3C229FE5 		ldr	r2, .L311+76
 3225 1b1c 05E0A0E3 		mov	lr, #5
 3226 1b20 5C40D2E5 		ldrb	r4, [r2, #92]	@ zero_extendqisi2
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3227              		.loc 1 1489 0
 3228 1b24 30A29FE5 		ldr	sl, .L311+76
1486:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3229              		.loc 1 1486 0
 3230 1b28 7F3084E2 		add	r3, r4, #127
 3231 1b2c FFC003E2 		and	ip, r3, #255
 3232 1b30 0E10A0E1 		mov	r1, lr
 3233 1b34 0B20A0E1 		mov	r2, fp
 3234 1b38 0930A0E1 		mov	r3, r9
 3235 1b3c 0800A0E1 		mov	r0, r8
 3236 1b40 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3237 1b44 FEFFFFEB 		bl	cmdSet
1487:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3238              		.loc 1 1487 0
 3239 1b48 1C0098E5 		ldr	r0, [r8, #28]
 3240 1b4c FEFFFFEB 		bl	_txe_mutex_put
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3241              		.loc 1 1489 0
 3242 1b50 5C00DAE5 		ldrb	r0, [sl, #92]	@ zero_extendqisi2
1491:../uvc.c      **** 							 break;
 3243              		.loc 1 1491 0
 3244 1b54 FFA0A0E3 		mov	sl, #255
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3245              		.loc 1 1489 0
 3246 1b58 801040E2 		sub	r1, r0, #128
1490:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3247              		.loc 1 1490 0
 3248 1b5c 0872C6E5 		strb	r7, [r6, #520]
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3249              		.loc 1 1489 0
 3250 1b60 0512C6E5 		strb	r1, [r6, #517]
1490:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3251              		.loc 1 1490 0
 3252 1b64 18809DE5 		ldr	r8, [sp, #24]
 3253 1b68 1C409DE5 		ldr	r4, [sp, #28]
1491:../uvc.c      **** 							 break;
 3254              		.loc 1 1491 0
 3255 1b6c 0A70A0E1 		mov	r7, sl
 3256 1b70 BCFCFFEA 		b	.L142
 3257              	.LVL292:
 3258              	.L224:
1522:../uvc.c      **** 							 Data0 = Data0 - 1;
 3259              		.loc 1 1522 0
 3260 1b74 012043E2 		sub	r2, r3, #1
 3261              	.LVL293:
 3262 1b78 FF2002E2 		and	r2, r2, #255
 3263              	.LVL294:
1523:../uvc.c      **** 							 is60Hz = Data0;
 3264              		.loc 1 1523 0
 3265 1b7c D8119FE5 		ldr	r1, .L311+76
1534:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3266              		.loc 1 1534 0
 3267 1b80 D4E19FE5 		ldr	lr, .L311+76
1529:../uvc.c      **** 							 else if(Data0 >2)
 3268              		.loc 1 1529 0
 3269 1b84 020052E3 		cmp	r2, #2
1521:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3270              		.loc 1 1521 0
 3271 1b88 ED31C6E5 		strb	r3, [r6, #493]
1532:../uvc.c      **** 								 is60Hz = CyTrue;
 3272              		.loc 1 1532 0
 3273 1b8c 0130A083 		movhi	r3, #1
1523:../uvc.c      **** 							 is60Hz = Data0;
 3274              		.loc 1 1523 0
 3275 1b90 582081E5 		str	r2, [r1, #88]
 3276              	.LVL295:
1534:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3277              		.loc 1 1534 0
 3278 1b94 0400A0E3 		mov	r0, #4
1532:../uvc.c      **** 								 is60Hz = CyTrue;
 3279              		.loc 1 1532 0
 3280 1b98 58308185 		strhi	r3, [r1, #88]
 3281              	.LVL296:
 3282 1b9c 0320A081 		movhi	r2, r3
1534:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3283              		.loc 1 1534 0
 3284 1ba0 90119FE5 		ldr	r1, .L311+40
 3285 1ba4 58309EE5 		ldr	r3, [lr, #88]
 3286 1ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 3287              	.LVL297:
1535:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3288              		.loc 1 1535 0
 3289 1bac A8019FE5 		ldr	r0, .L311+76
 3290 1bb0 283090E5 		ldr	r3, [r0, #40]
 3291 1bb4 010053E3 		cmp	r3, #1
 3292 1bb8 5101000A 		beq	.L307
 3293              	.LVL298:
 3294              	.L258:
1566:../uvc.c      **** 							 break;
 3295              		.loc 1 1566 0
 3296 1bbc FFA0A0E3 		mov	sl, #255
1565:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3297              		.loc 1 1565 0
 3298 1bc0 0130A0E3 		mov	r3, #1
 3299 1bc4 F031C6E5 		strb	r3, [r6, #496]
 3300 1bc8 18809DE5 		ldr	r8, [sp, #24]
 3301 1bcc 1C409DE5 		ldr	r4, [sp, #28]
1566:../uvc.c      **** 							 break;
 3302              		.loc 1 1566 0
 3303 1bd0 0A70A0E1 		mov	r7, sl
 3304 1bd4 A3FCFFEA 		b	.L142
 3305              	.LVL299:
 3306              	.L223:
1621:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3307              		.loc 1 1621 0
 3308 1bd8 70819FE5 		ldr	r8, .L311+64
 3309 1bdc 0010E0E3 		mvn	r1, #0
 3310 1be0 1C0098E5 		ldr	r0, [r8, #28]
 3311 1be4 FEFFFFEB 		bl	_txe_mutex_get
 3312              	.LVL300:
1622:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3313              		.loc 1 1622 0
 3314 1be8 18C09DE5 		ldr	ip, [sp, #24]
 3315 1bec 0410A0E1 		mov	r1, r4
 3316 1bf0 0A20A0E1 		mov	r2, sl
 3317 1bf4 0930A0E1 		mov	r3, r9
 3318 1bf8 0800A0E1 		mov	r0, r8
 3319 1bfc 00A0A0E3 		mov	sl, #0
 3320 1c00 00C08DE5 		str	ip, [sp, #0]
 3321 1c04 04A08DE5 		str	sl, [sp, #4]
 3322 1c08 FEFFFFEB 		bl	cmdSet
1623:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3323              		.loc 1 1623 0
 3324 1c0c 1C0098E5 		ldr	r0, [r8, #28]
 3325 1c10 FEFFFFEB 		bl	_txe_mutex_put
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3326              		.loc 1 1625 0
 3327 1c14 18709DE5 		ldr	r7, [sp, #24]
 3328              	.LVL301:
1630:../uvc.c      **** 							 break;
 3329              		.loc 1 1630 0
 3330 1c18 FFA0A0E3 		mov	sl, #255
1626:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3331              		.loc 1 1626 0
 3332 1c1c 0130A0E3 		mov	r3, #1
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3333              		.loc 1 1625 0
 3334 1c20 BD71C6E5 		strb	r7, [r6, #445]
1626:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3335              		.loc 1 1626 0
 3336 1c24 0780A0E1 		mov	r8, r7
 3337 1c28 C031C6E5 		strb	r3, [r6, #448]
 3338 1c2c 1C409DE5 		ldr	r4, [sp, #28]
1630:../uvc.c      **** 							 break;
 3339              		.loc 1 1630 0
 3340 1c30 0A70A0E1 		mov	r7, sl
 3341 1c34 8BFCFFEA 		b	.L142
 3342              	.LVL302:
 3343              	.L222:
1457:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3344              		.loc 1 1457 0
 3345 1c38 10819FE5 		ldr	r8, .L311+64
 3346 1c3c 0010E0E3 		mvn	r1, #0
 3347 1c40 1C0098E5 		ldr	r0, [r8, #28]
 3348 1c44 FEFFFFEB 		bl	_txe_mutex_get
 3349              	.LVL303:
1459:../uvc.c      **** 							  if(Data0&0x80){
 3350              		.loc 1 1459 0
 3351 1c48 18209DE5 		ldr	r2, [sp, #24]
1464:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3352              		.loc 1 1464 0
 3353 1c4c 0930A0E1 		mov	r3, r9
1459:../uvc.c      **** 							  if(Data0&0x80){
 3354              		.loc 1 1459 0
 3355 1c50 800012E3 		tst	r2, #128
1460:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3356              		.loc 1 1460 0
 3357 1c54 80704212 		subne	r7, r2, #128
 3358              	.LVL304:
1462:../uvc.c      **** 								  Data0 = ~Data0;
 3359              		.loc 1 1462 0
 3360 1c58 0270E001 		mvneq	r7, r2
 3361 1c5c FF7007E2 		and	r7, r7, #255
 3362              	.LVL305:
1464:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3363              		.loc 1 1464 0
 3364 1c60 0110A0E3 		mov	r1, #1
 3365 1c64 0B20A0E1 		mov	r2, fp
 3366 1c68 0040A0E3 		mov	r4, #0
 3367 1c6c DC009FE5 		ldr	r0, .L311+64
 3368 1c70 00708DE5 		str	r7, [sp, #0]
 3369 1c74 04408DE5 		str	r4, [sp, #4]
 3370 1c78 FEFFFFEB 		bl	cmdSet
1465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3371              		.loc 1 1465 0
 3372 1c7c 1C0098E5 		ldr	r0, [r8, #28]
 3373 1c80 FEFFFFEB 		bl	_txe_mutex_put
1471:../uvc.c      **** 							 break;
 3374              		.loc 1 1471 0
 3375 1c84 FFA0A0E3 		mov	sl, #255
1468:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3376              		.loc 1 1468 0
 3377 1c88 0130A0E3 		mov	r3, #1
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3378              		.loc 1 1467 0
 3379 1c8c A571C6E5 		strb	r7, [r6, #421]
1468:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3380              		.loc 1 1468 0
 3381 1c90 A831C6E5 		strb	r3, [r6, #424]
 3382 1c94 18809DE5 		ldr	r8, [sp, #24]
 3383 1c98 1C409DE5 		ldr	r4, [sp, #28]
1471:../uvc.c      **** 							 break;
 3384              		.loc 1 1471 0
 3385 1c9c 0A70A0E1 		mov	r7, sl
 3386              	.LVL306:
 3387 1ca0 70FCFFEA 		b	.L142
 3388              	.LVL307:
 3389              	.L221:
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3390              		.loc 1 1578 0
 3391 1ca4 B0409FE5 		ldr	r4, .L311+76
1568:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3392              		.loc 1 1568 0
 3393 1ca8 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3394              	.LVL308:
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3395              		.loc 1 1578 0
 3396 1cac BC20D4E5 		ldrb	r2, [r4, #188]	@ zero_extendqisi2
 3397              	.LVL309:
 3398 1cb0 0310A0E1 		mov	r1, r3
1569:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3399              		.loc 1 1569 0
 3400 1cb4 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1570:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3401              		.loc 1 1570 0
 3402 1cb8 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3403              		.loc 1 1578 0
 3404 1cbc 010052E3 		cmp	r2, #1
1576:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3405              		.loc 1 1576 0
 3406 1cc0 01E0A0E3 		mov	lr, #1
1575:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3407              		.loc 1 1575 0
 3408 1cc4 0515C6E5 		strb	r1, [r6, #1285]
1568:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3409              		.loc 1 1568 0
 3410 1cc8 FF7007E2 		and	r7, r7, #255
 3411              	.LVL310:
1576:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3412              		.loc 1 1576 0
 3413 1ccc 09E5C6E5 		strb	lr, [r6, #1289]
1570:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3414              		.loc 1 1570 0
 3415 1cd0 FF8008E2 		and	r8, r8, #255
 3416              	.LVL311:
 3417 1cd4 0160A011 		movne	r6, r1
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3418              		.loc 1 1578 0
 3419 1cd8 6E01000A 		beq	.L308
 3420              	.LVL312:
 3421              	.L272:
1589:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3422              		.loc 1 1589 0
 3423 1cdc 6CA09FE5 		ldr	sl, .L311+64
 3424 1ce0 0010E0E3 		mvn	r1, #0
 3425 1ce4 1C009AE5 		ldr	r0, [sl, #28]
 3426 1ce8 FEFFFFEB 		bl	_txe_mutex_get
1590:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3427              		.loc 1 1590 0
 3428 1cec 00C0A0E3 		mov	ip, #0
 3429 1cf0 0C10A0E1 		mov	r1, ip
 3430 1cf4 0720A0E1 		mov	r2, r7
 3431 1cf8 0830A0E1 		mov	r3, r8
 3432 1cfc 0A00A0E1 		mov	r0, sl
 3433 1d00 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3434 1d04 FEFFFFEB 		bl	cmdSet
1591:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3435              		.loc 1 1591 0
 3436 1d08 1C009AE5 		ldr	r0, [sl, #28]
 3437 1d0c 9BFEFFEA 		b	.L298
 3438              	.L312:
 3439              		.align	2
 3440              	.L311:
 3441 1d10 00000000 		.word	bRequest
 3442 1d14 B4040000 		.word	.LC29
 3443 1d18 5C000000 		.word	.LANCHOR0+92
 3444 1d1c 01000100 		.word	65537
 3445 1d20 FF00FF00 		.word	16711935
 3446 1d24 44030000 		.word	.LC21
 3447 1d28 80030000 		.word	.LC22
 3448 1d2c E4020000 		.word	.LC19
 3449 1d30 4C000000 		.word	.LANCHOR0+76
 3450 1d34 08040000 		.word	.LC25
 3451 1d38 40040000 		.word	.LC26
 3452 1d3c D4030000 		.word	.LC24
 3453 1d40 A8030000 		.word	.LC23
 3454 1d44 84040000 		.word	.LC28
 3455 1d48 60040000 		.word	.LC27
 3456 1d4c BC020000 		.word	.LC18
 3457 1d50 00000000 		.word	cmdQu
 3458 1d54 0C030000 		.word	.LC20
 3459 1d58 00000000 		.word	.LANCHOR1
 3460 1d5c 00000000 		.word	.LANCHOR0
 3461              	.LVL313:
 3462              	.L220:
1634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3463              		.loc 1 1634 0
 3464 1d60 18701FE5 		ldr	r7, .L311+64
 3465              	.LVL314:
 3466 1d64 0010E0E3 		mvn	r1, #0
 3467 1d68 1C0097E5 		ldr	r0, [r7, #28]
 3468 1d6c FEFFFFEB 		bl	_txe_mutex_get
 3469              	.LVL315:
1635:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3470              		.loc 1 1635 0
 3471 1d70 0A20A0E1 		mov	r2, sl
 3472 1d74 18A09DE5 		ldr	sl, [sp, #24]
 3473 1d78 0410A0E1 		mov	r1, r4
 3474 1d7c 0930A0E1 		mov	r3, r9
 3475 1d80 0700A0E1 		mov	r0, r7
 3476 1d84 0080A0E3 		mov	r8, #0
 3477 1d88 00A08DE5 		str	sl, [sp, #0]
 3478 1d8c 04808DE5 		str	r8, [sp, #4]
 3479 1d90 FEFFFFEB 		bl	cmdSet
1636:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3480              		.loc 1 1636 0
 3481 1d94 1C0097E5 		ldr	r0, [r7, #28]
 3482 1d98 FEFFFFEB 		bl	_txe_mutex_put
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3483              		.loc 1 1638 0
 3484 1d9c 18109DE5 		ldr	r1, [sp, #24]
 3485 1da0 840084E0 		add	r0, r4, r4, asl #1
 3486 1da4 806186E0 		add	r6, r6, r0, asl #3
1640:../uvc.c      **** 							 break;
 3487              		.loc 1 1640 0
 3488 1da8 FFA0A0E3 		mov	sl, #255
1639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3489              		.loc 1 1639 0
 3490 1dac 0120A0E3 		mov	r2, #1
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3491              		.loc 1 1638 0
 3492 1db0 8D11C6E5 		strb	r1, [r6, #397]
1639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3493              		.loc 1 1639 0
 3494 1db4 9021C6E5 		strb	r2, [r6, #400]
 3495 1db8 0180A0E1 		mov	r8, r1
 3496 1dbc 1C409DE5 		ldr	r4, [sp, #28]
1640:../uvc.c      **** 							 break;
 3497              		.loc 1 1640 0
 3498 1dc0 0A70A0E1 		mov	r7, sl
 3499 1dc4 27FCFFEA 		b	.L142
 3500              	.LVL316:
 3501              	.L230:
1275:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3502              		.loc 1 1275 0
 3503 1dc8 80401FE5 		ldr	r4, .L311+64
1271:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3504              		.loc 1 1271 0
 3505 1dcc E0A4D6E5 		ldrb	sl, [r6, #1248]	@ zero_extendqisi2
1272:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3506              		.loc 1 1272 0
 3507 1dd0 E1E4D6E5 		ldrb	lr, [r6, #1249]	@ zero_extendqisi2
1273:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3508              		.loc 1 1273 0
 3509 1dd4 EFC4D6E5 		ldrb	ip, [r6, #1263]	@ zero_extendqisi2
 3510              	.LVL317:
1275:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3511              		.loc 1 1275 0
 3512 1dd8 0010E0E3 		mvn	r1, #0
 3513 1ddc 1C0094E5 		ldr	r0, [r4, #28]
1273:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3514              		.loc 1 1273 0
 3515 1de0 FF800CE2 		and	r8, ip, #255
1272:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3516              		.loc 1 1272 0
 3517 1de4 FF900EE2 		and	r9, lr, #255
1275:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3518              		.loc 1 1275 0
 3519 1de8 FEFFFFEB 		bl	_txe_mutex_get
 3520              	.LVL318:
1276:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3521              		.loc 1 1276 0
 3522 1dec 18C09DE5 		ldr	ip, [sp, #24]
 3523 1df0 ED14D6E5 		ldrb	r1, [r6, #1261]	@ zero_extendqisi2
1271:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3524              		.loc 1 1271 0
 3525 1df4 FFA00AE2 		and	sl, sl, #255
 3526              	.LVL319:
1276:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3527              		.loc 1 1276 0
 3528 1df8 01005CE1 		cmp	ip, r1
1271:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3529              		.loc 1 1271 0
 3530 1dfc AC301FE5 		ldr	r3, .L311+72
 3531 1e00 0C70A001 		moveq	r7, ip
 3532              	.LVL320:
1276:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3533              		.loc 1 1276 0
 3534 1e04 0A00000A 		beq	.L243
1278:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3535              		.loc 1 1278 0
 3536 1e08 EDC4C3E5 		strb	ip, [r3, #1261]
1279:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3537              		.loc 1 1279 0
 3538 1e0c C534D3E5 		ldrb	r3, [r3, #1221]	@ zero_extendqisi2
1280:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3539              		.loc 1 1280 0
 3540 1e10 0400A0E1 		mov	r0, r4
1279:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3541              		.loc 1 1279 0
 3542 1e14 03728CE1 		orr	r7, ip, r3, asl #4
 3543 1e18 FF7007E2 		and	r7, r7, #255
 3544              	.LVL321:
1280:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3545              		.loc 1 1280 0
 3546 1e1c 00C0A0E3 		mov	ip, #0
 3547 1e20 1910A0E3 		mov	r1, #25
 3548 1e24 0A20A0E1 		mov	r2, sl
 3549 1e28 0830A0E1 		mov	r3, r8
 3550 1e2c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3551 1e30 FEFFFFEB 		bl	cmdSet
 3552              	.LVL322:
 3553              	.L243:
1292:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3554              		.loc 1 1292 0
 3555 1e34 EE04D6E5 		ldrb	r0, [r6, #1262]	@ zero_extendqisi2
 3556 1e38 1CE09DE5 		ldr	lr, [sp, #28]
 3557 1e3c 0E0050E1 		cmp	r0, lr
 3558 1e40 0500000A 		beq	.L244
1294:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3559              		.loc 1 1294 0
 3560 1e44 18A09DE5 		ldr	sl, [sp, #24]
 3561              	.LVL323:
1293:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3562              		.loc 1 1293 0
 3563 1e48 F8201FE5 		ldr	r2, .L311+72
1294:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3564              		.loc 1 1294 0
 3565 1e4c 02104AE2 		sub	r1, sl, #2
 3566 1e50 010051E3 		cmp	r1, #1
1293:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3567              		.loc 1 1293 0
 3568 1e54 EEE4C2E5 		strb	lr, [r2, #1262]
1294:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3569              		.loc 1 1294 0
 3570 1e58 E101009A 		bls	.L309
 3571              	.LVL324:
 3572              	.L244:
1299:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3573              		.loc 1 1299 0
 3574 1e5c 1C0094E5 		ldr	r0, [r4, #28]
 3575 1e60 FEFFFFEB 		bl	_txe_mutex_put
1301:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3576              		.loc 1 1301 0
 3577 1e64 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3578              		.loc 1 1300 0
 3579 1e68 1C409DE5 		ldr	r4, [sp, #28]
1301:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3580              		.loc 1 1301 0
 3581 1e6c EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
 3582 1e70 C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3583              		.loc 1 1300 0
 3584 1e74 0400A0E3 		mov	r0, #4
 3585 1e78 44111FE5 		ldr	r1, .L311+44
1302:../uvc.c      **** 							 break;
 3586              		.loc 1 1302 0
 3587 1e7c FFA0A0E3 		mov	sl, #255
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3588              		.loc 1 1300 0
 3589 1e80 04708DE5 		str	r7, [sp, #4]
 3590 1e84 00C08DE5 		str	ip, [sp, #0]
 3591 1e88 08408DE5 		str	r4, [sp, #8]
1302:../uvc.c      **** 							 break;
 3592              		.loc 1 1302 0
 3593 1e8c 0A70A0E1 		mov	r7, sl
 3594              	.LVL325:
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3595              		.loc 1 1300 0
 3596 1e90 FEFFFFEB 		bl	CyU3PDebugPrint
 3597              	.LVL326:
 3598 1e94 18809DE5 		ldr	r8, [sp, #24]
1302:../uvc.c      **** 							 break;
 3599              		.loc 1 1302 0
 3600 1e98 F2FBFFEA 		b	.L142
 3601              	.LVL327:
 3602              	.L229:
1211:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3603              		.loc 1 1211 0
 3604 1e9c B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 3605 1ea0 0310A0E1 		mov	r1, r3
1212:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3606              		.loc 1 1212 0
 3607 1ea4 B984D6E5 		ldrb	r8, [r6, #1209]	@ zero_extendqisi2
1213:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3608              		.loc 1 1213 0
 3609 1ea8 C744D6E5 		ldrb	r4, [r6, #1223]	@ zero_extendqisi2
1214:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3610              		.loc 1 1214 0
 3611 1eac C534C6E5 		strb	r3, [r6, #1221]
1216:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3612              		.loc 1 1216 0
 3613 1eb0 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
1211:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3614              		.loc 1 1211 0
 3615 1eb4 FF700AE2 		and	r7, sl, #255
 3616              	.LVL328:
1216:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3617              		.loc 1 1216 0
 3618 1eb8 030013E3 		tst	r3, #3
1212:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3619              		.loc 1 1212 0
 3620 1ebc FF8008E2 		and	r8, r8, #255
 3621              	.LVL329:
1213:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3622              		.loc 1 1213 0
 3623 1ec0 FF4004E2 		and	r4, r4, #255
 3624              	.LVL330:
1216:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3625              		.loc 1 1216 0
 3626 1ec4 0130A001 		moveq	r3, r1
 3627 1ec8 1D00000A 		beq	.L242
1218:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3628              		.loc 1 1218 0
 3629 1ecc 7C911FE5 		ldr	r9, .L311+72
1220:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3630              		.loc 1 1220 0
 3631 1ed0 88A11FE5 		ldr	sl, .L311+64
1218:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3632              		.loc 1 1218 0
 3633 1ed4 ED04D9E5 		ldrb	r0, [r9, #1261]	@ zero_extendqisi2
 3634 1ed8 0120A0E1 		mov	r2, r1
 3635              	.LVL331:
 3636 1edc 023280E1 		orr	r3, r0, r2, asl #4
1220:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3637              		.loc 1 1220 0
 3638 1ee0 0010E0E3 		mvn	r1, #0
 3639 1ee4 1C009AE5 		ldr	r0, [sl, #28]
1218:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3640              		.loc 1 1218 0
 3641 1ee8 FF9003E2 		and	r9, r3, #255
 3642              	.LVL332:
1220:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3643              		.loc 1 1220 0
 3644 1eec 14C08DE5 		str	ip, [sp, #20]
 3645 1ef0 FEFFFFEB 		bl	_txe_mutex_get
 3646              	.LVL333:
1221:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3647              		.loc 1 1221 0
 3648 1ef4 00E0A0E3 		mov	lr, #0
 3649 1ef8 1010A0E3 		mov	r1, #16
 3650 1efc 0820A0E1 		mov	r2, r8
 3651 1f00 0430A0E1 		mov	r3, r4
 3652 1f04 0A00A0E1 		mov	r0, sl
 3653 1f08 00E08DE5 		str	lr, [sp, #0]
 3654 1f0c 04E08DE5 		str	lr, [sp, #4]
 3655 1f10 FEFFFFEB 		bl	cmdSet
 3656              	.LVL334:
1223:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3657              		.loc 1 1223 0
 3658 1f14 0720A0E1 		mov	r2, r7
 3659 1f18 0430A0E1 		mov	r3, r4
 3660 1f1c 1010A0E3 		mov	r1, #16
 3661 1f20 0A00A0E1 		mov	r0, sl
 3662 1f24 0170A0E3 		mov	r7, #1
 3663              	.LVL335:
 3664 1f28 00908DE5 		str	r9, [sp, #0]
 3665 1f2c 04708DE5 		str	r7, [sp, #4]
 3666 1f30 FEFFFFEB 		bl	cmdSet
 3667              	.LVL336:
1224:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3668              		.loc 1 1224 0
 3669 1f34 1C009AE5 		ldr	r0, [sl, #28]
 3670 1f38 FEFFFFEB 		bl	_txe_mutex_put
 3671 1f3c 14C09DE5 		ldr	ip, [sp, #20]
 3672 1f40 0930A0E1 		mov	r3, r9
 3673              	.LVL337:
 3674              	.L242:
1227:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3675              		.loc 1 1227 0
 3676 1f44 ED84D6E5 		ldrb	r8, [r6, #1261]	@ zero_extendqisi2
 3677              	.LVL338:
 3678 1f48 C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3679              	.LVL339:
1226:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3680              		.loc 1 1226 0
 3681 1f4c 0400A0E3 		mov	r0, #4
 3682 1f50 18121FE5 		ldr	r1, .L311+48
 3683 1f54 0C20A0E1 		mov	r2, ip
1228:../uvc.c      **** 						     break;
 3684              		.loc 1 1228 0
 3685 1f58 FFA0A0E3 		mov	sl, #255
1226:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3686              		.loc 1 1226 0
 3687 1f5c 00808DE5 		str	r8, [sp, #0]
 3688 1f60 04408DE5 		str	r4, [sp, #4]
1228:../uvc.c      **** 						     break;
 3689              		.loc 1 1228 0
 3690 1f64 0A70A0E1 		mov	r7, sl
1226:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3691              		.loc 1 1226 0
 3692 1f68 FEFFFFEB 		bl	CyU3PDebugPrint
 3693 1f6c 18809DE5 		ldr	r8, [sp, #24]
 3694 1f70 1C409DE5 		ldr	r4, [sp, #28]
1228:../uvc.c      **** 						     break;
 3695              		.loc 1 1228 0
 3696 1f74 BBFBFFEA 		b	.L142
 3697              	.LVL340:
 3698              	.L228:
1509:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3699              		.loc 1 1509 0
 3700 1f78 30721FE5 		ldr	r7, .L311+64
 3701              	.LVL341:
 3702 1f7c 0010E0E3 		mvn	r1, #0
 3703 1f80 1C0097E5 		ldr	r0, [r7, #28]
 3704 1f84 FEFFFFEB 		bl	_txe_mutex_get
 3705              	.LVL342:
1510:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3706              		.loc 1 1510 0
 3707 1f88 18C09DE5 		ldr	ip, [sp, #24]
 3708 1f8c 0A20A0E1 		mov	r2, sl
 3709 1f90 0B10A0E3 		mov	r1, #11
 3710 1f94 0930A0E1 		mov	r3, r9
 3711 1f98 0700A0E1 		mov	r0, r7
 3712 1f9c 00A0A0E3 		mov	sl, #0
 3713 1fa0 00C08DE5 		str	ip, [sp, #0]
 3714 1fa4 04A08DE5 		str	sl, [sp, #4]
 3715 1fa8 FEFFFFEB 		bl	cmdSet
 3716              	.LVL343:
1512:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3717              		.loc 1 1512 0
 3718 1fac 1C409DE5 		ldr	r4, [sp, #28]
 3719 1fb0 0180A0E3 		mov	r8, #1
 3720 1fb4 0B10A0E3 		mov	r1, #11
 3721 1fb8 0B20A0E1 		mov	r2, fp
 3722 1fbc 0930A0E1 		mov	r3, r9
 3723 1fc0 0700A0E1 		mov	r0, r7
 3724 1fc4 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3725 1fc8 FEFFFFEB 		bl	cmdSet
1513:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3726              		.loc 1 1513 0
 3727 1fcc 1C0097E5 		ldr	r0, [r7, #28]
 3728 1fd0 FEFFFFEB 		bl	_txe_mutex_put
1515:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3729              		.loc 1 1515 0
 3730 1fd4 18009DE5 		ldr	r0, [sp, #24]
1516:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3731              		.loc 1 1516 0
 3732 1fd8 1C109DE5 		ldr	r1, [sp, #28]
1518:../uvc.c      **** 							 break;
 3733              		.loc 1 1518 0
 3734 1fdc FFA0A0E3 		mov	sl, #255
1517:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3735              		.loc 1 1517 0
 3736 1fe0 9882C6E5 		strb	r8, [r6, #664]
1515:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3737              		.loc 1 1515 0
 3738 1fe4 F404C6E5 		strb	r0, [r6, #1268]
1516:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3739              		.loc 1 1516 0
 3740 1fe8 F614C6E5 		strb	r1, [r6, #1270]
1517:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3741              		.loc 1 1517 0
 3742 1fec 0080A0E1 		mov	r8, r0
 3743 1ff0 0140A0E1 		mov	r4, r1
1518:../uvc.c      **** 							 break;
 3744              		.loc 1 1518 0
 3745 1ff4 0A70A0E1 		mov	r7, sl
 3746 1ff8 9AFBFFEA 		b	.L142
 3747              	.LVL344:
 3748              	.L227:
1595:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3749              		.loc 1 1595 0
 3750 1ffc 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1596:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3751              		.loc 1 1596 0
 3752 2000 0D25D6E5 		ldrb	r2, [r6, #1293]	@ zero_extendqisi2
 3753              	.LVL345:
1597:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3754              		.loc 1 1597 0
 3755 2004 1B15D6E5 		ldrb	r1, [r6, #1307]	@ zero_extendqisi2
1600:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3756              		.loc 1 1600 0
 3757 2008 0140A0E3 		mov	r4, #1
1601:../uvc.c      **** 							 if(Data0 != 0){
 3758              		.loc 1 1601 0
 3759 200c 000053E3 		cmp	r3, #0
1599:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3760              		.loc 1 1599 0
 3761 2010 1935C6E5 		strb	r3, [r6, #1305]
1595:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3762              		.loc 1 1595 0
 3763 2014 FF8000E2 		and	r8, r0, #255
 3764              	.LVL346:
1596:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3765              		.loc 1 1596 0
 3766 2018 FFA002E2 		and	sl, r2, #255
 3767              	.LVL347:
1597:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3768              		.loc 1 1597 0
 3769 201c FF7001E2 		and	r7, r1, #255
 3770              	.LVL348:
1600:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3771              		.loc 1 1600 0
 3772 2020 1D45C6E5 		strb	r4, [r6, #1309]
1601:../uvc.c      **** 							 if(Data0 != 0){
 3773              		.loc 1 1601 0
 3774 2024 1C00000A 		beq	.L274
1602:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3775              		.loc 1 1602 0
 3776 2028 E0621FE5 		ldr	r6, .L311+64
 3777 202c 0010E0E3 		mvn	r1, #0
 3778 2030 1C0096E5 		ldr	r0, [r6, #28]
 3779 2034 FEFFFFEB 		bl	_txe_mutex_get
 3780              	.LVL349:
1606:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3781              		.loc 1 1606 0
 3782 2038 0820A0E1 		mov	r2, r8
 3783 203c 00C0A0E3 		mov	ip, #0
 3784 2040 0710A0E3 		mov	r1, #7
 3785 2044 0730A0E1 		mov	r3, r7
 3786 2048 0600A0E1 		mov	r0, r6
 3787 204c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3788 2050 FEFFFFEB 		bl	cmdSet
 3789              	.LVL350:
1608:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3790              		.loc 1 1608 0
 3791 2054 18809DE5 		ldr	r8, [sp, #24]
 3792              	.LVL351:
 3793 2058 0710A0E3 		mov	r1, #7
 3794 205c 0A20A0E1 		mov	r2, sl
 3795 2060 0730A0E1 		mov	r3, r7
 3796 2064 0600A0E1 		mov	r0, r6
 3797 2068 00808DE5 		str	r8, [sp, #0]
 3798 206c 04408DE5 		str	r4, [sp, #4]
 3799 2070 FEFFFFEB 		bl	cmdSet
1610:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3800              		.loc 1 1610 0
 3801 2074 1C0096E5 		ldr	r0, [r6, #28]
 3802 2078 C0FDFFEA 		b	.L298
 3803              	.LVL352:
 3804              	.L219:
1643:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3805              		.loc 1 1643 0
 3806 207c FFA0A0E3 		mov	sl, #255
 3807 2080 0400A0E3 		mov	r0, #4
 3808              	.LVL353:
 3809 2084 48131FE5 		ldr	r1, .L311+52
 3810 2088 FEFFFFEB 		bl	CyU3PDebugPrint
 3811              	.LVL354:
 3812 208c 0A70A0E1 		mov	r7, sl
 3813              	.LVL355:
 3814 2090 0A40A0E1 		mov	r4, sl
 3815 2094 0A80A0E1 		mov	r8, sl
 3816 2098 72FBFFEA 		b	.L142
 3817              	.LVL356:
 3818              	.L274:
1612:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3819              		.loc 1 1612 0
 3820 209c 54431FE5 		ldr	r4, .L311+64
 3821 20a0 0010E0E3 		mvn	r1, #0
 3822 20a4 1C0094E5 		ldr	r0, [r4, #28]
 3823 20a8 FEFFFFEB 		bl	_txe_mutex_get
 3824              	.LVL357:
1613:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3825              		.loc 1 1613 0
 3826 20ac 18E09DE5 		ldr	lr, [sp, #24]
 3827 20b0 0820A0E1 		mov	r2, r8
 3828 20b4 0730A0E1 		mov	r3, r7
 3829 20b8 0710A0E3 		mov	r1, #7
 3830 20bc 0400A0E1 		mov	r0, r4
 3831 20c0 00E08DE5 		str	lr, [sp, #0]
 3832 20c4 04E08DE5 		str	lr, [sp, #4]
1614:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3833              		.loc 1 1614 0
 3834 20c8 FFA0A0E3 		mov	sl, #255
 3835              	.LVL358:
1613:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3836              		.loc 1 1613 0
 3837 20cc FEFFFFEB 		bl	cmdSet
1614:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3838              		.loc 1 1614 0
 3839 20d0 1C0094E5 		ldr	r0, [r4, #28]
 3840 20d4 FEFFFFEB 		bl	_txe_mutex_put
 3841 20d8 0A70A0E1 		mov	r7, sl
 3842              	.LVL359:
 3843 20dc 1C409DE5 		ldr	r4, [sp, #28]
 3844 20e0 18809DE5 		ldr	r8, [sp, #24]
 3845              	.LVL360:
 3846 20e4 5FFBFFEA 		b	.L142
 3847              	.LVL361:
 3848              	.L306:
 972:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 3849              		.loc 1 972 0
 3850 20e8 0A00A0E1 		mov	r0, sl
 3851 20ec 0910A0E1 		mov	r1, r9
 3852 20f0 FEFFFFEB 		bl	SensorGetControl
 3853              	.LVL362:
 974:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3854              		.loc 1 974 0
 3855 20f4 01A0A0E3 		mov	sl, #1
 3856 20f8 81A0C4E5 		strb	sl, [r4, #129]
 973:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 3857              		.loc 1 973 0
 3858 20fc 0502C6E5 		strb	r0, [r6, #517]
 3859 2100 47FDFFEA 		b	.L189
 3860              	.LVL363:
 3861              	.L307:
1538:../uvc.c      **** 			                       switch (setRes)
 3862              		.loc 1 1538 0
 3863 2104 BD80D0E5 		ldrb	r8, [r0, #189]	@ zero_extendqisi2
 3864 2108 010048E2 		sub	r0, r8, #1
 3865 210c 030050E3 		cmp	r0, #3
 3866 2110 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 3867 2114 A8FEFFEA 		b	.L258
 3868              	.L263:
 3869 2118 44220000 		.word	.L259
 3870 211c F0210000 		.word	.L260
 3871 2120 8C210000 		.word	.L261
 3872 2124 28210000 		.word	.L262
 3873              	.L262:
1556:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 3874              		.loc 1 1556 0
 3875 2128 D4031FE5 		ldr	r0, .L311+76
1558:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3876              		.loc 1 1558 0
 3877 212c D8A31FE5 		ldr	sl, .L311+76
1556:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 3878              		.loc 1 1556 0
 3879 2130 58C090E5 		ldr	ip, [r0, #88]
 3880 2134 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3881 2138 00005CE3 		cmp	ip, #0
 3882 213c F4C0A003 		moveq	ip, #244
 3883 2140 74C0A013 		movne	ip, #116
 3884 2144 02208CE1 		orr	r2, ip, r2
 3885 2148 3010A0E3 		mov	r1, #48
 3886 214c 5230A0E3 		mov	r3, #82
 3887 2150 0100A0E3 		mov	r0, #1
 3888 2154 FEFFFFEB 		bl	SensorSetIrisControl
1557:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3889              		.loc 1 1557 0
 3890 2158 7D0FA0E3 		mov	r0, #500
 3891 215c FEFFFFEB 		bl	_tx_thread_sleep
1558:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3892              		.loc 1 1558 0
 3893 2160 58409AE5 		ldr	r4, [sl, #88]
 3894 2164 8C74D6E5 		ldrb	r7, [r6, #1164]	@ zero_extendqisi2
 3895              	.LVL364:
 3896 2168 000054E3 		cmp	r4, #0
 3897 216c F440A003 		moveq	r4, #244
 3898 2170 7440A013 		movne	r4, #116
 3899 2174 58309AE5 		ldr	r3, [sl, #88]
 3900 2178 38141FE5 		ldr	r1, .L311+56
 3901 217c 072084E1 		orr	r2, r4, r7
 3902 2180 0400A0E3 		mov	r0, #4
 3903 2184 FEFFFFEB 		bl	CyU3PDebugPrint
 3904 2188 8BFEFFEA 		b	.L258
 3905              	.LVL365:
 3906              	.L261:
1551:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3907              		.loc 1 1551 0
 3908 218c 38841FE5 		ldr	r8, .L311+76
 3909 2190 5230A0E3 		mov	r3, #82
 3910 2194 58E098E5 		ldr	lr, [r8, #88]
 3911 2198 8C14D6E5 		ldrb	r1, [r6, #1164]	@ zero_extendqisi2
 3912 219c 00005EE3 		cmp	lr, #0
 3913 21a0 C4E0A003 		moveq	lr, #196
 3914 21a4 44E0A013 		movne	lr, #68
 3915 21a8 01208EE1 		orr	r2, lr, r1
 3916 21ac 0100A0E3 		mov	r0, #1
 3917 21b0 3010A0E3 		mov	r1, #48
 3918 21b4 FEFFFFEB 		bl	SensorSetIrisControl
1552:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3919              		.loc 1 1552 0
 3920 21b8 7D0FA0E3 		mov	r0, #500
 3921 21bc FEFFFFEB 		bl	_tx_thread_sleep
1553:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3922              		.loc 1 1553 0
 3923 21c0 6C341FE5 		ldr	r3, .L311+76
 3924 21c4 84141FE5 		ldr	r1, .L311+56
 3925 21c8 580093E5 		ldr	r0, [r3, #88]
 3926 21cc 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3927 21d0 000050E3 		cmp	r0, #0
 3928 21d4 C400A003 		moveq	r0, #196
 3929 21d8 4400A013 		movne	r0, #68
 3930 21dc 022080E1 		orr	r2, r0, r2
 3931 21e0 583093E5 		ldr	r3, [r3, #88]
 3932 21e4 0400A0E3 		mov	r0, #4
 3933 21e8 FEFFFFEB 		bl	CyU3PDebugPrint
1554:../uvc.c      **** 			                         		break;
 3934              		.loc 1 1554 0
 3935 21ec 72FEFFEA 		b	.L258
 3936              	.L260:
1546:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3937              		.loc 1 1546 0
 3938 21f0 9CC41FE5 		ldr	ip, .L311+76
1548:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3939              		.loc 1 1548 0
 3940 21f4 A0A41FE5 		ldr	sl, .L311+76
1546:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3941              		.loc 1 1546 0
 3942 21f8 58209CE5 		ldr	r2, [ip, #88]
 3943 21fc 3010A0E3 		mov	r1, #48
 3944 2200 000052E3 		cmp	r2, #0
 3945 2204 D420A003 		moveq	r2, #212
 3946 2208 5420A013 		movne	r2, #84
 3947 220c 5230A0E3 		mov	r3, #82
 3948 2210 0100A0E3 		mov	r0, #1
 3949 2214 FEFFFFEB 		bl	SensorSetIrisControl
1547:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3950              		.loc 1 1547 0
 3951 2218 7D0FA0E3 		mov	r0, #500
 3952 221c FEFFFFEB 		bl	_tx_thread_sleep
1548:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3953              		.loc 1 1548 0
 3954 2220 58209AE5 		ldr	r2, [sl, #88]
 3955 2224 E4141FE5 		ldr	r1, .L311+56
 3956 2228 000052E3 		cmp	r2, #0
 3957 222c 58309AE5 		ldr	r3, [sl, #88]
 3958 2230 D420A003 		moveq	r2, #212
 3959 2234 5420A013 		movne	r2, #84
 3960 2238 0400A0E3 		mov	r0, #4
 3961 223c FEFFFFEB 		bl	CyU3PDebugPrint
1549:../uvc.c      **** 			                         		break;
 3962              		.loc 1 1549 0
 3963 2240 5DFEFFEA 		b	.L258
 3964              	.L259:
1541:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3965              		.loc 1 1541 0
 3966 2244 F0441FE5 		ldr	r4, .L311+76
1543:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3967              		.loc 1 1543 0
 3968 2248 F4741FE5 		ldr	r7, .L311+76
 3969              	.LVL366:
1541:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3970              		.loc 1 1541 0
 3971 224c 582094E5 		ldr	r2, [r4, #88]
 3972 2250 3010A0E3 		mov	r1, #48
 3973 2254 000052E3 		cmp	r2, #0
 3974 2258 E420A003 		moveq	r2, #228
 3975 225c 6420A013 		movne	r2, #100
 3976 2260 5230A0E3 		mov	r3, #82
 3977 2264 0100A0E3 		mov	r0, #1
 3978 2268 FEFFFFEB 		bl	SensorSetIrisControl
1542:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3979              		.loc 1 1542 0
 3980 226c 7D0FA0E3 		mov	r0, #500
 3981 2270 FEFFFFEB 		bl	_tx_thread_sleep
1543:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3982              		.loc 1 1543 0
 3983 2274 582097E5 		ldr	r2, [r7, #88]
 3984 2278 38151FE5 		ldr	r1, .L311+56
 3985 227c 000052E3 		cmp	r2, #0
 3986 2280 583097E5 		ldr	r3, [r7, #88]
 3987 2284 E420A003 		moveq	r2, #228
 3988 2288 6420A013 		movne	r2, #100
 3989 228c 0400A0E3 		mov	r0, #4
 3990 2290 FEFFFFEB 		bl	CyU3PDebugPrint
1544:../uvc.c      **** 			                         		break;
 3991              		.loc 1 1544 0
 3992 2294 48FEFFEA 		b	.L258
 3993              	.LVL367:
 3994              	.L308:
1580:../uvc.c      **** 								 if(Data0 < 3){
 3995              		.loc 1 1580 0
 3996 2298 020051E3 		cmp	r1, #2
1581:../uvc.c      **** 					 				 Data0 += 4;
 3997              		.loc 1 1581 0
 3998 229c 04608192 		addls	r6, r1, #4
 3999 22a0 FF600692 		andls	r6, r6, #255
1580:../uvc.c      **** 								 if(Data0 < 3){
 4000              		.loc 1 1580 0
 4001 22a4 8CFEFF9A 		bls	.L272
1583:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4002              		.loc 1 1583 0
 4003 22a8 0400A0E3 		mov	r0, #4
 4004 22ac 60151FE5 		ldr	r1, .L311+68
 4005 22b0 18309DE5 		ldr	r3, [sp, #24]
 4006 22b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4007              	.LVL368:
1584:../uvc.c      **** 									Data0 = 4; //set to default.
 4008              		.loc 1 1584 0
 4009 22b8 0460A0E3 		mov	r6, #4
 4010 22bc 86FEFFEA 		b	.L272
 4011              	.LVL369:
 4012              	.L190:
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4013              		.loc 1 990 0
 4014 22c0 0A00A0E1 		mov	r0, sl
 4015              	.LVL370:
 4016 22c4 0910A0E1 		mov	r1, r9
 4017 22c8 FEFFFFEB 		bl	SensorGetControl
 991:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4018              		.loc 1 991 0
 4019 22cc 0910A0E1 		mov	r1, r9
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4020              		.loc 1 990 0
 4021 22d0 0070A0E1 		mov	r7, r0
 4022              	.LVL371:
 991:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4023              		.loc 1 991 0
 4024 22d4 0B00A0E1 		mov	r0, fp
 4025              	.LVL372:
 4026 22d8 FEFFFFEB 		bl	SensorGetControl
 996:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4027              		.loc 1 996 0
 4028 22dc 0110A0E3 		mov	r1, #1
 992:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4029              		.loc 1 992 0
 4030 22e0 5C70C4E5 		strb	r7, [r4, #92]
 993:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4031              		.loc 1 993 0
 4032 22e4 F474C6E5 		strb	r7, [r6, #1268]
 996:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4033              		.loc 1 996 0
 4034 22e8 8710C4E5 		strb	r1, [r4, #135]
 991:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4035              		.loc 1 991 0
 4036 22ec 00A0A0E1 		mov	sl, r0
 4037              	.LVL373:
 994:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4038              		.loc 1 994 0
 4039 22f0 5E00C4E5 		strb	r0, [r4, #94]
 995:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4040              		.loc 1 995 0
 4041 22f4 F604C6E5 		strb	r0, [r6, #1270]
 4042 22f8 3DFCFFEA 		b	.L191
 4043              	.LVL374:
 4044              	.L163:
 784:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4045              		.loc 1 784 0
 4046 22fc 0910A0E1 		mov	r1, r9
 4047 2300 0B00A0E1 		mov	r0, fp
 4048 2304 FEFFFFEB 		bl	SensorGetControl
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4049              		.loc 1 786 0
 4050 2308 0910A0E1 		mov	r1, r9
 787:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4051              		.loc 1 787 0
 4052 230c 0170A0E3 		mov	r7, #1
 4053              	.LVL375:
 784:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4054              		.loc 1 784 0
 4055 2310 0030A0E1 		mov	r3, r0
 4056 2314 5C30C4E5 		strb	r3, [r4, #92]
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4057              		.loc 1 786 0
 4058 2318 0A00A0E1 		mov	r0, sl
 785:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4059              		.loc 1 785 0
 4060 231c 9D34C6E5 		strb	r3, [r6, #1181]
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4061              		.loc 1 786 0
 4062 2320 FEFFFFEB 		bl	SensorGetControl
 787:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4063              		.loc 1 787 0
 4064 2324 A070C4E5 		strb	r7, [r4, #160]
 4065 2328 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 4066              	.LVL376:
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4067              		.loc 1 786 0
 4068 232c 00A0A0E1 		mov	sl, r0
 4069              	.LVL377:
 4070 2330 5D00C4E5 		strb	r0, [r4, #93]
 791:../uvc.c      **** 						 break;
 4071              		.loc 1 791 0
 4072 2334 F5FBFFEA 		b	.L165
 4073              	.LVL378:
 4074              	.L168:
 817:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4075              		.loc 1 817 0
 4076 2338 0A00A0E1 		mov	r0, sl
 4077              	.LVL379:
 4078 233c 0910A0E1 		mov	r1, r9
 4079 2340 FEFFFFEB 		bl	SensorGetControl
 4080              	.LVL380:
 823:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4081              		.loc 1 823 0
 4082 2344 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 824:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4083              		.loc 1 824 0
 4084 2348 01C0A0E3 		mov	ip, #1
 823:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4085              		.loc 1 823 0
 4086 234c 5DA0C4E5 		strb	sl, [r4, #93]
 824:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4087              		.loc 1 824 0
 4088 2350 A2C0C4E5 		strb	ip, [r4, #162]
 818:../uvc.c      **** 			 	 			if(Data0&0x80)
 4089              		.loc 1 818 0
 4090 2354 800010E3 		tst	r0, #128
 819:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4091              		.loc 1 819 0
 4092 2358 0170A013 		movne	r7, #1
 4093              	.LVL381:
 821:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4094              		.loc 1 821 0
 4095 235c 0B70A001 		moveq	r7, fp
 4096              	.LVL382:
 819:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4097              		.loc 1 819 0
 4098 2360 5C70C415 		strneb	r7, [r4, #92]
 821:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4099              		.loc 1 821 0
 4100 2364 5CB0C405 		streqb	fp, [r4, #92]
 822:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 4101              		.loc 1 822 0
 4102 2368 9D70C6E5 		strb	r7, [r6, #157]
 828:../uvc.c      **** 			 	 		 break;
 4103              		.loc 1 828 0
 4104 236c E7FBFFEA 		b	.L165
 4105              	.LVL383:
 4106              	.L194:
1025:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4107              		.loc 1 1025 0
 4108 2370 0B00A0E1 		mov	r0, fp
 4109              	.LVL384:
 4110 2374 0910A0E1 		mov	r1, r9
 4111 2378 FEFFFFEB 		bl	SensorGetControl
1028:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4112              		.loc 1 1028 0
 4113 237c 01C0A0E3 		mov	ip, #1
 4114 2380 83C0C4E5 		strb	ip, [r4, #131]
1026:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4115              		.loc 1 1026 0
 4116 2384 1905C6E5 		strb	r0, [r6, #1305]
1027:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4117              		.loc 1 1027 0
 4118 2388 1AA5D6E5 		ldrb	sl, [r6, #1306]	@ zero_extendqisi2
1025:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4119              		.loc 1 1025 0
 4120 238c 0070A0E1 		mov	r7, r0
 4121              	.LVL385:
1027:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4122              		.loc 1 1027 0
 4123 2390 FFA00AE2 		and	sl, sl, #255
 4124              	.LVL386:
1025:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4125              		.loc 1 1025 0
 4126 2394 5C00C4E5 		strb	r0, [r4, #92]
1027:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4127              		.loc 1 1027 0
 4128 2398 5DA0C4E5 		strb	sl, [r4, #93]
1032:../uvc.c      **** 					 break;
 4129              		.loc 1 1032 0
 4130 239c DBFBFFEA 		b	.L165
 4131              	.LVL387:
 4132              	.L182:
 917:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4133              		.loc 1 917 0
 4134 23a0 0710A0E1 		mov	r1, r7
 4135 23a4 FEFFFFEB 		bl	SensorGetControl
 4136              	.LVL388:
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4137              		.loc 1 921 0
 4138 23a8 0710A0E1 		mov	r1, r7
 918:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4139              		.loc 1 918 0
 4140 23ac 032000E2 		and	r2, r0, #3
 4141 23b0 5C20C4E5 		strb	r2, [r4, #92]
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4142              		.loc 1 921 0
 4143 23b4 0A00A0E1 		mov	r0, sl
 919:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4144              		.loc 1 919 0
 4145 23b8 ED24C6E5 		strb	r2, [r6, #1261]
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4146              		.loc 1 921 0
 4147 23bc FEFFFFEB 		bl	SensorGetControl
 923:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4148              		.loc 1 923 0
 4149 23c0 0130A0E3 		mov	r3, #1
 4150 23c4 9530C4E5 		strb	r3, [r4, #149]
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4151              		.loc 1 921 0
 4152 23c8 5E00C4E5 		strb	r0, [r4, #94]
 922:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4153              		.loc 1 922 0
 4154 23cc EE04C6E5 		strb	r0, [r6, #1262]
 4155 23d0 26FCFFEA 		b	.L183
 4156              	.LVL389:
 4157              	.L174:
 867:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4158              		.loc 1 867 0
 4159 23d4 FEFFFFEB 		bl	SensorGetControl
 4160              	.LVL390:
 870:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4161              		.loc 1 870 0
 4162 23d8 01C0A0E3 		mov	ip, #1
 4163 23dc 97C0C4E5 		strb	ip, [r4, #151]
 868:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4164              		.loc 1 868 0
 4165 23e0 D904C6E5 		strb	r0, [r6, #1241]
 869:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4166              		.loc 1 869 0
 4167 23e4 DA14D6E5 		ldrb	r1, [r6, #1242]	@ zero_extendqisi2
 867:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4168              		.loc 1 867 0
 4169 23e8 0070A0E1 		mov	r7, r0
 4170              	.LVL391:
 869:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4171              		.loc 1 869 0
 4172 23ec FFA001E2 		and	sl, r1, #255
 4173              	.LVL392:
 867:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4174              		.loc 1 867 0
 4175 23f0 5C00C4E5 		strb	r0, [r4, #92]
 869:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4176              		.loc 1 869 0
 4177 23f4 5DA0C4E5 		strb	sl, [r4, #93]
 874:../uvc.c      **** 			 		 break;
 4178              		.loc 1 874 0
 4179 23f8 C4FBFFEA 		b	.L165
 4180              	.LVL393:
 4181              	.L166:
 799:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4182              		.loc 1 799 0
 4183 23fc 0A00A0E1 		mov	r0, sl
 4184              	.LVL394:
 4185 2400 0910A0E1 		mov	r1, r9
 4186 2404 FEFFFFEB 		bl	SensorGetControl
 801:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4187              		.loc 1 801 0
 4188 2408 B104C6E5 		strb	r0, [r6, #1201]
 802:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4189              		.loc 1 802 0
 4190 240c B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 799:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4191              		.loc 1 799 0
 4192 2410 0070A0E1 		mov	r7, r0
 4193              	.LVL395:
 802:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4194              		.loc 1 802 0
 4195 2414 FFA001E2 		and	sl, r1, #255
 800:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4196              		.loc 1 800 0
 4197 2418 5C00C4E5 		strb	r0, [r4, #92]
 803:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4198              		.loc 1 803 0
 4199 241c 0100A0E3 		mov	r0, #1
 4200              	.LVL396:
 802:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4201              		.loc 1 802 0
 4202 2420 5DA0C4E5 		strb	sl, [r4, #93]
 803:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4203              		.loc 1 803 0
 4204 2424 A100C4E5 		strb	r0, [r4, #161]
 4205              	.LVL397:
 807:../uvc.c      **** 			 	 		 break;
 4206              		.loc 1 807 0
 4207 2428 B8FBFFEA 		b	.L165
 4208              	.LVL398:
 4209              	.L196:
1042:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4210              		.loc 1 1042 0
 4211 242c 0A00A0E1 		mov	r0, sl
 4212              	.LVL399:
 4213 2430 0910A0E1 		mov	r1, r9
 4214 2434 FEFFFFEB 		bl	SensorGetControl
1044:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4215              		.loc 1 1044 0
 4216 2438 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
 4217 243c 5DA0CBE5 		strb	sl, [fp, #93]
1042:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4218              		.loc 1 1042 0
 4219 2440 0070A0E1 		mov	r7, r0
 4220 2444 5C00CBE5 		strb	r0, [fp, #92]
1043:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4221              		.loc 1 1043 0
 4222 2448 BD01C6E5 		strb	r0, [r6, #445]
1045:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4223              		.loc 1 1045 0
 4224 244c 0100A0E3 		mov	r0, #1
 4225 2450 7C00C4E5 		strb	r0, [r4, #124]
 4226              	.LVL400:
1049:../uvc.c      **** 					 break;
 4227              		.loc 1 1049 0
 4228 2454 ADFBFFEA 		b	.L165
 4229              	.LVL401:
 4230              	.L204:
1097:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4231              		.loc 1 1097 0
 4232 2458 0A00A0E1 		mov	r0, sl
 4233              	.LVL402:
 4234 245c 0910A0E1 		mov	r1, r9
 4235 2460 14308DE5 		str	r3, [sp, #20]
 4236 2464 FEFFFFEB 		bl	SensorGetControl
1098:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4237              		.loc 1 1098 0
 4238 2468 84A084E0 		add	sl, r4, r4, asl #1
 4239 246c 8A6186E0 		add	r6, r6, sl, asl #3
1099:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4240              		.loc 1 1099 0
 4241 2470 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4242              		.loc 1 1100 0
 4243 2474 0110A0E3 		mov	r1, #1
1099:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4244              		.loc 1 1099 0
 4245 2478 5DA0CBE5 		strb	sl, [fp, #93]
1097:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4246              		.loc 1 1097 0
 4247 247c 5C00CBE5 		strb	r0, [fp, #92]
1098:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4248              		.loc 1 1098 0
 4249 2480 8D01C6E5 		strb	r0, [r6, #397]
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4250              		.loc 1 1100 0
 4251 2484 14C09DE5 		ldr	ip, [sp, #20]
1097:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4252              		.loc 1 1097 0
 4253 2488 0070A0E1 		mov	r7, r0
 4254              	.LVL403:
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4255              		.loc 1 1100 0
 4256 248c 7C10CCE5 		strb	r1, [ip, #124]
 4257              	.LVL404:
1106:../uvc.c      **** 					 break;
 4258              		.loc 1 1106 0
 4259 2490 9EFBFFEA 		b	.L165
 4260              	.LVL405:
 4261              	.L198:
1056:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4262              		.loc 1 1056 0
 4263 2494 0A00A0E1 		mov	r0, sl
 4264              	.LVL406:
 4265 2498 0910A0E1 		mov	r1, r9
 4266 249c FEFFFFEB 		bl	SensorGetControl
1059:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4267              		.loc 1 1059 0
 4268 24a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1061:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4269              		.loc 1 1061 0
 4270 24a4 0110A0E3 		mov	r1, #1
1059:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4271              		.loc 1 1059 0
 4272 24a8 5DA0C4E5 		strb	sl, [r4, #93]
1061:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4273              		.loc 1 1061 0
 4274 24ac 8510C4E5 		strb	r1, [r4, #133]
1058:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4275              		.loc 1 1058 0
 4276 24b0 037000E2 		and	r7, r0, #3
 4277              	.LVL407:
1057:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4278              		.loc 1 1057 0
 4279 24b4 6502C6E5 		strb	r0, [r6, #613]
1058:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4280              		.loc 1 1058 0
 4281 24b8 5C70C4E5 		strb	r7, [r4, #92]
1065:../uvc.c      **** 					 break;
 4282              		.loc 1 1065 0
 4283 24bc 93FBFFEA 		b	.L165
 4284              	.LVL408:
 4285              	.L200:
1078:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
 4286              		.loc 1 1078 0
 4287 24c0 0100A0E3 		mov	r0, #1
 4288              	.LVL409:
 4289 24c4 0910A0E1 		mov	r1, r9
 4290 24c8 FEFFFFEB 		bl	SensorGetControl
 4291              	.LVL410:
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4292              		.loc 1 1083 0
 4293 24cc 0130A0E3 		mov	r3, #1
1082:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4294              		.loc 1 1082 0
 4295 24d0 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4296              		.loc 1 1083 0
 4297 24d4 8030C4E5 		strb	r3, [r4, #128]
1082:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4298              		.loc 1 1082 0
 4299 24d8 5DA0C4E5 		strb	sl, [r4, #93]
1079:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4300              		.loc 1 1079 0
 4301 24dc A003A0E1 		mov	r0, r0, lsr #7
 4302              	.LVL411:
1080:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4303              		.loc 1 1080 0
 4304 24e0 037080E0 		add	r7, r0, r3
 4305              	.LVL412:
 4306 24e4 FF7007E2 		and	r7, r7, #255
 4307              	.LVL413:
 4308 24e8 5C70C4E5 		strb	r7, [r4, #92]
1081:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4309              		.loc 1 1081 0
 4310 24ec ED71C6E5 		strb	r7, [r6, #493]
1088:../uvc.c      **** 					 break;
 4311              		.loc 1 1088 0
 4312 24f0 86FBFFEA 		b	.L165
 4313              	.LVL414:
 4314              	.L192:
1008:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4315              		.loc 1 1008 0
 4316 24f4 0A00A0E1 		mov	r0, sl
 4317              	.LVL415:
 4318 24f8 0910A0E1 		mov	r1, r9
 4319 24fc FEFFFFEB 		bl	SensorGetControl
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4320              		.loc 1 1012 0
 4321 2500 0130A0E3 		mov	r3, #1
 4322 2504 7C30C4E5 		strb	r3, [r4, #124]
1009:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4323              		.loc 1 1009 0
 4324 2508 037000E0 		and	r7, r0, r3
 4325              	.LVL416:
1010:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4326              		.loc 1 1010 0
 4327 250c 0575C6E5 		strb	r7, [r6, #1285]
1011:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4328              		.loc 1 1011 0
 4329 2510 0605D6E5 		ldrb	r0, [r6, #1286]	@ zero_extendqisi2
1009:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4330              		.loc 1 1009 0
 4331 2514 5C70C4E5 		strb	r7, [r4, #92]
1011:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4332              		.loc 1 1011 0
 4333 2518 FFA000E2 		and	sl, r0, #255
 4334              	.LVL417:
 4335 251c 5DA0C4E5 		strb	sl, [r4, #93]
1016:../uvc.c      **** 					 break;
 4336              		.loc 1 1016 0
 4337 2520 7AFBFFEA 		b	.L165
 4338              	.LVL418:
 4339              	.L305:
 954:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4340              		.loc 1 954 0
 4341 2524 0A00A0E1 		mov	r0, sl
 4342 2528 0910A0E1 		mov	r1, r9
 4343 252c FEFFFFEB 		bl	SensorGetControl
 4344              	.LVL419:
 956:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4345              		.loc 1 956 0
 4346 2530 0170A0E3 		mov	r7, #1
 4347              	.LVL420:
 4348 2534 7D70C4E5 		strb	r7, [r4, #125]
 955:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4349              		.loc 1 955 0
 4350 2538 A501C6E5 		strb	r0, [r6, #421]
 4351 253c DCFBFFEA 		b	.L185
 4352              	.LVL421:
 4353              	.L172:
 842:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4354              		.loc 1 842 0
 4355 2540 FEFFFFEB 		bl	SensorGetControl
 4356              	.LVL422:
 848:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4357              		.loc 1 848 0
 4358 2544 00181FE5 		ldr	r1, .L311+60
 843:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4359              		.loc 1 843 0
 4360 2548 C504C6E5 		strb	r0, [r6, #1221]
 846:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4361              		.loc 1 846 0
 4362 254c C664D6E5 		ldrb	r6, [r6, #1222]	@ zero_extendqisi2
 842:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4363              		.loc 1 842 0
 4364 2550 0070A0E1 		mov	r7, r0
 4365              	.LVL423:
 844:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4366              		.loc 1 844 0
 4367 2554 700000E2 		and	r0, r0, #112
 4368              	.LVL424:
 4369 2558 20C2A0E1 		mov	ip, r0, lsr #4
 4370              	.LVL425:
 845:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4371              		.loc 1 845 0
 4372 255c 5CC0C4E5 		strb	ip, [r4, #92]
 846:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4373              		.loc 1 846 0
 4374 2560 5D60C4E5 		strb	r6, [r4, #93]
 848:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4375              		.loc 1 848 0
 4376 2564 0C20A0E1 		mov	r2, ip
 4377 2568 0C30A0E1 		mov	r3, ip
 4378 256c 0400A0E3 		mov	r0, #4
 4379 2570 00708DE5 		str	r7, [sp, #0]
 4380 2574 14C08DE5 		str	ip, [sp, #20]
 4381 2578 FEFFFFEB 		bl	CyU3PDebugPrint
 4382              	.LVL426:
 4383 257c 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 4384              	.LVL427:
 4385 2580 14C09DE5 		ldr	ip, [sp, #20]
 4386 2584 19FCFFEA 		b	.L173
 4387              	.LVL428:
 4388              	.L246:
1320:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4389              		.loc 1 1320 0
 4390 2588 0A20A0E1 		mov	r2, sl
 4391 258c 0730A0E1 		mov	r3, r7
 4392 2590 80E0A0E3 		mov	lr, #128
 4393 2594 00C0A0E3 		mov	ip, #0
 4394 2598 1B10A0E3 		mov	r1, #27
 4395 259c 54081FE5 		ldr	r0, .L311+64
 4396 25a0 00E08DE5 		str	lr, [sp, #0]
 4397 25a4 04C08DE5 		str	ip, [sp, #4]
 4398 25a8 FEFFFFEB 		bl	cmdSet
 4399              	.LVL429:
1322:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4400              		.loc 1 1322 0
 4401 25ac 0820A0E1 		mov	r2, r8
 4402 25b0 18809DE5 		ldr	r8, [sp, #24]
 4403              	.LVL430:
 4404 25b4 01A0A0E3 		mov	sl, #1
 4405              	.LVL431:
 4406 25b8 1B10A0E3 		mov	r1, #27
 4407 25bc 0730A0E1 		mov	r3, r7
 4408 25c0 78081FE5 		ldr	r0, .L311+64
 4409 25c4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4410 25c8 FEFFFFEB 		bl	cmdSet
 4411              	.LVL432:
 4412 25cc 87FCFFEA 		b	.L245
 4413              	.LVL433:
 4414              	.L304:
 879:../uvc.c      **** 						if(sendData >= 3){
 4415              		.loc 1 879 0
 4416 25d0 020057E3 		cmp	r7, #2
 4417 25d4 0D00008A 		bhi	.L310
 4418              	.LVL434:
 4419              	.L177:
 884:../uvc.c      **** 						sendData += 4;
 4420              		.loc 1 884 0
 4421 25d8 047087E2 		add	r7, r7, #4
 4422              	.LVL435:
 4423 25dc FF7007E2 		and	r7, r7, #255
 4424              	.LVL436:
 4425 25e0 69FBFFEA 		b	.L296
 4426              	.LVL437:
 4427              	.L309:
1295:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4428              		.loc 1 1295 0
 4429 25e4 0830A0E1 		mov	r3, r8
 4430 25e8 1910A0E3 		mov	r1, #25
 4431 25ec 0080A0E3 		mov	r8, #0
 4432              	.LVL438:
 4433 25f0 0920A0E1 		mov	r2, r9
 4434 25f4 AC081FE5 		ldr	r0, .L311+64
 4435 25f8 00E08DE5 		str	lr, [sp, #0]
 4436 25fc 04808DE5 		str	r8, [sp, #4]
 4437 2600 FEFFFFEB 		bl	cmdSet
 4438              	.LVL439:
 4439 2604 14FEFFEA 		b	.L244
 4440              	.LVL440:
 4441              	.L295:
 4442 2608 B4081FE5 		ldr	r0, .L311+76
 4443 260c 29FBFFEA 		b	.L162
 4444              	.LVL441:
 4445              	.L310:
 880:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4446              		.loc 1 880 0
 4447 2610 0730A0E1 		mov	r3, r7
 4448 2614 0400A0E3 		mov	r0, #4
 4449              	.LVL442:
 4450 2618 CC181FE5 		ldr	r1, .L311+68
 4451 261c FEFFFFEB 		bl	CyU3PDebugPrint
 4452              	.LVL443:
 882:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4453              		.loc 1 882 0
 4454 2620 D0081FE5 		ldr	r0, .L311+72
 4455 2624 0020A0E3 		mov	r2, #0
 881:../uvc.c      **** 							sendData = 0; //set back to default
 4456              		.loc 1 881 0
 4457 2628 0270A0E1 		mov	r7, r2
 882:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4458              		.loc 1 882 0
 4459 262c 2D24C0E5 		strb	r2, [r0, #1069]
 4460 2630 E8FFFFEA 		b	.L177
 4461              	.LVL444:
 4462              	.L275:
 4463 2634 E0081FE5 		ldr	r0, .L311+76
 4464              	.LVL445:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4465              		.loc 1 735 0
 4466 2638 0030A0E3 		mov	r3, #0
 4467 263c 16FBFFEA 		b	.L288
 4468              	.LVL446:
 4469              	.L277:
 4470 2640 0030A0E3 		mov	r3, #0
 4471 2644 0CFCFFEA 		b	.L289
 4472              		.cfi_endproc
 4473              	.LFE3:
 4475              		.align	2
 4476              		.global	CTControlHandle
 4478              	CTControlHandle:
 4479              	.LFB4:
1659:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4480              		.loc 1 1659 0
 4481              		.cfi_startproc
 4482              		@ args = 0, pretend = 0, frame = 64
 4483              		@ frame_needed = 0, uses_anonymous_args = 0
 4484              	.LVL447:
 4485 2648 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4486              	.LCFI18:
 4487              		.cfi_def_cfa_offset 36
1678:../uvc.c      ****     reqData = bRequest;
 4488              		.loc 1 1678 0
 4489 264c 64A99FE5 		ldr	sl, .L398
 4490              		.cfi_offset 14, -4
 4491              		.cfi_offset 11, -8
 4492              		.cfi_offset 10, -12
 4493              		.cfi_offset 9, -16
 4494              		.cfi_offset 8, -20
 4495              		.cfi_offset 7, -24
 4496              		.cfi_offset 6, -28
 4497              		.cfi_offset 5, -32
 4498              		.cfi_offset 4, -36
1670:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4499              		.loc 1 1670 0
 4500 2650 64899FE5 		ldr	r8, .L398+4
1678:../uvc.c      ****     reqData = bRequest;
 4501              		.loc 1 1678 0
 4502 2654 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1670:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4503              		.loc 1 1670 0
 4504 2658 8090A0E1 		mov	r9, r0, asl #1
 4505 265c 002089E0 		add	r2, r9, r0
 4506 2660 822188E0 		add	r2, r8, r2, asl #3
1680:../uvc.c      ****     switch (bRequest)
 4507              		.loc 1 1680 0
 4508 2664 830055E3 		cmp	r5, #131
1659:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4509              		.loc 1 1659 0
 4510 2668 5CD04DE2 		sub	sp, sp, #92
 4511              	.LCFI19:
 4512              		.cfi_def_cfa_offset 128
1659:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4513              		.loc 1 1659 0
 4514 266c 0060A0E1 		mov	r6, r0
1670:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4515              		.loc 1 1670 0
 4516 2670 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4517              	.LVL448:
1671:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4518              		.loc 1 1671 0
 4519 2674 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4520              	.LVL449:
1673:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4521              		.loc 1 1673 0
 4522 2678 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4523              	.LVL450:
1680:../uvc.c      ****     switch (bRequest)
 4524              		.loc 1 1680 0
 4525 267c 7600000A 		beq	.L318
 4526 2680 2100009A 		bls	.L393
 4527 2684 850055E3 		cmp	r5, #133
 4528 2688 5900000A 		beq	.L320
 4529 268c 4E00003A 		bcc	.L319
 4530 2690 860055E3 		cmp	r5, #134
 4531 2694 8000000A 		beq	.L321
 4532 2698 870055E3 		cmp	r5, #135
 4533 269c 7600000A 		beq	.L394
 4534              	.L314:
1887:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4535              		.loc 1 1887 0
 4536 26a0 0000A0E3 		mov	r0, #0
 4537              	.LVL451:
 4538 26a4 0110A0E3 		mov	r1, #1
 4539 26a8 0020A0E1 		mov	r2, r0
 4540 26ac FEFFFFEB 		bl	CyU3PUsbStall
 4541              	.LVL452:
 4542 26b0 08499FE5 		ldr	r4, .L398+8
1888:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4543              		.loc 1 1888 0
 4544 26b4 0620A0E1 		mov	r2, r6
 4545 26b8 0400A0E3 		mov	r0, #4
 4546 26bc 00199FE5 		ldr	r1, .L398+12
 4547 26c0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4548 26c4 FEFFFFEB 		bl	CyU3PDebugPrint
1889:../uvc.c      **** 			  break;
 4549              		.loc 1 1889 0
 4550 26c8 FFC0A0E3 		mov	ip, #255
 4551 26cc 0C60A0E1 		mov	r6, ip
 4552 26d0 0C80A0E1 		mov	r8, ip
 4553              	.LVL453:
 4554              	.L324:
1893:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4555              		.loc 1 1893 0
 4556 26d4 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 4557 26d8 08C08DE5 		str	ip, [sp, #8]
 4558 26dc E4189FE5 		ldr	r1, .L398+16
 4559 26e0 FFC0A0E3 		mov	ip, #255
 4560 26e4 0520A0E1 		mov	r2, r5
 4561 26e8 0830A0E1 		mov	r3, r8
 4562 26ec 0400A0E3 		mov	r0, #4
 4563 26f0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4564 26f4 0CC08DE5 		str	ip, [sp, #12]
 4565 26f8 10E08DE5 		str	lr, [sp, #16]
 4566 26fc 14708DE5 		str	r7, [sp, #20]
 4567 2700 FEFFFFEB 		bl	CyU3PDebugPrint
1894:../uvc.c      **** }
 4568              		.loc 1 1894 0
 4569 2704 5CD08DE2 		add	sp, sp, #92
 4570 2708 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4571              	.LVL454:
 4572              	.L393:
1680:../uvc.c      ****     switch (bRequest)
 4573              		.loc 1 1680 0
 4574 270c 810055E3 		cmp	r5, #129
 4575 2710 4200000A 		beq	.L316
 4576 2714 1100009A 		bls	.L395
1709:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4577              		.loc 1 1709 0
 4578 2718 A0489FE5 		ldr	r4, .L398+8
 4579 271c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1710:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4580              		.loc 1 1710 0
 4581 2720 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1711:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4582              		.loc 1 1711 0
 4583 2724 0A0050E3 		cmp	r0, #10
1709:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4584              		.loc 1 1709 0
 4585 2728 5C10C4E5 		strb	r1, [r4, #92]
1710:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4586              		.loc 1 1710 0
 4587 272c 5D60C4E5 		strb	r6, [r4, #93]
1711:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4588              		.loc 1 1711 0
 4589 2730 2C00000A 		beq	.L392
 4590              	.LVL455:
 4591              	.L331:
1745:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4592              		.loc 1 1745 0
 4593 2734 00E0A0E3 		mov	lr, #0
 4594 2738 5EE0C4E5 		strb	lr, [r4, #94]
 4595              	.L332:
1746:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4596              		.loc 1 1746 0
 4597 273c 0030A0E3 		mov	r3, #0
1747:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4598              		.loc 1 1747 0
 4599 2740 0700A0E1 		mov	r0, r7
 4600              	.LVL456:
 4601 2744 80189FE5 		ldr	r1, .L398+20
1749:../uvc.c      **** 			  break;
 4602              		.loc 1 1749 0
 4603 2748 FF60A0E3 		mov	r6, #255
1746:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4604              		.loc 1 1746 0
 4605 274c 5F30C4E5 		strb	r3, [r4, #95]
1749:../uvc.c      **** 			  break;
 4606              		.loc 1 1749 0
 4607 2750 0680A0E1 		mov	r8, r6
1747:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4608              		.loc 1 1747 0
 4609 2754 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4610              	.LVL457:
 4611 2758 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1749:../uvc.c      **** 			  break;
 4612              		.loc 1 1749 0
 4613 275c DCFFFFEA 		b	.L324
 4614              	.LVL458:
 4615              	.L395:
1680:../uvc.c      ****     switch (bRequest)
 4616              		.loc 1 1680 0
 4617 2760 010055E3 		cmp	r5, #1
 4618 2764 CDFFFF1A 		bne	.L314
1751:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4619              		.loc 1 1751 0
 4620 2768 50489FE5 		ldr	r4, .L398+8
 4621 276c 56208DE2 		add	r2, sp, #86
 4622 2770 2000A0E3 		mov	r0, #32
 4623              	.LVL459:
 4624 2774 5C1084E2 		add	r1, r4, #92
 4625 2778 2C308DE5 		str	r3, [sp, #44]
 4626 277c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4627              	.LVL460:
1753:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4628              		.loc 1 1753 0
 4629 2780 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1754:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4630              		.loc 1 1754 0
 4631 2784 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1757:../uvc.c      **** 			  switch(CtrlID)
 4632              		.loc 1 1757 0
 4633 2788 012046E2 		sub	r2, r6, #1
1753:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4634              		.loc 1 1753 0
 4635 278c 30008DE5 		str	r0, [sp, #48]
 4636              	.LVL461:
1754:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4637              		.loc 1 1754 0
 4638 2790 34C08DE5 		str	ip, [sp, #52]
 4639              	.LVL462:
1757:../uvc.c      **** 			  switch(CtrlID)
 4640              		.loc 1 1757 0
 4641 2794 2C309DE5 		ldr	r3, [sp, #44]
 4642 2798 090052E3 		cmp	r2, #9
 4643 279c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4644 27a0 550100EA 		b	.L333
 4645              	.L338:
 4646 27a4 B82C0000 		.word	.L334
 4647 27a8 FC2C0000 		.word	.L333
 4648 27ac C8290000 		.word	.L335
 4649 27b0 FC2C0000 		.word	.L333
 4650 27b4 FC2C0000 		.word	.L333
 4651 27b8 FC2C0000 		.word	.L333
 4652 27bc 44290000 		.word	.L336
 4653 27c0 FC2C0000 		.word	.L333
 4654 27c4 FC2C0000 		.word	.L333
 4655 27c8 C8280000 		.word	.L337
 4656              	.LVL463:
 4657              	.L319:
1727:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4658              		.loc 1 1727 0
 4659 27cc EC479FE5 		ldr	r4, .L398+8
 4660 27d0 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1728:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4661              		.loc 1 1728 0
 4662 27d4 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1729:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4663              		.loc 1 1729 0
 4664 27d8 0A0050E3 		cmp	r0, #10
1727:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4665              		.loc 1 1727 0
 4666 27dc 5C80C4E5 		strb	r8, [r4, #92]
1728:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4667              		.loc 1 1728 0
 4668 27e0 5D20C4E5 		strb	r2, [r4, #93]
1729:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4669              		.loc 1 1729 0
 4670 27e4 D2FFFF1A 		bne	.L331
 4671              	.LVL464:
 4672              	.L392:
1744:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4673              		.loc 1 1744 0 discriminator 1
 4674 27e8 0110A0E3 		mov	r1, #1
 4675 27ec 5E10C4E5 		strb	r1, [r4, #94]
 4676 27f0 D1FFFFEA 		b	.L332
 4677              	.LVL465:
 4678              	.L320:
1684:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4679              		.loc 1 1684 0
 4680 27f4 C4479FE5 		ldr	r4, .L398+8
1685:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4681              		.loc 1 1685 0
 4682 27f8 0030A0E3 		mov	r3, #0
 4683              	.LVL466:
1686:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4684              		.loc 1 1686 0
 4685 27fc 0200A0E3 		mov	r0, #2
 4686              	.LVL467:
 4687 2800 5C1084E2 		add	r1, r4, #92
1688:../uvc.c      **** 			  break;
 4688              		.loc 1 1688 0
 4689 2804 FF60A0E3 		mov	r6, #255
1684:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4690              		.loc 1 1684 0
 4691 2808 5C70C4E5 		strb	r7, [r4, #92]
1685:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4692              		.loc 1 1685 0
 4693 280c 5D30C4E5 		strb	r3, [r4, #93]
1688:../uvc.c      **** 			  break;
 4694              		.loc 1 1688 0
 4695 2810 0680A0E1 		mov	r8, r6
1686:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4696              		.loc 1 1686 0
 4697 2814 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4698              	.LVL468:
 4699 2818 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1688:../uvc.c      **** 			  break;
 4700              		.loc 1 1688 0
 4701 281c ACFFFFEA 		b	.L324
 4702              	.LVL469:
 4703              	.L316:
1694:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4704              		.loc 1 1694 0
 4705 2820 98479FE5 		ldr	r4, .L398+8
 4706 2824 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4707              		.loc 1 1695 0
 4708 2828 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1696:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4709              		.loc 1 1696 0
 4710 282c 0080A0E3 		mov	r8, #0
1702:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4711              		.loc 1 1702 0
 4712 2830 0700A0E1 		mov	r0, r7
 4713              	.LVL470:
 4714 2834 5C1084E2 		add	r1, r4, #92
1707:../uvc.c      **** 			  break;
 4715              		.loc 1 1707 0
 4716 2838 FF60A0E3 		mov	r6, #255
1695:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4717              		.loc 1 1695 0
 4718 283c 5DC0C4E5 		strb	ip, [r4, #93]
1696:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4719              		.loc 1 1696 0
 4720 2840 5E80C4E5 		strb	r8, [r4, #94]
1697:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4721              		.loc 1 1697 0
 4722 2844 5F80C4E5 		strb	r8, [r4, #95]
 4723              	.LVL471:
1694:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4724              		.loc 1 1694 0
 4725 2848 5CA0C4E5 		strb	sl, [r4, #92]
1707:../uvc.c      **** 			  break;
 4726              		.loc 1 1707 0
 4727 284c 0680A0E1 		mov	r8, r6
1702:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4728              		.loc 1 1702 0
 4729 2850 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4730              	.LVL472:
 4731 2854 0AC0A0E1 		mov	ip, sl
1707:../uvc.c      **** 			  break;
 4732              		.loc 1 1707 0
 4733 2858 9DFFFFEA 		b	.L324
 4734              	.LVL473:
 4735              	.L318:
1718:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4736              		.loc 1 1718 0
 4737 285c 5C479FE5 		ldr	r4, .L398+8
 4738 2860 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4739              	.LVL474:
1719:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4740              		.loc 1 1719 0
 4741 2864 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1720:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4742              		.loc 1 1720 0
 4743 2868 0A0050E3 		cmp	r0, #10
1718:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4744              		.loc 1 1718 0
 4745 286c 5C30C4E5 		strb	r3, [r4, #92]
1719:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4746              		.loc 1 1719 0
 4747 2870 5DE0C4E5 		strb	lr, [r4, #93]
1720:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4748              		.loc 1 1720 0
 4749 2874 AEFFFF1A 		bne	.L331
 4750 2878 DAFFFFEA 		b	.L392
 4751              	.LVL475:
 4752              	.L394:
1742:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4753              		.loc 1 1742 0
 4754 287c 3C479FE5 		ldr	r4, .L398+8
 4755 2880 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1743:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4756              		.loc 1 1743 0
 4757 2884 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1744:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4758              		.loc 1 1744 0
 4759 2888 0A0050E3 		cmp	r0, #10
1742:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4760              		.loc 1 1742 0
 4761 288c 5C60C4E5 		strb	r6, [r4, #92]
1743:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4762              		.loc 1 1743 0
 4763 2890 5DC0C4E5 		strb	ip, [r4, #93]
1744:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4764              		.loc 1 1744 0
 4765 2894 A6FFFF1A 		bne	.L331
 4766 2898 D2FFFFEA 		b	.L392
 4767              	.L321:
1736:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4768              		.loc 1 1736 0
 4769 289c 1C479FE5 		ldr	r4, .L398+8
 4770 28a0 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4771              	.LVL476:
 4772 28a4 0410A0E1 		mov	r1, r4
 4773 28a8 5C00E1E5 		strb	r0, [r1, #92]!
1740:../uvc.c      **** 			  break;
 4774              		.loc 1 1740 0
 4775 28ac FF60A0E3 		mov	r6, #255
1737:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4776              		.loc 1 1737 0
 4777 28b0 0100A0E3 		mov	r0, #1
 4778 28b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4779              	.LVL477:
1740:../uvc.c      **** 			  break;
 4780              		.loc 1 1740 0
 4781 28b8 0680A0E1 		mov	r8, r6
1737:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4782              		.loc 1 1737 0
 4783 28bc 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1740:../uvc.c      **** 			  break;
 4784              		.loc 1 1740 0
 4785 28c0 0170A0E3 		mov	r7, #1
 4786 28c4 82FFFFEA 		b	.L324
 4787              	.LVL478:
 4788              	.L337:
1866:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4789              		.loc 1 1866 0
 4790 28c8 00679FE5 		ldr	r6, .L398+24
 4791 28cc 0010E0E3 		mvn	r1, #0
 4792 28d0 1C0096E5 		ldr	r0, [r6, #28]
 4793 28d4 2C308DE5 		str	r3, [sp, #44]
 4794 28d8 FEFFFFEB 		bl	_txe_mutex_get
1867:../uvc.c      **** 					  if(getData == 1)
 4795              		.loc 1 1867 0
 4796 28dc 30E09DE5 		ldr	lr, [sp, #48]
 4797 28e0 2C309DE5 		ldr	r3, [sp, #44]
 4798 28e4 01005EE3 		cmp	lr, #1
 4799 28e8 AA01000A 		beq	.L396
1869:../uvc.c      **** 					  else if(getData == 0xff)
 4800              		.loc 1 1869 0
 4801 28ec FF005EE3 		cmp	lr, #255
 4802 28f0 9F01000A 		beq	.L397
1872:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4803              		.loc 1 1872 0
 4804 28f4 0080A0E3 		mov	r8, #0
 4805 28f8 0600A0E1 		mov	r0, r6
 4806 28fc 2310A0E3 		mov	r1, #35
 4807 2900 0B20A0E1 		mov	r2, fp
 4808 2904 00808DE5 		str	r8, [sp, #0]
 4809 2908 04808DE5 		str	r8, [sp, #4]
 4810 290c FEFFFFEB 		bl	cmdSet
 4811              	.L390:
1875:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4812              		.loc 1 1875 0
 4813 2910 1C0096E5 		ldr	r0, [r6, #28]
 4814 2914 FEFFFFEB 		bl	_txe_mutex_put
1877:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4815              		.loc 1 1877 0
 4816 2918 30809DE5 		ldr	r8, [sp, #48]
 4817 291c 34609DE5 		ldr	r6, [sp, #52]
 4818 2920 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4819 2924 0400A0E3 		mov	r0, #4
 4820 2928 A4169FE5 		ldr	r1, .L398+28
 4821 292c 0820A0E1 		mov	r2, r8
 4822 2930 0630A0E1 		mov	r3, r6
 4823 2934 00C08DE5 		str	ip, [sp, #0]
 4824 2938 FEFFFFEB 		bl	CyU3PDebugPrint
1878:../uvc.c      **** 					  break;
 4825              		.loc 1 1878 0
 4826 293c FFC0A0E3 		mov	ip, #255
 4827 2940 63FFFFEA 		b	.L324
 4828              	.LVL479:
 4829              	.L336:
1843:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4830              		.loc 1 1843 0
 4831 2944 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4832 2948 010058E3 		cmp	r8, #1
 4833 294c 08005813 		cmpne	r8, #8
 4834 2950 0000A013 		movne	r0, #0
 4835 2954 0100A003 		moveq	r0, #1
 4836 2958 8101001A 		bne	.L387
 4837              	.LVL480:
1846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4838              		.loc 1 1846 0
 4839 295c 6C869FE5 		ldr	r8, .L398+24
 4840 2960 0010E0E3 		mvn	r1, #0
 4841 2964 1C0098E5 		ldr	r0, [r8, #28]
 4842 2968 2C308DE5 		str	r3, [sp, #44]
 4843 296c FEFFFFEB 		bl	_txe_mutex_get
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4844              		.loc 1 1847 0
 4845 2970 30A09DE5 		ldr	sl, [sp, #48]
 4846 2974 2210A0E3 		mov	r1, #34
 4847 2978 0B20A0E1 		mov	r2, fp
 4848 297c 2C309DE5 		ldr	r3, [sp, #44]
 4849 2980 00C0A0E3 		mov	ip, #0
 4850 2984 0800A0E1 		mov	r0, r8
 4851 2988 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4852 298c FEFFFFEB 		bl	cmdSet
1848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4853              		.loc 1 1848 0
 4854 2990 1C0098E5 		ldr	r0, [r8, #28]
 4855 2994 FEFFFFEB 		bl	_txe_mutex_put
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4856              		.loc 1 1851 0
 4857 2998 1C069FE5 		ldr	r0, .L398+4
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4858              		.loc 1 1852 0
 4859 299c 34209DE5 		ldr	r2, [sp, #52]
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4860              		.loc 1 1851 0
 4861 29a0 061089E0 		add	r1, r9, r6
 4862 29a4 813180E0 		add	r3, r0, r1, asl #3
1853:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4863              		.loc 1 1853 0
 4864 29a8 0160A0E3 		mov	r6, #1
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4865              		.loc 1 1851 0
 4866 29ac 2DA5C3E5 		strb	sl, [r3, #1325]
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4867              		.loc 1 1852 0
 4868 29b0 2E25C3E5 		strb	r2, [r3, #1326]
1853:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4869              		.loc 1 1853 0
 4870 29b4 3065C3E5 		strb	r6, [r3, #1328]
 4871              	.LVL481:
 4872              	.L388:
1855:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4873              		.loc 1 1855 0
 4874 29b8 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4875 29bc 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1860:../uvc.c      **** 					  break;
 4876              		.loc 1 1860 0
 4877 29c0 FFC0A0E3 		mov	ip, #255
 4878 29c4 42FFFFEA 		b	.L324
 4879              	.LVL482:
 4880              	.L335:
1809:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4881              		.loc 1 1809 0
 4882 29c8 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 4883 29cc 010050E3 		cmp	r0, #1
 4884 29d0 04005013 		cmpne	r0, #4
 4885 29d4 5D01001A 		bne	.L345
1808:../uvc.c      **** 					  value = (value << 8)|Data0;
 4886              		.loc 1 1808 0
 4887 29d8 30109DE5 		ldr	r1, [sp, #48]
 4888 29dc 34E09DE5 		ldr	lr, [sp, #52]
 4889 29e0 0E2481E1 		orr	r2, r1, lr, asl #8
1810:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4890              		.loc 1 1810 0
 4891 29e4 F90052E3 		cmp	r2, #249
 4892 29e8 5801008A 		bhi	.L345
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4893              		.loc 1 1815 0
 4894 29ec C8A042E2 		sub	sl, r2, #200
 4895 29f0 0AC8A0E1 		mov	ip, sl, asl #16
 4896 29f4 3CC08DE5 		str	ip, [sp, #60]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4897              		.loc 1 1817 0
 4898 29f8 27A062E2 		rsb	sl, r2, #39
 4899 29fc 38A08DE5 		str	sl, [sp, #56]
 4900 2a00 3CA09DE5 		ldr	sl, [sp, #60]
 4901 2a04 C81062E2 		rsb	r1, r2, #200
 4902 2a08 C80052E3 		cmp	r2, #200
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4903              		.loc 1 1815 0
 4904 2a0c 640042E2 		sub	r0, r2, #100
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4905              		.loc 1 1817 0
 4906 2a10 0118A0E1 		mov	r1, r1, asl #16
 4907 2a14 64E062E2 		rsb	lr, r2, #100
 4908 2a18 2A18A081 		movhi	r1, sl, lsr #16
 4909 2a1c 2118A091 		movls	r1, r1, lsr #16
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4910              		.loc 1 1815 0
 4911 2a20 00C8A0E1 		mov	ip, r0, asl #16
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4912              		.loc 1 1817 0
 4913 2a24 640052E3 		cmp	r2, #100
 4914 2a28 0E08A0E1 		mov	r0, lr, asl #16
 4915 2a2c 2C08A081 		movhi	r0, ip, lsr #16
 4916 2a30 38C09DE5 		ldr	ip, [sp, #56]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4917              		.loc 1 1815 0
 4918 2a34 14A042E2 		sub	sl, r2, #20
 4919 2a38 38A08DE5 		str	sl, [sp, #56]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4920              		.loc 1 1817 0
 4921 2a3c 2008A091 		movls	r0, r0, lsr #16
 4922 2a40 14A062E2 		rsb	sl, r2, #20
 4923 2a44 3CA08DE5 		str	sl, [sp, #60]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4924              		.loc 1 1815 0
 4925 2a48 27E042E2 		sub	lr, r2, #39
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4926              		.loc 1 1817 0
 4927 2a4c 000051E1 		cmp	r1, r0
 4928 2a50 01A0A031 		movcc	sl, r1
 4929 2a54 00A0A021 		movcs	sl, r0
 4930 2a58 0CC8A0E1 		mov	ip, ip, asl #16
 4931 2a5c 270052E3 		cmp	r2, #39
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4932              		.loc 1 1815 0
 4933 2a60 0EE8A0E1 		mov	lr, lr, asl #16
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4934              		.loc 1 1817 0
 4935 2a64 2CE8A091 		movls	lr, ip, lsr #16
 4936 2a68 68C59FE5 		ldr	ip, .L398+32
 4937 2a6c 20A08DE5 		str	sl, [sp, #32]
 4938 2a70 01A06CE0 		rsb	sl, ip, r1
 4939 2a74 2EE8A081 		movhi	lr, lr, lsr #16
 4940 2a78 00C07AE2 		rsbs	ip, sl, #0
 4941 2a7c 0AC0ACE0 		adc	ip, ip, sl
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4942              		.loc 1 1815 0
 4943 2a80 38A09DE5 		ldr	sl, [sp, #56]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4944              		.loc 1 1817 0
 4945 2a84 44C08DE5 		str	ip, [sp, #68]
 4946              	.LVL483:
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4947              		.loc 1 1815 0
 4948 2a88 0AC8A0E1 		mov	ip, sl, asl #16
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4949              		.loc 1 1817 0
 4950 2a8c 3CA09DE5 		ldr	sl, [sp, #60]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4951              		.loc 1 1815 0
 4952 2a90 4CC08DE5 		str	ip, [sp, #76]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4953              		.loc 1 1817 0
 4954 2a94 0AC8A0E1 		mov	ip, sl, asl #16
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4955              		.loc 1 1815 0
 4956 2a98 0AA042E2 		sub	sl, r2, #10
 4957 2a9c 48A08DE5 		str	sl, [sp, #72]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4958              		.loc 1 1817 0
 4959 2aa0 20A09DE5 		ldr	sl, [sp, #32]
 4960 2aa4 3CC08DE5 		str	ip, [sp, #60]
 4961 2aa8 0A005EE1 		cmp	lr, sl
 4962 2aac 0EA0A031 		movcc	sl, lr
 4963 2ab0 0AC062E2 		rsb	ip, r2, #10
 4964 2ab4 40C08DE5 		str	ip, [sp, #64]
 4965 2ab8 38A08DE5 		str	sl, [sp, #56]
 4966 2abc 3CC09DE5 		ldr	ip, [sp, #60]
 4967 2ac0 4CA09DE5 		ldr	sl, [sp, #76]
 4968 2ac4 140052E3 		cmp	r2, #20
 4969 2ac8 2CA8A091 		movls	sl, ip, lsr #16
 4970 2acc 2AA8A081 		movhi	sl, sl, lsr #16
 4971 2ad0 44C09DE5 		ldr	ip, [sp, #68]
 4972 2ad4 010050E1 		cmp	r0, r1
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4973              		.loc 1 1815 0
 4974 2ad8 48109DE5 		ldr	r1, [sp, #72]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4975              		.loc 1 1817 0
 4976 2adc 01C0A033 		movcc	ip, #1
 4977 2ae0 3CA08DE5 		str	sl, [sp, #60]
 4978 2ae4 24C08DE5 		str	ip, [sp, #36]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4979              		.loc 1 1815 0
 4980 2ae8 01A8A0E1 		mov	sl, r1, asl #16
 4981 2aec 05C042E2 		sub	ip, r2, #5
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4982              		.loc 1 1817 0
 4983 2af0 051062E2 		rsb	r1, r2, #5
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4984              		.loc 1 1815 0
 4985 2af4 48A08DE5 		str	sl, [sp, #72]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4986              		.loc 1 1817 0
 4987 2af8 40009DE5 		ldr	r0, [sp, #64]
 4988 2afc 38A09DE5 		ldr	sl, [sp, #56]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4989              		.loc 1 1815 0
 4990 2b00 40C08DE5 		str	ip, [sp, #64]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4991              		.loc 1 1817 0
 4992 2b04 3CC09DE5 		ldr	ip, [sp, #60]
 4993 2b08 4C108DE5 		str	r1, [sp, #76]
 4994 2b0c 48109DE5 		ldr	r1, [sp, #72]
 4995 2b10 0008A0E1 		mov	r0, r0, asl #16
 4996 2b14 0A005CE1 		cmp	ip, sl
 4997 2b18 0AC0A021 		movcs	ip, sl
 4998 2b1c 0A0052E3 		cmp	r2, #10
 4999 2b20 20A09DE5 		ldr	sl, [sp, #32]
 5000 2b24 2108A081 		movhi	r0, r1, lsr #16
 5001 2b28 2008A091 		movls	r0, r0, lsr #16
 5002 2b2c 48008DE5 		str	r0, [sp, #72]
 5003 2b30 24009DE5 		ldr	r0, [sp, #36]
 5004 2b34 0A005EE1 		cmp	lr, sl
 5005 2b38 0200A033 		movcc	r0, #2
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5006              		.loc 1 1815 0
 5007 2b3c 02E042E2 		sub	lr, r2, #2
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5008              		.loc 1 1817 0
 5009 2b40 44C08DE5 		str	ip, [sp, #68]
 5010 2b44 24008DE5 		str	r0, [sp, #36]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5011              		.loc 1 1815 0
 5012 2b48 40C09DE5 		ldr	ip, [sp, #64]
 5013 2b4c 1CE08DE5 		str	lr, [sp, #28]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5014              		.loc 1 1817 0
 5015 2b50 44009DE5 		ldr	r0, [sp, #68]
 5016 2b54 48E09DE5 		ldr	lr, [sp, #72]
 5017 2b58 4C109DE5 		ldr	r1, [sp, #76]
 5018 2b5c 02A062E2 		rsb	sl, r2, #2
 5019 2b60 00005EE1 		cmp	lr, r0
 5020 2b64 00E0A021 		movcs	lr, r0
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5021              		.loc 1 1815 0
 5022 2b68 0CC8A0E1 		mov	ip, ip, asl #16
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5023              		.loc 1 1817 0
 5024 2b6c 050052E3 		cmp	r2, #5
 5025 2b70 40A08DE5 		str	sl, [sp, #64]
 5026 2b74 0118A0E1 		mov	r1, r1, asl #16
 5027 2b78 3CA09DE5 		ldr	sl, [sp, #60]
 5028 2b7c 2C18A081 		movhi	r1, ip, lsr #16
 5029 2b80 38C09DE5 		ldr	ip, [sp, #56]
 5030 2b84 4CE08DE5 		str	lr, [sp, #76]
 5031 2b88 24009DE5 		ldr	r0, [sp, #36]
 5032 2b8c 40E09DE5 		ldr	lr, [sp, #64]
 5033 2b90 2118A091 		movls	r1, r1, lsr #16
 5034 2b94 0C005AE1 		cmp	sl, ip
 5035 2b98 20108DE5 		str	r1, [sp, #32]
 5036 2b9c 0300A033 		movcc	r0, #3
 5037 2ba0 38008DE5 		str	r0, [sp, #56]
 5038 2ba4 4CA09DE5 		ldr	sl, [sp, #76]
 5039 2ba8 0E08A0E1 		mov	r0, lr, asl #16
 5040 2bac 20E09DE5 		ldr	lr, [sp, #32]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5041              		.loc 1 1815 0
 5042 2bb0 1C109DE5 		ldr	r1, [sp, #28]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5043              		.loc 1 1817 0
 5044 2bb4 0A005EE1 		cmp	lr, sl
 5045 2bb8 0AE0A021 		movcs	lr, sl
 5046 2bbc 44C09DE5 		ldr	ip, [sp, #68]
 5047 2bc0 48A09DE5 		ldr	sl, [sp, #72]
 5048 2bc4 020052E3 		cmp	r2, #2
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5049              		.loc 1 1815 0
 5050 2bc8 0118A0E1 		mov	r1, r1, asl #16
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5051              		.loc 1 1817 0
 5052 2bcc 2018A091 		movls	r1, r0, lsr #16
 5053 2bd0 38009DE5 		ldr	r0, [sp, #56]
 5054 2bd4 2118A081 		movhi	r1, r1, lsr #16
 5055 2bd8 0C005AE1 		cmp	sl, ip
 5056 2bdc 0400A033 		movcc	r0, #4
 5057 2be0 40008DE5 		str	r0, [sp, #64]
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5058              		.loc 1 1815 0
 5059 2be4 010042E2 		sub	r0, r2, #1
 5060 2be8 38008DE5 		str	r0, [sp, #56]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5061              		.loc 1 1817 0
 5062 2bec 4CA09DE5 		ldr	sl, [sp, #76]
 5063 2bf0 20009DE5 		ldr	r0, [sp, #32]
 5064 2bf4 01C062E2 		rsb	ip, r2, #1
 5065 2bf8 3CC08DE5 		str	ip, [sp, #60]
 5066 2bfc 0A0050E1 		cmp	r0, sl
1824:../uvc.c      **** 						  shutter = shutter+index;
 5067              		.loc 1 1824 0
 5068 2c00 38A09DE5 		ldr	sl, [sp, #56]
 5069 2c04 3C009DE5 		ldr	r0, [sp, #60]
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5070              		.loc 1 1817 0
 5071 2c08 40C09DE5 		ldr	ip, [sp, #64]
 5072 2c0c 05C0A033 		movcc	ip, #5
1824:../uvc.c      **** 						  shutter = shutter+index;
 5073              		.loc 1 1824 0
 5074 2c10 010052E3 		cmp	r2, #1
 5075 2c14 0028A091 		movls	r2, r0, asl #16
 5076 2c18 0A28A081 		movhi	r2, sl, asl #16
 5077 2c1c 0E0051E1 		cmp	r1, lr
 5078 2c20 01A0A031 		movcc	sl, r1
 5079 2c24 0EA0A021 		movcs	sl, lr
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5080              		.loc 1 1817 0
 5081 2c28 0E0051E1 		cmp	r1, lr
 5082 2c2c 0C10A021 		movcs	r1, ip
 5083 2c30 0610A033 		movcc	r1, #6
1824:../uvc.c      **** 						  shutter = shutter+index;
 5084              		.loc 1 1824 0
 5085 2c34 22085AE1 		cmp	sl, r2, lsr #16
1827:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5086              		.loc 1 1827 0
 5087 2c38 90A39FE5 		ldr	sl, .L398+24
1824:../uvc.c      **** 						  shutter = shutter+index;
 5088              		.loc 1 1824 0
 5089 2c3c 0120A091 		movls	r2, r1
 5090 2c40 0720A083 		movhi	r2, #7
 5091 2c44 012082E2 		add	r2, r2, #1
 5092 2c48 FFE002E2 		and	lr, r2, #255
1827:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5093              		.loc 1 1827 0
 5094 2c4c 0010E0E3 		mvn	r1, #0
 5095 2c50 1C009AE5 		ldr	r0, [sl, #28]
1824:../uvc.c      **** 						  shutter = shutter+index;
 5096              		.loc 1 1824 0
 5097 2c54 38E08DE5 		str	lr, [sp, #56]
 5098              	.LVL484:
1827:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5099              		.loc 1 1827 0
 5100 2c58 2C308DE5 		str	r3, [sp, #44]
 5101 2c5c FEFFFFEB 		bl	_txe_mutex_get
1828:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5102              		.loc 1 1828 0
 5103 2c60 38C09DE5 		ldr	ip, [sp, #56]
 5104 2c64 0310A0E3 		mov	r1, #3
 5105 2c68 0B20A0E1 		mov	r2, fp
 5106 2c6c 2C309DE5 		ldr	r3, [sp, #44]
 5107 2c70 00C08DE5 		str	ip, [sp, #0]
 5108 2c74 0A00A0E1 		mov	r0, sl
 5109 2c78 00C0A0E3 		mov	ip, #0
 5110 2c7c 04C08DE5 		str	ip, [sp, #4]
 5111 2c80 FEFFFFEB 		bl	cmdSet
1829:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5112              		.loc 1 1829 0
 5113 2c84 1C009AE5 		ldr	r0, [sl, #28]
 5114 2c88 FEFFFFEB 		bl	_txe_mutex_put
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5115              		.loc 1 1832 0
 5116 2c8c 30009DE5 		ldr	r0, [sp, #48]
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5117              		.loc 1 1833 0
 5118 2c90 34C09DE5 		ldr	ip, [sp, #52]
1835:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5119              		.loc 1 1835 0
 5120 2c94 38309DE5 		ldr	r3, [sp, #56]
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5121              		.loc 1 1832 0
 5122 2c98 061089E0 		add	r1, r9, r6
 5123 2c9c 816188E0 		add	r6, r8, r1, asl #3
1834:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5124              		.loc 1 1834 0
 5125 2ca0 0120A0E3 		mov	r2, #1
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5126              		.loc 1 1832 0
 5127 2ca4 2D05C6E5 		strb	r0, [r6, #1325]
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5128              		.loc 1 1833 0
 5129 2ca8 2EC5C6E5 		strb	ip, [r6, #1326]
1834:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5130              		.loc 1 1834 0
 5131 2cac 3025C6E5 		strb	r2, [r6, #1328]
1835:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5132              		.loc 1 1835 0
 5133 2cb0 0D33C8E5 		strb	r3, [r8, #781]
 5134 2cb4 3FFFFFEA 		b	.L388
 5135              	.LVL485:
 5136              	.L334:
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5137              		.loc 1 1762 0
 5138 2cb8 062089E0 		add	r2, r9, r6
 5139 2cbc 826188E0 		add	r6, r8, r2, asl #3
1763:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5140              		.loc 1 1763 0
 5141 2cc0 0110A0E3 		mov	r1, #1
1766:../uvc.c      **** 		  		    switch (getData){
 5142              		.loc 1 1766 0
 5143 2cc4 01E040E2 		sub	lr, r0, #1
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5144              		.loc 1 1762 0
 5145 2cc8 2D05C6E5 		strb	r0, [r6, #1325]
1763:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5146              		.loc 1 1763 0
 5147 2ccc 3015C6E5 		strb	r1, [r6, #1328]
 5148              	.LVL486:
1766:../uvc.c      **** 		  		    switch (getData){
 5149              		.loc 1 1766 0
 5150 2cd0 07005EE3 		cmp	lr, #7
 5151 2cd4 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5152 2cd8 980000EA 		b	.L339
 5153              	.L344:
 5154 2cdc D42E0000 		.word	.L340
 5155 2ce0 382E0000 		.word	.L341
 5156 2ce4 402F0000 		.word	.L339
 5157 2ce8 D02D0000 		.word	.L342
 5158 2cec 402F0000 		.word	.L339
 5159 2cf0 402F0000 		.word	.L339
 5160 2cf4 402F0000 		.word	.L339
 5161 2cf8 302D0000 		.word	.L343
 5162              	.LVL487:
 5163              	.L333:
1882:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5164              		.loc 1 1882 0
 5165 2cfc 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1881:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5166              		.loc 1 1881 0
 5167 2d00 30A09DE5 		ldr	sl, [sp, #48]
 5168 2d04 069089E0 		add	r9, r9, r6
 5169 2d08 89E188E0 		add	lr, r8, r9, asl #3
1882:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5170              		.loc 1 1882 0
 5171 2d0c 0620A0E1 		mov	r2, r6
 5172 2d10 0400A0E3 		mov	r0, #4
 5173 2d14 C0129FE5 		ldr	r1, .L398+36
1881:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5174              		.loc 1 1881 0
 5175 2d18 2DA5CEE5 		strb	sl, [lr, #1325]
1882:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5176              		.loc 1 1882 0
 5177 2d1c FEFFFFEB 		bl	CyU3PDebugPrint
1883:../uvc.c      **** 			  		 break;
 5178              		.loc 1 1883 0
 5179 2d20 FFC0A0E3 		mov	ip, #255
 5180 2d24 0C60A0E1 		mov	r6, ip
 5181 2d28 0C80A0E1 		mov	r8, ip
 5182 2d2c 68FEFFEA 		b	.L324
 5183              	.LVL488:
 5184              	.L343:
1785:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5185              		.loc 1 1785 0
 5186 2d30 98629FE5 		ldr	r6, .L398+24
1783:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5187              		.loc 1 1783 0
 5188 2d34 00A0A0E3 		mov	sl, #0
1785:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5189              		.loc 1 1785 0
 5190 2d38 1C0096E5 		ldr	r0, [r6, #28]
1783:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5191              		.loc 1 1783 0
 5192 2d3c 0DA3C8E5 		strb	sl, [r8, #781]
 5193              	.LVL489:
1785:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5194              		.loc 1 1785 0
 5195 2d40 0010E0E3 		mvn	r1, #0
 5196 2d44 2C308DE5 		str	r3, [sp, #44]
 5197 2d48 FEFFFFEB 		bl	_txe_mutex_get
1786:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5198              		.loc 1 1786 0
 5199 2d4c 0B20A0E1 		mov	r2, fp
 5200 2d50 2C309DE5 		ldr	r3, [sp, #44]
 5201 2d54 1010A0E3 		mov	r1, #16
 5202 2d58 0600A0E1 		mov	r0, r6
 5203 2d5c 00A08DE5 		str	sl, [sp, #0]
 5204 2d60 04A08DE5 		str	sl, [sp, #4]
 5205 2d64 FEFFFFEB 		bl	cmdSet
1787:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5206              		.loc 1 1787 0
 5207 2d68 1C0096E5 		ldr	r0, [r6, #28]
 5208 2d6c FEFFFFEB 		bl	_txe_mutex_put
 5209              	.LVL490:
 5210              	.LBB68:
 5211              	.LBB69:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5212              		.loc 1 680 0
 5213 2d70 0010E0E3 		mvn	r1, #0
 5214 2d74 1C0096E5 		ldr	r0, [r6, #28]
 5215 2d78 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5216              		.loc 1 681 0
 5217 2d7c 01C0A0E3 		mov	ip, #1
 5218 2d80 2010A0E3 		mov	r1, #32
 5219 2d84 2720A0E3 		mov	r2, #39
 5220 2d88 3030A0E3 		mov	r3, #48
 5221 2d8c 0600A0E1 		mov	r0, r6
 5222 2d90 00C08DE5 		str	ip, [sp, #0]
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5223              		.loc 1 682 0
 5224 2d94 0280A0E3 		mov	r8, #2
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5225              		.loc 1 681 0
 5226 2d98 04A08DE5 		str	sl, [sp, #4]
 5227 2d9c FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5228              		.loc 1 682 0
 5229 2da0 2110A0E3 		mov	r1, #33
 5230 2da4 2520A0E3 		mov	r2, #37
 5231 2da8 3030A0E3 		mov	r3, #48
 5232 2dac 0600A0E1 		mov	r0, r6
 5233 2db0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5234 2db4 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5235              		.loc 1 683 0
 5236 2db8 1C0096E5 		ldr	r0, [r6, #28]
 5237 2dbc FEFFFFEB 		bl	_txe_mutex_put
 5238              	.LBE69:
 5239              	.LBE68:
1789:../uvc.c      **** 							break;
 5240              		.loc 1 1789 0
 5241 2dc0 FFC0A0E3 		mov	ip, #255
 5242 2dc4 0C60A0E1 		mov	r6, ip
 5243 2dc8 0880A0E3 		mov	r8, #8
 5244 2dcc 40FEFFEA 		b	.L324
 5245              	.LVL491:
 5246              	.L342:
 5247              	.LBB70:
 5248              	.LBB71:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5249              		.loc 1 680 0
 5250 2dd0 F8619FE5 		ldr	r6, .L398+24
 5251 2dd4 0010E0E3 		mvn	r1, #0
 5252 2dd8 1C0096E5 		ldr	r0, [r6, #28]
 5253 2ddc FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5254              		.loc 1 681 0
 5255 2de0 0080A0E3 		mov	r8, #0
 5256 2de4 2010A0E3 		mov	r1, #32
 5257 2de8 2720A0E3 		mov	r2, #39
 5258 2dec 3030A0E3 		mov	r3, #48
 5259 2df0 0600A0E1 		mov	r0, r6
 5260 2df4 00808DE5 		str	r8, [sp, #0]
 5261 2df8 04808DE5 		str	r8, [sp, #4]
 5262 2dfc FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5263              		.loc 1 682 0
 5264 2e00 01C0A0E3 		mov	ip, #1
 5265 2e04 2110A0E3 		mov	r1, #33
 5266 2e08 2520A0E3 		mov	r2, #37
 5267 2e0c 3030A0E3 		mov	r3, #48
 5268 2e10 0600A0E1 		mov	r0, r6
 5269 2e14 00C08DE5 		str	ip, [sp, #0]
 5270 2e18 04808DE5 		str	r8, [sp, #4]
 5271 2e1c FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5272              		.loc 1 683 0
 5273 2e20 1C0096E5 		ldr	r0, [r6, #28]
 5274 2e24 FEFFFFEB 		bl	_txe_mutex_put
 5275 2e28 FFC0A0E3 		mov	ip, #255
 5276 2e2c 0C60A0E1 		mov	r6, ip
 5277 2e30 0480A0E3 		mov	r8, #4
 5278 2e34 26FEFFEA 		b	.L324
 5279              	.LVL492:
 5280              	.L341:
 5281              	.LBE71:
 5282              	.LBE70:
1773:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5283              		.loc 1 1773 0
 5284 2e38 90619FE5 		ldr	r6, .L398+24
1771:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5285              		.loc 1 1771 0
 5286 2e3c 00A0A0E3 		mov	sl, #0
1773:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5287              		.loc 1 1773 0
 5288 2e40 1C0096E5 		ldr	r0, [r6, #28]
1771:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5289              		.loc 1 1771 0
 5290 2e44 0DA3C8E5 		strb	sl, [r8, #781]
 5291              	.LVL493:
1773:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5292              		.loc 1 1773 0
 5293 2e48 0010E0E3 		mvn	r1, #0
 5294 2e4c 2C308DE5 		str	r3, [sp, #44]
 5295 2e50 FEFFFFEB 		bl	_txe_mutex_get
1774:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5296              		.loc 1 1774 0
 5297 2e54 0B20A0E1 		mov	r2, fp
 5298 2e58 2C309DE5 		ldr	r3, [sp, #44]
 5299 2e5c 1010A0E3 		mov	r1, #16
 5300 2e60 0600A0E1 		mov	r0, r6
 5301 2e64 00A08DE5 		str	sl, [sp, #0]
 5302 2e68 04A08DE5 		str	sl, [sp, #4]
 5303 2e6c FEFFFFEB 		bl	cmdSet
1775:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5304              		.loc 1 1775 0
 5305 2e70 1C0096E5 		ldr	r0, [r6, #28]
 5306 2e74 FEFFFFEB 		bl	_txe_mutex_put
 5307              	.LVL494:
 5308              	.LBB72:
 5309              	.LBB73:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5310              		.loc 1 680 0
 5311 2e78 0010E0E3 		mvn	r1, #0
 5312 2e7c 1C0096E5 		ldr	r0, [r6, #28]
 5313 2e80 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5314              		.loc 1 681 0
 5315 2e84 2010A0E3 		mov	r1, #32
 5316 2e88 2720A0E3 		mov	r2, #39
 5317 2e8c 3030A0E3 		mov	r3, #48
 5318 2e90 0600A0E1 		mov	r0, r6
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5319              		.loc 1 682 0
 5320 2e94 0180A0E3 		mov	r8, #1
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5321              		.loc 1 681 0
 5322 2e98 00A08DE5 		str	sl, [sp, #0]
 5323 2e9c 04A08DE5 		str	sl, [sp, #4]
 5324 2ea0 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5325              		.loc 1 682 0
 5326 2ea4 2110A0E3 		mov	r1, #33
 5327 2ea8 2520A0E3 		mov	r2, #37
 5328 2eac 3030A0E3 		mov	r3, #48
 5329 2eb0 0600A0E1 		mov	r0, r6
 5330 2eb4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5331 2eb8 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5332              		.loc 1 683 0
 5333 2ebc 1C0096E5 		ldr	r0, [r6, #28]
 5334 2ec0 FEFFFFEB 		bl	_txe_mutex_put
 5335 2ec4 FFC0A0E3 		mov	ip, #255
 5336 2ec8 0C60A0E1 		mov	r6, ip
 5337 2ecc 0280A0E3 		mov	r8, #2
 5338 2ed0 FFFDFFEA 		b	.L324
 5339              	.LVL495:
 5340              	.L340:
 5341              	.LBE73:
 5342              	.LBE72:
 5343              	.LBB74:
 5344              	.LBB75:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5345              		.loc 1 680 0
 5346 2ed4 F4609FE5 		ldr	r6, .L398+24
 5347 2ed8 0010E0E3 		mvn	r1, #0
 5348 2edc 1C0096E5 		ldr	r0, [r6, #28]
 5349 2ee0 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5350              		.loc 1 681 0
 5351 2ee4 0080A0E3 		mov	r8, #0
 5352 2ee8 01A0A0E3 		mov	sl, #1
 5353 2eec 2010A0E3 		mov	r1, #32
 5354 2ef0 2720A0E3 		mov	r2, #39
 5355 2ef4 3030A0E3 		mov	r3, #48
 5356 2ef8 0600A0E1 		mov	r0, r6
 5357 2efc 04808DE5 		str	r8, [sp, #4]
 5358 2f00 00A08DE5 		str	sl, [sp, #0]
 5359 2f04 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5360              		.loc 1 682 0
 5361 2f08 02C0A0E3 		mov	ip, #2
 5362 2f0c 2110A0E3 		mov	r1, #33
 5363 2f10 2520A0E3 		mov	r2, #37
 5364 2f14 3030A0E3 		mov	r3, #48
 5365 2f18 0600A0E1 		mov	r0, r6
 5366 2f1c 00C08DE5 		str	ip, [sp, #0]
 5367 2f20 04808DE5 		str	r8, [sp, #4]
 5368 2f24 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5369              		.loc 1 683 0
 5370 2f28 1C0096E5 		ldr	r0, [r6, #28]
 5371 2f2c FEFFFFEB 		bl	_txe_mutex_put
 5372              	.LBE75:
 5373              	.LBE74:
1769:../uvc.c      **** 							break;
 5374              		.loc 1 1769 0
 5375 2f30 FFC0A0E3 		mov	ip, #255
 5376 2f34 0C60A0E1 		mov	r6, ip
 5377 2f38 0A80A0E1 		mov	r8, sl
 5378 2f3c E4FDFFEA 		b	.L324
 5379              	.LVL496:
 5380              	.L339:
1766:../uvc.c      **** 		  		    switch (getData){
 5381              		.loc 1 1766 0
 5382 2f40 FFC0A0E3 		mov	ip, #255
 5383 2f44 0080A0E1 		mov	r8, r0
 5384 2f48 0C60A0E1 		mov	r6, ip
 5385 2f4c E0FDFFEA 		b	.L324
 5386              	.LVL497:
 5387              	.L345:
1837:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5388              		.loc 1 1837 0
 5389 2f50 0000A0E3 		mov	r0, #0
 5390 2f54 0110A0E3 		mov	r1, #1
 5391 2f58 0020A0E1 		mov	r2, r0
 5392 2f5c FEFFFFEB 		bl	CyU3PUsbStall
 5393              	.LVL498:
 5394 2f60 94FEFFEA 		b	.L388
 5395              	.LVL499:
 5396              	.L387:
1855:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5397              		.loc 1 1855 0
 5398 2f64 0110A0E3 		mov	r1, #1
 5399 2f68 0020A0E1 		mov	r2, r0
 5400 2f6c FEFFFFEB 		bl	CyU3PUsbStall
 5401 2f70 90FEFFEA 		b	.L388
 5402              	.LVL500:
 5403              	.L397:
1870:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5404              		.loc 1 1870 0
 5405 2f74 08E0A0E3 		mov	lr, #8
 5406 2f78 00C0A0E3 		mov	ip, #0
 5407 2f7c 0600A0E1 		mov	r0, r6
 5408 2f80 2310A0E3 		mov	r1, #35
 5409 2f84 0B20A0E1 		mov	r2, fp
 5410 2f88 00E08DE5 		str	lr, [sp, #0]
 5411 2f8c 04C08DE5 		str	ip, [sp, #4]
 5412 2f90 FEFFFFEB 		bl	cmdSet
 5413 2f94 5DFEFFEA 		b	.L390
 5414              	.L396:
1868:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5415              		.loc 1 1868 0
 5416 2f98 0480A0E3 		mov	r8, #4
 5417 2f9c 00E0A0E3 		mov	lr, #0
 5418 2fa0 0600A0E1 		mov	r0, r6
 5419 2fa4 2310A0E3 		mov	r1, #35
 5420 2fa8 0B20A0E1 		mov	r2, fp
 5421 2fac 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5422 2fb0 FEFFFFEB 		bl	cmdSet
 5423 2fb4 55FEFFEA 		b	.L390
 5424              	.L399:
 5425              		.align	2
 5426              	.L398:
 5427 2fb8 00000000 		.word	bRequest
 5428 2fbc 00000000 		.word	.LANCHOR1
 5429 2fc0 00000000 		.word	.LANCHOR0
 5430 2fc4 50050000 		.word	.LC32
 5431 2fc8 74050000 		.word	.LC33
 5432 2fcc 5C000000 		.word	.LANCHOR0+92
 5433 2fd0 00000000 		.word	cmdQu
 5434 2fd4 04050000 		.word	.LC30
 5435 2fd8 FFFF0000 		.word	65535
 5436 2fdc 2C050000 		.word	.LC31
 5437              		.cfi_endproc
 5438              	.LFE4:
 5440              		.align	2
 5441              		.global	UVCAppEP0Thread_Entry
 5443              	UVCAppEP0Thread_Entry:
 5444              	.LFB25:
4048:../uvc.c      **** {
 5445              		.loc 1 4048 0
 5446              		.cfi_startproc
 5447              		@ args = 0, pretend = 0, frame = 24
 5448              		@ frame_needed = 0, uses_anonymous_args = 0
 5449              	.LVL501:
 5450 2fe0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5451              	.LCFI20:
 5452              		.cfi_def_cfa_offset 36
 5453 2fe4 644D9FE5 		ldr	r4, .L595
 5454              		.cfi_offset 14, -4
 5455              		.cfi_offset 11, -8
 5456              		.cfi_offset 10, -12
 5457              		.cfi_offset 9, -16
 5458              		.cfi_offset 8, -20
 5459              		.cfi_offset 7, -24
 5460              		.cfi_offset 6, -28
 5461              		.cfi_offset 5, -32
 5462              		.cfi_offset 4, -36
 5463 2fe8 645D9FE5 		ldr	r5, .L595+4
 5464 2fec 648D9FE5 		ldr	r8, .L595+8
 5465 2ff0 64AD9FE5 		ldr	sl, .L595+12
 5466 2ff4 64BD9FE5 		ldr	fp, .L595+16
 5467 2ff8 647D9FE5 		ldr	r7, .L595+20
 5468 2ffc 34D04DE2 		sub	sp, sp, #52
 5469              	.LCFI21:
 5470              		.cfi_def_cfa_offset 88
 5471              	.LVL502:
4070:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5472              		.loc 1 4070 0
 5473 3000 0460A0E1 		mov	r6, r4
 5474              	.LVL503:
 5475              	.L555:
 5476 3004 00C0E0E3 		mvn	ip, #0
 5477 3008 400D9FE5 		ldr	r0, .L595
 5478 300c 4C10A0E3 		mov	r1, #76
 5479 3010 0120A0E3 		mov	r2, #1
 5480 3014 28308DE2 		add	r3, sp, #40
 5481 3018 00C08DE5 		str	ip, [sp, #0]
 5482 301c FEFFFFEB 		bl	_txe_event_flags_get
 5483 3020 000050E3 		cmp	r0, #0
 5484 3024 3000001A 		bne	.L401
4074:../uvc.c      ****             if (!isUsbConnected)
 5485              		.loc 1 4074 0
 5486 3028 303096E5 		ldr	r3, [r6, #48]
 5487 302c 000053E3 		cmp	r3, #0
 5488 3030 8C00000A 		beq	.L584
 5489              	.L402:
4083:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 5490              		.loc 1 4083 0
 5491 3034 28309DE5 		ldr	r3, [sp, #40]
 5492 3038 0C0013E3 		tst	r3, #12
 5493 303c 7500001A 		bne	.L585
 5494              	.L403:
4090:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5495              		.loc 1 4090 0
 5496 3040 040013E3 		tst	r3, #4
 5497 3044 1C00000A 		beq	.L404
4092:../uvc.c      ****             	switch ((wIndex >> 8))
 5498              		.loc 1 4092 0
 5499 3048 B0E0DBE1 		ldrh	lr, [fp, #0]
 5500 304c 2E24A0E1 		mov	r2, lr, lsr #8
 5501 3050 030052E3 		cmp	r2, #3
 5502 3054 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5503 3058 120000EA 		b	.L405
 5504              	.L410:
 5505 305c A8300000 		.word	.L405
 5506 3060 98310000 		.word	.L407
 5507 3064 6C300000 		.word	.L408
 5508 3068 D4310000 		.word	.L409
 5509              	.L408:
 5510              	.LBB90:
 5511              	.LBB94:
3296:../uvc.c      ****     switch (wValue)
 5512              		.loc 1 3296 0
 5513 306c B020DAE1 		ldrh	r2, [sl, #0]
 5514 3070 060C52E3 		cmp	r2, #1536
 5515 3074 9902000A 		beq	.L416
 5516 3078 D900008A 		bhi	.L422
 5517 307c 030C52E3 		cmp	r2, #768
 5518 3080 9202000A 		beq	.L414
 5519 3084 A001008A 		bhi	.L423
 5520 3088 010C52E3 		cmp	r2, #256
 5521 308c B602000A 		beq	.L412
 5522 3090 020C52E3 		cmp	r2, #512
 5523 3094 B002000A 		beq	.L586
 5524              	.L425:
 5525              	.LBE94:
 5526              	.LBE90:
 5527              	.LBB98:
 5528              	.LBB103:
3428:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5529              		.loc 1 3428 0
 5530 3098 C81C9FE5 		ldr	r1, .L595+24
 5531 309c 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5532 30a0 0400A0E3 		mov	r0, #4
 5533 30a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5534              	.L405:
 5535              	.LBE103:
 5536              	.LBE98:
4113:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5537              		.loc 1 4113 0
 5538 30a8 0000A0E3 		mov	r0, #0
 5539 30ac 0110A0E3 		mov	r1, #1
 5540 30b0 0020A0E1 		mov	r2, r0
 5541 30b4 FEFFFFEB 		bl	CyU3PUsbStall
 5542 30b8 28309DE5 		ldr	r3, [sp, #40]
 5543              	.L404:
4118:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5544              		.loc 1 4118 0
 5545 30bc 080013E3 		tst	r3, #8
 5546 30c0 0700000A 		beq	.L468
4122:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5547              		.loc 1 4122 0
 5548 30c4 B030DBE1 		ldrh	r3, [fp, #0]
 5549 30c8 010053E3 		cmp	r3, #1
 5550 30cc 6B00000A 		beq	.L469
 5551              	.L470:
 5552              	.LBB109:
 5553              	.LBB113:
4037:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5554              		.loc 1 4037 0
 5555 30d0 0000A0E3 		mov	r0, #0
 5556 30d4 0110A0E3 		mov	r1, #1
 5557 30d8 0020A0E1 		mov	r2, r0
 5558 30dc FEFFFFEB 		bl	CyU3PUsbStall
 5559              	.L574:
 5560 30e0 28309DE5 		ldr	r3, [sp, #40]
 5561              	.L468:
 5562              	.LBE113:
 5563              	.LBE109:
4133:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5564              		.loc 1 4133 0
 5565 30e4 400013E3 		tst	r3, #64
 5566 30e8 0100001A 		bne	.L587
 5567              	.L401:
4346:../uvc.c      ****         CyU3PThreadRelinquish ();
 5568              		.loc 1 4346 0
 5569 30ec FEFFFFEB 		bl	_txe_thread_relinquish
4347:../uvc.c      ****     }
 5570              		.loc 1 4347 0
 5571 30f0 C3FFFFEA 		b	.L555
 5572              	.L587:
4138:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5573              		.loc 1 4138 0
 5574 30f4 1800A0E3 		mov	r0, #24
 5575 30f8 24108DE2 		add	r1, sp, #36
 5576 30fc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4195:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5577              		.loc 1 4195 0
 5578 3100 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 5579 3104 0F0053E3 		cmp	r3, #15
 5580 3108 9400000A 		beq	.L588
4222:../uvc.c      **** 				}else if(!snapButFlag){
 5581              		.loc 1 4222 0
 5582 310c 000053E3 		cmp	r3, #0
 5583 3110 F5FFFF1A 		bne	.L401
4224:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5584              		.loc 1 4224 0
 5585 3114 002097E5 		ldr	r2, [r7, #0]
 5586 3118 0290A0E3 		mov	r9, #2
 5587 311c 0090C2E5 		strb	r9, [r2, #0]
4225:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5588              		.loc 1 4225 0
 5589 3120 001097E5 		ldr	r1, [r7, #0]
 5590 3124 0190A0E3 		mov	r9, #1
 5591 3128 0190C1E5 		strb	r9, [r1, #1]
4226:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5592              		.loc 1 4226 0
 5593 312c 000097E5 		ldr	r0, [r7, #0]
4230:../uvc.c      **** 					interStabuf.size   = 1024;
 5594              		.loc 1 4230 0
 5595 3130 01CBA0E3 		mov	ip, #1024	@ movhi
4226:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5596              		.loc 1 4226 0
 5597 3134 0230C0E5 		strb	r3, [r0, #2]
4227:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5598              		.loc 1 4227 0
 5599 3138 00E097E5 		ldr	lr, [r7, #0]
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5600              		.loc 1 4236 0
 5601 313c 0010E0E3 		mvn	r1, #0
4227:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5602              		.loc 1 4227 0
 5603 3140 0390CEE5 		strb	r9, [lr, #3]
4229:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5604              		.loc 1 4229 0
 5605 3144 002097E5 		ldr	r2, [r7, #0]
4233:../uvc.c      **** 					interStabuf.count = 4;
 5606              		.loc 1 4233 0
 5607 3148 04E0A0E3 		mov	lr, #4	@ movhi
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5608              		.loc 1 4236 0
 5609 314c 180C9FE5 		ldr	r0, .L595+28
4229:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5610              		.loc 1 4229 0
 5611 3150 18208DE5 		str	r2, [sp, #24]
4230:../uvc.c      **** 					interStabuf.size   = 1024;
 5612              		.loc 1 4230 0
 5613 3154 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4231:../uvc.c      **** 					interStabuf.status = 0;
 5614              		.loc 1 4231 0
 5615 3158 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4233:../uvc.c      **** 					interStabuf.count = 4;
 5616              		.loc 1 4233 0
 5617 315c BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5618              		.loc 1 4236 0
 5619 3160 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4239:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5620              		.loc 1 4239 0
 5621 3164 000C9FE5 		ldr	r0, .L595+28
 5622 3168 18108DE2 		add	r1, sp, #24
 5623 316c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5624              	.LVL504:
4241:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5625              		.loc 1 4241 0
 5626 3170 002050E2 		subs	r2, r0, #0
 5627 3174 5B01001A 		bne	.L589
4247:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 5628              		.loc 1 4247 0
 5629 3178 3010A0E3 		mov	r1, #48
 5630 317c 0920A0E1 		mov	r2, r9
 5631 3180 0500A0E3 		mov	r0, #5
 5632              	.LVL505:
 5633 3184 FEFFFFEB 		bl	SensorSetControl
4248:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 5634              		.loc 1 4248 0
 5635 3188 C43B9FE5 		ldr	r3, .L595+4
 5636 318c 0B97C3E5 		strb	r9, [r3, #1803]
4346:../uvc.c      ****         CyU3PThreadRelinquish ();
 5637              		.loc 1 4346 0
 5638 3190 FEFFFFEB 		bl	_txe_thread_relinquish
 5639 3194 9AFFFFEA 		b	.L555
 5640              	.L407:
 5641              	.LBB118:
 5642              	.LBB104:
3371:../uvc.c      ****     switch (wValue)
 5643              		.loc 1 3371 0
 5644 3198 B020DAE1 		ldrh	r2, [sl, #0]
 5645 319c 060C52E3 		cmp	r2, #1536
 5646 31a0 7502000A 		beq	.L431
 5647 31a4 9900008A 		bhi	.L437
 5648 31a8 030C52E3 		cmp	r2, #768
 5649 31ac 5B02000A 		beq	.L428
 5650 31b0 8101008A 		bhi	.L438
 5651 31b4 010C52E3 		cmp	r2, #256
 5652 31b8 5402000A 		beq	.L426
 5653 31bc 020C52E3 		cmp	r2, #512
 5654 31c0 B4FFFF1A 		bne	.L425
 5655              	.LVL506:
3379:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 5656              		.loc 1 3379 0
 5657 31c4 0100A0E3 		mov	r0, #1
 5658 31c8 FEFFFFEB 		bl	CTControlHandle
 5659              	.LVL507:
 5660 31cc 28309DE5 		ldr	r3, [sp, #40]
 5661 31d0 B9FFFFEA 		b	.L404
 5662              	.L409:
 5663              	.LBE104:
 5664              	.LBE118:
 5665              	.LBB119:
 5666              	.LBB125:
3596:../uvc.c      ****     switch (wValue)
 5667              		.loc 1 3596 0
 5668 31d4 B030DAE1 		ldrh	r3, [sl, #0]
 5669 31d8 090C53E3 		cmp	r3, #2304
 5670 31dc 4702000A 		beq	.L452
 5671 31e0 9200008A 		bhi	.L462
 5672 31e4 010B53E3 		cmp	r3, #1024
 5673 31e8 4002000A 		beq	.L447
 5674 31ec 5701008A 		bhi	.L463
 5675 31f0 020C53E3 		cmp	r3, #512
 5676 31f4 C101000A 		beq	.L445
 5677 31f8 030C53E3 		cmp	r3, #768
 5678 31fc BB01000A 		beq	.L446
 5679 3200 010C53E3 		cmp	r3, #256
 5680 3204 A7FFFF1A 		bne	.L405
 5681              	.LVL508:
3600:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5682              		.loc 1 3600 0
 5683 3208 1000A0E3 		mov	r0, #16
 5684 320c FEFFFFEB 		bl	ControlHandle
 5685              	.LVL509:
 5686 3210 28309DE5 		ldr	r3, [sp, #40]
 5687 3214 A8FFFFEA 		b	.L404
 5688              	.L585:
 5689              	.LBE125:
 5690              	.LBE119:
4084:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 5691              		.loc 1 4084 0
 5692 3218 B0C0DAE1 		ldrh	ip, [sl, #0]
 5693 321c 4C9B9FE5 		ldr	r9, .L595+32
 5694 3220 4C1B9FE5 		ldr	r1, .L595+36
 5695 3224 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 5696 3228 08C08DE5 		str	ip, [sp, #8]
 5697 322c B000DBE1 		ldrh	r0, [fp, #0]
 5698 3230 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 5699 3234 0C008DE5 		str	r0, [sp, #12]
 5700 3238 B0C0D1E1 		ldrh	ip, [r1, #0]
 5701 323c 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 5702 3240 04908DE5 		str	r9, [sp, #4]
 5703 3244 0400A0E3 		mov	r0, #4
 5704 3248 281B9FE5 		ldr	r1, .L595+40
 5705 324c 0090A0E3 		mov	r9, #0
 5706 3250 00E08DE5 		str	lr, [sp, #0]
 5707 3254 10C08DE5 		str	ip, [sp, #16]
 5708 3258 14908DE5 		str	r9, [sp, #20]
 5709 325c FEFFFFEB 		bl	CyU3PDebugPrint
 5710 3260 28309DE5 		ldr	r3, [sp, #40]
 5711 3264 75FFFFEA 		b	.L403
 5712              	.L584:
4076:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5713              		.loc 1 4076 0
 5714 3268 FEFFFFEB 		bl	CyU3PUsbGetSpeed
4077:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5715              		.loc 1 4077 0
 5716 326c 000050E3 		cmp	r0, #0
4076:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5717              		.loc 1 4076 0
 5718 3270 4800C6E5 		strb	r0, [r6, #72]
4079:../uvc.c      ****                     isUsbConnected = CyTrue;
 5719              		.loc 1 4079 0
 5720 3274 0100A013 		movne	r0, #1
 5721 3278 30008615 		strne	r0, [r6, #48]
 5722 327c 6CFFFFEA 		b	.L402
 5723              	.L469:
 5724              	.LVL510:
 5725              	.LBB132:
 5726              	.LBB114:
3697:../uvc.c      ****     switch (wValue)
 5727              		.loc 1 3697 0
 5728 3280 B020DAE1 		ldrh	r2, [sl, #0]
 5729 3284 030C52E3 		cmp	r2, #768
 5730 3288 CD00000A 		beq	.L473
 5731 328c 0F00008A 		bhi	.L476
 5732 3290 010C52E3 		cmp	r2, #256
 5733 3294 8600000A 		beq	.L471
 5734 3298 020C52E3 		cmp	r2, #512
 5735 329c 8BFFFF1A 		bne	.L470
3762:../uvc.c      ****             switch (bRequest)
 5736              		.loc 1 3762 0
 5737 32a0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5738 32a4 810053E3 		cmp	r3, #129
 5739 32a8 8301000A 		beq	.L542
 5740 32ac D100008A 		bhi	.L491
 5741 32b0 010053E3 		cmp	r3, #1
 5742 32b4 7101000A 		beq	.L590
 5743              	.L518:
3975:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5744              		.loc 1 3975 0
 5745 32b8 0000A0E3 		mov	r0, #0
 5746 32bc 0110A0E3 		mov	r1, #1
 5747 32c0 0020A0E1 		mov	r2, r0
 5748 32c4 FEFFFFEB 		bl	CyU3PUsbStall
 5749 32c8 28309DE5 		ldr	r3, [sp, #40]
 5750 32cc 84FFFFEA 		b	.L468
 5751              	.L476:
3697:../uvc.c      ****     switch (wValue)
 5752              		.loc 1 3697 0
 5753 32d0 010B52E3 		cmp	r2, #1024
 5754 32d4 6100000A 		beq	.L474
 5755 32d8 050C52E3 		cmp	r2, #1280
 5756 32dc 7BFFFF1A 		bne	.L470
3982:../uvc.c      ****             	switch (bRequest)
 5757              		.loc 1 3982 0
 5758 32e0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5759 32e4 810052E3 		cmp	r2, #129
 5760 32e8 7301000A 		beq	.L542
 5761 32ec 4401008A 		bhi	.L545
 5762 32f0 010052E3 		cmp	r2, #1
 5763 32f4 75FFFF1A 		bne	.L470
4007:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5764              		.loc 1 4007 0
 5765 32f8 2000A0E3 		mov	r0, #32
 5766 32fc 781A9FE5 		ldr	r1, .L595+44
 5767 3300 2E208DE2 		add	r2, sp, #46
 5768 3304 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5769              	.LVL511:
4009:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5770              		.loc 1 4009 0
 5771 3308 000050E3 		cmp	r0, #0
 5772 330c 5501001A 		bne	.L547
4013:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5773              		.loc 1 4013 0
 5774 3310 0020A0E3 		mov	r2, #0
 5775 3314 340A9FE5 		ldr	r0, .L595
 5776              	.LVL512:
 5777 3318 8010A0E3 		mov	r1, #128
 5778 331c FEFFFFEB 		bl	_txe_event_flags_set
 5779              	.LVL513:
4014:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5780              		.loc 1 4014 0
 5781 3320 002050E2 		subs	r2, r0, #0
4020:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5782              		.loc 1 4020 0
 5783 3324 0FC0E003 		mvneq	ip, #15
 5784 3328 3AC0C605 		streqb	ip, [r6, #58]
4014:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5785              		.loc 1 4014 0
 5786 332c 0200000A 		beq	.L549
4016:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5787              		.loc 1 4016 0
 5788 3330 481A9FE5 		ldr	r1, .L595+48
 5789 3334 0400A0E3 		mov	r0, #4
 5790              	.LVL514:
 5791 3338 FEFFFFEB 		bl	CyU3PDebugPrint
 5792              	.LVL515:
 5793              	.L549:
4023:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5794              		.loc 1 4023 0
 5795 333c C1E0D4E5 		ldrb	lr, [r4, #193]	@ zero_extendqisi2
 5796 3340 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 5797 3344 BE22DDE1 		ldrh	r2, [sp, #46]
 5798              	.LVL516:
 5799 3348 0400A0E3 		mov	r0, #4
 5800 334c 301A9FE5 		ldr	r1, .L595+52
 5801 3350 00E08DE5 		str	lr, [sp, #0]
 5802 3354 FEFFFFEB 		bl	CyU3PDebugPrint
 5803 3358 28309DE5 		ldr	r3, [sp, #40]
 5804 335c 60FFFFEA 		b	.L468
 5805              	.LVL517:
 5806              	.L588:
 5807              	.LBE114:
 5808              	.LBE132:
4197:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5809              		.loc 1 4197 0
 5810 3360 003097E5 		ldr	r3, [r7, #0]
 5811 3364 0290A0E3 		mov	r9, #2
 5812 3368 0090C3E5 		strb	r9, [r3, #0]
4198:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5813              		.loc 1 4198 0
 5814 336c 002097E5 		ldr	r2, [r7, #0]
 5815 3370 0190A0E3 		mov	r9, #1
 5816 3374 0190C2E5 		strb	r9, [r2, #1]
4199:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5817              		.loc 1 4199 0
 5818 3378 001097E5 		ldr	r1, [r7, #0]
 5819 337c 0030A0E3 		mov	r3, #0
 5820 3380 0230C1E5 		strb	r3, [r1, #2]
4200:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5821              		.loc 1 4200 0
 5822 3384 000097E5 		ldr	r0, [r7, #0]
4206:../uvc.c      **** 					interStabuf.count = 4;
 5823              		.loc 1 4206 0
 5824 3388 0420A0E3 		mov	r2, #4	@ movhi
4200:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5825              		.loc 1 4200 0
 5826 338c 0330C0E5 		strb	r3, [r0, #3]
4202:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5827              		.loc 1 4202 0
 5828 3390 00E097E5 		ldr	lr, [r7, #0]
4203:../uvc.c      **** 					interStabuf.size   = 1024;
 5829              		.loc 1 4203 0
 5830 3394 01CBA0E3 		mov	ip, #1024	@ movhi
4209:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5831              		.loc 1 4209 0
 5832 3398 0010E0E3 		mvn	r1, #0
 5833 339c C8099FE5 		ldr	r0, .L595+28
4206:../uvc.c      **** 					interStabuf.count = 4;
 5834              		.loc 1 4206 0
 5835 33a0 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
4202:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5836              		.loc 1 4202 0
 5837 33a4 18E08DE5 		str	lr, [sp, #24]
4203:../uvc.c      **** 					interStabuf.size   = 1024;
 5838              		.loc 1 4203 0
 5839 33a8 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4204:../uvc.c      **** 					interStabuf.status = 0;
 5840              		.loc 1 4204 0
 5841 33ac B032CDE1 		strh	r3, [sp, #32]	@ movhi
4209:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5842              		.loc 1 4209 0
 5843 33b0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4212:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5844              		.loc 1 4212 0
 5845 33b4 B0099FE5 		ldr	r0, .L595+28
 5846 33b8 18108DE2 		add	r1, sp, #24
 5847 33bc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5848              	.LVL518:
4214:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5849              		.loc 1 4214 0
 5850 33c0 002050E2 		subs	r2, r0, #0
 5851 33c4 D800001A 		bne	.L591
4219:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5852              		.loc 1 4219 0
 5853 33c8 3010A0E3 		mov	r1, #48
 5854 33cc 0500A0E3 		mov	r0, #5
 5855              	.LVL519:
 5856 33d0 FEFFFFEB 		bl	SensorSetControl
 5857              	.LVL520:
4221:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5858              		.loc 1 4221 0
 5859 33d4 78C99FE5 		ldr	ip, .L595+4
 5860 33d8 0B97CCE5 		strb	r9, [ip, #1803]
4346:../uvc.c      ****         CyU3PThreadRelinquish ();
 5861              		.loc 1 4346 0
 5862 33dc FEFFFFEB 		bl	_txe_thread_relinquish
 5863 33e0 07FFFFEA 		b	.L555
 5864              	.L422:
 5865              	.LBB133:
 5866              	.LBB93:
3296:../uvc.c      ****     switch (wValue)
 5867              		.loc 1 3296 0
 5868 33e4 0A0C52E3 		cmp	r2, #2560
 5869 33e8 1A01000A 		beq	.L419
 5870 33ec FA00008A 		bhi	.L424
 5871 33f0 070C52E3 		cmp	r2, #1792
 5872 33f4 1301000A 		beq	.L417
 5873 33f8 020B52E3 		cmp	r2, #2048
 5874 33fc 25FFFF1A 		bne	.L425
 5875              	.LVL521:
3327:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5876              		.loc 1 3327 0
 5877 3400 0700A0E3 		mov	r0, #7
 5878 3404 FEFFFFEB 		bl	ControlHandle
 5879              	.LVL522:
 5880 3408 28309DE5 		ldr	r3, [sp, #40]
 5881 340c 2AFFFFEA 		b	.L404
 5882              	.L437:
 5883              	.LBE93:
 5884              	.LBE133:
 5885              	.LBB134:
 5886              	.LBB102:
3371:../uvc.c      ****     switch (wValue)
 5887              		.loc 1 3371 0
 5888 3410 090C52E3 		cmp	r2, #2304
 5889 3414 A901000A 		beq	.L433
 5890 3418 D500008A 		bhi	.L439
 5891 341c 070C52E3 		cmp	r2, #1792
 5892 3420 A201000A 		beq	.L432
 5893 3424 020B52E3 		cmp	r2, #2048
 5894 3428 1AFFFF1A 		bne	.L425
 5895 342c 22FFFFEA 		b	.L404
 5896              	.L462:
 5897              	.LBE102:
 5898              	.LBE134:
 5899              	.LBB135:
 5900              	.LBB126:
3596:../uvc.c      ****     switch (wValue)
 5901              		.loc 1 3596 0
 5902 3430 0F0C53E3 		cmp	r3, #3840
 5903 3434 9901000A 		beq	.L457
 5904 3438 A100008A 		bhi	.L465
 5905 343c 0B0C53E3 		cmp	r3, #2816
 5906 3440 FC00000A 		beq	.L454
 5907 3444 9600008A 		bhi	.L466
 5908 3448 0A0C53E3 		cmp	r3, #2560
 5909 344c 15FFFF1A 		bne	.L405
 5910              	.LVL523:
3637:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5911              		.loc 1 3637 0
 5912 3450 1900A0E3 		mov	r0, #25
 5913 3454 FEFFFFEB 		bl	ControlHandle
 5914              	.LVL524:
 5915 3458 28309DE5 		ldr	r3, [sp, #40]
 5916 345c 16FFFFEA 		b	.L404
 5917              	.LVL525:
 5918              	.L474:
 5919              	.LBE126:
 5920              	.LBE135:
 5921              	.LBB136:
 5922              	.LBB112:
3896:../uvc.c      ****                 switch (bRequest)
 5923              		.loc 1 3896 0
 5924 3460 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5925 3464 810052E3 		cmp	r2, #129
 5926 3468 5A00000A 		beq	.L520
 5927 346c 2100008A 		bhi	.L523
 5928 3470 010052E3 		cmp	r2, #1
 5929 3474 8FFFFF1A 		bne	.L518
3921:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5930              		.loc 1 3921 0
 5931 3478 2000A0E3 		mov	r0, #32
 5932 347c F8189FE5 		ldr	r1, .L595+44
 5933 3480 2E208DE2 		add	r2, sp, #46
 5934 3484 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5935              	.LVL526:
3923:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5936              		.loc 1 3923 0
 5937 3488 000050E3 		cmp	r0, #0
 5938 348c 13FFFF1A 		bne	.L574
3942:../uvc.c      ****                            switch (glCommitCtrl[1])
 5939              		.loc 1 3942 0
 5940 3490 C120D6E5 		ldrb	r2, [r6, #193]	@ zero_extendqisi2
 5941 3494 011042E2 		sub	r1, r2, #1
 5942 3498 030051E3 		cmp	r1, #3
 5943 349c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5944 34a0 C90100EA 		b	.L526
 5945              	.L531:
 5946 34a4 383C0000 		.word	.L527
 5947 34a8 8C3C0000 		.word	.L528
 5948 34ac F43B0000 		.word	.L529
 5949 34b0 8C3B0000 		.word	.L530
 5950              	.LVL527:
 5951              	.L471:
3700:../uvc.c      ****             switch (bRequest)
 5952              		.loc 1 3700 0
 5953 34b4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5954 34b8 830052E3 		cmp	r2, #131
 5955 34bc 3100008A 		bhi	.L482
 5956 34c0 810052E3 		cmp	r2, #129
 5957 34c4 1600003A 		bcc	.L592
 5958              	.L479:
3715:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5959              		.loc 1 3715 0
 5960 34c8 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5961 34cc 030053E3 		cmp	r3, #3
 5962 34d0 FC00001A 		bne	.L546
3717:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5963              		.loc 1 3717 0
 5964 34d4 AC189FE5 		ldr	r1, .L595+56
 5965 34d8 1A00A0E3 		mov	r0, #26
 5966 34dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3718:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5967              		.loc 1 3718 0
 5968 34e0 0400A0E3 		mov	r0, #4
 5969 34e4 A0189FE5 		ldr	r1, .L595+60
 5970 34e8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5971 34ec FEFFFFEB 		bl	CyU3PDebugPrint
 5972 34f0 28309DE5 		ldr	r3, [sp, #40]
 5973 34f4 FAFEFFEA 		b	.L468
 5974              	.L523:
3896:../uvc.c      ****                 switch (bRequest)
 5975              		.loc 1 3896 0
 5976 34f8 850052E3 		cmp	r2, #133
 5977 34fc 2700000A 		beq	.L521
 5978 3500 860052E3 		cmp	r2, #134
 5979 3504 6BFFFF1A 		bne	.L518
 5980              	.L578:
3900:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5981              		.loc 1 3900 0
 5982 3508 0300A0E1 		mov	r0, r3
 5983              	.L573:
3766:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5984              		.loc 1 3766 0
 5985 350c 7C189FE5 		ldr	r1, .L595+64
3765:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5986              		.loc 1 3765 0
 5987 3510 0390A0E3 		mov	r9, #3
 5988 3514 5C90C4E5 		strb	r9, [r4, #92]
3766:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5989              		.loc 1 3766 0
 5990 3518 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5991 351c 28309DE5 		ldr	r3, [sp, #40]
 5992 3520 EFFEFFEA 		b	.L468
 5993              	.L592:
3700:../uvc.c      ****             switch (bRequest)
 5994              		.loc 1 3700 0
 5995 3524 010052E3 		cmp	r2, #1
 5996 3528 62FFFF1A 		bne	.L518
3727:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5997              		.loc 1 3727 0
 5998 352c 2000A0E3 		mov	r0, #32
 5999 3530 44189FE5 		ldr	r1, .L595+44
 6000 3534 2E208DE2 		add	r2, sp, #46
 6001 3538 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6002              	.LVL528:
3729:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6003              		.loc 1 3729 0
 6004 353c 000050E3 		cmp	r0, #0
 6005 3540 E6FEFF1A 		bne	.L574
3731:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6006              		.loc 1 3731 0
 6007 3544 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 6008 3548 030051E3 		cmp	r1, #3
 6009 354c E3FEFF1A 		bne	.L574
3738:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6010              		.loc 1 3738 0
 6011 3550 C530D4E5 		ldrb	r3, [r4, #197]	@ zero_extendqisi2
3735:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6012              		.loc 1 3735 0
 6013 3554 C2E0D4E5 		ldrb	lr, [r4, #194]	@ zero_extendqisi2
3736:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6014              		.loc 1 3736 0
 6015 3558 C3C0D4E5 		ldrb	ip, [r4, #195]	@ zero_extendqisi2
3737:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6016              		.loc 1 3737 0
 6017 355c C400D4E5 		ldrb	r0, [r4, #196]	@ zero_extendqisi2
 6018              	.LVL529:
3739:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6019              		.loc 1 3739 0
 6020 3560 C620D4E5 		ldrb	r2, [r4, #198]	@ zero_extendqisi2
3740:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6021              		.loc 1 3740 0
 6022 3564 C790D4E5 		ldrb	r9, [r4, #199]	@ zero_extendqisi2
3738:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6023              		.loc 1 3738 0
 6024 3568 A536C5E5 		strb	r3, [r5, #1701]
3735:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6025              		.loc 1 3735 0
 6026 356c A2E6C5E5 		strb	lr, [r5, #1698]
3736:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6027              		.loc 1 3736 0
 6028 3570 A3C6C5E5 		strb	ip, [r5, #1699]
3737:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6029              		.loc 1 3737 0
 6030 3574 A406C5E5 		strb	r0, [r5, #1700]
3739:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6031              		.loc 1 3739 0
 6032 3578 A626C5E5 		strb	r2, [r5, #1702]
3740:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6033              		.loc 1 3740 0
 6034 357c A796C5E5 		strb	r9, [r5, #1703]
 6035 3580 28309DE5 		ldr	r3, [sp, #40]
 6036 3584 D6FEFFEA 		b	.L468
 6037              	.LVL530:
 6038              	.L482:
3700:../uvc.c      ****             switch (bRequest)
 6039              		.loc 1 3700 0
 6040 3588 860052E3 		cmp	r2, #134
 6041 358c DDFFFF0A 		beq	.L578
 6042 3590 870052E3 		cmp	r2, #135
 6043 3594 CBFFFF0A 		beq	.L479
 6044              	.L583:
3846:../uvc.c      ****                 switch (bRequest)
 6045              		.loc 1 3846 0
 6046 3598 850052E3 		cmp	r2, #133
 6047 359c 45FFFF1A 		bne	.L518
 6048              	.L521:
3905:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6049              		.loc 1 3905 0
 6050 35a0 E8179FE5 		ldr	r1, .L595+64
 6051 35a4 0200A0E3 		mov	r0, #2
3903:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 6052              		.loc 1 3903 0
 6053 35a8 1A30A0E3 		mov	r3, #26
 6054              	.L575:
3990:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6055              		.loc 1 3990 0
 6056 35ac 0090A0E3 		mov	r9, #0
3989:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 6057              		.loc 1 3989 0
 6058 35b0 5C30C4E5 		strb	r3, [r4, #92]
3990:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6059              		.loc 1 3990 0
 6060 35b4 5D90C4E5 		strb	r9, [r4, #93]
3991:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6061              		.loc 1 3991 0
 6062 35b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6063 35bc 28309DE5 		ldr	r3, [sp, #40]
 6064 35c0 C7FEFFEA 		b	.L468
 6065              	.L473:
3846:../uvc.c      ****                 switch (bRequest)
 6066              		.loc 1 3846 0
 6067 35c4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6068 35c8 830052E3 		cmp	r2, #131
 6069 35cc 2F00008A 		bhi	.L514
 6070 35d0 810052E3 		cmp	r2, #129
 6071 35d4 0D00003A 		bcc	.L593
 6072              	.L520:
3908:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6073              		.loc 1 3908 0
 6074 35d8 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3910:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6075              		.loc 1 3910 0
 6076 35dc 0B00A0E3 		mov	r0, #11
3908:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6077              		.loc 1 3908 0
 6078 35e0 030053E3 		cmp	r3, #3
3910:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6079              		.loc 1 3910 0
 6080 35e4 A8179F05 		ldreq	r1, .L595+68
3914:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6081              		.loc 1 3914 0
 6082 35e8 A8179F15 		ldrne	r1, .L595+72
 6083 35ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6084 35f0 28309DE5 		ldr	r3, [sp, #40]
 6085 35f4 BAFEFFEA 		b	.L468
 6086              	.L491:
3762:../uvc.c      ****             switch (bRequest)
 6087              		.loc 1 3762 0
 6088 35f8 850053E3 		cmp	r3, #133
 6089 35fc E7FFFF0A 		beq	.L521
 6090 3600 860053E3 		cmp	r3, #134
 6091 3604 2BFFFF1A 		bne	.L518
 6092              	.L579:
3766:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6093              		.loc 1 3766 0
 6094 3608 0100A0E3 		mov	r0, #1
 6095 360c BEFFFFEA 		b	.L573
 6096              	.L593:
3846:../uvc.c      ****                 switch (bRequest)
 6097              		.loc 1 3846 0
 6098 3610 010052E3 		cmp	r2, #1
 6099 3614 27FFFF1A 		bne	.L518
3871:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6100              		.loc 1 3871 0
 6101 3618 2000A0E3 		mov	r0, #32
 6102 361c 58179FE5 		ldr	r1, .L595+44
 6103 3620 2E208DE2 		add	r2, sp, #46
 6104 3624 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6105              	.LVL531:
3873:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6106              		.loc 1 3873 0
 6107 3628 000050E3 		cmp	r0, #0
 6108 362c ABFEFF1A 		bne	.L574
3875:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 6109              		.loc 1 3875 0
 6110 3630 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 6111 3634 030051E3 		cmp	r1, #3
 6112 3638 0B00001A 		bne	.L517
3879:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6113              		.loc 1 3879 0
 6114 363c C1E0D6E5 		ldrb	lr, [r6, #193]	@ zero_extendqisi2
3880:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6115              		.loc 1 3880 0
 6116 3640 C2C0D6E5 		ldrb	ip, [r6, #194]	@ zero_extendqisi2
3881:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6117              		.loc 1 3881 0
 6118 3644 C300D6E5 		ldrb	r0, [r6, #195]	@ zero_extendqisi2
 6119              	.LVL532:
3882:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6120              		.loc 1 3882 0
 6121 3648 C420D6E5 		ldrb	r2, [r6, #196]	@ zero_extendqisi2
3883:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6122              		.loc 1 3883 0
 6123 364c C590D6E5 		ldrb	r9, [r6, #197]	@ zero_extendqisi2
3884:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6124              		.loc 1 3884 0
 6125 3650 C630D6E5 		ldrb	r3, [r6, #198]	@ zero_extendqisi2
3879:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6126              		.loc 1 3879 0
 6127 3654 F5E6C5E5 		strb	lr, [r5, #1781]
3880:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6128              		.loc 1 3880 0
 6129 3658 F6C6C5E5 		strb	ip, [r5, #1782]
3881:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6130              		.loc 1 3881 0
 6131 365c F706C5E5 		strb	r0, [r5, #1783]
3882:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6132              		.loc 1 3882 0
 6133 3660 F826C5E5 		strb	r2, [r5, #1784]
3883:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6134              		.loc 1 3883 0
 6135 3664 F996C5E5 		strb	r9, [r5, #1785]
3884:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6136              		.loc 1 3884 0
 6137 3668 FA36C5E5 		strb	r3, [r5, #1786]
 6138              	.L517:
3886:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 6139              		.loc 1 3886 0
 6140 366c C190D4E5 		ldrb	r9, [r4, #193]	@ zero_extendqisi2
 6141 3670 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6142 3674 BE22DDE1 		ldrh	r2, [sp, #46]
 6143              	.LVL533:
 6144 3678 0400A0E3 		mov	r0, #4
 6145 367c 18179FE5 		ldr	r1, .L595+76
 6146 3680 00908DE5 		str	r9, [sp, #0]
 6147 3684 FEFFFFEB 		bl	CyU3PDebugPrint
 6148 3688 28309DE5 		ldr	r3, [sp, #40]
 6149 368c 94FEFFEA 		b	.L468
 6150              	.LVL534:
 6151              	.L514:
3846:../uvc.c      ****                 switch (bRequest)
 6152              		.loc 1 3846 0
 6153 3690 860052E3 		cmp	r2, #134
 6154 3694 9BFFFF0A 		beq	.L578
 6155 3698 870052E3 		cmp	r2, #135
 6156 369c BDFFFF1A 		bne	.L583
 6157 36a0 CCFFFFEA 		b	.L520
 6158              	.LVL535:
 6159              	.L466:
 6160              	.LBE112:
 6161              	.LBE136:
 6162              	.LBB137:
 6163              	.LBB124:
3596:../uvc.c      ****     switch (wValue)
 6164              		.loc 1 3596 0
 6165 36a4 030B53E3 		cmp	r3, #3072
 6166 36a8 A401000A 		beq	.L455
 6167 36ac 0D0C53E3 		cmp	r3, #3328
 6168 36b0 7CFEFF1A 		bne	.L405
 6169              	.LVL536:
3653:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6170              		.loc 1 3653 0
 6171 36b4 1C00A0E3 		mov	r0, #28
 6172 36b8 FEFFFFEB 		bl	ControlHandle
 6173              	.LVL537:
 6174 36bc 28309DE5 		ldr	r3, [sp, #40]
 6175 36c0 7DFEFFEA 		b	.L404
 6176              	.L465:
3596:../uvc.c      ****     switch (wValue)
 6177              		.loc 1 3596 0
 6178 36c4 110C53E3 		cmp	r3, #4352
 6179 36c8 9801000A 		beq	.L459
 6180 36cc 5100008A 		bhi	.L467
 6181 36d0 010A53E3 		cmp	r3, #4096
 6182 36d4 73FEFF1A 		bne	.L405
 6183              	.LVL538:
3665:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6184              		.loc 1 3665 0
 6185 36d8 1F00A0E3 		mov	r0, #31
 6186 36dc FEFFFFEB 		bl	ControlHandle
 6187              	.LVL539:
 6188 36e0 28309DE5 		ldr	r3, [sp, #40]
 6189 36e4 74FEFFEA 		b	.L404
 6190              	.LVL540:
 6191              	.L589:
 6192              	.LBE124:
 6193              	.LBE137:
4243:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6194              		.loc 1 4243 0
 6195 36e8 0400A0E3 		mov	r0, #4
 6196              	.LVL541:
 6197 36ec AC169FE5 		ldr	r1, .L595+80
 6198 36f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6199              	.LVL542:
 6200              	.L554:
 6201              	.LBB138:
 6202              	.LBB139:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6203              		.loc 1 2005 0
 6204 36f4 A8169FE5 		ldr	r1, .L595+84
 6205 36f8 0400A0E3 		mov	r0, #4
 6206 36fc FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 6207              		.loc 1 2006 0
 6208 3700 FA0FA0E3 		mov	r0, #1000
 6209 3704 FEFFFFEB 		bl	_tx_thread_sleep
 6210 3708 F9FFFFEA 		b	.L554
 6211              	.L423:
 6212              	.LBE139:
 6213              	.LBE138:
 6214              	.LBB140:
 6215              	.LBB95:
3296:../uvc.c      ****     switch (wValue)
 6216              		.loc 1 3296 0
 6217 370c 010B52E3 		cmp	r2, #1024
 6218 3710 69FEFF0A 		beq	.L404
 6219 3714 050C52E3 		cmp	r2, #1280
 6220 3718 5EFEFF1A 		bne	.L425
 6221              	.LVL543:
3315:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6222              		.loc 1 3315 0
 6223 371c 0400A0E3 		mov	r0, #4
 6224 3720 FEFFFFEB 		bl	ControlHandle
 6225              	.LVL544:
 6226 3724 28309DE5 		ldr	r3, [sp, #40]
 6227 3728 63FEFFEA 		b	.L404
 6228              	.LVL545:
 6229              	.L591:
 6230              	.LBE95:
 6231              	.LBE140:
4216:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6232              		.loc 1 4216 0
 6233 372c 0400A0E3 		mov	r0, #4
 6234              	.LVL546:
 6235 3730 68169FE5 		ldr	r1, .L595+80
 6236 3734 FEFFFFEB 		bl	CyU3PDebugPrint
 6237              	.LVL547:
 6238              	.L552:
 6239              	.LBB141:
 6240              	.LBB142:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6241              		.loc 1 2005 0
 6242 3738 64169FE5 		ldr	r1, .L595+84
 6243 373c 0400A0E3 		mov	r0, #4
 6244 3740 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 6245              		.loc 1 2006 0
 6246 3744 FA0FA0E3 		mov	r0, #1000
 6247 3748 FEFFFFEB 		bl	_tx_thread_sleep
 6248 374c F9FFFFEA 		b	.L552
 6249              	.L463:
 6250              	.LBE142:
 6251              	.LBE141:
 6252              	.LBB143:
 6253              	.LBB127:
3596:../uvc.c      ****     switch (wValue)
 6254              		.loc 1 3596 0
 6255 3750 060C53E3 		cmp	r3, #1536
 6256 3754 7101000A 		beq	.L449
 6257 3758 0F00008A 		bhi	.L464
 6258 375c 050C53E3 		cmp	r3, #1280
 6259 3760 50FEFF1A 		bne	.L405
 6260              	.LVL548:
3616:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6261              		.loc 1 3616 0
 6262 3764 1400A0E3 		mov	r0, #20
 6263 3768 FEFFFFEB 		bl	ControlHandle
 6264              	.LVL549:
 6265 376c 28309DE5 		ldr	r3, [sp, #40]
 6266 3770 51FEFFEA 		b	.L404
 6267              	.L439:
 6268              	.LBE127:
 6269              	.LBE143:
 6270              	.LBB144:
 6271              	.LBB105:
3371:../uvc.c      ****     switch (wValue)
 6272              		.loc 1 3371 0
 6273 3774 0B0C52E3 		cmp	r2, #2816
 6274 3778 6401000A 		beq	.L435
 6275 377c 030B52E3 		cmp	r2, #3072
 6276 3780 5E01000A 		beq	.L436
 6277 3784 0A0C52E3 		cmp	r2, #2560
 6278 3788 42FEFF1A 		bne	.L425
 6279              	.LVL550:
3412:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6280              		.loc 1 3412 0
 6281 378c 0800A0E3 		mov	r0, #8
 6282 3790 FEFFFFEB 		bl	CTControlHandle
 6283              	.LVL551:
 6284 3794 28309DE5 		ldr	r3, [sp, #40]
 6285 3798 47FEFFEA 		b	.L404
 6286              	.L464:
 6287              	.LBE105:
 6288              	.LBE144:
 6289              	.LBB145:
 6290              	.LBB123:
3596:../uvc.c      ****     switch (wValue)
 6291              		.loc 1 3596 0
 6292 379c 070C53E3 		cmp	r3, #1792
 6293 37a0 5201000A 		beq	.L450
 6294 37a4 020B53E3 		cmp	r3, #2048
 6295 37a8 3EFEFF1A 		bne	.L405
 6296              	.LVL552:
3628:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6297              		.loc 1 3628 0
 6298 37ac 1700A0E3 		mov	r0, #23
 6299 37b0 FEFFFFEB 		bl	ControlHandle
 6300              	.LVL553:
 6301 37b4 28309DE5 		ldr	r3, [sp, #40]
 6302 37b8 3FFEFFEA 		b	.L404
 6303              	.L438:
 6304              	.LBE123:
 6305              	.LBE145:
 6306              	.LBB146:
 6307              	.LBB101:
3371:../uvc.c      ****     switch (wValue)
 6308              		.loc 1 3371 0
 6309 37bc 010B52E3 		cmp	r2, #1024
 6310 37c0 4601000A 		beq	.L429
 6311 37c4 050C52E3 		cmp	r2, #1280
 6312 37c8 32FEFF1A 		bne	.L425
 6313              	.LVL554:
3393:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6314              		.loc 1 3393 0
 6315 37cc 0400A0E3 		mov	r0, #4
 6316 37d0 FEFFFFEB 		bl	CTControlHandle
 6317              	.LVL555:
 6318 37d4 28309DE5 		ldr	r3, [sp, #40]
 6319 37d8 37FEFFEA 		b	.L404
 6320              	.L424:
 6321              	.LBE101:
 6322              	.LBE146:
 6323              	.LBB147:
 6324              	.LBB92:
3296:../uvc.c      ****     switch (wValue)
 6325              		.loc 1 3296 0
 6326 37dc 0D0C52E3 		cmp	r2, #3328
 6327 37e0 1C00000A 		beq	.L419
 6328 37e4 0E0C52E3 		cmp	r2, #3584
 6329 37e8 D700000A 		beq	.L421
 6330 37ec 030B52E3 		cmp	r2, #3072
 6331 37f0 28FEFF1A 		bne	.L425
 6332              	.LVL556:
3337:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6333              		.loc 1 3337 0
 6334 37f4 0B00A0E3 		mov	r0, #11
 6335 37f8 FEFFFFEB 		bl	ControlHandle
 6336              	.LVL557:
 6337 37fc 28309DE5 		ldr	r3, [sp, #40]
 6338 3800 2DFEFFEA 		b	.L404
 6339              	.LVL558:
 6340              	.L545:
 6341              	.LBE92:
 6342              	.LBE147:
 6343              	.LBB148:
 6344              	.LBB115:
3982:../uvc.c      ****             	switch (bRequest)
 6345              		.loc 1 3982 0
 6346 3804 850052E3 		cmp	r2, #133
 6347 3808 CC00000A 		beq	.L543
 6348 380c 860052E3 		cmp	r2, #134
 6349 3810 2EFEFF1A 		bne	.L470
 6350 3814 7BFFFFEA 		b	.L579
 6351              	.LVL559:
 6352              	.L467:
 6353              	.LBE115:
 6354              	.LBE148:
 6355              	.LBB149:
 6356              	.LBB128:
3596:../uvc.c      ****     switch (wValue)
 6357              		.loc 1 3596 0
 6358 3818 120C53E3 		cmp	r3, #4608
 6359 381c C300000A 		beq	.L460
 6360 3820 130C53E3 		cmp	r3, #4864
 6361 3824 1FFEFF1A 		bne	.L405
 6362              	.LVL560:
3677:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6363              		.loc 1 3677 0
 6364 3828 2600A0E3 		mov	r0, #38
 6365 382c FEFFFFEB 		bl	ControlHandle
 6366              	.LVL561:
 6367 3830 28309DE5 		ldr	r3, [sp, #40]
 6368 3834 20FEFFEA 		b	.L404
 6369              	.L454:
 6370              	.LVL562:
3643:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 6371              		.loc 1 3643 0
 6372 3838 1A00A0E3 		mov	r0, #26
 6373 383c FEFFFFEB 		bl	ControlHandle
 6374              	.LVL563:
 6375 3840 28309DE5 		ldr	r3, [sp, #40]
 6376 3844 1CFEFFEA 		b	.L404
 6377              	.L417:
 6378              	.LVL564:
 6379              	.LBE128:
 6380              	.LBE149:
 6381              	.LBB150:
 6382              	.LBB96:
3323:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 6383              		.loc 1 3323 0
 6384 3848 0600A0E3 		mov	r0, #6
 6385 384c FEFFFFEB 		bl	ControlHandle
 6386              	.LVL565:
 6387 3850 28309DE5 		ldr	r3, [sp, #40]
 6388 3854 18FEFFEA 		b	.L404
 6389              	.L419:
 6390              	.LVL566:
3333:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 6391              		.loc 1 3333 0
 6392 3858 0900A0E3 		mov	r0, #9
 6393 385c FEFFFFEB 		bl	ControlHandle
 6394              	.LVL567:
 6395 3860 28309DE5 		ldr	r3, [sp, #40]
 6396 3864 14FEFFEA 		b	.L404
 6397              	.LVL568:
 6398              	.L547:
 6399              	.LBE96:
 6400              	.LBE150:
 6401              	.LBB151:
 6402              	.LBB111:
4025:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6403              		.loc 1 4025 0
 6404 3868 38159FE5 		ldr	r1, .L595+88
 6405 386c BE22DDE1 		ldrh	r2, [sp, #46]
 6406 3870 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6407 3874 0400A0E3 		mov	r0, #4
 6408              	.LVL569:
 6409 3878 FEFFFFEB 		bl	CyU3PDebugPrint
 6410 387c 13FEFFEA 		b	.L470
 6411              	.LVL570:
 6412              	.L590:
3787:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6413              		.loc 1 3787 0
 6414 3880 2000A0E3 		mov	r0, #32
 6415 3884 F0149FE5 		ldr	r1, .L595+44
 6416 3888 2E208DE2 		add	r2, sp, #46
 6417 388c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6418              	.LVL571:
3789:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6419              		.loc 1 3789 0
 6420 3890 000050E3 		cmp	r0, #0
 6421 3894 11FEFF1A 		bne	.L574
3791:../uvc.c      ****                         switch (glCommitCtrl[3])
 6422              		.loc 1 3791 0
 6423 3898 C320D4E5 		ldrb	r2, [r4, #195]	@ zero_extendqisi2
 6424 389c 011042E2 		sub	r1, r2, #1
 6425 38a0 030051E3 		cmp	r1, #3
 6426 38a4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6427 38a8 2E0000EA 		b	.L494
 6428              	.L499:
 6429 38ac 083A0000 		.word	.L495
 6430 38b0 543A0000 		.word	.L496
 6431 38b4 AC390000 		.word	.L497
 6432 38b8 10390000 		.word	.L498
 6433              	.LVL572:
 6434              	.L542:
3994:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6435              		.loc 1 3994 0
 6436 38bc 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 6437 38c0 030051E3 		cmp	r1, #3
 6438 38c4 0400000A 		beq	.L594
 6439              	.L546:
4000:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6440              		.loc 1 4000 0
 6441 38c8 1A00A0E3 		mov	r0, #26
 6442 38cc D8149FE5 		ldr	r1, .L595+92
 6443 38d0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6444 38d4 28309DE5 		ldr	r3, [sp, #40]
 6445 38d8 01FEFFEA 		b	.L468
 6446              	.L594:
3996:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6447              		.loc 1 3996 0
 6448 38dc 1A00A0E3 		mov	r0, #26
 6449 38e0 C8149FE5 		ldr	r1, .L595+96
 6450 38e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6451 38e8 28309DE5 		ldr	r3, [sp, #40]
 6452 38ec FCFDFFEA 		b	.L468
 6453              	.LVL573:
 6454              	.L446:
 6455              	.LBE111:
 6456              	.LBE151:
 6457              	.LBB152:
 6458              	.LBB122:
3608:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 6459              		.loc 1 3608 0
 6460 38f0 1200A0E3 		mov	r0, #18
 6461 38f4 FEFFFFEB 		bl	ControlHandle
 6462              	.LVL574:
 6463 38f8 28309DE5 		ldr	r3, [sp, #40]
 6464 38fc EEFDFFEA 		b	.L404
 6465              	.L445:
 6466              	.LVL575:
3604:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 6467              		.loc 1 3604 0
 6468 3900 1100A0E3 		mov	r0, #17
 6469 3904 FEFFFFEB 		bl	ControlHandle
 6470              	.LVL576:
 6471 3908 28309DE5 		ldr	r3, [sp, #40]
 6472 390c EAFDFFEA 		b	.L404
 6473              	.LVL577:
 6474              	.L498:
 6475              	.LBE122:
 6476              	.LBE152:
 6477              	.LBB153:
 6478              	.LBB116:
3809:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6479              		.loc 1 3809 0
 6480 3910 58C094E5 		ldr	ip, [r4, #88]
 6481 3914 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 6482              	.LVL578:
 6483 3918 00005CE3 		cmp	ip, #0
 6484 391c F4C0A003 		moveq	ip, #244
 6485 3920 74C0A013 		movne	ip, #116
 6486 3924 00208CE1 		orr	r2, ip, r0
 6487 3928 3010A0E3 		mov	r1, #48
 6488 392c 5230A0E3 		mov	r3, #82
 6489 3930 0100A0E3 		mov	r0, #1
 6490 3934 FEFFFFEB 		bl	SensorSetIrisControl
3810:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6491              		.loc 1 3810 0
 6492 3938 7D0FA0E3 		mov	r0, #500
 6493 393c FEFFFFEB 		bl	_tx_thread_sleep
3811:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6494              		.loc 1 3811 0
 6495 3940 582094E5 		ldr	r2, [r4, #88]
 6496 3944 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6497 3948 000052E3 		cmp	r2, #0
 6498 394c F420A003 		moveq	r2, #244
 6499 3950 7420A013 		movne	r2, #116
 6500 3954 583094E5 		ldr	r3, [r4, #88]
 6501 3958 0400A0E3 		mov	r0, #4
 6502 395c 50149FE5 		ldr	r1, .L595+100
 6503 3960 092082E1 		orr	r2, r2, r9
 6504 3964 FEFFFFEB 		bl	CyU3PDebugPrint
 6505              	.L494:
3816:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6506              		.loc 1 3816 0
 6507 3968 C3E0D4E5 		ldrb	lr, [r4, #195]	@ zero_extendqisi2
3817:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6508              		.loc 1 3817 0
 6509 396c 44149FE5 		ldr	r1, .L595+104
 6510 3970 0E20A0E1 		mov	r2, lr
 6511 3974 0400A0E3 		mov	r0, #4
3816:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6512              		.loc 1 3816 0
 6513 3978 BDE0C4E5 		strb	lr, [r4, #189]
3817:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6514              		.loc 1 3817 0
 6515 397c FEFFFFEB 		bl	CyU3PDebugPrint
3830:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6516              		.loc 1 3830 0
 6517 3980 0020A0E3 		mov	r2, #0
 6518 3984 C4039FE5 		ldr	r0, .L595
 6519 3988 0110A0E3 		mov	r1, #1
 6520 398c FEFFFFEB 		bl	_txe_event_flags_set
 6521              	.LVL579:
3831:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6522              		.loc 1 3831 0
 6523 3990 002050E2 		subs	r2, r0, #0
 6524 3994 D1FDFF0A 		beq	.L574
3833:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6525              		.loc 1 3833 0
 6526 3998 0400A0E3 		mov	r0, #4
 6527              	.LVL580:
 6528 399c 18149FE5 		ldr	r1, .L595+108
 6529 39a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6530              	.LVL581:
 6531 39a4 28309DE5 		ldr	r3, [sp, #40]
 6532 39a8 CDFDFFEA 		b	.L468
 6533              	.LVL582:
 6534              	.L497:
3804:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6535              		.loc 1 3804 0
 6536 39ac 58E094E5 		ldr	lr, [r4, #88]
 6537 39b0 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6538 39b4 00005EE3 		cmp	lr, #0
 6539 39b8 C4E0A003 		moveq	lr, #196
 6540 39bc 44E0A013 		movne	lr, #68
 6541 39c0 03208EE1 		orr	r2, lr, r3
 6542 39c4 3010A0E3 		mov	r1, #48
 6543 39c8 5230A0E3 		mov	r3, #82
 6544 39cc 0100A0E3 		mov	r0, #1
 6545              	.LVL583:
 6546 39d0 FEFFFFEB 		bl	SensorSetIrisControl
3805:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6547              		.loc 1 3805 0
 6548 39d4 7D0FA0E3 		mov	r0, #500
 6549 39d8 FEFFFFEB 		bl	_tx_thread_sleep
3806:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6550              		.loc 1 3806 0
 6551 39dc 580094E5 		ldr	r0, [r4, #88]
 6552 39e0 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6553 39e4 000050E3 		cmp	r0, #0
 6554 39e8 C400A003 		moveq	r0, #196
 6555 39ec 4400A013 		movne	r0, #68
 6556 39f0 0C2080E1 		orr	r2, r0, ip
 6557 39f4 583094E5 		ldr	r3, [r4, #88]
 6558 39f8 B4139FE5 		ldr	r1, .L595+100
 6559 39fc 0400A0E3 		mov	r0, #4
 6560 3a00 FEFFFFEB 		bl	CyU3PDebugPrint
 6561 3a04 D7FFFFEA 		b	.L494
 6562              	.LVL584:
 6563              	.L495:
3794:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6564              		.loc 1 3794 0
 6565 3a08 582094E5 		ldr	r2, [r4, #88]
 6566 3a0c 3010A0E3 		mov	r1, #48
 6567 3a10 000052E3 		cmp	r2, #0
 6568 3a14 E420A003 		moveq	r2, #228
 6569 3a18 6420A013 		movne	r2, #100
 6570 3a1c 5230A0E3 		mov	r3, #82
 6571 3a20 0100A0E3 		mov	r0, #1
 6572              	.LVL585:
 6573 3a24 FEFFFFEB 		bl	SensorSetIrisControl
3795:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6574              		.loc 1 3795 0
 6575 3a28 7D0FA0E3 		mov	r0, #500
 6576 3a2c FEFFFFEB 		bl	_tx_thread_sleep
3796:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6577              		.loc 1 3796 0
 6578 3a30 582094E5 		ldr	r2, [r4, #88]
 6579 3a34 78139FE5 		ldr	r1, .L595+100
 6580 3a38 000052E3 		cmp	r2, #0
 6581 3a3c 583094E5 		ldr	r3, [r4, #88]
 6582 3a40 E420A003 		moveq	r2, #228
 6583 3a44 6420A013 		movne	r2, #100
 6584 3a48 0400A0E3 		mov	r0, #4
 6585 3a4c FEFFFFEB 		bl	CyU3PDebugPrint
 6586 3a50 C4FFFFEA 		b	.L494
 6587              	.LVL586:
 6588              	.L496:
3799:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6589              		.loc 1 3799 0
 6590 3a54 582094E5 		ldr	r2, [r4, #88]
 6591 3a58 3010A0E3 		mov	r1, #48
 6592 3a5c 000052E3 		cmp	r2, #0
 6593 3a60 D420A003 		moveq	r2, #212
 6594 3a64 5420A013 		movne	r2, #84
 6595 3a68 5230A0E3 		mov	r3, #82
 6596 3a6c 0100A0E3 		mov	r0, #1
 6597              	.LVL587:
 6598 3a70 FEFFFFEB 		bl	SensorSetIrisControl
3800:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6599              		.loc 1 3800 0
 6600 3a74 7D0FA0E3 		mov	r0, #500
 6601 3a78 FEFFFFEB 		bl	_tx_thread_sleep
3801:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6602              		.loc 1 3801 0
 6603 3a7c 582094E5 		ldr	r2, [r4, #88]
 6604 3a80 2C139FE5 		ldr	r1, .L595+100
 6605 3a84 000052E3 		cmp	r2, #0
 6606 3a88 583094E5 		ldr	r3, [r4, #88]
 6607 3a8c D420A003 		moveq	r2, #212
 6608 3a90 5420A013 		movne	r2, #84
 6609 3a94 0400A0E3 		mov	r0, #4
 6610 3a98 FEFFFFEB 		bl	CyU3PDebugPrint
 6611 3a9c B1FFFFEA 		b	.L494
 6612              	.L457:
 6613              	.LVL588:
 6614              	.LBE116:
 6615              	.LBE153:
 6616              	.LBB154:
 6617              	.LBB129:
3661:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 6618              		.loc 1 3661 0
 6619 3aa0 1E00A0E3 		mov	r0, #30
 6620 3aa4 FEFFFFEB 		bl	ControlHandle
 6621              	.LVL589:
 6622 3aa8 28309DE5 		ldr	r3, [sp, #40]
 6623 3aac 82FDFFEA 		b	.L404
 6624              	.L432:
 6625              	.LVL590:
 6626              	.LBE129:
 6627              	.LBE154:
 6628              	.LBB155:
 6629              	.LBB106:
3401:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 6630              		.loc 1 3401 0
 6631 3ab0 0600A0E3 		mov	r0, #6
 6632 3ab4 FEFFFFEB 		bl	CTControlHandle
 6633              	.LVL591:
 6634 3ab8 28309DE5 		ldr	r3, [sp, #40]
 6635 3abc 7EFDFFEA 		b	.L404
 6636              	.L433:
 6637              	.LVL592:
3407:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 6638              		.loc 1 3407 0
 6639 3ac0 0700A0E3 		mov	r0, #7
 6640 3ac4 FEFFFFEB 		bl	CTControlHandle
 6641              	.LVL593:
 6642 3ac8 28309DE5 		ldr	r3, [sp, #40]
 6643 3acc 7AFDFFEA 		b	.L404
 6644              	.L414:
 6645              	.LVL594:
 6646              	.LBE106:
 6647              	.LBE155:
 6648              	.LBB156:
 6649              	.LBB91:
3308:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 6650              		.loc 1 3308 0
 6651 3ad0 0200A0E3 		mov	r0, #2
 6652 3ad4 FEFFFFEB 		bl	ControlHandle
 6653              	.LVL595:
 6654 3ad8 28309DE5 		ldr	r3, [sp, #40]
 6655 3adc 76FDFFEA 		b	.L404
 6656              	.L416:
 6657              	.LVL596:
3319:../uvc.c      ****      		ControlHandle(HueCtlID5);
 6658              		.loc 1 3319 0
 6659 3ae0 0500A0E3 		mov	r0, #5
 6660 3ae4 FEFFFFEB 		bl	ControlHandle
 6661              	.LVL597:
 6662 3ae8 28309DE5 		ldr	r3, [sp, #40]
 6663 3aec 72FDFFEA 		b	.L404
 6664              	.L447:
 6665              	.LVL598:
 6666              	.LBE91:
 6667              	.LBE156:
 6668              	.LBB157:
 6669              	.LBB121:
3612:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6670              		.loc 1 3612 0
 6671 3af0 1300A0E3 		mov	r0, #19
 6672 3af4 FEFFFFEB 		bl	ControlHandle
 6673              	.LVL599:
 6674 3af8 28309DE5 		ldr	r3, [sp, #40]
 6675 3afc 6EFDFFEA 		b	.L404
 6676              	.L452:
 6677              	.LVL600:
3632:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6678              		.loc 1 3632 0
 6679 3b00 1800A0E3 		mov	r0, #24
 6680 3b04 FEFFFFEB 		bl	ControlHandle
 6681              	.LVL601:
 6682 3b08 28309DE5 		ldr	r3, [sp, #40]
 6683 3b0c 6AFDFFEA 		b	.L404
 6684              	.L426:
 6685              	.LVL602:
 6686              	.LBE121:
 6687              	.LBE157:
 6688              	.LBB158:
 6689              	.LBB100:
3375:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6690              		.loc 1 3375 0
 6691 3b10 0000A0E3 		mov	r0, #0
 6692 3b14 FEFFFFEB 		bl	CTControlHandle
 6693              	.LVL603:
 6694 3b18 28309DE5 		ldr	r3, [sp, #40]
 6695 3b1c 66FDFFEA 		b	.L404
 6696              	.L428:
 6697              	.LVL604:
3383:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6698              		.loc 1 3383 0
 6699 3b20 0200A0E3 		mov	r0, #2
 6700 3b24 FEFFFFEB 		bl	CTControlHandle
 6701              	.LVL605:
 6702 3b28 28309DE5 		ldr	r3, [sp, #40]
 6703 3b2c 62FDFFEA 		b	.L404
 6704              	.L460:
 6705              	.LVL606:
 6706              	.LBE100:
 6707              	.LBE158:
 6708              	.LBB159:
 6709              	.LBB130:
3673:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6710              		.loc 1 3673 0
 6711 3b30 2500A0E3 		mov	r0, #37
 6712 3b34 FEFFFFEB 		bl	ControlHandle
 6713              	.LVL607:
 6714 3b38 28309DE5 		ldr	r3, [sp, #40]
 6715 3b3c 5EFDFFEA 		b	.L404
 6716              	.LVL608:
 6717              	.L543:
 6718              	.LBE130:
 6719              	.LBE159:
 6720              	.LBB160:
 6721              	.LBB110:
3991:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6722              		.loc 1 3991 0
 6723 3b40 0200A0E3 		mov	r0, #2
 6724 3b44 44129FE5 		ldr	r1, .L595+64
 6725 3b48 97FEFFEA 		b	.L575
 6726              	.LVL609:
 6727              	.L421:
 6728              	.LBE110:
 6729              	.LBE160:
 6730              	.LBB161:
 6731              	.LBB97:
3341:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6732              		.loc 1 3341 0
 6733 3b4c 0E00A0E3 		mov	r0, #14
 6734 3b50 FEFFFFEB 		bl	ControlHandle
 6735              	.LVL610:
 6736 3b54 28309DE5 		ldr	r3, [sp, #40]
 6737 3b58 57FDFFEA 		b	.L404
 6738              	.L586:
 6739              	.LVL611:
3304:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6740              		.loc 1 3304 0
 6741 3b5c 0100A0E3 		mov	r0, #1
 6742 3b60 FEFFFFEB 		bl	ControlHandle
 6743              	.LVL612:
 6744 3b64 28309DE5 		ldr	r3, [sp, #40]
 6745 3b68 53FDFFEA 		b	.L404
 6746              	.L412:
 6747              	.LVL613:
3300:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6748              		.loc 1 3300 0
 6749 3b6c 0000A0E3 		mov	r0, #0
 6750 3b70 FEFFFFEB 		bl	ControlHandle
 6751              	.LVL614:
 6752 3b74 28309DE5 		ldr	r3, [sp, #40]
 6753 3b78 4FFDFFEA 		b	.L404
 6754              	.L431:
 6755              	.LVL615:
 6756              	.LBE97:
 6757              	.LBE161:
 6758              	.LBB162:
 6759              	.LBB107:
3397:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6760              		.loc 1 3397 0
 6761 3b7c 0500A0E3 		mov	r0, #5
 6762 3b80 FEFFFFEB 		bl	CTControlHandle
 6763              	.LVL616:
 6764 3b84 28309DE5 		ldr	r3, [sp, #40]
 6765 3b88 4BFDFFEA 		b	.L404
 6766              	.LVL617:
 6767              	.L530:
 6768              	.LBE107:
 6769              	.LBE162:
 6770              	.LBB163:
 6771              	.LBB117:
3945:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6772              		.loc 1 3945 0
 6773 3b8c 582094E5 		ldr	r2, [r4, #88]
 6774 3b90 3010A0E3 		mov	r1, #48
 6775 3b94 000052E3 		cmp	r2, #0
 6776 3b98 E420A003 		moveq	r2, #228
 6777 3b9c 6420A013 		movne	r2, #100
 6778 3ba0 5230A0E3 		mov	r3, #82
 6779 3ba4 0100A0E3 		mov	r0, #1
 6780              	.LVL618:
 6781 3ba8 FEFFFFEB 		bl	SensorSetIrisControl
3947:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6782              		.loc 1 3947 0
 6783 3bac 582094E5 		ldr	r2, [r4, #88]
 6784 3bb0 08129FE5 		ldr	r1, .L595+112
 6785 3bb4 000052E3 		cmp	r2, #0
 6786 3bb8 583094E5 		ldr	r3, [r4, #88]
 6787 3bbc E420A003 		moveq	r2, #228
 6788 3bc0 6420A013 		movne	r2, #100
 6789 3bc4 0400A0E3 		mov	r0, #4
 6790 3bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 6791              	.L526:
3967:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6792              		.loc 1 3967 0
 6793 3bcc C1E0D4E5 		ldrb	lr, [r4, #193]	@ zero_extendqisi2
3969:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6794              		.loc 1 3969 0
 6795 3bd0 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6796 3bd4 BE22DDE1 		ldrh	r2, [sp, #46]
 6797              	.LVL619:
 6798 3bd8 0400A0E3 		mov	r0, #4
 6799 3bdc E0119FE5 		ldr	r1, .L595+116
3967:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6800              		.loc 1 3967 0
 6801 3be0 E0E0C4E5 		strb	lr, [r4, #224]
3969:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6802              		.loc 1 3969 0
 6803 3be4 00E08DE5 		str	lr, [sp, #0]
 6804 3be8 FEFFFFEB 		bl	CyU3PDebugPrint
 6805 3bec 28309DE5 		ldr	r3, [sp, #40]
 6806 3bf0 3BFDFFEA 		b	.L468
 6807              	.LVL620:
 6808              	.L529:
3950:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6809              		.loc 1 3950 0
 6810 3bf4 582094E5 		ldr	r2, [r4, #88]
 6811 3bf8 3010A0E3 		mov	r1, #48
 6812 3bfc 000052E3 		cmp	r2, #0
 6813 3c00 D420A003 		moveq	r2, #212
 6814 3c04 5420A013 		movne	r2, #84
 6815 3c08 5230A0E3 		mov	r3, #82
 6816 3c0c 0100A0E3 		mov	r0, #1
 6817              	.LVL621:
 6818 3c10 FEFFFFEB 		bl	SensorSetIrisControl
3952:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6819              		.loc 1 3952 0
 6820 3c14 582094E5 		ldr	r2, [r4, #88]
 6821 3c18 A0119FE5 		ldr	r1, .L595+112
 6822 3c1c 000052E3 		cmp	r2, #0
 6823 3c20 583094E5 		ldr	r3, [r4, #88]
 6824 3c24 D420A003 		moveq	r2, #212
 6825 3c28 5420A013 		movne	r2, #84
 6826 3c2c 0400A0E3 		mov	r0, #4
 6827 3c30 FEFFFFEB 		bl	CyU3PDebugPrint
 6828 3c34 E4FFFFEA 		b	.L526
 6829              	.LVL622:
 6830              	.L527:
3960:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6831              		.loc 1 3960 0
 6832 3c38 580094E5 		ldr	r0, [r4, #88]
 6833              	.LVL623:
 6834 3c3c 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6835 3c40 000050E3 		cmp	r0, #0
 6836 3c44 F400A003 		moveq	r0, #244
 6837 3c48 7400A013 		movne	r0, #116
 6838 3c4c 032080E1 		orr	r2, r0, r3
 6839 3c50 3010A0E3 		mov	r1, #48
 6840 3c54 5230A0E3 		mov	r3, #82
 6841 3c58 0100A0E3 		mov	r0, #1
 6842 3c5c FEFFFFEB 		bl	SensorSetIrisControl
3962:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6843              		.loc 1 3962 0
 6844 3c60 58C094E5 		ldr	ip, [r4, #88]
 6845 3c64 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6846 3c68 00005CE3 		cmp	ip, #0
 6847 3c6c F4C0A003 		moveq	ip, #244
 6848 3c70 74C0A013 		movne	ip, #116
 6849 3c74 583094E5 		ldr	r3, [r4, #88]
 6850 3c78 40119FE5 		ldr	r1, .L595+112
 6851 3c7c 02208CE1 		orr	r2, ip, r2
 6852 3c80 0400A0E3 		mov	r0, #4
 6853 3c84 FEFFFFEB 		bl	CyU3PDebugPrint
 6854 3c88 CFFFFFEA 		b	.L526
 6855              	.LVL624:
 6856              	.L528:
3955:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6857              		.loc 1 3955 0
 6858 3c8c 58E094E5 		ldr	lr, [r4, #88]
 6859 3c90 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6860 3c94 00005EE3 		cmp	lr, #0
 6861 3c98 C4E0A003 		moveq	lr, #196
 6862 3c9c 44E0A013 		movne	lr, #68
 6863 3ca0 09208EE1 		orr	r2, lr, r9
 6864 3ca4 3010A0E3 		mov	r1, #48
 6865 3ca8 5230A0E3 		mov	r3, #82
 6866 3cac 0100A0E3 		mov	r0, #1
 6867              	.LVL625:
 6868 3cb0 FEFFFFEB 		bl	SensorSetIrisControl
3957:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6869              		.loc 1 3957 0
 6870 3cb4 580094E5 		ldr	r0, [r4, #88]
 6871 3cb8 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6872 3cbc 000050E3 		cmp	r0, #0
 6873 3cc0 C400A003 		moveq	r0, #196
 6874 3cc4 4400A013 		movne	r0, #68
 6875 3cc8 0C2080E1 		orr	r2, r0, ip
 6876 3ccc 583094E5 		ldr	r3, [r4, #88]
 6877 3cd0 E8109FE5 		ldr	r1, .L595+112
 6878 3cd4 0400A0E3 		mov	r0, #4
 6879 3cd8 FEFFFFEB 		bl	CyU3PDebugPrint
 6880 3cdc BAFFFFEA 		b	.L526
 6881              	.L429:
 6882              	.LVL626:
 6883              	.LBE117:
 6884              	.LBE163:
 6885              	.LBB164:
 6886              	.LBB99:
3388:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 6887              		.loc 1 3388 0
 6888 3ce0 0300A0E3 		mov	r0, #3
 6889 3ce4 FEFFFFEB 		bl	CTControlHandle
 6890              	.LVL627:
 6891 3ce8 28309DE5 		ldr	r3, [sp, #40]
 6892 3cec F2FCFFEA 		b	.L404
 6893              	.L450:
 6894              	.LVL628:
 6895              	.LBE99:
 6896              	.LBE164:
 6897              	.LBB165:
 6898              	.LBB120:
3624:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 6899              		.loc 1 3624 0
 6900 3cf0 1600A0E3 		mov	r0, #22
 6901 3cf4 FEFFFFEB 		bl	ControlHandle
 6902              	.LVL629:
 6903 3cf8 28309DE5 		ldr	r3, [sp, #40]
 6904 3cfc EEFCFFEA 		b	.L404
 6905              	.L436:
 6906              	.LVL630:
 6907              	.LBE120:
 6908              	.LBE165:
 6909              	.LBB166:
 6910              	.LBB108:
3420:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 6911              		.loc 1 3420 0
 6912 3d00 0A00A0E3 		mov	r0, #10
 6913 3d04 FEFFFFEB 		bl	CTControlHandle
 6914              	.LVL631:
 6915 3d08 28309DE5 		ldr	r3, [sp, #40]
 6916 3d0c EAFCFFEA 		b	.L404
 6917              	.L435:
 6918              	.LVL632:
3416:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 6919              		.loc 1 3416 0
 6920 3d10 0900A0E3 		mov	r0, #9
 6921 3d14 FEFFFFEB 		bl	CTControlHandle
 6922              	.LVL633:
 6923 3d18 28309DE5 		ldr	r3, [sp, #40]
 6924 3d1c E6FCFFEA 		b	.L404
 6925              	.L449:
 6926              	.LVL634:
 6927              	.LBE108:
 6928              	.LBE166:
 6929              	.LBB167:
 6930              	.LBB131:
3620:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 6931              		.loc 1 3620 0
 6932 3d20 1500A0E3 		mov	r0, #21
 6933 3d24 FEFFFFEB 		bl	ControlHandle
 6934              	.LVL635:
 6935 3d28 28309DE5 		ldr	r3, [sp, #40]
 6936 3d2c E2FCFFEA 		b	.L404
 6937              	.L459:
 6938              	.LVL636:
3669:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 6939              		.loc 1 3669 0
 6940 3d30 2400A0E3 		mov	r0, #36
 6941 3d34 FEFFFFEB 		bl	ControlHandle
 6942              	.LVL637:
 6943 3d38 28309DE5 		ldr	r3, [sp, #40]
 6944 3d3c DEFCFFEA 		b	.L404
 6945              	.L455:
 6946              	.LVL638:
3647:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6947              		.loc 1 3647 0
 6948 3d40 1B00A0E3 		mov	r0, #27
 6949 3d44 FEFFFFEB 		bl	ControlHandle
 6950              	.LVL639:
 6951 3d48 28309DE5 		ldr	r3, [sp, #40]
 6952 3d4c DAFCFFEA 		b	.L404
 6953              	.L596:
 6954              		.align	2
 6955              	.L595:
 6956 3d50 00000000 		.word	.LANCHOR0
 6957 3d54 00000000 		.word	.LANCHOR1
 6958 3d58 00000000 		.word	bRequest
 6959 3d5c 00000000 		.word	wValue
 6960 3d60 00000000 		.word	wIndex
 6961 3d64 00000000 		.word	glInterStaBuffer
 6962 3d68 54060000 		.word	.LC35
 6963 3d6c 00000000 		.word	glChHandleInterStat
 6964 3d70 00000000 		.word	bmReqType
 6965 3d74 00000000 		.word	wLength
 6966 3d78 D8050000 		.word	.LC34
 6967 3d7c C0000000 		.word	.LANCHOR0+192
 6968 3d80 94070000 		.word	.LC43
 6969 3d84 B8070000 		.word	.LC44
 6970 3d88 A0060000 		.word	.LANCHOR1+1696
 6971 3d8c 80060000 		.word	.LC36
 6972 3d90 5C000000 		.word	.LANCHOR0+92
 6973 3d94 F4060000 		.word	.LANCHOR1+1780
 6974 3d98 00070000 		.word	.LANCHOR1+1792
 6975 3d9c 1C070000 		.word	.LC40
 6976 3da0 0C080000 		.word	.LC46
 6977 3da4 F0010000 		.word	.LC13
 6978 3da8 E4070000 		.word	.LC45
 6979 3dac BC060000 		.word	.LANCHOR1+1724
 6980 3db0 D8060000 		.word	.LANCHOR1+1752
 6981 3db4 A8060000 		.word	.LC37
 6982 3db8 CC060000 		.word	.LC38
 6983 3dbc F4060000 		.word	.LC39
 6984 3dc0 48070000 		.word	.LC41
 6985 3dc4 6C070000 		.word	.LC42
 6986              	.LBE131:
 6987              	.LBE167:
 6988              		.cfi_endproc
 6989              	.LFE25:
 6991              		.align	2
 6992              		.global	CamDefSet
 6994              	CamDefSet:
 6995              	.LFB5:
1898:../uvc.c      **** {
 6996              		.loc 1 1898 0
 6997              		.cfi_startproc
 6998              		@ args = 0, pretend = 0, frame = 24
 6999              		@ frame_needed = 0, uses_anonymous_args = 0
 7000              	.LVL640:
 7001 3dc8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7002              	.LCFI22:
 7003              		.cfi_def_cfa_offset 36
1905:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7004              		.loc 1 1905 0
 7005 3dcc B0429FE5 		ldr	r4, .L600
 7006              		.cfi_offset 14, -4
 7007              		.cfi_offset 11, -8
 7008              		.cfi_offset 10, -12
 7009              		.cfi_offset 9, -16
 7010              		.cfi_offset 8, -20
 7011              		.cfi_offset 7, -24
 7012              		.cfi_offset 6, -28
 7013              		.cfi_offset 5, -32
 7014              		.cfi_offset 4, -36
1910:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7015              		.loc 1 1910 0
 7016 3dd0 B0229FE5 		ldr	r2, .L600+4
1907:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 7017              		.loc 1 1907 0
 7018 3dd4 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1898:../uvc.c      **** {
 7019              		.loc 1 1898 0
 7020 3dd8 2CD04DE2 		sub	sp, sp, #44
 7021              	.LCFI23:
 7022              		.cfi_def_cfa_offset 80
1910:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7023              		.loc 1 1910 0
 7024 3ddc 1C0092E5 		ldr	r0, [r2, #28]
 7025 3de0 0010E0E3 		mvn	r1, #0
1912:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7026              		.loc 1 1912 0
 7027 3de4 2963A0E1 		mov	r6, r9, lsr #6
1906:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7028              		.loc 1 1906 0
 7029 3de8 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1905:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7030              		.loc 1 1905 0
 7031 3dec 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 7032              	.LVL641:
1910:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7033              		.loc 1 1910 0
 7034 3df0 FEFFFFEB 		bl	_txe_mutex_get
1911:../uvc.c      ****     if(Data1&0x80){
 7035              		.loc 1 1911 0
 7036 3df4 800019E3 		tst	r9, #128
1912:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7037              		.loc 1 1912 0
 7038 3df8 01600612 		andne	r6, r6, #1
 7039 3dfc 0660E011 		mvnne	r6, r6
 7040 3e00 3B600612 		andne	r6, r6, #59
 7041 3e04 0660E011 		mvnne	r6, r6
 7042 3e08 FF600612 		andne	r6, r6, #255
 7043              	.LVL642:
1914:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 7044              		.loc 1 1914 0
 7045 3e0c C6608603 		orreq	r6, r6, #198
 7046              	.LVL643:
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7047              		.loc 1 1918 0
 7048 3e10 0080A0E3 		mov	r8, #0
 7049 3e14 0A20A0E1 		mov	r2, sl
 7050 3e18 0730A0E1 		mov	r3, r7
 7051 3e1c 0110A0E3 		mov	r1, #1
1916:../uvc.c      ****     Data0 = (Data0 << 2);
 7052              		.loc 1 1916 0
 7053 3e20 0951A0E1 		mov	r5, r9, asl #2
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7054              		.loc 1 1918 0
 7055 3e24 5C029FE5 		ldr	r0, .L600+4
1921:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7056              		.loc 1 1921 0
 7057 3e28 0190A0E3 		mov	r9, #1
 7058              	.LVL644:
1916:../uvc.c      ****     Data0 = (Data0 << 2);
 7059              		.loc 1 1916 0
 7060 3e2c FF5005E2 		and	r5, r5, #255
 7061              	.LVL645:
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7062              		.loc 1 1918 0
 7063 3e30 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7064 3e34 FEFFFFEB 		bl	cmdSet
 7065              	.LVL646:
1921:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7066              		.loc 1 1921 0
 7067 3e38 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 7068 3e3c 0910A0E1 		mov	r1, r9
 7069 3e40 0730A0E1 		mov	r3, r7
 7070 3e44 3C029FE5 		ldr	r0, .L600+4
 7071 3e48 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 7072 3e4c FEFFFFEB 		bl	cmdSet
 7073              	.LVL647:
1924:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7074              		.loc 1 1924 0
 7075 3e50 0620A0E1 		mov	r2, r6
 7076 3e54 0530A0E1 		mov	r3, r5
 7077 3e58 2C129FE5 		ldr	r1, .L600+8
 7078 3e5c 0400A0E3 		mov	r0, #4
1923:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 7079              		.loc 1 1923 0
 7080 3e60 A661C4E5 		strb	r6, [r4, #422]
1922:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7081              		.loc 1 1922 0
 7082 3e64 A551C4E5 		strb	r5, [r4, #421]
1924:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7083              		.loc 1 1924 0
 7084 3e68 FEFFFFEB 		bl	CyU3PDebugPrint
 7085              	.LVL648:
1929:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7086              		.loc 1 1929 0
 7087 3e6c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 7088              	.LVL649:
1930:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 7089              		.loc 1 1930 0
 7090 3e70 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 7091 3e74 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 7092 3e78 0210A0E3 		mov	r1, #2
 7093 3e7c 04029FE5 		ldr	r0, .L600+4
 7094 3e80 00B08DE5 		str	fp, [sp, #0]
 7095 3e84 04808DE5 		str	r8, [sp, #4]
 7096 3e88 FEFFFFEB 		bl	cmdSet
 7097              	.LVL650:
1933:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7098              		.loc 1 1933 0
 7099 3e8c 0B20A0E1 		mov	r2, fp
 7100 3e90 0530A0E1 		mov	r3, r5
 7101 3e94 F0119FE5 		ldr	r1, .L600+8
 7102 3e98 0400A0E3 		mov	r0, #4
1931:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7103              		.loc 1 1931 0
 7104 3e9c BD51C4E5 		strb	r5, [r4, #445]
1932:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 7105              		.loc 1 1932 0
 7106 3ea0 FD53C4E5 		strb	r5, [r4, #1021]
1933:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7107              		.loc 1 1933 0
 7108 3ea4 FEFFFFEB 		bl	CyU3PDebugPrint
 7109              	.LVL651:
1938:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7110              		.loc 1 1938 0
 7111 3ea8 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1937:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7112              		.loc 1 1937 0
 7113 3eac 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 7114              	.LVL652:
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7115              		.loc 1 1939 0
 7116 3eb0 80B047E2 		sub	fp, r7, #128
 7117 3eb4 FF100BE2 		and	r1, fp, #255
 7118 3eb8 14108DE5 		str	r1, [sp, #20]
 7119 3ebc 14C09DE5 		ldr	ip, [sp, #20]
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7120              		.loc 1 1940 0
 7121 3ec0 760047E2 		sub	r0, r7, #118
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7122              		.loc 1 1941 0
 7123 3ec4 7EE087E2 		add	lr, r7, #126
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7124              		.loc 1 1939 0
 7125 3ec8 0630A0E1 		mov	r3, r6
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7126              		.loc 1 1940 0
 7127 3ecc 18008DE5 		str	r0, [sp, #24]
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7128              		.loc 1 1939 0
 7129 3ed0 0510A0E3 		mov	r1, #5
 7130 3ed4 DF20A0E3 		mov	r2, #223
 7131 3ed8 A8019FE5 		ldr	r0, .L600+4
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7132              		.loc 1 1941 0
 7133 3edc 1CE08DE5 		str	lr, [sp, #28]
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7134              		.loc 1 1939 0
 7135 3ee0 00C08DE5 		str	ip, [sp, #0]
 7136 3ee4 04808DE5 		str	r8, [sp, #4]
 7137 3ee8 FEFFFFEB 		bl	cmdSet
 7138              	.LVL653:
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7139              		.loc 1 1940 0
 7140 3eec 18A09DE5 		ldr	sl, [sp, #24]
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7141              		.loc 1 1942 0
 7142 3ef0 72E087E2 		add	lr, r7, #114
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7143              		.loc 1 1940 0
 7144 3ef4 FFC00AE2 		and	ip, sl, #255
 7145 3ef8 0630A0E1 		mov	r3, r6
 7146 3efc 0510A0E3 		mov	r1, #5
 7147 3f00 DC20A0E3 		mov	r2, #220
 7148 3f04 7C019FE5 		ldr	r0, .L600+4
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7149              		.loc 1 1942 0
 7150 3f08 20E08DE5 		str	lr, [sp, #32]
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7151              		.loc 1 1940 0
 7152 3f0c 00C08DE5 		str	ip, [sp, #0]
 7153 3f10 04908DE5 		str	r9, [sp, #4]
 7154 3f14 FEFFFFEB 		bl	cmdSet
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7155              		.loc 1 1941 0
 7156 3f18 1C009DE5 		ldr	r0, [sp, #28]
 7157 3f1c 02E0A0E3 		mov	lr, #2
 7158 3f20 FFC000E2 		and	ip, r0, #255
 7159 3f24 0630A0E1 		mov	r3, r6
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7160              		.loc 1 1943 0
 7161 3f28 6FA047E2 		sub	sl, r7, #111
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7162              		.loc 1 1941 0
 7163 3f2c 0510A0E3 		mov	r1, #5
 7164 3f30 DE20A0E3 		mov	r2, #222
 7165 3f34 4C019FE5 		ldr	r0, .L600+4
 7166 3f38 04E08DE5 		str	lr, [sp, #4]
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7167              		.loc 1 1943 0
 7168 3f3c 24A08DE5 		str	sl, [sp, #36]
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7169              		.loc 1 1941 0
 7170 3f40 00C08DE5 		str	ip, [sp, #0]
 7171 3f44 FEFFFFEB 		bl	cmdSet
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7172              		.loc 1 1942 0
 7173 3f48 20A09DE5 		ldr	sl, [sp, #32]
 7174 3f4c 0630A0E1 		mov	r3, r6
 7175 3f50 FFC00AE2 		and	ip, sl, #255
 7176 3f54 00C08DE5 		str	ip, [sp, #0]
 7177 3f58 0510A0E3 		mov	r1, #5
 7178 3f5c 03C0A0E3 		mov	ip, #3
 7179 3f60 E020A0E3 		mov	r2, #224
 7180 3f64 1C019FE5 		ldr	r0, .L600+4
 7181 3f68 04C08DE5 		str	ip, [sp, #4]
 7182 3f6c FEFFFFEB 		bl	cmdSet
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7183              		.loc 1 1943 0
 7184 3f70 24009DE5 		ldr	r0, [sp, #36]
 7185 3f74 04A0A0E3 		mov	sl, #4
 7186 3f78 FFC000E2 		and	ip, r0, #255
 7187 3f7c 0630A0E1 		mov	r3, r6
 7188 3f80 0510A0E3 		mov	r1, #5
 7189 3f84 DD20A0E3 		mov	r2, #221
 7190 3f88 F8009FE5 		ldr	r0, .L600+4
 7191 3f8c 00C08DE5 		str	ip, [sp, #0]
1944:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7192              		.loc 1 1944 0
 7193 3f90 7F7087E2 		add	r7, r7, #127
 7194              	.LVL654:
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7195              		.loc 1 1943 0
 7196 3f94 04A08DE5 		str	sl, [sp, #4]
 7197 3f98 FEFFFFEB 		bl	cmdSet
1944:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7198              		.loc 1 1944 0
 7199 3f9c 05E0A0E3 		mov	lr, #5
 7200 3fa0 0E10A0E1 		mov	r1, lr
 7201 3fa4 0630A0E1 		mov	r3, r6
 7202 3fa8 E120A0E3 		mov	r2, #225
 7203 3fac FF6007E2 		and	r6, r7, #255
 7204              	.LVL655:
 7205 3fb0 D0009FE5 		ldr	r0, .L600+4
 7206 3fb4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7207 3fb8 FEFFFFEB 		bl	cmdSet
 7208              	.LVL656:
1945:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7209              		.loc 1 1945 0
 7210 3fbc 14C09DE5 		ldr	ip, [sp, #20]
1946:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7211              		.loc 1 1946 0
 7212 3fc0 24E09DE5 		ldr	lr, [sp, #36]
 7213 3fc4 1C609DE5 		ldr	r6, [sp, #28]
1945:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7214              		.loc 1 1945 0
 7215 3fc8 05C2C4E5 		strb	ip, [r4, #517]
1946:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7216              		.loc 1 1946 0
 7217 3fcc 20C09DE5 		ldr	ip, [sp, #32]
 7218 3fd0 0B20A0E1 		mov	r2, fp
 7219 3fd4 18309DE5 		ldr	r3, [sp, #24]
 7220 3fd8 B0109FE5 		ldr	r1, .L600+12
 7221 3fdc 0A00A0E1 		mov	r0, sl
 7222 3fe0 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7223 3fe4 0C708DE5 		str	r7, [sp, #12]
 7224 3fe8 FEFFFFEB 		bl	CyU3PDebugPrint
 7225              	.LVL657:
1950:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7226              		.loc 1 1950 0
 7227 3fec 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7228              	.LVL658:
1951:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7229              		.loc 1 1951 0
 7230 3ff0 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7231              	.LVL659:
1952:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7232              		.loc 1 1952 0
 7233 3ff4 0730A0E1 		mov	r3, r7
 7234 3ff8 0610A0E3 		mov	r1, #6
 7235 3ffc 8520A0E3 		mov	r2, #133
 7236 4000 80009FE5 		ldr	r0, .L600+4
 7237 4004 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7238 4008 FEFFFFEB 		bl	cmdSet
1953:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7239              		.loc 1 1953 0
 7240 400c 0730A0E1 		mov	r3, r7
 7241 4010 0610A0E3 		mov	r1, #6
 7242 4014 8620A0E3 		mov	r2, #134
 7243 4018 68009FE5 		ldr	r0, .L600+4
 7244 401c 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7245 4020 FEFFFFEB 		bl	cmdSet
1955:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7246              		.loc 1 1955 0
 7247 4024 0620A0E1 		mov	r2, r6
 7248 4028 0530A0E1 		mov	r3, r5
 7249 402c 58109FE5 		ldr	r1, .L600+8
 7250 4030 0A00A0E1 		mov	r0, sl
1954:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7251              		.loc 1 1954 0
 7252 4034 1D62C4E5 		strb	r6, [r4, #541]
1955:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7253              		.loc 1 1955 0
 7254 4038 FEFFFFEB 		bl	CyU3PDebugPrint
 7255              	.LVL660:
1960:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7256              		.loc 1 1960 0
 7257 403c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7258              	.LVL661:
1961:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7259              		.loc 1 1961 0
 7260 4040 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7261 4044 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7262 4048 0710A0E3 		mov	r1, #7
 7263 404c 34009FE5 		ldr	r0, .L600+4
 7264 4050 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7265 4054 FEFFFFEB 		bl	cmdSet
 7266              	.LVL662:
1963:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7267              		.loc 1 1963 0
 7268 4058 0530A0E1 		mov	r3, r5
 7269 405c 0A00A0E1 		mov	r0, sl
 7270 4060 24109FE5 		ldr	r1, .L600+8
 7271 4064 0620A0E1 		mov	r2, r6
1962:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7272              		.loc 1 1962 0
 7273 4068 3552C4E5 		strb	r5, [r4, #565]
1963:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7274              		.loc 1 1963 0
 7275 406c FEFFFFEB 		bl	CyU3PDebugPrint
1965:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7276              		.loc 1 1965 0
 7277 4070 10309FE5 		ldr	r3, .L600+4
 7278 4074 1C0093E5 		ldr	r0, [r3, #28]
1968:../uvc.c      **** }
 7279              		.loc 1 1968 0
 7280 4078 2CD08DE2 		add	sp, sp, #44
 7281 407c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1965:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7282              		.loc 1 1965 0
 7283 4080 FEFFFFEA 		b	_txe_mutex_put
 7284              	.L601:
 7285              		.align	2
 7286              	.L600:
 7287 4084 00000000 		.word	.LANCHOR1
 7288 4088 00000000 		.word	statQu
 7289 408c 40080000 		.word	.LC47
 7290 4090 60080000 		.word	.LC48
 7291              		.cfi_endproc
 7292              	.LFE5:
 7294              		.align	2
 7295              		.global	CyFxUVCAddHeader
 7297              	CyFxUVCAddHeader:
 7298              	.LFB6:
1976:../uvc.c      **** {
 7299              		.loc 1 1976 0
 7300              		.cfi_startproc
 7301              		@ args = 0, pretend = 0, frame = 0
 7302              		@ frame_needed = 0, uses_anonymous_args = 0
 7303              	.LVL663:
 7304 4094 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7305              	.LCFI24:
 7306              		.cfi_def_cfa_offset 16
1976:../uvc.c      **** {
 7307              		.loc 1 1976 0
 7308 4098 0040A0E1 		mov	r4, r0
 7309              		.cfi_offset 14, -4
 7310              		.cfi_offset 5, -8
 7311              		.cfi_offset 4, -12
 7312              		.cfi_offset 3, -16
 7313 409c 0150A0E1 		mov	r5, r1
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7314              		.loc 1 1978 0
 7315 40a0 30009FE5 		ldr	r0, .L604
 7316              	.LVL664:
 7317 40a4 0010E0E3 		mvn	r1, #0
 7318              	.LVL665:
 7319 40a8 FEFFFFEB 		bl	_txe_mutex_get
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7320              		.loc 1 1979 0
 7321 40ac 0400A0E1 		mov	r0, r4
 7322 40b0 24109FE5 		ldr	r1, .L604+4
 7323 40b4 0C20A0E3 		mov	r2, #12
 7324 40b8 FEFFFFEB 		bl	CyU3PMemCopy
1980:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7325              		.loc 1 1980 0
 7326 40bc 14009FE5 		ldr	r0, .L604
 7327 40c0 FEFFFFEB 		bl	_txe_mutex_put
1983:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7328              		.loc 1 1983 0
 7329 40c4 020015E3 		tst	r5, #2
1985:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7330              		.loc 1 1985 0
 7331 40c8 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7332 40cc 02308313 		orrne	r3, r3, #2
 7333 40d0 0130C415 		strneb	r3, [r4, #1]
 7334 40d4 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7335              	.L605:
 7336              		.align	2
 7337              	.L604:
 7338 40d8 00000000 		.word	imgHdMux
 7339 40dc 80040000 		.word	.LANCHOR1+1152
 7340              		.cfi_endproc
 7341              	.LFE6:
 7343              		.align	2
 7344              		.global	CyFxAppErrorHandler
 7346              	CyFxAppErrorHandler:
 7347              	.LFB7:
1995:../uvc.c      **** {
 7348              		.loc 1 1995 0
 7349              		.cfi_startproc
 7350              		@ args = 0, pretend = 0, frame = 0
 7351              		@ frame_needed = 0, uses_anonymous_args = 0
 7352              	.LVL666:
 7353 40e0 08402DE9 		stmfd	sp!, {r3, lr}
 7354              	.LCFI25:
 7355              		.cfi_def_cfa_offset 8
 7356              	.LVL667:
 7357              	.L607:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7358              		.loc 1 2005 0 discriminator 1
 7359 40e4 10109FE5 		ldr	r1, .L608
 7360 40e8 0400A0E3 		mov	r0, #4
 7361              		.cfi_offset 14, -4
 7362              		.cfi_offset 3, -8
 7363 40ec FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 7364              		.loc 1 2006 0 discriminator 1
 7365 40f0 FA0FA0E3 		mov	r0, #1000
 7366 40f4 FEFFFFEB 		bl	_tx_thread_sleep
 7367 40f8 F9FFFFEA 		b	.L607
 7368              	.L609:
 7369              		.align	2
 7370              	.L608:
 7371 40fc F0010000 		.word	.LC13
 7372              		.cfi_endproc
 7373              	.LFE7:
 7375              		.align	2
 7376              		.global	UVCAppThread_Entry
 7378              	UVCAppThread_Entry:
 7379              	.LFB19:
2982:../uvc.c      **** {
 7380              		.loc 1 2982 0
 7381              		.cfi_startproc
 7382              		@ args = 0, pretend = 0, frame = 176
 7383              		@ frame_needed = 0, uses_anonymous_args = 0
 7384              	.LVL668:
 7385 4100 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 7386              	.LCFI26:
 7387              		.cfi_def_cfa_offset 28
 7388 4104 BCD04DE2 		sub	sp, sp, #188
 7389              	.LCFI27:
 7390              		.cfi_def_cfa_offset 216
 7391              	.LBB220:
 7392              	.LBB221:
2438:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7393              		.loc 1 2438 0
 7394              		.cfi_offset 14, -4
 7395              		.cfi_offset 10, -8
 7396              		.cfi_offset 8, -12
 7397              		.cfi_offset 7, -16
 7398              		.cfi_offset 6, -20
 7399              		.cfi_offset 5, -24
 7400              		.cfi_offset 4, -28
 7401 4108 FEFFFFEB 		bl	CyU3PUartInit
 7402              	.LVL669:
2439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7403              		.loc 1 2439 0
 7404 410c 004050E2 		subs	r4, r0, #0
 7405 4110 0400000A 		beq	.L611
2441:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7406              		.loc 1 2441 0
 7407 4114 0400A0E3 		mov	r0, #4
 7408              	.LVL670:
 7409 4118 F81B9FE5 		ldr	r1, .L727
 7410 411c FEFFFFEB 		bl	CyU3PDebugPrint
2442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7411              		.loc 1 2442 0
 7412 4120 0400A0E1 		mov	r0, r4
 7413 4124 FEFFFFEB 		bl	CyFxAppErrorHandler
 7414              	.L611:
2446:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7415              		.loc 1 2446 0
 7416 4128 ECCB9FE5 		ldr	ip, .L727+4
2448:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7417              		.loc 1 2448 0
 7418 412c 0030A0E3 		mov	r3, #0
2447:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7419              		.loc 1 2447 0
 7420 4130 0120A0E3 		mov	r2, #1
2455:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7421              		.loc 1 2455 0
 7422 4134 50008DE2 		add	r0, sp, #80
 7423 4138 0310A0E1 		mov	r1, r3
2446:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7424              		.loc 1 2446 0
 7425 413c 60C08DE5 		str	ip, [sp, #96]
2447:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7426              		.loc 1 2447 0
 7427 4140 6420CDE5 		strb	r2, [sp, #100]
2448:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7428              		.loc 1 2448 0
 7429 4144 6530CDE5 		strb	r3, [sp, #101]
2449:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7430              		.loc 1 2449 0
 7431 4148 50208DE5 		str	r2, [sp, #80]
2450:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7432              		.loc 1 2450 0
 7433 414c 54308DE5 		str	r3, [sp, #84]
2451:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7434              		.loc 1 2451 0
 7435 4150 58308DE5 		str	r3, [sp, #88]
2452:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7436              		.loc 1 2452 0
 7437 4154 5C208DE5 		str	r2, [sp, #92]
2455:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7438              		.loc 1 2455 0
 7439 4158 FEFFFFEB 		bl	CyU3PUartSetConfig
 7440              	.LVL671:
2456:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7441              		.loc 1 2456 0
 7442 415c 000050E3 		cmp	r0, #0
 7443 4160 0000000A 		beq	.L612
2458:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7444              		.loc 1 2458 0
 7445 4164 FEFFFFEB 		bl	CyFxAppErrorHandler
 7446              	.LVL672:
 7447              	.L612:
2462:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7448              		.loc 1 2462 0
 7449 4168 0000E0E3 		mvn	r0, #0
 7450 416c FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7451              	.LVL673:
2463:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7452              		.loc 1 2463 0
 7453 4170 000050E3 		cmp	r0, #0
 7454 4174 0000000A 		beq	.L613
2465:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7455              		.loc 1 2465 0
 7456 4178 FEFFFFEB 		bl	CyFxAppErrorHandler
 7457              	.LVL674:
 7458              	.L613:
2469:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7459              		.loc 1 2469 0
 7460 417c 0300A0E3 		mov	r0, #3
 7461 4180 0410A0E3 		mov	r1, #4
 7462 4184 FEFFFFEB 		bl	CyU3PDebugInit
 7463              	.LVL675:
2470:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7464              		.loc 1 2470 0
 7465 4188 000050E3 		cmp	r0, #0
 7466 418c 0000000A 		beq	.L614
2472:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7467              		.loc 1 2472 0
 7468 4190 FEFFFFEB 		bl	CyFxAppErrorHandler
 7469              	.LVL676:
 7470              	.L614:
2476:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7471              		.loc 1 2476 0
 7472 4194 0000A0E3 		mov	r0, #0
 7473 4198 FEFFFFEB 		bl	CyU3PDebugPreamble
 7474              	.LVL677:
 7475              	.LBE221:
 7476              	.LBE220:
2998:../uvc.c      **** 		CyU3PThreadSleep(500);
 7477              		.loc 1 2998 0
 7478 419c 7D0FA0E3 		mov	r0, #500
 7479 41a0 FEFFFFEB 		bl	_tx_thread_sleep
 7480              	.LVL678:
 7481 41a4 7D0FA0E3 		mov	r0, #500
 7482 41a8 FEFFFFEB 		bl	_tx_thread_sleep
 7483 41ac 7D0FA0E3 		mov	r0, #500
 7484 41b0 FEFFFFEB 		bl	_tx_thread_sleep
 7485 41b4 7D0FA0E3 		mov	r0, #500
 7486 41b8 FEFFFFEB 		bl	_tx_thread_sleep
 7487 41bc 7D0FA0E3 		mov	r0, #500
 7488 41c0 FEFFFFEB 		bl	_tx_thread_sleep
 7489 41c4 7D0FA0E3 		mov	r0, #500
 7490 41c8 FEFFFFEB 		bl	_tx_thread_sleep
 7491              	.LBB222:
 7492              	.LBB223:
2486:../uvc.c      ****     status = CyU3PI2cInit ();
 7493              		.loc 1 2486 0
 7494 41cc FEFFFFEB 		bl	CyU3PI2cInit
 7495              	.LVL679:
2487:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7496              		.loc 1 2487 0
 7497 41d0 004050E2 		subs	r4, r0, #0
 7498 41d4 0400000A 		beq	.L615
2489:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7499              		.loc 1 2489 0
 7500 41d8 0400A0E3 		mov	r0, #4
 7501              	.LVL680:
 7502 41dc 3C1B9FE5 		ldr	r1, .L727+8
 7503 41e0 FEFFFFEB 		bl	CyU3PDebugPrint
2490:../uvc.c      ****         CyFxAppErrorHandler (status);
 7504              		.loc 1 2490 0
 7505 41e4 0400A0E1 		mov	r0, r4
 7506 41e8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7507              	.L615:
2494:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7508              		.loc 1 2494 0
 7509 41ec 306B9FE5 		ldr	r6, .L727+12
2495:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7510              		.loc 1 2495 0
 7511 41f0 0050A0E3 		mov	r5, #0
2496:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7512              		.loc 1 2496 0
 7513 41f4 0040E0E3 		mvn	r4, #0
 7514              	.LVL681:
2499:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7515              		.loc 1 2499 0
 7516 41f8 8C008DE2 		add	r0, sp, #140
 7517 41fc 0510A0E1 		mov	r1, r5
2496:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7518              		.loc 1 2496 0
 7519 4200 94408DE5 		str	r4, [sp, #148]
2497:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7520              		.loc 1 2497 0
 7521 4204 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2494:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7522              		.loc 1 2494 0
 7523 4208 8C608DE5 		str	r6, [sp, #140]
2495:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7524              		.loc 1 2495 0
 7525 420c 90508DE5 		str	r5, [sp, #144]
2499:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7526              		.loc 1 2499 0
 7527 4210 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7528              	.LVL682:
2500:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7529              		.loc 1 2500 0
 7530 4214 004050E2 		subs	r4, r0, #0
 7531 4218 0400000A 		beq	.L616
2502:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7532              		.loc 1 2502 0
 7533 421c 0400A0E3 		mov	r0, #4
 7534              	.LVL683:
 7535 4220 001B9FE5 		ldr	r1, .L727+16
 7536 4224 FEFFFFEB 		bl	CyU3PDebugPrint
2503:../uvc.c      ****         CyFxAppErrorHandler (status);
 7537              		.loc 1 2503 0
 7538 4228 0400A0E1 		mov	r0, r4
 7539 422c FEFFFFEB 		bl	CyFxAppErrorHandler
 7540              	.L616:
 7541              	.LBE223:
 7542              	.LBE222:
 7543              	.LBB224:
 7544              	.LBB227:
2573:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 7545              		.loc 1 2573 0
 7546 4230 F44A9FE5 		ldr	r4, .L727+20
 7547              	.LVL684:
 7548 4234 2820A0E3 		mov	r2, #40
 7549 4238 0010A0E3 		mov	r1, #0
 7550 423c 0400A0E1 		mov	r0, r4
 7551 4240 FEFFFFEB 		bl	_txe_event_flags_create
 7552              	.LVL685:
2574:../uvc.c      ****     if (apiRetStatus != 0)
 7553              		.loc 1 2574 0
 7554 4244 002050E2 		subs	r2, r0, #0
 7555 4248 F800001A 		bne	.L701
2588:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7556              		.loc 1 2588 0
 7557 424c 0260A0E3 		mov	r6, #2
2595:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7558              		.loc 1 2595 0
 7559 4250 0210A0E1 		mov	r1, r2
2584:../uvc.c      ****     isUsbConnected = CyFalse;
 7560              		.loc 1 2584 0
 7561 4254 302084E5 		str	r2, [r4, #48]
2585:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7562              		.loc 1 2585 0
 7563 4258 442084E5 		str	r2, [r4, #68]
2591:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7564              		.loc 1 2591 0
 7565 425c 0370A0E3 		mov	r7, #3
2595:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7566              		.loc 1 2595 0
 7567 4260 9C008DE2 		add	r0, sp, #156
 7568              	.LVL686:
2590:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7569              		.loc 1 2590 0
 7570 4264 A420CDE5 		strb	r2, [sp, #164]
2592:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7571              		.loc 1 2592 0
 7572 4268 A0208DE5 		str	r2, [sp, #160]
2588:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7573              		.loc 1 2588 0
 7574 426c 9C60CDE5 		strb	r6, [sp, #156]
2589:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7575              		.loc 1 2589 0
 7576 4270 9D60CDE5 		strb	r6, [sp, #157]
2591:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7577              		.loc 1 2591 0
 7578 4274 A570CDE5 		strb	r7, [sp, #165]
2595:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7579              		.loc 1 2595 0
 7580 4278 FEFFFFEB 		bl	CyU3PGpioInit
 7581              	.LVL687:
2596:../uvc.c      ****     if (apiRetStatus != 0)
 7582              		.loc 1 2596 0
 7583 427c 002050E2 		subs	r2, r0, #0
 7584 4280 FC00001A 		bne	.L702
2604:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 7585              		.loc 1 2604 0
 7586 4284 1600A0E3 		mov	r0, #22
 7587              	.LVL688:
 7588 4288 0110A0E3 		mov	r1, #1
 7589 428c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7590              	.LVL689:
2605:../uvc.c      ****     if (apiRetStatus != 0)
 7591              		.loc 1 2605 0
 7592 4290 002050E2 		subs	r2, r0, #0
 7593 4294 EE00001A 		bne	.L703
2610:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 7594              		.loc 1 2610 0
 7595 4298 1400A0E3 		mov	r0, #20
 7596              	.LVL690:
 7597 429c 0110A0E3 		mov	r1, #1
 7598 42a0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7599              	.LVL691:
2611:../uvc.c      ****     if (apiRetStatus != 0)
 7600              		.loc 1 2611 0
 7601 42a4 002050E2 		subs	r2, r0, #0
 7602 42a8 FB00001A 		bne	.L704
2616:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 7603              		.loc 1 2616 0
 7604 42ac 1800A0E3 		mov	r0, #24
 7605              	.LVL692:
 7606 42b0 0110A0E3 		mov	r1, #1
 7607 42b4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7608              	.LVL693:
2617:../uvc.c      ****     if (apiRetStatus != 0)
 7609              		.loc 1 2617 0
 7610 42b8 002050E2 		subs	r2, r0, #0
 7611 42bc D601001A 		bne	.L705
2624:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7612              		.loc 1 2624 0
 7613 42c0 0150A0E3 		mov	r5, #1
2629:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7614              		.loc 1 2629 0
 7615 42c4 1600A0E3 		mov	r0, #22
 7616              	.LVL694:
 7617 42c8 68108DE2 		add	r1, sp, #104
2627:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7618              		.loc 1 2627 0
 7619 42cc 74208DE5 		str	r2, [sp, #116]
2628:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7620              		.loc 1 2628 0
 7621 42d0 7820CDE5 		strb	r2, [sp, #120]
2624:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7622              		.loc 1 2624 0
 7623 42d4 68508DE5 		str	r5, [sp, #104]
2625:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7624              		.loc 1 2625 0
 7625 42d8 6C508DE5 		str	r5, [sp, #108]
2626:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7626              		.loc 1 2626 0
 7627 42dc 70508DE5 		str	r5, [sp, #112]
2629:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7628              		.loc 1 2629 0
 7629 42e0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7630              	.LVL695:
2630:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7631              		.loc 1 2630 0
 7632 42e4 002050E2 		subs	r2, r0, #0
 7633 42e8 C201001A 		bne	.L706
2643:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7634              		.loc 1 2643 0
 7635 42ec 1400A0E3 		mov	r0, #20
 7636              	.LVL696:
 7637 42f0 68108DE2 		add	r1, sp, #104
2641:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7638              		.loc 1 2641 0
 7639 42f4 74208DE5 		str	r2, [sp, #116]
2642:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7640              		.loc 1 2642 0
 7641 42f8 7820CDE5 		strb	r2, [sp, #120]
2638:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7642              		.loc 1 2638 0
 7643 42fc 68508DE5 		str	r5, [sp, #104]
2639:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7644              		.loc 1 2639 0
 7645 4300 6C508DE5 		str	r5, [sp, #108]
2640:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7646              		.loc 1 2640 0
 7647 4304 70508DE5 		str	r5, [sp, #112]
2643:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7648              		.loc 1 2643 0
 7649 4308 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7650              	.LVL697:
2644:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7651              		.loc 1 2644 0
 7652 430c 002050E2 		subs	r2, r0, #0
 7653 4310 CA01001A 		bne	.L707
2657:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7654              		.loc 1 2657 0
 7655 4314 1800A0E3 		mov	r0, #24
 7656              	.LVL698:
 7657 4318 68108DE2 		add	r1, sp, #104
2652:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 7658              		.loc 1 2652 0
 7659 431c 68208DE5 		str	r2, [sp, #104]
2653:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7660              		.loc 1 2653 0
 7661 4320 6C208DE5 		str	r2, [sp, #108]
2654:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7662              		.loc 1 2654 0
 7663 4324 70208DE5 		str	r2, [sp, #112]
2656:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7664              		.loc 1 2656 0
 7665 4328 7820CDE5 		strb	r2, [sp, #120]
2655:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7666              		.loc 1 2655 0
 7667 432c 74508DE5 		str	r5, [sp, #116]
2657:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7668              		.loc 1 2657 0
 7669 4330 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7670              	.LVL699:
2658:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7671              		.loc 1 2658 0
 7672 4334 002050E2 		subs	r2, r0, #0
 7673 4338 A501001A 		bne	.L708
2670:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7674              		.loc 1 2670 0
 7675 433c 0500A0E1 		mov	r0, r5
 7676              	.LVL700:
 7677 4340 7C108DE2 		add	r1, sp, #124
2667:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7678              		.loc 1 2667 0
 7679 4344 84208DE5 		str	r2, [sp, #132]
2668:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7680              		.loc 1 2668 0
 7681 4348 80208DE5 		str	r2, [sp, #128]
2665:../uvc.c      ****     pibclock.clkDiv      = 2;
 7682              		.loc 1 2665 0
 7683 434c BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2666:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7684              		.loc 1 2666 0
 7685 4350 8870CDE5 		strb	r7, [sp, #136]
2670:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7686              		.loc 1 2670 0
 7687 4354 FEFFFFEB 		bl	CyU3PPibInit
 7688              	.LVL701:
2671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7689              		.loc 1 2671 0
 7690 4358 002050E2 		subs	r2, r0, #0
 7691 435c 9301001A 		bne	.L709
2678:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7692              		.loc 1 2678 0
 7693 4360 C8099FE5 		ldr	r0, .L727+24
 7694              	.LVL702:
 7695 4364 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7696              	.LVL703:
2686:../uvc.c      ****     SensorReset ();
 7697              		.loc 1 2686 0
 7698 4368 FEFFFFEB 		bl	SensorReset
2687:../uvc.c      ****     CyU3PThreadSleep(5000);
 7699              		.loc 1 2687 0
 7700 436c C0099FE5 		ldr	r0, .L727+28
 7701 4370 FEFFFFEB 		bl	_tx_thread_sleep
2691:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7702              		.loc 1 2691 0
 7703 4374 FEFFFFEB 		bl	CyU3PUsbStart
 7704              	.LVL704:
2692:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7705              		.loc 1 2692 0
 7706 4378 002050E2 		subs	r2, r0, #0
 7707 437c 8201001A 		bne	.L710
2698:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7708              		.loc 1 2698 0
 7709 4380 0010A0E3 		mov	r1, #0
 7710 4384 AC099FE5 		ldr	r0, .L727+32
 7711              	.LVL705:
 7712 4388 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7713              	.LVL706:
2701:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7714              		.loc 1 2701 0
 7715 438c A8099FE5 		ldr	r0, .L727+36
 7716 4390 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2707:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7717              		.loc 1 2707 0
 7718 4394 0010A0E3 		mov	r1, #0
 7719 4398 A0299FE5 		ldr	r2, .L727+40
 7720 439c 0100A0E3 		mov	r0, #1
 7721 43a0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2708:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7722              		.loc 1 2708 0
 7723 43a4 0000A0E3 		mov	r0, #0
 7724 43a8 0010A0E1 		mov	r1, r0
 7725 43ac 90299FE5 		ldr	r2, .L727+44
 7726 43b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2711:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7727              		.loc 1 2711 0
 7728 43b4 0010A0E3 		mov	r1, #0
 7729 43b8 88299FE5 		ldr	r2, .L727+48
 7730 43bc 0200A0E3 		mov	r0, #2
 7731 43c0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2712:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7732              		.loc 1 2712 0
 7733 43c4 0010A0E3 		mov	r1, #0
 7734 43c8 7C299FE5 		ldr	r2, .L727+52
 7735 43cc 0700A0E3 		mov	r0, #7
 7736 43d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2715:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7737              		.loc 1 2715 0
 7738 43d4 0010A0E3 		mov	r1, #0
 7739 43d8 70299FE5 		ldr	r2, .L727+56
 7740 43dc 0400A0E3 		mov	r0, #4
 7741 43e0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2716:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7742              		.loc 1 2716 0
 7743 43e4 0010A0E3 		mov	r1, #0
 7744 43e8 64299FE5 		ldr	r2, .L727+60
 7745 43ec 0300A0E3 		mov	r0, #3
 7746 43f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2717:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7747              		.loc 1 2717 0
 7748 43f4 0010A0E3 		mov	r1, #0
 7749 43f8 58299FE5 		ldr	r2, .L727+64
 7750 43fc 0600A0E3 		mov	r0, #6
 7751 4400 FEFFFFEB 		bl	CyU3PUsbSetDesc
2720:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7752              		.loc 1 2720 0
 7753 4404 0010A0E3 		mov	r1, #0
 7754 4408 4C299FE5 		ldr	r2, .L727+68
 7755 440c 0500A0E3 		mov	r0, #5
 7756 4410 FEFFFFEB 		bl	CyU3PUsbSetDesc
2721:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7757              		.loc 1 2721 0
 7758 4414 0110A0E3 		mov	r1, #1
 7759 4418 40299FE5 		ldr	r2, .L727+72
 7760 441c 0500A0E3 		mov	r0, #5
 7761 4420 FEFFFFEB 		bl	CyU3PUsbSetDesc
2722:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7762              		.loc 1 2722 0
 7763 4424 0210A0E3 		mov	r1, #2
 7764 4428 34299FE5 		ldr	r2, .L727+76
 7765 442c 0500A0E3 		mov	r0, #5
 7766 4430 FEFFFFEB 		bl	CyU3PUsbSetDesc
2732:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7767              		.loc 1 2732 0
 7768 4434 0080A0E3 		mov	r8, #0
2729:../uvc.c      ****     endPointConfig.enable   = 1;
 7769              		.loc 1 2729 0
 7770 4438 0150A0E3 		mov	r5, #1
2731:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7771              		.loc 1 2731 0
 7772 443c 4070A0E3 		mov	r7, #64	@ movhi
2735:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7773              		.loc 1 2735 0
 7774 4440 8200A0E3 		mov	r0, #130
 7775 4444 A8108DE2 		add	r1, sp, #168
2730:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7776              		.loc 1 2730 0
 7777 4448 03A0A0E3 		mov	sl, #3
2731:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7778              		.loc 1 2731 0
 7779 444c B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2729:../uvc.c      ****     endPointConfig.enable   = 1;
 7780              		.loc 1 2729 0
 7781 4450 A8508DE5 		str	r5, [sp, #168]
2730:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7782              		.loc 1 2730 0
 7783 4454 ACA0CDE5 		strb	sl, [sp, #172]
2732:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7784              		.loc 1 2732 0
 7785 4458 B380CDE5 		strb	r8, [sp, #179]
2733:../uvc.c      ****     endPointConfig.streams  = 0;
 7786              		.loc 1 2733 0
 7787 445c BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2734:../uvc.c      ****     endPointConfig.burstLen = 1;
 7788              		.loc 1 2734 0
 7789 4460 B250CDE5 		strb	r5, [sp, #178]
2735:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7790              		.loc 1 2735 0
 7791 4464 FEFFFFEB 		bl	CyU3PSetEpConfig
 7792              	.LVL707:
2733:../uvc.c      ****     endPointConfig.streams  = 0;
 7793              		.loc 1 2733 0
 7794 4468 0870A0E1 		mov	r7, r8	@ movhi
2736:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7795              		.loc 1 2736 0
 7796 446c 003050E2 		subs	r3, r0, #0
 7797 4470 3B01001A 		bne	.L711
2746:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7798              		.loc 1 2746 0
 7799 4474 ECC89FE5 		ldr	ip, .L727+80
2747:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7800              		.loc 1 2747 0
 7801 4478 ECE89FE5 		ldr	lr, .L727+84
2744:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7802              		.loc 1 2744 0
 7803 447c 016BA0E3 		mov	r6, #1024	@ movhi
2753:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7804              		.loc 1 2753 0
 7805 4480 1080A0E3 		mov	r8, #16
2755:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7806              		.loc 1 2755 0
 7807 4484 E4089FE5 		ldr	r0, .L727+88
 7808              	.LVL708:
 7809 4488 0410A0E3 		mov	r1, #4
 7810 448c 34208DE2 		add	r2, sp, #52
2744:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7811              		.loc 1 2744 0
 7812 4490 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2745:../uvc.c      ****     dmaInterConfig.count          = 1;
 7813              		.loc 1 2745 0
 7814 4494 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2746:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7815              		.loc 1 2746 0
 7816 4498 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2747:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7817              		.loc 1 2747 0
 7818 449c BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2748:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7819              		.loc 1 2748 0
 7820 44a0 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2749:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7821              		.loc 1 2749 0
 7822 44a4 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2750:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7823              		.loc 1 2750 0
 7824 44a8 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2751:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7825              		.loc 1 2751 0
 7826 44ac B234CDE1 		strh	r3, [sp, #66]	@ movhi
2752:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7827              		.loc 1 2752 0
 7828 44b0 4470CDE5 		strb	r7, [sp, #68]
2753:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7829              		.loc 1 2753 0
 7830 44b4 48808DE5 		str	r8, [sp, #72]
2754:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7831              		.loc 1 2754 0
 7832 44b8 4C308DE5 		str	r3, [sp, #76]
2755:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7833              		.loc 1 2755 0
 7834 44bc FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7835              	.LVL709:
2757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7836              		.loc 1 2757 0
 7837 44c0 006050E2 		subs	r6, r0, #0
 7838 44c4 DF00001A 		bne	.L712
2764:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7839              		.loc 1 2764 0
 7840 44c8 010BA0E3 		mov	r0, #1024
 7841              	.LVL710:
 7842 44cc FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7843 44d0 9C189FE5 		ldr	r1, .L727+92
2765:../uvc.c      ****     if (glInterStaBuffer == 0)
 7844              		.loc 1 2765 0
 7845 44d4 000050E3 		cmp	r0, #0
2764:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7846              		.loc 1 2764 0
 7847 44d8 000081E5 		str	r0, [r1, #0]
2765:../uvc.c      ****     if (glInterStaBuffer == 0)
 7848              		.loc 1 2765 0
 7849 44dc D000000A 		beq	.L713
2772:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7850              		.loc 1 2772 0
 7851 44e0 0610A0E1 		mov	r1, r6
 7852 44e4 0620A0E1 		mov	r2, r6
 7853 44e8 3830A0E3 		mov	r3, #56
 7854 44ec 84089FE5 		ldr	r0, .L727+96
 7855 44f0 FEFFFFEB 		bl	_txe_mutex_create
2774:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7856              		.loc 1 2774 0
 7857 44f4 0430A0E3 		mov	r3, #4	@ movhi
 7858 44f8 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2777:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7859              		.loc 1 2777 0
 7860 44fc 78389FE5 		ldr	r3, .L727+100
2773:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7861              		.loc 1 2773 0
 7862 4500 01C9A0E3 		mov	ip, #16384	@ movhi
 7863 4504 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2776:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7864              		.loc 1 2776 0
 7865 4508 01CCA0E3 		mov	ip, #256	@ movhi
 7866 450c B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2777:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7867              		.loc 1 2777 0
 7868 4510 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2778:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7869              		.loc 1 2778 0
 7870 4514 64C89FE5 		ldr	ip, .L727+104
2780:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7871              		.loc 1 2780 0
 7872 4518 0C30A0E3 		mov	r3, #12	@ movhi
 7873 451c B432CDE1 		strh	r3, [sp, #36]	@ movhi
2785:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7874              		.loc 1 2785 0
 7875 4520 5C389FE5 		ldr	r3, .L727+108
2786:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7876              		.loc 1 2786 0
 7877 4524 0C208DE2 		add	r2, sp, #12
2778:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7878              		.loc 1 2778 0
 7879 4528 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2783:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7880              		.loc 1 2783 0
 7881 452c 2A70CDE5 		strb	r7, [sp, #42]
2781:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7882              		.loc 1 2781 0
 7883 4530 04C0A0E3 		mov	ip, #4	@ movhi
2775:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7884              		.loc 1 2775 0
 7885 4534 02A0A0E3 		mov	sl, #2	@ movhi
2786:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7886              		.loc 1 2786 0
 7887 4538 48089FE5 		ldr	r0, .L727+112
 7888 453c 0710A0E3 		mov	r1, #7
2784:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7889              		.loc 1 2784 0
 7890 4540 1870A0E3 		mov	r7, #24
2775:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7891              		.loc 1 2775 0
 7892 4544 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2779:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7893              		.loc 1 2779 0
 7894 4548 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2781:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7895              		.loc 1 2781 0
 7896 454c B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2782:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7897              		.loc 1 2782 0
 7898 4550 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2784:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7899              		.loc 1 2784 0
 7900 4554 2C708DE5 		str	r7, [sp, #44]
2785:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7901              		.loc 1 2785 0
 7902 4558 30308DE5 		str	r3, [sp, #48]
2786:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7903              		.loc 1 2786 0
 7904 455c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7905              	.LVL711:
2788:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7906              		.loc 1 2788 0
 7907 4560 002050E2 		subs	r2, r0, #0
 7908 4564 A500001A 		bne	.L714
2879:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 7909              		.loc 1 2879 0
 7910 4568 0500A0E1 		mov	r0, r5
 7911              	.LVL712:
 7912 456c 0510A0E1 		mov	r1, r5
 7913 4570 FEFFFFEB 		bl	CyU3PConnectState
 7914              	.LVL713:
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7915              		.loc 1 2880 0
 7916 4574 002050E2 		subs	r2, r0, #0
 7917 4578 9700001A 		bne	.L715
2886:../uvc.c      ****     CyU3PBusyWait(100);
 7918              		.loc 1 2886 0
 7919 457c 6400A0E3 		mov	r0, #100
 7920              	.LVL714:
 7921 4580 FEFFFFEB 		bl	CyU3PBusyWait
 7922              	.LVL715:
2888:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7923              		.loc 1 2888 0
 7924 4584 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2902:../uvc.c      ****     endPointConfig.streams  = 0;
 7925              		.loc 1 2902 0
 7926 4588 0020A0E3 		mov	r2, #0	@ movhi
2891:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7927              		.loc 1 2891 0
 7928 458c ACA0CDE5 		strb	sl, [sp, #172]
2903:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7929              		.loc 1 2903 0
 7930 4590 A8108DE2 		add	r1, sp, #168
2902:../uvc.c      ****     endPointConfig.streams  = 0;
 7931              		.loc 1 2902 0
 7932 4594 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2890:../uvc.c      ****     endPointConfig.enable   = 1;
 7933              		.loc 1 2890 0
 7934 4598 A8508DE5 		str	r5, [sp, #168]
2892:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7935              		.loc 1 2892 0
 7936 459c 030050E3 		cmp	r0, #3
2888:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7937              		.loc 1 2888 0
 7938 45a0 4800C4E5 		strb	r0, [r4, #72]
2899:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7939              		.loc 1 2899 0
 7940 45a4 020CA013 		movne	r0, #512	@ movhi
2894:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7941              		.loc 1 2894 0
 7942 45a8 01ABA003 		moveq	sl, #1024	@ movhi
2899:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7943              		.loc 1 2899 0
 7944 45ac B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2903:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7945              		.loc 1 2903 0
 7946 45b0 8300A0E3 		mov	r0, #131
2894:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7947              		.loc 1 2894 0
 7948 45b4 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2895:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7949              		.loc 1 2895 0
 7950 45b8 B280CD05 		streqb	r8, [sp, #178]
2900:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7951              		.loc 1 2900 0
 7952 45bc B250CD15 		strneb	r5, [sp, #178]
2903:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7953              		.loc 1 2903 0
 7954 45c0 FEFFFFEB 		bl	CyU3PSetEpConfig
 7955              	.LVL716:
2904:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7956              		.loc 1 2904 0
 7957 45c4 002050E2 		subs	r2, r0, #0
 7958 45c8 4F00001A 		bne	.L698
 7959 45cc B8779FE5 		ldr	r7, .L727+116
 7960              	.LBE227:
 7961              	.LBE224:
3027:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7962              		.loc 1 3027 0
 7963 45d0 54579FE5 		ldr	r5, .L727+20
 7964 45d4 0260A0E1 		mov	r6, r2
3216:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7965              		.loc 1 3216 0
 7966 45d8 0080E0E3 		mvn	r8, #0
 7967              	.LVL717:
 7968              	.L649:
3027:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7969              		.loc 1 3027 0
 7970 45dc 48079FE5 		ldr	r0, .L727+20
 7971 45e0 0110A0E3 		mov	r1, #1
 7972 45e4 0220A0E3 		mov	r2, #2
 7973 45e8 B4308DE2 		add	r3, sp, #180
 7974 45ec 00608DE5 		str	r6, [sp, #0]
 7975 45f0 FEFFFFEB 		bl	_txe_event_flags_get
 7976 45f4 000050E3 		cmp	r0, #0
 7977 45f8 3000001A 		bne	.L651
3073:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7978              		.loc 1 3073 0
 7979 45fc 3CE095E5 		ldr	lr, [r5, #60]
 7980 4600 00005EE3 		cmp	lr, #0
 7981 4604 0300000A 		beq	.L652
3073:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7982              		.loc 1 3073 0 is_stmt 0 discriminator 1
 7983 4608 B014D5E1 		ldrh	r1, [r5, #64]
 7984 460c B234D5E1 		ldrh	r3, [r5, #66]
 7985 4610 030051E1 		cmp	r1, r3
 7986 4614 1201000A 		beq	.L716
 7987              	.L652:
3277:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7988              		.loc 1 3277 0 is_stmt 1
 7989 4618 4010A0E3 		mov	r1, #64
 7990 461c 0020A0E3 		mov	r2, #0
 7991 4620 04079FE5 		ldr	r0, .L727+20
 7992 4624 FEFFFFEB 		bl	_txe_event_flags_set
3280:../uvc.c      ****         CyU3PThreadRelinquish ();
 7993              		.loc 1 3280 0
 7994 4628 FEFFFFEB 		bl	_txe_thread_relinquish
3281:../uvc.c      ****     }
 7995              		.loc 1 3281 0
 7996 462c EAFFFFEA 		b	.L649
 7997              	.LVL718:
 7998              	.L701:
 7999              	.LBB262:
 8000              	.LBB226:
2576:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 8001              		.loc 1 2576 0
 8002 4630 0400A0E3 		mov	r0, #4
 8003              	.LVL719:
 8004 4634 54179FE5 		ldr	r1, .L727+120
 8005 4638 FEFFFFEB 		bl	CyU3PDebugPrint
 8006              	.LVL720:
 8007              	.L618:
 8008              	.LBB242:
 8009              	.LBB243:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8010              		.loc 1 2005 0
 8011 463c 50179FE5 		ldr	r1, .L727+124
 8012 4640 0400A0E3 		mov	r0, #4
 8013 4644 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8014              		.loc 1 2006 0
 8015 4648 FA0FA0E3 		mov	r0, #1000
 8016 464c FEFFFFEB 		bl	_tx_thread_sleep
 8017 4650 F9FFFFEA 		b	.L618
 8018              	.LVL721:
 8019              	.L703:
 8020              	.LBE243:
 8021              	.LBE242:
2607:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 8022              		.loc 1 2607 0
 8023 4654 0400A0E3 		mov	r0, #4
 8024              	.LVL722:
 8025 4658 38179FE5 		ldr	r1, .L727+128
 8026 465c FEFFFFEB 		bl	CyU3PDebugPrint
 8027              	.LVL723:
 8028              	.L622:
 8029              	.LBB240:
 8030              	.LBB241:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8031              		.loc 1 2005 0
 8032 4660 2C179FE5 		ldr	r1, .L727+124
 8033 4664 0400A0E3 		mov	r0, #4
 8034 4668 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8035              		.loc 1 2006 0
 8036 466c FA0FA0E3 		mov	r0, #1000
 8037 4670 FEFFFFEB 		bl	_tx_thread_sleep
 8038 4674 F9FFFFEA 		b	.L622
 8039              	.LVL724:
 8040              	.L702:
 8041              	.LBE241:
 8042              	.LBE240:
2598:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 8043              		.loc 1 2598 0
 8044 4678 0400A0E3 		mov	r0, #4
 8045              	.LVL725:
 8046 467c 18179FE5 		ldr	r1, .L727+132
 8047 4680 FEFFFFEB 		bl	CyU3PDebugPrint
 8048              	.LVL726:
 8049              	.L620:
 8050              	.LBB238:
 8051              	.LBB239:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8052              		.loc 1 2005 0
 8053 4684 08179FE5 		ldr	r1, .L727+124
 8054 4688 0400A0E3 		mov	r0, #4
 8055 468c FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8056              		.loc 1 2006 0
 8057 4690 FA0FA0E3 		mov	r0, #1000
 8058 4694 FEFFFFEB 		bl	_tx_thread_sleep
 8059 4698 F9FFFFEA 		b	.L620
 8060              	.LVL727:
 8061              	.L704:
 8062              	.LBE239:
 8063              	.LBE238:
2613:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 8064              		.loc 1 2613 0
 8065 469c 0400A0E3 		mov	r0, #4
 8066              	.LVL728:
 8067 46a0 F8169FE5 		ldr	r1, .L727+136
 8068 46a4 FEFFFFEB 		bl	CyU3PDebugPrint
 8069              	.LVL729:
 8070              	.L624:
 8071              	.LBB236:
 8072              	.LBB237:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8073              		.loc 1 2005 0
 8074 46a8 E4169FE5 		ldr	r1, .L727+124
 8075 46ac 0400A0E3 		mov	r0, #4
 8076 46b0 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8077              		.loc 1 2006 0
 8078 46b4 FA0FA0E3 		mov	r0, #1000
 8079 46b8 FEFFFFEB 		bl	_tx_thread_sleep
 8080 46bc F9FFFFEA 		b	.L624
 8081              	.LVL730:
 8082              	.L651:
 8083              	.LBE237:
 8084              	.LBE236:
 8085              	.LBE226:
 8086              	.LBE262:
3184:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 8087              		.loc 1 3184 0
 8088 46c0 64069FE5 		ldr	r0, .L727+20
 8089 46c4 0210A0E3 		mov	r1, #2
 8090 46c8 0320A0E3 		mov	r2, #3
 8091 46cc B4308DE2 		add	r3, sp, #180
 8092 46d0 00608DE5 		str	r6, [sp, #0]
 8093 46d4 FEFFFFEB 		bl	_txe_event_flags_get
 8094 46d8 000050E3 		cmp	r0, #0
 8095 46dc 2500001A 		bne	.L674
3199:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8096              		.loc 1 3199 0
 8097 46e0 441095E5 		ldr	r1, [r5, #68]
3187:../uvc.c      ****                 hitFV     = CyFalse;
 8098              		.loc 1 3187 0
 8099 46e4 3C6085E5 		str	r6, [r5, #60]
3199:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8100              		.loc 1 3199 0
 8101 46e8 000051E3 		cmp	r1, #0
3188:../uvc.c      ****                 prodCount = 0;
 8102              		.loc 1 3188 0
 8103 46ec B064C5E1 		strh	r6, [r5, #64]	@ movhi
3195:../uvc.c      ****                 fb=0;
 8104              		.loc 1 3195 0
 8105 46f0 B463C5E1 		strh	r6, [r5, #52]	@ movhi
3189:../uvc.c      ****                 consCount = 0;
 8106              		.loc 1 3189 0
 8107 46f4 B264C5E1 		strh	r6, [r5, #66]	@ movhi
3196:../uvc.c      ****                 pb=0;
 8108              		.loc 1 3196 0
 8109 46f8 B663C5E1 		strh	r6, [r5, #54]	@ movhi
3197:../uvc.c      ****                 pbc=0;
 8110              		.loc 1 3197 0
 8111 46fc B863C5E1 		strh	r6, [r5, #56]	@ movhi
3199:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8112              		.loc 1 3199 0
 8113 4700 0A00000A 		beq	.L717
 8114              	.L675:
3211:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 8115              		.loc 1 3211 0
 8116 4704 446084E5 		str	r6, [r4, #68]
 8117 4708 C2FFFFEA 		b	.L652
 8118              	.LVL731:
 8119              	.L698:
 8120              	.LBB263:
 8121              	.LBB260:
2907:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8122              		.loc 1 2907 0
 8123 470c 0400A0E3 		mov	r0, #4
 8124              	.LVL732:
 8125 4710 8C169FE5 		ldr	r1, .L727+140
 8126 4714 FEFFFFEB 		bl	CyU3PDebugPrint
 8127              	.LVL733:
 8128              	.L650:
 8129              	.LBB244:
 8130              	.LBB245:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8131              		.loc 1 2005 0
 8132 4718 74169FE5 		ldr	r1, .L727+124
 8133 471c 0400A0E3 		mov	r0, #4
 8134 4720 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8135              		.loc 1 2006 0
 8136 4724 FA0FA0E3 		mov	r0, #1000
 8137 4728 FEFFFFEB 		bl	_tx_thread_sleep
 8138 472c F9FFFFEA 		b	.L650
 8139              	.LVL734:
 8140              	.L717:
 8141              	.LBE245:
 8142              	.LBE244:
 8143              	.LBE260:
 8144              	.LBE263:
3201:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8145              		.loc 1 3201 0
 8146 4730 50069FE5 		ldr	r0, .L727+112
 8147 4734 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8148              	.LVL735:
3202:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8149              		.loc 1 3202 0
 8150 4738 000050E3 		cmp	r0, #0
 8151 473c 0200001A 		bne	.L699
3208:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8152              		.loc 1 3208 0
 8153 4740 8300A0E3 		mov	r0, #131
 8154              	.LVL736:
 8155 4744 FEFFFFEB 		bl	CyU3PUsbFlushEp
 8156 4748 EDFFFFEA 		b	.L675
 8157              	.L699:
 8158              	.LBB264:
 8159              	.LBB265:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8160              		.loc 1 2005 0
 8161 474c 40169FE5 		ldr	r1, .L727+124
 8162 4750 0400A0E3 		mov	r0, #4
 8163 4754 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8164              		.loc 1 2006 0
 8165 4758 FA0FA0E3 		mov	r0, #1000
 8166 475c FEFFFFEB 		bl	_tx_thread_sleep
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8167              		.loc 1 2005 0
 8168 4760 2C169FE5 		ldr	r1, .L727+124
 8169 4764 0400A0E3 		mov	r0, #4
 8170 4768 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8171              		.loc 1 2006 0
 8172 476c FA0FA0E3 		mov	r0, #1000
 8173 4770 FEFFFFEB 		bl	_tx_thread_sleep
 8174 4774 F4FFFFEA 		b	.L699
 8175              	.L674:
 8176              	.LBE265:
 8177              	.LBE264:
3216:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8178              		.loc 1 3216 0
 8179 4778 0110A0E3 		mov	r1, #1
 8180 477c 0220A0E3 		mov	r2, #2
 8181 4780 B4308DE2 		add	r3, sp, #180
 8182 4784 A0059FE5 		ldr	r0, .L727+20
 8183 4788 00808DE5 		str	r8, [sp, #0]
 8184 478c FEFFFFEB 		bl	_txe_event_flags_get
3220:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8185              		.loc 1 3220 0
 8186 4790 0620A0E1 		mov	r2, r6
 8187 4794 EC059FE5 		ldr	r0, .L727+112
 8188 4798 0610A0E1 		mov	r1, r6
 8189 479c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8190              	.LVL737:
3221:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8191              		.loc 1 3221 0
 8192 47a0 002050E2 		subs	r2, r0, #0
 8193 47a4 6500001A 		bne	.L718
3229:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8194              		.loc 1 3229 0
 8195 47a8 280095E5 		ldr	r0, [r5, #40]
 8196              	.LVL738:
 8197 47ac 000050E3 		cmp	r0, #0
 8198 47b0 5A00001A 		bne	.L680
 8199              	.LVL739:
 8200              	.LBB266:
 8201              	.LBB267:
2932:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8202              		.loc 1 2932 0
 8203 47b4 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 8204 47b8 030053E3 		cmp	r3, #3
 8205 47bc 4700000A 		beq	.L719
2937:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8206              		.loc 1 2937 0
 8207 47c0 020053E3 		cmp	r3, #2
 8208 47c4 2900000A 		beq	.L720
 8209              	.LVL740:
 8210              	.L683:
 8211              	.LBE267:
 8212              	.LBE266:
3265:../uvc.c      ****                     gpif_initialized = CyTrue;
 8213              		.loc 1 3265 0
 8214 47c8 0120A0E3 		mov	r2, #1
 8215 47cc 282084E5 		str	r2, [r4, #40]
3266:../uvc.c      ****                     CyU3PThreadSleep(200);
 8216              		.loc 1 3266 0
 8217 47d0 C800A0E3 		mov	r0, #200
 8218 47d4 FEFFFFEB 		bl	_tx_thread_sleep
 8219 47d8 8EFFFFEA 		b	.L652
 8220              	.LVL741:
 8221              	.L715:
 8222              	.LBB273:
 8223              	.LBB225:
2882:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 8224              		.loc 1 2882 0
 8225 47dc 0400A0E3 		mov	r0, #4
 8226              	.LVL742:
 8227 47e0 C0159FE5 		ldr	r1, .L727+144
 8228 47e4 FEFFFFEB 		bl	CyU3PDebugPrint
 8229              	.LVL743:
 8230              	.L646:
 8231              	.LBB234:
 8232              	.LBB235:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8233              		.loc 1 2005 0
 8234 47e8 A4159FE5 		ldr	r1, .L727+124
 8235 47ec 0400A0E3 		mov	r0, #4
 8236 47f0 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8237              		.loc 1 2006 0
 8238 47f4 FA0FA0E3 		mov	r0, #1000
 8239 47f8 FEFFFFEB 		bl	_tx_thread_sleep
 8240 47fc F9FFFFEA 		b	.L646
 8241              	.LVL744:
 8242              	.L714:
 8243              	.LBE235:
 8244              	.LBE234:
2791:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 8245              		.loc 1 2791 0
 8246 4800 0400A0E3 		mov	r0, #4
 8247              	.LVL745:
 8248 4804 A0159FE5 		ldr	r1, .L727+148
 8249 4808 FEFFFFEB 		bl	CyU3PDebugPrint
 8250              	.LVL746:
 8251              	.L644:
 8252              	.LBB232:
 8253              	.LBB233:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8254              		.loc 1 2005 0
 8255 480c 80159FE5 		ldr	r1, .L727+124
 8256 4810 0400A0E3 		mov	r0, #4
 8257 4814 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8258              		.loc 1 2006 0
 8259 4818 FA0FA0E3 		mov	r0, #1000
 8260 481c FEFFFFEB 		bl	_tx_thread_sleep
 8261 4820 F9FFFFEA 		b	.L644
 8262              	.LVL747:
 8263              	.L713:
 8264              	.LBE233:
 8265              	.LBE232:
2767:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 8266              		.loc 1 2767 0
 8267 4824 040080E2 		add	r0, r0, #4
 8268 4828 80159FE5 		ldr	r1, .L727+152
 8269 482c FEFFFFEB 		bl	CyU3PDebugPrint
 8270              	.LVL748:
 8271              	.L642:
 8272              	.LBB230:
 8273              	.LBB231:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8274              		.loc 1 2005 0
 8275 4830 5C159FE5 		ldr	r1, .L727+124
 8276 4834 0400A0E3 		mov	r0, #4
 8277 4838 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8278              		.loc 1 2006 0
 8279 483c FA0FA0E3 		mov	r0, #1000
 8280 4840 FEFFFFEB 		bl	_tx_thread_sleep
 8281 4844 F9FFFFEA 		b	.L642
 8282              	.LVL749:
 8283              	.L712:
 8284              	.LBE231:
 8285              	.LBE230:
2760:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 8286              		.loc 1 2760 0
 8287 4848 0400A0E3 		mov	r0, #4
 8288 484c 60159FE5 		ldr	r1, .L727+156
 8289 4850 0620A0E1 		mov	r2, r6
 8290 4854 FEFFFFEB 		bl	CyU3PDebugPrint
 8291              	.L640:
 8292              	.LBB228:
 8293              	.LBB229:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8294              		.loc 1 2005 0
 8295 4858 34159FE5 		ldr	r1, .L727+124
 8296 485c 0400A0E3 		mov	r0, #4
 8297 4860 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8298              		.loc 1 2006 0
 8299 4864 FA0FA0E3 		mov	r0, #1000
 8300 4868 FEFFFFEB 		bl	_tx_thread_sleep
 8301 486c F9FFFFEA 		b	.L640
 8302              	.LVL750:
 8303              	.L720:
 8304              	.LBE229:
 8305              	.LBE228:
 8306              	.LBE225:
 8307              	.LBE273:
 8308              	.LBB274:
 8309              	.LBB272:
2939:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8310              		.loc 1 2939 0
 8311 4870 40159FE5 		ldr	r1, .L727+160
 8312 4874 0100A0E3 		mov	r0, #1
 8313 4878 FEFFFFEB 		bl	CyU3PDebugPrint
 8314              	.LVL751:
2940:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8315              		.loc 1 2940 0
 8316 487c 38059FE5 		ldr	r0, .L727+164
 8317 4880 FEFFFFEB 		bl	CyU3PGpifLoad
 8318 4884 0020A0E1 		mov	r2, r0
 8319              	.LVL752:
 8320              	.L682:
2942:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8321              		.loc 1 2942 0
 8322 4888 000052E3 		cmp	r2, #0
 8323 488c 1A00001A 		bne	.L721
2950:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8324              		.loc 1 2950 0
 8325 4890 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 8326 4894 030053E3 		cmp	r3, #3
 8327 4898 0100000A 		beq	.L700
2954:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8328              		.loc 1 2954 0
 8329 489c 020053E3 		cmp	r3, #2
 8330 48a0 C8FFFF1A 		bne	.L683
 8331              	.L700:
2956:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8332              		.loc 1 2956 0
 8333 48a4 0200A0E1 		mov	r0, r2
 8334              	.LVL753:
 8335 48a8 0210A0E1 		mov	r1, r2
 8336 48ac FEFFFFEB 		bl	CyU3PGpifSMStart
 8337              	.LVL754:
2958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8338              		.loc 1 2958 0
 8339 48b0 000050E3 		cmp	r0, #0
2956:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8340              		.loc 1 2956 0
 8341 48b4 0020A0E1 		mov	r2, r0
 8342              	.LVL755:
2958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8343              		.loc 1 2958 0
 8344 48b8 C2FFFF0A 		beq	.L683
2961:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8345              		.loc 1 2961 0
 8346 48bc 0400A0E3 		mov	r0, #4
 8347              	.LVL756:
 8348 48c0 F8149FE5 		ldr	r1, .L727+168
 8349 48c4 FEFFFFEB 		bl	CyU3PDebugPrint
 8350              	.LVL757:
 8351              	.L688:
 8352              	.LBB268:
 8353              	.LBB269:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8354              		.loc 1 2005 0
 8355 48c8 C4149FE5 		ldr	r1, .L727+124
 8356 48cc 0400A0E3 		mov	r0, #4
 8357 48d0 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8358              		.loc 1 2006 0
 8359 48d4 FA0FA0E3 		mov	r0, #1000
 8360 48d8 FEFFFFEB 		bl	_tx_thread_sleep
 8361 48dc F9FFFFEA 		b	.L688
 8362              	.LVL758:
 8363              	.L719:
 8364              	.LBE269:
 8365              	.LBE268:
2934:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 8366              		.loc 1 2934 0
 8367 48e0 DC149FE5 		ldr	r1, .L727+172
 8368 48e4 0100A0E3 		mov	r0, #1
 8369 48e8 FEFFFFEB 		bl	CyU3PDebugPrint
 8370              	.LVL759:
2935:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 8371              		.loc 1 2935 0
 8372 48ec D4049FE5 		ldr	r0, .L727+176
 8373 48f0 FEFFFFEB 		bl	CyU3PGpifLoad
 8374 48f4 0020A0E1 		mov	r2, r0
 8375              	.LVL760:
 8376 48f8 E2FFFFEA 		b	.L682
 8377              	.L721:
2945:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 8378              		.loc 1 2945 0
 8379 48fc 0400A0E3 		mov	r0, #4
 8380              	.LVL761:
 8381 4900 C4149FE5 		ldr	r1, .L727+180
 8382 4904 FEFFFFEB 		bl	CyU3PDebugPrint
 8383              	.LVL762:
 8384              	.L685:
 8385              	.LBB270:
 8386              	.LBB271:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8387              		.loc 1 2005 0
 8388 4908 84149FE5 		ldr	r1, .L727+124
 8389 490c 0400A0E3 		mov	r0, #4
 8390 4910 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8391              		.loc 1 2006 0
 8392 4914 FA0FA0E3 		mov	r0, #1000
 8393 4918 FEFFFFEB 		bl	_tx_thread_sleep
 8394 491c F9FFFFEA 		b	.L685
 8395              	.LVL763:
 8396              	.L680:
 8397              	.LBE271:
 8398              	.LBE270:
 8399              	.LBE272:
 8400              	.LBE274:
3273:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8401              		.loc 1 3273 0
 8402 4920 54049FE5 		ldr	r0, .L727+100
 8403 4924 02C0A0E3 		mov	ip, #2
 8404 4928 0610A0E1 		mov	r1, r6
 8405 492c 0020A0E1 		mov	r2, r0
 8406              	.LVL764:
 8407 4930 0630A0E1 		mov	r3, r6
 8408 4934 00C08DE5 		str	ip, [sp, #0]
 8409 4938 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8410 493c 35FFFFEA 		b	.L652
 8411              	.LVL765:
 8412              	.L718:
3224:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 8413              		.loc 1 3224 0
 8414 4940 0400A0E3 		mov	r0, #4
 8415              	.LVL766:
 8416 4944 84149FE5 		ldr	r1, .L727+184
 8417 4948 FEFFFFEB 		bl	CyU3PDebugPrint
 8418              	.LVL767:
 8419              	.L679:
 8420              	.LBB275:
 8421              	.LBB276:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8422              		.loc 1 2005 0
 8423 494c 40149FE5 		ldr	r1, .L727+124
 8424 4950 0400A0E3 		mov	r0, #4
 8425 4954 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8426              		.loc 1 2006 0
 8427 4958 FA0FA0E3 		mov	r0, #1000
 8428 495c FEFFFFEB 		bl	_tx_thread_sleep
 8429 4960 F9FFFFEA 		b	.L679
 8430              	.LVL768:
 8431              	.L711:
 8432              	.LBE276:
 8433              	.LBE275:
 8434              	.LBB277:
 8435              	.LBB261:
2739:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8436              		.loc 1 2739 0
 8437 4964 0400A0E3 		mov	r0, #4
 8438              	.LVL769:
 8439 4968 34149FE5 		ldr	r1, .L727+140
 8440 496c 0320A0E1 		mov	r2, r3
 8441 4970 FEFFFFEB 		bl	CyU3PDebugPrint
 8442              	.LVL770:
 8443              	.L638:
 8444              	.LBB246:
 8445              	.LBB247:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8446              		.loc 1 2005 0
 8447 4974 18149FE5 		ldr	r1, .L727+124
 8448 4978 0400A0E3 		mov	r0, #4
 8449 497c FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8450              		.loc 1 2006 0
 8451 4980 FA0FA0E3 		mov	r0, #1000
 8452 4984 FEFFFFEB 		bl	_tx_thread_sleep
 8453 4988 F9FFFFEA 		b	.L638
 8454              	.LVL771:
 8455              	.L710:
 8456              	.LBE247:
 8457              	.LBE246:
2694:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8458              		.loc 1 2694 0
 8459 498c 0400A0E3 		mov	r0, #4
 8460              	.LVL772:
 8461 4990 3C149FE5 		ldr	r1, .L727+188
 8462 4994 FEFFFFEB 		bl	CyU3PDebugPrint
 8463              	.LVL773:
 8464              	.L636:
 8465              	.LBB248:
 8466              	.LBB249:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8467              		.loc 1 2005 0
 8468 4998 F4139FE5 		ldr	r1, .L727+124
 8469 499c 0400A0E3 		mov	r0, #4
 8470 49a0 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8471              		.loc 1 2006 0
 8472 49a4 FA0FA0E3 		mov	r0, #1000
 8473 49a8 FEFFFFEB 		bl	_tx_thread_sleep
 8474 49ac F9FFFFEA 		b	.L636
 8475              	.LVL774:
 8476              	.L709:
 8477              	.LBE249:
 8478              	.LBE248:
2673:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8479              		.loc 1 2673 0
 8480 49b0 0400A0E3 		mov	r0, #4
 8481              	.LVL775:
 8482 49b4 1C149FE5 		ldr	r1, .L727+192
 8483 49b8 FEFFFFEB 		bl	CyU3PDebugPrint
 8484              	.LVL776:
 8485              	.L634:
 8486              	.LBB250:
 8487              	.LBB251:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8488              		.loc 1 2005 0
 8489 49bc D0139FE5 		ldr	r1, .L727+124
 8490 49c0 0400A0E3 		mov	r0, #4
 8491 49c4 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8492              		.loc 1 2006 0
 8493 49c8 FA0FA0E3 		mov	r0, #1000
 8494 49cc FEFFFFEB 		bl	_tx_thread_sleep
 8495 49d0 F9FFFFEA 		b	.L634
 8496              	.LVL777:
 8497              	.L708:
 8498              	.LBE251:
 8499              	.LBE250:
2660:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 8500              		.loc 1 2660 0
 8501 49d4 0400A0E3 		mov	r0, #4
 8502              	.LVL778:
 8503 49d8 FC139FE5 		ldr	r1, .L727+196
 8504 49dc FEFFFFEB 		bl	CyU3PDebugPrint
 8505              	.LVL779:
 8506              	.L632:
 8507              	.LBB252:
 8508              	.LBB253:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8509              		.loc 1 2005 0
 8510 49e0 AC139FE5 		ldr	r1, .L727+124
 8511 49e4 0400A0E3 		mov	r0, #4
 8512 49e8 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8513              		.loc 1 2006 0
 8514 49ec FA0FA0E3 		mov	r0, #1000
 8515 49f0 FEFFFFEB 		bl	_tx_thread_sleep
 8516 49f4 F9FFFFEA 		b	.L632
 8517              	.LVL780:
 8518              	.L706:
 8519              	.LBE253:
 8520              	.LBE252:
2632:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 8521              		.loc 1 2632 0
 8522 49f8 0400A0E3 		mov	r0, #4
 8523              	.LVL781:
 8524 49fc DC139FE5 		ldr	r1, .L727+200
 8525 4a00 FEFFFFEB 		bl	CyU3PDebugPrint
 8526              	.LVL782:
 8527              	.L628:
 8528              	.LBB254:
 8529              	.LBB255:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8530              		.loc 1 2005 0
 8531 4a04 88139FE5 		ldr	r1, .L727+124
 8532 4a08 0400A0E3 		mov	r0, #4
 8533 4a0c FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8534              		.loc 1 2006 0
 8535 4a10 FA0FA0E3 		mov	r0, #1000
 8536 4a14 FEFFFFEB 		bl	_tx_thread_sleep
 8537 4a18 F9FFFFEA 		b	.L628
 8538              	.LVL783:
 8539              	.L705:
 8540              	.LBE255:
 8541              	.LBE254:
2619:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 8542              		.loc 1 2619 0
 8543 4a1c 0400A0E3 		mov	r0, #4
 8544              	.LVL784:
 8545 4a20 BC139FE5 		ldr	r1, .L727+204
 8546 4a24 FEFFFFEB 		bl	CyU3PDebugPrint
 8547              	.LVL785:
 8548              	.L626:
 8549              	.LBB256:
 8550              	.LBB257:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8551              		.loc 1 2005 0
 8552 4a28 64139FE5 		ldr	r1, .L727+124
 8553 4a2c 0400A0E3 		mov	r0, #4
 8554 4a30 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8555              		.loc 1 2006 0
 8556 4a34 FA0FA0E3 		mov	r0, #1000
 8557 4a38 FEFFFFEB 		bl	_tx_thread_sleep
 8558 4a3c F9FFFFEA 		b	.L626
 8559              	.LVL786:
 8560              	.L707:
 8561              	.LBE257:
 8562              	.LBE256:
2646:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 8563              		.loc 1 2646 0
 8564 4a40 0400A0E3 		mov	r0, #4
 8565              	.LVL787:
 8566 4a44 9C139FE5 		ldr	r1, .L727+208
 8567 4a48 FEFFFFEB 		bl	CyU3PDebugPrint
 8568              	.LVL788:
 8569              	.L630:
 8570              	.LBB258:
 8571              	.LBB259:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8572              		.loc 1 2005 0
 8573 4a4c 40139FE5 		ldr	r1, .L727+124
 8574 4a50 0400A0E3 		mov	r0, #4
 8575 4a54 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8576              		.loc 1 2006 0
 8577 4a58 FA0FA0E3 		mov	r0, #1000
 8578 4a5c FEFFFFEB 		bl	_tx_thread_sleep
 8579 4a60 F9FFFFEA 		b	.L630
 8580              	.LVL789:
 8581              	.L716:
 8582              	.LBE259:
 8583              	.LBE258:
 8584              	.LBE261:
 8585              	.LBE277:
3083:../uvc.c      ****                 prodCount = 0;
 8586              		.loc 1 3083 0
 8587 4a64 B064C5E1 		strh	r6, [r5, #64]	@ movhi
3098:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8588              		.loc 1 3098 0
 8589 4a68 08039FE5 		ldr	r0, .L727+96
3084:../uvc.c      ****                 consCount = 0;
 8590              		.loc 1 3084 0
 8591 4a6c B264C5E1 		strh	r6, [r5, #66]	@ movhi
3098:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8592              		.loc 1 3098 0
 8593 4a70 0010E0E3 		mvn	r1, #0
3080:../uvc.c      ****             	fb=0;
 8594              		.loc 1 3080 0
 8595 4a74 B463C5E1 		strh	r6, [r5, #52]	@ movhi
3081:../uvc.c      ****             	pb=0;
 8596              		.loc 1 3081 0
 8597 4a78 B663C5E1 		strh	r6, [r5, #54]	@ movhi
3082:../uvc.c      ****             	pbc=0;
 8598              		.loc 1 3082 0
 8599 4a7c B863C5E1 		strh	r6, [r5, #56]	@ movhi
3085:../uvc.c      ****                 hitFV     = CyFalse;
 8600              		.loc 1 3085 0
 8601 4a80 3C6085E5 		str	r6, [r5, #60]
3098:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8602              		.loc 1 3098 0
 8603 4a84 FEFFFFEB 		bl	_txe_mutex_get
3099:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 8604              		.loc 1 3099 0
 8605 4a88 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 8606 4a8c 012020E2 		eor	r2, r0, #1
 8607 4a90 8124C7E5 		strb	r2, [r7, #1153]
3101:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8608              		.loc 1 3101 0
 8609 4a94 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 8610 4a98 F0005CE3 		cmp	ip, #240
 8611 4a9c 1800000A 		beq	.L722
 8612              	.L653:
3109:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 8613              		.loc 1 3109 0
 8614 4aa0 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 8615 4aa4 FF005AE3 		cmp	sl, #255
 8616 4aa8 4000000A 		beq	.L723
3121:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 8617              		.loc 1 3121 0
 8618 4aac 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 8619 4ab0 AA0050E3 		cmp	r0, #170
 8620 4ab4 2F00000A 		beq	.L724
 8621              	.L654:
3159:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 8622              		.loc 1 3159 0
 8623 4ab8 B8029FE5 		ldr	r0, .L727+96
 8624 4abc FEFFFFEB 		bl	_txe_mutex_put
3161:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8625              		.loc 1 3161 0
 8626 4ac0 C0029FE5 		ldr	r0, .L727+112
 8627 4ac4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8628              	.LVL790:
3162:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8629              		.loc 1 3162 0
 8630 4ac8 002050E2 		subs	r2, r0, #0
 8631 4acc 2000001A 		bne	.L725
3169:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8632              		.loc 1 3169 0
 8633 4ad0 0210A0E1 		mov	r1, r2
 8634 4ad4 AC029FE5 		ldr	r0, .L727+112
 8635              	.LVL791:
 8636 4ad8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8637              	.LVL792:
3170:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8638              		.loc 1 3170 0
 8639 4adc 002050E2 		subs	r2, r0, #0
 8640 4ae0 1200001A 		bne	.L726
3178:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8641              		.loc 1 3178 0
 8642 4ae4 90029FE5 		ldr	r0, .L727+100
 8643              	.LVL793:
 8644 4ae8 0210A0E1 		mov	r1, r2
 8645 4aec 02A0A0E3 		mov	sl, #2
 8646 4af0 0020A0E1 		mov	r2, r0
 8647              	.LVL794:
 8648 4af4 0130A0E1 		mov	r3, r1
 8649 4af8 00A08DE5 		str	sl, [sp, #0]
 8650 4afc FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8651              	.LVL795:
 8652 4b00 C4FEFFEA 		b	.L652
 8653              	.L722:
3101:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8654              		.loc 1 3101 0 discriminator 1
 8655 4b04 20029FE5 		ldr	r0, .L727+20
 8656 4b08 8010A0E3 		mov	r1, #128
 8657 4b0c 0320A0E3 		mov	r2, #3
 8658 4b10 B4308DE2 		add	r3, sp, #180
 8659 4b14 00608DE5 		str	r6, [sp, #0]
 8660 4b18 FEFFFFEB 		bl	_txe_event_flags_get
 8661 4b1c 000050E3 		cmp	r0, #0
3106:../uvc.c      ****                 		stiflag = 0xFF;
 8662              		.loc 1 3106 0 discriminator 1
 8663 4b20 3A80C505 		streqb	r8, [r5, #58]
3107:../uvc.c      ****                 		IMcount = 0;
 8664              		.loc 1 3107 0 discriminator 1
 8665 4b24 E160C505 		streqb	r6, [r5, #225]
3101:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8666              		.loc 1 3101 0 discriminator 1
 8667 4b28 E2FFFF0A 		beq	.L654
 8668 4b2c DBFFFFEA 		b	.L653
 8669              	.LVL796:
 8670              	.L726:
3172:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8671              		.loc 1 3172 0
 8672 4b30 0400A0E3 		mov	r0, #4
 8673              	.LVL797:
 8674 4b34 B0129FE5 		ldr	r1, .L727+212
 8675 4b38 FEFFFFEB 		bl	CyU3PDebugPrint
 8676              	.LVL798:
 8677              	.L673:
 8678              	.LBB278:
 8679              	.LBB279:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8680              		.loc 1 2005 0
 8681 4b3c 50129FE5 		ldr	r1, .L727+124
 8682 4b40 0400A0E3 		mov	r0, #4
 8683 4b44 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8684              		.loc 1 2006 0
 8685 4b48 FA0FA0E3 		mov	r0, #1000
 8686 4b4c FEFFFFEB 		bl	_tx_thread_sleep
 8687 4b50 F9FFFFEA 		b	.L673
 8688              	.LVL799:
 8689              	.L725:
 8690              	.LBE279:
 8691              	.LBE278:
3164:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 8692              		.loc 1 3164 0
 8693 4b54 0400A0E3 		mov	r0, #4
 8694              	.LVL800:
 8695 4b58 90129FE5 		ldr	r1, .L727+216
 8696 4b5c FEFFFFEB 		bl	CyU3PDebugPrint
 8697              	.LVL801:
 8698              	.L671:
 8699              	.LBB280:
 8700              	.LBB281:
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8701              		.loc 1 2005 0
 8702 4b60 2C129FE5 		ldr	r1, .L727+124
 8703 4b64 0400A0E3 		mov	r0, #4
 8704 4b68 FEFFFFEB 		bl	CyU3PDebugPrint
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
 8705              		.loc 1 2006 0
 8706 4b6c FA0FA0E3 		mov	r0, #1000
 8707 4b70 FEFFFFEB 		bl	_tx_thread_sleep
 8708 4b74 F9FFFFEA 		b	.L671
 8709              	.L724:
 8710              	.LBE281:
 8711              	.LBE280:
3127:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 8712              		.loc 1 3127 0
 8713 4b78 E1E0D5E5 		ldrb	lr, [r5, #225]	@ zero_extendqisi2
 8714 4b7c 01A08EE2 		add	sl, lr, #1
 8715 4b80 02005EE3 		cmp	lr, #2
 8716 4b84 E1A0C5E5 		strb	sl, [r5, #225]
 8717 4b88 CAFFFF9A 		bls	.L654
3129:../uvc.c      ****                     switch (setRes)
 8718              		.loc 1 3129 0
 8719 4b8c BD30D5E5 		ldrb	r3, [r5, #189]	@ zero_extendqisi2
 8720 4b90 011043E2 		sub	r1, r3, #1
 8721 4b94 030051E3 		cmp	r1, #3
 8722 4b98 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 8723 4b9c 230000EA 		b	.L656
 8724              	.L661:
 8725 4ba0 904C0000 		.word	.L657
 8726 4ba4 D44C0000 		.word	.L658
 8727 4ba8 3C4C0000 		.word	.L659
 8728 4bac E04B0000 		.word	.L660
 8729              	.L723:
3111:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8730              		.loc 1 3111 0
 8731 4bb0 E110D5E5 		ldrb	r1, [r5, #225]	@ zero_extendqisi2
 8732 4bb4 01E081E2 		add	lr, r1, #1
 8733 4bb8 020051E3 		cmp	r1, #2
 8734 4bbc E1E0C5E5 		strb	lr, [r5, #225]
 8735 4bc0 BCFFFF9A 		bls	.L654
3112:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8736              		.loc 1 3112 0
 8737 4bc4 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
3113:../uvc.c      ****                 		stiflag = 0x0F;
 8738              		.loc 1 3113 0
 8739 4bc8 0F30A0E3 		mov	r3, #15
3112:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8740              		.loc 1 3112 0
 8741 4bcc 20C082E3 		orr	ip, r2, #32
 8742 4bd0 81C4C7E5 		strb	ip, [r7, #1153]
3114:../uvc.c      ****                 		IMcount = 0;
 8743              		.loc 1 3114 0
 8744 4bd4 E160C5E5 		strb	r6, [r5, #225]
3113:../uvc.c      ****                 		stiflag = 0x0F;
 8745              		.loc 1 3113 0
 8746 4bd8 3A30C5E5 		strb	r3, [r5, #58]
 8747 4bdc B5FFFFEA 		b	.L654
 8748              	.L660:
3147:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8749              		.loc 1 3147 0
 8750 4be0 58E094E5 		ldr	lr, [r4, #88]
 8751 4be4 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8752 4be8 00005EE3 		cmp	lr, #0
 8753 4bec F4E0A003 		moveq	lr, #244
 8754 4bf0 74E0A013 		movne	lr, #116
 8755 4bf4 03208EE1 		orr	r2, lr, r3
 8756 4bf8 3010A0E3 		mov	r1, #48
 8757 4bfc 5230A0E3 		mov	r3, #82
 8758 4c00 0100A0E3 		mov	r0, #1
 8759 4c04 FEFFFFEB 		bl	SensorSetIrisControl
3149:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8760              		.loc 1 3149 0
 8761 4c08 58C094E5 		ldr	ip, [r4, #88]
 8762 4c0c 8C24D7E5 		ldrb	r2, [r7, #1164]	@ zero_extendqisi2
 8763 4c10 00005CE3 		cmp	ip, #0
 8764 4c14 F4C0A003 		moveq	ip, #244
 8765 4c18 74C0A013 		movne	ip, #116
 8766 4c1c 583094E5 		ldr	r3, [r4, #88]
 8767 4c20 0400A0E3 		mov	r0, #4
 8768 4c24 C8119FE5 		ldr	r1, .L727+220
 8769 4c28 02208CE1 		orr	r2, ip, r2
 8770 4c2c FEFFFFEB 		bl	CyU3PDebugPrint
 8771              	.L656:
3154:../uvc.c      ****                     IMcount = 0;
 8772              		.loc 1 3154 0
 8773 4c30 E160C4E5 		strb	r6, [r4, #225]
3156:../uvc.c      ****                 	stiflag = 0x0;
 8774              		.loc 1 3156 0
 8775 4c34 3A60C4E5 		strb	r6, [r4, #58]
 8776 4c38 9EFFFFEA 		b	.L654
 8777              	.L659:
3142:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 8778              		.loc 1 3142 0
 8779 4c3c 580094E5 		ldr	r0, [r4, #88]
 8780 4c40 8CA4D7E5 		ldrb	sl, [r7, #1164]	@ zero_extendqisi2
 8781 4c44 000050E3 		cmp	r0, #0
 8782 4c48 C400A003 		moveq	r0, #196
 8783 4c4c 4400A013 		movne	r0, #68
 8784 4c50 0A2080E1 		orr	r2, r0, sl
 8785 4c54 3010A0E3 		mov	r1, #48
 8786 4c58 5230A0E3 		mov	r3, #82
 8787 4c5c 0100A0E3 		mov	r0, #1
 8788 4c60 FEFFFFEB 		bl	SensorSetIrisControl
3144:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 8789              		.loc 1 3144 0
 8790 4c64 582094E5 		ldr	r2, [r4, #88]
 8791 4c68 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 8792 4c6c 000052E3 		cmp	r2, #0
 8793 4c70 C420A003 		moveq	r2, #196
 8794 4c74 4420A013 		movne	r2, #68
 8795 4c78 583094E5 		ldr	r3, [r4, #88]
 8796 4c7c 70119FE5 		ldr	r1, .L727+220
 8797 4c80 0C2082E1 		orr	r2, r2, ip
 8798 4c84 0400A0E3 		mov	r0, #4
 8799 4c88 FEFFFFEB 		bl	CyU3PDebugPrint
3145:../uvc.c      ****                  		break;
 8800              		.loc 1 3145 0
 8801 4c8c E7FFFFEA 		b	.L656
 8802              	.L657:
3132:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 8803              		.loc 1 3132 0
 8804 4c90 582094E5 		ldr	r2, [r4, #88]
 8805 4c94 3010A0E3 		mov	r1, #48
 8806 4c98 000052E3 		cmp	r2, #0
 8807 4c9c E420A003 		moveq	r2, #228
 8808 4ca0 6420A013 		movne	r2, #100
 8809 4ca4 5230A0E3 		mov	r3, #82
 8810 4ca8 0100A0E3 		mov	r0, #1
 8811 4cac FEFFFFEB 		bl	SensorSetIrisControl
3134:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 8812              		.loc 1 3134 0
 8813 4cb0 582094E5 		ldr	r2, [r4, #88]
 8814 4cb4 38119FE5 		ldr	r1, .L727+220
 8815 4cb8 000052E3 		cmp	r2, #0
 8816 4cbc 583094E5 		ldr	r3, [r4, #88]
 8817 4cc0 E420A003 		moveq	r2, #228
 8818 4cc4 6420A013 		movne	r2, #100
 8819 4cc8 0400A0E3 		mov	r0, #4
 8820 4ccc FEFFFFEB 		bl	CyU3PDebugPrint
3135:../uvc.c      ****                  		break;
 8821              		.loc 1 3135 0
 8822 4cd0 D6FFFFEA 		b	.L656
 8823              	.L658:
3137:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 8824              		.loc 1 3137 0
 8825 4cd4 582094E5 		ldr	r2, [r4, #88]
 8826 4cd8 3010A0E3 		mov	r1, #48
 8827 4cdc 000052E3 		cmp	r2, #0
 8828 4ce0 D420A003 		moveq	r2, #212
 8829 4ce4 5420A013 		movne	r2, #84
 8830 4ce8 5230A0E3 		mov	r3, #82
 8831 4cec 0100A0E3 		mov	r0, #1
 8832 4cf0 FEFFFFEB 		bl	SensorSetIrisControl
3139:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 8833              		.loc 1 3139 0
 8834 4cf4 582094E5 		ldr	r2, [r4, #88]
 8835 4cf8 F4109FE5 		ldr	r1, .L727+220
 8836 4cfc 000052E3 		cmp	r2, #0
 8837 4d00 583094E5 		ldr	r3, [r4, #88]
 8838 4d04 D420A003 		moveq	r2, #212
 8839 4d08 5420A013 		movne	r2, #84
 8840 4d0c 0400A0E3 		mov	r0, #4
 8841 4d10 FEFFFFEB 		bl	CyU3PDebugPrint
3140:../uvc.c      ****                  		break;
 8842              		.loc 1 3140 0
 8843 4d14 C5FFFFEA 		b	.L656
 8844              	.L728:
 8845              		.align	2
 8846              	.L727:
 8847 4d18 98080000 		.word	.LC49
 8848 4d1c 00C20100 		.word	115200
 8849 4d20 B8080000 		.word	.LC50
 8850 4d24 A0860100 		.word	100000
 8851 4d28 D4080000 		.word	.LC51
 8852 4d2c 00000000 		.word	.LANCHOR0
 8853 4d30 00000000 		.word	CyFxGpifCB
 8854 4d34 88130000 		.word	5000
 8855 4d38 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8856 4d3c 00000000 		.word	CyFxUVCApplnUSBEventCB
 8857 4d40 00000000 		.word	CyFxUSBDeviceDscr
 8858 4d44 00000000 		.word	CyFxUSBDeviceDscrSS
 8859 4d48 00000000 		.word	CyFxUSBDeviceQualDscr
 8860 4d4c 00000000 		.word	CyFxUSBBOSDscr
 8861 4d50 00000000 		.word	CyFxUSBHSConfigDscr
 8862 4d54 00000000 		.word	CyFxUSBFSConfigDscr
 8863 4d58 00000000 		.word	CyFxUSBSSConfigDscr
 8864 4d5c 00000000 		.word	CyFxUSBStringLangIDDscr
 8865 4d60 00000000 		.word	CyFxUSBManufactureDscr
 8866 4d64 00000000 		.word	CyFxUSBProductDscr
 8867 4d68 013F0000 		.word	16129
 8868 4d6c 02030000 		.word	770
 8869 4d70 00000000 		.word	glChHandleInterStat
 8870 4d74 00000000 		.word	glInterStaBuffer
 8871 4d78 00000000 		.word	imgHdMux
 8872 4d7c 01010000 		.word	257
 8873 4d80 03030000 		.word	771
 8874 4d84 00000000 		.word	CyFxUvcApplnDmaCallback
 8875 4d88 00000000 		.word	glChHandleUVCStream
 8876 4d8c 00000000 		.word	.LANCHOR1
 8877 4d90 F0080000 		.word	.LC52
 8878 4d94 F0010000 		.word	.LC13
 8879 4d98 40090000 		.word	.LC54
 8880 4d9c 1C090000 		.word	.LC53
 8881 4da0 68090000 		.word	.LC55
 8882 4da4 C00A0000 		.word	.LC62
 8883 4da8 9C0B0000 		.word	.LC66
 8884 4dac 6C0B0000 		.word	.LC65
 8885 4db0 340B0000 		.word	.LC64
 8886 4db4 F40A0000 		.word	.LC63
 8887 4db8 8C0C0000 		.word	.LC72
 8888 4dbc 3C000000 		.word	.LANCHOR2+60
 8889 4dc0 D40C0000 		.word	.LC74
 8890 4dc4 7C0C0000 		.word	.LC71
 8891 4dc8 20000000 		.word	.LANCHOR2+32
 8892 4dcc 9C0C0000 		.word	.LC73
 8893 4dd0 480C0000 		.word	.LC70
 8894 4dd4 900A0000 		.word	.LC61
 8895 4dd8 600A0000 		.word	.LC60
 8896 4ddc 280A0000 		.word	.LC59
 8897 4de0 C0090000 		.word	.LC57
 8898 4de4 94090000 		.word	.LC56
 8899 4de8 F4090000 		.word	.LC58
 8900 4dec 140C0000 		.word	.LC69
 8901 4df0 E80B0000 		.word	.LC68
 8902 4df4 C40B0000 		.word	.LC67
 8903              		.cfi_endproc
 8904              	.LFE19:
 8906              		.align	2
 8907              		.global	CyFxApplicationDefine
 8909              	CyFxApplicationDefine:
 8910              	.LFB27:
4613:../uvc.c      **** }
4614:../uvc.c      **** 
4615:../uvc.c      **** 
4616:../uvc.c      **** /*
4617:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4618:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4619:../uvc.c      ****  */
4620:../uvc.c      **** void
4621:../uvc.c      **** CyFxApplicationDefine (
4622:../uvc.c      ****         void)
4623:../uvc.c      **** {
 8911              		.loc 1 4623 0
 8912              		.cfi_startproc
 8913              		@ args = 0, pretend = 0, frame = 32
 8914              		@ frame_needed = 0, uses_anonymous_args = 0
 8915              	.LVL802:
 8916 4df8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8917              	.LCFI28:
 8918              		.cfi_def_cfa_offset 32
4624:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4625:../uvc.c      ****     uint32_t retThrdCreate;
4626:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4627:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4628:../uvc.c      **** 
4629:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4630:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8919              		.loc 1 4630 0
 8920 4dfc 010AA0E3 		mov	r0, #4096
4623:../uvc.c      **** {
 8921              		.loc 1 4623 0
 8922 4e00 40D04DE2 		sub	sp, sp, #64
 8923              	.LCFI29:
 8924              		.cfi_def_cfa_offset 96
 8925              		.loc 1 4630 0
 8926              		.cfi_offset 14, -4
 8927              		.cfi_offset 10, -8
 8928              		.cfi_offset 9, -12
 8929              		.cfi_offset 8, -16
 8930              		.cfi_offset 7, -20
 8931              		.cfi_offset 6, -24
 8932              		.cfi_offset 5, -28
 8933              		.cfi_offset 4, -32
 8934 4e04 FEFFFFEB 		bl	CyU3PMemAlloc
 8935 4e08 0080A0E1 		mov	r8, r0
 8936              	.LVL803:
4631:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8937              		.loc 1 4631 0
 8938 4e0c 010AA0E3 		mov	r0, #4096
 8939              	.LVL804:
 8940 4e10 FEFFFFEB 		bl	CyU3PMemAlloc
 8941 4e14 00A0A0E1 		mov	sl, r0
 8942              	.LVL805:
4632:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8943              		.loc 1 4632 0
 8944 4e18 010AA0E3 		mov	r0, #4096
 8945              	.LVL806:
 8946 4e1c FEFFFFEB 		bl	CyU3PMemAlloc
4633:../uvc.c      **** 
4634:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 8947              		.loc 1 4634 0
 8948 4e20 000058E3 		cmp	r8, #0
 8949 4e24 00005A13 		cmpne	sl, #0
 8950 4e28 0070A013 		movne	r7, #0
 8951 4e2c 0170A003 		moveq	r7, #1
4632:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8952              		.loc 1 4632 0
 8953 4e30 0090A0E1 		mov	r9, r0
 8954              	.LVL807:
 8955              		.loc 1 4634 0
 8956 4e34 0000001A 		bne	.L733
 8957              	.LVL808:
 8958              	.L730:
 8959              	.L732:
 8960 4e38 FEFFFFEA 		b	.L732
 8961              	.L733:
 8962              		.loc 1 4634 0 is_stmt 0 discriminator 1
 8963 4e3c 000050E3 		cmp	r0, #0
 8964 4e40 FCFFFF0A 		beq	.L730
 8965              	.LVL809:
4635:../uvc.c      ****         goto fatalErrorHandler;
4636:../uvc.c      **** 
4637:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4638:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4639:../uvc.c      ****     char *staName = "I2CstaQue";
4640:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8966              		.loc 1 4640 0 is_stmt 1
 8967 4e44 04619FE5 		ldr	r6, .L734
 8968 4e48 20408DE2 		add	r4, sp, #32
 8969 4e4c 0400A0E1 		mov	r0, r4
 8970 4e50 4010A0E3 		mov	r1, #64
 8971 4e54 F8209FE5 		ldr	r2, .L734+4
 8972 4e58 0730A0E1 		mov	r3, r7
 8973 4e5c 00608DE5 		str	r6, [sp, #0]
 8974 4e60 FEFFFFEB 		bl	cmdbufCreate
 8975 4e64 04E0A0E1 		mov	lr, r4
 8976 4e68 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 8977 4e6c E4C09FE5 		ldr	ip, .L734+8
4641:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4642:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4643:../uvc.c      **** 
4644:../uvc.c      **** 	/****** initialize command descriptor ***********/
4645:../uvc.c      **** 	cmdquInit(cmdQuptr);
4646:../uvc.c      **** 	cmdquInit(statQuptr);
4647:../uvc.c      **** 
4648:../uvc.c      ****     /* Create the UVC application thread. */
4649:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 8978              		.loc 1 4649 0
 8979 4e70 0840A0E3 		mov	r4, #8
4640:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8980              		.loc 1 4640 0
 8981 4e74 0C50A0E1 		mov	r5, ip
 8982 4e78 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 8983 4e7c 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 8984              		.loc 1 4649 0
 8985 4e80 0160A0E3 		mov	r6, #1
4640:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8986              		.loc 1 4640 0
 8987 4e84 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
4645:../uvc.c      **** 	cmdquInit(cmdQuptr);
 8988              		.loc 1 4645 0
 8989 4e88 0C00A0E1 		mov	r0, ip
 8990 4e8c FEFFFFEB 		bl	cmdquInit
4646:../uvc.c      **** 	cmdquInit(statQuptr);
 8991              		.loc 1 4646 0
 8992 4e90 C4009FE5 		ldr	r0, .L734+12
 8993 4e94 FEFFFFEB 		bl	cmdquInit
 8994              		.loc 1 4649 0
 8995 4e98 A850A0E3 		mov	r5, #168
 8996 4e9c 01CAA0E3 		mov	ip, #4096
 8997 4ea0 B8009FE5 		ldr	r0, .L734+16
 8998 4ea4 B8109FE5 		ldr	r1, .L734+20
 8999 4ea8 B8209FE5 		ldr	r2, .L734+24
 9000 4eac 0730A0E1 		mov	r3, r7
 9001 4eb0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 9002 4eb4 08408DE5 		str	r4, [sp, #8]
 9003 4eb8 0C408DE5 		str	r4, [sp, #12]
 9004 4ebc 10708DE5 		str	r7, [sp, #16]
 9005 4ec0 14608DE5 		str	r6, [sp, #20]
 9006 4ec4 18508DE5 		str	r5, [sp, #24]
 9007 4ec8 FEFFFFEB 		bl	_txe_thread_create
 9008              	.LVL810:
4650:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4651:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4652:../uvc.c      ****             0,                                          /* No input parameter to thread */
4653:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4654:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4655:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4656:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4657:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4658:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4659:../uvc.c      ****             );
4660:../uvc.c      ****     if (retThrdCreate != 0)
 9009              		.loc 1 4660 0
 9010 4ecc 00C050E2 		subs	ip, r0, #0
 9011 4ed0 D8FFFF1A 		bne	.L730
4661:../uvc.c      ****     {
4662:../uvc.c      ****         goto fatalErrorHandler;
4663:../uvc.c      ****     }
4664:../uvc.c      **** 
4665:../uvc.c      ****     /* Create the control request handling thread. */
4666:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 9012              		.loc 1 4666 0
 9013 4ed4 0C30A0E1 		mov	r3, ip
 9014 4ed8 027BA0E3 		mov	r7, #2048
 9015 4edc 88009FE5 		ldr	r0, .L734+28
 9016              	.LVL811:
 9017 4ee0 88109FE5 		ldr	r1, .L734+32
 9018 4ee4 88209FE5 		ldr	r2, .L734+36
 9019 4ee8 10C08DE5 		str	ip, [sp, #16]
 9020 4eec 00A08DE5 		str	sl, [sp, #0]
 9021 4ef0 04708DE5 		str	r7, [sp, #4]
 9022 4ef4 08408DE5 		str	r4, [sp, #8]
 9023 4ef8 0C408DE5 		str	r4, [sp, #12]
 9024 4efc 14608DE5 		str	r6, [sp, #20]
 9025 4f00 18508DE5 		str	r5, [sp, #24]
 9026 4f04 FEFFFFEB 		bl	_txe_thread_create
 9027              	.LVL812:
4667:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4668:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4669:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4670:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4671:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4672:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4673:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4674:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4675:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4676:../uvc.c      ****             );
4677:../uvc.c      ****     if (retThrdCreate != 0)
 9028              		.loc 1 4677 0
 9029 4f08 00C050E2 		subs	ip, r0, #0
 9030 4f0c C9FFFF1A 		bne	.L730
4678:../uvc.c      ****     {
4679:../uvc.c      ****         goto fatalErrorHandler;
4680:../uvc.c      ****     }
4681:../uvc.c      **** #if 1
4682:../uvc.c      ****     /* Create the I2C control command handling thread. */
4683:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 9031              		.loc 1 4683 0
 9032 4f10 60009FE5 		ldr	r0, .L734+40
 9033              	.LVL813:
 9034 4f14 60109FE5 		ldr	r1, .L734+44
 9035 4f18 60209FE5 		ldr	r2, .L734+48
 9036 4f1c 0C30A0E1 		mov	r3, ip
 9037 4f20 00908DE5 		str	r9, [sp, #0]
 9038 4f24 04708DE5 		str	r7, [sp, #4]
 9039 4f28 08408DE5 		str	r4, [sp, #8]
 9040 4f2c 0C408DE5 		str	r4, [sp, #12]
 9041 4f30 10C08DE5 		str	ip, [sp, #16]
 9042 4f34 14608DE5 		str	r6, [sp, #20]
 9043 4f38 18508DE5 		str	r5, [sp, #24]
 9044 4f3c FEFFFFEB 		bl	_txe_thread_create
 9045              	.LVL814:
4684:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4685:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4686:../uvc.c      ****             0,                                          /* No input parameter to thread */
4687:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4688:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4689:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4690:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4691:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4692:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4693:../uvc.c      ****             );
4694:../uvc.c      ****     if (retThrdCreate != 0)
 9046              		.loc 1 4694 0
 9047 4f40 000050E3 		cmp	r0, #0
 9048 4f44 BBFFFF1A 		bne	.L730
4695:../uvc.c      ****     {
4696:../uvc.c      ****         goto fatalErrorHandler;
4697:../uvc.c      ****     }
4698:../uvc.c      **** #endif
4699:../uvc.c      **** 
4700:../uvc.c      ****     return;
4701:../uvc.c      **** 
4702:../uvc.c      **** fatalErrorHandler:
4703:../uvc.c      ****     /* Add custom recovery or debug actions here */
4704:../uvc.c      ****     /* Loop indefinitely */
4705:../uvc.c      ****     while (1);
4706:../uvc.c      **** }
 9049              		.loc 1 4706 0
 9050 4f48 40D08DE2 		add	sp, sp, #64
 9051 4f4c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 9052              	.L735:
 9053              		.align	2
 9054              	.L734:
 9055 4f50 00000000 		.word	cmdQuMux
 9056 4f54 0C0D0000 		.word	.LC75
 9057 4f58 00000000 		.word	cmdQu
 9058 4f5c 00000000 		.word	statQu
 9059 4f60 E4000000 		.word	.LANCHOR0+228
 9060 4f64 180D0000 		.word	.LC76
 9061 4f68 00000000 		.word	UVCAppThread_Entry
 9062 4f6c 8C010000 		.word	.LANCHOR0+396
 9063 4f70 2C0D0000 		.word	.LC77
 9064 4f74 00000000 		.word	UVCAppEP0Thread_Entry
 9065 4f78 34020000 		.word	.LANCHOR0+564
 9066 4f7c 440D0000 		.word	.LC78
 9067 4f80 00000000 		.word	I2cAppThread_Entry
 9068              		.cfi_endproc
 9069              	.LFE27:
 9071              		.align	2
 9072              		.global	main
 9074              	main:
 9075              	.LFB28:
4707:../uvc.c      **** 
4708:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4709:../uvc.c      ****  * the ThreadX RTOS here.
4710:../uvc.c      ****  */
4711:../uvc.c      **** int
4712:../uvc.c      **** main (
4713:../uvc.c      ****         void)
4714:../uvc.c      **** {
 9076              		.loc 1 4714 0
 9077              		.cfi_startproc
 9078              		@ args = 0, pretend = 0, frame = 56
 9079              		@ frame_needed = 0, uses_anonymous_args = 0
 9080 4f84 30402DE9 		stmfd	sp!, {r4, r5, lr}
 9081              	.LCFI30:
 9082              		.cfi_def_cfa_offset 12
4715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4716:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4717:../uvc.c      **** 
4718:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4719:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4720:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4721:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4722:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4723:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9083              		.loc 1 4723 0
 9084 4f88 0010A0E3 		mov	r1, #0
4714:../uvc.c      **** {
 9085              		.loc 1 4714 0
 9086 4f8c 3CD04DE2 		sub	sp, sp, #60
 9087              	.LCFI31:
 9088              		.cfi_def_cfa_offset 72
4720:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9089              		.loc 1 4720 0
 9090 4f90 0220A0E3 		mov	r2, #2
4724:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9091              		.loc 1 4724 0
 9092 4f94 033081E2 		add	r3, r1, #3
4719:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9093              		.loc 1 4719 0
 9094 4f98 0150A0E3 		mov	r5, #1
 9095              		.cfi_offset 14, -4
 9096              		.cfi_offset 5, -8
 9097              		.cfi_offset 4, -12
4725:../uvc.c      **** 
4726:../uvc.c      ****     /* Initialize the device */
4727:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9098              		.loc 1 4727 0
 9099 4f9c 28008DE2 		add	r0, sp, #40
4719:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9100              		.loc 1 4719 0
 9101 4fa0 28508DE5 		str	r5, [sp, #40]
4720:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9102              		.loc 1 4720 0
 9103 4fa4 2C20CDE5 		strb	r2, [sp, #44]
4721:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9104              		.loc 1 4721 0
 9105 4fa8 2D20CDE5 		strb	r2, [sp, #45]
4722:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9106              		.loc 1 4722 0
 9107 4fac 2E20CDE5 		strb	r2, [sp, #46]
4723:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9108              		.loc 1 4723 0
 9109 4fb0 30108DE5 		str	r1, [sp, #48]
4724:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9110              		.loc 1 4724 0
 9111 4fb4 3430CDE5 		strb	r3, [sp, #52]
 9112              		.loc 1 4727 0
 9113 4fb8 FEFFFFEB 		bl	CyU3PDeviceInit
 9114              	.LVL815:
4728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9115              		.loc 1 4728 0
 9116 4fbc 004050E2 		subs	r4, r0, #0
 9117 4fc0 0000000A 		beq	.L739
 9118              	.L737:
 9119              	.L738:
 9120 4fc4 FEFFFFEA 		b	.L738
 9121              	.L739:
4729:../uvc.c      ****     {
4730:../uvc.c      ****         goto handle_fatal_error;
4731:../uvc.c      ****     }
4732:../uvc.c      **** 
4733:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4734:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 9122              		.loc 1 4734 0
 9123 4fc8 0410A0E1 		mov	r1, r4
 9124 4fcc 0420A0E1 		mov	r2, r4
 9125 4fd0 0500A0E1 		mov	r0, r5
 9126              	.LVL816:
 9127 4fd4 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 9128              	.LVL817:
4735:../uvc.c      **** 
4736:../uvc.c      ****     /* Configure the IO matrix for the device. */
4737:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4738:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4739:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4740:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4741:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4742:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4743:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4744:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4745:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4746:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4747:../uvc.c      **** 
4748:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 9129              		.loc 1 4748 0
 9130 4fd8 0D00A0E1 		mov	r0, sp
4738:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 9131              		.loc 1 4738 0
 9132 4fdc 1640CDE5 		strb	r4, [sp, #22]
4739:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 9133              		.loc 1 4739 0
 9134 4fe0 18408DE5 		str	r4, [sp, #24]
4740:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 9135              		.loc 1 4740 0
 9136 4fe4 1C408DE5 		str	r4, [sp, #28]
4741:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 9137              		.loc 1 4741 0
 9138 4fe8 20408DE5 		str	r4, [sp, #32]
4742:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 9139              		.loc 1 4742 0
 9140 4fec 24408DE5 		str	r4, [sp, #36]
4745:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 9141              		.loc 1 4745 0
 9142 4ff0 0C408DE5 		str	r4, [sp, #12]
4746:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 9143              		.loc 1 4746 0
 9144 4ff4 10408DE5 		str	r4, [sp, #16]
4737:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 9145              		.loc 1 4737 0
 9146 4ff8 00508DE5 		str	r5, [sp, #0]
4743:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 9147              		.loc 1 4743 0
 9148 4ffc 04508DE5 		str	r5, [sp, #4]
4744:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 9149              		.loc 1 4744 0
 9150 5000 08508DE5 		str	r5, [sp, #8]
 9151              		.loc 1 4748 0
 9152 5004 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 9153              	.LVL818:
4749:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9154              		.loc 1 4749 0
 9155 5008 004050E2 		subs	r4, r0, #0
 9156 500c ECFFFF1A 		bne	.L737
4750:../uvc.c      ****     {
4751:../uvc.c      ****         goto handle_fatal_error;
4752:../uvc.c      ****     }
4753:../uvc.c      **** 
4754:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4755:../uvc.c      ****     CyU3PKernelEntry ();
 9157              		.loc 1 4755 0
 9158 5010 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 9159              	.LVL819:
4756:../uvc.c      **** 
4757:../uvc.c      ****     /* Dummy return to make the compiler happy */
4758:../uvc.c      ****     return 0;
4759:../uvc.c      **** 
4760:../uvc.c      **** handle_fatal_error:
4761:../uvc.c      ****     /* Cannot recover from this error. */
4762:../uvc.c      ****     while (1);
4763:../uvc.c      **** }
 9160              		.loc 1 4763 0
 9161 5014 0400A0E1 		mov	r0, r4
 9162 5018 3CD08DE2 		add	sp, sp, #60
 9163 501c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 9164              		.cfi_endproc
 9165              	.LFE28:
 9167              		.global	CyFxGpifTransition
 9168              		.global	CyFxGpifWavedata
 9169              		.global	CyFxGpifWavedataPosition
 9170              		.global	CyFxGpifRegValue
 9171              		.global	CyFxGpifConfig
 9172              		.global	CyFxGpifTransition_usb2
 9173              		.global	CyFxGpifWavedata_usb2
 9174              		.global	CyFxGpifWavedataPosition_usb2
 9175              		.global	CyFxGpifRegValue_usb2
 9176              		.global	CyFxGpifConfig_usb2
 9177              		.global	snapButFlag
 9178              		.global	testSnap
 9179              		.global	fb
 9180              		.global	pb
 9181              		.global	pbc
 9182              		.global	fbbak
 9183              		.global	pbbak
 9184              		.global	pbcbak
 9185              		.global	pbcpbak
 9186              		.global	isUsbConnected
 9187              		.global	usbSpeed
 9188              		.global	clearFeatureRqtReceived
 9189              		.global	streamingStarted
 9190              		.global	glProbeCtrl
 9191              		.global	glProbeCtrlFull
 9192              		.global	glProbeStilCtrl
 9193              		.global	glProbeCtrl20
 9194              		.global	glProbeStilCtrl20
 9195              		.global	glUVCHeader
 9196              		.comm	glChHandleUVCStream,220,4
 9197              		.comm	glChHandleStillStream,220,4
 9198              		.comm	glChHandleInterStat,160,4
 9199              		.comm	glInterStaBuffer,4,4
 9200              		.comm	cmdQu,32,4
 9201              		.comm	statQu,32,4
 9202              		.comm	cmdQuMux,56,4
 9203              		.comm	staQuMux,56,4
 9204              		.comm	timMux,56,4
 9205              		.comm	imgHdMux,56,4
 9206              		.comm	bmReqType,1,1
 9207              		.comm	bRequest,1,1
 9208              		.comm	wValue,2,2
 9209              		.comm	wIndex,2,2
 9210              		.comm	wLength,2,2
 9211              		.comm	posTick,4,4
 9212              		.comm	I2CCmdTimer,44,4
 9213              		.section	.rodata
 9214              		.align	2
 9215              		.set	.LANCHOR2,. + 0
 9218              	ShutSp:
 9219 0000 3582     		.short	-32203
 9220 0002 1B41     		.short	16667
 9221 0004 8D20     		.short	8333
 9222 0006 A00F     		.short	4000
 9223 0008 D007     		.short	2000
 9224 000a E803     		.short	1000
 9225 000c F401     		.short	500
 9226 000e C800     		.short	200
 9227 0010 6400     		.short	100
 9228 0012 0A00     		.short	10
 9229 0014 0000     		.short	0
 9230 0016 00000000 		.space	10
 9230      00000000 
 9230      0000
 9233              	CyFxGpifConfig:
 9234 0020 0F00     		.short	15
 9235 0022 0000     		.space	2
 9236 0024 00000000 		.word	CyFxGpifWavedata
 9237 0028 00000000 		.word	CyFxGpifWavedataPosition
 9238 002c 0500     		.short	5
 9239 002e 0000     		.space	2
 9240 0030 00000000 		.word	CyFxGpifTransition
 9241 0034 4C00     		.short	76
 9242 0036 0000     		.space	2
 9243 0038 00000000 		.word	CyFxGpifRegValue
 9246              	CyFxGpifConfig_usb2:
 9247 003c 9300     		.short	147
 9248 003e 0000     		.space	2
 9249 0040 00000000 		.word	CyFxGpifWavedata_usb2
 9250 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 9251 0048 0800     		.short	8
 9252 004a 0000     		.space	2
 9253 004c 00000000 		.word	CyFxGpifTransition_usb2
 9254 0050 4C00     		.short	76
 9255 0052 0000     		.space	2
 9256 0054 00000000 		.word	CyFxGpifRegValue_usb2
 9257              		.data
 9258              		.align	2
 9259              		.set	.LANCHOR1,. + 0
 9262              	ExUCtrlParArry:
 9263 0000 00       		.byte	0
 9264 0001 00       		.byte	0
 9265 0002 04       		.byte	4
 9266 0003 01       		.byte	1
 9267 0004 00       		.byte	0
 9268 0005 38       		.byte	56
 9269 0006 01       		.byte	1
 9270 0007 01       		.byte	1
 9271 0008 00       		.byte	0
 9272 0009 03       		.byte	3
 9273 000a 00       		.byte	0
 9274 000b 4E       		.byte	78
 9275 000c 00       		.byte	0
 9276 000d 4E       		.byte	78
 9277 000e 00       		.byte	0
 9278 000f 30       		.byte	48
 9279 0010 01       		.byte	1
 9280 0011 00       		.byte	0
 9281 0012 00       		.byte	0
 9282 0013 00000000 		.space	5
 9282      00
 9283 0018 00       		.byte	0
 9284 0019 00       		.byte	0
 9285 001a 01       		.byte	1
 9286 001b 00       		.byte	0
 9287 001c 00       		.byte	0
 9288 001d 00       		.byte	0
 9289 001e 00       		.byte	0
 9290 001f 01       		.byte	1
 9291 0020 00       		.byte	0
 9292 0021 03       		.byte	3
 9293 0022 00       		.byte	0
 9294 0023 00       		.byte	0
 9295 0024 00       		.byte	0
 9296 0025 00       		.byte	0
 9297 0026 00       		.byte	0
 9298 0027 30       		.byte	48
 9299 0028 01       		.byte	1
 9300 0029 00       		.byte	0
 9301 002a 00       		.byte	0
 9302 002b 00000000 		.space	5
 9302      00
 9303 0030 00       		.byte	0
 9304 0031 00       		.byte	0
 9305 0032 02       		.byte	2
 9306 0033 00       		.byte	0
 9307 0034 00       		.byte	0
 9308 0035 FF       		.byte	-1
 9309 0036 00       		.byte	0
 9310 0037 01       		.byte	1
 9311 0038 00       		.byte	0
 9312 0039 03       		.byte	3
 9313 003a 00       		.byte	0
 9314 003b 01       		.byte	1
 9315 003c 00       		.byte	0
 9316 003d 00       		.byte	0
 9317 003e 00       		.byte	0
 9318 003f 30       		.byte	48
 9319 0040 01       		.byte	1
 9320 0041 01       		.byte	1
 9321 0042 00       		.byte	0
 9322 0043 00000000 		.space	5
 9322      00
 9323 0048 00       		.byte	0
 9324 0049 00       		.byte	0
 9325 004a 02       		.byte	2
 9326 004b 00       		.byte	0
 9327 004c 00       		.byte	0
 9328 004d 00       		.byte	0
 9329 004e 00       		.byte	0
 9330 004f 00       		.byte	0
 9331 0050 00       		.byte	0
 9332 0051 03       		.byte	3
 9333 0052 00       		.byte	0
 9334 0053 00       		.byte	0
 9335 0054 00       		.byte	0
 9336 0055 00       		.byte	0
 9337 0056 00       		.byte	0
 9338 0057 30       		.byte	48
 9339 0058 01       		.byte	1
 9340 0059 01       		.byte	1
 9341 005a 00       		.byte	0
 9342 005b 00000000 		.space	5
 9342      00
 9343 0060 13       		.byte	19
 9344 0061 14       		.byte	20
 9345 0062 02       		.byte	2
 9346 0063 00       		.byte	0
 9347 0064 00       		.byte	0
 9348 0065 FF       		.byte	-1
 9349 0066 FF       		.byte	-1
 9350 0067 01       		.byte	1
 9351 0068 00       		.byte	0
 9352 0069 03       		.byte	3
 9353 006a 00       		.byte	0
 9354 006b 66       		.byte	102
 9355 006c 66       		.byte	102
 9356 006d 66       		.byte	102
 9357 006e 66       		.byte	102
 9358 006f 30       		.byte	48
 9359 0070 01       		.byte	1
 9360 0071 00       		.byte	0
 9361 0072 00       		.byte	0
 9362 0073 00000000 		.space	5
 9362      00
 9363 0078 11       		.byte	17
 9364 0079 00       		.byte	0
 9365 007a 02       		.byte	2
 9366 007b 01       		.byte	1
 9367 007c 00       		.byte	0
 9368 007d 03       		.byte	3
 9369 007e 00       		.byte	0
 9370 007f 01       		.byte	1
 9371 0080 00       		.byte	0
 9372 0081 03       		.byte	3
 9373 0082 00       		.byte	0
 9374 0083 80       		.byte	-128
 9375 0084 00       		.byte	0
 9376 0085 80       		.byte	-128
 9377 0086 00       		.byte	0
 9378 0087 30       		.byte	48
 9379 0088 01       		.byte	1
 9380 0089 01       		.byte	1
 9381 008a 00       		.byte	0
 9382 008b 00000000 		.space	5
 9382      00
 9383 0090 10       		.byte	16
 9384 0091 00       		.byte	0
 9385 0092 01       		.byte	1
 9386 0093 01       		.byte	1
 9387 0094 00       		.byte	0
 9388 0095 02       		.byte	2
 9389 0096 00       		.byte	0
 9390 0097 01       		.byte	1
 9391 0098 00       		.byte	0
 9392 0099 03       		.byte	3
 9393 009a 00       		.byte	0
 9394 009b 00       		.byte	0
 9395 009c 00       		.byte	0
 9396 009d 00       		.byte	0
 9397 009e 00       		.byte	0
 9398 009f 30       		.byte	48
 9399 00a0 01       		.byte	1
 9400 00a1 01       		.byte	1
 9401 00a2 00       		.byte	0
 9402 00a3 00000000 		.space	5
 9402      00
 9403 00a8 00       		.byte	0
 9404 00a9 00       		.byte	0
 9405 00aa 04       		.byte	4
 9406 00ab 01       		.byte	1
 9407 00ac 00       		.byte	0
 9408 00ad 38       		.byte	56
 9409 00ae 01       		.byte	1
 9410 00af 01       		.byte	1
 9411 00b0 00       		.byte	0
 9412 00b1 03       		.byte	3
 9413 00b2 00       		.byte	0
 9414 00b3 4E       		.byte	78
 9415 00b4 00       		.byte	0
 9416 00b5 4E       		.byte	78
 9417 00b6 00       		.byte	0
 9418 00b7 30       		.byte	48
 9419 00b8 01       		.byte	1
 9420 00b9 00       		.byte	0
 9421 00ba 00       		.byte	0
 9422 00bb 00000000 		.space	5
 9422      00
 9423 00c0 00       		.byte	0
 9424 00c1 00       		.byte	0
 9425 00c2 01       		.byte	1
 9426 00c3 00       		.byte	0
 9427 00c4 00       		.byte	0
 9428 00c5 00       		.byte	0
 9429 00c6 00       		.byte	0
 9430 00c7 01       		.byte	1
 9431 00c8 00       		.byte	0
 9432 00c9 03       		.byte	3
 9433 00ca 00       		.byte	0
 9434 00cb 00       		.byte	0
 9435 00cc 00       		.byte	0
 9436 00cd 00       		.byte	0
 9437 00ce 00       		.byte	0
 9438 00cf 30       		.byte	48
 9439 00d0 01       		.byte	1
 9440 00d1 00       		.byte	0
 9441 00d2 00       		.byte	0
 9442 00d3 00000000 		.space	5
 9442      00
 9443 00d8 00       		.byte	0
 9444 00d9 00       		.byte	0
 9445 00da 02       		.byte	2
 9446 00db 00       		.byte	0
 9447 00dc 00       		.byte	0
 9448 00dd 05       		.byte	5
 9449 00de 00       		.byte	0
 9450 00df 01       		.byte	1
 9451 00e0 00       		.byte	0
 9452 00e1 03       		.byte	3
 9453 00e2 00       		.byte	0
 9454 00e3 00       		.byte	0
 9455 00e4 00       		.byte	0
 9456 00e5 00       		.byte	0
 9457 00e6 00       		.byte	0
 9458 00e7 30       		.byte	48
 9459 00e8 01       		.byte	1
 9460 00e9 00       		.byte	0
 9461 00ea 00       		.byte	0
 9462 00eb 00000000 		.space	5
 9462      00
 9463 00f0 00       		.byte	0
 9464 00f1 00       		.byte	0
 9465 00f2 03       		.byte	3
 9466 00f3 00       		.byte	0
 9467 00f4 00       		.byte	0
 9468 00f5 0A       		.byte	10
 9469 00f6 00       		.byte	0
 9470 00f7 01       		.byte	1
 9471 00f8 00       		.byte	0
 9472 00f9 03       		.byte	3
 9473 00fa 00       		.byte	0
 9474 00fb 00       		.byte	0
 9475 00fc 00       		.byte	0
 9476 00fd 00       		.byte	0
 9477 00fe 00       		.byte	0
 9478 00ff 30       		.byte	48
 9479 0100 01       		.byte	1
 9480 0101 00       		.byte	0
 9481 0102 00       		.byte	0
 9482 0103 00000000 		.space	5
 9482      00
 9483 0108 00       		.byte	0
 9484 0109 00       		.byte	0
 9485 010a 02       		.byte	2
 9486 010b 00       		.byte	0
 9487 010c 00       		.byte	0
 9488 010d 40       		.byte	64
 9489 010e 00       		.byte	0
 9490 010f 01       		.byte	1
 9491 0110 00       		.byte	0
 9492 0111 03       		.byte	3
 9493 0112 00       		.byte	0
 9494 0113 0F       		.byte	15
 9495 0114 11       		.byte	17
 9496 0115 00       		.byte	0
 9497 0116 00       		.byte	0
 9498 0117 30       		.byte	48
 9499 0118 01       		.byte	1
 9500 0119 00       		.byte	0
 9501 011a 00       		.byte	0
 9502 011b 00000000 		.space	5
 9502      00
 9503 0120 00       		.byte	0
 9504 0121 00       		.byte	0
 9505 0122 02       		.byte	2
 9506 0123 00       		.byte	0
 9507 0124 00       		.byte	0
 9508 0125 64       		.byte	100
 9509 0126 00       		.byte	0
 9510 0127 01       		.byte	1
 9511 0128 00       		.byte	0
 9512 0129 03       		.byte	3
 9513 012a 00       		.byte	0
 9514 012b 00       		.byte	0
 9515 012c 00       		.byte	0
 9516 012d 00       		.byte	0
 9517 012e 00       		.byte	0
 9518 012f 30       		.byte	48
 9519 0130 01       		.byte	1
 9520 0131 00       		.byte	0
 9521 0132 00       		.byte	0
 9522 0133 00000000 		.space	5
 9522      00
 9523 0138 00       		.byte	0
 9524 0139 00       		.byte	0
 9525 013a 02       		.byte	2
 9526 013b 00       		.byte	0
 9527 013c 00       		.byte	0
 9528 013d 64       		.byte	100
 9529 013e 00       		.byte	0
 9530 013f 01       		.byte	1
 9531 0140 00       		.byte	0
 9532 0141 03       		.byte	3
 9533 0142 00       		.byte	0
 9534 0143 00       		.byte	0
 9535 0144 00       		.byte	0
 9536 0145 00       		.byte	0
 9537 0146 00       		.byte	0
 9538 0147 30       		.byte	48
 9539 0148 01       		.byte	1
 9540 0149 00       		.byte	0
 9541 014a 00       		.byte	0
 9542 014b 00000000 		.space	5
 9542      00
 9543 0150 00       		.byte	0
 9544 0151 00       		.byte	0
 9545 0152 02       		.byte	2
 9546 0153 00       		.byte	0
 9547 0154 00       		.byte	0
 9548 0155 64       		.byte	100
 9549 0156 00       		.byte	0
 9550 0157 01       		.byte	1
 9551 0158 00       		.byte	0
 9552 0159 03       		.byte	3
 9553 015a 00       		.byte	0
 9554 015b 00       		.byte	0
 9555 015c 00       		.byte	0
 9556 015d 00       		.byte	0
 9557 015e 00       		.byte	0
 9558 015f 30       		.byte	48
 9559 0160 01       		.byte	1
 9560 0161 00       		.byte	0
 9561 0162 00       		.byte	0
 9562 0163 00000000 		.space	5
 9562      00
 9563 0168 00       		.byte	0
 9564 0169 00       		.byte	0
 9565 016a 02       		.byte	2
 9566 016b 00       		.byte	0
 9567 016c 00       		.byte	0
 9568 016d 64       		.byte	100
 9569 016e 00       		.byte	0
 9570 016f 01       		.byte	1
 9571 0170 00       		.byte	0
 9572 0171 03       		.byte	3
 9573 0172 00       		.byte	0
 9574 0173 00       		.byte	0
 9575 0174 00       		.byte	0
 9576 0175 00       		.byte	0
 9577 0176 00       		.byte	0
 9578 0177 30       		.byte	48
 9579 0178 01       		.byte	1
 9580 0179 00       		.byte	0
 9581 017a 00       		.byte	0
 9582 017b 00000000 		.space	5
 9582      00
 9585              	CtrlParArry:
 9586 0180 10       		.byte	16
 9587 0181 10       		.byte	16
 9588 0182 02       		.byte	2
 9589 0183 00       		.byte	0
 9590 0184 00       		.byte	0
 9591 0185 03       		.byte	3
 9592 0186 00       		.byte	0
 9593 0187 01       		.byte	1
 9594 0188 00       		.byte	0
 9595 0189 03       		.byte	3
 9596 018a 00       		.byte	0
 9597 018b 03       		.byte	3
 9598 018c 00       		.byte	0
 9599 018d 03       		.byte	3
 9600 018e 00       		.byte	0
 9601 018f 30       		.byte	48
 9602 0190 01       		.byte	1
 9603 0191 00       		.byte	0
 9604 0192 00       		.byte	0
 9605 0193 00000000 		.space	5
 9605      00
 9606 0198 15       		.byte	21
 9607 0199 15       		.byte	21
 9608 019a 02       		.byte	2
 9609 019b 00       		.byte	0
 9610 019c 00       		.byte	0
 9611 019d FF       		.byte	-1
 9612 019e 00       		.byte	0
 9613 019f 01       		.byte	1
 9614 01a0 00       		.byte	0
 9615 01a1 03       		.byte	3
 9616 01a2 00       		.byte	0
 9617 01a3 76       		.byte	118
 9618 01a4 00       		.byte	0
 9619 01a5 76       		.byte	118
 9620 01a6 C7       		.byte	-57
 9621 01a7 30       		.byte	48
 9622 01a8 01       		.byte	1
 9623 01a9 01       		.byte	1
 9624 01aa 00       		.byte	0
 9625 01ab 00000000 		.space	5
 9625      00
 9626 01b0 04       		.byte	4
 9627 01b1 04       		.byte	4
 9628 01b2 02       		.byte	2
 9629 01b3 00       		.byte	0
 9630 01b4 00       		.byte	0
 9631 01b5 FF       		.byte	-1
 9632 01b6 00       		.byte	0
 9633 01b7 01       		.byte	1
 9634 01b8 00       		.byte	0
 9635 01b9 03       		.byte	3
 9636 01ba 00       		.byte	0
 9637 01bb 70       		.byte	112
 9638 01bc 00       		.byte	0
 9639 01bd 70       		.byte	112
 9640 01be 00       		.byte	0
 9641 01bf 30       		.byte	48
 9642 01c0 01       		.byte	1
 9643 01c1 01       		.byte	1
 9644 01c2 00       		.byte	0
 9645 01c3 00000000 		.space	5
 9645      00
 9646 01c8 00       		.byte	0
 9647 01c9 00       		.byte	0
 9648 01ca 02       		.byte	2
 9649 01cb 00       		.byte	0
 9650 01cc 00       		.byte	0
 9651 01cd 64       		.byte	100
 9652 01ce 00       		.byte	0
 9653 01cf 01       		.byte	1
 9654 01d0 00       		.byte	0
 9655 01d1 03       		.byte	3
 9656 01d2 00       		.byte	0
 9657 01d3 00       		.byte	0
 9658 01d4 00       		.byte	0
 9659 01d5 00       		.byte	0
 9660 01d6 00       		.byte	0
 9661 01d7 30       		.byte	48
 9662 01d8 01       		.byte	1
 9663 01d9 00       		.byte	0
 9664 01da 00       		.byte	0
 9665 01db 00000000 		.space	5
 9665      00
 9666 01e0 07       		.byte	7
 9667 01e1 07       		.byte	7
 9668 01e2 02       		.byte	2
 9669 01e3 00       		.byte	0
 9670 01e4 00       		.byte	0
 9671 01e5 01       		.byte	1
 9672 01e6 00       		.byte	0
 9673 01e7 01       		.byte	1
 9674 01e8 00       		.byte	0
 9675 01e9 03       		.byte	3
 9676 01ea 00       		.byte	0
 9677 01eb 01       		.byte	1
 9678 01ec 00       		.byte	0
 9679 01ed 01       		.byte	1
 9680 01ee 00       		.byte	0
 9681 01ef 30       		.byte	48
 9682 01f0 01       		.byte	1
 9683 01f1 00       		.byte	0
 9684 01f2 00       		.byte	0
 9685 01f3 00000000 		.space	5
 9685      00
 9686 01f8 DF       		.byte	-33
 9687 01f9 E1       		.byte	-31
 9688 01fa 02       		.byte	2
 9689 01fb 00       		.byte	0
 9690 01fc 00       		.byte	0
 9691 01fd FF       		.byte	-1
 9692 01fe 00       		.byte	0
 9693 01ff 01       		.byte	1
 9694 0200 00       		.byte	0
 9695 0201 03       		.byte	3
 9696 0202 00       		.byte	0
 9697 0203 80       		.byte	-128
 9698 0204 00       		.byte	0
 9699 0205 00       		.byte	0
 9700 0206 00       		.byte	0
 9701 0207 C6       		.byte	-58
 9702 0208 01       		.byte	1
 9703 0209 01       		.byte	1
 9704 020a 00       		.byte	0
 9705 020b 00000000 		.space	5
 9705      00
 9706 0210 85       		.byte	-123
 9707 0211 86       		.byte	-122
 9708 0212 02       		.byte	2
 9709 0213 00       		.byte	0
 9710 0214 00       		.byte	0
 9711 0215 64       		.byte	100
 9712 0216 00       		.byte	0
 9713 0217 01       		.byte	1
 9714 0218 00       		.byte	0
 9715 0219 03       		.byte	3
 9716 021a 00       		.byte	0
 9717 021b 32       		.byte	50
 9718 021c 00       		.byte	0
 9719 021d 32       		.byte	50
 9720 021e 00       		.byte	0
 9721 021f F2       		.byte	-14
 9722 0220 01       		.byte	1
 9723 0221 01       		.byte	1
 9724 0222 00       		.byte	0
 9725 0223 00000000 		.space	5
 9725      00
 9726 0228 06       		.byte	6
 9727 0229 06       		.byte	6
 9728 022a 02       		.byte	2
 9729 022b 00       		.byte	0
 9730 022c 00       		.byte	0
 9731 022d FF       		.byte	-1
 9732 022e 00       		.byte	0
 9733 022f 01       		.byte	1
 9734 0230 00       		.byte	0
 9735 0231 03       		.byte	3
 9736 0232 00       		.byte	0
 9737 0233 20       		.byte	32
 9738 0234 00       		.byte	0
 9739 0235 20       		.byte	32
 9740 0236 00       		.byte	0
 9741 0237 30       		.byte	48
 9742 0238 01       		.byte	1
 9743 0239 01       		.byte	1
 9744 023a 00       		.byte	0
 9745 023b 00000000 		.space	5
 9745      00
 9746 0240 00       		.byte	0
 9747 0241 00       		.byte	0
 9748 0242 02       		.byte	2
 9749 0243 00       		.byte	0
 9750 0244 00       		.byte	0
 9751 0245 64       		.byte	100
 9752 0246 00       		.byte	0
 9753 0247 01       		.byte	1
 9754 0248 00       		.byte	0
 9755 0249 03       		.byte	3
 9756 024a 00       		.byte	0
 9757 024b 00       		.byte	0
 9758 024c 00       		.byte	0
 9759 024d 00       		.byte	0
 9760 024e 00       		.byte	0
 9761 024f 30       		.byte	48
 9762 0250 01       		.byte	1
 9763 0251 00       		.byte	0
 9764 0252 00       		.byte	0
 9765 0253 00000000 		.space	5
 9765      00
 9766 0258 08       		.byte	8
 9767 0259 08       		.byte	8
 9768 025a 02       		.byte	2
 9769 025b 00       		.byte	0
 9770 025c 00       		.byte	0
 9771 025d 05       		.byte	5
 9772 025e 00       		.byte	0
 9773 025f 01       		.byte	1
 9774 0260 00       		.byte	0
 9775 0261 03       		.byte	3
 9776 0262 00       		.byte	0
 9777 0263 00       		.byte	0
 9778 0264 00       		.byte	0
 9779 0265 00       		.byte	0
 9780 0266 00       		.byte	0
 9781 0267 30       		.byte	48
 9782 0268 01       		.byte	1
 9783 0269 00       		.byte	0
 9784 026a 00       		.byte	0
 9785 026b 00000000 		.space	5
 9785      00
 9786 0270 00       		.byte	0
 9787 0271 00       		.byte	0
 9788 0272 02       		.byte	2
 9789 0273 00       		.byte	0
 9790 0274 00       		.byte	0
 9791 0275 40       		.byte	64
 9792 0276 00       		.byte	0
 9793 0277 01       		.byte	1
 9794 0278 00       		.byte	0
 9795 0279 03       		.byte	3
 9796 027a 00       		.byte	0
 9797 027b 00       		.byte	0
 9798 027c 00       		.byte	0
 9799 027d 00       		.byte	0
 9800 027e 00       		.byte	0
 9801 027f 30       		.byte	48
 9802 0280 01       		.byte	1
 9803 0281 00       		.byte	0
 9804 0282 00       		.byte	0
 9805 0283 00000000 		.space	5
 9805      00
 9806 0288 09       		.byte	9
 9807 0289 0A       		.byte	10
 9808 028a 04       		.byte	4
 9809 028b 00       		.byte	0
 9810 028c 00       		.byte	0
 9811 028d 40       		.byte	64
 9812 028e 00       		.byte	0
 9813 028f 01       		.byte	1
 9814 0290 00       		.byte	0
 9815 0291 03       		.byte	3
 9816 0292 00       		.byte	0
 9817 0293 20       		.byte	32
 9818 0294 38       		.byte	56
 9819 0295 20       		.byte	32
 9820 0296 38       		.byte	56
 9821 0297 30       		.byte	48
 9822 0298 01       		.byte	1
 9823 0299 00       		.byte	0
 9824 029a 00       		.byte	0
 9825 029b 00000000 		.space	5
 9825      00
 9826 02a0 00       		.byte	0
 9827 02a1 00       		.byte	0
 9828 02a2 02       		.byte	2
 9829 02a3 00       		.byte	0
 9830 02a4 00       		.byte	0
 9831 02a5 64       		.byte	100
 9832 02a6 00       		.byte	0
 9833 02a7 01       		.byte	1
 9834 02a8 00       		.byte	0
 9835 02a9 03       		.byte	3
 9836 02aa 00       		.byte	0
 9837 02ab 00       		.byte	0
 9838 02ac 00       		.byte	0
 9839 02ad 00       		.byte	0
 9840 02ae 00       		.byte	0
 9841 02af 30       		.byte	48
 9842 02b0 01       		.byte	1
 9843 02b1 00       		.byte	0
 9844 02b2 00       		.byte	0
 9845 02b3 00000000 		.space	5
 9845      00
 9846 02b8 00       		.byte	0
 9847 02b9 00       		.byte	0
 9848 02ba 02       		.byte	2
 9849 02bb 00       		.byte	0
 9850 02bc 00       		.byte	0
 9851 02bd 64       		.byte	100
 9852 02be 00       		.byte	0
 9853 02bf 01       		.byte	1
 9854 02c0 00       		.byte	0
 9855 02c1 03       		.byte	3
 9856 02c2 00       		.byte	0
 9857 02c3 00       		.byte	0
 9858 02c4 00       		.byte	0
 9859 02c5 00       		.byte	0
 9860 02c6 00       		.byte	0
 9861 02c7 30       		.byte	48
 9862 02c8 01       		.byte	1
 9863 02c9 00       		.byte	0
 9864 02ca 00       		.byte	0
 9865 02cb 00000000 		.space	5
 9865      00
 9866 02d0 2A       		.byte	42
 9867 02d1 2A       		.byte	42
 9868 02d2 02       		.byte	2
 9869 02d3 00       		.byte	0
 9870 02d4 00       		.byte	0
 9871 02d5 1B       		.byte	27
 9872 02d6 00       		.byte	0
 9873 02d7 01       		.byte	1
 9874 02d8 00       		.byte	0
 9875 02d9 03       		.byte	3
 9876 02da 00       		.byte	0
 9877 02db 00       		.byte	0
 9878 02dc 00       		.byte	0
 9879 02dd 00       		.byte	0
 9880 02de 00       		.byte	0
 9881 02df 30       		.byte	48
 9882 02e0 01       		.byte	1
 9883 02e1 00       		.byte	0
 9884 02e2 00       		.byte	0
 9885 02e3 00000000 		.space	5
 9885      00
 9886 02e8 00       		.byte	0
 9887 02e9 00       		.byte	0
 9888 02ea 02       		.byte	2
 9889 02eb 00       		.byte	0
 9890 02ec 00       		.byte	0
 9891 02ed 64       		.byte	100
 9892 02ee 00       		.byte	0
 9893 02ef 01       		.byte	1
 9894 02f0 00       		.byte	0
 9895 02f1 03       		.byte	3
 9896 02f2 00       		.byte	0
 9897 02f3 00       		.byte	0
 9898 02f4 00       		.byte	0
 9899 02f5 00       		.byte	0
 9900 02f6 00       		.byte	0
 9901 02f7 30       		.byte	48
 9902 02f8 01       		.byte	1
 9903 02f9 00       		.byte	0
 9904 02fa 00       		.byte	0
 9905 02fb 00000000 		.space	5
 9905      00
 9906 0300 00       		.byte	0
 9907 0301 00       		.byte	0
 9908 0302 02       		.byte	2
 9909 0303 00       		.byte	0
 9910 0304 00       		.byte	0
 9911 0305 12       		.byte	18
 9912 0306 00       		.byte	0
 9913 0307 01       		.byte	1
 9914 0308 00       		.byte	0
 9915 0309 03       		.byte	3
 9916 030a 00       		.byte	0
 9917 030b 00       		.byte	0
 9918 030c 00       		.byte	0
 9919 030d 00       		.byte	0
 9920 030e 00       		.byte	0
 9921 030f 30       		.byte	48
 9922 0310 01       		.byte	1
 9923 0311 00       		.byte	0
 9924 0312 00       		.byte	0
 9925 0313 00000000 		.space	5
 9925      00
 9926 0318 01       		.byte	1
 9927 0319 01       		.byte	1
 9928 031a 02       		.byte	2
 9929 031b 00       		.byte	0
 9930 031c 00       		.byte	0
 9931 031d 09       		.byte	9
 9932 031e 00       		.byte	0
 9933 031f 01       		.byte	1
 9934 0320 00       		.byte	0
 9935 0321 03       		.byte	3
 9936 0322 00       		.byte	0
 9937 0323 00       		.byte	0
 9938 0324 00       		.byte	0
 9939 0325 01       		.byte	1
 9940 0326 00       		.byte	0
 9941 0327 30       		.byte	48
 9942 0328 01       		.byte	1
 9943 0329 00       		.byte	0
 9944 032a 00       		.byte	0
 9945 032b 00000000 		.space	5
 9945      00
 9946 0330 05       		.byte	5
 9947 0331 05       		.byte	5
 9948 0332 02       		.byte	2
 9949 0333 00       		.byte	0
 9950 0334 00       		.byte	0
 9951 0335 03       		.byte	3
 9952 0336 00       		.byte	0
 9953 0337 01       		.byte	1
 9954 0338 00       		.byte	0
 9955 0339 03       		.byte	3
 9956 033a 00       		.byte	0
 9957 033b 00       		.byte	0
 9958 033c 00       		.byte	0
 9959 033d 00       		.byte	0
 9960 033e 00       		.byte	0
 9961 033f 30       		.byte	48
 9962 0340 01       		.byte	1
 9963 0341 00       		.byte	0
 9964 0342 00       		.byte	0
 9965 0343 00000000 		.space	5
 9965      00
 9966 0348 18       		.byte	24
 9967 0349 18       		.byte	24
 9968 034a 02       		.byte	2
 9969 034b 00       		.byte	0
 9970 034c 00       		.byte	0
 9971 034d 01       		.byte	1
 9972 034e 00       		.byte	0
 9973 034f 01       		.byte	1
 9974 0350 00       		.byte	0
 9975 0351 03       		.byte	3
 9976 0352 00       		.byte	0
 9977 0353 00       		.byte	0
 9978 0354 00       		.byte	0
 9979 0355 00       		.byte	0
 9980 0356 00       		.byte	0
 9981 0357 30       		.byte	48
 9982 0358 01       		.byte	1
 9983 0359 00       		.byte	0
 9984 035a 00       		.byte	0
 9985 035b 00000000 		.space	5
 9985      00
 9986 0360 19       		.byte	25
 9987 0361 19       		.byte	25
 9988 0362 01       		.byte	1
 9989 0363 00       		.byte	0
 9990 0364 00       		.byte	0
 9991 0365 40       		.byte	64
 9992 0366 00       		.byte	0
 9993 0367 01       		.byte	1
 9994 0368 00       		.byte	0
 9995 0369 03       		.byte	3
 9996 036a 00       		.byte	0
 9997 036b 20       		.byte	32
 9998 036c 00       		.byte	0
 9999 036d 20       		.byte	32
 10000 036e 00       		.byte	0
 10001 036f 30       		.byte	48
 10002 0370 01       		.byte	1
 10003 0371 00       		.byte	0
 10004 0372 00       		.byte	0
 10005 0373 00000000 		.space	5
 10005      00
 10006 0378 20       		.byte	32
 10007 0379 20       		.byte	32
 10008 037a 02       		.byte	2
 10009 037b 00       		.byte	0
 10010 037c 00       		.byte	0
 10011 037d 02       		.byte	2
 10012 037e 00       		.byte	0
 10013 037f 01       		.byte	1
 10014 0380 00       		.byte	0
 10015 0381 03       		.byte	3
 10016 0382 00       		.byte	0
 10017 0383 00       		.byte	0
 10018 0384 00       		.byte	0
 10019 0385 00       		.byte	0
 10020 0386 00       		.byte	0
 10021 0387 30       		.byte	48
 10022 0388 01       		.byte	1
 10023 0389 00       		.byte	0
 10024 038a 00       		.byte	0
 10025 038b 00000000 		.space	5
 10025      00
 10026 0390 22       		.byte	34
 10027 0391 22       		.byte	34
 10028 0392 02       		.byte	2
 10029 0393 00       		.byte	0
 10030 0394 00       		.byte	0
 10031 0395 3F       		.byte	63
 10032 0396 00       		.byte	0
 10033 0397 01       		.byte	1
 10034 0398 00       		.byte	0
 10035 0399 03       		.byte	3
 10036 039a 00       		.byte	0
 10037 039b 00       		.byte	0
 10038 039c 00       		.byte	0
 10039 039d 00       		.byte	0
 10040 039e 00       		.byte	0
 10041 039f 30       		.byte	48
 10042 03a0 01       		.byte	1
 10043 03a1 00       		.byte	0
 10044 03a2 00       		.byte	0
 10045 03a3 00000000 		.space	5
 10045      00
 10046 03a8 23       		.byte	35
 10047 03a9 23       		.byte	35
 10048 03aa 02       		.byte	2
 10049 03ab 00       		.byte	0
 10050 03ac 00       		.byte	0
 10051 03ad 64       		.byte	100
 10052 03ae 00       		.byte	0
 10053 03af 01       		.byte	1
 10054 03b0 00       		.byte	0
 10055 03b1 03       		.byte	3
 10056 03b2 00       		.byte	0
 10057 03b3 10       		.byte	16
 10058 03b4 00       		.byte	0
 10059 03b5 10       		.byte	16
 10060 03b6 00       		.byte	0
 10061 03b7 30       		.byte	48
 10062 03b8 01       		.byte	1
 10063 03b9 00       		.byte	0
 10064 03ba 00       		.byte	0
 10065 03bb 00000000 		.space	5
 10065      00
 10066 03c0 24       		.byte	36
 10067 03c1 24       		.byte	36
 10068 03c2 02       		.byte	2
 10069 03c3 00       		.byte	0
 10070 03c4 00       		.byte	0
 10071 03c5 64       		.byte	100
 10072 03c6 00       		.byte	0
 10073 03c7 01       		.byte	1
 10074 03c8 00       		.byte	0
 10075 03c9 03       		.byte	3
 10076 03ca 00       		.byte	0
 10077 03cb 10       		.byte	16
 10078 03cc 00       		.byte	0
 10079 03cd 10       		.byte	16
 10080 03ce 00       		.byte	0
 10081 03cf 30       		.byte	48
 10082 03d0 01       		.byte	1
 10083 03d1 00       		.byte	0
 10084 03d2 00       		.byte	0
 10085 03d3 00000000 		.space	5
 10085      00
 10086 03d8 02       		.byte	2
 10087 03d9 03       		.byte	3
 10088 03da 04       		.byte	4
 10089 03db 00       		.byte	0
 10090 03dc 00       		.byte	0
 10091 03dd 7F       		.byte	127
 10092 03de 00       		.byte	0
 10093 03df 01       		.byte	1
 10094 03e0 00       		.byte	0
 10095 03e1 03       		.byte	3
 10096 03e2 00       		.byte	0
 10097 03e3 00       		.byte	0
 10098 03e4 20       		.byte	32
 10099 03e5 00       		.byte	0
 10100 03e6 20       		.byte	32
 10101 03e7 30       		.byte	48
 10102 03e8 01       		.byte	1
 10103 03e9 00       		.byte	0
 10104 03ea 00       		.byte	0
 10105 03eb 00000000 		.space	5
 10105      00
 10106 03f0 04       		.byte	4
 10107 03f1 04       		.byte	4
 10108 03f2 02       		.byte	2
 10109 03f3 00       		.byte	0
 10110 03f4 00       		.byte	0
 10111 03f5 FF       		.byte	-1
 10112 03f6 00       		.byte	0
 10113 03f7 01       		.byte	1
 10114 03f8 00       		.byte	0
 10115 03f9 03       		.byte	3
 10116 03fa 00       		.byte	0
 10117 03fb 60       		.byte	96
 10118 03fc 00       		.byte	0
 10119 03fd 60       		.byte	96
 10120 03fe 00       		.byte	0
 10121 03ff 30       		.byte	48
 10122 0400 01       		.byte	1
 10123 0401 00       		.byte	0
 10124 0402 00       		.byte	0
 10125 0403 00000000 		.space	5
 10125      00
 10126 0408 00       		.byte	0
 10127 0409 00       		.byte	0
 10128 040a 02       		.byte	2
 10129 040b 00       		.byte	0
 10130 040c 00       		.byte	0
 10131 040d 19       		.byte	25
 10132 040e 00       		.byte	0
 10133 040f 01       		.byte	1
 10134 0410 00       		.byte	0
 10135 0411 03       		.byte	3
 10136 0412 00       		.byte	0
 10137 0413 00       		.byte	0
 10138 0414 00       		.byte	0
 10139 0415 00       		.byte	0
 10140 0416 00       		.byte	0
 10141 0417 30       		.byte	48
 10142 0418 01       		.byte	1
 10143 0419 00       		.byte	0
 10144 041a 00       		.byte	0
 10145 041b 00000000 		.space	5
 10145      00
 10146 0420 10       		.byte	16
 10147 0421 10       		.byte	16
 10148 0422 02       		.byte	2
 10149 0423 00       		.byte	0
 10150 0424 00       		.byte	0
 10151 0425 06       		.byte	6
 10152 0426 00       		.byte	0
 10153 0427 01       		.byte	1
 10154 0428 00       		.byte	0
 10155 0429 03       		.byte	3
 10156 042a 00       		.byte	0
 10157 042b 03       		.byte	3
 10158 042c 00       		.byte	0
 10159 042d 03       		.byte	3
 10160 042e 00       		.byte	0
 10161 042f 30       		.byte	48
 10162 0430 01       		.byte	1
 10163 0431 00       		.byte	0
 10164 0432 00       		.byte	0
 10165 0433 00000000 		.space	5
 10165      00
 10166 0438 00       		.byte	0
 10167 0439 00       		.byte	0
 10168 043a 02       		.byte	2
 10169 043b 00       		.byte	0
 10170 043c 00       		.byte	0
 10171 043d 03       		.byte	3
 10172 043e 00       		.byte	0
 10173 043f 01       		.byte	1
 10174 0440 00       		.byte	0
 10175 0441 03       		.byte	3
 10176 0442 00       		.byte	0
 10177 0443 00       		.byte	0
 10178 0444 00       		.byte	0
 10179 0445 00       		.byte	0
 10180 0446 00       		.byte	0
 10181 0447 30       		.byte	48
 10182 0448 01       		.byte	1
 10183 0449 00       		.byte	0
 10184 044a 00       		.byte	0
 10185 044b 00000000 		.space	5
 10185      00
 10186 0450 50       		.byte	80
 10187 0451 50       		.byte	80
 10188 0452 01       		.byte	1
 10189 0453 00       		.byte	0
 10190 0454 00       		.byte	0
 10191 0455 03       		.byte	3
 10192 0456 00       		.byte	0
 10193 0457 01       		.byte	1
 10194 0458 00       		.byte	0
 10195 0459 03       		.byte	3
 10196 045a 00       		.byte	0
 10197 045b 00       		.byte	0
 10198 045c 00       		.byte	0
 10199 045d 00       		.byte	0
 10200 045e 00       		.byte	0
 10201 045f 30       		.byte	48
 10202 0460 01       		.byte	1
 10203 0461 00       		.byte	0
 10204 0462 00       		.byte	0
 10205 0463 00000000 		.space	5
 10205      00
 10206 0468 00       		.byte	0
 10207 0469 00       		.byte	0
 10208 046a 0B       		.byte	11
 10209 046b 00       		.byte	0
 10210 046c 00       		.byte	0
 10211 046d FF       		.byte	-1
 10212 046e FF       		.byte	-1
 10213 046f 01       		.byte	1
 10214 0470 00       		.byte	0
 10215 0471 03       		.byte	3
 10216 0472 00       		.byte	0
 10217 0473 00       		.byte	0
 10218 0474 00       		.byte	0
 10219 0475 00       		.byte	0
 10220 0476 00       		.byte	0
 10221 0477 00       		.byte	0
 10222 0478 01       		.byte	1
 10223 0479 00       		.byte	0
 10224 047a 00       		.byte	0
 10225 047b 00000000 		.space	5
 10225      00
 10228              	glUVCHeader:
 10229 0480 0C       		.byte	12
 10230 0481 8C       		.byte	-116
 10231 0482 00       		.byte	0
 10232 0483 00       		.byte	0
 10233 0484 00       		.byte	0
 10234 0485 00       		.byte	0
 10235 0486 00       		.byte	0
 10236 0487 00       		.byte	0
 10237 0488 00       		.byte	0
 10238 0489 00       		.byte	0
 10239 048a 00       		.byte	0
 10240 048b 00       		.byte	0
 10243              	ROIMode:
 10244 048c 01       		.byte	1
 10245 048d 000000   		.space	3
 10248              	EXTBLCWinPos:
 10249 0490 14       		.byte	20
 10250 0491 13       		.byte	19
 10251 0492 02       		.byte	2
 10252 0493 00       		.byte	0
 10253 0494 00       		.byte	0
 10254 0495 FF       		.byte	-1
 10255 0496 FF       		.byte	-1
 10256 0497 01       		.byte	1
 10257 0498 00       		.byte	0
 10258 0499 03       		.byte	3
 10259 049a 00       		.byte	0
 10260 049b 66       		.byte	102
 10261 049c 66       		.byte	102
 10262 049d 66       		.byte	102
 10263 049e 66       		.byte	102
 10264 049f 30       		.byte	48
 10265 04a0 01       		.byte	1
 10266 04a1 00       		.byte	0
 10267 04a2 0000     		.space	2
 10270              	EXTBLCWeight:
 10271 04a4 11       		.byte	17
 10272 04a5 11       		.byte	17
 10273 04a6 02       		.byte	2
 10274 04a7 00       		.byte	0
 10275 04a8 00       		.byte	0
 10276 04a9 FF       		.byte	-1
 10277 04aa 00       		.byte	0
 10278 04ab 01       		.byte	1
 10279 04ac 00       		.byte	0
 10280 04ad 03       		.byte	3
 10281 04ae 00       		.byte	0
 10282 04af 80       		.byte	-128
 10283 04b0 00       		.byte	0
 10284 04b1 80       		.byte	-128
 10285 04b2 00       		.byte	0
 10286 04b3 30       		.byte	48
 10287 04b4 01       		.byte	1
 10288 04b5 00       		.byte	0
 10289 04b6 0000     		.space	2
 10292              	EXTShutter:
 10293 04b8 00       		.byte	0
 10294 04b9 02       		.byte	2
 10295 04ba 02       		.byte	2
 10296 04bb 00       		.byte	0
 10297 04bc 00       		.byte	0
 10298 04bd 08       		.byte	8
 10299 04be 00       		.byte	0
 10300 04bf 01       		.byte	1
 10301 04c0 00       		.byte	0
 10302 04c1 03       		.byte	3
 10303 04c2 00       		.byte	0
 10304 04c3 00       		.byte	0
 10305 04c4 00       		.byte	0
 10306 04c5 00       		.byte	0
 10307 04c6 00       		.byte	0
 10308 04c7 30       		.byte	48
 10309 04c8 01       		.byte	1
 10310 04c9 00       		.byte	0
 10311 04ca 0000     		.space	2
 10314              	EXTShutlev:
 10315 04cc 02       		.byte	2
 10316 04cd 12       		.byte	18
 10317 04ce 02       		.byte	2
 10318 04cf 00       		.byte	0
 10319 04d0 00       		.byte	0
 10320 04d1 FF       		.byte	-1
 10321 04d2 7F       		.byte	127
 10322 04d3 01       		.byte	1
 10323 04d4 00       		.byte	0
 10324 04d5 03       		.byte	3
 10325 04d6 00       		.byte	0
 10326 04d7 3F       		.byte	63
 10327 04d8 00       		.byte	0
 10328 04d9 3F       		.byte	63
 10329 04da 00       		.byte	0
 10330 04db 30       		.byte	48
 10331 04dc 01       		.byte	1
 10332 04dd 00       		.byte	0
 10333 04de 0000     		.space	2
 10336              	EXTAexModGainlev:
 10337 04e0 00       		.byte	0
 10338 04e1 03       		.byte	3
 10339 04e2 04       		.byte	4
 10340 04e3 00       		.byte	0
 10341 04e4 00       		.byte	0
 10342 04e5 03       		.byte	3
 10343 04e6 7F       		.byte	127
 10344 04e7 01       		.byte	1
 10345 04e8 00       		.byte	0
 10346 04e9 03       		.byte	3
 10347 04ea 00       		.byte	0
 10348 04eb 00       		.byte	0
 10349 04ec 3F       		.byte	63
 10350 04ed 00       		.byte	0
 10351 04ee 3F       		.byte	63
 10352 04ef 30       		.byte	48
 10353 04f0 01       		.byte	1
 10354 04f1 00       		.byte	0
 10355 04f2 0000     		.space	2
 10358              	WBMenuCmpArry:
 10359 04f4 20       		.byte	32
 10360 04f5 0F       		.byte	15
 10361 04f6 38       		.byte	56
 10362 04f7 F0       		.byte	-16
 10365              	PUCBLC:
 10366 04f8 10       		.byte	16
 10367 04f9 11       		.byte	17
 10368 04fa 02       		.byte	2
 10369 04fb 00       		.byte	0
 10370 04fc 00       		.byte	0
 10371 04fd 03       		.byte	3
 10372 04fe 00       		.byte	0
 10373 04ff 01       		.byte	1
 10374 0500 00       		.byte	0
 10375 0501 03       		.byte	3
 10376 0502 00       		.byte	0
 10377 0503 03       		.byte	3
 10378 0504 00       		.byte	0
 10379 0505 03       		.byte	3
 10380 0506 00       		.byte	0
 10381 0507 30       		.byte	48
 10382 0508 01       		.byte	1
 10383 0509 00       		.byte	0
 10384 050a 0000     		.space	2
 10387              	PUCSharp:
 10388 050c 06       		.byte	6
 10389 050d 07       		.byte	7
 10390 050e 02       		.byte	2
 10391 050f 00       		.byte	0
 10392 0510 00       		.byte	0
 10393 0511 08       		.byte	8
 10394 0512 00       		.byte	0
 10395 0513 01       		.byte	1
 10396 0514 00       		.byte	0
 10397 0515 03       		.byte	3
 10398 0516 00       		.byte	0
 10399 0517 00       		.byte	0
 10400 0518 00       		.byte	0
 10401 0519 00       		.byte	0
 10402 051a 00       		.byte	0
 10403 051b 30       		.byte	48
 10404 051c 01       		.byte	1
 10405 051d 00       		.byte	0
 10406 051e 0000     		.space	2
 10409              	CTCtrlParArry:
 10410 0520 00       		.byte	0
 10411 0521 00       		.byte	0
 10412 0522 01       		.byte	1
 10413 0523 00       		.byte	0
 10414 0524 00       		.byte	0
 10415 0525 03       		.byte	3
 10416 0526 00       		.byte	0
 10417 0527 01       		.byte	1
 10418 0528 00       		.byte	0
 10419 0529 03       		.byte	3
 10420 052a 00       		.byte	0
 10421 052b 03       		.byte	3
 10422 052c 00       		.byte	0
 10423 052d 03       		.byte	3
 10424 052e 00       		.byte	0
 10425 052f 30       		.byte	48
 10426 0530 01       		.byte	1
 10427 0531 00       		.byte	0
 10428 0532 00       		.byte	0
 10429 0533 00000000 		.space	5
 10429      00
 10430 0538 00       		.byte	0
 10431 0539 00       		.byte	0
 10432 053a 01       		.byte	1
 10433 053b 01       		.byte	1
 10434 053c 00       		.byte	0
 10435 053d 0F       		.byte	15
 10436 053e 00       		.byte	0
 10437 053f 0F       		.byte	15
 10438 0540 00       		.byte	0
 10439 0541 03       		.byte	3
 10440 0542 00       		.byte	0
 10441 0543 02       		.byte	2
 10442 0544 00       		.byte	0
 10443 0545 02       		.byte	2
 10444 0546 00       		.byte	0
 10445 0547 30       		.byte	48
 10446 0548 01       		.byte	1
 10447 0549 01       		.byte	1
 10448 054a 00       		.byte	0
 10449 054b 00000000 		.space	5
 10449      00
 10450 0550 02       		.byte	2
 10451 0551 00       		.byte	0
 10452 0552 01       		.byte	1
 10453 0553 00       		.byte	0
 10454 0554 00       		.byte	0
 10455 0555 01       		.byte	1
 10456 0556 00       		.byte	0
 10457 0557 01       		.byte	1
 10458 0558 00       		.byte	0
 10459 0559 03       		.byte	3
 10460 055a 00       		.byte	0
 10461 055b 00       		.byte	0
 10462 055c 00       		.byte	0
 10463 055d 00       		.byte	0
 10464 055e 00       		.byte	0
 10465 055f 30       		.byte	48
 10466 0560 01       		.byte	1
 10467 0561 01       		.byte	1
 10468 0562 00       		.byte	0
 10469 0563 00000000 		.space	5
 10469      00
 10470 0568 00       		.byte	0
 10471 0569 00       		.byte	0
 10472 056a 04       		.byte	4
 10473 056b 01       		.byte	1
 10474 056c 00       		.byte	0
 10475 056d 38       		.byte	56
 10476 056e 01       		.byte	1
 10477 056f 01       		.byte	1
 10478 0570 00       		.byte	0
 10479 0571 03       		.byte	3
 10480 0572 00       		.byte	0
 10481 0573 4E       		.byte	78
 10482 0574 00       		.byte	0
 10483 0575 4E       		.byte	78
 10484 0576 00       		.byte	0
 10485 0577 30       		.byte	48
 10486 0578 01       		.byte	1
 10487 0579 00       		.byte	0
 10488 057a 00       		.byte	0
 10489 057b 00000000 		.space	5
 10489      00
 10490 0580 04       		.byte	4
 10491 0581 00       		.byte	0
 10492 0582 01       		.byte	1
 10493 0583 00       		.byte	0
 10494 0584 00       		.byte	0
 10495 0585 00       		.byte	0
 10496 0586 00       		.byte	0
 10497 0587 01       		.byte	1
 10498 0588 00       		.byte	0
 10499 0589 03       		.byte	3
 10500 058a 00       		.byte	0
 10501 058b 00       		.byte	0
 10502 058c 00       		.byte	0
 10503 058d 00       		.byte	0
 10504 058e 00       		.byte	0
 10505 058f 30       		.byte	48
 10506 0590 01       		.byte	1
 10507 0591 00       		.byte	0
 10508 0592 00       		.byte	0
 10509 0593 00000000 		.space	5
 10509      00
 10510 0598 05       		.byte	5
 10511 0599 00       		.byte	0
 10512 059a 02       		.byte	2
 10513 059b 00       		.byte	0
 10514 059c 00       		.byte	0
 10515 059d FF       		.byte	-1
 10516 059e 00       		.byte	0
 10517 059f 01       		.byte	1
 10518 05a0 00       		.byte	0
 10519 05a1 03       		.byte	3
 10520 05a2 00       		.byte	0
 10521 05a3 01       		.byte	1
 10522 05a4 00       		.byte	0
 10523 05a5 00       		.byte	0
 10524 05a6 00       		.byte	0
 10525 05a7 30       		.byte	48
 10526 05a8 01       		.byte	1
 10527 05a9 01       		.byte	1
 10528 05aa 00       		.byte	0
 10529 05ab 00000000 		.space	5
 10529      00
 10530 05b0 06       		.byte	6
 10531 05b1 00       		.byte	0
 10532 05b2 02       		.byte	2
 10533 05b3 00       		.byte	0
 10534 05b4 00       		.byte	0
 10535 05b5 00       		.byte	0
 10536 05b6 00       		.byte	0
 10537 05b7 00       		.byte	0
 10538 05b8 00       		.byte	0
 10539 05b9 03       		.byte	3
 10540 05ba 00       		.byte	0
 10541 05bb 00       		.byte	0
 10542 05bc 00       		.byte	0
 10543 05bd 00       		.byte	0
 10544 05be 00       		.byte	0
 10545 05bf 30       		.byte	48
 10546 05c0 01       		.byte	1
 10547 05c1 01       		.byte	1
 10548 05c2 00       		.byte	0
 10549 05c3 00000000 		.space	5
 10549      00
 10550 05c8 23       		.byte	35
 10551 05c9 00       		.byte	0
 10552 05ca 02       		.byte	2
 10553 05cb 00       		.byte	0
 10554 05cc 00       		.byte	0
 10555 05cd 30       		.byte	48
 10556 05ce 00       		.byte	0
 10557 05cf 01       		.byte	1
 10558 05d0 00       		.byte	0
 10559 05d1 03       		.byte	3
 10560 05d2 0A       		.byte	10
 10561 05d3 00       		.byte	0
 10562 05d4 00       		.byte	0
 10563 05d5 0A       		.byte	10
 10564 05d6 00       		.byte	0
 10565 05d7 30       		.byte	48
 10566 05d8 01       		.byte	1
 10567 05d9 01       		.byte	1
 10568 05da 00       		.byte	0
 10569 05db 00000000 		.space	5
 10569      00
 10570 05e0 08       		.byte	8
 10571 05e1 00       		.byte	0
 10572 05e2 01       		.byte	1
 10573 05e3 00       		.byte	0
 10574 05e4 00       		.byte	0
 10575 05e5 7F       		.byte	127
 10576 05e6 00       		.byte	0
 10577 05e7 01       		.byte	1
 10578 05e8 00       		.byte	0
 10579 05e9 03       		.byte	3
 10580 05ea 00       		.byte	0
 10581 05eb 00       		.byte	0
 10582 05ec 00       		.byte	0
 10583 05ed 00       		.byte	0
 10584 05ee 00       		.byte	0
 10585 05ef 30       		.byte	48
 10586 05f0 01       		.byte	1
 10587 05f1 00       		.byte	0
 10588 05f2 00       		.byte	0
 10589 05f3 00000000 		.space	5
 10589      00
 10590 05f8 09       		.byte	9
 10591 05f9 00       		.byte	0
 10592 05fa 02       		.byte	2
 10593 05fb 00       		.byte	0
 10594 05fc 00       		.byte	0
 10595 05fd 05       		.byte	5
 10596 05fe 00       		.byte	0
 10597 05ff 01       		.byte	1
 10598 0600 00       		.byte	0
 10599 0601 03       		.byte	3
 10600 0602 00       		.byte	0
 10601 0603 00       		.byte	0
 10602 0604 00       		.byte	0
 10603 0605 00       		.byte	0
 10604 0606 00       		.byte	0
 10605 0607 30       		.byte	48
 10606 0608 01       		.byte	1
 10607 0609 00       		.byte	0
 10608 060a 00       		.byte	0
 10609 060b 00000000 		.space	5
 10609      00
 10610 0610 10       		.byte	16
 10611 0611 00       		.byte	0
 10612 0612 03       		.byte	3
 10613 0613 00       		.byte	0
 10614 0614 00       		.byte	0
 10615 0615 00       		.byte	0
 10616 0616 00       		.byte	0
 10617 0617 00       		.byte	0
 10618 0618 00       		.byte	0
 10619 0619 03       		.byte	3
 10620 061a 00       		.byte	0
 10621 061b 00       		.byte	0
 10622 061c 00       		.byte	0
 10623 061d 00       		.byte	0
 10624 061e 00       		.byte	0
 10625 061f 30       		.byte	48
 10626 0620 01       		.byte	1
 10627 0621 00       		.byte	0
 10628 0622 00       		.byte	0
 10629 0623 00000000 		.space	5
 10629      00
 10630 0628 00       		.byte	0
 10631 0629 00       		.byte	0
 10632 062a 02       		.byte	2
 10633 062b 00       		.byte	0
 10634 062c 00       		.byte	0
 10635 062d 40       		.byte	64
 10636 062e 00       		.byte	0
 10637 062f 01       		.byte	1
 10638 0630 00       		.byte	0
 10639 0631 03       		.byte	3
 10640 0632 00       		.byte	0
 10641 0633 0F       		.byte	15
 10642 0634 11       		.byte	17
 10643 0635 00       		.byte	0
 10644 0636 00       		.byte	0
 10645 0637 30       		.byte	48
 10646 0638 01       		.byte	1
 10647 0639 00       		.byte	0
 10648 063a 00       		.byte	0
 10649 063b 00000000 		.space	5
 10649      00
 10650 0640 00       		.byte	0
 10651 0641 00       		.byte	0
 10652 0642 02       		.byte	2
 10653 0643 00       		.byte	0
 10654 0644 00       		.byte	0
 10655 0645 64       		.byte	100
 10656 0646 00       		.byte	0
 10657 0647 01       		.byte	1
 10658 0648 00       		.byte	0
 10659 0649 03       		.byte	3
 10660 064a 00       		.byte	0
 10661 064b 00       		.byte	0
 10662 064c 00       		.byte	0
 10663 064d 00       		.byte	0
 10664 064e 00       		.byte	0
 10665 064f 30       		.byte	48
 10666 0650 01       		.byte	1
 10667 0651 00       		.byte	0
 10668 0652 00       		.byte	0
 10669 0653 00000000 		.space	5
 10669      00
 10670 0658 00       		.byte	0
 10671 0659 00       		.byte	0
 10672 065a 02       		.byte	2
 10673 065b 00       		.byte	0
 10674 065c 00       		.byte	0
 10675 065d 64       		.byte	100
 10676 065e 00       		.byte	0
 10677 065f 01       		.byte	1
 10678 0660 00       		.byte	0
 10679 0661 03       		.byte	3
 10680 0662 00       		.byte	0
 10681 0663 00       		.byte	0
 10682 0664 00       		.byte	0
 10683 0665 00       		.byte	0
 10684 0666 00       		.byte	0
 10685 0667 30       		.byte	48
 10686 0668 01       		.byte	1
 10687 0669 00       		.byte	0
 10688 066a 00       		.byte	0
 10689 066b 00000000 		.space	5
 10689      00
 10690 0670 00       		.byte	0
 10691 0671 00       		.byte	0
 10692 0672 02       		.byte	2
 10693 0673 00       		.byte	0
 10694 0674 00       		.byte	0
 10695 0675 64       		.byte	100
 10696 0676 00       		.byte	0
 10697 0677 01       		.byte	1
 10698 0678 00       		.byte	0
 10699 0679 03       		.byte	3
 10700 067a 00       		.byte	0
 10701 067b 00       		.byte	0
 10702 067c 00       		.byte	0
 10703 067d 00       		.byte	0
 10704 067e 00       		.byte	0
 10705 067f 30       		.byte	48
 10706 0680 01       		.byte	1
 10707 0681 00       		.byte	0
 10708 0682 00       		.byte	0
 10709 0683 00000000 		.space	5
 10709      00
 10710 0688 00       		.byte	0
 10711 0689 00       		.byte	0
 10712 068a 02       		.byte	2
 10713 068b 00       		.byte	0
 10714 068c 00       		.byte	0
 10715 068d 64       		.byte	100
 10716 068e 00       		.byte	0
 10717 068f 01       		.byte	1
 10718 0690 00       		.byte	0
 10719 0691 03       		.byte	3
 10720 0692 00       		.byte	0
 10721 0693 00       		.byte	0
 10722 0694 00       		.byte	0
 10723 0695 00       		.byte	0
 10724 0696 00       		.byte	0
 10725 0697 30       		.byte	48
 10726 0698 01       		.byte	1
 10727 0699 00       		.byte	0
 10728 069a 00       		.byte	0
 10729 069b 00000000 		.space	5
 10729      00
 10732              	glProbeCtrlFull:
 10733 06a0 00       		.byte	0
 10734 06a1 00       		.byte	0
 10735 06a2 01       		.byte	1
 10736 06a3 01       		.byte	1
 10737 06a4 15       		.byte	21
 10738 06a5 16       		.byte	22
 10739 06a6 05       		.byte	5
 10740 06a7 00       		.byte	0
 10741 06a8 00       		.byte	0
 10742 06a9 00       		.byte	0
 10743 06aa 00       		.byte	0
 10744 06ab 00       		.byte	0
 10745 06ac 00       		.byte	0
 10746 06ad 00       		.byte	0
 10747 06ae 00       		.byte	0
 10748 06af 00       		.byte	0
 10749 06b0 00       		.byte	0
 10750 06b1 00       		.byte	0
 10751 06b2 00       		.byte	0
 10752 06b3 C6       		.byte	-58
 10753 06b4 99       		.byte	-103
 10754 06b5 00       		.byte	0
 10755 06b6 00       		.byte	0
 10756 06b7 40       		.byte	64
 10757 06b8 00       		.byte	0
 10758 06b9 00       		.byte	0
 10759 06ba 0000     		.space	2
 10762              	glProbeCtrl20:
 10763 06bc 00       		.byte	0
 10764 06bd 00       		.byte	0
 10765 06be 01       		.byte	1
 10766 06bf 01       		.byte	1
 10767 06c0 80       		.byte	-128
 10768 06c1 1A       		.byte	26
 10769 06c2 06       		.byte	6
 10770 06c3 00       		.byte	0
 10771 06c4 00       		.byte	0
 10772 06c5 00       		.byte	0
 10773 06c6 00       		.byte	0
 10774 06c7 00       		.byte	0
 10775 06c8 00       		.byte	0
 10776 06c9 00       		.byte	0
 10777 06ca 00       		.byte	0
 10778 06cb 00       		.byte	0
 10779 06cc 00       		.byte	0
 10780 06cd 00       		.byte	0
 10781 06ce 00       		.byte	0
 10782 06cf D2       		.byte	-46
 10783 06d0 0F       		.byte	15
 10784 06d1 00       		.byte	0
 10785 06d2 00       		.byte	0
 10786 06d3 40       		.byte	64
 10787 06d4 00       		.byte	0
 10788 06d5 00       		.byte	0
 10789 06d6 0000     		.space	2
 10792              	glProbeCtrl:
 10793 06d8 00       		.byte	0
 10794 06d9 00       		.byte	0
 10795 06da 01       		.byte	1
 10796 06db 01       		.byte	1
 10797 06dc 15       		.byte	21
 10798 06dd 16       		.byte	22
 10799 06de 05       		.byte	5
 10800 06df 00       		.byte	0
 10801 06e0 00       		.byte	0
 10802 06e1 00       		.byte	0
 10803 06e2 00       		.byte	0
 10804 06e3 00       		.byte	0
 10805 06e4 00       		.byte	0
 10806 06e5 00       		.byte	0
 10807 06e6 00       		.byte	0
 10808 06e7 00       		.byte	0
 10809 06e8 00       		.byte	0
 10810 06e9 00       		.byte	0
 10811 06ea 00       		.byte	0
 10812 06eb 48       		.byte	72
 10813 06ec 3F       		.byte	63
 10814 06ed 00       		.byte	0
 10815 06ee 00       		.byte	0
 10816 06ef 40       		.byte	64
 10817 06f0 00       		.byte	0
 10818 06f1 00       		.byte	0
 10819 06f2 0000     		.space	2
 10822              	glProbeStilCtrl:
 10823 06f4 01       		.byte	1
 10824 06f5 02       		.byte	2
 10825 06f6 00       		.byte	0
 10826 06f7 00       		.byte	0
 10827 06f8 C6       		.byte	-58
 10828 06f9 99       		.byte	-103
 10829 06fa 00       		.byte	0
 10830 06fb 00       		.byte	0
 10831 06fc 40       		.byte	64
 10832 06fd 00       		.byte	0
 10833 06fe 00       		.byte	0
 10834 06ff 00       		.space	1
 10837              	glProbeStilCtrl20:
 10838 0700 01       		.byte	1
 10839 0701 01       		.byte	1
 10840 0702 00       		.byte	0
 10841 0703 00       		.byte	0
 10842 0704 D2       		.byte	-46
 10843 0705 0F       		.byte	15
 10844 0706 00       		.byte	0
 10845 0707 00       		.byte	0
 10846 0708 40       		.byte	64
 10847 0709 00       		.byte	0
 10848 070a 00       		.byte	0
 10851              	snapButFlag:
 10852 070b 01       		.byte	1
 10855              	CyFxGpifTransition:
 10856 070c 0000     		.short	0
 10857 070e 5555     		.short	21845
 10858 0710 8888     		.short	-30584
 10859 0712 AAAA     		.short	-21846
 10860 0714 3333     		.short	13107
 10861 0716 0000     		.space	2
 10864              	CyFxGpifWavedata:
 10865 0718 0181731E 		.word	510886145
 10866 071c 00000000 		.word	0
 10867 0720 00000080 		.word	-2147483648
 10868 0724 00000000 		.word	0
 10869 0728 00000000 		.word	0
 10870 072c 00000000 		.word	0
 10871 0730 0201702E 		.word	779092226
 10872 0734 00010000 		.word	256
 10873 0738 A0000080 		.word	-2147483488
 10874 073c 00000000 		.word	0
 10875 0740 00000000 		.word	0
 10876 0744 00000000 		.word	0
 10877 0748 0380722E 		.word	779255811
 10878 074c 02010020 		.word	536871170
 10879 0750 60000080 		.word	-2147483552
 10880 0754 00000000 		.word	0
 10881 0758 00000000 		.word	0
 10882 075c 00000000 		.word	0
 10883 0760 0460722E 		.word	779247620
 10884 0764 02010024 		.word	603980034
 10885 0768 90000080 		.word	-2147483504
 10886 076c 0594731E 		.word	510891013
 10887 0770 06000000 		.word	6
 10888 0774 00000080 		.word	-2147483648
 10889 0778 0380722E 		.word	779255811
 10890 077c 02010020 		.word	536871170
 10891 0780 60000080 		.word	-2147483552
 10892 0784 0693731E 		.word	510890758
 10893 0788 06000000 		.word	6
 10894 078c 00000080 		.word	-2147483648
 10895 0790 0720703E 		.word	1047535623
 10896 0794 08010000 		.word	264
 10897 0798 00000080 		.word	-2147483648
 10898 079c 0820703E 		.word	1047535624
 10899 07a0 08010000 		.word	264
 10900 07a4 00000080 		.word	-2147483648
 10901 07a8 0920703E 		.word	1047535625
 10902 07ac 08010000 		.word	264
 10903 07b0 00000080 		.word	-2147483648
 10904 07b4 0A20703E 		.word	1047535626
 10905 07b8 08010000 		.word	264
 10906 07bc 00000080 		.word	-2147483648
 10907 07c0 0380722E 		.word	779255811
 10908 07c4 02010020 		.word	536871170
 10909 07c8 60000080 		.word	-2147483552
 10910 07cc 0B000000 		.word	11
 10911 07d0 00000000 		.word	0
 10912 07d4 00010080 		.word	-2147483392
 10913 07d8 0460722E 		.word	779247620
 10914 07dc 02010024 		.word	603980034
 10915 07e0 90000080 		.word	-2147483504
 10916 07e4 0D000000 		.word	13
 10917 07e8 00000000 		.word	0
 10918 07ec 00010080 		.word	-2147483392
 10919 07f0 0460722E 		.word	779247620
 10920 07f4 02010024 		.word	603980034
 10921 07f8 90000080 		.word	-2147483504
 10922 07fc 0C000000 		.word	12
 10923 0800 00000000 		.word	0
 10924 0804 00010080 		.word	-2147483392
 10925 0808 0380722E 		.word	779255811
 10926 080c 02010020 		.word	536871170
 10927 0810 60000080 		.word	-2147483552
 10928 0814 0E000000 		.word	14
 10929 0818 00000000 		.word	0
 10930 081c 00010080 		.word	-2147483392
 10931 0820 00000000 		.word	0
 10932 0824 00000000 		.word	0
 10933 0828 00000000 		.word	0
 10934 082c 00000000 		.word	0
 10935 0830 00000000 		.word	0
 10936 0834 00000000 		.word	0
 10939              	CyFxGpifWavedataPosition:
 10940 0838 00       		.byte	0
 10941 0839 01       		.byte	1
 10942 083a 02       		.byte	2
 10943 083b 03       		.byte	3
 10944 083c 04       		.byte	4
 10945 083d 05       		.byte	5
 10946 083e 06       		.byte	6
 10947 083f 07       		.byte	7
 10948 0840 08       		.byte	8
 10949 0841 09       		.byte	9
 10950 0842 0A       		.byte	10
 10951 0843 0B       		.byte	11
 10952 0844 0B       		.byte	11
 10953 0845 0B       		.byte	11
 10954 0846 0B       		.byte	11
 10955 0847 00       		.space	1
 10958              	CyFxGpifRegValue:
 10959 0848 08830080 		.word	-2147450104
 10960 084c 67000000 		.word	103
 10961 0850 00000000 		.word	0
 10962 0854 46000000 		.word	70
 10963 0858 00000000 		.word	0
 10964 085c 00000000 		.word	0
 10965 0860 02000000 		.word	2
 10966 0864 82000000 		.word	130
 10967 0868 82070000 		.word	1922
 10968 086c 40040000 		.word	1088
 10969 0870 FCFF0000 		.word	65532
 10970 0874 28000000 		.word	40
 10971 0878 00000000 		.word	0
 10972 087c 00000000 		.word	0
 10973 0880 00000000 		.word	0
 10974 0884 00000000 		.word	0
 10975 0888 01000000 		.word	1
 10976 088c 00000000 		.word	0
 10977 0890 00000000 		.word	0
 10978 0894 00000000 		.word	0
 10979 0898 00000000 		.word	0
 10980 089c 00000000 		.word	0
 10981 08a0 00000000 		.word	0
 10982 08a4 00000000 		.word	0
 10983 08a8 00000000 		.word	0
 10984 08ac 00000000 		.word	0
 10985 08b0 00000000 		.word	0
 10986 08b4 00000000 		.word	0
 10987 08b8 00000000 		.word	0
 10988 08bc 06000000 		.word	6
 10989 08c0 00000000 		.word	0
 10990 08c4 FFFF0000 		.word	65535
 10991 08c8 09010000 		.word	265
 10992 08cc 00000000 		.word	0
 10993 08d0 F71F0000 		.word	8183
 10994 08d4 00000000 		.word	0
 10995 08d8 FFFF0000 		.word	65535
 10996 08dc 09010000 		.word	265
 10997 08e0 00000000 		.word	0
 10998 08e4 F71F0000 		.word	8183
 10999 08e8 00000000 		.word	0
 11000 08ec 00000000 		.word	0
 11001 08f0 00000000 		.word	0
 11002 08f4 00000000 		.word	0
 11003 08f8 00000000 		.word	0
 11004 08fc 00000000 		.word	0
 11005 0900 00000000 		.word	0
 11006 0904 00000000 		.word	0
 11007 0908 00000000 		.word	0
 11008 090c 00000000 		.word	0
 11009 0910 00000000 		.word	0
 11010 0914 00000000 		.word	0
 11011 0918 00000000 		.word	0
 11012 091c 00000000 		.word	0
 11013 0920 00000000 		.word	0
 11014 0924 00000000 		.word	0
 11015 0928 00000000 		.word	0
 11016 092c 00000000 		.word	0
 11017 0930 00000000 		.word	0
 11018 0934 00000000 		.word	0
 11019 0938 00000000 		.word	0
 11020 093c 00000000 		.word	0
 11021 0940 00000000 		.word	0
 11022 0944 00040180 		.word	-2147417088
 11023 0948 01040180 		.word	-2147417087
 11024 094c 02040180 		.word	-2147417086
 11025 0950 03040180 		.word	-2147417085
 11026 0954 00000000 		.word	0
 11027 0958 00000000 		.word	0
 11028 095c 00000000 		.word	0
 11029 0960 00000000 		.word	0
 11030 0964 00000000 		.word	0
 11031 0968 00000000 		.word	0
 11032 096c 00000000 		.word	0
 11033 0970 00000000 		.word	0
 11034 0974 C1FFFFFF 		.word	-63
 11037              	CyFxGpifTransition_usb2:
 11038 0978 0000     		.short	0
 11039 097a 5555     		.short	21845
 11040 097c AAAA     		.short	-21846
 11041 097e 8888     		.short	-30584
 11042 0980 1111     		.short	4369
 11043 0982 4444     		.short	17476
 11044 0984 3333     		.short	13107
 11045 0986 CCCC     		.short	-13108
 11048              	CyFxGpifWavedata_usb2:
 11049 0988 0181731E 		.word	510886145
 11050 098c 00000000 		.word	0
 11051 0990 00000080 		.word	-2147483648
 11052 0994 00000000 		.word	0
 11053 0998 00000000 		.word	0
 11054 099c 00000000 		.word	0
 11055 09a0 0201703E 		.word	1047527682
 11056 09a4 00010000 		.word	256
 11057 09a8 A00000C0 		.word	-1073741664
 11058 09ac 00000000 		.word	0
 11059 09b0 00000000 		.word	0
 11060 09b4 00000000 		.word	0
 11061 09b8 0394731E 		.word	510891011
 11062 09bc 04000020 		.word	536870916
 11063 09c0 60004080 		.word	-2143289248
 11064 09c4 00000000 		.word	0
 11065 09c8 00000000 		.word	0
 11066 09cc 00000000 		.word	0
 11067 09d0 0620702E 		.word	779100166
 11068 09d4 0C000000 		.word	12
 11069 09d8 00000080 		.word	-2147483648
 11070 09dc 0620702E 		.word	779100166
 11071 09e0 0C000000 		.word	12
 11072 09e4 00000080 		.word	-2147483648
 11073 09e8 0394731E 		.word	510891011
 11074 09ec 04000020 		.word	536870916
 11075 09f0 60004080 		.word	-2143289248
 11076 09f4 0620702E 		.word	779100166
 11077 09f8 0C000000 		.word	12
 11078 09fc 00000080 		.word	-2147483648
 11079 0a00 0C93731E 		.word	510890764
 11080 0a04 04000024 		.word	603979780
 11081 0a08 90004080 		.word	-2143289200
 11082 0a0c 0D20702E 		.word	779100173
 11083 0a10 0C000000 		.word	12
 11084 0a14 00000080 		.word	-2147483648
 11085 0a18 0780724E 		.word	1316126727
 11086 0a1c 0A000000 		.word	10
 11087 0a20 00000080 		.word	-2147483648
 11088 0a24 08000000 		.word	8
 11089 0a28 00000000 		.word	0
 11090 0a2c 00010080 		.word	-2147483392
 11091 0a30 0920702E 		.word	779100169
 11092 0a34 0C010000 		.word	268
 11093 0a38 00000080 		.word	-2147483648
 11094 0a3c 0A01701E 		.word	510656778
 11095 0a40 0E000100 		.word	65550
 11096 0a44 00000080 		.word	-2147483648
 11097 0a48 00000000 		.word	0
 11098 0a4c 00000000 		.word	0
 11099 0a50 00000000 		.word	0
 11100 0a54 00000000 		.word	0
 11101 0a58 00000000 		.word	0
 11102 0a5c 00000000 		.word	0
 11103 0a60 0394731E 		.word	510891011
 11104 0a64 04000020 		.word	536870916
 11105 0a68 60004080 		.word	-2143289248
 11106 0a6c 08000000 		.word	8
 11107 0a70 00000000 		.word	0
 11108 0a74 00010080 		.word	-2147483392
 11109 0a78 0B000000 		.word	11
 11110 0a7c 00000000 		.word	0
 11111 0a80 00010080 		.word	-2147483392
 11112 0a84 0C93731E 		.word	510890764
 11113 0a88 04000024 		.word	603979780
 11114 0a8c 90004080 		.word	-2143289200
 11115 0a90 0D20702E 		.word	779100173
 11116 0a94 0C000000 		.word	12
 11117 0a98 00000080 		.word	-2147483648
 11118 0a9c 0D20702E 		.word	779100173
 11119 0aa0 0C000000 		.word	12
 11120 0aa4 00000080 		.word	-2147483648
 11121 0aa8 0E60724E 		.word	1316118542
 11122 0aac 0A000000 		.word	10
 11123 0ab0 00000080 		.word	-2147483648
 11124 0ab4 0F000000 		.word	15
 11125 0ab8 00000000 		.word	0
 11126 0abc 00010080 		.word	-2147483392
 11127 0ac0 1020702E 		.word	779100176
 11128 0ac4 0C010000 		.word	268
 11129 0ac8 00000080 		.word	-2147483648
 11130 0acc 1101701E 		.word	510656785
 11131 0ad0 0E000100 		.word	65550
 11132 0ad4 00000080 		.word	-2147483648
 11133 0ad8 0C93731E 		.word	510890764
 11134 0adc 04000024 		.word	603979780
 11135 0ae0 90004080 		.word	-2143289200
 11136 0ae4 0F000000 		.word	15
 11137 0ae8 00000000 		.word	0
 11138 0aec 00010080 		.word	-2147483392
 11139 0af0 12000000 		.word	18
 11140 0af4 00000000 		.word	0
 11141 0af8 00010080 		.word	-2147483392
 11142 0afc 0394731E 		.word	510891011
 11143 0b00 04000020 		.word	536870916
 11144 0b04 60004080 		.word	-2143289248
 11145 0b08 0480732E 		.word	779321348
 11146 0b0c 02010000 		.word	258
 11147 0b10 0000C0C0 		.word	-1061158912
 11148 0b14 0580732E 		.word	779321349
 11149 0b18 02010000 		.word	258
 11150 0b1c 0000C0C0 		.word	-1061158912
 11151 0b20 0580732E 		.word	779321349
 11152 0b24 02010000 		.word	258
 11153 0b28 0000C0C0 		.word	-1061158912
 11154 0b2c 0480732E 		.word	779321348
 11155 0b30 02010000 		.word	258
 11156 0b34 0000C0C0 		.word	-1061158912
 11159              	CyFxGpifWavedataPosition_usb2:
 11160 0b38 00       		.byte	0
 11161 0b39 01       		.byte	1
 11162 0b3a 02       		.byte	2
 11163 0b3b 03       		.byte	3
 11164 0b3c 04       		.byte	4
 11165 0b3d 05       		.byte	5
 11166 0b3e 06       		.byte	6
 11167 0b3f 07       		.byte	7
 11168 0b40 08       		.byte	8
 11169 0b41 09       		.byte	9
 11170 0b42 0A       		.byte	10
 11171 0b43 08       		.byte	8
 11172 0b44 0B       		.byte	11
 11173 0b45 0C       		.byte	12
 11174 0b46 0D       		.byte	13
 11175 0b47 08       		.byte	8
 11176 0b48 0E       		.byte	14
 11177 0b49 0F       		.byte	15
 11178 0b4a 08       		.byte	8
 11179 0b4b 08       		.byte	8
 11180 0b4c 08       		.byte	8
 11181 0b4d 08       		.byte	8
 11182 0b4e 08       		.byte	8
 11183 0b4f 08       		.byte	8
 11184 0b50 08       		.byte	8
 11185 0b51 08       		.byte	8
 11186 0b52 08       		.byte	8
 11187 0b53 08       		.byte	8
 11188 0b54 08       		.byte	8
 11189 0b55 08       		.byte	8
 11190 0b56 08       		.byte	8
 11191 0b57 08       		.byte	8
 11192 0b58 08       		.byte	8
 11193 0b59 08       		.byte	8
 11194 0b5a 08       		.byte	8
 11195 0b5b 08       		.byte	8
 11196 0b5c 08       		.byte	8
 11197 0b5d 08       		.byte	8
 11198 0b5e 08       		.byte	8
 11199 0b5f 08       		.byte	8
 11200 0b60 08       		.byte	8
 11201 0b61 08       		.byte	8
 11202 0b62 08       		.byte	8
 11203 0b63 08       		.byte	8
 11204 0b64 08       		.byte	8
 11205 0b65 08       		.byte	8
 11206 0b66 08       		.byte	8
 11207 0b67 08       		.byte	8
 11208 0b68 08       		.byte	8
 11209 0b69 08       		.byte	8
 11210 0b6a 08       		.byte	8
 11211 0b6b 08       		.byte	8
 11212 0b6c 08       		.byte	8
 11213 0b6d 08       		.byte	8
 11214 0b6e 08       		.byte	8
 11215 0b6f 08       		.byte	8
 11216 0b70 08       		.byte	8
 11217 0b71 08       		.byte	8
 11218 0b72 08       		.byte	8
 11219 0b73 08       		.byte	8
 11220 0b74 08       		.byte	8
 11221 0b75 08       		.byte	8
 11222 0b76 08       		.byte	8
 11223 0b77 08       		.byte	8
 11224 0b78 08       		.byte	8
 11225 0b79 08       		.byte	8
 11226 0b7a 08       		.byte	8
 11227 0b7b 08       		.byte	8
 11228 0b7c 08       		.byte	8
 11229 0b7d 08       		.byte	8
 11230 0b7e 08       		.byte	8
 11231 0b7f 08       		.byte	8
 11232 0b80 08       		.byte	8
 11233 0b81 08       		.byte	8
 11234 0b82 08       		.byte	8
 11235 0b83 08       		.byte	8
 11236 0b84 08       		.byte	8
 11237 0b85 08       		.byte	8
 11238 0b86 08       		.byte	8
 11239 0b87 08       		.byte	8
 11240 0b88 08       		.byte	8
 11241 0b89 08       		.byte	8
 11242 0b8a 08       		.byte	8
 11243 0b8b 08       		.byte	8
 11244 0b8c 08       		.byte	8
 11245 0b8d 08       		.byte	8
 11246 0b8e 08       		.byte	8
 11247 0b8f 08       		.byte	8
 11248 0b90 08       		.byte	8
 11249 0b91 08       		.byte	8
 11250 0b92 08       		.byte	8
 11251 0b93 08       		.byte	8
 11252 0b94 08       		.byte	8
 11253 0b95 08       		.byte	8
 11254 0b96 08       		.byte	8
 11255 0b97 08       		.byte	8
 11256 0b98 08       		.byte	8
 11257 0b99 08       		.byte	8
 11258 0b9a 08       		.byte	8
 11259 0b9b 08       		.byte	8
 11260 0b9c 08       		.byte	8
 11261 0b9d 08       		.byte	8
 11262 0b9e 08       		.byte	8
 11263 0b9f 08       		.byte	8
 11264 0ba0 08       		.byte	8
 11265 0ba1 08       		.byte	8
 11266 0ba2 08       		.byte	8
 11267 0ba3 08       		.byte	8
 11268 0ba4 08       		.byte	8
 11269 0ba5 08       		.byte	8
 11270 0ba6 08       		.byte	8
 11271 0ba7 08       		.byte	8
 11272 0ba8 08       		.byte	8
 11273 0ba9 08       		.byte	8
 11274 0baa 08       		.byte	8
 11275 0bab 08       		.byte	8
 11276 0bac 08       		.byte	8
 11277 0bad 08       		.byte	8
 11278 0bae 08       		.byte	8
 11279 0baf 08       		.byte	8
 11280 0bb0 08       		.byte	8
 11281 0bb1 08       		.byte	8
 11282 0bb2 08       		.byte	8
 11283 0bb3 08       		.byte	8
 11284 0bb4 08       		.byte	8
 11285 0bb5 08       		.byte	8
 11286 0bb6 08       		.byte	8
 11287 0bb7 08       		.byte	8
 11288 0bb8 00       		.byte	0
 11289 0bb9 01       		.byte	1
 11290 0bba 02       		.byte	2
 11291 0bbb 10       		.byte	16
 11292 0bbc 04       		.byte	4
 11293 0bbd 05       		.byte	5
 11294 0bbe 06       		.byte	6
 11295 0bbf 07       		.byte	7
 11296 0bc0 08       		.byte	8
 11297 0bc1 09       		.byte	9
 11298 0bc2 0A       		.byte	10
 11299 0bc3 08       		.byte	8
 11300 0bc4 11       		.byte	17
 11301 0bc5 0C       		.byte	12
 11302 0bc6 0D       		.byte	13
 11303 0bc7 08       		.byte	8
 11304 0bc8 0E       		.byte	14
 11305 0bc9 0F       		.byte	15
 11306 0bca 08       		.byte	8
 11307 0bcb 00       		.space	1
 11310              	CyFxGpifRegValue_usb2:
 11311 0bcc 08830080 		.word	-2147450104
 11312 0bd0 67000000 		.word	103
 11313 0bd4 01000000 		.word	1
 11314 0bd8 46000000 		.word	70
 11315 0bdc 00000000 		.word	0
 11316 0be0 00000000 		.word	0
 11317 0be4 02000000 		.word	2
 11318 0be8 82000000 		.word	130
 11319 0bec 82070000 		.word	1922
 11320 0bf0 40040000 		.word	1088
 11321 0bf4 FCFF0000 		.word	65532
 11322 0bf8 28000000 		.word	40
 11323 0bfc 00000000 		.word	0
 11324 0c00 00000000 		.word	0
 11325 0c04 00000000 		.word	0
 11326 0c08 00000000 		.word	0
 11327 0c0c 01000000 		.word	1
 11328 0c10 00000000 		.word	0
 11329 0c14 00000000 		.word	0
 11330 0c18 00000000 		.word	0
 11331 0c1c 00000000 		.word	0
 11332 0c20 00000000 		.word	0
 11333 0c24 00000000 		.word	0
 11334 0c28 00000000 		.word	0
 11335 0c2c 00000000 		.word	0
 11336 0c30 00000000 		.word	0
 11337 0c34 00000000 		.word	0
 11338 0c38 00000000 		.word	0
 11339 0c3c 00000000 		.word	0
 11340 0c40 06000000 		.word	6
 11341 0c44 00000000 		.word	0
 11342 0c48 FFFF0000 		.word	65535
 11343 0c4c 09010000 		.word	265
 11344 0c50 00000000 		.word	0
 11345 0c54 F71F0000 		.word	8183
 11346 0c58 00000000 		.word	0
 11347 0c5c FFFF0000 		.word	65535
 11348 0c60 09010000 		.word	265
 11349 0c64 00000000 		.word	0
 11350 0c68 F71F0000 		.word	8183
 11351 0c6c 00000000 		.word	0
 11352 0c70 00000000 		.word	0
 11353 0c74 00000000 		.word	0
 11354 0c78 00000000 		.word	0
 11355 0c7c 00000000 		.word	0
 11356 0c80 00000000 		.word	0
 11357 0c84 00000000 		.word	0
 11358 0c88 00000000 		.word	0
 11359 0c8c 00000000 		.word	0
 11360 0c90 00000000 		.word	0
 11361 0c94 00000000 		.word	0
 11362 0c98 00000000 		.word	0
 11363 0c9c 00000000 		.word	0
 11364 0ca0 00000000 		.word	0
 11365 0ca4 00000000 		.word	0
 11366 0ca8 00000000 		.word	0
 11367 0cac 00000000 		.word	0
 11368 0cb0 00000000 		.word	0
 11369 0cb4 00000000 		.word	0
 11370 0cb8 00000000 		.word	0
 11371 0cbc 00000000 		.word	0
 11372 0cc0 00000000 		.word	0
 11373 0cc4 00000000 		.word	0
 11374 0cc8 00040180 		.word	-2147417088
 11375 0ccc 01040180 		.word	-2147417087
 11376 0cd0 02040180 		.word	-2147417086
 11377 0cd4 03040180 		.word	-2147417085
 11378 0cd8 00000000 		.word	0
 11379 0cdc 00000000 		.word	0
 11380 0ce0 00000000 		.word	0
 11381 0ce4 00000000 		.word	0
 11382 0ce8 00000000 		.word	0
 11383 0cec 00000000 		.word	0
 11384 0cf0 00000000 		.word	0
 11385 0cf4 00000000 		.word	0
 11386 0cf8 C1FFFFFF 		.word	-63
 11387              		.section	.rodata.str1.4,"aMS",%progbits,1
 11388              		.align	2
 11389              	.LC0:
 11390 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 11390      7065722D 
 11390      74696D65 
 11390      72202564 
 11390      0D0A00
 11391 0013 00       		.space	1
 11392              	.LC1:
 11393 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 11393      636F6D6D 
 11393      616E6420 
 11393      71756575 
 11393      65206973 
 11394 0037 00       		.space	1
 11395              	.LC2:
 11396 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 11396      706F732D 
 11396      74696D65 
 11396      72202564 
 11396      2025640D 
 11397 004e 0000     		.space	2
 11398              	.LC3:
 11399 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 11399      5420656E 
 11399      636F756E 
 11399      74657265 
 11399      642E2E2E 
 11400              	.LC4:
 11401 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 11401      454E4420 
 11401      656E636F 
 11401      756E7465 
 11401      7265642E 
 11402 0092 0000     		.space	2
 11403              	.LC5:
 11404 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 11404      64697363 
 11404      6F6E6E65 
 11404      63746564 
 11404      2E2E2E30 
 11405 00b3 00       		.space	1
 11406              	.LC6:
 11407 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 11407      7220696E 
 11407      206D756C 
 11407      74696368 
 11407      616E6E65 
 11408 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 11408      2025782C 
 11408      20646D61 
 11408      446F6E65 
 11408      20256420 
 11409              	.LC7:
 11410 0100 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 11410      43595F46 
 11410      585F5556 
 11410      435F5649 
 11410      44454F5F 
 11411 0133 0A00     		.ascii	"\012\000"
 11412 0135 000000   		.space	3
 11413              	.LC8:
 11414 0138 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 11414      43595F46 
 11414      585F5556 
 11414      435F5649 
 11414      44454F5F 
 11415 016b 00       		.ascii	"\000"
 11416              	.LC9:
 11417 016c 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 11417      726E6174 
 11417      65207365 
 11417      7474696E 
 11417      6720302E 
 11418              	.LC10:
 11419 0184 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 11419      72206665 
 11419      61747572 
 11419      65207265 
 11419      71756573 
 11420 01a7 00       		.space	1
 11421              	.LC11:
 11422 01a8 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 11422      6F6D6D69 
 11422      74656F66 
 11422      20737461 
 11422      7465203D 
 11423              	.LC12:
 11424 01c0 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 11424      6E656C20 
 11424      53657420 
 11424      57726170 
 11424      55702066 
 11425 01ed 000000   		.space	3
 11426              	.LC13:
 11427 01f0 4572726F 		.ascii	"Error handler...\015\012\000"
 11427      72206861 
 11427      6E646C65 
 11427      722E2E2E 
 11427      0D0A00
 11428 0203 00       		.space	1
 11429              	.LC14:
 11430 0204 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 11430      69742045 
 11430      4F462066 
 11430      61696C65 
 11430      64210D0A 
 11431 0219 000000   		.space	3
 11432              	.LC15:
 11433 021c 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 11433      49324320 
 11433      636F6D6D 
 11433      616E6420 
 11433      69732030 
 11434 024f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11434      78257820 
 11434      30782578 
 11434      20307825 
 11434      78203078 
 11435              	.LC16:
 11436 0268 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 11436      49324320 
 11436      636F6D6D 
 11436      616E6420 
 11436      73657474 
 11437 028e 0000     		.space	2
 11438              	.LC17:
 11439 0290 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 11439      73687574 
 11439      74657220 
 11439      73657420 
 11439      76616C75 
 11440 02ba 0000     		.space	2
 11441              	.LC18:
 11442 02bc 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 11442      20736875 
 11442      74746572 
 11442      20737065 
 11442      65642E20 
 11443 02e1 000000   		.space	3
 11444              	.LC19:
 11445 02e4 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 11445      20736875 
 11445      74746572 
 11445      20737065 
 11445      6564322E 
 11446 030a 0000     		.space	2
 11447              	.LC20:
 11448 030c 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 11448      206C6967 
 11448      68742063 
 11448      6F6D7065 
 11448      6E736174 
 11449 033f 25640D0A 		.ascii	"%d\015\012\000"
 11449      00
 11450              	.LC21:
 11451 0344 54686520 		.ascii	"The I2C current data is not available. try again. %"
 11451      49324320 
 11451      63757272 
 11451      656E7420 
 11451      64617461 
 11452 0377 64202564 		.ascii	"d %d\015\012\000"
 11452      0D0A00
 11453 037e 0000     		.space	2
 11454              	.LC22:
 11455 0380 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 11455      26414743 
 11455      2073656E 
 11455      7420746F 
 11455      20686F73 
 11456 03a6 0000     		.space	2
 11457              	.LC23:
 11458 03a8 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11458      73687574 
 11458      74657226 
 11458      6578706F 
 11458      73757265 
 11459 03d3 00       		.space	1
 11460              	.LC24:
 11461 03d4 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 11461      26414743 
 11461      20676F74 
 11461      74656E20 
 11461      66726F6D 
 11462 0405 0A00     		.ascii	"\012\000"
 11463 0407 00       		.space	1
 11464              	.LC25:
 11465 0408 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 11465      74657220 
 11465      6C657665 
 11465      6C20676F 
 11465      7474656E 
 11466 043b 25640D0A 		.ascii	"%d\015\012\000"
 11466      00
 11467              	.LC26:
 11468 0440 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 11468      75656E63 
 11468      79207365 
 11468      7474696E 
 11468      67206973 
 11469 045e 0000     		.space	2
 11470              	.LC27:
 11471 0460 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 11471      20746865 
 11471      20766964 
 11471      656F206D 
 11471      6F646520 
 11472 0482 0000     		.space	2
 11473              	.LC28:
 11474 0484 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 11474      67657420 
 11474      64617461 
 11474      2066726F 
 11474      6D20686F 
 11475 04b1 000000   		.space	3
 11476              	.LC29:
 11477 04b4 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 11477      52657175 
 11477      65737420 
 11477      30782578 
 11477      20706172 
 11478 04e7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 11478      6E642074 
 11478      6F20686F 
 11478      73742030 
 11478      78257820 
 11479 0502 0000     		.space	2
 11480              	.LC30:
 11481 0504 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 11481      204F7020 
 11481      72656365 
 11481      69766573 
 11481      20284354 
 11482 052b 00       		.space	1
 11483              	.LC31:
 11484 052c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 11484      756C7420 
 11484      73656C65 
 11484      63746F72 
 11484      20284354 
 11485 054e 0000     		.space	2
 11486              	.LC32:
 11487 0550 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 11487      756C7420 
 11487      72657175 
 11487      65737420 
 11487      28435429 
 11488 0571 000000   		.space	3
 11489              	.LC33:
 11490 0574 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 11490      52657175 
 11490      65737420 
 11490      30782578 
 11490      20706172 
 11491 05a7 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 11491      20307825 
 11491      78202F20 
 11491      73656E64 
 11491      20746F20 
 11492 05d4 00       		.ascii	"\000"
 11493 05d5 000000   		.space	3
 11494              	.LC34:
 11495 05d8 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 11495      73706565 
 11495      64203D20 
 11495      25642065 
 11495      76656E66 
 11496 0608 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 11496      71756573 
 11496      74203D20 
 11496      30782578 
 11496      20775661 
 11497 0638 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 11497      203D2030 
 11497      78257820 
 11497      6973666C 
 11497      61672030 
 11498 0652 0000     		.space	2
 11499              	.LC35:
 11500 0654 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 11500      64656661 
 11500      756C7420 
 11500      73657475 
 11500      70207265 
 11501              	.LC36:
 11502 0680 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 11502      6F207374 
 11502      7265616D 
 11502      20474554 
 11502      20726571 
 11503 06a5 000000   		.space	3
 11504              	.LC37:
 11505 06a8 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 11505      74686520 
 11505      76696465 
 11505      6F206D6F 
 11505      64652066 
 11506 06c9 000000   		.space	3
 11507              	.LC38:
 11508 06cc 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 11508      74686520 
 11508      76696465 
 11508      6F206D6F 
 11508      64652066 
 11509 06f1 000000   		.space	3
 11510              	.LC39:
 11511 06f4 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 11511      43595F46 
 11511      585F5556 
 11511      435F5354 
 11511      5245414D 
 11512 071a 0000     		.space	2
 11513              	.LC40:
 11514 071c 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 11514      55564320 
 11514      7374696C 
 11514      6C205072 
 11514      6F622873 
 11515 0747 00       		.space	1
 11516              	.LC41:
 11517 0748 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 11517      74686520 
 11517      7374696C 
 11517      6C206D6F 
 11517      64652066 
 11518 0769 000000   		.space	3
 11519              	.LC42:
 11520 076c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 11520      7374696C 
 11520      6C20636F 
 11520      6D6D6974 
 11520      20636F6E 
 11521              	.LC43:
 11522 0794 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 11522      43595F46 
 11522      585F5556 
 11522      435F5354 
 11522      494C5F45 
 11523              	.LC44:
 11524 07b8 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 11524      55564320 
 11524      7374696C 
 11524      6C207472 
 11524      69676765 
 11525 07e1 000000   		.space	3
 11526              	.LC45:
 11527 07e4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 11527      7374696C 
 11527      6C207472 
 11527      69676765 
 11527      7220636F 
 11528 080b 00       		.space	1
 11529              	.LC46:
 11530 080c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 11530      65642074 
 11530      6F207365 
 11530      6E642069 
 11530      6E746572 
 11531 083d 0A00     		.ascii	"\012\000"
 11532 083f 00       		.space	1
 11533              	.LC47:
 11534 0840 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 11534      73657420 
 11534      64656620 
 11534      64617461 
 11534      20307825 
 11535 085f 00       		.space	1
 11536              	.LC48:
 11537 0860 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 11537      73657420 
 11537      64656620 
 11537      64617461 
 11537      20307825 
 11538 0893 2E0D0A00 		.ascii	".\015\012\000"
 11539 0897 00       		.space	1
 11540              	.LC49:
 11541 0898 55415254 		.ascii	"UART initialization failed!\012\000"
 11541      20696E69 
 11541      7469616C 
 11541      697A6174 
 11541      696F6E20 
 11542 08b5 000000   		.space	3
 11543              	.LC50:
 11544 08b8 49324320 		.ascii	"I2C initialization failed!\012\000"
 11544      696E6974 
 11544      69616C69 
 11544      7A617469 
 11544      6F6E2066 
 11545              	.LC51:
 11546 08d4 49324320 		.ascii	"I2C configuration failed!\012\000"
 11546      636F6E66 
 11546      69677572 
 11546      6174696F 
 11546      6E206661 
 11547 08ef 00       		.space	1
 11548              	.LC52:
 11549 08f0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 11549      43726561 
 11549      74652045 
 11549      76656E74 
 11549      20666169 
 11550 091a 0000     		.space	2
 11551              	.LC53:
 11552 091c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 11552      20496E69 
 11552      74206661 
 11552      696C6564 
 11552      2C204572 
 11553 093f 00       		.space	1
 11554              	.LC54:
 11555 0940 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 11555      204F7665 
 11555      72726964 
 11555      65206661 
 11555      696C6564 
 11556 0967 00       		.space	1
 11557              	.LC55:
 11558 0968 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 11558      28323029 
 11558      204F7665 
 11558      72726964 
 11558      65206661 
 11559 0993 00       		.space	1
 11560              	.LC56:
 11561 0994 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 11561      28323429 
 11561      204F7665 
 11561      72726964 
 11561      65206661 
 11562 09bf 00       		.space	1
 11563              	.LC57:
 11564 09c0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 11564      20536574 
 11564      20287265 
 11564      73657420 
 11564      32322920 
 11565 09f2 00       		.ascii	"\000"
 11566 09f3 00       		.space	1
 11567              	.LC58:
 11568 09f4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 11568      20536574 
 11568      2028706F 
 11568      77657220 
 11568      32302920 
 11569 0a26 00       		.ascii	"\000"
 11570 0a27 00       		.space	1
 11571              	.LC59:
 11572 0a28 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 11572      20536574 
 11572      2028736E 
 11572      61702073 
 11572      686F7420 
 11573 0a5b 25640A00 		.ascii	"%d\012\000"
 11574 0a5f 00       		.space	1
 11575              	.LC60:
 11576 0a60 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 11576      46756E63 
 11576      74696F6E 
 11576      20466169 
 11576      6C656420 
 11577 0a8f 00       		.space	1
 11578              	.LC61:
 11579 0a90 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 11579      46756E63 
 11579      74696F6E 
 11579      20466169 
 11579      6C656420 
 11580 0abf 00       		.space	1
 11581              	.LC62:
 11582 0ac0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 11582      53657420 
 11582      456E6470 
 11582      6F696E74 
 11582      20636F6E 
 11583 0af0 00       		.ascii	"\000"
 11584 0af1 000000   		.space	3
 11585              	.LC63:
 11586 0af4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 11586      496E7465 
 11586      72727570 
 11586      74205374 
 11586      61747573 
 11587 0b27 20436F64 		.ascii	" Code = %d\012\000"
 11587      65203D20 
 11587      25640A00 
 11588 0b33 00       		.space	1
 11589              	.LC64:
 11590 0b34 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 11590      65642074 
 11590      6F20616C 
 11590      6C6F6361 
 11590      7465206D 
 11591 0b67 65720D0A 		.ascii	"er\015\012\000"
 11591      00
 11592              	.LC65:
 11593 0b6c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 11593      4368616E 
 11593      6E656C20 
 11593      43726561 
 11593      74696F6E 
 11594 0b9a 0000     		.space	2
 11595              	.LC66:
 11596 0b9c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 11596      436F6E6E 
 11596      65637420 
 11596      6661696C 
 11596      65642C20 
 11597 0bc1 000000   		.space	3
 11598              	.LC67:
 11599 0bc4 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 11599      74686520 
 11599      76696465 
 11599      6F206D6F 
 11599      64652066 
 11600 0be6 0000     		.space	2
 11601              	.LC68:
 11602 0be8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 11602      4368616E 
 11602      6E656C20 
 11602      52657365 
 11602      74204661 
 11603 0c13 00       		.space	1
 11604              	.LC69:
 11605 0c14 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 11605      4368616E 
 11605      6E656C20 
 11605      53657420 
 11605      5472616E 
 11606 0c45 00       		.ascii	"\000"
 11607 0c46 0000     		.space	2
 11608              	.LC70:
 11609 0c48 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 11609      4368616E 
 11609      6E656C20 
 11609      53657420 
 11609      5472616E 
 11610 0c79 0A00     		.ascii	"\012\000"
 11611 0c7b 00       		.space	1
 11612              	.LC71:
 11613 0c7c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 11613      75706572 
 11613      20677069 
 11613      6600
 11614 0c8a 0000     		.space	2
 11615              	.LC72:
 11616 0c8c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 11616      69676820 
 11616      67706966 
 11616      00
 11617 0c99 000000   		.space	3
 11618              	.LC73:
 11619 0c9c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11619      696E6720 
 11619      47504946 
 11619      20436F6E 
 11619      66696775 
 11620 0ccf 0A00     		.ascii	"\012\000"
 11621 0cd1 000000   		.space	3
 11622              	.LC74:
 11623 0cd4 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11623      74696E67 
 11623      20475049 
 11623      46207374 
 11623      61746520 
 11624 0d07 0D0A00   		.ascii	"\015\012\000"
 11625 0d0a 0000     		.space	2
 11626              	.LC75:
 11627 0d0c 49324363 		.ascii	"I2CcmdQue\000"
 11627      6D645175 
 11627      6500
 11628 0d16 0000     		.space	2
 11629              	.LC76:
 11630 0d18 33303A55 		.ascii	"30:UVC App Thread\000"
 11630      56432041 
 11630      70702054 
 11630      68726561 
 11630      6400
 11631 0d2a 0000     		.space	2
 11632              	.LC77:
 11633 0d2c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11633      56432041 
 11633      70702045 
 11633      50302054 
 11633      68726561 
 11634 0d42 0000     		.space	2
 11635              	.LC78:
 11636 0d44 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11636      32432041 
 11636      70702043 
 11636      54524C20 
 11636      54687265 
 11637 0d5b 00       		.bss
 11638              		.align	2
 11639              		.set	.LANCHOR0,. + 0
 11642              	glFxUVCEvent:
 11643 0000 00000000 		.space	40
 11643      00000000 
 11643      00000000 
 11643      00000000 
 11643      00000000 
 11646              	gpif_initialized:
 11647 0028 00000000 		.space	4
 11650              	streamingStarted:
 11651 002c 00000000 		.space	4
 11654              	isUsbConnected:
 11655 0030 00000000 		.space	4
 11658              	fb:
 11659 0034 0000     		.space	2
 11662              	pb:
 11663 0036 0000     		.space	2
 11666              	pbc:
 11667 0038 0000     		.space	2
 11670              	stiflag:
 11671 003a 00       		.space	1
 11672 003b 00       		.space	1
 11675              	hitFV:
 11676 003c 00000000 		.space	4
 11679              	prodCount:
 11680 0040 0000     		.space	2
 11683              	consCount:
 11684 0042 0000     		.space	2
 11687              	clearFeatureRqtReceived:
 11688 0044 00000000 		.space	4
 11691              	usbSpeed:
 11692 0048 00       		.space	1
 11693 0049 000000   		.space	3
 11696              	I2CCMDArry:
 11697 004c 00000000 		.space	12
 11697      00000000 
 11697      00000000 
 11700              	is60Hz:
 11701 0058 00000000 		.space	4
 11704              	glEp0Buffer:
 11705 005c 00000000 		.space	32
 11705      00000000 
 11705      00000000 
 11705      00000000 
 11705      00000000 
 11708              	curFlag:
 11709 007c 00000000 		.space	64
 11709      00000000 
 11709      00000000 
 11709      00000000 
 11709      00000000 
 11712              	CamMode:
 11713 00bc 00       		.space	1
 11716              	setRes:
 11717 00bd 00       		.space	1
 11718 00be 0000     		.space	2
 11721              	glCommitCtrl:
 11722 00c0 00000000 		.space	32
 11722      00000000 
 11722      00000000 
 11722      00000000 
 11722      00000000 
 11725              	setstilRes:
 11726 00e0 00       		.space	1
 11729              	IMcount.7858:
 11730 00e1 00       		.space	1
 11731 00e2 0000     		.space	2
 11734              	uvcAppThread:
 11735 00e4 00000000 		.space	168
 11735      00000000 
 11735      00000000 
 11735      00000000 
 11735      00000000 
 11738              	uvcAppEP0Thread:
 11739 018c 00000000 		.space	168
 11739      00000000 
 11739      00000000 
 11739      00000000 
 11739      00000000 
 11742              	i2cAppThread:
 11743 0234 00000000 		.space	168
 11743      00000000 
 11743      00000000 
 11743      00000000 
 11743      00000000 
 11746              	testSnap:
 11747 02dc 00       		.space	1
 11748 02dd 00       		.space	1
 11751              	fbbak:
 11752 02de 0000     		.space	2
 11755              	pbbak:
 11756 02e0 0000     		.space	2
 11759              	pbcbak:
 11760 02e2 0000     		.space	2
 11763              	pbcpbak:
 11764 02e4 0000     		.space	2
 11765 02e6 0000     		.text
 11766              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:199    .text:00000168 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:206    .text:00000178 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:307    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:321    .text:0000025c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:318    .text:0000025c $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:355    .text:0000028c $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:361    .text:00000298 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:363    .text:00000298 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:542    .text:000003f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:551    .text:00000408 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:554    .text:00000408 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:776    .text:000005a8 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:786    .text:000005c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:788    .text:000005c4 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1113   .text:0000088c $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1129   .text:000008b8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1132   .text:000008b8 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1169   .text:000008f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1182   .text:0000091c $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1229   .text:00000970 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1236   .text:00000980 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1254   .text:0000099c $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1263   .text:000009b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1266   .text:000009b4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1494   .text:00000c00 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1502   .text:00000c14 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1505   .text:00000c14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1568   .text:00000c94 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1591   .text:00000cac $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1604   .text:00000cd4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1710   .text:00000dc8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1718   .text:00000ddc $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1721   .text:00000ddc ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1933   .text:00000f78 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:1975   .text:00001014 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:2041   .text:00001094 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:2082   .text:00001130 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:3441   .text:00001d10 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:3464   .text:00001d60 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:3869   .text:00002118 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:3875   .text:00002128 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:4478   .text:00002648 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:4646   .text:000027a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:4659   .text:000027cc $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5154   .text:00002cdc $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5165   .text:00002cfc $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5427   .text:00002fb8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5440   .text:00002fe0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5443   .text:00002fe0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5505   .text:0000305c $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5513   .text:0000306c $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5946   .text:000034a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:5953   .text:000034b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:6429   .text:000038ac $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:6436   .text:000038bc $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:6956   .text:00003d50 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:6991   .text:00003dc8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:6994   .text:00003dc8 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7287   .text:00004084 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7294   .text:00004094 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7297   .text:00004094 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7338   .text:000040d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7343   .text:000040e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7346   .text:000040e0 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7371   .text:000040fc $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7375   .text:00004100 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:7378   .text:00004100 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:8725   .text:00004ba0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:8731   .text:00004bb0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:8847   .text:00004d18 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:8906   .text:00004df8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:8909   .text:00004df8 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9055   .text:00004f50 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9071   .text:00004f84 $a
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9074   .text:00004f84 main
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10855  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10864  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10939  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10958  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9233   .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11037  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11048  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11159  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11310  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9246   .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10851  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11746  .bss:000002dc testSnap
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11658  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11662  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11666  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11751  .bss:000002de fbbak
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11755  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11759  .bss:000002e2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11763  .bss:000002e4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11654  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11691  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11687  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11650  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10792  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10732  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10822  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10762  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10837  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10228  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 staQuMux
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9214   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9218   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9258   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9262   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:9585   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10243  .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10248  .data:00000490 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10270  .data:000004a4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10292  .data:000004b8 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10314  .data:000004cc EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10336  .data:000004e0 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10358  .data:000004f4 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10365  .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10387  .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:10409  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11388  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11638  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11642  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11646  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11670  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11675  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11679  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11683  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11696  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11700  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11704  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11708  .bss:0000007c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11712  .bss:000000bc CamMode
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11716  .bss:000000bd setRes
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11721  .bss:000000c0 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11725  .bss:000000e0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11729  .bss:000000e1 IMcount.7858
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11734  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11738  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccFPLZtv.s:11742  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
