   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 0xFF,				//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x12/*ShutterFineReg*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl EXTAGCMaxLimit =
1083:../uvc.c      **** 		{AGCMaxLimtReg,			//Reg1: the command register address1
1084:../uvc.c      **** 		 AGCMaxLimtReg,			//Reg2: the command register address2
1085:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1086:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1087:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1088:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1089:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1090:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1091:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1092:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1093:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1094:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1095:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1096:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1097:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1098:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1099:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1100:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1101:../uvc.c      **** 		}; //
1102:../uvc.c      **** 
1103:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1104:../uvc.c      **** 		&EXTShutter,
1105:../uvc.c      **** 		&EXTSensUp,
1106:../uvc.c      **** 		&EXTMirror,
1107:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1108:../uvc.c      **** 		&EXT3DNoiseLev,
1109:../uvc.c      **** 		&EXTDayNightMode,
1110:../uvc.c      **** 		&EXTDayNightdely,
1111:../uvc.c      **** 		&EXTDayNightlev,
1112:../uvc.c      **** 		&EXTNightDaylev,
1113:../uvc.c      **** 		&EXTAexModGainlev,
1114:../uvc.c      **** 		&EXTExpReflev,
1115:../uvc.c      **** 		&EXTShutlev,
1116:../uvc.c      **** 		&EXTCamMode,
1117:../uvc.c      **** 		0, //&EXTSnapshot,
1118:../uvc.c      **** 		&EXTSensorPare,
1119:../uvc.c      **** 		&EXTI2Ccmd,
1120:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1121:../uvc.c      **** 		0, //&Ext1CtlID1,
1122:../uvc.c      **** 		0, //&Ext1CtlID2,
1123:../uvc.c      **** 		0, //&Ext1CtlID3,
1124:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1125:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1126:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1127:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1128:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1129:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1130:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1131:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1132:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1133:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1134:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1135:../uvc.c      **** 		&EXTAGCMaxLimit, 	// AGC Maximum Gain limitation &Ext1AGCMaxLimetCtlID15,
1136:../uvc.c      **** 		0
1137:../uvc.c      **** };
1138:../uvc.c      **** 
1139:../uvc.c      **** #endif //end of the new control structure
1140:../uvc.c      **** 
1141:../uvc.c      **** #ifndef CAM720
1142:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1143:../uvc.c      **** #else
1144:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1145:../uvc.c      **** #endif
1146:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1147:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1148:../uvc.c      **** 
1149:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1150:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1151:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1152:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1153:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1154:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1155:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1156:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1157:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1158:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1159:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1160:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1161:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1162:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1163:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1164:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1165:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1166:../uvc.c      **** };
1167:../uvc.c      **** 
1168:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1169:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1170:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1171:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1172:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1173:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1174:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1175:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1176:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1177:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1178:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1179:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1180:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1181:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1182:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1183:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1184:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1185:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1186:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1187:../uvc.c      **** };
1188:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1189:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1190:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1191:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1192:../uvc.c      **** /*
1193:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1194:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1195:../uvc.c      ****  */
1196:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1197:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1198:../uvc.c      **** };
1199:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1200:../uvc.c      **** 		0
1201:../uvc.c      **** };
1202:../uvc.c      **** 
1203:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1204:../uvc.c      **** 
1205:../uvc.c      **** void I2CCmdHandler(){
1206:../uvc.c      **** 	uint8_t buf[2];
1207:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1208:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1209:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1210:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1211:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1212:../uvc.c      **** 	uint8_t i;
1213:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1214:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1215:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1216:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1217:../uvc.c      **** 	{
1218:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1219:../uvc.c      **** 		if(is60Hz==CyFalse)
1220:../uvc.c      **** 			{
1221:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1224:../uvc.c      **** 
1225:../uvc.c      **** 	}
1226:../uvc.c      **** 	if(CmdType == 0)//I2C read
1227:../uvc.c      **** 	{
1228:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1229:../uvc.c      **** #if 0 //for debugging
1230:../uvc.c      **** 		/* test still image operation */
1231:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1232:../uvc.c      **** 			snapButFlag = 0; //press
1233:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1234:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1235:../uvc.c      **** 			snapButFlag = 0xf; //release
1236:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1237:../uvc.c      **** 		}
1238:../uvc.c      **** 
1239:../uvc.c      **** 		/* end of the test */
1240:../uvc.c      **** #endif
1241:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1242:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1243:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1244:../uvc.c      **** 				if(CmdDataLen == 2){
1245:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1246:../uvc.c      **** 				}
1247:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1248:../uvc.c      **** 		}else{//not support currently
1249:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1250:../uvc.c      **** 		}
1251:../uvc.c      **** 	}else if(CmdType == 1){
1252:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1253:../uvc.c      **** 			if(CmdRegLen == 2){
1254:../uvc.c      **** 				for(i = 0; i<4; i++)
1255:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1256:../uvc.c      **** 			}
1257:../uvc.c      **** 			else{
1258:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1259:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1260:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1261:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1262:../uvc.c      **** 				}
1263:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1264:../uvc.c      **** 			}
1265:../uvc.c      **** 		}else{//not support currently
1266:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1267:../uvc.c      **** 		}
1268:../uvc.c      **** 
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /************************************
1273:../uvc.c      ****  * set Iris mode
1274:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1275:../uvc.c      ****  */
1276:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1277:../uvc.c      **** 	uint8_t dataIdx = 0;
1278:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1280:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1281:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1282:../uvc.c      **** }
1283:../uvc.c      **** 
1284:../uvc.c      **** 
1285:../uvc.c      **** 
1286:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1287:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1288:../uvc.c      **** 	uint16_t NumLn;
1289:../uvc.c      **** 	uint16_t fRate, shutTm;
1290:../uvc.c      **** 	uint8_t LnVal;
1291:../uvc.c      **** 	switch (Data){
1292:../uvc.c      **** 	case 1:
1293:../uvc.c      **** 	case 2:
1294:../uvc.c      **** 	case 3:
1295:../uvc.c      **** 	case 4:
1296:../uvc.c      **** 	case 5:
1297:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1298:../uvc.c      **** 		fRate = 30;
1299:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1300:../uvc.c      **** 		if(NumLn > 1944)
1301:../uvc.c      **** 			NumLn =1944;
1302:../uvc.c      **** 		else if(NumLn < 8)
1303:../uvc.c      **** 			NumLn = 8;
1304:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1305:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1306:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	case 6:
1309:../uvc.c      **** 	case 7:
1310:../uvc.c      **** 	case 8:
1311:../uvc.c      **** 	case 9:
1312:../uvc.c      **** 	case 10:
1313:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1314:../uvc.c      **** 		fRate = 30;
1315:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1316:../uvc.c      **** 		if(NumLn > 1944)
1317:../uvc.c      **** 			NumLn =1944;
1318:../uvc.c      **** 		else if(NumLn < 8)
1319:../uvc.c      **** 			NumLn = 8;
1320:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1321:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1322:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1323:../uvc.c      **** 		break;
1324:../uvc.c      **** 	case 0: //auto
1325:../uvc.c      **** 	default:
1326:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1327:../uvc.c      **** 		LnVal = 1;
1328:../uvc.c      **** 		break;
1329:../uvc.c      **** 	}
1330:../uvc.c      **** 	return LnVal;
1331:../uvc.c      **** }
1332:../uvc.c      **** 
1333:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1334:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1335:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1336:../uvc.c      ****     uint16_t readCount;
1337:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1338:../uvc.c      ****     uint8_t devAdd;
1339:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1340:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1341:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1344:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1345:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1346:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1347:../uvc.c      ****     }else{
1348:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1349:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1350:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1351:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1352:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1353:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1354:../uvc.c      ****     }
1355:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1356:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1357:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1358:../uvc.c      **** #endif
1359:../uvc.c      ****     reqData = bRequest;
1360:../uvc.c      ****     /*
1361:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1362:../uvc.c      ****      */
1363:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1364:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1365:../uvc.c      ****     	//goto EndofSet;
1366:../uvc.c      ****     //}
1367:../uvc.c      ****     switch (bRequest)
1368:../uvc.c      **** 		 {
1369:../uvc.c      **** 
1370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1371:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1372:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1373:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1374:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1375:../uvc.c      **** 			  break;
1376:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1377:../uvc.c      **** 
1378:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1379:../uvc.c      **** 				 switch(CtrlID)
1380:../uvc.c      **** 				 {
1381:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1382:../uvc.c      **** 						 if(curFlag[CtrlID]){
1383:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1384:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1385:../uvc.c      **** 						 }else{
1386:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1387:../uvc.c      **** 							if(Data0&0x80)
1388:../uvc.c      **** 								glEp0Buffer[0] = 1;
1389:../uvc.c      **** 							else
1390:../uvc.c      **** 								glEp0Buffer[0] = 0;
1391:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1392:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1393:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1394:../uvc.c      **** 						 }
1395:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1396:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1397:../uvc.c      **** 						 break;
1398:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1399:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1400:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1401:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1402:../uvc.c      **** 			 	 		 }else{
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
1405:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1406:../uvc.c      **** 
1407:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1408:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1409:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1410:../uvc.c      **** 			 	 		 }
1411:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1412:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1413:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1414:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1415:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1
1416:../uvc.c      **** 						 break;
1417:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1418:../uvc.c      **** #if 0 //not be used
1419:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1420:../uvc.c      **** 
1421:../uvc.c      **** 						 if(CamMode == 1){//720p
1422:../uvc.c      **** 							if(sendData >= 3){
1423:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1424:../uvc.c      **** 								sendData = 0; //set back to default
1425:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1426:../uvc.c      **** 							}
1427:../uvc.c      **** 							sendData += 4;
1428:../uvc.c      **** 						 }
1429:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1430:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1431:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1432:../uvc.c      **** #endif
1433:../uvc.c      **** 						 break;
1434:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1435:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1436:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1437:../uvc.c      **** 				 		 }
1438:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1439:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1440:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1441:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1442:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1443:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1444:../uvc.c      **** 	#endif
1445:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1446:../uvc.c      **** 				 		 {
1447:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1448:../uvc.c      **** 				 		 }
1449:../uvc.c      **** 				 		 break;
1450:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1451:../uvc.c      **** 			 	 		 sendData = SensorGetControl(RegAdd1, devAdd);
1452:../uvc.c      **** 			 	 		// sendData &= 0x70;
1453:../uvc.c      **** 	 	 				 glEp0Buffer[0] = sendData >> 4; // bit6:4 are significant bits. bit7 is fine shutter & shu
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1455:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
1456:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1457:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1458:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1459:../uvc.c      **** 	 	 				 break;
1460:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
1461:../uvc.c      **** 	 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1463:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
1464:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1465:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1466:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1467:../uvc.c      **** 	 	 				 break;
1468:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1469:../uvc.c      **** 				 	 case ExtShutCtlID0:
1470:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1471:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1472:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1473:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1474:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1475:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1476:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1477:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1478:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1479:../uvc.c      **** 			 	 	 case Ext1AGCMaxLimetCtlID15:
1480:../uvc.c      **** 					 case ExtExRefCtlID10:
1481:../uvc.c      **** 			 	 	 default:
1482:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1483:../uvc.c      **** 			 	 			 if(Len == 2)
1484:../uvc.c      **** 			 	 			 {
1485:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1486:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1488:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1489:../uvc.c      **** 			 	 			 }else if(Len == 4){
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1491:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1493:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1494:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1495:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1496:../uvc.c      **** 			 	 			 }
1497:../uvc.c      **** 			 	 		 }else{
1498:../uvc.c      **** 			 	 			 if(Len == 2)
1499:../uvc.c      **** 			 	 			 {
1500:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1501:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1502:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1503:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1504:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1505:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1506:../uvc.c      **** 			 	 			 }else if(Len == 4){
1507:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1509:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1510:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1511:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1512:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1513:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1514:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1515:../uvc.c      **** 			 	 			 }
1516:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1517:../uvc.c      **** 			 	 		 }
1518:../uvc.c      **** 			 	 		 break;
1519:../uvc.c      **** 			 	 }
1520:../uvc.c      **** 		 	 }
1521:../uvc.c      **** 		 	 else{
1522:../uvc.c      **** 				 switch(CtrlID)
1523:../uvc.c      **** 				 {
1524:../uvc.c      **** 					 case BrgtCtlID1:
1525:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1526:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1527:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1528:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1529:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1530:../uvc.c      **** 						 }else{
1531:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1532:../uvc.c      **** 						 }
1533:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1534:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1535:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1536:../uvc.c      **** 						 */
1537:../uvc.c      **** 						 if(curFlag[CtrlID]){
1538:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1539:../uvc.c      **** 						 }else{
1540:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1541:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1542:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1543:../uvc.c      **** 						 }
1544:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1545:../uvc.c      **** 						 /*//new implementation 8/23/2016
1546:../uvc.c      **** 						 if(Data0&0x80){
1547:../uvc.c      **** 							  Data0 = ~Data0;
1548:../uvc.c      **** 						  }else{
1549:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1550:../uvc.c      **** 						  }
1551:../uvc.c      **** 						  */
1552:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1553:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1554:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1555:../uvc.c      **** 						 break;
1556:../uvc.c      **** 					 case HueCtlID5:
1557:../uvc.c      **** 						 if(curFlag[CtrlID]){
1558:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1559:../uvc.c      **** 						 }else{
1560:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1561:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1562:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1563:../uvc.c      **** 						 }
1564:../uvc.c      **** 
1565:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1566:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1567:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1568:../uvc.c      **** 						 break;
1569:../uvc.c      **** 					 case MFreqCtlID4:
1570:../uvc.c      **** 
1571:../uvc.c      **** 						 if(curFlag[CtrlID]){
1572:../uvc.c      **** 
1573:../uvc.c      **** 							 if(is60Hz)
1574:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1575:../uvc.c      **** 							 else
1576:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1577:../uvc.c      **** 
1578:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1579:../uvc.c      **** 						 }else{
1580:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1581:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1582:../uvc.c      **** 							glEp0Buffer[0]++;
1583:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1584:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1585:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1586:../uvc.c      **** 						 }
1587:../uvc.c      **** 
1588:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1589:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1590:../uvc.c      **** 						 break;
1591:../uvc.c      **** 					 case WBTLevCtlID11:
1592:../uvc.c      **** 						 if(curFlag[CtrlID]){
1593:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1594:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1595:../uvc.c      **** 						 }else{
1596:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1597:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1598:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1599:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1600:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1601:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1602:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1603:../uvc.c      **** 						 }
1604:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1605:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1606:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1607:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1608:../uvc.c      **** 						 break;
1609:../uvc.c      **** 					 case ShapCtlID7:
1610:../uvc.c      **** 						 if(curFlag[CtrlID]){
1611:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1612:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1613:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1614:../uvc.c      **** 			 	 		 }else{
1615:../uvc.c      **** 			 	 			 if(Len == 2)
1616:../uvc.c      **** 			 	 			 {
1617:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1618:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1619:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1620:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1621:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1622:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1623:../uvc.c      **** 			 	 			 }
1624:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1625:../uvc.c      **** 			 	 		 }
1626:../uvc.c      **** 						 break;
1627:../uvc.c      **** 					 case BLCCtlID0:
1628:../uvc.c      **** 					 case ConsCtlID2:
1629:../uvc.c      **** 					 case WBTMdCtlID9:
1630:../uvc.c      **** 					 case SaturCtlID6:
1631:../uvc.c      **** 					 default:
1632:../uvc.c      **** 						 if(curFlag[CtrlID]){
1633:../uvc.c      **** 			 	 			 if(Len == 2)
1634:../uvc.c      **** 			 	 			 {
1635:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1636:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1637:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1638:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1639:../uvc.c      **** 			 	 			 }else if(Len == 4){
1640:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1641:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1642:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1643:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1644:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1645:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1646:../uvc.c      **** 			 	 			 }
1647:../uvc.c      **** 			 	 		 }else{
1648:../uvc.c      **** 			 	 			 if(Len == 2)
1649:../uvc.c      **** 			 	 			 {
1650:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1651:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1652:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1653:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1654:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1655:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1656:../uvc.c      **** 			 	 			 }else if(Len == 4){
1657:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1659:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1660:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1661:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1662:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1663:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1664:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1665:../uvc.c      **** 			 	 			 }
1666:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1667:../uvc.c      **** 			 	 		 }
1668:../uvc.c      **** 						 break;
1669:../uvc.c      **** 				 }
1670:../uvc.c      **** 		 	 }
1671:../uvc.c      **** 
1672:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1673:../uvc.c      **** 
1674:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1675:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1676:../uvc.c      **** //#endif
1677:../uvc.c      **** 			  break;
1678:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1679:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1680:../uvc.c      **** 		 		 if(Len == 2){
1681:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1682:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1683:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1684:../uvc.c      **** 		 		 }else //if(Len == 4)
1685:../uvc.c      **** 		 		 {
1686:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1687:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1688:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1689:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1690:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1691:../uvc.c      **** 				 }
1692:../uvc.c      **** 			 }else{
1693:../uvc.c      **** 			 	 if(Len ==2){
1694:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1695:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1696:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1697:../uvc.c      **** 				 }else{
1698:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1699:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1700:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1701:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1702:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1703:../uvc.c      **** 				 }
1704:../uvc.c      **** 			 }
1705:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1706:../uvc.c      **** 		 	 if(Len == 2){
1707:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1708:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1709:../uvc.c      **** 		 	 }else{
1710:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1711:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1712:../uvc.c      **** 			  }
1713:../uvc.c      **** 			  break;
1714:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1715:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1716:../uvc.c      **** 		 		 if(Len == 2){
1717:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1718:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1719:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1720:../uvc.c      **** 		 		 }else //if(Len == 4)
1721:../uvc.c      **** 		 		 {
1722:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1723:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1724:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1725:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1726:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1727:../uvc.c      **** 				 }
1728:../uvc.c      **** 			 }else{
1729:../uvc.c      **** 			 	 if(Len ==2){
1730:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1731:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1732:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1733:../uvc.c      **** 				 }else{
1734:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1735:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1736:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1737:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1738:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1739:../uvc.c      **** 				 }
1740:../uvc.c      **** 			 }
1741:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1742:../uvc.c      **** 				  if(Len == 2){
1743:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1745:../uvc.c      **** 				  }else{
1746:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1748:../uvc.c      **** 				  }
1749:../uvc.c      **** 				  break;
1750:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1751:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1752:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1753:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1754:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1755:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1756:../uvc.c      **** 		 	 }
1757:../uvc.c      **** 		 	 else{
1758:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1759:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1760:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1761:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1762:../uvc.c      **** 		 	 }
1763:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1764:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1765:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1766:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1767:../uvc.c      **** 			  break;
1768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1769:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1770:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1771:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1772:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1773:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1774:../uvc.c      **** 		 	 }
1775:../uvc.c      **** 		 	 else{
1776:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1777:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1778:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1779:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1780:../uvc.c      **** 		 	 }
1781:../uvc.c      **** 		 	 Len = 1;
1782:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1783:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1784:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1785:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1786:../uvc.c      **** 		 	 break;
1787:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1788:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1789:../uvc.c      **** 		 		 if(Len == 2){
1790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1791:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1792:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1793:../uvc.c      **** 		 		 }else //if(Len == 4)
1794:../uvc.c      **** 		 		 {
1795:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1796:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1797:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1798:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1799:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1800:../uvc.c      **** 				 }
1801:../uvc.c      **** 			 }else{
1802:../uvc.c      **** 			 	 if(Len ==2){
1803:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1804:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1805:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1806:../uvc.c      **** 				 }else{
1807:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1808:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1809:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1810:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1811:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1812:../uvc.c      **** 				 }
1813:../uvc.c      **** 			 }
1814:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1815:../uvc.c      **** 		 	 if(Len == 2){
1816:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1817:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1818:../uvc.c      **** 		 	 }else{
1819:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1820:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1821:../uvc.c      **** 		 	 }
1822:../uvc.c      **** 		 	 break;
1823:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1824:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1825:../uvc.c      **** 				  glEp0Buffer, &readCount);
1826:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1827:../uvc.c      **** 			   {
1828:../uvc.c      **** 				 if(Len == 2){
1829:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1830:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
1831:../uvc.c      **** 				 }else{
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
1834:../uvc.c      **** 				 }
1835:../uvc.c      **** 				 dataIdx = 0;
1836:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
1837:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
1838:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
1839:../uvc.c      **** 					 switch(CtrlID)
1840:../uvc.c      **** 					 {
1841:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1842:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1843:../uvc.c      **** 							 if(Data0 == 1){
1844:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1845:../uvc.c      **** 							 }else{
1846:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1847:../uvc.c      **** 							 }
1848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1851:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1852:../uvc.c      **** 							 break;
1853:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
1854:../uvc.c      **** 	#if 0 // not be used
1855:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
1856:../uvc.c      **** 
1857:../uvc.c      **** 							 if(CamMode == 1){//720p
1858:../uvc.c      **** 								if(sendData >= 3){
1859:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1860:../uvc.c      **** 									sendData = 0; //set back to default
1861:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
1862:../uvc.c      **** 								}
1863:../uvc.c      **** 								sendData += 4;
1864:../uvc.c      **** 							 }
1865:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1866:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
1867:../uvc.c      **** 							 glEp0Buffer[1] = 0;
1868:../uvc.c      **** 	#endif
1869:../uvc.c      **** 							 break;
1870:../uvc.c      **** 					 	 case ExtSensorParCtlID14:
1871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
1873:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1875:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
1876:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1877:../uvc.c      **** 							 break;
1878:../uvc.c      **** 					 	 case ExtI2CCtlID15:
1879:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1880:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1881:../uvc.c      **** 					 		 }
1882:../uvc.c      **** 					 		 I2CCmdHandler();
1883:../uvc.c      **** 							 break;
1884:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
1885:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1886:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1887:../uvc.c      **** 							 {
1888:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wind
1889:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1890:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1891:../uvc.c      **** 								 dataIdx++;
1892:../uvc.c      **** 							 }
1893:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
1894:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
1895:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
1896:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
1897:../uvc.c      **** 								 }
1898:../uvc.c      **** 							 }
1899:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1901:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1902:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
1903:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
1904:../uvc.c      **** 							 break;
1905:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
1906:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
1907:../uvc.c      **** 	#if 1	// register setting directly
1908:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vi
1909:../uvc.c      **** 						     {
1910:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1911:../uvc.c      **** 						    	 dataIdx = 0;
1912:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1913:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1914:../uvc.c      **** 								 //dataIdx++;
1915:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1916:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1917:../uvc.c      **** 						     }
1918:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1919:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1920:../uvc.c      **** 						     break;
1921:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
1922:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
1924:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1925:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1926:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1927:../uvc.c      **** 									 //dataIdx++;
1928:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
1929:../uvc.c      **** 								 }
1930:../uvc.c      **** 							 }
1931:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1933:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1934:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1935:../uvc.c      **** 							 break;
1936:../uvc.c      **** 
1937:../uvc.c      **** 	#else	// old fashion
1938:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1939:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1940:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1941:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1942:../uvc.c      **** 									 }else{
1943:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1944:../uvc.c      **** 									 }
1945:../uvc.c      **** 								 }
1946:../uvc.c      **** 							 }else{
1947:../uvc.c      **** 								 Data1 = Data0 - 1;
1948:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1949:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1950:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1951:../uvc.c      **** 									 }else{
1952:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1953:../uvc.c      **** 									 }
1954:../uvc.c      **** 								 }
1955:../uvc.c      **** 								 if(Data1 < 8){
1956:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1957:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1958:../uvc.c      **** 								 }else{
1959:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1960:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1961:../uvc.c      **** 								 }
1962:../uvc.c      **** 							 }
1963:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1964:../uvc.c      **** 							 dataIdx = 0;
1965:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1966:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1968:../uvc.c      **** 							 if(AxMode){
1969:../uvc.c      **** 								 dataIdx++;
1970:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1971:../uvc.c      **** 								 dataIdx++;
1972:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1973:../uvc.c      **** 							 }
1974:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1975:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1976:../uvc.c      **** 							 break;
1977:../uvc.c      **** 	#endif
1978:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
1979:../uvc.c      **** 	#if 0 //seperate version
1980:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
1981:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1982:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1983:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1984:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1985:../uvc.c      **** 							 }else{ //disable BLD window
1986:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1987:../uvc.c      **** 							 }
1988:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1989:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1990:../uvc.c      **** 							 dataIdx++;
1991:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1992:../uvc.c      **** 							 dataIdx++;
1993:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1994:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1995:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1996:../uvc.c      **** 							 dataIdx++;
1997:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1998:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1999:../uvc.c      **** 	#else //combination version
2000:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2001:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2002:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2003:../uvc.c      **** 							 dataIdx++;
2004:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2005:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2006:../uvc.c      **** 							 getData1 = Data1;
2007:../uvc.c      **** 	#endif
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2009:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2010:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2011:../uvc.c      **** 							 break;
2012:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2013:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2014:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2015:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
2016:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
2017:../uvc.c      **** 								 Data0 |= Data1;
2018:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2019:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2020:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2021:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2022:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2023:../uvc.c      **** 							 }
2024:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2025:../uvc.c      **** 
2026:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2027:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2028:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2029:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2030:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2031:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2032:../uvc.c      **** 				 	 	 case Ext1AGCMaxLimetCtlID15:
2033:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2034:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2035:../uvc.c      **** 						 case ExtExRefCtlID10:
2036:../uvc.c      **** 				 	 	 default:
2037:../uvc.c      **** 				 	 			 if(Len == 2)
2038:../uvc.c      **** 				 	 			 {
2039:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2040:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2041:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2042:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2044:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2045:../uvc.c      **** 									 }
2046:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2047:../uvc.c      **** 				 	 			 }else if(Len == 4){
2048:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2049:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2050:../uvc.c      **** 									 {
2051:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2052:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2053:../uvc.c      **** 										 dataIdx++;
2054:../uvc.c      **** 									 }
2055:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2056:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2057:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2058:../uvc.c      **** 									 }
2059:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2060:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2061:../uvc.c      **** 
2062:../uvc.c      **** 				 	 			 }
2063:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2064:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2065:../uvc.c      **** 				 	 			 break;
2066:../uvc.c      **** 					 }
2067:../uvc.c      **** 			 	 }
2068:../uvc.c      **** 			 	 else{
2069:../uvc.c      **** 					 switch(CtrlID)
2070:../uvc.c      **** 					 {
2071:../uvc.c      **** 						 case BrgtCtlID1:
2072:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2073:../uvc.c      **** 								 dataIdx = 0;
2074:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2075:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2076:../uvc.c      **** 								  if(Data0&0x80){
2077:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2078:../uvc.c      **** 								  }else{
2079:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2080:../uvc.c      **** 								  }
2081:../uvc.c      **** 								 Data1 |= ~0x03;
2082:../uvc.c      **** 								 Data1 &= 0xC7;
2083:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2084:../uvc.c      **** 							  	 dataIdx++;
2085:../uvc.c      **** 
2086:../uvc.c      **** 								 Data0 = (Data0 << 2);
2087:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2088:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2089:../uvc.c      **** 
2090:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2091:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2092:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2093:../uvc.c      **** 	#endif
2094:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2095:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2096:../uvc.c      **** 								 /*// new I2C command. direct using Data0 coming from host. 8/23/2016
2097:../uvc.c      **** 								 if(Data0&0x80){
2098:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2099:../uvc.c      **** 								  }else{
2100:../uvc.c      **** 									  Data0 = ~Data0;
2101:../uvc.c      **** 								  }
2102:../uvc.c      **** 								  */
2103:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2104:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2105:../uvc.c      **** 
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2107:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2108:../uvc.c      **** 							 break;
2109:../uvc.c      **** 						 case HueCtlID5://not being used
2110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2111:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2112:../uvc.c      **** 							 dataIdx++;
2113:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2114:../uvc.c      **** 							 dataIdx++;
2115:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2116:../uvc.c      **** 							 dataIdx++;
2117:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2118:../uvc.c      **** 							 dataIdx++;
2119:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2120:../uvc.c      **** 							 dataIdx++;
2121:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2122:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2123:../uvc.c      **** 
2124:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2125:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2126:../uvc.c      **** 							 break;
2127:../uvc.c      **** 						 case MFreqCtlID4:
2128:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2129:../uvc.c      **** 							 Data0 = Data0 - 1;
2130:../uvc.c      **** 							 is60Hz = Data0;
2131:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2132:../uvc.c      **** 							 {
2133:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
2134:../uvc.c      **** 								 is60Hz = CyFalse;
2135:../uvc.c      **** 							 }
2136:../uvc.c      **** 							 else if(Data0 >2)
2137:../uvc.c      **** 							 {
2138:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
2139:../uvc.c      **** 								 is60Hz = CyTrue;
2140:../uvc.c      **** 							 }
2141:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2142:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2143:../uvc.c      **** 							 {
2144:../uvc.c      **** 			                       switch (setRes)
2145:../uvc.c      **** 			                         {
2146:../uvc.c      **** 			                         	case 1: //1944
2147:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2148:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2149:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2150:../uvc.c      **** 			                         		break;
2151:../uvc.c      **** 			                         	case 2: //1080
2152:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2153:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2154:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2155:../uvc.c      **** 			                         		break;
2156:../uvc.c      **** 			                         	case 3: //720
2157:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2158:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2159:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2160:../uvc.c      **** 			                         		break;
2161:../uvc.c      **** 			                         	case 4: //VGA
2162:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2163:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2164:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2165:../uvc.c      **** 			                         	default:
2166:../uvc.c      **** 			                         		break;
2167:../uvc.c      **** 			                         }
2168:../uvc.c      **** 							 }
2169:../uvc.c      **** 
2170:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2171:../uvc.c      **** 							 break;
2172:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2173:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2174:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2175:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2176:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2177:../uvc.c      **** 							 dataIdx++;
2178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2179:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2180:../uvc.c      **** 
2181:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2182:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2183:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2184:../uvc.c      **** 							 break;
2185:../uvc.c      **** 						 case BLCCtlID0:
2186:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2187:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2188:../uvc.c      **** 							 {
2189:../uvc.c      **** 								 if(Data0 < 3){
2190:../uvc.c      **** 					 				 Data0 += 4;
2191:../uvc.c      **** 					 			 }else{
2192:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2193:../uvc.c      **** 									Data0 = 4; //set to default.
2194:../uvc.c      **** 					 			 }
2195:../uvc.c      **** 					 		 }
2196:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2197:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2198:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2199:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2200:../uvc.c      **** 					 		 break;
2201:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2202:../uvc.c      **** 
2203:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2204:../uvc.c      **** 							 if(Data0 != 0){
2205:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2206:../uvc.c      **** 	#ifdef COLOR
2207:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2208:../uvc.c      **** 	#else
2209:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2210:../uvc.c      **** 								 dataIdx++;
2211:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2212:../uvc.c      **** 	#endif
2213:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2214:../uvc.c      **** 							 }else{
2215:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2216:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2217:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2218:../uvc.c      **** 							 }
2219:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2220:../uvc.c      **** 							 break;
2221:../uvc.c      **** 						 case ConsCtlID2:
2222:../uvc.c      **** 						 case WBTMdCtlID9:
2223:../uvc.c      **** 						 case SaturCtlID6:
2224:../uvc.c      **** 						 default:
2225:../uvc.c      **** 			 	 			 if(Len == 2)
2226:../uvc.c      **** 			 	 			 {
2227:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2228:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2229:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2230:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2231:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2232:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2233:../uvc.c      **** 								 }
2234:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2235:../uvc.c      **** 			 	 			 }else if(Len == 4){
2236:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2237:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2238:../uvc.c      **** 								 {
2239:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2240:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2241:../uvc.c      **** 									 dataIdx++;
2242:../uvc.c      **** 								 }
2243:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2244:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2245:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2246:../uvc.c      **** 								 }
2247:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2248:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2249:../uvc.c      **** 
2250:../uvc.c      **** 			 	 			 }
2251:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2252:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2253:../uvc.c      **** 			 	 			 break;
2254:../uvc.c      **** 					 }
2255:../uvc.c      **** 			 	 }
2256:../uvc.c      **** 			   }else{
2257:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2258:../uvc.c      **** 			   }
2259:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2260:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2261:../uvc.c      **** #endif
2262:../uvc.c      **** 
2263:../uvc.c      **** 			  break;
2264:../uvc.c      **** 		  default:
2265:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2266:../uvc.c      **** 			  break;
2267:../uvc.c      **** 		 }
2268:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2269:../uvc.c      **** }
2270:../uvc.c      **** /************** CT control requests handler *************************/
2271:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2272:../uvc.c      **** 
2273:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2274:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2275:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2276:../uvc.c      ****     uint16_t readCount;
2277:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2278:../uvc.c      ****     uint16_t diff, value, diffRd;
2279:../uvc.c      ****     uint8_t i, shutter, index;
2280:../uvc.c      ****     diff = 0xffff;
2281:../uvc.c      ****     shutter = 1;
2282:../uvc.c      ****     index = 1;
2283:../uvc.c      **** 
2284:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2285:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2286:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2287:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2288:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2289:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2290:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2291:../uvc.c      **** #endif
2292:../uvc.c      ****     reqData = bRequest;
2293:../uvc.c      **** 
2294:../uvc.c      ****     switch (bRequest)
2295:../uvc.c      **** 		 {
2296:../uvc.c      **** 
2297:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2298:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2299:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2300:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2301:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2302:../uvc.c      **** 			  break;
2303:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2304:../uvc.c      **** 
2305:../uvc.c      **** 			 switch(CtrlID)
2306:../uvc.c      **** 			 {
2307:../uvc.c      **** 				 default:
2308:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2309:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2310:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2311:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2312:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2313:../uvc.c      **** 					 break;
2314:../uvc.c      **** 			 }
2315:../uvc.c      **** 
2316:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2317:../uvc.c      **** 
2318:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2319:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2320:../uvc.c      **** #endif
2321:../uvc.c      **** 			  break;
2322:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2323:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2324:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2325:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2326:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2327:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2328:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2329:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2330:../uvc.c      **** 			  break;
2331:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2332:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2333:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2334:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2335:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2336:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2339:../uvc.c      **** 			  break;
2340:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2341:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2342:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2343:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2344:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2345:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2346:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2347:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2348:../uvc.c      **** 			  break;
2349:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2350:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2351:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2352:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2353:../uvc.c      **** 			  Len = 1;
2354:../uvc.c      **** 			  break;
2355:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2356:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2357:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2358:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2359:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2360:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2361:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2362:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2363:../uvc.c      **** 			  break;
2364:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2365:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2366:../uvc.c      **** 			  glEp0Buffer, &readCount);
2367:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2368:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2369:../uvc.c      **** 			  value = Data1;
2370:../uvc.c      **** 
2371:../uvc.c      **** 			  switch(CtrlID)
2372:../uvc.c      **** 			  {
2373:../uvc.c      **** 		  	      case AutoExMCtlID1:
2374:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2375:../uvc.c      **** 
2376:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2377:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2378:../uvc.c      **** 				    getData = glEp0Buffer[0];
2379:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2380:../uvc.c      **** 		  		    switch (getData){
2381:../uvc.c      **** 						case 1:
2382:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2383:../uvc.c      **** 							break;
2384:../uvc.c      **** 						case 2:
2385:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2386:../uvc.c      **** 							dataIdx = 0;
2387:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2388:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2389:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2390:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2391:../uvc.c      **** 
2392:../uvc.c      **** 							break;
2393:../uvc.c      **** 						case 4:
2394:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2395:../uvc.c      **** 							break;
2396:../uvc.c      **** 						case 8:
2397:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2398:../uvc.c      **** 			  		    	dataIdx = 0;
2399:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2400:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2401:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2402:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2403:../uvc.c      **** 							break;
2404:../uvc.c      **** 		  		    }
2405:../uvc.c      **** #if 0
2406:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2407:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2408:../uvc.c      **** 						  dataIdx = 0;
2409:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2410:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2411:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2412:../uvc.c      **** 		  		    }
2413:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2414:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2415:../uvc.c      **** 		  		    }
2416:../uvc.c      **** #endif
2417:../uvc.c      **** 				    break;
2418:../uvc.c      **** 
2419:../uvc.c      **** 			  	  case ExTmACtlID3:
2420:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2421:../uvc.c      **** 
2422:../uvc.c      **** 					  value = (value << 8)|Data0;
2423:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2424:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2425:../uvc.c      **** 					  {
2426:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2427:../uvc.c      **** 						  {
2428:../uvc.c      **** 							if(value > ShutValueArry[i]){
2429:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2430:../uvc.c      **** 							}else{
2431:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2432:../uvc.c      **** 							}
2433:../uvc.c      **** 							  if(diff > diffRd){
2434:../uvc.c      **** 								  diff = diffRd;
2435:../uvc.c      **** 								  index = i;
2436:../uvc.c      **** 							  }
2437:../uvc.c      **** 						  }
2438:../uvc.c      **** 						  shutter = shutter+index;
2439:../uvc.c      **** 
2440:../uvc.c      **** 						  dataIdx = 0;
2441:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2442:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2443:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2444:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2445:../uvc.c      **** 
2446:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2447:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2448:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2449:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2450:../uvc.c      **** 					  }else{
2451:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2452:../uvc.c      **** 					  }
2453:../uvc.c      **** 					  getData = glEp0Buffer[0];
2454:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2455:../uvc.c      **** 					  break;
2456:../uvc.c      **** 			  	  case IriACtlID7:
2457:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2458:../uvc.c      **** 					  {
2459:../uvc.c      **** 							 dataIdx = 0;
2460:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2461:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2462:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2463:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2464:../uvc.c      **** 
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2466:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2467:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2468:../uvc.c      **** 					  }else{
2469:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2470:../uvc.c      **** 					  }
2471:../uvc.c      **** 					  getData = glEp0Buffer[0];
2472:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2473:../uvc.c      **** 
2474:../uvc.c      **** 					  break;
2475:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2476:../uvc.c      **** 					  getData = glEp0Buffer[0];
2477:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2478:../uvc.c      **** #if 1
2479:../uvc.c      **** 					  dataIdx = 0;
2480:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2481:../uvc.c      **** 					  if(getData == 1)
2482:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2483:../uvc.c      **** 					  else if(getData == 0xff)
2484:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2485:../uvc.c      **** 					  else
2486:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2487:../uvc.c      **** 					  //dataIdx++;
2488:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2489:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2490:../uvc.c      **** #endif
2491:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2492:../uvc.c      **** 					  break;
2493:../uvc.c      **** 
2494:../uvc.c      **** 			  	  default:
2495:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2496:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2497:../uvc.c      **** 			  		 break;
2498:../uvc.c      **** 			  }
2499:../uvc.c      **** 			  break;
2500:../uvc.c      **** 		  default:
2501:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2502:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2503:../uvc.c      **** 			  break;
2504:../uvc.c      **** 		 }
2505:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2506:../uvc.c      **** 
2507:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2508:../uvc.c      **** }
2509:../uvc.c      **** 
2510:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2511:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2512:../uvc.c      **** {
2513:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2514:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2515:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2516:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2517:../uvc.c      **** 
2518:../uvc.c      ****     CtrlID = BrgtCtlID1;
2519:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2520:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2521:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2522:../uvc.c      ****     Data1 = Data0;
2523:../uvc.c      **** 
2524:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2525:../uvc.c      ****     if(Data1&0x80){
2526:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2527:../uvc.c      ****     }else{
2528:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2529:../uvc.c      ****     }
2530:../uvc.c      ****     Data0 = (Data0 << 2);
2531:../uvc.c      **** 
2532:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2533:../uvc.c      **** 
2534:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2535:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2536:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2537:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2538:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2539:../uvc.c      **** 
2540:../uvc.c      ****     CtrlID = ConsCtlID2;
2541:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2542:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2543:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2544:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2545:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2546:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2547:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2548:../uvc.c      **** 
2549:../uvc.c      ****     CtrlID = HueCtlID5;
2550:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2551:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2552:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2553:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2559:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2560:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2561:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2562:../uvc.c      **** 
2563:../uvc.c      ****     CtrlID = SaturCtlID6;
2564:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2565:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2566:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2567:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2568:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2569:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2570:../uvc.c      **** 
2571:../uvc.c      ****     CtrlID = ShapCtlID7;
2572:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2573:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2574:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2575:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2576:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2577:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2578:../uvc.c      **** 
2579:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2580:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2581:../uvc.c      **** 	return;
2582:../uvc.c      **** }
2583:../uvc.c      **** 
2584:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2585:../uvc.c      **** void
2586:../uvc.c      **** CyFxUVCAddHeader (
2587:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2588:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2589:../uvc.c      ****         )
2590:../uvc.c      **** {
2591:../uvc.c      ****     /* Copy header to buffer */
2592:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2593:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2594:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2595:../uvc.c      **** 
2596:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2597:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2598:../uvc.c      ****     {
2599:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2600:../uvc.c      ****     }
2601:../uvc.c      **** }
2602:../uvc.c      **** 
2603:../uvc.c      **** 
2604:../uvc.c      **** /* Application Error Handler */
2605:../uvc.c      **** void
2606:../uvc.c      **** CyFxAppErrorHandler (
2607:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2608:../uvc.c      ****         )
2609:../uvc.c      **** {
2610:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2611:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2612:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2613:../uvc.c      **** 
2614:../uvc.c      ****        This function can be modified to take additional error handling actions such
2615:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2616:../uvc.c      ****      */
2617:../uvc.c      ****     for (;;)
2618:../uvc.c      ****     {
2619:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2620:../uvc.c      ****         CyU3PThreadSleep (1000);
2621:../uvc.c      ****     }
2622:../uvc.c      **** }
2623:../uvc.c      **** 
2624:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2625:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2626:../uvc.c      ****  */
2627:../uvc.c      **** static void
2628:../uvc.c      **** CyFxUVCApplnAbortHandler (
2629:../uvc.c      ****         void)
2630:../uvc.c      **** {
2631:../uvc.c      **** 	uint32_t flag;
2632:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2633:../uvc.c      **** 	{
2634:../uvc.c      ****         /* Clear the Video Stream Request Event */
2635:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2636:../uvc.c      **** 
2637:../uvc.c      ****         /* Set Video Stream Abort Event */
2638:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2639:../uvc.c      **** 	}
2640:../uvc.c      **** }
2641:../uvc.c      **** 
2642:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2643:../uvc.c      **** static void
2644:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2645:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2646:../uvc.c      ****         uint16_t             evdata  /* Event data */
2647:../uvc.c      ****         )
2648:../uvc.c      **** {
2649:../uvc.c      ****     switch (evtype)
2650:../uvc.c      ****     {
2651:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2652:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2653:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2654:../uvc.c      ****             gpif_initialized = 0;
2655:../uvc.c      ****             streamingStarted = CyFalse;
2656:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2657:../uvc.c      ****             break;
2658:../uvc.c      **** 
2659:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2660:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2661:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2662:../uvc.c      ****             gpif_initialized = 0;
2663:../uvc.c      ****             streamingStarted = CyFalse;
2664:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2665:../uvc.c      ****             break;
2666:../uvc.c      **** 
2667:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2668:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2669:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2670:../uvc.c      ****             gpif_initialized = 0;
2671:../uvc.c      ****             isUsbConnected = CyFalse;
2672:../uvc.c      ****             streamingStarted = CyFalse;
2673:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2674:../uvc.c      ****             break;
2675:../uvc.c      **** 
2676:../uvc.c      **** #ifdef BACKFLOW_DETECT
2677:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2678:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2679:../uvc.c      ****             break;
2680:../uvc.c      **** #endif
2681:../uvc.c      **** 
2682:../uvc.c      ****         default:
2683:../uvc.c      ****             break;
2684:../uvc.c      ****     }
2685:../uvc.c      **** }
2686:../uvc.c      **** 
2687:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2688:../uvc.c      **** static CyBool_t
2689:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2690:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2691:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2692:../uvc.c      ****         )
2693:../uvc.c      **** {
2694:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2695:../uvc.c      ****     uint32_t status;
2696:../uvc.c      **** 
2697:../uvc.c      ****     /* Obtain Request Type and Request */
2698:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2699:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2700:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2701:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2702:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2703:../uvc.c      **** 
2704:../uvc.c      ****     /* Check for UVC Class Requests */
2705:../uvc.c      ****     switch (bmReqType)
2706:../uvc.c      ****     {
2707:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2708:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2709:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2710:../uvc.c      ****             switch (wIndex & 0xFF)
2711:../uvc.c      ****             {
2712:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2713:../uvc.c      ****                     {
2714:../uvc.c      ****                         uvcHandleReq = CyTrue;
2715:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2716:../uvc.c      ****                                 CYU3P_EVENT_OR);
2717:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2718:../uvc.c      ****                         {
2719:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2720:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2721:../uvc.c      ****                         }
2722:../uvc.c      ****                     }
2723:../uvc.c      ****                     break;
2724:../uvc.c      **** 
2725:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2726:../uvc.c      ****                     {
2727:../uvc.c      ****                         uvcHandleReq = CyTrue;
2728:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2729:../uvc.c      ****                                 CYU3P_EVENT_OR);
2730:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2731:../uvc.c      ****                         {
2732:../uvc.c      ****                             /* Error handling */
2733:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2734:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2735:../uvc.c      ****                         }
2736:../uvc.c      ****                     }
2737:../uvc.c      ****                     break;
2738:../uvc.c      **** 
2739:../uvc.c      ****                 default:
2740:../uvc.c      ****                     break;
2741:../uvc.c      ****             }
2742:../uvc.c      ****             break;
2743:../uvc.c      **** 
2744:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2745:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2746:../uvc.c      ****             {
2747:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2748:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2749:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2750:../uvc.c      ****                 {
2751:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2752:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2753:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2754:../uvc.c      ****                     gpif_initialized = 0;
2755:../uvc.c      ****                     streamingStarted = CyFalse;
2756:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2757:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2758:../uvc.c      ****                     CyU3PBusyWait (100);
2759:../uvc.c      **** 
2760:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2761:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2762:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2763:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2764:../uvc.c      ****                     CyU3PBusyWait (100);
2765:../uvc.c      **** 
2766:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2767:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2768:../uvc.c      ****                     uvcHandleReq = CyTrue;
2769:../uvc.c      ****                     /* Complete Control request handshake */
2770:../uvc.c      ****                     CyU3PUsbAckSetup ();
2771:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2772:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2773:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2774:../uvc.c      **** 
2775:../uvc.c      ****                 }
2776:../uvc.c      ****             }
2777:../uvc.c      ****             break;
2778:../uvc.c      **** 
2779:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2780:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2781:../uvc.c      ****             {
2782:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2783:../uvc.c      ****                 {
2784:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2785:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2786:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2787:../uvc.c      ****                 	 * has started. */
2788:../uvc.c      ****                     if (streamingStarted == CyTrue)
2789:../uvc.c      ****                     {
2790:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2791:../uvc.c      **** 
2792:../uvc.c      ****                         /* Disable the GPIF state machine. */
2793:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2794:../uvc.c      ****                         gpif_initialized = 0;
2795:../uvc.c      ****                         streamingStarted = CyFalse;
2796:../uvc.c      **** 
2797:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2798:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2799:../uvc.c      ****                         CyU3PBusyWait (100);
2800:../uvc.c      **** 
2801:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2802:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2803:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2804:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2805:../uvc.c      ****                         CyU3PBusyWait (100);
2806:../uvc.c      **** 
2807:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2808:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2809:../uvc.c      **** 
2810:../uvc.c      ****                         uvcHandleReq = CyTrue;
2811:../uvc.c      ****                         /* Complete Control request handshake */
2812:../uvc.c      ****                         CyU3PUsbAckSetup ();
2813:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2814:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2815:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2816:../uvc.c      ****                     }
2817:../uvc.c      ****                     else
2818:../uvc.c      ****                     {
2819:../uvc.c      ****                         uvcHandleReq = CyTrue;
2820:../uvc.c      ****                         CyU3PUsbAckSetup ();
2821:../uvc.c      ****                     }
2822:../uvc.c      ****                 }
2823:../uvc.c      ****             }
2824:../uvc.c      ****             break;
2825:../uvc.c      **** 
2826:../uvc.c      ****         default:
2827:../uvc.c      ****             break;
2828:../uvc.c      ****     }
2829:../uvc.c      **** 
2830:../uvc.c      ****     /* Return status of request handling to the USB driver */
2831:../uvc.c      ****     return uvcHandleReq;
2832:../uvc.c      **** }
2833:../uvc.c      **** 
2834:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2835:../uvc.c      **** 
2836:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2837:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2838:../uvc.c      ****  */
2839:../uvc.c      **** void
2840:../uvc.c      **** CyFxUvcApplnDmaCallback (
2841:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2842:../uvc.c      ****         CyU3PDmaCbType_t      type,
2843:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2844:../uvc.c      ****         )
2845:../uvc.c      **** {
2846:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2847:../uvc.c      **** #if 1
2848:../uvc.c      ****     CyU3PReturnStatus_t status;
2849:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2850:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2851:../uvc.c      **** 
2852:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2853:../uvc.c      ****     {
2854:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2855:../uvc.c      ****             {
2856:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2857:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2858:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2859:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2860:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2861:../uvc.c      ****                 	stiflag = 0x03;
2862:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2863:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2864:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2865:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2866:../uvc.c      ****                 }
2867:../uvc.c      **** #endif
2868:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2869:../uvc.c      ****                 fb++;
2870:../uvc.c      ****             }
2871:../uvc.c      ****             else
2872:../uvc.c      ****             {
2873:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2874:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2875:../uvc.c      ****                 pb++;
2876:../uvc.c      ****                 pbc = input->buffer_p.count;
2877:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2878:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2879:../uvc.c      ****                 //lineCount = 0; //res test
2880:../uvc.c      **** #if 1   //remove the still flag clearing here
2881:../uvc.c      ****                 if(stiflag == 0x0F){
2882:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2883:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2884:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2885:../uvc.c      ****                 	stiflag = 0xAA;
2886:../uvc.c      ****                 }
2887:../uvc.c      **** #endif
2888:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2889:../uvc.c      ****             }
2890:../uvc.c      **** 
2891:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2892:../uvc.c      ****             prodCount++;
2893:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2894:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2895:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2896:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2897:../uvc.c      ****             {
2898:../uvc.c      ****                 prodCount--;
2899:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2900:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2901:../uvc.c      ****             }
2902:../uvc.c      ****     }
2903:../uvc.c      **** #endif
2904:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2905:../uvc.c      ****     {
2906:../uvc.c      ****         consCount++;
2907:../uvc.c      ****         streamingStarted = CyTrue;
2908:../uvc.c      ****     }
2909:../uvc.c      **** }
2910:../uvc.c      **** 
2911:../uvc.c      **** /*
2912:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2913:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2914:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2915:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2916:../uvc.c      ****  * to commit the buffer.
2917:../uvc.c      ****  */
2918:../uvc.c      **** static uint8_t
2919:../uvc.c      **** CyFxUvcAppCommitEOF (
2920:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2921:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2922:../uvc.c      ****         )
2923:../uvc.c      **** {
2924:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2925:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2926:../uvc.c      **** 
2927:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2928:../uvc.c      **** 
2929:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2930:../uvc.c      ****     {
2931:../uvc.c      ****         switch (stateId)
2932:../uvc.c      ****         {
2933:../uvc.c      **** 
2934:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2935:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2936:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2937:../uvc.c      ****                 break;
2938:../uvc.c      **** 
2939:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2940:../uvc.c      ****                 socket = 0;
2941:../uvc.c      ****                 break;
2942:../uvc.c      **** 
2943:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2944:../uvc.c      ****                 socket = 1;
2945:../uvc.c      ****                 break;
2946:../uvc.c      **** 
2947:../uvc.c      ****             default:
2948:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2949:../uvc.c      ****                 /* Unexpected current state. Return error. */
2950:../uvc.c      ****             	//lineCount++;
2951:../uvc.c      ****             	return 1;
2952:../uvc.c      ****         }
2953:../uvc.c      ****     }
2954:../uvc.c      **** 
2955:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2956:../uvc.c      ****     {
2957:../uvc.c      ****         switch (stateId)
2958:../uvc.c      ****         {
2959:../uvc.c      **** #ifndef CAM720
2960:../uvc.c      **** #ifdef GPIFIIM
2961:../uvc.c      ****             case 13:
2962:../uvc.c      ****             case 24:
2963:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2964:../uvc.c      ****                 break;
2965:../uvc.c      **** 
2966:../uvc.c      ****             case 8:
2967:../uvc.c      ****                 socket = 0;
2968:../uvc.c      ****                 break;
2969:../uvc.c      **** 
2970:../uvc.c      ****             case 20:
2971:../uvc.c      ****                 socket = 1;
2972:../uvc.c      ****                 break;
2973:../uvc.c      **** #else
2974:../uvc.c      ****             case 11:
2975:../uvc.c      ****             case 18:
2976:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2977:../uvc.c      ****                 break;
2978:../uvc.c      **** 
2979:../uvc.c      ****             case 8:
2980:../uvc.c      ****                 socket = 0;
2981:../uvc.c      ****                 break;
2982:../uvc.c      **** 
2983:../uvc.c      ****             case 15:
2984:../uvc.c      ****                 socket = 1;
2985:../uvc.c      ****                 break;
2986:../uvc.c      **** #endif
2987:../uvc.c      **** #else
2988:../uvc.c      ****             case 11:
2989:../uvc.c      ****             case 18:
2990:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2991:../uvc.c      ****                 break;
2992:../uvc.c      **** 
2993:../uvc.c      ****             case 8:
2994:../uvc.c      ****                 socket = 0;
2995:../uvc.c      ****                 break;
2996:../uvc.c      **** 
2997:../uvc.c      ****             case 15:
2998:../uvc.c      ****                 socket = 1;
2999:../uvc.c      ****                 break;
3000:../uvc.c      **** 
3001:../uvc.c      **** #endif
3002:../uvc.c      ****              default:
3003:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3004:../uvc.c      ****                 /* Unexpected current state. Return error. */
3005:../uvc.c      ****                return 1;
3006:../uvc.c      ****         }
3007:../uvc.c      ****     }
3008:../uvc.c      **** 
3009:../uvc.c      ****     if (socket != 0xFF)
3010:../uvc.c      ****     {
3011:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3012:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3013:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3014:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3015:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3016:../uvc.c      ****         {
3017:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3018:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3019:../uvc.c      ****         }
3020:../uvc.c      ****     }
3021:../uvc.c      **** 
3022:../uvc.c      ****     return 0;
3023:../uvc.c      **** }
3024:../uvc.c      **** 
3025:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3026:../uvc.c      **** void
3027:../uvc.c      **** CyFxGpifCB (
3028:../uvc.c      ****         CyU3PGpifEventType event,
3029:../uvc.c      ****         uint8_t currentState
3030:../uvc.c      ****         )
3031:../uvc.c      **** {
3032:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3033:../uvc.c      ****     {
3034:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3035:../uvc.c      ****     	           in the UVC implementation. */
3036:../uvc.c      ****     	//hitFV = CyTrue;
3037:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3038:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3039:../uvc.c      ****     }
3040:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3041:../uvc.c      **** }
3042:../uvc.c      **** 
3043:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3044:../uvc.c      **** static void
3045:../uvc.c      **** CyFxUVCApplnDebugInit (
3046:../uvc.c      ****         void)
3047:../uvc.c      **** {
3048:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3049:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3050:../uvc.c      **** 
3051:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3052:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3053:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3054:../uvc.c      ****     {
3055:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3056:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3057:../uvc.c      ****     }
3058:../uvc.c      **** 
3059:../uvc.c      ****     /* Set UART Configuration */
3060:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3061:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3062:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3063:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3064:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3065:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3066:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3067:../uvc.c      **** 
3068:../uvc.c      ****     /* Set the UART configuration */
3069:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3070:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3071:../uvc.c      ****     {
3072:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3073:../uvc.c      ****     }
3074:../uvc.c      **** 
3075:../uvc.c      ****     /* Set the UART transfer */
3076:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3077:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3078:../uvc.c      ****     {
3079:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3080:../uvc.c      ****     }
3081:../uvc.c      **** 
3082:../uvc.c      ****     /* Initialize the Debug logger module. */
3083:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3084:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3085:../uvc.c      ****     {
3086:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3087:../uvc.c      ****     }
3088:../uvc.c      **** 
3089:../uvc.c      ****     /* Disable log message headers. */
3090:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3091:../uvc.c      **** }
3092:../uvc.c      **** 
3093:../uvc.c      **** /* I2C initialization. */
3094:../uvc.c      **** static void
3095:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3096:../uvc.c      **** {
3097:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3098:../uvc.c      ****     CyU3PReturnStatus_t status;
3099:../uvc.c      **** 
3100:../uvc.c      ****     status = CyU3PI2cInit ();
3101:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3102:../uvc.c      ****     {
3103:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3104:../uvc.c      ****         CyFxAppErrorHandler (status);
3105:../uvc.c      ****     }
3106:../uvc.c      **** 
3107:../uvc.c      ****     /*  Set I2C Configuration */
3108:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3109:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3110:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3111:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3112:../uvc.c      **** 
3113:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3114:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3115:../uvc.c      ****     {
3116:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3117:../uvc.c      ****         CyFxAppErrorHandler (status);
3118:../uvc.c      ****     }
3119:../uvc.c      **** }
3120:../uvc.c      **** 
3121:../uvc.c      **** #ifdef BACKFLOW_DETECT
3122:../uvc.c      **** static void CyFxUvcAppPibCallback (
3123:../uvc.c      ****         CyU3PPibIntrType cbType,
3124:../uvc.c      ****         uint16_t cbArg)
3125:../uvc.c      **** {
3126:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3127:../uvc.c      ****     {
3128:../uvc.c      ****         if (!back_flow_detected)
3129:../uvc.c      ****         {
3130:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3131:../uvc.c      ****             back_flow_detected = 1;
3132:../uvc.c      ****         }
3133:../uvc.c      ****     }
3134:../uvc.c      **** }
3135:../uvc.c      **** #endif
3136:../uvc.c      **** 
3137:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3138:../uvc.c      **** static void
3139:../uvc.c      **** CyFxUvcAppDebugCallback (
3140:../uvc.c      ****         CyU3PDmaChannel   *handle,
3141:../uvc.c      ****         CyU3PDmaCbType_t   type,
3142:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3143:../uvc.c      **** {
3144:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3145:../uvc.c      ****     {
3146:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3147:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3148:../uvc.c      ****     }
3149:../uvc.c      **** }
3150:../uvc.c      **** #endif
3151:../uvc.c      **** 
3152:../uvc.c      **** #if 0
3153:../uvc.c      **** static void CyFxAppIntEpCb(
3154:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3155:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3156:../uvc.c      **** 		uint8_t  ebNum)
3157:../uvc.c      **** 		{
3158:../uvc.c      **** 			//CyBool_t value;
3159:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3160:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3161:../uvc.c      **** 
3162:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3163:../uvc.c      **** 		}
3164:../uvc.c      **** #endif
3165:../uvc.c      **** 
3166:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3167:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3168:../uvc.c      ****    configures the DMA module for the UVC Application */
3169:../uvc.c      **** static void
3170:../uvc.c      **** CyFxUVCApplnInit (void)
3171:../uvc.c      **** {
3172:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3173:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3174:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3175:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3176:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3177:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3178:../uvc.c      **** 
3179:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3180:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3181:../uvc.c      **** 
3182:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3183:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3184:../uvc.c      **** #endif
3185:../uvc.c      **** 
3186:../uvc.c      ****     /* Create UVC event group */
3187:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3188:../uvc.c      ****     if (apiRetStatus != 0)
3189:../uvc.c      ****     {
3190:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3191:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3192:../uvc.c      ****     }
3193:../uvc.c      **** 
3194:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3195:../uvc.c      ****     CyFxUvcAppPTZInit ();
3196:../uvc.c      **** #endif
3197:../uvc.c      **** 
3198:../uvc.c      ****     isUsbConnected = CyFalse;
3199:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3200:../uvc.c      **** 
3201:../uvc.c      ****     /* Init the GPIO module */
3202:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3203:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3204:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3205:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3206:../uvc.c      ****     gpioClock.halfDiv    = 0;
3207:../uvc.c      **** 
3208:../uvc.c      ****     /* Initialize Gpio interface */
3209:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3210:../uvc.c      ****     if (apiRetStatus != 0)
3211:../uvc.c      ****     {
3212:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3213:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3214:../uvc.c      ****     }
3215:../uvc.c      **** 
3216:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3217:../uvc.c      ****      * must use GpioOverride to configure it */
3218:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3219:../uvc.c      ****     if (apiRetStatus != 0)
3220:../uvc.c      ****     {
3221:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3222:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3223:../uvc.c      ****     }
3224:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3225:../uvc.c      ****     if (apiRetStatus != 0)
3226:../uvc.c      ****     {
3227:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3228:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3229:../uvc.c      ****     }
3230:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3231:../uvc.c      ****     if (apiRetStatus != 0)
3232:../uvc.c      ****     {
3233:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3235:../uvc.c      ****     }
3236:../uvc.c      **** 
3237:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3238:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3239:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3240:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3241:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3242:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3243:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3244:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3245:../uvc.c      ****     {
3246:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3247:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3248:../uvc.c      ****     }
3249:../uvc.c      **** 
3250:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3251:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3252:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3253:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3254:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3255:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3256:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3257:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3258:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3259:../uvc.c      ****     {
3260:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3261:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3262:../uvc.c      ****     }
3263:../uvc.c      **** 
3264:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3265:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3266:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3267:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3268:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3269:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3270:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3271:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3272:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3273:../uvc.c      ****     {
3274:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3275:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3276:../uvc.c      ****     }
3277:../uvc.c      **** 
3278:../uvc.c      ****     /* Initialize the P-port. */
3279:../uvc.c      ****     pibclock.clkDiv      = 2;
3280:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3281:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3282:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3283:../uvc.c      **** 
3284:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3285:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3286:../uvc.c      ****     {
3287:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3288:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3289:../uvc.c      ****     }
3290:../uvc.c      **** 
3291:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3292:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3293:../uvc.c      **** 
3294:../uvc.c      **** #ifdef BACKFLOW_DETECT
3295:../uvc.c      ****     back_flow_detected = 0;
3296:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3297:../uvc.c      **** #endif
3298:../uvc.c      **** 
3299:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3300:../uvc.c      ****     SensorReset ();
3301:../uvc.c      ****     CyU3PThreadSleep(5000);
3302:../uvc.c      ****     //SensorInit ();
3303:../uvc.c      **** 
3304:../uvc.c      ****     /* USB initialization. */
3305:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3306:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3307:../uvc.c      ****     {
3308:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3309:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3310:../uvc.c      ****     }
3311:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3312:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3313:../uvc.c      **** 
3314:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3315:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3316:../uvc.c      **** 
3317:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3318:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3319:../uvc.c      **** 
3320:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3321:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3322:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3323:../uvc.c      **** 
3324:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3325:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3326:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3327:../uvc.c      **** 
3328:../uvc.c      ****     /* Configuration descriptors. */
3329:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3330:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3331:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3332:../uvc.c      **** 
3333:../uvc.c      ****     /* String Descriptors */
3334:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3335:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3336:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3337:../uvc.c      **** 
3338:../uvc.c      ****     /* Configure the status interrupt endpoint.
3339:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3340:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3341:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3342:../uvc.c      ****      */
3343:../uvc.c      ****     endPointConfig.enable   = 1;
3344:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3345:../uvc.c      ****     endPointConfig.pcktSize = 64;
3346:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3347:../uvc.c      ****     endPointConfig.streams  = 0;
3348:../uvc.c      ****     endPointConfig.burstLen = 1;
3349:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3350:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3351:../uvc.c      ****     {
3352:../uvc.c      ****         /* Error Handling */
3353:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3354:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3355:../uvc.c      ****     }
3356:../uvc.c      **** 
3357:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3358:../uvc.c      ****     dmaInterConfig.size           = 1024;
3359:../uvc.c      ****     dmaInterConfig.count          = 1;
3360:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3361:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3362:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3363:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3364:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3365:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3366:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3367:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3368:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3369:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3370:../uvc.c      ****             &dmaInterConfig);
3371:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3372:../uvc.c      ****     {
3373:../uvc.c      ****         /* Error handling */
3374:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3375:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3376:../uvc.c      ****     }
3377:../uvc.c      **** 
3378:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3379:../uvc.c      ****     if (glInterStaBuffer == 0)
3380:../uvc.c      ****     {
3381:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3382:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3383:../uvc.c      ****     }
3384:../uvc.c      **** 
3385:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3386:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3387:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3388:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3389:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3390:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3391:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3392:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3393:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3394:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3395:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3396:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3397:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3398:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3399:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3400:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3401:../uvc.c      ****             &dmaMultiConfig);
3402:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3403:../uvc.c      ****     {
3404:../uvc.c      ****         /* Error handling */
3405:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3406:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3407:../uvc.c      ****     }
3408:../uvc.c      **** 
3409:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3410:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3411:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3412:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3413:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3414:../uvc.c      ****      */
3415:../uvc.c      **** 
3416:../uvc.c      ****     endPointConfig.enable   = 1;
3417:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3418:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3419:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3420:../uvc.c      ****     endPointConfig.streams  = 0;
3421:../uvc.c      ****     endPointConfig.burstLen = 1;
3422:../uvc.c      **** 
3423:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3424:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3425:../uvc.c      ****     {
3426:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3427:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3428:../uvc.c      ****     }
3429:../uvc.c      **** 
3430:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3431:../uvc.c      **** 
3432:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3433:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3434:../uvc.c      ****     {
3435:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3436:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3437:../uvc.c      ****     }
3438:../uvc.c      **** 
3439:../uvc.c      ****     channelConfig.size           = 1024;
3440:../uvc.c      ****     channelConfig.count          = 1;
3441:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3442:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3443:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3444:../uvc.c      ****     channelConfig.prodHeader     = 0;
3445:../uvc.c      ****     channelConfig.prodFooter     = 0;
3446:../uvc.c      ****     channelConfig.consHeader     = 0;
3447:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3448:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3449:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3450:../uvc.c      **** 
3451:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3452:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3453:../uvc.c      ****     {
3454:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3455:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3456:../uvc.c      ****     }
3457:../uvc.c      **** 
3458:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3459:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3460:../uvc.c      ****     {
3461:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3462:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3463:../uvc.c      ****     }
3464:../uvc.c      **** 
3465:../uvc.c      ****     channelConfig.size           = 1024;
3466:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3467:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3468:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3469:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3470:../uvc.c      ****     channelConfig.prodHeader     = 0;
3471:../uvc.c      ****     channelConfig.prodFooter     = 0;
3472:../uvc.c      ****     channelConfig.consHeader     = 0;
3473:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3474:../uvc.c      ****     channelConfig.notification   = 0;
3475:../uvc.c      ****     channelConfig.cb             = 0;
3476:../uvc.c      **** 
3477:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3478:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3479:../uvc.c      ****     {
3480:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3481:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3482:../uvc.c      ****     }
3483:../uvc.c      **** 
3484:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3485:../uvc.c      ****     if (glDebugRspBuffer == 0)
3486:../uvc.c      ****     {
3487:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3488:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3489:../uvc.c      ****     }
3490:../uvc.c      **** #endif
3491:../uvc.c      **** 
3492:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3493:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3494:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3495:../uvc.c      ****     {
3496:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3497:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3498:../uvc.c      ****     }
3499:../uvc.c      **** 
3500:../uvc.c      ****     CyU3PBusyWait(100);
3501:../uvc.c      **** 
3502:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3503:../uvc.c      **** 
3504:../uvc.c      ****     endPointConfig.enable   = 1;
3505:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3506:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3507:../uvc.c      ****     {
3508:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3509:../uvc.c      ****     	endPointConfig.burstLen = 16;
3510:../uvc.c      ****     }
3511:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3512:../uvc.c      ****     {
3513:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3514:../uvc.c      ****     	endPointConfig.burstLen = 1;
3515:../uvc.c      ****     }
3516:../uvc.c      ****     endPointConfig.streams  = 0;
3517:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3518:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3519:../uvc.c      ****     {
3520:../uvc.c      ****         /* Error Handling */
3521:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3522:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3523:../uvc.c      ****     }
3524:../uvc.c      **** #if 0    //for still image method 3 using
3525:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3527:../uvc.c      ****     {
3528:../uvc.c      ****         /* Error Handling */
3529:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3530:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3531:../uvc.c      ****     }
3532:../uvc.c      **** #endif
3533:../uvc.c      **** 
3534:../uvc.c      **** }
3535:../uvc.c      **** 
3536:../uvc.c      **** /*
3537:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3538:../uvc.c      ****  * streaming session is started.
3539:../uvc.c      ****  */
3540:../uvc.c      **** static void
3541:../uvc.c      **** CyFxUvcAppGpifInit (
3542:../uvc.c      ****         void)
3543:../uvc.c      **** {
3544:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3545:../uvc.c      **** 
3546:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3547:../uvc.c      ****     {
3548:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3549:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3550:../uvc.c      ****     }
3551:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3552:../uvc.c      ****     {
3553:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3554:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3555:../uvc.c      ****     }
3556:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3557:../uvc.c      ****     {
3558:../uvc.c      ****         /* Error Handling */
3559:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3560:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3561:../uvc.c      ****     }
3562:../uvc.c      **** 
3563:../uvc.c      ****     /* Start the state machine from the designated start state. */
3564:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3565:../uvc.c      ****     {
3566:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3567:../uvc.c      ****     }
3568:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3569:../uvc.c      ****     {
3570:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3571:../uvc.c      ****     }
3572:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3573:../uvc.c      ****     {
3574:../uvc.c      ****         /* Error Handling */
3575:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3576:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3577:../uvc.c      ****     }
3578:../uvc.c      **** }
3579:../uvc.c      **** 
3580:../uvc.c      **** /*
3581:../uvc.c      ****  * Entry function for the UVC Application Thread
3582:../uvc.c      ****  */
3583:../uvc.c      **** 
3584:../uvc.c      **** uint32_t posTick;
3585:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3586:../uvc.c      **** 
3587:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3587 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3588:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3588 0
  28 0000 28209FE5 		ldr	r2, .L2
3587:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3587 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3588 0
  36 0008 002092E5 		ldr	r2, [r2]
3587:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3587 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3588 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3589:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3589 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3590:../uvc.c      **** }
  49              		.loc 1 3590 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3589:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3589 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3591:../uvc.c      **** 
3592:../uvc.c      **** 
3593:../uvc.c      **** void
3594:../uvc.c      **** UVCAppThread_Entry (
3595:../uvc.c      ****         uint32_t input)
3596:../uvc.c      **** {
3597:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3598:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3599:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3600:../uvc.c      ****     uint8_t i = 0;
3601:../uvc.c      ****     uint32_t flag;
3602:../uvc.c      ****     uint32_t prinflag = 0;
3603:../uvc.c      **** static uint8_t IMcount = 0;
3604:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3605:../uvc.c      ****     uint32_t frameCnt = 0;
3606:../uvc.c      **** #endif
3607:../uvc.c      ****     /* Initialize the Uart Debug Module */
3608:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3609:../uvc.c      **** 
3610:../uvc.c      ****     /* Initialize the I2C interface */
3611:../uvc.c      **** 	while (i++ < 6){
3612:../uvc.c      **** 		CyU3PThreadSleep(500);
3613:../uvc.c      **** 	}
3614:../uvc.c      **** 
3615:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3616:../uvc.c      **** 
3617:../uvc.c      ****     /* Initialize the UVC Application */
3618:../uvc.c      ****     CyFxUVCApplnInit ();
3619:../uvc.c      ****     /*
3620:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3621:../uvc.c      **** 
3622:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3623:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3624:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3625:../uvc.c      **** 
3626:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3627:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3628:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3629:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3630:../uvc.c      **** 
3631:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3632:../uvc.c      ****        of handling the abort request.
3633:../uvc.c      ****      */
3634:../uvc.c      **** 
3635:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3636:../uvc.c      ****     //CyU3PThreadSleep(1000);
3637:../uvc.c      **** 
3638:../uvc.c      ****     for (;;)
3639:../uvc.c      ****     {
3640:../uvc.c      ****         /* Waiting for the Video Stream Event */
3641:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3642:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3643:../uvc.c      ****         {
3644:../uvc.c      **** #if 0 //test for new firmware no video bring up
3645:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3646:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3647:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3648:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3649:../uvc.c      ****             {
3650:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3651:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3652:../uvc.c      ****                 {
3653:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3654:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3655:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3656:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3657:../uvc.c      **** #endif
3658:../uvc.c      **** #endif
3659:../uvc.c      ****                     }
3660:../uvc.c      ****                 else
3661:../uvc.c      ****                 {
3662:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3663:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3664:../uvc.c      **** #ifdef USB_LOWRES_IMG
3665:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3666:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3667:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3668:../uvc.c      **** #endif
3669:../uvc.c      **** #endif
3670:../uvc.c      ****                 }
3671:../uvc.c      **** 
3672:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3673:../uvc.c      ****                 prodCount++;
3674:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3675:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3676:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3677:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3678:../uvc.c      ****                 {
3679:../uvc.c      ****                     prodCount--;
3680:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3681:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3682:../uvc.c      ****                 }
3683:../uvc.c      ****             }
3684:../uvc.c      **** #endif
3685:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3686:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3687:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3688:../uvc.c      ****             {
3689:../uvc.c      ****             	if(0&&(prinflag == 0)){
3690:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3691:../uvc.c      ****             		prinflag = 1;
3692:../uvc.c      ****             	}
3693:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3694:../uvc.c      ****             	fb=0;
3695:../uvc.c      ****             	pb=0;
3696:../uvc.c      ****             	pbc=0;
3697:../uvc.c      ****                 prodCount = 0;
3698:../uvc.c      ****                 consCount = 0;
3699:../uvc.c      ****                 hitFV     = CyFalse;
3700:../uvc.c      **** 
3701:../uvc.c      **** #ifdef BACKFLOW_DETECT
3702:../uvc.c      ****                 back_flow_detected = 0;
3703:../uvc.c      **** #endif
3704:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3705:../uvc.c      ****                 frameCnt++;
3706:../uvc.c      **** #endif
3707:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3708:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3709:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3710:../uvc.c      ****                 //}
3711:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3712:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3713:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3714:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3715:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3716:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3717:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3718:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3719:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3720:../uvc.c      ****                 		stiflag = 0xFF;
3721:../uvc.c      ****                 		IMcount = 0;
3722:../uvc.c      ****                 	}
3723:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3724:../uvc.c      **** 
3725:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3726:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3727:../uvc.c      ****                 		stiflag = 0x0F;
3728:../uvc.c      ****                 		IMcount = 0;
3729:../uvc.c      ****                 		}
3730:../uvc.c      ****                  		/*if(IMcount > 0x4){
3731:../uvc.c      ****                 			stiflag = 0x0F;
3732:../uvc.c      ****                 			IMcount = 0;
3733:../uvc.c      ****                 		}*/
3734:../uvc.c      **** 
3735:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3736:../uvc.c      ****                     //CyU3PThreadSleep(400);
3737:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3738:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3739:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3740:../uvc.c      **** 
3741:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3742:../uvc.c      ****                 	{
3743:../uvc.c      ****                     switch (setRes)
3744:../uvc.c      ****                      {
3745:../uvc.c      ****                  	case 1: //1944
3746:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
3747:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3748:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
3749:../uvc.c      ****                  		break;
3750:../uvc.c      ****                  	case 2: //1080
3751:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
3752:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3753:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
3754:../uvc.c      ****                  		break;
3755:../uvc.c      ****                  	case 3: //720
3756:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
3757:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3758:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
3759:../uvc.c      ****                  		break;
3760:../uvc.c      ****                  	case 4: //VGA
3761:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
3762:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3763:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
3764:../uvc.c      ****                  		break;
3765:../uvc.c      ****                  	default:
3766:../uvc.c      ****                  		break;
3767:../uvc.c      ****                      }
3768:../uvc.c      ****                     IMcount = 0;
3769:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3770:../uvc.c      ****                 	stiflag = 0x0;
3771:../uvc.c      ****                 	}
3772:../uvc.c      ****                 }
3773:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3774:../uvc.c      ****                 /* Reset the DMA channel. */
3775:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3776:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3777:../uvc.c      ****                 {
3778:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3779:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3780:../uvc.c      ****                 }
3781:../uvc.c      **** 
3782:../uvc.c      ****                 /* Start Channel Immediately */
3783:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3784:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3785:../uvc.c      ****                 {
3786:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3787:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3788:../uvc.c      ****                 }
3789:../uvc.c      **** 
3790:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3791:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3792:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3793:../uvc.c      ****                 }
3794:../uvc.c      ****         }
3795:../uvc.c      ****         else
3796:../uvc.c      ****         {
3797:../uvc.c      ****             /* If we have a stream abort request pending. */
3798:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3799:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3800:../uvc.c      ****             {
3801:../uvc.c      ****                 hitFV     = CyFalse;
3802:../uvc.c      ****                 prodCount = 0;
3803:../uvc.c      ****                 consCount = 0;
3804:../uvc.c      ****                 if(0&&(prinflag == 0)){
3805:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3806:../uvc.c      ****                 	prinflag = 1;
3807:../uvc.c      ****                 }
3808:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3809:../uvc.c      ****                 fb=0;
3810:../uvc.c      ****                 pb=0;
3811:../uvc.c      ****                 pbc=0;
3812:../uvc.c      **** 
3813:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3814:../uvc.c      ****                 {
3815:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3816:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3817:../uvc.c      ****                     {
3818:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3819:../uvc.c      ****                     }
3820:../uvc.c      **** 
3821:../uvc.c      ****                     /* Flush the Endpoint memory */
3822:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3823:../uvc.c      ****                 }
3824:../uvc.c      **** 
3825:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3826:../uvc.c      ****             }
3827:../uvc.c      ****             else
3828:../uvc.c      ****             {
3829:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3830:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3831:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3832:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3833:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3834:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3835:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3836:../uvc.c      ****                 {
3837:../uvc.c      ****                     /* Error handling */
3838:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3839:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3840:../uvc.c      ****                 }
3841:../uvc.c      **** 
3842:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3843:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3844:../uvc.c      ****                 {
3845:../uvc.c      **** #if 0
3846:../uvc.c      ****                 	//for start up of the AF Lens
3847:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3848:../uvc.c      ****                     CyU3PThreadSleep(500);
3849:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3850:../uvc.c      ****                     CyU3PThreadSleep(500);
3851:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3852:../uvc.c      ****                    	CyU3PThreadSleep(300);
3853:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3854:../uvc.c      ****                     CyU3PThreadSleep(500);
3855:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3856:../uvc.c      ****                     CyU3PThreadSleep(500);
3857:../uvc.c      **** #endif
3858:../uvc.c      **** #if 0
3859:../uvc.c      ****                     switch (setRes)
3860:../uvc.c      ****                     {
3861:../uvc.c      ****                     	case 1: //1944
3862:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3863:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3864:../uvc.c      ****                     		break;
3865:../uvc.c      ****                     	case 2: //1080
3866:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3867:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3868:../uvc.c      ****                     		break;
3869:../uvc.c      ****                     	case 3: //720
3870:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3871:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3872:../uvc.c      ****                     		break;
3873:../uvc.c      ****                     	default:
3874:../uvc.c      ****                     		break;
3875:../uvc.c      ****                     }
3876:../uvc.c      **** #endif
3877:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3878:../uvc.c      **** 
3879:../uvc.c      ****                     gpif_initialized = CyTrue;
3880:../uvc.c      ****                     CyU3PThreadSleep(200);
3881:../uvc.c      ****                     
3882:../uvc.c      ****                 }
3883:../uvc.c      ****                 else
3884:../uvc.c      ****                 {
3885:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3886:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3887:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3888:../uvc.c      ****                 }
3889:../uvc.c      ****             }
3890:../uvc.c      ****         }
3891:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3892:../uvc.c      **** 
3893:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3894:../uvc.c      ****         CyU3PThreadRelinquish ();
3895:../uvc.c      ****     }
3896:../uvc.c      **** }
3897:../uvc.c      **** 
3898:../uvc.c      **** /*
3899:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3900:../uvc.c      ****  */
3901:../uvc.c      **** 
3902:../uvc.c      **** static void
3903:../uvc.c      **** UVCHandleProcessingUnitRqts (
3904:../uvc.c      ****         void)
3905:../uvc.c      **** {
3906:../uvc.c      ****     uint8_t CtrlAdd;
3907:../uvc.c      **** #ifdef DbgInfo
3908:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3909:../uvc.c      **** #endif
3910:../uvc.c      ****     switch (wValue)
3911:../uvc.c      ****     {
3912:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3913:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3914:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3915:../uvc.c      ****     		break;
3916:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3917:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3918:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3919:../uvc.c      ****     		break;
3920:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3921:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3922:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3923:../uvc.c      **** 			break;
3924:../uvc.c      **** 
3925:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3926:../uvc.c      **** 
3927:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3928:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3929:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3930:../uvc.c      ****       		break;
3931:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3932:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3933:../uvc.c      ****      		ControlHandle(HueCtlID5);
3934:../uvc.c      ****      		break;
3935:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3936:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3937:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3938:../uvc.c      ****           		break;
3939:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3940:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3941:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3942:../uvc.c      ****           		break;
3943:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3944:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3945:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3946:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3947:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3948:../uvc.c      ****     		break;
3949:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3950:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3951:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3952:../uvc.c      ****     		break;
3953:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3954:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3955:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3956:../uvc.c      ****     		break;
3957:../uvc.c      **** 
3958:../uvc.c      ****         default:
3959:../uvc.c      ****             /*
3960:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3961:../uvc.c      ****              * other controls.
3962:../uvc.c      ****              */
3963:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3964:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3965:../uvc.c      ****             break;
3966:../uvc.c      ****     }
3967:../uvc.c      **** }
3968:../uvc.c      **** 
3969:../uvc.c      **** /*
3970:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3971:../uvc.c      ****  */
3972:../uvc.c      **** static void
3973:../uvc.c      **** UVCHandleCameraTerminalRqts (
3974:../uvc.c      ****         void)
3975:../uvc.c      **** {
3976:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3977:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3978:../uvc.c      ****     uint16_t readCount;
3979:../uvc.c      ****     uint16_t zoomVal;
3980:../uvc.c      ****     int32_t  panVal, tiltVal;
3981:../uvc.c      ****     CyBool_t sendData = CyFalse;
3982:../uvc.c      **** #endif
3983:../uvc.c      ****     uint8_t CtrlAdd;
3984:../uvc.c      **** 
3985:../uvc.c      ****     switch (wValue)
3986:../uvc.c      ****     {
3987:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3988:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3989:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3990:../uvc.c      ****     		break;
3991:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3992:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3993:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3994:../uvc.c      ****     		break;
3995:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3996:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3997:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3998:../uvc.c      **** 			break;
3999:../uvc.c      **** 
4000:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4001:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4002:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4003:../uvc.c      **** 			break;
4004:../uvc.c      **** 
4005:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4006:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4007:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4008:../uvc.c      ****       		break;
4009:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4010:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4011:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4012:../uvc.c      ****      		break;
4013:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4014:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4015:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4016:../uvc.c      ****           		break;
4017:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4018:../uvc.c      ****           		break;
4019:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4020:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4021:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4022:../uvc.c      ****      		break;
4023:../uvc.c      **** 
4024:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4025:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4026:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4027:../uvc.c      ****     		break;
4028:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4029:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4030:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4031:../uvc.c      ****     		break;
4032:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4033:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4034:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4035:../uvc.c      ****     		break;
4036:../uvc.c      **** 
4037:../uvc.c      ****         default:
4038:../uvc.c      ****             /*
4039:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4040:../uvc.c      ****              * other controls.
4041:../uvc.c      ****              */
4042:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4043:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4044:../uvc.c      ****             break;
4045:../uvc.c      ****     }
4046:../uvc.c      **** 
4047:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4048:../uvc.c      ****     switch (wValue)
4049:../uvc.c      ****     {
4050:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4051:../uvc.c      ****             switch (bRequest)
4052:../uvc.c      ****             {
4053:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4054:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4055:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4056:../uvc.c      ****                     break;
4057:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4058:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4059:../uvc.c      ****                     sendData = CyTrue;
4060:../uvc.c      ****                     break;
4061:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4062:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4063:../uvc.c      ****                     sendData = CyTrue;
4064:../uvc.c      ****                     break;
4065:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4066:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4067:../uvc.c      ****                     sendData = CyTrue;
4068:../uvc.c      ****                     break;
4069:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4070:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4071:../uvc.c      ****                     sendData = CyTrue;
4072:../uvc.c      ****                     break;
4073:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4074:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4075:../uvc.c      ****                     sendData = CyTrue;
4076:../uvc.c      ****                     break;
4077:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4078:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4079:../uvc.c      ****                             glEp0Buffer, &readCount);
4080:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4081:../uvc.c      ****                     {
4082:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4083:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4084:../uvc.c      ****                     }
4085:../uvc.c      ****                     break;
4086:../uvc.c      ****                 default:
4087:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4088:../uvc.c      ****                     break;
4089:../uvc.c      ****             }
4090:../uvc.c      **** 
4091:../uvc.c      ****             if (sendData)
4092:../uvc.c      ****             {
4093:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4094:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4095:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4096:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4097:../uvc.c      ****             }
4098:../uvc.c      ****             break;
4099:../uvc.c      **** 
4100:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4101:../uvc.c      ****             switch (bRequest)
4102:../uvc.c      ****             {
4103:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4104:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4105:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4106:../uvc.c      ****                     break;
4107:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4108:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4109:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4110:../uvc.c      ****                     sendData = CyTrue;
4111:../uvc.c      ****                     break;
4112:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4113:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4114:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4115:../uvc.c      ****                     sendData = CyTrue;
4116:../uvc.c      ****                     break;
4117:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4118:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4119:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4120:../uvc.c      ****                     sendData = CyTrue;
4121:../uvc.c      ****                     break;
4122:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4123:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4124:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4125:../uvc.c      ****                     sendData = CyTrue;
4126:../uvc.c      ****                     break;
4127:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4128:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4129:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4130:../uvc.c      ****                     sendData = CyTrue;
4131:../uvc.c      ****                     break;
4132:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4133:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4134:../uvc.c      ****                             glEp0Buffer, &readCount);
4135:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4136:../uvc.c      ****                     {
4137:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4138:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4139:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4140:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4141:../uvc.c      **** 
4142:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4143:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4144:../uvc.c      ****                     }
4145:../uvc.c      ****                     break;
4146:../uvc.c      ****                 default:
4147:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4148:../uvc.c      ****                     break;
4149:../uvc.c      ****             }
4150:../uvc.c      **** 
4151:../uvc.c      ****             if (sendData)
4152:../uvc.c      ****             {
4153:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4154:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4155:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4156:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4157:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4158:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4159:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4160:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4161:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4162:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4163:../uvc.c      ****             }
4164:../uvc.c      ****             break;
4165:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4166:../uvc.c      ****         default:
4167:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4168:../uvc.c      ****             break;
4169:../uvc.c      ****     }
4170:../uvc.c      **** #endif
4171:../uvc.c      **** }
4172:../uvc.c      **** 
4173:../uvc.c      **** /*
4174:../uvc.c      ****  * Handler for UVC Interface control requests.
4175:../uvc.c      ****  */
4176:../uvc.c      **** static void
4177:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4178:../uvc.c      ****         void)
4179:../uvc.c      **** {
4180:../uvc.c      **** 
4181:../uvc.c      ****     switch (wValue)
4182:../uvc.c      ****     {
4183:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4184:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4185:../uvc.c      ****     		break;
4186:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4187:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4188:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4189:../uvc.c      ****     		break;
4190:../uvc.c      ****     	default:
4191:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4192:../uvc.c      ****      		break;
4193:../uvc.c      ****     }
4194:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4195:../uvc.c      **** 
4196:../uvc.c      **** }
4197:../uvc.c      **** 
4198:../uvc.c      **** /*
4199:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4200:../uvc.c      ****  */
4201:../uvc.c      **** static void
4202:../uvc.c      **** UVCHandleExtensionUnitRqts (
4203:../uvc.c      ****         void)
4204:../uvc.c      **** {
4205:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4206:../uvc.c      **** 
4207:../uvc.c      **** #ifdef DbgInfo
4208:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4209:../uvc.c      **** #endif
4210:../uvc.c      ****     switch (wValue)
4211:../uvc.c      ****     {
4212:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4213:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4214:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4215:../uvc.c      ****     		break;
4216:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4217:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4218:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4219:../uvc.c      ****     		break;
4220:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4221:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4222:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4223:../uvc.c      ****      		break;
4224:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4225:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4226:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4227:../uvc.c      ****     		break;
4228:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4229:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4230:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4231:../uvc.c      ****     		break;
4232:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4233:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4234:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4235:../uvc.c      ****      		break;
4236:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4237:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4238:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4239:../uvc.c      ****     		break;
4240:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4241:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4242:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4243:../uvc.c      ****     		break;
4244:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4245:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4246:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4247:../uvc.c      ****      		break;
4248:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4249:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4250:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4251:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4252:../uvc.c      ****     		}else/* no support for 1080p camera */
4253:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4254:../uvc.c      ****     		break;
4255:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4256:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4257:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4258:../uvc.c      ****     		break;
4259:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4260:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4261:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4262:../uvc.c      ****     		break;
4263:../uvc.c      **** 
4264:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4265:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4266:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4267:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4268:../uvc.c      ****     		break;
4269:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4270:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4271:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4272:../uvc.c      ****     		//break;
4273:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4274:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4275:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4276:../uvc.c      ****     		break;
4277:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4278:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4279:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4280:../uvc.c      ****     		break;
4281:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4282:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4283:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4284:../uvc.c      ****     		break;
4285:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4286:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4287:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4288:../uvc.c      ****     		break;
4289:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4290:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4291:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4292:../uvc.c      ****     		break;
4293:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4294:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4295:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4296:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4297:../uvc.c      ****     		break;
4298:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4299:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4300:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4301:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4302:../uvc.c      ****     		break;
4303:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4304:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4305:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4306:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4307:../uvc.c      ****     		break;
4308:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4309:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4310:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4311:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4312:../uvc.c      ****    		break;
4313:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4314:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4315:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4316:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4317:../uvc.c      ****     		break;
4318:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4319:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4320:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4321:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4322:../uvc.c      ****     		break;
4323:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4324:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4325:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4326:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4327:../uvc.c      ****     		break;
4328:../uvc.c      **** 		case CY_FX_EXT_CONTROL_28AGC_MAX: //AGC Maximum limitation CONTROL28
4329:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4330:../uvc.c      ****       		ControlHandle(Ext1AGCMaxLimetCtlID15);
4331:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
4332:../uvc.c      ****     		break;
4333:../uvc.c      **** 
4334:../uvc.c      ****    	default:
4335:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4336:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4337:../uvc.c      ****     		break;
4338:../uvc.c      ****     }
4339:../uvc.c      **** 
4340:../uvc.c      **** }
4341:../uvc.c      **** 
4342:../uvc.c      **** /*
4343:../uvc.c      ****  * Handler for the video streaming control requests.
4344:../uvc.c      ****  */
4345:../uvc.c      **** static void
4346:../uvc.c      **** UVCHandleVideoStreamingRqts (
4347:../uvc.c      ****         void)
4348:../uvc.c      **** {
  67              		.loc 1 4348 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4349:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4350:../uvc.c      ****     uint16_t readCount;
4351:../uvc.c      **** 
4352:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4352 0
  73 003c A8369FE5 		ldr	r3, .L133
4348:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4348 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4352 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4348:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4348 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4352 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4353:../uvc.c      ****     {
4354:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4355:../uvc.c      ****             switch (bRequest)
4356:../uvc.c      ****             {
4357:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4358:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4359:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4360:../uvc.c      ****                     break;
4361:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4362:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4363:../uvc.c      ****                     glEp0Buffer[1] = 0;
4364:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4365:../uvc.c      ****                     break;
4366:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4367:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4368:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4369:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4370:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4371:../uvc.c      ****                     {
4372:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4373:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4374:../uvc.c      **** 
4375:../uvc.c      ****                     }
4376:../uvc.c      ****                     else
4377:../uvc.c      ****                     {
4378:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4379:../uvc.c      ****                     }
4380:../uvc.c      ****                     break;
4381:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4382:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4383:../uvc.c      ****                             glCommitCtrl, &readCount);
4384:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4385:../uvc.c      ****                     {
4386:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4387:../uvc.c      ****                         {
4388:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4389:../uvc.c      ****                                active data structure. */
4390:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4391:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4392:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4393:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4394:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4395:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4396:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4397:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4398:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4399:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4400:../uvc.c      **** #if 0
4401:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4402:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4403:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4404:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4405:../uvc.c      **** #endif
4406:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4407:../uvc.c      ****                        }
4408:../uvc.c      ****                     }
4409:../uvc.c      ****                     break;
4410:../uvc.c      ****                 default:
4411:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4412:../uvc.c      ****                     break;
4413:../uvc.c      ****             }
4414:../uvc.c      ****             break;
4415:../uvc.c      **** 
4416:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4417:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4417 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4418:../uvc.c      ****             {
4419:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4420:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4421:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4422:../uvc.c      ****                     break;
4423:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4424:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4425:../uvc.c      ****                     glEp0Buffer[1] = 0;
4426:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4427:../uvc.c      ****                     break;
4428:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4429:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4430:../uvc.c      ****                     {
4431:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4432:../uvc.c      ****                     }
4433:../uvc.c      ****                     else
4434:../uvc.c      ****                     {
4435:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4436:../uvc.c      ****                     }
4437:../uvc.c      ****                     break;
4438:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4439:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4440:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4441:../uvc.c      ****                        */
4442:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4443:../uvc.c      ****                             glCommitCtrl, &readCount);
4444:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4445:../uvc.c      ****                     {
4446:../uvc.c      ****                         switch (glCommitCtrl[3])
4447:../uvc.c      ****                          {
4448:../uvc.c      ****                          	case 1: //1944
4449:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
4450:../uvc.c      ****                          		CyU3PThreadSleep(500);
4451:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4452:../uvc.c      ****                          		break;
4453:../uvc.c      ****                          	case 2: //1080
4454:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
4455:../uvc.c      ****                          		CyU3PThreadSleep(500);
4456:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4457:../uvc.c      ****                          		break;
4458:../uvc.c      ****                          	case 3: //720
4459:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
4460:../uvc.c      ****                          		CyU3PThreadSleep(500);
4461:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4462:../uvc.c      ****                          		break;
4463:../uvc.c      ****                          	case 4: //VGA
4464:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
4465:../uvc.c      ****                          		CyU3PThreadSleep(500);
4466:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4467:../uvc.c      ****                          		break;
4468:../uvc.c      ****                          	default:
4469:../uvc.c      ****                          		break;
4470:../uvc.c      ****                          }
4471:../uvc.c      ****                         setRes = glCommitCtrl[3];
4472:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4473:../uvc.c      **** 
4474:../uvc.c      **** #if 0
4475:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4476:../uvc.c      ****                         {
4477:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4478:../uvc.c      ****                         }
4479:../uvc.c      ****                         else
4480:../uvc.c      ****                         {
4481:../uvc.c      ****                             SensorScaling_VGA ();
4482:../uvc.c      ****                         }
4483:../uvc.c      **** #endif
4484:../uvc.c      ****                         /* We can start streaming video now. */
4485:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4486:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4487:../uvc.c      ****                         {
4488:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4489:../uvc.c      ****                         }
4490:../uvc.c      ****                     }
4491:../uvc.c      ****                     break;
4492:../uvc.c      **** 
4493:../uvc.c      ****                 default:
4494:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4495:../uvc.c      ****                     break;
4496:../uvc.c      ****             }
4497:../uvc.c      ****             break;
4498:../uvc.c      **** 
4499:../uvc.c      **** /* still image streaming handler */
4500:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4501:../uvc.c      ****                 switch (bRequest)
4502:../uvc.c      ****                 {
4503:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4504:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4505:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4506:../uvc.c      ****                         break;
4507:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4508:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4509:../uvc.c      ****                         glEp0Buffer[1] = 0;
4510:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4511:../uvc.c      ****                         break;
4512:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4513:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4514:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4515:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4516:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4517:../uvc.c      ****                         {
4518:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4519:../uvc.c      ****                         }
4520:../uvc.c      ****                         else
4521:../uvc.c      ****                         {
4522:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4523:../uvc.c      ****                         }
4524:../uvc.c      ****                         break;
4525:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4526:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4527:../uvc.c      ****                                 glCommitCtrl, &readCount);
4528:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4529:../uvc.c      ****                         {
4530:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4531:../uvc.c      ****                             {
4532:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4533:../uvc.c      ****                                    active data structure. */
4534:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4535:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4536:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4537:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4538:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4539:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4540:../uvc.c      ****                             }
4541:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4542:../uvc.c      ****                         }
4543:../uvc.c      ****                         break;
4544:../uvc.c      ****                     default:
4545:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4546:../uvc.c      ****                         break;
4547:../uvc.c      ****                 }
4548:../uvc.c      ****                 break;
4549:../uvc.c      **** 
4550:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4551:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4551 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4552:../uvc.c      ****                 {
4553:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4554:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4555:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4556:../uvc.c      ****                         break;
4557:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4558:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4559:../uvc.c      ****                         glEp0Buffer[1] = 0;
4560:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4561:../uvc.c      ****                         break;
4562:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4563:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4564:../uvc.c      ****                         {
4565:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4566:../uvc.c      ****                         }
4567:../uvc.c      ****                         else
4568:../uvc.c      ****                         {
4569:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4570:../uvc.c      ****                         }
4571:../uvc.c      ****                         break;
4572:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4573:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4574:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4575:../uvc.c      ****                            */
4576:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4577:../uvc.c      ****                                 glCommitCtrl, &readCount);
4578:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4579:../uvc.c      ****                         {
4580:../uvc.c      ****     #if 0
4581:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4582:../uvc.c      ****                             {
4583:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4584:../uvc.c      ****                             }
4585:../uvc.c      ****                             else
4586:../uvc.c      ****                             {
4587:../uvc.c      ****                                 SensorScaling_VGA ();
4588:../uvc.c      ****                             }
4589:../uvc.c      ****                             /* We can start streaming video now. */
4590:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4591:../uvc.c      **** 
4592:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4593:../uvc.c      ****                             {
4594:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4595:../uvc.c      ****                             }
4596:../uvc.c      **** 	#endif
4597:../uvc.c      ****                            switch (glCommitCtrl[1])
4598:../uvc.c      ****                              {
4599:../uvc.c      ****                              	case 4: //1944
4600:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
4601:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4602:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4603:../uvc.c      ****                              		break;
4604:../uvc.c      ****                              	case 3: //1080
4605:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
4606:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4607:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4608:../uvc.c      ****                              		break;
4609:../uvc.c      ****                              	case 2: //720
4610:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
4611:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4612:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4613:../uvc.c      ****                              		break;
4614:../uvc.c      ****                             	case 1: //VGA
4615:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4616:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4617:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4618:../uvc.c      ****                              		break;
4619:../uvc.c      ****                               	default:
4620:../uvc.c      ****                              		break;
4621:../uvc.c      ****                              }
4622:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4623:../uvc.c      **** 
4624:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4625:../uvc.c      **** 
4626:../uvc.c      ****                         }
4627:../uvc.c      ****                         break;
4628:../uvc.c      **** 
4629:../uvc.c      ****                     default:
4630:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4631:../uvc.c      ****                         break;
4632:../uvc.c      ****                 }
4633:../uvc.c      ****                 break;
4634:../uvc.c      **** 
4635:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4636:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4637:../uvc.c      ****             	switch (bRequest)
4638:../uvc.c      ****                 {
4639:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4640:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4640 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4641:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4641 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4642:../uvc.c      ****                         break;
4643:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4644:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4645:../uvc.c      ****                         glEp0Buffer[1] = 0;
4646:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4647:../uvc.c      ****                         break;
4648:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4649:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4650:../uvc.c      ****                         {
4651:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4652:../uvc.c      ****                         }
4653:../uvc.c      ****                         else
4654:../uvc.c      ****                         {
4655:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4656:../uvc.c      ****                         }
4657:../uvc.c      ****                         break;
4658:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4659:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4660:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4661:../uvc.c      ****                            */
4662:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4663:../uvc.c      ****                                 glCommitCtrl, &readCount);
4664:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4665:../uvc.c      ****                         {
4666:../uvc.c      ****     #if 1
4667:../uvc.c      ****                             /* We can start still streaming video now. */
4668:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4669:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4670:../uvc.c      ****                             {
4671:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4672:../uvc.c      ****                             }
4673:../uvc.c      ****     #endif
4674:../uvc.c      ****                             else{
4675:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4676:../uvc.c      ****                             //stillcont = 0;
4677:../uvc.c      ****                             }
4678:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4679:../uvc.c      ****                         }else{
4680:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4681:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4682:../uvc.c      ****                         }
4683:../uvc.c      ****                         break;
4684:../uvc.c      **** 
4685:../uvc.c      ****                     default:
4686:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4687:../uvc.c      ****                         break;
4688:../uvc.c      ****                 }
4689:../uvc.c      ****                 break;
4690:../uvc.c      **** 
4691:../uvc.c      ****         default:
4692:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4693:../uvc.c      ****             break;
4694:../uvc.c      ****     }
4695:../uvc.c      **** }
 117              		.loc 1 4695 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4352:../uvc.c      ****     {
 122              		.loc 1 4352 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4637:../uvc.c      ****                 {
 127              		.loc 1 4637 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4692:../uvc.c      ****             break;
 138              		.loc 1 4692 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4695 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4355:../uvc.c      ****             {
 151              		.loc 1 4355 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4501:../uvc.c      ****                 {
 161              		.loc 1 4501 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4558:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4558 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4645:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4645 0
 170 0124 0020A0E3 		mov	r2, #0
4646:../uvc.c      ****                         break;
 171              		.loc 1 4646 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4644:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4644 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4645:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4645 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4646:../uvc.c      ****                         break;
 178              		.loc 1 4646 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4695 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4551:../uvc.c      ****                 {
 186              		.loc 1 4551 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4576:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4576 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4578:../uvc.c      ****                         {
 201              		.loc 1 4578 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4597:../uvc.c      ****                              {
 204              		.loc 1 4597 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4501:../uvc.c      ****                 {
 217              		.loc 1 4501 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4516:../uvc.c      ****                         {
 227              		.loc 1 4516 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4518:../uvc.c      ****                         }
 229              		.loc 1 4518 0
 230 01c4 0B00A0E3 		mov	r0, #11
4516:../uvc.c      ****                         {
 231              		.loc 1 4516 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4518:../uvc.c      ****                         }
 234              		.loc 1 4518 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4522:../uvc.c      ****                         }
 236              		.loc 1 4522 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4501:../uvc.c      ****                 {
 242              		.loc 1 4501 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4526:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4526 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4528:../uvc.c      ****                         {
 254              		.loc 1 4528 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4530:../uvc.c      ****                             {
 257              		.loc 1 4530 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4534:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4534 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4535:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4535 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4534:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4534 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4535:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4535 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4541:../uvc.c      ****                         }
 272              		.loc 1 4541 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4355:../uvc.c      ****             {
 283              		.loc 1 4355 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4382:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4382 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4384:../uvc.c      ****                     {
 295              		.loc 1 4384 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4386:../uvc.c      ****                         {
 298              		.loc 1 4386 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4390:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4390 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4391:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4391 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4392:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4392 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4393:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4393 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4394:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4394 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4395:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4395 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4390:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4390 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4391:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4391 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4392:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4392 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4393:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4393 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4394:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4394 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4395:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4395 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4429:../uvc.c      ****                     {
 331              		.loc 1 4429 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4378:../uvc.c      ****                     }
 337              		.loc 1 4378 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4637:../uvc.c      ****                 {
 344              		.loc 1 4637 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4662:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4662 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4664:../uvc.c      ****                         {
 354              		.loc 1 4664 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4668:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4668 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4669:../uvc.c      ****                             {
 363              		.loc 1 4669 0
 364 030c 002050E2 		subs	r2, r0, #0
4675:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4675 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4669:../uvc.c      ****                             {
 368              		.loc 1 4669 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4678:../uvc.c      ****                         }else{
 372              		.loc 1 4678 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4417:../uvc.c      ****             {
 384              		.loc 1 4417 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4442:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4442 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4444:../uvc.c      ****                     {
 394              		.loc 1 4444 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4446:../uvc.c      ****                          {
 397              		.loc 1 4446 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4431:../uvc.c      ****                     }
 410              		.loc 1 4431 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4464:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4464 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4465:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4465 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4466:../uvc.c      ****                          		break;
 436              		.loc 1 4466 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4472:../uvc.c      **** 
 451              		.loc 1 4472 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4471:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4471 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4472:../uvc.c      **** 
 457              		.loc 1 4472 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4485:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4485 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4486:../uvc.c      ****                         {
 466              		.loc 1 4486 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4488:../uvc.c      ****                         }
 469              		.loc 1 4488 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4605:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4605 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4607:../uvc.c      ****                              		break;
 489              		.loc 1 4607 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4624:../uvc.c      **** 
 501              		.loc 1 4624 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4622:../uvc.c      **** 
 506              		.loc 1 4622 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4624:../uvc.c      **** 
 508              		.loc 1 4624 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4610:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4610 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4612:../uvc.c      ****                              		break;
 529              		.loc 1 4612 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
4617:../uvc.c      ****                              		break;
 537              		.loc 1 4617 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4618:../uvc.c      ****                               	default:
 544              		.loc 1 4618 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4615:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4615 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4617:../uvc.c      ****                              		break;
 562              		.loc 1 4617 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4459:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4459 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4460:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4460 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4461:../uvc.c      ****                          		break;
 590              		.loc 1 4461 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4454:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4454 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4455:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4455 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4456:../uvc.c      ****                          		break;
 615              		.loc 1 4456 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4457:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4457 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4449:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4449 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4450:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4450 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4451:../uvc.c      ****                          		break;
 645              		.loc 1 4451 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4452:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4452 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4600:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4600 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4602:../uvc.c      ****                              		break;
 671              		.loc 1 4602 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4603:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4603 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4644:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4644 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4370:../uvc.c      ****                     {
 691              		.loc 1 4370 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4372:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4372 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4373:../uvc.c      **** 
 701              		.loc 1 4373 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4680:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4680 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4681:../uvc.c      ****                         }
 718              		.loc 1 4681 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4671:../uvc.c      ****                             }
 727              		.loc 1 4671 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4446:../uvc.c      ****                          {
 736              		.loc 1 4446 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4696:../uvc.c      **** 
4697:../uvc.c      **** /*
4698:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4699:../uvc.c      ****  */
4700:../uvc.c      **** void
4701:../uvc.c      **** UVCAppEP0Thread_Entry (
4702:../uvc.c      ****         uint32_t input)
4703:../uvc.c      **** {
4704:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4705:../uvc.c      ****     uint32_t eventFlag;
4706:../uvc.c      **** 	CyBool_t value;
4707:../uvc.c      **** 	CyBool_t *valueptr = &value;
4708:../uvc.c      **** 
4709:../uvc.c      **** 
4710:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4711:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4712:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4713:../uvc.c      **** 
4714:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4715:../uvc.c      **** #endif
4716:../uvc.c      **** 
4717:../uvc.c      ****     /* for interrupt status test */
4718:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4719:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4720:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4721:../uvc.c      **** 
4722:../uvc.c      ****     for (;;)
4723:../uvc.c      ****     {
4724:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4725:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4726:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4727:../uvc.c      ****         {
4728:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4729:../uvc.c      ****             if (!isUsbConnected)
4730:../uvc.c      ****             {
4731:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4732:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4733:../uvc.c      ****                 {
4734:../uvc.c      ****                     isUsbConnected = CyTrue;
4735:../uvc.c      ****                 }
4736:../uvc.c      ****             }
4737:../uvc.c      **** //#ifdef DbgInfo
4738:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4739:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4740:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4741:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4742:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4743:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4744:../uvc.c      **** //#endif
4745:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4746:../uvc.c      ****             {
4747:../uvc.c      ****             	switch ((wIndex >> 8))
4748:../uvc.c      ****                 {
4749:../uvc.c      **** 
4750:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4751:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4752:../uvc.c      ****                         break;
4753:../uvc.c      **** 
4754:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4755:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4756:../uvc.c      ****                         break;
4757:../uvc.c      **** 
4758:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4759:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4760:../uvc.c      ****                         break;
4761:../uvc.c      **** 
4762:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4763:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4764:../uvc.c      ****                         break;
4765:../uvc.c      **** 
4766:../uvc.c      ****                     default:
4767:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4768:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4769:../uvc.c      ****                         break;
4770:../uvc.c      ****                 }
4771:../uvc.c      ****             }
4772:../uvc.c      **** 
4773:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4774:../uvc.c      ****             {
4775:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4776:../uvc.c      **** 
4777:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4778:../uvc.c      ****                 {
4779:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4780:../uvc.c      ****                 }
4781:../uvc.c      ****                 else
4782:../uvc.c      ****                 {
4783:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4784:../uvc.c      ****                 }
4785:../uvc.c      ****             }
4786:../uvc.c      **** 
4787:../uvc.c      ****             /* handle interrupt status event */
4788:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4789:../uvc.c      ****             {
4790:../uvc.c      **** 
4791:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4792:../uvc.c      ****             	/** preparing interrupt status data **/
4793:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4794:../uvc.c      **** 
4795:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4796:../uvc.c      **** 
4797:../uvc.c      **** #if 0 //for real button
4798:../uvc.c      **** 				if(value&&(!snapButFlag)){
4799:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4800:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4801:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4802:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4803:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4804:../uvc.c      **** 
4805:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4806:../uvc.c      **** 					interStabuf.size   = 1024;
4807:../uvc.c      **** 					interStabuf.status = 0;
4808:../uvc.c      **** 
4809:../uvc.c      **** 					interStabuf.count = 4;
4810:../uvc.c      **** 
4811:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4812:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4813:../uvc.c      **** 
4814:../uvc.c      **** 					/** send a interrupt status data **/
4815:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4816:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4817:../uvc.c      **** 					{
4818:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4819:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4820:../uvc.c      **** 					}
4821:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4822:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4823:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4824:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4825:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4826:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4827:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4828:../uvc.c      **** 
4829:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4830:../uvc.c      **** 					interStabuf.size   = 1024;
4831:../uvc.c      **** 					interStabuf.status = 0;
4832:../uvc.c      **** 
4833:../uvc.c      **** 					interStabuf.count = 4;
4834:../uvc.c      **** 
4835:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4836:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4837:../uvc.c      **** 
4838:../uvc.c      **** 					/** send a interrupt status data **/
4839:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4840:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4841:../uvc.c      **** 					{
4842:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4843:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4844:../uvc.c      **** 					}
4845:../uvc.c      **** 
4846:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4847:../uvc.c      **** 					stiflag = 0xFF;
4848:../uvc.c      **** 				}
4849:../uvc.c      **** #else			//for botton simulation
4850:../uvc.c      **** 				if(snapButFlag == 0x0f){
4851:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4852:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4853:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4854:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4855:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4856:../uvc.c      **** 
4857:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4858:../uvc.c      **** 					interStabuf.size   = 1024;
4859:../uvc.c      **** 					interStabuf.status = 0;
4860:../uvc.c      **** 
4861:../uvc.c      **** 					interStabuf.count = 4;
4862:../uvc.c      **** 
4863:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4864:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4865:../uvc.c      **** 
4866:../uvc.c      **** 					/** send a interrupt status data **/
4867:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4868:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4869:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4870:../uvc.c      **** 					{
4871:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4872:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4873:../uvc.c      **** 					}
4874:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4875:../uvc.c      **** 
4876:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4877:../uvc.c      **** 				}else if(!snapButFlag){
4878:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4879:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4880:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4881:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4882:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4883:../uvc.c      **** 
4884:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4885:../uvc.c      **** 					interStabuf.size   = 1024;
4886:../uvc.c      **** 					interStabuf.status = 0;
4887:../uvc.c      **** 
4888:../uvc.c      **** 					interStabuf.count = 4;
4889:../uvc.c      **** 
4890:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4891:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4892:../uvc.c      **** 
4893:../uvc.c      **** 					/** send a interrupt status data **/
4894:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4895:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4896:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4897:../uvc.c      **** 					{
4898:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4899:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4900:../uvc.c      **** 					}
4901:../uvc.c      **** 
4902:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4903:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4904:../uvc.c      **** 				}
4905:../uvc.c      **** #endif
4906:../uvc.c      **** 
4907:../uvc.c      ****             }
4908:../uvc.c      **** 
4909:../uvc.c      **** 
4910:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4911:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4912:../uvc.c      ****             {
4913:../uvc.c      ****                 /* Get the command buffer */
4914:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4915:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4916:../uvc.c      ****                 {
4917:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4918:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4919:../uvc.c      ****                 }
4920:../uvc.c      **** 
4921:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4922:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4923:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4924:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4925:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4926:../uvc.c      ****                  * register value high byte and register value low byte.
4927:../uvc.c      ****                  */
4928:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4929:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4930:../uvc.c      ****                 {
4931:../uvc.c      ****                     if (dmaInfo.count == 3)
4932:../uvc.c      ****                     {
4933:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4934:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4935:../uvc.c      ****                         dmaInfo.count = 3;
4936:../uvc.c      ****                     }
4937:../uvc.c      ****                     else if (dmaInfo.count == 4)
4938:../uvc.c      ****                     {
4939:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4940:../uvc.c      ****                         {
4941:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4942:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4943:../uvc.c      ****                         }
4944:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4945:../uvc.c      ****                     }
4946:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4947:../uvc.c      ****                 }
4948:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4949:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4950:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4951:../uvc.c      ****                  */
4952:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4953:../uvc.c      ****                 {
4954:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4955:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4956:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4957:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4958:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4959:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4960:../uvc.c      ****                         	break;
4961:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4962:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4963:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4964:../uvc.c      ****                         	break;*/
4965:../uvc.c      ****                     dmaInfo.count -= 2;
4966:../uvc.c      ****                 }
4967:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4968:../uvc.c      ****                 else
4969:../uvc.c      ****                 {
4970:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4971:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4972:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4973:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4974:../uvc.c      ****                 }
4975:../uvc.c      **** 
4976:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4977:../uvc.c      ****                 dmaInfo.size   = 1024;
4978:../uvc.c      ****                 dmaInfo.status = 0;
4979:../uvc.c      **** 
4980:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4981:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4982:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4983:../uvc.c      ****                 {
4984:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4985:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4986:../uvc.c      ****                 }
4987:../uvc.c      **** 
4988:../uvc.c      ****                 /* Wait until the response has gone out. */
4989:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4990:../uvc.c      **** 
4991:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4992:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4993:../uvc.c      ****                 {
4994:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4995:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4996:../uvc.c      ****                 }
4997:../uvc.c      ****             }
4998:../uvc.c      **** #endif
4999:../uvc.c      ****         }
5000:../uvc.c      ****         /* Allow other ready threads to run. */
5001:../uvc.c      ****         CyU3PThreadRelinquish ();
5002:../uvc.c      ****     }
5003:../uvc.c      **** }
5004:../uvc.c      **** 
5005:../uvc.c      **** /*
5006:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5007:../uvc.c      ****  * added 10/2013
5008:../uvc.c      ****  */
5009:../uvc.c      **** /*
5010:../uvc.c      **** static uint8_t timeDelay[64] = {
5011:../uvc.c      **** 
5012:../uvc.c      **** };
5013:../uvc.c      **** */
5014:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5014 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5015:../uvc.c      **** 
5016:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5017:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5018:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5019:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5020:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5021:../uvc.c      **** 	uint32_t flag = 0;
5022:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5023:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5024:../uvc.c      **** 	uint8_t i;
5025:../uvc.c      **** 	uint16_t delaytime;
5026:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5027:../uvc.c      **** 
5028:../uvc.c      **** #if 0 //for test the command queue
5029:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5030:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5031:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5032:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5033:../uvc.c      **** 		lcCmdDes += 1;
5034:../uvc.c      **** 	}
5035:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5036:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5037:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5038:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5039:../uvc.c      **** 		lcCmdDes += 1;
5040:../uvc.c      **** 	}
5041:../uvc.c      **** 
5042:../uvc.c      **** #endif
5043:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5044:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5044 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5014:../uvc.c      **** 
 786              		.loc 1 5014 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5021:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5021 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5044 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5021:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5021 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5044 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5045:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5045 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5046:../uvc.c      **** 	CyU3PThreadSleep(50);
5047:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5048:../uvc.c      **** 
5049:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5049 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5045:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5045 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5046:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5046 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5047:../uvc.c      **** 
 823              		.loc 1 5047 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5049 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5050:../uvc.c      ****         /* Allow other ready threads to run. */
5051:../uvc.c      **** 
5052:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5052 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5049:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5049 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5053:../uvc.c      **** 	}
5054:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5054 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5055:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5056:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5057:../uvc.c      **** 	//CyU3PThreadSleep(100);
5058:../uvc.c      **** 	//SetCurCmd();
5059:../uvc.c      **** 	/*********** the loop of the thread ***********/
5060:../uvc.c      **** 	for(;;){
5061:../uvc.c      **** 
5062:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5062 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5063:../uvc.c      **** /*  // for test GPIO output
5064:../uvc.c      **** 		if(trigger)
5065:../uvc.c      **** 		{
5066:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5067:../uvc.c      **** 			{
5068:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5069:../uvc.c      **** 			}
5070:../uvc.c      **** 
5071:../uvc.c      **** 		}else{
5072:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5073:../uvc.c      **** 			{
5074:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5075:../uvc.c      **** 			}
5076:../uvc.c      **** 
5077:../uvc.c      **** 		}
5078:../uvc.c      **** */
5079:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5079 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5080:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5081:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5082:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5083:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5084:../uvc.c      **** 				i = 0;
5085:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5085 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5086:../uvc.c      **** 					i++;
5087:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5088:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5089:../uvc.c      **** 				}
5090:../uvc.c      **** #if 0
5091:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5092:../uvc.c      **** 				i = lcStaDes->curNum;
5093:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5094:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5095:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5096:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5097:../uvc.c      **** 
5098:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5099:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5100:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5101:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5102:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5103:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5104:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5105:../uvc.c      **** #endif
5106:../uvc.c      **** 				//}
5107:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5108:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5109:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5110:../uvc.c      **** 				/* setting delay */
5111:../uvc.c      **** 				delaytime = 300;
5112:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5113:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5114:../uvc.c      **** 			} //end of the if condition statment
5115:../uvc.c      **** #endif
5116:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5116 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5117:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5118:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5118 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5119:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5119 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5120:../uvc.c      **** 
5121:../uvc.c      **** 				/*
5122:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5123:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5124:../uvc.c      **** 				*/
5125:../uvc.c      **** 
5126:../uvc.c      **** 				/* find a available command */
5127:../uvc.c      **** 				i = 0;
5128:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5128 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5128 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5129:../uvc.c      **** 					i++;
5130:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5130 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5128:../uvc.c      **** 					i++;
 905              		.loc 1 5128 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5131:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5132:../uvc.c      **** 				}
5133:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5134:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5135:../uvc.c      **** 					i = lcCmdDes->curNum;
5136:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5137:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5138:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5139:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5140:../uvc.c      **** #if 1
5141:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5141 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5136:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5136 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5137:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5137 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5138:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5138 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5139:../uvc.c      **** #if 1
 927              		.loc 1 5139 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5141 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5142:../uvc.c      **** 						case 0x20:
5143:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5144:../uvc.c      **** 							delaytime = 500;
5145:../uvc.c      **** 							break;
5146:../uvc.c      **** 						case 0x21:
5147:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5148:../uvc.c      **** 							delaytime = 500;
5149:../uvc.c      **** 							break;
5150:../uvc.c      **** 						case 0x22:
5151:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5152:../uvc.c      **** 							delaytime = 300;
5153:../uvc.c      **** 							break;
5154:../uvc.c      **** 						case 0x23:
5155:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5155 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5156:../uvc.c      **** 							delaytime = 300;
5157:../uvc.c      **** 							break;
 945              		.loc 1 5157 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5158:../uvc.c      **** 						default:
5159:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5160:../uvc.c      **** 							break;
5161:../uvc.c      **** 					}
5162:../uvc.c      **** #endif
5163:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5164:../uvc.c      **** 					/** timer's ticket modify **/
5165:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5166:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5166 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5167:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5167 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5168:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5169:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5170:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5171:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5172:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5173:../uvc.c      **** #endif
5174:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5174 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5175:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5176:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5177:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5178:../uvc.c      **** 						}else{
5179:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5180:../uvc.c      **** 						}
5181:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5182:../uvc.c      **** 					}else{
5183:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5183 0
 964 08d4 013083E2 		add	r3, r3, #1
5184:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5184 0
 966 08d8 0F20A0E3 		mov	r2, #15
5183:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5183 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5184 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5185:../uvc.c      **** 					}
5186:../uvc.c      **** 				}else{
5187:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5188:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5189:../uvc.c      **** 				}
5190:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5190 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5191:../uvc.c      **** 			}
5192:../uvc.c      **** /*
5193:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5194:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5195:../uvc.c      **** */
5196:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5197:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5198:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5199:../uvc.c      **** #endif
5200:../uvc.c      **** 
5201:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5202:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5203:../uvc.c      **** #if 0
5204:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5205:../uvc.c      **** 
5206:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5207:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5208:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5209:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5210:../uvc.c      **** 			    i = 0;
5211:../uvc.c      **** 				 switch(cmdCopyIdx)
5212:../uvc.c      **** 				 {
5213:../uvc.c      **** 					 case BrgtCtlID1:
5214:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5215:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5216:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5217:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5218:../uvc.c      **** 							 i++;
5219:../uvc.c      **** 						 }
5220:../uvc.c      **** 						 else{
5221:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5222:../uvc.c      **** 						 }
5223:../uvc.c      **** 
5224:../uvc.c      **** 						 CyU3PBusyWait(500);
5225:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5226:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5227:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5228:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5229:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5230:../uvc.c      **** 						 }
5231:../uvc.c      **** 						 else{
5232:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5233:../uvc.c      **** 						 }
5234:../uvc.c      **** 						 break;
5235:../uvc.c      **** 					 case HueCtlID5:
5236:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5237:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5238:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5239:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5240:../uvc.c      **** 						 }
5241:../uvc.c      **** 						 else{
5242:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5243:../uvc.c      **** 						 }
5244:../uvc.c      **** 						 break;
5245:../uvc.c      **** 					 case SaturCtlID6:
5246:../uvc.c      **** 					 case WBTLevCtlID10:
5247:../uvc.c      **** 					 default:
5248:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5249:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5250:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5251:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5252:../uvc.c      **** 						 }
5253:../uvc.c      **** 						 else{
5254:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5255:../uvc.c      **** 						 }
5256:../uvc.c      **** 						 break;
5257:../uvc.c      **** 				 }
5258:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5259:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5260:../uvc.c      **** 			}
5261:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5262:../uvc.c      **** #endif
5263:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5264:../uvc.c      **** 		/* Allow other ready threads to run. */
5265:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5266:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5266 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5267:../uvc.c      **** 		}
 980              		.loc 1 5267 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5147:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5147 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5149:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5149 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5143:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5143 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5145:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5145 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5187:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5187 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5188:../uvc.c      **** 				}
 1010              		.loc 1 5188 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5176:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5176 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5175:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5175 0
 1020 0934 0020A0E3 		mov	r2, #0
5176:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5176 0
 1022 0938 230053E3 		cmp	r3, #35
5177:../uvc.c      **** 						}else{
 1023              		.loc 1 5177 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5179:../uvc.c      **** 						}
 1026              		.loc 1 5179 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5177:../uvc.c      **** 						}else{
 1028              		.loc 1 5177 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5179:../uvc.c      **** 						}
 1030              		.loc 1 5179 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5177:../uvc.c      **** 						}else{
 1032              		.loc 1 5177 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5179:../uvc.c      **** 						}
 1034              		.loc 1 5179 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5181:../uvc.c      **** 					}else{
 1036              		.loc 1 5181 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5175:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5175 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5181:../uvc.c      **** 					}else{
 1040              		.loc 1 5181 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5159:../uvc.c      **** 							break;
 1045              		.loc 1 5159 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5160:../uvc.c      **** 					}
 1049              		.loc 1 5160 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2845:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2845 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2852:../uvc.c      ****     {
 1075              		.loc 1 2852 0
 1076 0994 080051E3 		cmp	r1, #8
2845:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2845 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2852:../uvc.c      ****     {
 1089              		.loc 1 2852 0
 1090 09a4 0B00000A 		beq	.L174
2904:../uvc.c      ****     {
 1091              		.loc 1 2904 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2906:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2906 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2907:../uvc.c      ****     }
 1096              		.loc 1 2907 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2906:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2906 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2907:../uvc.c      ****     }
 1102              		.loc 1 2907 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2906:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2906 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2909:../uvc.c      **** 
 1111              		.loc 1 2909 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2854:../uvc.c      ****             {
 1117              		.loc 1 2854 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2868:../uvc.c      ****                 fb++;
 1121              		.loc 1 2868 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2854:../uvc.c      ****             {
 1123              		.loc 1 2854 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2592:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2592 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2854:../uvc.c      ****             {
 1132              		.loc 1 2854 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2592:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2592 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2593:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2593 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2594:../uvc.c      **** 
 1147              		.loc 1 2594 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2599:../uvc.c      ****     }
 1151              		.loc 1 2599 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2875:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2875 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2599:../uvc.c      ****     }
 1159              		.loc 1 2599 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2881:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2881 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2875:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2875 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2876:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2876 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2875:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2875 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2881:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2881 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2875:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2875 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2876:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2876 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2593:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2593 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2881:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2881 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2888:../uvc.c      ****             }
 1187              		.loc 1 2888 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2892 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2893:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2893 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2892 0
 1196 0a54 013082E2 		add	r3, r2, #1
2893:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2893 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2892 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2893:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2893 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2892 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2893:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2893 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2892 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2893:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2893 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2892:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2892 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2896:../uvc.c      ****             {
 1215              		.loc 1 2896 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2898:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2898 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2899:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2899 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2898:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2898 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2899:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2899 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2592:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2592 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2869:../uvc.c      ****             }
 1246              		.loc 1 2869 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2592:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2592 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2868:../uvc.c      ****                 fb++;
 1255              		.loc 1 2868 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2593:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2593 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2594:../uvc.c      **** 
 1266              		.loc 1 2594 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2869:../uvc.c      ****             }
 1272              		.loc 1 2869 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2882:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2882 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2883:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2883 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2884:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2884 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2883:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2883 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2884:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2884 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2885:../uvc.c      ****                 }
 1295              		.loc 1 2885 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2648:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2648 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2649:../uvc.c      ****     {
 1322              		.loc 1 2649 0
 1323 0b40 020050E3 		cmp	r0, #2
2648:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2648 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2649:../uvc.c      ****     {
 1336              		.loc 1 2649 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2685:../uvc.c      **** 
 1344              		.loc 1 2685 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2668:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2668 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2670:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2670 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2668:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2668 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2669:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2669 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2670:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2670 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2632:../uvc.c      **** 	{
 1372              		.loc 1 2632 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2670:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2670 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2671:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2671 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2672:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2672 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2632:../uvc.c      **** 	{
 1388              		.loc 1 2632 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2635:../uvc.c      **** 
 1395              		.loc 1 2635 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2638:../uvc.c      **** 	}
 1401              		.loc 1 2638 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2652:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2652 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2654:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2654 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2653:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2653 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2654:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2654 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2632:../uvc.c      **** 	{
 1433              		.loc 1 2632 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2654:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2654 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2655:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2655 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2632:../uvc.c      **** 	{
 1447              		.loc 1 2632 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2635:../uvc.c      **** 
 1454              		.loc 1 2635 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2638:../uvc.c      **** 	}
 1460              		.loc 1 2638 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2660:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2660 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2662:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2662 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2660:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2660 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2661:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2661 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2662:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2662 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2632:../uvc.c      **** 	{
 1493              		.loc 1 2632 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2662:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2662 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2663:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2663 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2632:../uvc.c      **** 	{
 1507              		.loc 1 2632 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2635:../uvc.c      **** 
 1514              		.loc 1 2635 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2638:../uvc.c      **** 	}
 1520              		.loc 1 2638 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2693:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2693 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2702:../uvc.c      **** 
 1560              		.loc 1 2702 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2699:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2699 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2701:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2701 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2698:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2698 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2700:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2700 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2701:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2701 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2698:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2698 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2699:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2699 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2701:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2701 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2702:../uvc.c      **** 
 1579              		.loc 1 2702 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2700:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2700 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2705:../uvc.c      ****     {
 1584              		.loc 1 2705 0
 1585 0d00 020054E3 		cmp	r4, #2
2693:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2693 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2699:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2699 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2701:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2701 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2702:../uvc.c      **** 
 1594              		.loc 1 2702 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2698:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2698 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2700:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2700 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2705:../uvc.c      ****     {
 1600              		.loc 1 2705 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2694:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2694 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2832:../uvc.c      **** 
 1612              		.loc 1 2832 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2705:../uvc.c      ****     {
 1618              		.loc 1 2705 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2745:../uvc.c      ****             {
 1621              		.loc 1 2745 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2749:../uvc.c      ****                 {
 1624              		.loc 1 2749 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2749:../uvc.c      ****                 {
 1627              		.loc 1 2749 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2754:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2754 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2752:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2752 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2753:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2753 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2757:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2757 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2754:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2754 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2755:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2755 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2757:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2757 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2758:../uvc.c      **** 
 1652              		.loc 1 2758 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2761:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2761 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2762:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2762 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2763:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2763 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2764:../uvc.c      **** 
 1669              		.loc 1 2764 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2767:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2767 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2770:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2770 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2632:../uvc.c      **** 	{
 1684              		.loc 1 2632 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2772:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2772 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2632:../uvc.c      **** 	{
 1696              		.loc 1 2632 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2635:../uvc.c      **** 
 1703              		.loc 1 2635 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2638:../uvc.c      **** 	}
 1709              		.loc 1 2638 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2710:../uvc.c      ****             {
 1722              		.loc 1 2710 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2728:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2728 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2730:../uvc.c      ****                         {
 1736              		.loc 1 2730 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2714:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2714 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2832:../uvc.c      **** 
 1744              		.loc 1 2832 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2780:../uvc.c      ****             {
 1750              		.loc 1 2780 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2782:../uvc.c      ****                 {
 1753              		.loc 1 2782 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2788:../uvc.c      ****                     {
 1756              		.loc 1 2788 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2820:../uvc.c      ****                     }
 1762              		.loc 1 2820 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2819:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2819 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2715:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2715 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2717:../uvc.c      ****                         {
 1777              		.loc 1 2717 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2719:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2719 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2720:../uvc.c      ****                         }
 1786              		.loc 1 2720 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2733:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2733 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2734:../uvc.c      ****                         }
 1801              		.loc 1 2734 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2727:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2727 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2790:../uvc.c      **** 
 1812              		.loc 1 2790 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2793:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2793 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2794:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2794 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2798:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2798 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2794:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2794 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2795:../uvc.c      **** 
 1829              		.loc 1 2795 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2798:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2798 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2799:../uvc.c      **** 
 1834              		.loc 1 2799 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2802:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2802 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2803:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2803 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2804:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2804 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2805:../uvc.c      **** 
 1851              		.loc 1 2805 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2808:../uvc.c      **** 
 1855              		.loc 1 2808 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2812:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2812 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2632:../uvc.c      **** 	{
 1866              		.loc 1 2632 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2814:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2814 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2632:../uvc.c      **** 	{
 1878              		.loc 1 2632 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2635:../uvc.c      **** 
 1885              		.loc 1 2635 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2638:../uvc.c      **** 	}
 1891              		.loc 1 2638 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1205:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1205 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1208 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1205:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1205 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1213 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1208 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1209:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1209 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1210:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1210 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1213 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1216:../uvc.c      **** 	{
 1980              		.loc 1 1216 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1226:../uvc.c      **** 	{
 1985              		.loc 1 1226 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1251:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1251 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1270:../uvc.c      **** 
 1993              		.loc 1 1270 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1253 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1258 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1258 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1263:../uvc.c      **** 			}
 2018              		.loc 1 1263 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1270:../uvc.c      **** 
 2025              		.loc 1 1270 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1242 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1228:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1228 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1242 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1228:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1228 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1242 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1243 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1244:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1244 0
 2051 10c4 020056E3 		cmp	r6, #2
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1243 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1245:../uvc.c      **** 				}
 2054              		.loc 1 1245 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1228:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1228 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1245:../uvc.c      **** 				}
 2058              		.loc 1 1245 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1247:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1247 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1270:../uvc.c      **** 
 2063              		.loc 1 1270 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1216:../uvc.c      **** 	{
 2069              		.loc 1 1216 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1218:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1218 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1219:../uvc.c      **** 			{
 2081              		.loc 1 1219 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1223:../uvc.c      **** 
 2083              		.loc 1 1223 0
 2084 1114 0400A0E3 		mov	r0, #4
1219:../uvc.c      **** 			{
 2085              		.loc 1 1219 0
 2086 1118 000051E3 		cmp	r1, #0
1221:../uvc.c      **** 			}
 2087              		.loc 1 1221 0
 2088 111c 80208203 		orreq	r2, r2, #128
1223:../uvc.c      **** 
 2089              		.loc 1 1223 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1221:../uvc.c      **** 			}
 2092              		.loc 1 1221 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1223:../uvc.c      **** 
 2094              		.loc 1 1223 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1253 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1255:../uvc.c      **** 			}
 2103              		.loc 1 1255 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1254:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1254 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1258 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1259:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1259 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1260:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1260 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1261:../uvc.c      **** 				}
 2142              		.loc 1 1261 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1276 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1276 0
 2180 11d8 0040A0E1 		mov	r4, r0
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1279 0
 2182 11dc 0060A0E3 		mov	r6, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1278 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1279 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1280 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1281:../uvc.c      **** }
 2213              		.loc 1 1281 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1282:../uvc.c      **** 
 2215              		.loc 1 1282 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1281:../uvc.c      **** }
 2220              		.loc 1 1281 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1286 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1291:../uvc.c      **** 	case 1:
 2236              		.loc 1 1291 0
 2237 1248 013040E2 		sub	r3, r0, #1
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1286 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1291:../uvc.c      **** 	case 1:
 2249              		.loc 1 1291 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1313:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1313 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1315:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1315 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1316:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1316 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1315:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1315 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1316:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1316 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1318:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1318 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1321 0
 2298 12d8 0150A0E3 		mov	r5, #1
1322:../uvc.c      **** 		break;
 2299              		.loc 1 1322 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1321 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1322:../uvc.c      **** 		break;
 2305              		.loc 1 1322 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1331:../uvc.c      **** 
 2310              		.loc 1 1331 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1297:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1297 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1299:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1299 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1300:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1300 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1299:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1299 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1300:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1300 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1327:../uvc.c      **** 		break;
 2345              		.loc 1 1327 0
 2346 133c 0140A0E3 		mov	r4, #1
1326:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1326 0
 2348 1340 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 
 2349              		.loc 1 1331 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1326:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1326 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1331:../uvc.c      **** 
 2355              		.loc 1 1331 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1333 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 32
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1341 0
 2399 137c C07F9FE5 		ldr	r7, .L452+52
1340:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1340 0
 2401 1380 0F0050E3 		cmp	r0, #15
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1341 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1348 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1333 0
 2408 1390 3CD04DE2 		sub	sp, sp, #60
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 96
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1348 0
 2412 1394 00C0D3E5 		ldrb	ip, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1349 0
 2414 1398 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1350 0
 2416 139c 0FB0D3E5 		ldrb	fp, [r3, #15]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1351 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 2419              		.loc 1 1359 0
 2420 13a4 643F9FE5 		ldr	r3, .L452
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2421              		.loc 1 1349 0
 2422 13a8 FF2002E2 		and	r2, r2, #255
1359:../uvc.c      ****     /*
 2423              		.loc 1 1359 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2425              		.loc 1 1333 0
 2426 13b0 0050A0E1 		mov	r5, r0
1367:../uvc.c      **** 		 {
 2427              		.loc 1 1367 0
 2428 13b4 830056E3 		cmp	r6, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2429              		.loc 1 1348 0
 2430 13b8 FFC00CE2 		and	ip, ip, #255
 2431              	.LVL269:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2432              		.loc 1 1349 0
 2433 13bc 20208DE5 		str	r2, [sp, #32]
 2434              	.LVL270:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2435              		.loc 1 1350 0
 2436 13c0 FFB00BE2 		and	fp, fp, #255
 2437              	.LVL271:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2438              		.loc 1 1351 0
 2439 13c4 FF8008E2 		and	r8, r8, #255
 2440              	.LVL272:
1367:../uvc.c      **** 		 {
 2441              		.loc 1 1367 0
 2442 13c8 B100000A 		beq	.L275
 2443 13cc 1500009A 		bls	.L435
 2444 13d0 850056E3 		cmp	r6, #133
 2445 13d4 A200000A 		beq	.L280
 2446 13d8 BC00003A 		bcc	.L281
 2447 13dc 860056E3 		cmp	r6, #134
 2448 13e0 6500000A 		beq	.L282
 2449 13e4 870056E3 		cmp	r6, #135
 2450 13e8 9400001A 		bne	.L274
1788:../uvc.c      **** 		 		 if(Len == 2){
 2451              		.loc 1 1788 0
 2452 13ec 0F0050E3 		cmp	r0, #15
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2453              		.loc 1 1790 0
 2454 13f0 005187E0 		add	r5, r7, r0, asl #2
1788:../uvc.c      **** 		 		 if(Len == 2){
 2455              		.loc 1 1788 0
 2456 13f4 C300009A 		bls	.L328
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2457              		.loc 1 1789 0
 2458 13f8 020058E3 		cmp	r8, #2
 2459 13fc 0701000A 		beq	.L436
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2460              		.loc 1 1795 0
 2461 1400 202015E5 		ldr	r2, [r5, #-32]
 2462 1404 4C4F9FE5 		ldr	r4, .L452+72
 2463 1408 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2464              		.loc 1 1796 0
 2465 140c 0030A0E3 		mov	r3, #0
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2466              		.loc 1 1795 0
 2467 1410 2810C4E5 		strb	r1, [r4, #40]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2468              		.loc 1 1796 0
 2469 1414 2930C4E5 		strb	r3, [r4, #41]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2470              		.loc 1 1797 0
 2471 1418 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2472              		.loc 1 1798 0
 2473 141c 2B30C4E5 		strb	r3, [r4, #43]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2474              		.loc 1 1797 0
 2475 1420 2A20C4E5 		strb	r2, [r4, #42]
 2476 1424 E60000EA 		b	.L331
 2477              	.L435:
1367:../uvc.c      **** 		 {
 2478              		.loc 1 1367 0
 2479 1428 810056E3 		cmp	r6, #129
 2480 142c 6D00000A 		beq	.L277
 2481 1430 4200008A 		bhi	.L278
 2482 1434 010056E3 		cmp	r6, #1
 2483 1438 8000001A 		bne	.L274
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2484              		.loc 1 1824 0
 2485 143c 144F9FE5 		ldr	r4, .L452+72
 2486 1440 36208DE2 		add	r2, sp, #54
 2487 1444 2000A0E3 		mov	r0, #32
 2488              	.LVL273:
 2489 1448 281084E2 		add	r1, r4, #40
 2490 144c 18C08DE5 		str	ip, [sp, #24]
 2491 1450 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2492              	.LVL274:
1826:../uvc.c      **** 			   {
 2493              		.loc 1 1826 0
 2494 1454 18C09DE5 		ldr	ip, [sp, #24]
 2495 1458 002050E2 		subs	r2, r0, #0
 2496 145c 1204001A 		bne	.L333
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2497              		.loc 1 1828 0
 2498 1460 020058E3 		cmp	r8, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2499              		.loc 1 1829 0
 2500 1464 2810D405 		ldreqb	r1, [r4, #40]	@ zero_extendqisi2
1830:../uvc.c      **** 				 }else{
 2501              		.loc 1 1830 0
 2502 1468 2920D405 		ldreqb	r2, [r4, #41]	@ zero_extendqisi2
1832:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2503              		.loc 1 1832 0
 2504 146c 2830D415 		ldrneb	r3, [r4, #40]	@ zero_extendqisi2
1833:../uvc.c      **** 				 }
 2505              		.loc 1 1833 0
 2506 1470 2A10D415 		ldrneb	r1, [r4, #42]	@ zero_extendqisi2
 2507 1474 0130A001 		moveq	r3, r1
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2508              		.loc 1 1829 0
 2509 1478 24108D05 		streq	r1, [sp, #36]
 2510              	.LVL275:
1830:../uvc.c      **** 				 }else{
 2511              		.loc 1 1830 0
 2512 147c 28208D05 		streq	r2, [sp, #40]
 2513              	.LVL276:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2514              		.loc 1 1836 0
 2515 1480 20209DE5 		ldr	r2, [sp, #32]
 2516 1484 28109D05 		ldreq	r1, [sp, #40]
1832:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2517              		.loc 1 1832 0
 2518 1488 24308D15 		strne	r3, [sp, #36]
 2519              	.LVL277:
1833:../uvc.c      **** 				 }
 2520              		.loc 1 1833 0
 2521 148c 28108D15 		strne	r1, [sp, #40]
 2522              	.LVL278:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2523              		.loc 1 1836 0
 2524 1490 04088DE8 		stmia	sp, {r2, fp}
 2525 1494 0C308DE5 		str	r3, [sp, #12]
 2526 1498 10108DE5 		str	r1, [sp, #16]
 2527 149c 0C30A0E1 		mov	r3, ip
 2528 14a0 08808DE5 		str	r8, [sp, #8]
 2529 14a4 0400A0E3 		mov	r0, #4
 2530              	.LVL279:
 2531 14a8 641E9FE5 		ldr	r1, .L452+4
 2532 14ac 0520A0E1 		mov	r2, r5
 2533 14b0 18C08DE5 		str	ip, [sp, #24]
 2534 14b4 FEFFFFEB 		bl	CyU3PDebugPrint
 2535              	.LVL280:
1838:../uvc.c      **** 					 switch(CtrlID)
 2536              		.loc 1 1838 0
 2537 14b8 0F0055E3 		cmp	r5, #15
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2538              		.loc 1 1836 0
 2539 14bc 24909DE5 		ldr	r9, [sp, #36]
 2540 14c0 28A09DE5 		ldr	r10, [sp, #40]
1838:../uvc.c      **** 					 switch(CtrlID)
 2541              		.loc 1 1838 0
 2542 14c4 18C09DE5 		ldr	ip, [sp, #24]
 2543 14c8 C500009A 		bls	.L336
1839:../uvc.c      **** 					 {
 2544              		.loc 1 1839 0
 2545 14cc 104045E2 		sub	r4, r5, #16
 2546 14d0 180054E3 		cmp	r4, #24
 2547 14d4 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2548 14d8 F00300EA 		b	.L337
 2549              	.L339:
 2550 14dc 78220000 		.word	.L338
 2551 14e0 A0240000 		.word	.L337
 2552 14e4 A0240000 		.word	.L337
 2553 14e8 A0240000 		.word	.L337
 2554 14ec A0240000 		.word	.L337
 2555 14f0 A0240000 		.word	.L337
 2556 14f4 A0240000 		.word	.L337
 2557 14f8 A0240000 		.word	.L337
 2558 14fc A0240000 		.word	.L337
 2559 1500 5C230000 		.word	.L340
 2560 1504 A0240000 		.word	.L337
 2561 1508 40210000 		.word	.L341
 2562 150c 881F0000 		.word	.L398
 2563 1510 A0240000 		.word	.L337
 2564 1514 941F0000 		.word	.L342
 2565 1518 50220000 		.word	.L343
 2566 151c A0240000 		.word	.L337
 2567 1520 A0240000 		.word	.L337
 2568 1524 A0240000 		.word	.L337
 2569 1528 A0240000 		.word	.L337
 2570 152c C4210000 		.word	.L344
 2571 1530 A0240000 		.word	.L337
 2572 1534 E4200000 		.word	.L345
 2573 1538 A0240000 		.word	.L337
 2574 153c 00200000 		.word	.L346
 2575              	.LVL281:
 2576              	.L278:
1679:../uvc.c      **** 		 		 if(Len == 2){
 2577              		.loc 1 1679 0
 2578 1540 0F0050E3 		cmp	r0, #15
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2579              		.loc 1 1681 0
 2580 1544 005187E0 		add	r5, r7, r0, asl #2
1679:../uvc.c      **** 		 		 if(Len == 2){
 2581              		.loc 1 1679 0
 2582 1548 8800009A 		bls	.L314
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2583              		.loc 1 1680 0
 2584 154c 020058E3 		cmp	r8, #2
 2585 1550 CB00000A 		beq	.L437
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2586              		.loc 1 1686 0
 2587 1554 202015E5 		ldr	r2, [r5, #-32]
 2588 1558 F84D9FE5 		ldr	r4, .L452+72
 2589 155c 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1687:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2590              		.loc 1 1687 0
 2591 1560 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2592              		.loc 1 1686 0
 2593 1564 2810C4E5 		strb	r1, [r4, #40]
1687:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2594              		.loc 1 1687 0
 2595 1568 2930C4E5 		strb	r3, [r4, #41]
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2596              		.loc 1 1688 0
 2597 156c 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1689:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2598              		.loc 1 1689 0
 2599 1570 2B30C4E5 		strb	r3, [r4, #43]
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2600              		.loc 1 1688 0
 2601 1574 2A20C4E5 		strb	r2, [r4, #42]
 2602 1578 910000EA 		b	.L331
 2603              	.L282:
 2604              	.LVL282:
1769:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2605              		.loc 1 1769 0
 2606 157c 0F0050E3 		cmp	r0, #15
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2607              		.loc 1 1770 0
 2608 1580 005187E0 		add	r5, r7, r0, asl #2
 2609 1584 20301585 		ldrhi	r3, [r5, #-32]
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2610              		.loc 1 1776 0
 2611 1588 20319595 		ldrls	r3, [r5, #288]
 2612 158c C44D9FE5 		ldr	r4, .L452+72
 2613 1590 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2614              		.loc 1 1782 0
 2615 1594 0100A0E3 		mov	r0, #1
 2616              	.LVL283:
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2617              		.loc 1 1777 0
 2618 1598 0030A0E3 		mov	r3, #0
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2619              		.loc 1 1776 0
 2620 159c 2820C4E5 		strb	r2, [r4, #40]
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2621              		.loc 1 1777 0
 2622 15a0 2930C4E5 		strb	r3, [r4, #41]
1778:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2623              		.loc 1 1778 0
 2624 15a4 2A30C4E5 		strb	r3, [r4, #42]
1779:../uvc.c      **** 		 	 }
 2625              		.loc 1 1779 0
 2626 15a8 2B30C4E5 		strb	r3, [r4, #43]
 2627              	.LVL284:
 2628              	.L428:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2629              		.loc 1 1814 0
 2630 15ac 641D9FE5 		ldr	r1, .L452+8
 2631 15b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2632              	.LVL285:
 2633 15b4 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2634              	.LVL286:
 2635 15b8 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2636 15bc 0090A0E3 		mov	r9, #0
 2637 15c0 09A0A0E1 		mov	r10, r9
 2638              	.LVL287:
 2639              	.L284:
2268:../uvc.c      **** }
 2640              		.loc 1 2268 0
 2641 15c4 000C8DE8 		stmia	sp, {r10, fp}
 2642 15c8 4C1D9FE5 		ldr	r1, .L452+12
 2643 15cc 08708DE5 		str	r7, [sp, #8]
 2644 15d0 0620A0E1 		mov	r2, r6
 2645 15d4 0930A0E1 		mov	r3, r9
 2646 15d8 0400A0E3 		mov	r0, #4
 2647 15dc FEFFFFEB 		bl	CyU3PDebugPrint
 2648              	.LVL288:
2269:../uvc.c      **** /************** CT control requests handler *************************/
 2649              		.loc 1 2269 0
 2650 15e0 3CD08DE2 		add	sp, sp, #60
 2651              		@ sp needed
 2652 15e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2653              	.LVL289:
 2654              	.L277:
1378:../uvc.c      **** 				 switch(CtrlID)
 2655              		.loc 1 1378 0
 2656 15e8 0F0050E3 		cmp	r0, #15
 2657 15ec 5000009A 		bls	.L285
1379:../uvc.c      **** 				 {
 2658              		.loc 1 1379 0
 2659 15f0 193040E2 		sub	r3, r0, #25
 2660 15f4 0F0053E3 		cmp	r3, #15
 2661 15f8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2662 15fc 940300EA 		b	.L286
 2663              	.L288:
 2664 1600 C81A0000 		.word	.L287
 2665 1604 54240000 		.word	.L286
 2666 1608 54240000 		.word	.L286
 2667 160c 3C190000 		.word	.L303
 2668 1610 54240000 		.word	.L286
 2669 1614 54240000 		.word	.L286
 2670 1618 381B0000 		.word	.L290
 2671 161c 54240000 		.word	.L286
 2672 1620 54240000 		.word	.L286
 2673 1624 54240000 		.word	.L286
 2674 1628 54240000 		.word	.L286
 2675 162c 401A0000 		.word	.L291
 2676 1630 54240000 		.word	.L286
 2677 1634 081A0000 		.word	.L292
 2678 1638 54240000 		.word	.L286
 2679 163c 881A0000 		.word	.L293
 2680              	.L274:
2265:../uvc.c      **** 			  break;
 2681              		.loc 1 2265 0
 2682 1640 0000A0E3 		mov	r0, #0
 2683              	.LVL290:
 2684 1644 0020A0E1 		mov	r2, r0
 2685 1648 0110A0E3 		mov	r1, #1
2266:../uvc.c      **** 		 }
 2686              		.loc 1 2266 0
 2687 164c FF70A0E3 		mov	r7, #255
 2688 1650 0090A0E3 		mov	r9, #0
2265:../uvc.c      **** 			  break;
 2689              		.loc 1 2265 0
 2690 1654 FEFFFFEB 		bl	CyU3PUsbStall
 2691              	.LVL291:
2266:../uvc.c      **** 		 }
 2692              		.loc 1 2266 0
 2693 1658 07B0A0E1 		mov	fp, r7
 2694              	.LVL292:
 2695 165c 09A0A0E1 		mov	r10, r9
 2696 1660 D7FFFFEA 		b	.L284
 2697              	.LVL293:
 2698              	.L280:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2699              		.loc 1 1371 0
 2700 1664 EC4C9FE5 		ldr	r4, .L452+72
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2701              		.loc 1 1372 0
 2702 1668 0030A0E3 		mov	r3, #0
 2703 166c 0390A0E1 		mov	r9, r3
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2704              		.loc 1 1373 0
 2705 1670 281084E2 		add	r1, r4, #40
 2706 1674 0200A0E3 		mov	r0, #2
 2707              	.LVL294:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2708              		.loc 1 1371 0
 2709 1678 2880C4E5 		strb	r8, [r4, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2710              		.loc 1 1372 0
 2711 167c 2930C4E5 		strb	r3, [r4, #41]
 2712 1680 09A0A0E1 		mov	r10, r9
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2713              		.loc 1 1373 0
 2714 1684 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2715              	.LVL295:
1375:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2716              		.loc 1 1375 0
 2717 1688 FF70A0E3 		mov	r7, #255
 2718 168c 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2719              	.LVL296:
 2720 1690 CBFFFFEA 		b	.L284
 2721              	.LVL297:
 2722              	.L275:
1715:../uvc.c      **** 		 		 if(Len == 2){
 2723              		.loc 1 1715 0
 2724 1694 0F0050E3 		cmp	r0, #15
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2725              		.loc 1 1717 0
 2726 1698 005187E0 		add	r5, r7, r0, asl #2
1715:../uvc.c      **** 		 		 if(Len == 2){
 2727              		.loc 1 1715 0
 2728 169c 3E00009A 		bls	.L319
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2729              		.loc 1 1716 0
 2730 16a0 020058E3 		cmp	r8, #2
 2731 16a4 6500000A 		beq	.L438
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2732              		.loc 1 1722 0
 2733 16a8 202015E5 		ldr	r2, [r5, #-32]
 2734 16ac A44C9FE5 		ldr	r4, .L452+72
 2735 16b0 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2736              		.loc 1 1723 0
 2737 16b4 0030A0E3 		mov	r3, #0
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2738              		.loc 1 1722 0
 2739 16b8 2810C4E5 		strb	r1, [r4, #40]
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2740              		.loc 1 1723 0
 2741 16bc 2930C4E5 		strb	r3, [r4, #41]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2742              		.loc 1 1724 0
 2743 16c0 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1725:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2744              		.loc 1 1725 0
 2745 16c4 2B30C4E5 		strb	r3, [r4, #43]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2746              		.loc 1 1724 0
 2747 16c8 2A20C4E5 		strb	r2, [r4, #42]
 2748 16cc 3C0000EA 		b	.L331
 2749              	.L281:
1751:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2750              		.loc 1 1751 0
 2751 16d0 0F0050E3 		cmp	r0, #15
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2752              		.loc 1 1752 0
 2753 16d4 005187E0 		add	r5, r7, r0, asl #2
 2754 16d8 20201585 		ldrhi	r2, [r5, #-32]
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2755              		.loc 1 1758 0
 2756 16dc 20219595 		ldrls	r2, [r5, #288]
 2757 16e0 704C9FE5 		ldr	r4, .L452+72
 2758 16e4 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2759              		.loc 1 1760 0
 2760 16e8 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2761              		.loc 1 1758 0
 2762 16ec 2810C4E5 		strb	r1, [r4, #40]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2763              		.loc 1 1759 0
 2764 16f0 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2765              		.loc 1 1763 0
 2766 16f4 0800A0E1 		mov	r0, r8
 2767              	.LVL298:
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2768              		.loc 1 1760 0
 2769 16f8 2A30C4E5 		strb	r3, [r4, #42]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2770              		.loc 1 1759 0
 2771 16fc 2920C4E5 		strb	r2, [r4, #41]
1761:../uvc.c      **** 		 	 }
 2772              		.loc 1 1761 0
 2773 1700 2B30C4E5 		strb	r3, [r4, #43]
 2774 1704 A8FFFFEA 		b	.L428
 2775              	.LVL299:
 2776              	.L328:
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2777              		.loc 1 1802 0
 2778 1708 020058E3 		cmp	r8, #2
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2779              		.loc 1 1803 0
 2780 170c 203195E5 		ldr	r3, [r5, #288]
 2781 1710 404C9FE5 		ldr	r4, .L452+72
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2782              		.loc 1 1802 0
 2783 1714 5500000A 		beq	.L439
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2784              		.loc 1 1807 0
 2785 1718 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2786              		.loc 1 1810 0
 2787 171c 0020A0E3 		mov	r2, #0
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2788              		.loc 1 1807 0
 2789 1720 2810C4E5 		strb	r1, [r4, #40]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2790              		.loc 1 1809 0
 2791 1724 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2792              		.loc 1 1810 0
 2793 1728 2B20C4E5 		strb	r2, [r4, #43]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2794              		.loc 1 1809 0
 2795 172c 2930C4E5 		strb	r3, [r4, #41]
 2796 1730 230000EA 		b	.L331
 2797              	.L285:
1522:../uvc.c      **** 				 {
 2798              		.loc 1 1522 0
 2799 1734 013040E2 		sub	r3, r0, #1
 2800 1738 0A0053E3 		cmp	r3, #10
 2801 173c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2802 1740 F80100EA 		b	.L304
 2803              	.L306:
 2804 1744 D0190000 		.word	.L305
 2805 1748 281F0000 		.word	.L304
 2806 174c 281F0000 		.word	.L304
 2807 1750 90190000 		.word	.L307
 2808 1754 54190000 		.word	.L308
 2809 1758 281F0000 		.word	.L304
 2810 175c 34190000 		.word	.L309
 2811 1760 281F0000 		.word	.L304
 2812 1764 281F0000 		.word	.L304
 2813 1768 281F0000 		.word	.L304
 2814 176c B4180000 		.word	.L310
 2815              	.L314:
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2816              		.loc 1 1693 0
 2817 1770 020058E3 		cmp	r8, #2
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2818              		.loc 1 1694 0
 2819 1774 203195E5 		ldr	r3, [r5, #288]
 2820 1778 D84B9FE5 		ldr	r4, .L452+72
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2821              		.loc 1 1693 0
 2822 177c 4700000A 		beq	.L440
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2823              		.loc 1 1698 0
 2824 1780 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2825              		.loc 1 1701 0
 2826 1784 0020A0E3 		mov	r2, #0
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2827              		.loc 1 1698 0
 2828 1788 2810C4E5 		strb	r1, [r4, #40]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2829              		.loc 1 1700 0
 2830 178c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2831              		.loc 1 1701 0
 2832 1790 2B20C4E5 		strb	r2, [r4, #43]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2833              		.loc 1 1700 0
 2834 1794 2930C4E5 		strb	r3, [r4, #41]
 2835 1798 090000EA 		b	.L331
 2836              	.L319:
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2837              		.loc 1 1729 0
 2838 179c 020058E3 		cmp	r8, #2
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2839              		.loc 1 1730 0
 2840 17a0 203195E5 		ldr	r3, [r5, #288]
 2841 17a4 AC4B9FE5 		ldr	r4, .L452+72
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2842              		.loc 1 1729 0
 2843 17a8 2B00000A 		beq	.L441
1734:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2844              		.loc 1 1734 0
 2845 17ac 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1737:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2846              		.loc 1 1737 0
 2847 17b0 0020A0E3 		mov	r2, #0
1734:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2848              		.loc 1 1734 0
 2849 17b4 2810C4E5 		strb	r1, [r4, #40]
1736:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2850              		.loc 1 1736 0
 2851 17b8 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1737:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2852              		.loc 1 1737 0
 2853 17bc 2B20C4E5 		strb	r2, [r4, #43]
1736:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2854              		.loc 1 1736 0
 2855 17c0 2930C4E5 		strb	r3, [r4, #41]
 2856              	.L331:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2857              		.loc 1 1814 0
 2858 17c4 0800A0E1 		mov	r0, r8
 2859              	.LVL300:
 2860 17c8 481B9FE5 		ldr	r1, .L452+8
 2861 17cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2862              	.LVL301:
 2863 17d0 0090A0E3 		mov	r9, #0
 2864 17d4 09A0A0E1 		mov	r10, r9
 2865 17d8 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2866              	.LVL302:
 2867 17dc 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2868 17e0 77FFFFEA 		b	.L284
 2869              	.LVL303:
 2870              	.L336:
2069:../uvc.c      **** 					 {
 2871              		.loc 1 2069 0
 2872 17e4 0B0055E3 		cmp	r5, #11
 2873 17e8 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2874 17ec 240300EA 		b	.L367
 2875              	.L369:
 2876 17f0 C41E0000 		.word	.L368
 2877 17f4 641E0000 		.word	.L370
 2878 17f8 84240000 		.word	.L367
 2879 17fc 84240000 		.word	.L367
 2880 1800 001E0000 		.word	.L371
 2881 1804 AC1C0000 		.word	.L372
 2882 1808 84240000 		.word	.L367
 2883 180c 1C1C0000 		.word	.L373
 2884 1810 84240000 		.word	.L367
 2885 1814 84240000 		.word	.L367
 2886 1818 84240000 		.word	.L367
 2887 181c 881B0000 		.word	.L374
 2888              	.LVL304:
 2889              	.L436:
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2890              		.loc 1 1790 0
 2891 1820 203015E5 		ldr	r3, [r5, #-32]
 2892 1824 2C4B9FE5 		ldr	r4, .L452+72
 2893 1828 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2894 182c 2820C4E5 		strb	r2, [r4, #40]
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2895              		.loc 1 1791 0
 2896 1830 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2897 1834 2930C4E5 		strb	r3, [r4, #41]
 2898              	.L330:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2899              		.loc 1 1814 0
 2900 1838 0200A0E3 		mov	r0, #2
 2901              	.LVL305:
 2902 183c 5AFFFFEA 		b	.L428
 2903              	.LVL306:
 2904              	.L438:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2905              		.loc 1 1717 0
 2906 1840 203015E5 		ldr	r3, [r5, #-32]
 2907 1844 0C4B9FE5 		ldr	r4, .L452+72
 2908 1848 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2909 184c 2820C4E5 		strb	r2, [r4, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2910              		.loc 1 1718 0
 2911 1850 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2912 1854 2930C4E5 		strb	r3, [r4, #41]
 2913 1858 F6FFFFEA 		b	.L330
 2914              	.L441:
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2915              		.loc 1 1730 0
 2916 185c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2917 1860 2820C4E5 		strb	r2, [r4, #40]
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2918              		.loc 1 1731 0
 2919 1864 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2920 1868 2930C4E5 		strb	r3, [r4, #41]
 2921 186c F1FFFFEA 		b	.L330
 2922              	.L439:
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2923              		.loc 1 1803 0
 2924 1870 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2925 1874 2820C4E5 		strb	r2, [r4, #40]
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2926              		.loc 1 1804 0
 2927 1878 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2928 187c 2930C4E5 		strb	r3, [r4, #41]
 2929 1880 ECFFFFEA 		b	.L330
 2930              	.L437:
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2931              		.loc 1 1681 0
 2932 1884 203015E5 		ldr	r3, [r5, #-32]
 2933 1888 C84A9FE5 		ldr	r4, .L452+72
 2934 188c 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2935 1890 2820C4E5 		strb	r2, [r4, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2936              		.loc 1 1682 0
 2937 1894 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2938 1898 2930C4E5 		strb	r3, [r4, #41]
 2939 189c E5FFFFEA 		b	.L330
 2940              	.L440:
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2941              		.loc 1 1694 0
 2942 18a0 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2943 18a4 2820C4E5 		strb	r2, [r4, #40]
1695:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2944              		.loc 1 1695 0
 2945 18a8 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2946 18ac 2930C4E5 		strb	r3, [r4, #41]
 2947 18b0 E0FFFFEA 		b	.L330
 2948              	.L310:
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2949              		.loc 1 1596 0
 2950 18b4 0B10A0E1 		mov	r1, fp
 2951 18b8 0C00A0E1 		mov	r0, ip
 2952              	.LVL307:
 2953 18bc FEFFFFEB 		bl	SensorGetControl
 2954              	.LVL308:
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2955              		.loc 1 1597 0
 2956 18c0 0B10A0E1 		mov	r1, fp
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2957              		.loc 1 1598 0
 2958 18c4 8C4A9FE5 		ldr	r4, .L452+72
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2959              		.loc 1 1596 0
 2960 18c8 0050A0E1 		mov	r5, r0
 2961              	.LVL309:
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2962              		.loc 1 1597 0
 2963 18cc 20009DE5 		ldr	r0, [sp, #32]
 2964              	.LVL310:
 2965 18d0 FEFFFFEB 		bl	SensorGetControl
 2966              	.LVL311:
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2967              		.loc 1 1599 0
 2968 18d4 742A9FE5 		ldr	r2, .L452+64
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2969              		.loc 1 1604 0
 2970 18d8 0030A0E3 		mov	r3, #0
 2971 18dc 05B0A0E1 		mov	fp, r5
 2972              	.LVL312:
1608:../uvc.c      **** 					 case ShapCtlID7:
 2973              		.loc 1 1608 0
 2974 18e0 0590A0E1 		mov	r9, r5
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2975              		.loc 1 1598 0
 2976 18e4 2850C4E5 		strb	r5, [r4, #40]
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2977              		.loc 1 1599 0
 2978 18e8 8455C2E5 		strb	r5, [r2, #1412]
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2979              		.loc 1 1604 0
 2980 18ec 2930C4E5 		strb	r3, [r4, #41]
1605:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2981              		.loc 1 1605 0
 2982 18f0 2B30C4E5 		strb	r3, [r4, #43]
 2983 18f4 0070A0E1 		mov	r7, r0
1608:../uvc.c      **** 					 case ShapCtlID7:
 2984              		.loc 1 1608 0
 2985 18f8 00A0A0E1 		mov	r10, r0
1600:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2986              		.loc 1 1600 0
 2987 18fc 2A00C4E5 		strb	r0, [r4, #42]
1601:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 2988              		.loc 1 1601 0
 2989 1900 8605C2E5 		strb	r0, [r2, #1414]
 2990              	.LVL313:
 2991              	.L294:
1672:../uvc.c      **** 
 2992              		.loc 1 1672 0
 2993 1904 0800A0E1 		mov	r0, r8
 2994 1908 081A9FE5 		ldr	r1, .L452+8
 2995 190c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2996              	.LVL314:
1675:../uvc.c      **** //#endif
 2997              		.loc 1 1675 0
 2998 1910 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2999 1914 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 3000 1918 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3001 191c 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 3002 1920 03018DE8 		stmia	sp, {r0, r1, r8}
 3003 1924 F4199FE5 		ldr	r1, .L452+16
 3004 1928 0400A0E3 		mov	r0, #4
 3005 192c FEFFFFEB 		bl	CyU3PDebugPrint
 3006              	.LVL315:
1677:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 3007              		.loc 1 1677 0
 3008 1930 23FFFFEA 		b	.L284
 3009              	.LVL316:
 3010              	.L309:
1615:../uvc.c      **** 			 	 			 {
 3011              		.loc 1 1615 0
 3012 1934 020058E3 		cmp	r8, #2
 3013 1938 EC03000A 		beq	.L442
 3014              	.L303:
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3015              		.loc 1 1397 0
 3016 193c FF70A0E3 		mov	r7, #255
 3017 1940 0090A0E3 		mov	r9, #0
 3018 1944 07B0A0E1 		mov	fp, r7
 3019              	.LVL317:
 3020 1948 09A0A0E1 		mov	r10, r9
 3021 194c 044A9FE5 		ldr	r4, .L452+72
 3022 1950 EBFFFFEA 		b	.L294
 3023              	.LVL318:
 3024              	.L308:
1560:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3025              		.loc 1 1560 0
 3026 1954 0B10A0E1 		mov	r1, fp
 3027 1958 0C00A0E1 		mov	r0, ip
 3028              	.LVL319:
 3029 195c FEFFFFEB 		bl	SensorGetControl
 3030              	.LVL320:
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3031              		.loc 1 1565 0
 3032 1960 F0499FE5 		ldr	r4, .L452+72
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3033              		.loc 1 1561 0
 3034 1964 E4299FE5 		ldr	r2, .L452+64
1566:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3035              		.loc 1 1566 0
 3036 1968 0030A0E3 		mov	r3, #0
 3037 196c 2930C4E5 		strb	r3, [r4, #41]
 3038 1970 03A0A0E1 		mov	r10, r3
1568:../uvc.c      **** 					 case MFreqCtlID4:
 3039              		.loc 1 1568 0
 3040 1974 FF70A0E3 		mov	r7, #255
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3041              		.loc 1 1565 0
 3042 1978 80B040E2 		sub	fp, r0, #128
 3043              	.LVL321:
 3044 197c FFB00BE2 		and	fp, fp, #255
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3045              		.loc 1 1561 0
 3046 1980 6905C2E5 		strb	r0, [r2, #1385]
 3047 1984 0090A0E1 		mov	r9, r0
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3048              		.loc 1 1565 0
 3049 1988 28B0C4E5 		strb	fp, [r4, #40]
 3050              	.LVL322:
1568:../uvc.c      **** 					 case MFreqCtlID4:
 3051              		.loc 1 1568 0
 3052 198c DCFFFFEA 		b	.L294
 3053              	.LVL323:
 3054              	.L307:
1580:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 3055              		.loc 1 1580 0
 3056 1990 0B10A0E1 		mov	r1, fp
 3057 1994 0100A0E3 		mov	r0, #1
 3058              	.LVL324:
 3059 1998 FEFFFFEB 		bl	SensorGetControl
 3060              	.LVL325:
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3061              		.loc 1 1583 0
 3062 199c AC399FE5 		ldr	r3, .L452+64
1582:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 3063              		.loc 1 1582 0
 3064 19a0 B0499FE5 		ldr	r4, .L452+72
 3065 19a4 00A0A0E3 		mov	r10, #0
1581:../uvc.c      **** 							glEp0Buffer[0]++;
 3066              		.loc 1 1581 0
 3067 19a8 A0B3A0E1 		mov	fp, r0, lsr #7
 3068              	.LVL326:
1582:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 3069              		.loc 1 1582 0
 3070 19ac 01B08BE2 		add	fp, fp, #1
 3071 19b0 FFB00BE2 		and	fp, fp, #255
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3072              		.loc 1 1583 0
 3073 19b4 7DB5C3E5 		strb	fp, [r3, #1405]
1584:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3074              		.loc 1 1584 0
 3075 19b8 7E75D3E5 		ldrb	r7, [r3, #1406]	@ zero_extendqisi2
 3076 19bc 0090A0E1 		mov	r9, r0
 3077 19c0 FF7007E2 		and	r7, r7, #255
 3078 19c4 2970C4E5 		strb	r7, [r4, #41]
 3079              	.LVL327:
1582:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 3080              		.loc 1 1582 0
 3081 19c8 28B0C4E5 		strb	fp, [r4, #40]
1590:../uvc.c      **** 					 case WBTLevCtlID11:
 3082              		.loc 1 1590 0
 3083 19cc CCFFFFEA 		b	.L294
 3084              	.LVL328:
 3085              	.L305:
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3086              		.loc 1 1540 0
 3087 19d0 0B10A0E1 		mov	r1, fp
 3088 19d4 0C00A0E1 		mov	r0, ip
 3089              	.LVL329:
 3090 19d8 FEFFFFEB 		bl	SensorGetControl
 3091              	.LVL330:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3092              		.loc 1 1552 0
 3093 19dc 74499FE5 		ldr	r4, .L452+72
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3094              		.loc 1 1541 0
 3095 19e0 68299FE5 		ldr	r2, .L452+64
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3096              		.loc 1 1553 0
 3097 19e4 0030A0E3 		mov	r3, #0
 3098 19e8 2930C4E5 		strb	r3, [r4, #41]
 3099 19ec 03A0A0E1 		mov	r10, r3
1555:../uvc.c      **** 					 case HueCtlID5:
 3100              		.loc 1 1555 0
 3101 19f0 FF70A0E3 		mov	r7, #255
 3102 19f4 00B0A0E1 		mov	fp, r0
 3103              	.LVL331:
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3104              		.loc 1 1541 0
 3105 19f8 5505C2E5 		strb	r0, [r2, #1365]
 3106              	.LVL332:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3107              		.loc 1 1552 0
 3108 19fc 2800C4E5 		strb	r0, [r4, #40]
1555:../uvc.c      **** 					 case HueCtlID5:
 3109              		.loc 1 1555 0
 3110 1a00 0090A0E1 		mov	r9, r0
 3111 1a04 BEFFFFEA 		b	.L294
 3112              	.LVL333:
 3113              	.L292:
1386:../uvc.c      **** 							if(Data0&0x80)
 3114              		.loc 1 1386 0
 3115 1a08 0B10A0E1 		mov	r1, fp
 3116 1a0c 0C00A0E1 		mov	r0, ip
 3117              	.LVL334:
 3118 1a10 FEFFFFEB 		bl	SensorGetControl
 3119              	.LVL335:
 3120 1a14 3C499FE5 		ldr	r4, .L452+72
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3121              		.loc 1 1391 0
 3122 1a18 30399FE5 		ldr	r3, .L452+64
1392:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3123              		.loc 1 1392 0
 3124 1a1c 0070A0E3 		mov	r7, #0
 3125 1a20 2970C4E5 		strb	r7, [r4, #41]
 3126 1a24 07A0A0E1 		mov	r10, r7
1387:../uvc.c      **** 								glEp0Buffer[0] = 1;
 3127              		.loc 1 1387 0
 3128 1a28 FFB000E2 		and	fp, r0, #255
 3129              	.LVL336:
 3130 1a2c ABB3A0E1 		mov	fp, fp, lsr #7
 3131              	.LVL337:
 3132 1a30 0090A0E1 		mov	r9, r0
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3133              		.loc 1 1391 0
 3134 1a34 05B5C3E5 		strb	fp, [r3, #1285]
 3135 1a38 28B0C4E5 		strb	fp, [r4, #40]
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3136              		.loc 1 1397 0
 3137 1a3c B0FFFFEA 		b	.L294
 3138              	.LVL338:
 3139              	.L291:
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3140              		.loc 1 1461 0
 3141 1a40 0B10A0E1 		mov	r1, fp
 3142 1a44 0C00A0E1 		mov	r0, ip
 3143              	.LVL339:
 3144 1a48 FEFFFFEB 		bl	SensorGetControl
 3145              	.LVL340:
 3146 1a4c 04499FE5 		ldr	r4, .L452+72
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3147              		.loc 1 1462 0
 3148 1a50 F8589FE5 		ldr	r5, .L452+64
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3149              		.loc 1 1463 0
 3150 1a54 0B10A0E1 		mov	r1, fp
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3151              		.loc 1 1461 0
 3152 1a58 0030A0E1 		mov	r3, r0
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3153              		.loc 1 1463 0
 3154 1a5c 20009DE5 		ldr	r0, [sp, #32]
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3155              		.loc 1 1461 0
 3156 1a60 2830C4E5 		strb	r3, [r4, #40]
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3157              		.loc 1 1462 0
 3158 1a64 4135C5E5 		strb	r3, [r5, #1345]
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3159              		.loc 1 1463 0
 3160 1a68 FEFFFFEB 		bl	SensorGetControl
 3161              	.LVL341:
 3162 1a6c 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 3163              	.LVL342:
 3164 1a70 0070A0E1 		mov	r7, r0
 3165 1a74 2900C4E5 		strb	r0, [r4, #41]
1464:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3166              		.loc 1 1464 0
 3167 1a78 4205C5E5 		strb	r0, [r5, #1346]
 3168              	.LVL343:
 3169              	.L423:
 3170 1a7c 0090A0E3 		mov	r9, #0
 3171 1a80 09A0A0E1 		mov	r10, r9
1467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 3172              		.loc 1 1467 0
 3173 1a84 9EFFFFEA 		b	.L294
 3174              	.LVL344:
 3175              	.L293:
1451:../uvc.c      **** 			 	 		// sendData &= 0x70;
 3176              		.loc 1 1451 0
 3177 1a88 0B10A0E1 		mov	r1, fp
 3178 1a8c 20009DE5 		ldr	r0, [sp, #32]
 3179              	.LVL345:
 3180 1a90 FEFFFFEB 		bl	SensorGetControl
 3181              	.LVL346:
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3182              		.loc 1 1453 0
 3183 1a94 BC489FE5 		ldr	r4, .L452+72
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3184              		.loc 1 1454 0
 3185 1a98 B0289FE5 		ldr	r2, .L452+64
1455:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3186              		.loc 1 1455 0
 3187 1a9c 0030A0E3 		mov	r3, #0
 3188 1aa0 2930C4E5 		strb	r3, [r4, #41]
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3189              		.loc 1 1459 0
 3190 1aa4 0370A0E1 		mov	r7, r3
 3191 1aa8 0390A0E1 		mov	r9, r3
 3192 1aac 03A0A0E1 		mov	r10, r3
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3193              		.loc 1 1453 0
 3194 1ab0 2002A0E1 		mov	r0, r0, lsr #4
 3195              	.LVL347:
 3196 1ab4 FFB000E2 		and	fp, r0, #255
 3197              	.LVL348:
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3198              		.loc 1 1454 0
 3199 1ab8 2DB5C2E5 		strb	fp, [r2, #1325]
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3200              		.loc 1 1453 0
 3201 1abc 28B0C4E5 		strb	fp, [r4, #40]
1456:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3202              		.loc 1 1456 0
 3203 1ac0 2E35C2E5 		strb	r3, [r2, #1326]
 3204              	.LVL349:
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3205              		.loc 1 1459 0
 3206 1ac4 8EFFFFEA 		b	.L294
 3207              	.LVL350:
 3208              	.L287:
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3209              		.loc 1 1403 0
 3210 1ac8 0C00A0E1 		mov	r0, ip
 3211              	.LVL351:
 3212 1acc 0B10A0E1 		mov	r1, fp
 3213 1ad0 FEFFFFEB 		bl	SensorGetControl
 3214              	.LVL352:
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3215              		.loc 1 1404 0
 3216 1ad4 7C489FE5 		ldr	r4, .L452+72
1405:../uvc.c      **** 
 3217              		.loc 1 1405 0
 3218 1ad8 70589FE5 		ldr	r5, .L452+64
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3219              		.loc 1 1407 0
 3220 1adc 0B10A0E1 		mov	r1, fp
 3221 1ae0 0090A0E3 		mov	r9, #0
 3222 1ae4 09A0A0E1 		mov	r10, r9
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3223              		.loc 1 1404 0
 3224 1ae8 033000E2 		and	r3, r0, #3
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3225              		.loc 1 1407 0
 3226 1aec 20009DE5 		ldr	r0, [sp, #32]
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3227              		.loc 1 1404 0
 3228 1af0 2830C4E5 		strb	r3, [r4, #40]
1405:../uvc.c      **** 
 3229              		.loc 1 1405 0
 3230 1af4 1935C5E5 		strb	r3, [r5, #1305]
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3231              		.loc 1 1407 0
 3232 1af8 FEFFFFEB 		bl	SensorGetControl
 3233              	.LVL353:
1415:../uvc.c      **** 						 break;
 3234              		.loc 1 1415 0
 3235 1afc 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 3236              	.LVL354:
 3237 1b00 0930A0E1 		mov	r3, r9
 3238 1b04 04908DE5 		str	r9, [sp, #4]
 3239 1b08 0B20A0E1 		mov	r2, fp
 3240 1b0c 10189FE5 		ldr	r1, .L452+20
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3241              		.loc 1 1407 0
 3242 1b10 00E0A0E1 		mov	lr, r0
1415:../uvc.c      **** 						 break;
 3243              		.loc 1 1415 0
 3244 1b14 00008DE5 		str	r0, [sp]
 3245 1b18 0070A0E1 		mov	r7, r0
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3246              		.loc 1 1407 0
 3247 1b1c 2AE0C4E5 		strb	lr, [r4, #42]
1408:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
 3248              		.loc 1 1408 0
 3249 1b20 1AE5C5E5 		strb	lr, [r5, #1306]
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3250              		.loc 1 1411 0
 3251 1b24 2990C4E5 		strb	r9, [r4, #41]
1412:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3252              		.loc 1 1412 0
 3253 1b28 2B90C4E5 		strb	r9, [r4, #43]
 3254              	.LVL355:
1415:../uvc.c      **** 						 break;
 3255              		.loc 1 1415 0
 3256 1b2c 0400A0E3 		mov	r0, #4
 3257              	.LVL356:
 3258 1b30 FEFFFFEB 		bl	CyU3PDebugPrint
 3259              	.LVL357:
1416:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3260              		.loc 1 1416 0
 3261 1b34 72FFFFEA 		b	.L294
 3262              	.LVL358:
 3263              	.L290:
1435:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3264              		.loc 1 1435 0 discriminator 1
 3265 1b38 000058E3 		cmp	r8, #0
 3266 1b3c 0300000A 		beq	.L298
 3267 1b40 D0079FE5 		ldr	r0, .L452+8
 3268              	.LVL359:
 3269 1b44 0820A0E1 		mov	r2, r8
 3270 1b48 6C1080E2 		add	r1, r0, #108
 3271 1b4c FEFFFFEB 		bl	memcpy
 3272              	.LVL360:
 3273              	.L298:
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3274              		.loc 1 1438 0
 3275 1b50 00489FE5 		ldr	r4, .L452+72
1445:../uvc.c      **** 				 		 {
 3276              		.loc 1 1445 0
 3277 1b54 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3278              		.loc 1 1438 0
 3279 1b58 31B0D4E5 		ldrb	fp, [r4, #49]	@ zero_extendqisi2
 3280              	.LVL361:
1445:../uvc.c      **** 				 		 {
 3281              		.loc 1 1445 0
 3282 1b5c FF0053E3 		cmp	r3, #255
1439:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3283              		.loc 1 1439 0
 3284 1b60 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3285              	.LVL362:
1445:../uvc.c      **** 				 		 {
 3286              		.loc 1 1445 0
 3287 1b64 C4FFFF0A 		beq	.L423
1447:../uvc.c      **** 				 		 }
 3288              		.loc 1 1447 0
 3289 1b68 0400A0E3 		mov	r0, #4
 3290 1b6c B4179FE5 		ldr	r1, .L452+24
 3291 1b70 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3292 1b74 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3293 1b78 FEFFFFEB 		bl	CyU3PDebugPrint
 3294              	.LVL363:
 3295 1b7c 0090A0E3 		mov	r9, #0
 3296 1b80 09A0A0E1 		mov	r10, r9
 3297 1b84 5EFFFFEA 		b	.L294
 3298              	.LVL364:
 3299              	.L374:
2175:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3300              		.loc 1 2175 0
 3301 1b88 C4479FE5 		ldr	r4, .L452+68
 3302 1b8c 0010E0E3 		mvn	r1, #0
 3303 1b90 1C0094E5 		ldr	r0, [r4, #28]
 3304 1b94 18C08DE5 		str	ip, [sp, #24]
 3305 1b98 FEFFFFEB 		bl	_txe_mutex_get
 3306              	.LVL365:
2176:../uvc.c      **** 							 dataIdx++;
 3307              		.loc 1 2176 0
 3308 1b9c 24109DE5 		ldr	r1, [sp, #36]
 3309 1ba0 18C09DE5 		ldr	ip, [sp, #24]
 3310 1ba4 0030A0E3 		mov	r3, #0
 3311 1ba8 0C20A0E1 		mov	r2, ip
 3312 1bac 00108DE5 		str	r1, [sp]
 3313 1bb0 04308DE5 		str	r3, [sp, #4]
 3314 1bb4 0B10A0E3 		mov	r1, #11
 3315 1bb8 0B30A0E1 		mov	r3, fp
 3316 1bbc 0400A0E1 		mov	r0, r4
 3317 1bc0 FEFFFFEB 		bl	cmdSet
 3318              	.LVL366:
2178:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3319              		.loc 1 2178 0
 3320 1bc4 28C09DE5 		ldr	ip, [sp, #40]
 3321 1bc8 0180A0E3 		mov	r8, #1
 3322              	.LVL367:
 3323 1bcc 0B30A0E1 		mov	r3, fp
 3324 1bd0 00C08DE5 		str	ip, [sp]
 3325 1bd4 20209DE5 		ldr	r2, [sp, #32]
 3326 1bd8 0B10A0E3 		mov	r1, #11
 3327 1bdc 0400A0E1 		mov	r0, r4
 3328 1be0 04808DE5 		str	r8, [sp, #4]
 3329 1be4 FEFFFFEB 		bl	cmdSet
 3330              	.LVL368:
2179:../uvc.c      **** 
 3331              		.loc 1 2179 0
 3332 1be8 1C0094E5 		ldr	r0, [r4, #28]
 3333 1bec FEFFFFEB 		bl	_txe_mutex_put
 3334              	.LVL369:
2181:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3335              		.loc 1 2181 0
 3336 1bf0 58379FE5 		ldr	r3, .L452+64
 3337 1bf4 24C09DE5 		ldr	ip, [sp, #36]
2183:../uvc.c      **** 							 break;
 3338              		.loc 1 2183 0
 3339 1bf8 055187E0 		add	r5, r7, r5, asl #2
 3340 1bfc 202195E5 		ldr	r2, [r5, #288]
2181:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3341              		.loc 1 2181 0
 3342 1c00 84C5C3E5 		strb	ip, [r3, #1412]
2182:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3343              		.loc 1 2182 0
 3344 1c04 28C09DE5 		ldr	ip, [sp, #40]
2184:../uvc.c      **** 						 case BLCCtlID0:
 3345              		.loc 1 2184 0
 3346 1c08 FF70A0E3 		mov	r7, #255
2183:../uvc.c      **** 							 break;
 3347              		.loc 1 2183 0
 3348 1c0c 1180C2E5 		strb	r8, [r2, #17]
2182:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3349              		.loc 1 2182 0
 3350 1c10 86C5C3E5 		strb	ip, [r3, #1414]
2184:../uvc.c      **** 						 case BLCCtlID0:
 3351              		.loc 1 2184 0
 3352 1c14 07B0A0E1 		mov	fp, r7
 3353              	.LVL370:
 3354 1c18 69FEFFEA 		b	.L284
 3355              	.LVL371:
 3356              	.L373:
2204:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3357              		.loc 1 2204 0
 3358 1c1c 24309DE5 		ldr	r3, [sp, #36]
2203:../uvc.c      **** 							 if(Data0 != 0){
 3359              		.loc 1 2203 0
 3360 1c20 055187E0 		add	r5, r7, r5, asl #2
 3361 1c24 205195E5 		ldr	r5, [r5, #288]
2205:../uvc.c      **** 	#ifdef COLOR
 3362              		.loc 1 2205 0
 3363 1c28 24479FE5 		ldr	r4, .L452+68
2204:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3364              		.loc 1 2204 0
 3365 1c2c 000053E3 		cmp	r3, #0
2203:../uvc.c      **** 							 if(Data0 != 0){
 3366              		.loc 1 2203 0
 3367 1c30 0D30C5E5 		strb	r3, [r5, #13]
2205:../uvc.c      **** 	#ifdef COLOR
 3368              		.loc 1 2205 0
 3369 1c34 0010E0E3 		mvn	r1, #0
 3370 1c38 1C0094E5 		ldr	r0, [r4, #28]
 3371 1c3c 18C08DE5 		str	ip, [sp, #24]
2204:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3372              		.loc 1 2204 0
 3373 1c40 5B02000A 		beq	.L390
2205:../uvc.c      **** 	#ifdef COLOR
 3374              		.loc 1 2205 0
 3375 1c44 FEFFFFEB 		bl	_txe_mutex_get
 3376              	.LVL372:
2209:../uvc.c      **** 								 dataIdx++;
 3377              		.loc 1 2209 0
 3378 1c48 18C09DE5 		ldr	ip, [sp, #24]
 3379 1c4c 0170A0E3 		mov	r7, #1
 3380 1c50 0030A0E3 		mov	r3, #0
 3381 1c54 0C20A0E1 		mov	r2, ip
 3382 1c58 04308DE5 		str	r3, [sp, #4]
 3383 1c5c 0400A0E1 		mov	r0, r4
 3384 1c60 00708DE5 		str	r7, [sp]
 3385 1c64 0710A0E3 		mov	r1, #7
 3386 1c68 0B30A0E1 		mov	r3, fp
 3387 1c6c FEFFFFEB 		bl	cmdSet
 3388              	.LVL373:
2211:../uvc.c      **** 	#endif
 3389              		.loc 1 2211 0
 3390 1c70 24C09DE5 		ldr	ip, [sp, #36]
 3391 1c74 20209DE5 		ldr	r2, [sp, #32]
 3392 1c78 04708DE5 		str	r7, [sp, #4]
 3393 1c7c 00C08DE5 		str	ip, [sp]
 3394              	.LVL374:
 3395              	.L426:
2216:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3396              		.loc 1 2216 0
 3397 1c80 0B30A0E1 		mov	r3, fp
 3398 1c84 0710A0E3 		mov	r1, #7
 3399 1c88 0400A0E1 		mov	r0, r4
 3400 1c8c FEFFFFEB 		bl	cmdSet
 3401              	.LVL375:
2217:../uvc.c      **** 							 }
 3402              		.loc 1 2217 0
 3403 1c90 1C0094E5 		ldr	r0, [r4, #28]
 3404 1c94 FEFFFFEB 		bl	_txe_mutex_put
 3405              	.LVL376:
2220:../uvc.c      **** 						 case ConsCtlID2:
 3406              		.loc 1 2220 0
 3407 1c98 FF70A0E3 		mov	r7, #255
2219:../uvc.c      **** 							 break;
 3408              		.loc 1 2219 0
 3409 1c9c 0130A0E3 		mov	r3, #1
 3410 1ca0 1130C5E5 		strb	r3, [r5, #17]
 3411              	.LVL377:
2220:../uvc.c      **** 						 case ConsCtlID2:
 3412              		.loc 1 2220 0
 3413 1ca4 07B0A0E1 		mov	fp, r7
 3414              	.LVL378:
 3415 1ca8 45FEFFEA 		b	.L284
 3416              	.LVL379:
 3417              	.L372:
2110:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3418              		.loc 1 2110 0
 3419 1cac A0869FE5 		ldr	r8, .L452+68
 3420              	.LVL380:
 3421 1cb0 0010E0E3 		mvn	r1, #0
 3422 1cb4 1C0098E5 		ldr	r0, [r8, #28]
 3423 1cb8 18C08DE5 		str	ip, [sp, #24]
 3424 1cbc FEFFFFEB 		bl	_txe_mutex_get
 3425              	.LVL381:
2111:../uvc.c      **** 							 dataIdx++;
 3426              		.loc 1 2111 0
 3427 1cc0 24209DE5 		ldr	r2, [sp, #36]
 3428 1cc4 18C09DE5 		ldr	ip, [sp, #24]
 3429 1cc8 801042E2 		sub	r1, r2, #128
 3430 1ccc FF1001E2 		and	r1, r1, #255
 3431 1cd0 0030A0E3 		mov	r3, #0
 3432 1cd4 0C20A0E1 		mov	r2, ip
 3433 1cd8 00108DE5 		str	r1, [sp]
 3434 1cdc 04308DE5 		str	r3, [sp, #4]
 3435 1ce0 0510A0E3 		mov	r1, #5
 3436 1ce4 0B30A0E1 		mov	r3, fp
 3437 1ce8 0800A0E1 		mov	r0, r8
 3438 1cec FEFFFFEB 		bl	cmdSet
 3439              	.LVL382:
2113:../uvc.c      **** 							 dataIdx++;
 3440              		.loc 1 2113 0
 3441 1cf0 24C09DE5 		ldr	ip, [sp, #36]
 3442 1cf4 0510A0E3 		mov	r1, #5
 3443 1cf8 76304CE2 		sub	r3, ip, #118
 3444 1cfc FF3003E2 		and	r3, r3, #255
 3445 1d00 01C0A0E3 		mov	ip, #1
 3446 1d04 04C08DE5 		str	ip, [sp, #4]
 3447 1d08 00308DE5 		str	r3, [sp]
 3448 1d0c DC20A0E3 		mov	r2, #220
 3449 1d10 0B30A0E1 		mov	r3, fp
 3450 1d14 0800A0E1 		mov	r0, r8
 3451 1d18 18C08DE5 		str	ip, [sp, #24]
 3452 1d1c FEFFFFEB 		bl	cmdSet
 3453              	.LVL383:
2115:../uvc.c      **** 							 dataIdx++;
 3454              		.loc 1 2115 0
 3455 1d20 24109DE5 		ldr	r1, [sp, #36]
 3456 1d24 0230A0E3 		mov	r3, #2
 3457 1d28 7E2081E2 		add	r2, r1, #126
 3458 1d2c FF2002E2 		and	r2, r2, #255
 3459 1d30 00208DE5 		str	r2, [sp]
 3460 1d34 04308DE5 		str	r3, [sp, #4]
 3461 1d38 0510A0E3 		mov	r1, #5
 3462 1d3c 0B30A0E1 		mov	r3, fp
 3463 1d40 DE20A0E3 		mov	r2, #222
 3464 1d44 0800A0E1 		mov	r0, r8
 3465 1d48 FEFFFFEB 		bl	cmdSet
 3466              	.LVL384:
2117:../uvc.c      **** 							 dataIdx++;
 3467              		.loc 1 2117 0
 3468 1d4c 24309DE5 		ldr	r3, [sp, #36]
 3469 1d50 0510A0E3 		mov	r1, #5
 3470 1d54 722083E2 		add	r2, r3, #114
 3471 1d58 FF2002E2 		and	r2, r2, #255
 3472 1d5c 0330A0E3 		mov	r3, #3
 3473 1d60 00208DE5 		str	r2, [sp]
 3474 1d64 04308DE5 		str	r3, [sp, #4]
 3475 1d68 E020A0E3 		mov	r2, #224
 3476 1d6c 0B30A0E1 		mov	r3, fp
 3477 1d70 0800A0E1 		mov	r0, r8
 3478 1d74 FEFFFFEB 		bl	cmdSet
 3479              	.LVL385:
2119:../uvc.c      **** 							 dataIdx++;
 3480              		.loc 1 2119 0
 3481 1d78 24109DE5 		ldr	r1, [sp, #36]
 3482 1d7c 0430A0E3 		mov	r3, #4
 3483 1d80 6F2041E2 		sub	r2, r1, #111
 3484 1d84 FF2002E2 		and	r2, r2, #255
 3485 1d88 00208DE5 		str	r2, [sp]
 3486 1d8c 04308DE5 		str	r3, [sp, #4]
 3487 1d90 0510A0E3 		mov	r1, #5
 3488 1d94 0B30A0E1 		mov	r3, fp
 3489 1d98 DD20A0E3 		mov	r2, #221
 3490 1d9c 0800A0E1 		mov	r0, r8
 3491 1da0 FEFFFFEB 		bl	cmdSet
 3492              	.LVL386:
2121:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3493              		.loc 1 2121 0
 3494 1da4 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3495 1da8 0510A0E3 		mov	r1, #5
 3496 1dac 7F0080E2 		add	r0, r0, #127
 3497 1db0 FF0000E2 		and	r0, r0, #255
 3498 1db4 0B30A0E1 		mov	r3, fp
 3499 1db8 20209DE5 		ldr	r2, [sp, #32]
 3500 1dbc 00008DE5 		str	r0, [sp]
 3501 1dc0 04108DE5 		str	r1, [sp, #4]
 3502 1dc4 0800A0E1 		mov	r0, r8
 3503 1dc8 FEFFFFEB 		bl	cmdSet
 3504              	.LVL387:
2122:../uvc.c      **** 
 3505              		.loc 1 2122 0
 3506 1dcc 1C0098E5 		ldr	r0, [r8, #28]
 3507 1dd0 FEFFFFEB 		bl	_txe_mutex_put
 3508              	.LVL388:
2124:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3509              		.loc 1 2124 0
 3510 1dd4 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3511 1dd8 055187E0 		add	r5, r7, r5, asl #2
 3512 1ddc 203195E5 		ldr	r3, [r5, #288]
 3513 1de0 802042E2 		sub	r2, r2, #128
 3514 1de4 FF2002E2 		and	r2, r2, #255
 3515 1de8 0D20C3E5 		strb	r2, [r3, #13]
2125:../uvc.c      **** 							 break;
 3516              		.loc 1 2125 0
 3517 1dec 18C09DE5 		ldr	ip, [sp, #24]
2126:../uvc.c      **** 						 case MFreqCtlID4:
 3518              		.loc 1 2126 0
 3519 1df0 FF70A0E3 		mov	r7, #255
 3520 1df4 07B0A0E1 		mov	fp, r7
 3521              	.LVL389:
2125:../uvc.c      **** 							 break;
 3522              		.loc 1 2125 0
 3523 1df8 11C0C3E5 		strb	ip, [r3, #17]
2126:../uvc.c      **** 						 case MFreqCtlID4:
 3524              		.loc 1 2126 0
 3525 1dfc F0FDFFEA 		b	.L284
 3526              	.LVL390:
 3527              	.L371:
2129:../uvc.c      **** 							 is60Hz = Data0;
 3528              		.loc 1 2129 0
 3529 1e00 24C09DE5 		ldr	ip, [sp, #36]
2128:../uvc.c      **** 							 Data0 = Data0 - 1;
 3530              		.loc 1 2128 0
 3531 1e04 055187E0 		add	r5, r7, r5, asl #2
 3532 1e08 208195E5 		ldr	r8, [r5, #288]
 3533              	.LVL391:
2129:../uvc.c      **** 							 is60Hz = Data0;
 3534              		.loc 1 2129 0
 3535 1e0c 01904CE2 		sub	r9, ip, #1
 3536 1e10 FF9009E2 		and	r9, r9, #255
 3537              	.LVL392:
2130:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3538              		.loc 1 2130 0
 3539 1e14 3C359FE5 		ldr	r3, .L452+72
2136:../uvc.c      **** 							 {
 3540              		.loc 1 2136 0
 3541 1e18 020059E3 		cmp	r9, #2
2128:../uvc.c      **** 							 Data0 = Data0 - 1;
 3542              		.loc 1 2128 0
 3543 1e1c 0DC0C8E5 		strb	ip, [r8, #13]
2130:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3544              		.loc 1 2130 0
 3545 1e20 6C9084E5 		str	r9, [r4, #108]
 3546              	.LVL393:
2139:../uvc.c      **** 							 }
 3547              		.loc 1 2139 0
 3548 1e24 0190A083 		movhi	r9, #1
 3549 1e28 6C908385 		strhi	r9, [r3, #108]
 3550              	.LVL394:
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3551              		.loc 1 2141 0
 3552 1e2c 0920A0E1 		mov	r2, r9
 3553 1e30 6C3094E5 		ldr	r3, [r4, #108]
 3554 1e34 0400A0E3 		mov	r0, #4
 3555 1e38 EC149FE5 		ldr	r1, .L452+28
 3556 1e3c FEFFFFEB 		bl	CyU3PDebugPrint
 3557              	.LVL395:
2142:../uvc.c      **** 							 {
 3558              		.loc 1 2142 0
 3559 1e40 883094E5 		ldr	r3, [r4, #136]
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3560              		.loc 1 2141 0
 3561 1e44 0C259FE5 		ldr	r2, .L452+72
2142:../uvc.c      **** 							 {
 3562              		.loc 1 2142 0
 3563 1e48 010053E3 		cmp	r3, #1
 3564 1e4c FB01000A 		beq	.L443
 3565              	.L376:
2170:../uvc.c      **** 							 break;
 3566              		.loc 1 2170 0
 3567 1e50 0130A0E3 		mov	r3, #1
2171:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3568              		.loc 1 2171 0
 3569 1e54 FF70A0E3 		mov	r7, #255
2170:../uvc.c      **** 							 break;
 3570              		.loc 1 2170 0
 3571 1e58 1130C8E5 		strb	r3, [r8, #17]
2171:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3572              		.loc 1 2171 0
 3573 1e5c 07B0A0E1 		mov	fp, r7
 3574              	.LVL396:
 3575 1e60 D7FDFFEA 		b	.L284
 3576              	.LVL397:
 3577              	.L370:
2094:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3578              		.loc 1 2094 0
 3579 1e64 E8449FE5 		ldr	r4, .L452+68
 3580 1e68 0010E0E3 		mvn	r1, #0
 3581 1e6c 1C0094E5 		ldr	r0, [r4, #28]
 3582 1e70 FEFFFFEB 		bl	_txe_mutex_get
 3583              	.LVL398:
2103:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3584              		.loc 1 2103 0
 3585 1e74 24C09DE5 		ldr	ip, [sp, #36]
 3586 1e78 0010A0E3 		mov	r1, #0
 3587 1e7c 0B30A0E1 		mov	r3, fp
 3588 1e80 00C08DE5 		str	ip, [sp]
 3589 1e84 20209DE5 		ldr	r2, [sp, #32]
 3590 1e88 04108DE5 		str	r1, [sp, #4]
 3591 1e8c 0400A0E1 		mov	r0, r4
 3592 1e90 0110A0E3 		mov	r1, #1
 3593 1e94 FEFFFFEB 		bl	cmdSet
 3594              	.LVL399:
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3595              		.loc 1 2106 0
 3596 1e98 055187E0 		add	r5, r7, r5, asl #2
2104:../uvc.c      **** 
 3597              		.loc 1 2104 0
 3598 1e9c 1C0094E5 		ldr	r0, [r4, #28]
 3599 1ea0 FEFFFFEB 		bl	_txe_mutex_put
 3600              	.LVL400:
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3601              		.loc 1 2106 0
 3602 1ea4 203195E5 		ldr	r3, [r5, #288]
 3603 1ea8 24C09DE5 		ldr	ip, [sp, #36]
2107:../uvc.c      **** 							 break;
 3604              		.loc 1 2107 0
 3605 1eac 0120A0E3 		mov	r2, #1
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3606              		.loc 1 2108 0
 3607 1eb0 FF70A0E3 		mov	r7, #255
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3608              		.loc 1 2106 0
 3609 1eb4 0DC0C3E5 		strb	ip, [r3, #13]
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3610              		.loc 1 2108 0
 3611 1eb8 07B0A0E1 		mov	fp, r7
 3612              	.LVL401:
2107:../uvc.c      **** 							 break;
 3613              		.loc 1 2107 0
 3614 1ebc 1120C3E5 		strb	r2, [r3, #17]
 3615              	.LVL402:
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3616              		.loc 1 2108 0
 3617 1ec0 BFFDFFEA 		b	.L284
 3618              	.LVL403:
 3619              	.L368:
2186:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3620              		.loc 1 2186 0
 3621 1ec4 055187E0 		add	r5, r7, r5, asl #2
 3622 1ec8 24109DE5 		ldr	r1, [sp, #36]
 3623 1ecc 205195E5 		ldr	r5, [r5, #288]
2196:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3624              		.loc 1 2196 0
 3625 1ed0 7C449FE5 		ldr	r4, .L452+68
2186:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3626              		.loc 1 2186 0
 3627 1ed4 0D10C5E5 		strb	r1, [r5, #13]
2196:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3628              		.loc 1 2196 0
 3629 1ed8 0010E0E3 		mvn	r1, #0
 3630 1edc 1C0094E5 		ldr	r0, [r4, #28]
 3631 1ee0 18C08DE5 		str	ip, [sp, #24]
 3632 1ee4 FEFFFFEB 		bl	_txe_mutex_get
 3633              	.LVL404:
2197:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3634              		.loc 1 2197 0
 3635 1ee8 24209DE5 		ldr	r2, [sp, #36]
 3636 1eec 18C09DE5 		ldr	ip, [sp, #24]
 3637 1ef0 0010A0E3 		mov	r1, #0
 3638 1ef4 00208DE5 		str	r2, [sp]
 3639 1ef8 0B30A0E1 		mov	r3, fp
 3640 1efc 0C20A0E1 		mov	r2, ip
 3641 1f00 0400A0E1 		mov	r0, r4
 3642 1f04 04108DE5 		str	r1, [sp, #4]
 3643              	.LVL405:
 3644              	.L427:
 3645 1f08 FEFFFFEB 		bl	cmdSet
 3646              	.LVL406:
2198:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3647              		.loc 1 2198 0
 3648 1f0c 1C0094E5 		ldr	r0, [r4, #28]
 3649 1f10 FEFFFFEB 		bl	_txe_mutex_put
 3650              	.LVL407:
2200:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3651              		.loc 1 2200 0
 3652 1f14 FF70A0E3 		mov	r7, #255
2199:../uvc.c      **** 					 		 break;
 3653              		.loc 1 2199 0
 3654 1f18 0130A0E3 		mov	r3, #1
 3655 1f1c 1130C5E5 		strb	r3, [r5, #17]
 3656              	.LVL408:
2200:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3657              		.loc 1 2200 0
 3658 1f20 07B0A0E1 		mov	fp, r7
 3659              	.LVL409:
 3660 1f24 A6FDFFEA 		b	.L284
 3661              	.LVL410:
 3662              	.L304:
1632:../uvc.c      **** 			 	 			 if(Len == 2)
 3663              		.loc 1 1632 0
 3664 1f28 007087E0 		add	r7, r7, r0
 3665 1f2c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 3666 1f30 0C449FE5 		ldr	r4, .L452+52
 3667 1f34 000053E3 		cmp	r3, #0
 3668 1f38 6301000A 		beq	.L311
1633:../uvc.c      **** 			 	 			 {
 3669              		.loc 1 1633 0
 3670 1f3c 020058E3 		cmp	r8, #2
 3671 1f40 5B02000A 		beq	.L444
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3672              		.loc 1 1639 0
 3673 1f44 040058E3 		cmp	r8, #4
 3674 1f48 7BFEFF1A 		bne	.L303
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3675              		.loc 1 1640 0
 3676 1f4c 004184E0 		add	r4, r4, r0, asl #2
 3677 1f50 202194E5 		ldr	r2, [r4, #288]
 3678              	.L422:
 3679 1f54 0DB0D2E5 		ldrb	fp, [r2, #13]	@ zero_extendqisi2
 3680              	.LVL411:
 3681 1f58 F8439FE5 		ldr	r4, .L452+72
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3682              		.loc 1 1641 0
 3683 1f5c 0030A0E3 		mov	r3, #0
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3684              		.loc 1 1640 0
 3685 1f60 FFB00BE2 		and	fp, fp, #255
 3686 1f64 28B0C4E5 		strb	fp, [r4, #40]
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3687              		.loc 1 1641 0
 3688 1f68 2930C4E5 		strb	r3, [r4, #41]
1642:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3689              		.loc 1 1642 0
 3690 1f6c 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3691 1f70 0390A0E1 		mov	r9, r3
 3692 1f74 FF7007E2 		and	r7, r7, #255
 3693 1f78 2A70C4E5 		strb	r7, [r4, #42]
1643:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3694              		.loc 1 1643 0
 3695 1f7c 2B30C4E5 		strb	r3, [r4, #43]
 3696              	.LVL412:
 3697 1f80 03A0A0E1 		mov	r10, r3
 3698 1f84 5EFEFFEA 		b	.L294
 3699              	.LVL413:
 3700              	.L398:
1839:../uvc.c      **** 					 {
 3701              		.loc 1 1839 0
 3702 1f88 FF70A0E3 		mov	r7, #255
 3703 1f8c 07B0A0E1 		mov	fp, r7
 3704              	.LVL414:
 3705 1f90 8BFDFFEA 		b	.L284
 3706              	.LVL415:
 3707              	.L342:
1871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3708              		.loc 1 1871 0
 3709 1f94 B8539FE5 		ldr	r5, .L452+68
 3710 1f98 0010E0E3 		mvn	r1, #0
 3711 1f9c 1C0095E5 		ldr	r0, [r5, #28]
 3712 1fa0 18C08DE5 		str	ip, [sp, #24]
 3713 1fa4 FEFFFFEB 		bl	_txe_mutex_get
 3714              	.LVL416:
1872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3715              		.loc 1 1872 0
 3716 1fa8 18C09DE5 		ldr	ip, [sp, #24]
 3717 1fac 24309DE5 		ldr	r3, [sp, #36]
 3718 1fb0 0080A0E3 		mov	r8, #0
 3719              	.LVL417:
 3720 1fb4 0C20A0E1 		mov	r2, ip
 3721 1fb8 00308DE5 		str	r3, [sp]
 3722 1fbc 1E10A0E3 		mov	r1, #30
 3723 1fc0 0B30A0E1 		mov	r3, fp
 3724 1fc4 0500A0E1 		mov	r0, r5
 3725 1fc8 04808DE5 		str	r8, [sp, #4]
 3726 1fcc FEFFFFEB 		bl	cmdSet
 3727              	.LVL418:
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3728              		.loc 1 1874 0
 3729 1fd0 044187E0 		add	r4, r7, r4, asl #2
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3730              		.loc 1 1873 0
 3731 1fd4 1C0095E5 		ldr	r0, [r5, #28]
 3732 1fd8 FEFFFFEB 		bl	_txe_mutex_put
 3733              	.LVL419:
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3734              		.loc 1 1874 0
 3735 1fdc 203094E5 		ldr	r3, [r4, #32]
 3736 1fe0 24C09DE5 		ldr	ip, [sp, #36]
1876:../uvc.c      **** 							 break;
 3737              		.loc 1 1876 0
 3738 1fe4 0120A0E3 		mov	r2, #1
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3739              		.loc 1 1877 0
 3740 1fe8 FF70A0E3 		mov	r7, #255
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3741              		.loc 1 1874 0
 3742 1fec 0DC0C3E5 		strb	ip, [r3, #13]
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3743              		.loc 1 1877 0
 3744 1ff0 07B0A0E1 		mov	fp, r7
 3745              	.LVL420:
1875:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3746              		.loc 1 1875 0
 3747 1ff4 0E80C3E5 		strb	r8, [r3, #14]
1876:../uvc.c      **** 							 break;
 3748              		.loc 1 1876 0
 3749 1ff8 1120C3E5 		strb	r2, [r3, #17]
 3750              	.LVL421:
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3751              		.loc 1 1877 0
 3752 1ffc 70FDFFEA 		b	.L284
 3753              	.LVL422:
 3754              	.L346:
2013:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3755              		.loc 1 2013 0
 3756 2000 044187E0 		add	r4, r7, r4, asl #2
 3757 2004 207094E5 		ldr	r7, [r4, #32]
 3758 2008 24109DE5 		ldr	r1, [sp, #36]
 3759 200c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3760 2010 010053E1 		cmp	r3, r1
 3761 2014 2100000A 		beq	.L361
2014:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
 3762              		.loc 1 2014 0
 3763 2018 0D10C7E5 		strb	r1, [r7, #13]
2015:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
 3764              		.loc 1 2015 0
 3765 201c 0C00A0E1 		mov	r0, ip
 3766 2020 0B10A0E1 		mov	r1, fp
 3767 2024 18C08DE5 		str	ip, [sp, #24]
 3768 2028 FEFFFFEB 		bl	SensorGetControl
 3769              	.LVL423:
2016:../uvc.c      **** 								 Data0 |= Data1;
 3770              		.loc 1 2016 0
 3771 202c 24209DE5 		ldr	r2, [sp, #36]
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3772              		.loc 1 2018 0
 3773 2030 1C439FE5 		ldr	r4, .L452+68
2016:../uvc.c      **** 								 Data0 |= Data1;
 3774              		.loc 1 2016 0
 3775 2034 0232A0E1 		mov	r3, r2, asl #4
 3776 2038 FF3003E2 		and	r3, r3, #255
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3777              		.loc 1 2018 0
 3778 203c 0010E0E3 		mvn	r1, #0
2019:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3779              		.loc 1 2019 0
 3780 2040 0090A0E3 		mov	r9, #0
2016:../uvc.c      **** 								 Data0 |= Data1;
 3781              		.loc 1 2016 0
 3782 2044 0F0000E2 		and	r0, r0, #15
 3783              	.LVL424:
2017:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3784              		.loc 1 2017 0
 3785 2048 033080E1 		orr	r3, r0, r3
2016:../uvc.c      **** 								 Data0 |= Data1;
 3786              		.loc 1 2016 0
 3787 204c 28008DE5 		str	r0, [sp, #40]
 3788              	.LVL425:
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3789              		.loc 1 2018 0
 3790 2050 1C0094E5 		ldr	r0, [r4, #28]
2017:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3791              		.loc 1 2017 0
 3792 2054 24308DE5 		str	r3, [sp, #36]
 3793              	.LVL426:
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3794              		.loc 1 2018 0
 3795 2058 FEFFFFEB 		bl	_txe_mutex_get
 3796              	.LVL427:
2019:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3797              		.loc 1 2019 0
 3798 205c 18C09DE5 		ldr	ip, [sp, #24]
 3799 2060 24309DE5 		ldr	r3, [sp, #36]
 3800 2064 0C20A0E1 		mov	r2, ip
 3801 2068 2810A0E3 		mov	r1, #40
 3802 206c 00308DE5 		str	r3, [sp]
 3803 2070 04908DE5 		str	r9, [sp, #4]
 3804 2074 0B30A0E1 		mov	r3, fp
 3805 2078 0400A0E1 		mov	r0, r4
 3806 207c FEFFFFEB 		bl	cmdSet
 3807              	.LVL428:
2020:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3808              		.loc 1 2020 0
 3809 2080 1C0094E5 		ldr	r0, [r4, #28]
 3810 2084 FEFFFFEB 		bl	_txe_mutex_put
 3811              	.LVL429:
2021:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3812              		.loc 1 2021 0
 3813 2088 0E90C7E5 		strb	r9, [r7, #14]
2022:../uvc.c      **** 							 }
 3814              		.loc 1 2022 0
 3815 208c 1C0094E5 		ldr	r0, [r4, #28]
 3816 2090 FEFFFFEB 		bl	_txe_mutex_put
 3817              	.LVL430:
 3818 2094 24909DE5 		ldr	r9, [sp, #36]
 3819 2098 28A09DE5 		ldr	r10, [sp, #40]
 3820 209c 18C09DE5 		ldr	ip, [sp, #24]
 3821              	.L361:
2024:../uvc.c      **** 
 3822              		.loc 1 2024 0
 3823 20a0 0130A0E3 		mov	r3, #1
 3824 20a4 1130C7E5 		strb	r3, [r7, #17]
 3825              	.L347:
2037:../uvc.c      **** 				 	 			 {
 3826              		.loc 1 2037 0
 3827 20a8 020058E3 		cmp	r8, #2
 3828 20ac 4701000A 		beq	.L445
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3829              		.loc 1 2047 0
 3830 20b0 040058E3 		cmp	r8, #4
 3831 20b4 D801000A 		beq	.L446
 3832              	.LVL431:
 3833              	.L394:
2252:../uvc.c      **** 			 	 			 break;
 3834              		.loc 1 2252 0
 3835 20b8 0E00D7E5 		ldrb	r0, [r7, #14]	@ zero_extendqisi2
 3836 20bc 0D10D7E5 		ldrb	r1, [r7, #13]	@ zero_extendqisi2
2251:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3837              		.loc 1 2251 0
 3838 20c0 24209DE5 		ldr	r2, [sp, #36]
 3839 20c4 03018DE8 		stmia	sp, {r0, r1, r8}
 3840 20c8 28309DE5 		ldr	r3, [sp, #40]
 3841 20cc 0400A0E3 		mov	r0, #4
 3842 20d0 58129FE5 		ldr	r1, .L452+32
 3843 20d4 FEFFFFEB 		bl	CyU3PDebugPrint
 3844              	.LVL432:
2253:../uvc.c      **** 					 }
 3845              		.loc 1 2253 0
 3846 20d8 FF70A0E3 		mov	r7, #255
 3847 20dc 07B0A0E1 		mov	fp, r7
 3848              	.LVL433:
 3849 20e0 37FDFFEA 		b	.L284
 3850              	.LVL434:
 3851              	.L345:
1842:../uvc.c      **** 							 if(Data0 == 1){
 3852              		.loc 1 1842 0
 3853 20e4 044187E0 		add	r4, r7, r4, asl #2
1843:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3854              		.loc 1 1843 0
 3855 20e8 24209DE5 		ldr	r2, [sp, #36]
1842:../uvc.c      **** 							 if(Data0 == 1){
 3856              		.loc 1 1842 0
 3857 20ec 205094E5 		ldr	r5, [r4, #32]
1844:../uvc.c      **** 							 }else{
 3858              		.loc 1 1844 0
 3859 20f0 58329FE5 		ldr	r3, .L452+64
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3860              		.loc 1 1848 0
 3861 20f4 58429FE5 		ldr	r4, .L452+68
1842:../uvc.c      **** 							 if(Data0 == 1){
 3862              		.loc 1 1842 0
 3863 20f8 0D20C5E5 		strb	r2, [r5, #13]
1844:../uvc.c      **** 							 }else{
 3864              		.loc 1 1844 0
 3865 20fc A995D3E5 		ldrb	r9, [r3, #1449]	@ zero_extendqisi2
1843:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3866              		.loc 1 1843 0
 3867 2100 010052E3 		cmp	r2, #1
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3868              		.loc 1 1848 0
 3869 2104 0010E0E3 		mvn	r1, #0
 3870 2108 1C0094E5 		ldr	r0, [r4, #28]
1844:../uvc.c      **** 							 }else{
 3871              		.loc 1 1844 0
 3872 210c 80908903 		orreq	r9, r9, #128
 3873              	.LVL435:
1846:../uvc.c      **** 							 }
 3874              		.loc 1 1846 0
 3875 2110 7F900912 		andne	r9, r9, #127
 3876              	.LVL436:
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3877              		.loc 1 1848 0
 3878 2114 18C08DE5 		str	ip, [sp, #24]
 3879 2118 FEFFFFEB 		bl	_txe_mutex_get
 3880              	.LVL437:
1849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3881              		.loc 1 1849 0
 3882 211c 18C09DE5 		ldr	ip, [sp, #24]
 3883 2120 0010A0E3 		mov	r1, #0
 3884 2124 04108DE5 		str	r1, [sp, #4]
 3885 2128 00908DE5 		str	r9, [sp]
 3886 212c 0C20A0E1 		mov	r2, ip
 3887 2130 0B30A0E1 		mov	r3, fp
 3888 2134 0400A0E1 		mov	r0, r4
 3889 2138 2610A0E3 		mov	r1, #38
 3890 213c 71FFFFEA 		b	.L427
 3891              	.LVL438:
 3892              	.L341:
1922:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3893              		.loc 1 1922 0
 3894 2140 0CC29FE5 		ldr	ip, .L452+68
 3895 2144 0010E0E3 		mvn	r1, #0
 3896 2148 1C009CE5 		ldr	r0, [ip, #28]
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3897              		.loc 1 1923 0
 3898 214c 044187E0 		add	r4, r7, r4, asl #2
1922:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3899              		.loc 1 1922 0
 3900 2150 2CC08DE5 		str	ip, [sp, #44]
 3901 2154 FEFFFFEB 		bl	_txe_mutex_get
 3902              	.LVL439:
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3903              		.loc 1 1923 0
 3904 2158 203094E5 		ldr	r3, [r4, #32]
 3905 215c 24C09DE5 		ldr	ip, [sp, #36]
 3906 2160 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3907              		.loc 1 1925 0
 3908 2164 E4519FE5 		ldr	r5, .L452+64
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3909              		.loc 1 1923 0
 3910 2168 0C0052E1 		cmp	r2, ip
 3911 216c 0600000A 		beq	.L358
1924:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3912              		.loc 1 1924 0
 3913 2170 0DC0C3E5 		strb	ip, [r3, #13]
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3914              		.loc 1 1925 0
 3915 2174 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3916 2178 010053E3 		cmp	r3, #1
 3917 217c 9C01000A 		beq	.L359
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3918              		.loc 1 1925 0 is_stmt 0 discriminator 1
 3919 2180 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3920 2184 030053E3 		cmp	r3, #3
 3921 2188 9901000A 		beq	.L359
 3922              	.L358:
1932:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3923              		.loc 1 1932 0 is_stmt 1
 3924 218c 2CC09DE5 		ldr	ip, [sp, #44]
1933:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3925              		.loc 1 1933 0
 3926 2190 FF70A0E3 		mov	r7, #255
1932:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3927              		.loc 1 1932 0
 3928 2194 1C009CE5 		ldr	r0, [ip, #28]
 3929 2198 FEFFFFEB 		bl	_txe_mutex_put
 3930              	.LVL440:
1934:../uvc.c      **** 							 break;
 3931              		.loc 1 1934 0
 3932 219c 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
 3933 21a0 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3934 21a4 D115D5E5 		ldrb	r1, [r5, #1489]	@ zero_extendqisi2
1933:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3935              		.loc 1 1933 0
 3936 21a8 0400A0E3 		mov	r0, #4
 3937 21ac 82008DE8 		stmia	sp, {r1, r7}
 3938 21b0 7C119FE5 		ldr	r1, .L452+36
 3939 21b4 08708DE5 		str	r7, [sp, #8]
 3940 21b8 FEFFFFEB 		bl	CyU3PDebugPrint
 3941              	.LVL441:
1935:../uvc.c      **** 
 3942              		.loc 1 1935 0
 3943 21bc 07B0A0E1 		mov	fp, r7
 3944              	.LVL442:
 3945 21c0 FFFCFFEA 		b	.L284
 3946              	.LVL443:
 3947              	.L344:
2001:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3948              		.loc 1 2001 0
 3949 21c4 88419FE5 		ldr	r4, .L452+68
 3950 21c8 0010E0E3 		mvn	r1, #0
 3951 21cc 1C0094E5 		ldr	r0, [r4, #28]
 3952 21d0 18C08DE5 		str	ip, [sp, #24]
 3953 21d4 FEFFFFEB 		bl	_txe_mutex_get
 3954              	.LVL444:
2002:../uvc.c      **** 							 dataIdx++;
 3955              		.loc 1 2002 0
 3956 21d8 24109DE5 		ldr	r1, [sp, #36]
 3957 21dc 18C09DE5 		ldr	ip, [sp, #24]
 3958 21e0 0030A0E3 		mov	r3, #0
 3959 21e4 0C20A0E1 		mov	r2, ip
 3960 21e8 00108DE5 		str	r1, [sp]
 3961 21ec 04308DE5 		str	r3, [sp, #4]
 3962 21f0 2410A0E3 		mov	r1, #36
 3963 21f4 0B30A0E1 		mov	r3, fp
 3964 21f8 0400A0E1 		mov	r0, r4
 3965 21fc FEFFFFEB 		bl	cmdSet
 3966              	.LVL445:
2004:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3967              		.loc 1 2004 0
 3968 2200 28C09DE5 		ldr	ip, [sp, #40]
 3969 2204 0150A0E3 		mov	r5, #1
 3970 2208 0B30A0E1 		mov	r3, fp
 3971 220c 00C08DE5 		str	ip, [sp]
 3972 2210 20209DE5 		ldr	r2, [sp, #32]
 3973 2214 2410A0E3 		mov	r1, #36
 3974 2218 0400A0E1 		mov	r0, r4
 3975 221c 04508DE5 		str	r5, [sp, #4]
 3976 2220 FEFFFFEB 		bl	cmdSet
 3977              	.LVL446:
2005:../uvc.c      **** 							 getData1 = Data1;
 3978              		.loc 1 2005 0
 3979 2224 1C0094E5 		ldr	r0, [r4, #28]
 3980 2228 FEFFFFEB 		bl	_txe_mutex_put
 3981              	.LVL447:
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3982              		.loc 1 2008 0
 3983 222c 1C319FE5 		ldr	r3, .L452+64
 3984 2230 24C09DE5 		ldr	ip, [sp, #36]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 3985              		.loc 1 2011 0
 3986 2234 FF70A0E3 		mov	r7, #255
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3987              		.loc 1 2008 0
 3988 2238 41C5C3E5 		strb	ip, [r3, #1345]
2009:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3989              		.loc 1 2009 0
 3990 223c 28C09DE5 		ldr	ip, [sp, #40]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 3991              		.loc 1 2011 0
 3992 2240 07B0A0E1 		mov	fp, r7
 3993              	.LVL448:
2009:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3994              		.loc 1 2009 0
 3995 2244 42C5C3E5 		strb	ip, [r3, #1346]
2010:../uvc.c      **** 							 break;
 3996              		.loc 1 2010 0
 3997 2248 4555C3E5 		strb	r5, [r3, #1349]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 3998              		.loc 1 2011 0
 3999 224c DCFCFFEA 		b	.L284
 4000              	.LVL449:
 4001              	.L343:
1879:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 4002              		.loc 1 1879 0 discriminator 1
 4003 2250 000058E3 		cmp	r8, #0
 4004 2254 0300000A 		beq	.L351
 4005 2258 D8009FE5 		ldr	r0, .L452+40
 4006 225c 0820A0E1 		mov	r2, r8
 4007 2260 6C1040E2 		sub	r1, r0, #108
 4008 2264 FEFFFFEB 		bl	memcpy
 4009              	.LVL450:
 4010              	.L351:
1883:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4011              		.loc 1 1883 0
 4012 2268 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 							 break;
 4013              		.loc 1 1882 0
 4014 226c FEFFFFEB 		bl	I2CCmdHandler
 4015              	.LVL451:
1883:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4016              		.loc 1 1883 0
 4017 2270 07B0A0E1 		mov	fp, r7
 4018              	.LVL452:
 4019 2274 D2FCFFEA 		b	.L284
 4020              	.LVL453:
 4021              	.L338:
1906:../uvc.c      **** 	#if 1	// register setting directly
 4022              		.loc 1 1906 0
 4023 2278 044187E0 		add	r4, r7, r4, asl #2
 4024 227c 203094E5 		ldr	r3, [r4, #32]
1908:../uvc.c      **** 						     {
 4025              		.loc 1 1908 0
 4026 2280 C8509FE5 		ldr	r5, .L452+64
1906:../uvc.c      **** 	#if 1	// register setting directly
 4027              		.loc 1 1906 0
 4028 2284 24109DE5 		ldr	r1, [sp, #36]
 4029 2288 0D10C3E5 		strb	r1, [r3, #13]
1908:../uvc.c      **** 						     {
 4030              		.loc 1 1908 0
 4031 228c 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 4032 2290 030013E3 		tst	r3, #3
 4033 2294 1200000A 		beq	.L356
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4034              		.loc 1 1910 0
 4035 2298 1995D5E5 		ldrb	r9, [r5, #1305]	@ zero_extendqisi2
1912:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4036              		.loc 1 1912 0
 4037 229c B0409FE5 		ldr	r4, .L452+68
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4038              		.loc 1 1910 0
 4039 22a0 019289E1 		orr	r9, r9, r1, asl #4
1912:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4040              		.loc 1 1912 0
 4041 22a4 1C0094E5 		ldr	r0, [r4, #28]
 4042 22a8 0010E0E3 		mvn	r1, #0
 4043 22ac 18C08DE5 		str	ip, [sp, #24]
 4044 22b0 FEFFFFEB 		bl	_txe_mutex_get
 4045              	.LVL454:
1915:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4046              		.loc 1 1915 0
 4047 22b4 18C09DE5 		ldr	ip, [sp, #24]
 4048 22b8 0010A0E3 		mov	r1, #0
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4049              		.loc 1 1910 0
 4050 22bc FF9009E2 		and	r9, r9, #255
 4051              	.LVL455:
1915:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4052              		.loc 1 1915 0
 4053 22c0 04108DE5 		str	r1, [sp, #4]
 4054 22c4 00908DE5 		str	r9, [sp]
 4055 22c8 0C20A0E1 		mov	r2, ip
 4056 22cc 0B30A0E1 		mov	r3, fp
 4057 22d0 0400A0E1 		mov	r0, r4
 4058 22d4 1010A0E3 		mov	r1, #16
 4059 22d8 FEFFFFEB 		bl	cmdSet
 4060              	.LVL456:
1916:../uvc.c      **** 						     }
 4061              		.loc 1 1916 0
 4062 22dc 1C0094E5 		ldr	r0, [r4, #28]
 4063 22e0 FEFFFFEB 		bl	_txe_mutex_put
 4064              	.LVL457:
 4065              	.L356:
1919:../uvc.c      **** 						     break;
 4066              		.loc 1 1919 0
 4067 22e4 1915D5E5 		ldrb	r1, [r5, #1305]	@ zero_extendqisi2
 4068 22e8 BD35D5E5 		ldrb	r3, [r5, #1469]	@ zero_extendqisi2
1918:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4069              		.loc 1 1918 0
 4070 22ec 28209DE5 		ldr	r2, [sp, #40]
 4071 22f0 0A008DE8 		stmia	sp, {r1, r3}
 4072 22f4 40109FE5 		ldr	r1, .L452+44
 4073 22f8 0400A0E3 		mov	r0, #4
 4074 22fc 0930A0E1 		mov	r3, r9
1920:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 4075              		.loc 1 1920 0
 4076 2300 FF70A0E3 		mov	r7, #255
1918:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4077              		.loc 1 1918 0
 4078 2304 FEFFFFEB 		bl	CyU3PDebugPrint
 4079              	.LVL458:
1920:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 4080              		.loc 1 1920 0
 4081 2308 07B0A0E1 		mov	fp, r7
 4082              	.LVL459:
 4083 230c ACFCFFEA 		b	.L284
 4084              	.L453:
 4085              		.align	2
 4086              	.L452:
 4087 2310 00000000 		.word	bRequest
 4088 2314 68040000 		.word	.LC27
 4089 2318 28000000 		.word	.LANCHOR0+40
 4090 231c 2C060000 		.word	.LC35
 4091 2320 38040000 		.word	.LC26
 4092 2324 D4030000 		.word	.LC24
 4093 2328 FC030000 		.word	.LC25
 4094 232c B8050000 		.word	.LC32
 4095 2330 64050000 		.word	.LC31
 4096 2334 2C050000 		.word	.LC30
 4097 2338 94000000 		.word	.LANCHOR0+148
 4098 233c 00050000 		.word	.LC29
 4099 2340 CC040000 		.word	.LC28
 4100 2344 00000000 		.word	.LANCHOR2
 4101 2348 FC050000 		.word	.LC34
 4102 234c D8050000 		.word	.LC33
 4103 2350 00000000 		.word	.LANCHOR1
 4104 2354 00000000 		.word	cmdQu
 4105 2358 00000000 		.word	.LANCHOR0
 4106              	.LVL460:
 4107              	.L340:
1885:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4108              		.loc 1 1885 0
 4109 235c 10101FE5 		ldr	r1, .L452+68
1886:../uvc.c      **** 							 {
 4110              		.loc 1 1886 0
 4111 2360 044187E0 		add	r4, r7, r4, asl #2
1885:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4112              		.loc 1 1885 0
 4113 2364 2C108DE5 		str	r1, [sp, #44]
 4114 2368 2C209DE5 		ldr	r2, [sp, #44]
 4115 236c 0010E0E3 		mvn	r1, #0
 4116 2370 1C0092E5 		ldr	r0, [r2, #28]
 4117 2374 18C08DE5 		str	ip, [sp, #24]
 4118 2378 FEFFFFEB 		bl	_txe_mutex_get
 4119              	.LVL461:
1886:../uvc.c      **** 							 {
 4120              		.loc 1 1886 0
 4121 237c 204094E5 		ldr	r4, [r4, #32]
 4122 2380 24109DE5 		ldr	r1, [sp, #36]
 4123 2384 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4124              		.loc 1 1889 0
 4125 2388 40501FE5 		ldr	r5, .L452+64
1886:../uvc.c      **** 							 {
 4126              		.loc 1 1886 0
 4127 238c 010053E1 		cmp	r3, r1
 4128 2390 18C09DE5 		ldr	ip, [sp, #24]
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 4129              		.loc 1 1835 0
 4130 2394 0020A003 		moveq	r2, #0
1886:../uvc.c      **** 							 {
 4131              		.loc 1 1886 0
 4132 2398 0F00000A 		beq	.L352
1888:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4133              		.loc 1 1888 0
 4134 239c 0D10C4E5 		strb	r1, [r4, #13]
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4135              		.loc 1 1889 0
 4136 23a0 BD25D5E5 		ldrb	r2, [r5, #1469]	@ zero_extendqisi2
1890:../uvc.c      **** 								 dataIdx++;
 4137              		.loc 1 1890 0
 4138 23a4 0030A0E3 		mov	r3, #0
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4139              		.loc 1 1889 0
 4140 23a8 022281E1 		orr	r2, r1, r2, asl #4
 4141 23ac FF2002E2 		and	r2, r2, #255
 4142 23b0 24208DE5 		str	r2, [sp, #36]
 4143              	.LVL462:
1890:../uvc.c      **** 								 dataIdx++;
 4144              		.loc 1 1890 0
 4145 23b4 0C20A0E1 		mov	r2, ip
 4146 23b8 24C09DE5 		ldr	ip, [sp, #36]
 4147 23bc 04308DE5 		str	r3, [sp, #4]
 4148 23c0 00C08DE5 		str	ip, [sp]
 4149 23c4 2C009DE5 		ldr	r0, [sp, #44]
 4150 23c8 1910A0E3 		mov	r1, #25
 4151 23cc 0B30A0E1 		mov	r3, fp
 4152 23d0 FEFFFFEB 		bl	cmdSet
 4153              	.LVL463:
 4154 23d4 24909DE5 		ldr	r9, [sp, #36]
1891:../uvc.c      **** 							 }
 4155              		.loc 1 1891 0
 4156 23d8 0120A0E3 		mov	r2, #1
 4157              	.LVL464:
 4158              	.L352:
1893:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4159              		.loc 1 1893 0
 4160 23dc 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
 4161 23e0 28C09DE5 		ldr	ip, [sp, #40]
 4162 23e4 0C0053E1 		cmp	r3, ip
 4163 23e8 0600000A 		beq	.L354
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4164              		.loc 1 1895 0
 4165 23ec 24C09DE5 		ldr	ip, [sp, #36]
 4166 23f0 02304CE2 		sub	r3, ip, #2
1894:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 4167              		.loc 1 1894 0
 4168 23f4 28C09DE5 		ldr	ip, [sp, #40]
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4169              		.loc 1 1895 0
 4170 23f8 FF3003E2 		and	r3, r3, #255
 4171 23fc 010053E3 		cmp	r3, #1
1894:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 4172              		.loc 1 1894 0
 4173 2400 0EC0C4E5 		strb	ip, [r4, #14]
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4174              		.loc 1 1895 0
 4175 2404 5001009A 		bls	.L447
 4176              	.LVL465:
 4177              	.L354:
1900:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4178              		.loc 1 1900 0
 4179 2408 2CC09DE5 		ldr	ip, [sp, #44]
1899:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4180              		.loc 1 1899 0
 4181 240c 0130A0E3 		mov	r3, #1
 4182 2410 1130C4E5 		strb	r3, [r4, #17]
1900:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4183              		.loc 1 1900 0
 4184 2414 1C009CE5 		ldr	r0, [ip, #28]
 4185 2418 FEFFFFEB 		bl	_txe_mutex_put
 4186              	.LVL466:
1901:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 4187              		.loc 1 1901 0
 4188 241c 24C09DE5 		ldr	ip, [sp, #36]
1902:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 4189              		.loc 1 1902 0
 4190 2420 0D20D4E5 		ldrb	r2, [r4, #13]	@ zero_extendqisi2
 4191 2424 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
1903:../uvc.c      **** 							 break;
 4192              		.loc 1 1903 0
 4193 2428 BD15D5E5 		ldrb	r1, [r5, #1469]	@ zero_extendqisi2
1901:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 4194              		.loc 1 1901 0
 4195 242c 04C08DE5 		str	ip, [sp, #4]
 4196 2430 28C09DE5 		ldr	ip, [sp, #40]
 4197 2434 00108DE5 		str	r1, [sp]
 4198 2438 08C08DE5 		str	ip, [sp, #8]
 4199 243c 0400A0E3 		mov	r0, #4
 4200 2440 08111FE5 		ldr	r1, .L452+48
 4201 2444 FEFFFFEB 		bl	CyU3PDebugPrint
 4202              	.LVL467:
1904:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 4203              		.loc 1 1904 0
 4204 2448 FF70A0E3 		mov	r7, #255
 4205 244c 07B0A0E1 		mov	fp, r7
 4206              	.LVL468:
 4207 2450 5BFCFFEA 		b	.L284
 4208              	.LVL469:
 4209              	.L286:
1482:../uvc.c      **** 			 	 			 if(Len == 2)
 4210              		.loc 1 1482 0
 4211 2454 007087E0 		add	r7, r7, r0
 4212 2458 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 4213 245c 20411FE5 		ldr	r4, .L452+52
 4214 2460 000053E3 		cmp	r3, #0
 4215 2464 3500000A 		beq	.L299
1483:../uvc.c      **** 			 	 			 {
 4216              		.loc 1 1483 0
 4217 2468 020058E3 		cmp	r8, #2
 4218 246c 1C01000A 		beq	.L448
1489:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 4219              		.loc 1 1489 0
 4220 2470 040058E3 		cmp	r8, #4
 4221 2474 30FDFF1A 		bne	.L303
1490:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4222              		.loc 1 1490 0
 4223 2478 004184E0 		add	r4, r4, r0, asl #2
 4224 247c 202014E5 		ldr	r2, [r4, #-32]
 4225 2480 B3FEFFEA 		b	.L422
 4226              	.LVL470:
 4227              	.L367:
2225:../uvc.c      **** 			 	 			 {
 4228              		.loc 1 2225 0
 4229 2484 020058E3 		cmp	r8, #2
 4230 2488 CB00000A 		beq	.L449
2235:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 4231              		.loc 1 2235 0
 4232 248c 040058E3 		cmp	r8, #4
 4233 2490 2401000A 		beq	.L395
 4234 2494 055187E0 		add	r5, r7, r5, asl #2
 4235 2498 207195E5 		ldr	r7, [r5, #288]
 4236 249c 05FFFFEA 		b	.L394
 4237              	.L337:
 4238 24a0 044187E0 		add	r4, r7, r4, asl #2
 4239 24a4 207094E5 		ldr	r7, [r4, #32]
 4240 24a8 FEFEFFEA 		b	.L347
 4241              	.LVL471:
 4242              	.L333:
2257:../uvc.c      **** 			   }
 4243              		.loc 1 2257 0
 4244 24ac 0400A0E3 		mov	r0, #4
 4245              	.LVL472:
 4246 24b0 70111FE5 		ldr	r1, .L452+56
 4247 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4248              	.LVL473:
 4249 24b8 FF70A0E3 		mov	r7, #255
 4250 24bc 0090A0E3 		mov	r9, #0
 4251 24c0 07B0A0E1 		mov	fp, r7
 4252              	.LVL474:
 4253 24c4 09A0A0E1 		mov	r10, r9
 4254 24c8 3DFCFFEA 		b	.L284
 4255              	.LVL475:
 4256              	.L311:
1648:../uvc.c      **** 			 	 			 {
 4257              		.loc 1 1648 0
 4258 24cc 020058E3 		cmp	r8, #2
 4259 24d0 2501000A 		beq	.L450
1656:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4260              		.loc 1 1656 0
 4261 24d4 040058E3 		cmp	r8, #4
 4262 24d8 17FDFF1A 		bne	.L303
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4263              		.loc 1 1657 0
 4264 24dc 0B10A0E1 		mov	r1, fp
 4265 24e0 20009DE5 		ldr	r0, [sp, #32]
 4266              	.LVL476:
 4267 24e4 1C308DE5 		str	r3, [sp, #28]
 4268 24e8 18C08DE5 		str	ip, [sp, #24]
 4269 24ec FEFFFFEB 		bl	SensorGetControl
 4270              	.LVL477:
1658:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4271              		.loc 1 1658 0
 4272 24f0 054184E0 		add	r4, r4, r5, asl #2
 4273 24f4 205194E5 		ldr	r5, [r4, #288]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4274              		.loc 1 1659 0
 4275 24f8 18C09DE5 		ldr	ip, [sp, #24]
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4276              		.loc 1 1657 0
 4277 24fc AC411FE5 		ldr	r4, .L452+72
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4278              		.loc 1 1659 0
 4279 2500 0B10A0E1 		mov	r1, fp
 4280 2504 0090A0E3 		mov	r9, #0
 4281 2508 09A0A0E1 		mov	r10, r9
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4282              		.loc 1 1657 0
 4283 250c 0020A0E1 		mov	r2, r0
 4284 2510 2820C4E5 		strb	r2, [r4, #40]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4285              		.loc 1 1659 0
 4286 2514 0C00A0E1 		mov	r0, ip
1658:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4287              		.loc 1 1658 0
 4288 2518 0D20C5E5 		strb	r2, [r5, #13]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4289              		.loc 1 1659 0
 4290 251c FEFFFFEB 		bl	SensorGetControl
 4291              	.LVL478:
 4292 2520 2A00C4E5 		strb	r0, [r4, #42]
1660:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4293              		.loc 1 1660 0
 4294 2524 0E00C5E5 		strb	r0, [r5, #14]
1661:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4295              		.loc 1 1661 0
 4296 2528 1C309DE5 		ldr	r3, [sp, #28]
 4297 252c 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 4298              	.LVL479:
 4299 2530 0070A0E1 		mov	r7, r0
 4300 2534 2930C4E5 		strb	r3, [r4, #41]
1662:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4301              		.loc 1 1662 0
 4302 2538 2B30C4E5 		strb	r3, [r4, #43]
 4303              	.LVL480:
 4304 253c F0FCFFEA 		b	.L294
 4305              	.LVL481:
 4306              	.L299:
1498:../uvc.c      **** 			 	 			 {
 4307              		.loc 1 1498 0
 4308 2540 020058E3 		cmp	r8, #2
 4309 2544 1901000A 		beq	.L451
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4310              		.loc 1 1506 0
 4311 2548 040058E3 		cmp	r8, #4
 4312 254c FAFCFF1A 		bne	.L303
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4313              		.loc 1 1507 0
 4314 2550 0B10A0E1 		mov	r1, fp
 4315 2554 20009DE5 		ldr	r0, [sp, #32]
 4316              	.LVL482:
 4317 2558 1C308DE5 		str	r3, [sp, #28]
 4318 255c 18C08DE5 		str	ip, [sp, #24]
 4319 2560 FEFFFFEB 		bl	SensorGetControl
 4320              	.LVL483:
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4321              		.loc 1 1508 0
 4322 2564 054184E0 		add	r4, r4, r5, asl #2
 4323 2568 205014E5 		ldr	r5, [r4, #-32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4324              		.loc 1 1509 0
 4325 256c 18C09DE5 		ldr	ip, [sp, #24]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4326              		.loc 1 1507 0
 4327 2570 20421FE5 		ldr	r4, .L452+72
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4328              		.loc 1 1509 0
 4329 2574 0B10A0E1 		mov	r1, fp
 4330 2578 0090A0E3 		mov	r9, #0
 4331 257c 09A0A0E1 		mov	r10, r9
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4332              		.loc 1 1507 0
 4333 2580 0020A0E1 		mov	r2, r0
 4334 2584 2820C4E5 		strb	r2, [r4, #40]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4335              		.loc 1 1509 0
 4336 2588 0C00A0E1 		mov	r0, ip
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4337              		.loc 1 1508 0
 4338 258c 0D20C5E5 		strb	r2, [r5, #13]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4339              		.loc 1 1509 0
 4340 2590 FEFFFFEB 		bl	SensorGetControl
 4341              	.LVL484:
 4342 2594 2A00C4E5 		strb	r0, [r4, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4343              		.loc 1 1510 0
 4344 2598 0E00C5E5 		strb	r0, [r5, #14]
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4345              		.loc 1 1511 0
 4346 259c 1C309DE5 		ldr	r3, [sp, #28]
 4347 25a0 0070A0E1 		mov	r7, r0
 4348 25a4 2930C4E5 		strb	r3, [r4, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4349              		.loc 1 1512 0
 4350 25a8 2B30C4E5 		strb	r3, [r4, #43]
 4351              	.LVL485:
 4352 25ac 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 4353              	.LVL486:
 4354 25b0 D3FCFFEA 		b	.L294
 4355              	.LVL487:
 4356              	.L390:
2215:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4357              		.loc 1 2215 0
 4358 25b4 FEFFFFEB 		bl	_txe_mutex_get
 4359              	.LVL488:
2216:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4360              		.loc 1 2216 0
 4361 25b8 24109DE5 		ldr	r1, [sp, #36]
 4362 25bc 18C09DE5 		ldr	ip, [sp, #24]
 4363 25c0 00108DE5 		str	r1, [sp]
 4364 25c4 04108DE5 		str	r1, [sp, #4]
 4365 25c8 0C20A0E1 		mov	r2, ip
 4366 25cc ABFDFFEA 		b	.L426
 4367              	.L445:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4368              		.loc 1 2039 0
 4369 25d0 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4370 25d4 24109DE5 		ldr	r1, [sp, #36]
 4371 25d8 010053E1 		cmp	r3, r1
 4372 25dc 1400000A 		beq	.L393
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4373              		.loc 1 2040 0
 4374 25e0 94421FE5 		ldr	r4, .L452+68
 4375 25e4 0010E0E3 		mvn	r1, #0
 4376 25e8 1C0094E5 		ldr	r0, [r4, #28]
 4377 25ec 18C08DE5 		str	ip, [sp, #24]
 4378 25f0 FEFFFFEB 		bl	_txe_mutex_get
 4379              	.LVL489:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4380              		.loc 1 2041 0
 4381 25f4 24209DE5 		ldr	r2, [sp, #36]
 4382 25f8 00208DE5 		str	r2, [sp]
 4383              	.L429:
2229:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4384              		.loc 1 2229 0
 4385 25fc 18C09DE5 		ldr	ip, [sp, #24]
 4386 2600 0510A0E1 		mov	r1, r5
 4387 2604 0C20A0E1 		mov	r2, ip
 4388 2608 00C0A0E3 		mov	ip, #0
 4389 260c 04C08DE5 		str	ip, [sp, #4]
 4390 2610 0B30A0E1 		mov	r3, fp
 4391 2614 0400A0E1 		mov	r0, r4
 4392 2618 FEFFFFEB 		bl	cmdSet
 4393              	.LVL490:
2230:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4394              		.loc 1 2230 0
 4395 261c 1C0094E5 		ldr	r0, [r4, #28]
 4396 2620 FEFFFFEB 		bl	_txe_mutex_put
 4397              	.LVL491:
2231:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4398              		.loc 1 2231 0
 4399 2624 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 								 }
 4400              		.loc 1 2232 0
 4401 2628 0010A0E3 		mov	r1, #0
2231:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4402              		.loc 1 2231 0
 4403 262c 0DC0C7E5 		strb	ip, [r7, #13]
 4404              	.LVL492:
2232:../uvc.c      **** 								 }
 4405              		.loc 1 2232 0
 4406 2630 0E10C7E5 		strb	r1, [r7, #14]
 4407              	.L393:
2234:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4408              		.loc 1 2234 0
 4409 2634 0130A0E3 		mov	r3, #1
 4410 2638 1130C7E5 		strb	r3, [r7, #17]
 4411 263c 9DFEFFEA 		b	.L394
 4412              	.LVL493:
 4413              	.L443:
2144:../uvc.c      **** 			                         {
 4414              		.loc 1 2144 0
 4415 2640 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4416 2644 013043E2 		sub	r3, r3, #1
 4417 2648 030053E3 		cmp	r3, #3
 4418 264c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4419 2650 FEFDFFEA 		b	.L376
 4420              	.L378:
 4421 2654 70270000 		.word	.L377
 4422 2658 24270000 		.word	.L379
 4423 265c C4260000 		.word	.L380
 4424 2660 64260000 		.word	.L381
 4425              	.L381:
2162:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4426              		.loc 1 2162 0
 4427 2664 1C531FE5 		ldr	r5, .L452+64
 4428 2668 6C2094E5 		ldr	r2, [r4, #108]
 4429 266c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4430 2670 000052E3 		cmp	r2, #0
 4431 2674 B020A003 		moveq	r2, #176
 4432 2678 3020A013 		movne	r2, #48
 4433 267c 032082E1 		orr	r2, r2, r3
 4434 2680 3010A0E3 		mov	r1, #48
 4435 2684 5230A0E3 		mov	r3, #82
 4436 2688 0100A0E3 		mov	r0, #1
 4437 268c FEFFFFEB 		bl	SensorSetIrisControl
 4438              	.LVL494:
2163:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4439              		.loc 1 2163 0
 4440 2690 7D0FA0E3 		mov	r0, #500
 4441 2694 FEFFFFEB 		bl	_tx_thread_sleep
 4442              	.LVL495:
2164:../uvc.c      **** 			                         	default:
 4443              		.loc 1 2164 0
 4444 2698 6C1094E5 		ldr	r1, [r4, #108]
 4445 269c 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4446 26a0 000051E3 		cmp	r1, #0
 4447 26a4 B010A003 		moveq	r1, #176
 4448 26a8 3010A013 		movne	r1, #48
 4449 26ac 022081E1 		orr	r2, r1, r2
 4450 26b0 6C3094E5 		ldr	r3, [r4, #108]
 4451 26b4 70131FE5 		ldr	r1, .L452+60
 4452 26b8 0400A0E3 		mov	r0, #4
 4453 26bc FEFFFFEB 		bl	CyU3PDebugPrint
 4454              	.LVL496:
 4455 26c0 E2FDFFEA 		b	.L376
 4456              	.L380:
2157:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4457              		.loc 1 2157 0
 4458 26c4 7C531FE5 		ldr	r5, .L452+64
 4459 26c8 6C2094E5 		ldr	r2, [r4, #108]
 4460 26cc 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4461 26d0 000052E3 		cmp	r2, #0
 4462 26d4 8020A003 		moveq	r2, #128
 4463 26d8 0020A013 		movne	r2, #0
 4464 26dc 032082E1 		orr	r2, r2, r3
 4465 26e0 3010A0E3 		mov	r1, #48
 4466 26e4 5230A0E3 		mov	r3, #82
 4467 26e8 0100A0E3 		mov	r0, #1
 4468 26ec FEFFFFEB 		bl	SensorSetIrisControl
 4469              	.LVL497:
2158:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4470              		.loc 1 2158 0
 4471 26f0 7D0FA0E3 		mov	r0, #500
 4472 26f4 FEFFFFEB 		bl	_tx_thread_sleep
 4473              	.LVL498:
2159:../uvc.c      **** 			                         		break;
 4474              		.loc 1 2159 0
 4475 26f8 6C1094E5 		ldr	r1, [r4, #108]
 4476 26fc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4477 2700 000051E3 		cmp	r1, #0
 4478 2704 8010A003 		moveq	r1, #128
 4479 2708 0010A013 		movne	r1, #0
 4480 270c 022081E1 		orr	r2, r1, r2
 4481 2710 6C3094E5 		ldr	r3, [r4, #108]
 4482 2714 D0131FE5 		ldr	r1, .L452+60
 4483 2718 0400A0E3 		mov	r0, #4
 4484 271c FEFFFFEB 		bl	CyU3PDebugPrint
 4485              	.LVL499:
2160:../uvc.c      **** 			                         	case 4: //VGA
 4486              		.loc 1 2160 0
 4487 2720 CAFDFFEA 		b	.L376
 4488              	.L379:
2152:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4489              		.loc 1 2152 0
 4490 2724 6C2094E5 		ldr	r2, [r4, #108]
 4491 2728 3010A0E3 		mov	r1, #48
 4492 272c 000052E3 		cmp	r2, #0
 4493 2730 9220A003 		moveq	r2, #146
 4494 2734 1220A013 		movne	r2, #18
 4495 2738 5230A0E3 		mov	r3, #82
 4496 273c 0100A0E3 		mov	r0, #1
 4497 2740 FEFFFFEB 		bl	SensorSetIrisControl
 4498              	.LVL500:
2153:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4499              		.loc 1 2153 0
 4500 2744 7D0FA0E3 		mov	r0, #500
 4501 2748 FEFFFFEB 		bl	_tx_thread_sleep
 4502              	.LVL501:
2154:../uvc.c      **** 			                         		break;
 4503              		.loc 1 2154 0
 4504 274c 6C2094E5 		ldr	r2, [r4, #108]
 4505 2750 0C141FE5 		ldr	r1, .L452+60
 4506 2754 000052E3 		cmp	r2, #0
 4507 2758 6C3094E5 		ldr	r3, [r4, #108]
 4508 275c 9220A003 		moveq	r2, #146
 4509 2760 1220A013 		movne	r2, #18
 4510 2764 0400A0E3 		mov	r0, #4
 4511 2768 FEFFFFEB 		bl	CyU3PDebugPrint
 4512              	.LVL502:
2155:../uvc.c      **** 			                         	case 3: //720
 4513              		.loc 1 2155 0
 4514 276c B7FDFFEA 		b	.L376
 4515              	.L377:
2147:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4516              		.loc 1 2147 0
 4517 2770 6C2094E5 		ldr	r2, [r4, #108]
 4518 2774 3010A0E3 		mov	r1, #48
 4519 2778 000052E3 		cmp	r2, #0
 4520 277c A220A003 		moveq	r2, #162
 4521 2780 2220A013 		movne	r2, #34
 4522 2784 5230A0E3 		mov	r3, #82
 4523 2788 0100A0E3 		mov	r0, #1
 4524 278c FEFFFFEB 		bl	SensorSetIrisControl
 4525              	.LVL503:
2148:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4526              		.loc 1 2148 0
 4527 2790 7D0FA0E3 		mov	r0, #500
 4528 2794 FEFFFFEB 		bl	_tx_thread_sleep
 4529              	.LVL504:
2149:../uvc.c      **** 			                         		break;
 4530              		.loc 1 2149 0
 4531 2798 6C2094E5 		ldr	r2, [r4, #108]
 4532 279c 58141FE5 		ldr	r1, .L452+60
 4533 27a0 000052E3 		cmp	r2, #0
 4534 27a4 6C3094E5 		ldr	r3, [r4, #108]
 4535 27a8 A220A003 		moveq	r2, #162
 4536 27ac 2220A013 		movne	r2, #34
 4537 27b0 0400A0E3 		mov	r0, #4
 4538 27b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4539              	.LVL505:
2150:../uvc.c      **** 			                         	case 2: //1080
 4540              		.loc 1 2150 0
 4541 27b8 A4FDFFEA 		b	.L376
 4542              	.LVL506:
 4543              	.L449:
2227:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4544              		.loc 1 2227 0
 4545 27bc 057187E0 		add	r7, r7, r5, asl #2
 4546 27c0 207197E5 		ldr	r7, [r7, #288]
 4547 27c4 24209DE5 		ldr	r2, [sp, #36]
 4548 27c8 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4549 27cc 020053E1 		cmp	r3, r2
 4550 27d0 97FFFF0A 		beq	.L393
2228:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4551              		.loc 1 2228 0
 4552 27d4 88441FE5 		ldr	r4, .L452+68
 4553 27d8 0010E0E3 		mvn	r1, #0
 4554 27dc 1C0094E5 		ldr	r0, [r4, #28]
 4555 27e0 18C08DE5 		str	ip, [sp, #24]
 4556 27e4 FEFFFFEB 		bl	_txe_mutex_get
 4557              	.LVL507:
2229:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4558              		.loc 1 2229 0
 4559 27e8 24309DE5 		ldr	r3, [sp, #36]
 4560 27ec 00308DE5 		str	r3, [sp]
 4561 27f0 81FFFFEA 		b	.L429
 4562              	.L359:
1928:../uvc.c      **** 								 }
 4563              		.loc 1 1928 0
 4564 27f4 24C09DE5 		ldr	ip, [sp, #36]
 4565 27f8 0010A0E3 		mov	r1, #0
 4566 27fc 04108DE5 		str	r1, [sp, #4]
 4567 2800 00C08DE5 		str	ip, [sp]
 4568 2804 20209DE5 		ldr	r2, [sp, #32]
 4569 2808 0B30A0E1 		mov	r3, fp
 4570 280c 1B10A0E3 		mov	r1, #27
 4571 2810 C4041FE5 		ldr	r0, .L452+68
 4572 2814 FEFFFFEB 		bl	cmdSet
 4573              	.LVL508:
 4574 2818 5BFEFFEA 		b	.L358
 4575              	.L446:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4576              		.loc 1 2048 0
 4577 281c D0241FE5 		ldr	r2, .L452+68
 4578 2820 0010E0E3 		mvn	r1, #0
 4579 2824 1C0092E5 		ldr	r0, [r2, #28]
 4580 2828 2C208DE5 		str	r2, [sp, #44]
 4581 282c 18C08DE5 		str	ip, [sp, #24]
 4582 2830 FEFFFFEB 		bl	_txe_mutex_get
 4583              	.LVL509:
 4584              	.L434:
2237:../uvc.c      **** 								 {
 4585              		.loc 1 2237 0
 4586 2834 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4587 2838 24109DE5 		ldr	r1, [sp, #36]
 4588 283c 18C09DE5 		ldr	ip, [sp, #24]
 4589 2840 010053E1 		cmp	r3, r1
2240:../uvc.c      **** 									 dataIdx++;
 4590              		.loc 1 2240 0
 4591 2844 0030A0E3 		mov	r3, #0
2237:../uvc.c      **** 								 {
 4592              		.loc 1 2237 0
 4593 2848 0700000A 		beq	.L396
2239:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4594              		.loc 1 2239 0
 4595 284c 0D10C7E5 		strb	r1, [r7, #13]
 4596              	.LVL510:
2240:../uvc.c      **** 									 dataIdx++;
 4597              		.loc 1 2240 0
 4598 2850 0C20A0E1 		mov	r2, ip
 4599 2854 0A008DE8 		stmia	sp, {r1, r3}
 4600 2858 2C009DE5 		ldr	r0, [sp, #44]
 4601 285c 0B30A0E1 		mov	r3, fp
 4602 2860 0510A0E1 		mov	r1, r5
 4603 2864 FEFFFFEB 		bl	cmdSet
 4604              	.LVL511:
2241:../uvc.c      **** 								 }
 4605              		.loc 1 2241 0
 4606 2868 0130A0E3 		mov	r3, #1
 4607              	.LVL512:
 4608              	.L396:
2243:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4609              		.loc 1 2243 0
 4610 286c 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4611 2870 28C09DE5 		ldr	ip, [sp, #40]
 4612 2874 0C0052E1 		cmp	r2, ip
 4613 2878 0700000A 		beq	.L397
2244:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4614              		.loc 1 2244 0
 4615 287c 0EC0C7E5 		strb	ip, [r7, #14]
2245:../uvc.c      **** 								 }
 4616              		.loc 1 2245 0
 4617 2880 0510A0E1 		mov	r1, r5
 4618 2884 04308DE5 		str	r3, [sp, #4]
 4619 2888 00C08DE5 		str	ip, [sp]
 4620 288c 20209DE5 		ldr	r2, [sp, #32]
 4621 2890 0B30A0E1 		mov	r3, fp
 4622              	.LVL513:
 4623 2894 48051FE5 		ldr	r0, .L452+68
 4624 2898 FEFFFFEB 		bl	cmdSet
 4625              	.LVL514:
 4626              	.L397:
2247:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4627              		.loc 1 2247 0
 4628 289c 0130A0E3 		mov	r3, #1
 4629 28a0 1130C7E5 		strb	r3, [r7, #17]
2248:../uvc.c      **** 
 4630              		.loc 1 2248 0
 4631 28a4 2CC09DE5 		ldr	ip, [sp, #44]
 4632 28a8 1C009CE5 		ldr	r0, [ip, #28]
 4633 28ac FEFFFFEB 		bl	_txe_mutex_put
 4634              	.LVL515:
 4635 28b0 00FEFFEA 		b	.L394
 4636              	.LVL516:
 4637              	.L444:
1635:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4638              		.loc 1 1635 0
 4639 28b4 004184E0 		add	r4, r4, r0, asl #2
 4640 28b8 203194E5 		ldr	r3, [r4, #288]
 4641              	.L421:
 4642 28bc 0DB0D3E5 		ldrb	fp, [r3, #13]	@ zero_extendqisi2
 4643              	.LVL517:
 4644 28c0 70451FE5 		ldr	r4, .L452+72
 4645 28c4 FFB00BE2 		and	fp, fp, #255
 4646 28c8 28B0C4E5 		strb	fp, [r4, #40]
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4647              		.loc 1 1636 0
 4648 28cc 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4649 28d0 0090A0E3 		mov	r9, #0
 4650 28d4 FF7007E2 		and	r7, r7, #255
 4651 28d8 2970C4E5 		strb	r7, [r4, #41]
 4652              	.LVL518:
 4653 28dc 09A0A0E1 		mov	r10, r9
 4654 28e0 07FCFFEA 		b	.L294
 4655              	.LVL519:
 4656              	.L448:
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4657              		.loc 1 1485 0
 4658 28e4 004184E0 		add	r4, r4, r0, asl #2
 4659 28e8 203014E5 		ldr	r3, [r4, #-32]
 4660 28ec F2FFFFEA 		b	.L421
 4661              	.L442:
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4662              		.loc 1 1617 0
 4663 28f0 0B10A0E1 		mov	r1, fp
 4664 28f4 20009DE5 		ldr	r0, [sp, #32]
 4665              	.LVL520:
 4666 28f8 FEFFFFEB 		bl	SensorGetControl
 4667              	.LVL521:
 4668 28fc AC451FE5 		ldr	r4, .L452+72
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4669              		.loc 1 1618 0
 4670 2900 B8351FE5 		ldr	r3, .L452+64
1619:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4671              		.loc 1 1619 0
 4672 2904 0070A0E3 		mov	r7, #0
 4673 2908 2970C4E5 		strb	r7, [r4, #41]
 4674 290c 0790A0E1 		mov	r9, r7
 4675 2910 07A0A0E1 		mov	r10, r7
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4676              		.loc 1 1618 0
 4677 2914 9505C3E5 		strb	r0, [r3, #1429]
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4678              		.loc 1 1617 0
 4679 2918 2800C4E5 		strb	r0, [r4, #40]
1620:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4680              		.loc 1 1620 0
 4681 291c 9675C3E5 		strb	r7, [r3, #1430]
 4682              	.LVL522:
 4683 2920 00B0A0E1 		mov	fp, r0
 4684              	.LVL523:
 4685 2924 F6FBFFEA 		b	.L294
 4686              	.LVL524:
 4687              	.L395:
2236:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4688              		.loc 1 2236 0
 4689 2928 DC251FE5 		ldr	r2, .L452+68
 4690 292c 0010E0E3 		mvn	r1, #0
 4691 2930 1C0092E5 		ldr	r0, [r2, #28]
2237:../uvc.c      **** 								 {
 4692              		.loc 1 2237 0
 4693 2934 057187E0 		add	r7, r7, r5, asl #2
2236:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4694              		.loc 1 2236 0
 4695 2938 2C208DE5 		str	r2, [sp, #44]
 4696 293c 18C08DE5 		str	ip, [sp, #24]
 4697 2940 FEFFFFEB 		bl	_txe_mutex_get
 4698              	.LVL525:
2237:../uvc.c      **** 								 {
 4699              		.loc 1 2237 0
 4700 2944 207197E5 		ldr	r7, [r7, #288]
 4701 2948 B9FFFFEA 		b	.L434
 4702              	.LVL526:
 4703              	.L447:
1896:../uvc.c      **** 								 }
 4704              		.loc 1 1896 0
 4705 294c 04208DE5 		str	r2, [sp, #4]
 4706 2950 00C08DE5 		str	ip, [sp]
 4707 2954 20209DE5 		ldr	r2, [sp, #32]
 4708              	.LVL527:
 4709 2958 0B30A0E1 		mov	r3, fp
 4710 295c 1910A0E3 		mov	r1, #25
 4711 2960 14061FE5 		ldr	r0, .L452+68
 4712 2964 FEFFFFEB 		bl	cmdSet
 4713              	.LVL528:
 4714 2968 A6FEFFEA 		b	.L354
 4715              	.LVL529:
 4716              	.L450:
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4717              		.loc 1 1650 0
 4718 296c 0C00A0E1 		mov	r0, ip
 4719              	.LVL530:
 4720 2970 0B10A0E1 		mov	r1, fp
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4721              		.loc 1 1651 0
 4722 2974 054184E0 		add	r4, r4, r5, asl #2
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4723              		.loc 1 1650 0
 4724 2978 1C308DE5 		str	r3, [sp, #28]
 4725 297c FEFFFFEB 		bl	SensorGetControl
 4726              	.LVL531:
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4727              		.loc 1 1651 0
 4728 2980 202194E5 		ldr	r2, [r4, #288]
 4729              	.L420:
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4730              		.loc 1 1650 0
 4731 2984 34461FE5 		ldr	r4, .L452+72
 4732 2988 0090A0E3 		mov	r9, #0
 4733 298c 2800C4E5 		strb	r0, [r4, #40]
 4734 2990 1C309DE5 		ldr	r3, [sp, #28]
 4735 2994 00B0A0E1 		mov	fp, r0
 4736              	.LVL532:
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4737              		.loc 1 1651 0
 4738 2998 0D00C2E5 		strb	r0, [r2, #13]
 4739              	.LVL533:
 4740 299c 0370A0E1 		mov	r7, r3
1652:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4741              		.loc 1 1652 0
 4742 29a0 2930C4E5 		strb	r3, [r4, #41]
 4743 29a4 09A0A0E1 		mov	r10, r9
1653:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4744              		.loc 1 1653 0
 4745 29a8 0E30C2E5 		strb	r3, [r2, #14]
 4746              	.LVL534:
 4747 29ac D4FBFFEA 		b	.L294
 4748              	.LVL535:
 4749              	.L451:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4750              		.loc 1 1500 0
 4751 29b0 0C00A0E1 		mov	r0, ip
 4752              	.LVL536:
 4753 29b4 0B10A0E1 		mov	r1, fp
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4754              		.loc 1 1501 0
 4755 29b8 054184E0 		add	r4, r4, r5, asl #2
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4756              		.loc 1 1500 0
 4757 29bc 1C308DE5 		str	r3, [sp, #28]
 4758 29c0 FEFFFFEB 		bl	SensorGetControl
 4759              	.LVL537:
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4760              		.loc 1 1501 0
 4761 29c4 202014E5 		ldr	r2, [r4, #-32]
 4762 29c8 EDFFFFEA 		b	.L420
 4763              		.cfi_endproc
 4764              	.LFE3:
 4766              		.align	2
 4767              		.global	CTControlHandle
 4769              	CTControlHandle:
 4770              	.LFB4:
2273:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4771              		.loc 1 2273 0
 4772              		.cfi_startproc
 4773              		@ args = 0, pretend = 0, frame = 24
 4774              		@ frame_needed = 0, uses_anonymous_args = 0
 4775              	.LVL538:
 4776 29cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4777              	.LCFI19:
 4778              		.cfi_def_cfa_offset 36
 4779              		.cfi_offset 4, -36
 4780              		.cfi_offset 5, -32
 4781              		.cfi_offset 6, -28
 4782              		.cfi_offset 7, -24
 4783              		.cfi_offset 8, -20
 4784              		.cfi_offset 9, -16
 4785              		.cfi_offset 10, -12
 4786              		.cfi_offset 11, -8
 4787              		.cfi_offset 14, -4
2292:../uvc.c      **** 
 4788              		.loc 1 2292 0
 4789 29d0 28B89FE5 		ldr	fp, .L492
2284:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4790              		.loc 1 2284 0
 4791 29d4 28389FE5 		ldr	r3, .L492+4
2292:../uvc.c      **** 
 4792              		.loc 1 2292 0
 4793 29d8 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2284:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4794              		.loc 1 2284 0
 4795 29dc 8080A0E1 		mov	r8, r0, asl #1
 4796 29e0 002088E0 		add	r2, r8, r0
 4797 29e4 822183E0 		add	r2, r3, r2, asl #3
2294:../uvc.c      **** 		 {
 4798              		.loc 1 2294 0
 4799 29e8 830055E3 		cmp	r5, #131
2273:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4800              		.loc 1 2273 0
 4801 29ec 34D04DE2 		sub	sp, sp, #52
 4802              	.LCFI20:
 4803              		.cfi_def_cfa_offset 88
2273:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4804              		.loc 1 2273 0
 4805 29f0 0060A0E1 		mov	r6, r0
2284:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4806              		.loc 1 2284 0
 4807 29f4 E795D2E5 		ldrb	r9, [r2, #1511]	@ zero_extendqisi2
 4808              	.LVL539:
2285:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4809              		.loc 1 2285 0
 4810 29f8 D8A5D2E5 		ldrb	r10, [r2, #1496]	@ zero_extendqisi2
 4811              	.LVL540:
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4812              		.loc 1 2287 0
 4813 29fc DA75D2E5 		ldrb	r7, [r2, #1498]	@ zero_extendqisi2
 4814              	.LVL541:
2294:../uvc.c      **** 		 {
 4815              		.loc 1 2294 0
 4816 2a00 8000000A 		beq	.L456
 4817 2a04 2600009A 		bls	.L490
 4818 2a08 850055E3 		cmp	r5, #133
 4819 2a0c 7200000A 		beq	.L461
 4820 2a10 5000003A 		bcc	.L462
 4821 2a14 860055E3 		cmp	r5, #134
 4822 2a18 4300000A 		beq	.L463
 4823 2a1c 870055E3 		cmp	r5, #135
 4824 2a20 5F00001A 		bne	.L455
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4825              		.loc 1 2356 0
 4826 2a24 E3C5D2E5 		ldrb	ip, [r2, #1507]	@ zero_extendqisi2
 4827 2a28 D8479FE5 		ldr	r4, .L492+8
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4828              		.loc 1 2357 0
 4829 2a2c E425D2E5 		ldrb	r2, [r2, #1508]	@ zero_extendqisi2
 4830              	.LVL542:
 4831              	.L489:
2334:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4832              		.loc 1 2334 0
 4833 2a30 0A1056E2 		subs	r1, r6, #10
 4834 2a34 006071E2 		rsbs	r6, r1, #0
 4835 2a38 0160B6E0 		adcs	r6, r6, r1
2336:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4836              		.loc 1 2336 0
 4837 2a3c 0030A0E3 		mov	r3, #0
 4838              	.LVL543:
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4839              		.loc 1 2337 0
 4840 2a40 281084E2 		add	r1, r4, #40
 4841 2a44 0700A0E1 		mov	r0, r7
 4842              	.LVL544:
2334:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4843              		.loc 1 2334 0
 4844 2a48 2A60C4E5 		strb	r6, [r4, #42]
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4845              		.loc 1 2332 0
 4846 2a4c 28C0C4E5 		strb	ip, [r4, #40]
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4847              		.loc 1 2333 0
 4848 2a50 2920C4E5 		strb	r2, [r4, #41]
2336:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4849              		.loc 1 2336 0
 4850 2a54 2B30C4E5 		strb	r3, [r4, #43]
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4851              		.loc 1 2337 0
 4852 2a58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4853              	.LVL545:
 4854 2a5c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2339:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4855              		.loc 1 2339 0
 4856 2a60 FF80A0E3 		mov	r8, #255
 4857 2a64 0860A0E1 		mov	r6, r8
 4858              	.LVL546:
 4859              	.L465:
2507:../uvc.c      **** }
 4860              		.loc 1 2507 0
 4861 2a68 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4862 2a6c FFC0A0E3 		mov	ip, #255
 4863 2a70 04108DE5 		str	r1, [sp, #4]
 4864 2a74 10108DE5 		str	r1, [sp, #16]
 4865 2a78 08008DE5 		str	r0, [sp, #8]
 4866 2a7c 00808DE5 		str	r8, [sp]
 4867 2a80 14708DE5 		str	r7, [sp, #20]
 4868 2a84 0520A0E1 		mov	r2, r5
 4869 2a88 0630A0E1 		mov	r3, r6
 4870 2a8c 0CC08DE5 		str	ip, [sp, #12]
 4871 2a90 74179FE5 		ldr	r1, .L492+12
 4872 2a94 0400A0E3 		mov	r0, #4
 4873 2a98 FEFFFFEB 		bl	CyU3PDebugPrint
 4874              	.LVL547:
2508:../uvc.c      **** 
 4875              		.loc 1 2508 0
 4876 2a9c 34D08DE2 		add	sp, sp, #52
 4877              		@ sp needed
 4878 2aa0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4879              	.LVL548:
 4880              	.L490:
2294:../uvc.c      **** 		 {
 4881              		.loc 1 2294 0
 4882 2aa4 810055E3 		cmp	r5, #129
 4883 2aa8 2E00000A 		beq	.L458
 4884 2aac 1A00008A 		bhi	.L459
 4885 2ab0 010055E3 		cmp	r5, #1
 4886 2ab4 3A00001A 		bne	.L455
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4887              		.loc 1 2365 0
 4888 2ab8 48479FE5 		ldr	r4, .L492+8
 4889 2abc 2E208DE2 		add	r2, sp, #46
 4890              	.LVL549:
 4891 2ac0 2000A0E3 		mov	r0, #32
 4892              	.LVL550:
 4893 2ac4 281084E2 		add	r1, r4, #40
 4894 2ac8 18308DE5 		str	r3, [sp, #24]
 4895 2acc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4896              	.LVL551:
2367:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4897              		.loc 1 2367 0
 4898 2ad0 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2371:../uvc.c      **** 			  {
 4899              		.loc 1 2371 0
 4900 2ad4 012046E2 		sub	r2, r6, #1
2367:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4901              		.loc 1 2367 0
 4902 2ad8 1CC08DE5 		str	ip, [sp, #28]
 4903              	.LVL552:
2368:../uvc.c      **** 			  value = Data1;
 4904              		.loc 1 2368 0
 4905 2adc 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2371:../uvc.c      **** 			  {
 4906              		.loc 1 2371 0
 4907 2ae0 18309DE5 		ldr	r3, [sp, #24]
2368:../uvc.c      **** 			  value = Data1;
 4908              		.loc 1 2368 0
 4909 2ae4 20C08DE5 		str	ip, [sp, #32]
 4910              	.LVL553:
2371:../uvc.c      **** 			  {
 4911              		.loc 1 2371 0
 4912 2ae8 090052E3 		cmp	r2, #9
 4913 2aec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4914 2af0 1D0100EA 		b	.L466
 4915              	.L468:
 4916 2af4 242F0000 		.word	.L467
 4917 2af8 6C2F0000 		.word	.L466
 4918 2afc 242D0000 		.word	.L469
 4919 2b00 6C2F0000 		.word	.L466
 4920 2b04 6C2F0000 		.word	.L466
 4921 2b08 6C2F0000 		.word	.L466
 4922 2b0c 942C0000 		.word	.L470
 4923 2b10 6C2F0000 		.word	.L466
 4924 2b14 6C2F0000 		.word	.L466
 4925 2b18 182C0000 		.word	.L471
 4926              	.LVL554:
 4927              	.L459:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4928              		.loc 1 2323 0
 4929 2b1c DBC5D2E5 		ldrb	ip, [r2, #1499]	@ zero_extendqisi2
 4930 2b20 E0469FE5 		ldr	r4, .L492+8
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4931              		.loc 1 2324 0
 4932 2b24 DC25D2E5 		ldrb	r2, [r2, #1500]	@ zero_extendqisi2
 4933              	.LVL555:
 4934 2b28 C0FFFFEA 		b	.L489
 4935              	.LVL556:
 4936              	.L463:
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4937              		.loc 1 2350 0
 4938 2b2c D4469FE5 		ldr	r4, .L492+8
 4939 2b30 E135D2E5 		ldrb	r3, [r2, #1505]	@ zero_extendqisi2
 4940 2b34 0410A0E1 		mov	r1, r4
 4941 2b38 2830E1E5 		strb	r3, [r1, #40]!
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4942              		.loc 1 2351 0
 4943 2b3c 0100A0E3 		mov	r0, #1
 4944              	.LVL557:
2354:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4945              		.loc 1 2354 0
 4946 2b40 FF80A0E3 		mov	r8, #255
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4947              		.loc 1 2351 0
 4948 2b44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4949              	.LVL558:
2354:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4950              		.loc 1 2354 0
 4951 2b48 0860A0E1 		mov	r6, r8
 4952 2b4c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4953 2b50 0170A0E3 		mov	r7, #1
 4954 2b54 C3FFFFEA 		b	.L465
 4955              	.LVL559:
 4956              	.L462:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4957              		.loc 1 2341 0
 4958 2b58 DFC5D2E5 		ldrb	ip, [r2, #1503]	@ zero_extendqisi2
 4959 2b5c A4469FE5 		ldr	r4, .L492+8
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4960              		.loc 1 2342 0
 4961 2b60 E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 4962              	.LVL560:
 4963 2b64 B1FFFFEA 		b	.L489
 4964              	.LVL561:
 4965              	.L458:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4966              		.loc 1 2308 0
 4967 2b68 98469FE5 		ldr	r4, .L492+8
 4968 2b6c E595D2E5 		ldrb	r9, [r2, #1509]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4969              		.loc 1 2309 0
 4970 2b70 E6C5D2E5 		ldrb	ip, [r2, #1510]	@ zero_extendqisi2
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4971              		.loc 1 2310 0
 4972 2b74 0030A0E3 		mov	r3, #0
2316:../uvc.c      **** 
 4973              		.loc 1 2316 0
 4974 2b78 281084E2 		add	r1, r4, #40
 4975 2b7c 0700A0E1 		mov	r0, r7
 4976              	.LVL562:
2321:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4977              		.loc 1 2321 0
 4978 2b80 FF80A0E3 		mov	r8, #255
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4979              		.loc 1 2309 0
 4980 2b84 29C0C4E5 		strb	ip, [r4, #41]
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4981              		.loc 1 2308 0
 4982 2b88 2890C4E5 		strb	r9, [r4, #40]
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4983              		.loc 1 2310 0
 4984 2b8c 2A30C4E5 		strb	r3, [r4, #42]
2311:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4985              		.loc 1 2311 0
 4986 2b90 2B30C4E5 		strb	r3, [r4, #43]
 4987              	.LVL563:
2321:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4988              		.loc 1 2321 0
 4989 2b94 0860A0E1 		mov	r6, r8
 4990              	.LVL564:
2316:../uvc.c      **** 
 4991              		.loc 1 2316 0
 4992 2b98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4993              	.LVL565:
 4994 2b9c 0900A0E1 		mov	r0, r9
2321:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4995              		.loc 1 2321 0
 4996 2ba0 B0FFFFEA 		b	.L465
 4997              	.LVL566:
 4998              	.L455:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4999              		.loc 1 2501 0
 5000 2ba4 0000A0E3 		mov	r0, #0
 5001              	.LVL567:
 5002 2ba8 0020A0E1 		mov	r2, r0
 5003              	.LVL568:
 5004 2bac 0110A0E3 		mov	r1, #1
 5005 2bb0 FEFFFFEB 		bl	CyU3PUsbStall
 5006              	.LVL569:
2502:../uvc.c      **** 			  break;
 5007              		.loc 1 2502 0
 5008 2bb4 0620A0E1 		mov	r2, r6
 5009 2bb8 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5010 2bbc 0400A0E3 		mov	r0, #4
 5011 2bc0 48169FE5 		ldr	r1, .L492+16
 5012 2bc4 FEFFFFEB 		bl	CyU3PDebugPrint
 5013              	.LVL570:
2503:../uvc.c      **** 		 }
 5014              		.loc 1 2503 0
 5015 2bc8 FF00A0E3 		mov	r0, #255
 5016 2bcc 34469FE5 		ldr	r4, .L492+8
 5017 2bd0 0080A0E1 		mov	r8, r0
 5018 2bd4 0060A0E1 		mov	r6, r0
 5019 2bd8 A2FFFFEA 		b	.L465
 5020              	.LVL571:
 5021              	.L461:
2298:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5022              		.loc 1 2298 0
 5023 2bdc 24469FE5 		ldr	r4, .L492+8
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5024              		.loc 1 2299 0
 5025 2be0 0030A0E3 		mov	r3, #0
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5026              		.loc 1 2300 0
 5027 2be4 281084E2 		add	r1, r4, #40
 5028 2be8 0200A0E3 		mov	r0, #2
 5029              	.LVL572:
2302:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5030              		.loc 1 2302 0
 5031 2bec FF80A0E3 		mov	r8, #255
2298:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5032              		.loc 1 2298 0
 5033 2bf0 2870C4E5 		strb	r7, [r4, #40]
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5034              		.loc 1 2299 0
 5035 2bf4 2930C4E5 		strb	r3, [r4, #41]
2302:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5036              		.loc 1 2302 0
 5037 2bf8 0860A0E1 		mov	r6, r8
 5038              	.LVL573:
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5039              		.loc 1 2300 0
 5040 2bfc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5041              	.LVL574:
 5042 2c00 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2302:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5043              		.loc 1 2302 0
 5044 2c04 97FFFFEA 		b	.L465
 5045              	.LVL575:
 5046              	.L456:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5047              		.loc 1 2332 0
 5048 2c08 DDC5D2E5 		ldrb	ip, [r2, #1501]	@ zero_extendqisi2
 5049 2c0c F4459FE5 		ldr	r4, .L492+8
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5050              		.loc 1 2333 0
 5051 2c10 DE25D2E5 		ldrb	r2, [r2, #1502]	@ zero_extendqisi2
 5052              	.LVL576:
 5053 2c14 85FFFFEA 		b	.L489
 5054              	.LVL577:
 5055              	.L471:
2480:../uvc.c      **** 					  if(getData == 1)
 5056              		.loc 1 2480 0
 5057 2c18 F4659FE5 		ldr	r6, .L492+20
 5058 2c1c 0010E0E3 		mvn	r1, #0
 5059 2c20 1C0096E5 		ldr	r0, [r6, #28]
 5060 2c24 FEFFFFEB 		bl	_txe_mutex_get
 5061              	.LVL578:
2481:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5062              		.loc 1 2481 0
 5063 2c28 1CC09DE5 		ldr	ip, [sp, #28]
 5064 2c2c 01005CE3 		cmp	ip, #1
2482:../uvc.c      **** 					  else if(getData == 0xff)
 5065              		.loc 1 2482 0
 5066 2c30 0400A003 		moveq	r0, #4
2481:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5067              		.loc 1 2481 0
 5068 2c34 6901000A 		beq	.L488
2483:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5069              		.loc 1 2483 0
 5070 2c38 FF005CE3 		cmp	ip, #255
 5071 2c3c 6601000A 		beq	.L491
2486:../uvc.c      **** 					  //dataIdx++;
 5072              		.loc 1 2486 0
 5073 2c40 0010A0E3 		mov	r1, #0
 5074 2c44 00108DE5 		str	r1, [sp]
 5075 2c48 04108DE5 		str	r1, [sp, #4]
 5076 2c4c 0A20A0E1 		mov	r2, r10
 5077 2c50 0930A0E1 		mov	r3, r9
 5078 2c54 0600A0E1 		mov	r0, r6
 5079 2c58 2310A0E3 		mov	r1, #35
 5080 2c5c FEFFFFEB 		bl	cmdSet
 5081              	.LVL579:
 5082              	.L483:
2489:../uvc.c      **** #endif
 5083              		.loc 1 2489 0
 5084 2c60 1C0096E5 		ldr	r0, [r6, #28]
 5085 2c64 FEFFFFEB 		bl	_txe_mutex_put
 5086              	.LVL580:
2491:../uvc.c      **** 					  break;
 5087              		.loc 1 2491 0
 5088 2c68 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5089 2c6c 1C609DE5 		ldr	r6, [sp, #28]
 5090 2c70 20809DE5 		ldr	r8, [sp, #32]
 5091 2c74 00108DE5 		str	r1, [sp]
 5092 2c78 0620A0E1 		mov	r2, r6
 5093 2c7c 0830A0E1 		mov	r3, r8
 5094 2c80 0400A0E3 		mov	r0, #4
 5095 2c84 8C159FE5 		ldr	r1, .L492+24
 5096 2c88 FEFFFFEB 		bl	CyU3PDebugPrint
 5097              	.LVL581:
2492:../uvc.c      **** 
 5098              		.loc 1 2492 0
 5099 2c8c FF00A0E3 		mov	r0, #255
 5100 2c90 74FFFFEA 		b	.L465
 5101              	.LVL582:
 5102              	.L470:
2457:../uvc.c      **** 					  {
 5103              		.loc 1 2457 0
 5104 2c94 FD05D3E5 		ldrb	r0, [r3, #1533]	@ zero_extendqisi2
 5105 2c98 64C59FE5 		ldr	ip, .L492+4
 5106 2c9c 010050E3 		cmp	r0, #1
 5107 2ca0 08005013 		cmpne	r0, #8
 5108 2ca4 0000A013 		movne	r0, #0
 5109 2ca8 0100A003 		moveq	r0, #1
 5110 2cac 4601001A 		bne	.L480
 5111              	.LVL583:
2460:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5112              		.loc 1 2460 0
 5113 2cb0 5CB59FE5 		ldr	fp, .L492+20
 5114 2cb4 0010E0E3 		mvn	r1, #0
 5115 2cb8 1C009BE5 		ldr	r0, [fp, #28]
 5116 2cbc 18C08DE5 		str	ip, [sp, #24]
 5117 2cc0 FEFFFFEB 		bl	_txe_mutex_get
 5118              	.LVL584:
2461:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5119              		.loc 1 2461 0
 5120 2cc4 1C009DE5 		ldr	r0, [sp, #28]
 5121 2cc8 0010A0E3 		mov	r1, #0
 5122 2ccc 0A20A0E1 		mov	r2, r10
 5123 2cd0 0930A0E1 		mov	r3, r9
 5124 2cd4 00008DE5 		str	r0, [sp]
 5125 2cd8 04108DE5 		str	r1, [sp, #4]
 5126 2cdc 0B00A0E1 		mov	r0, fp
 5127 2ce0 2210A0E3 		mov	r1, #34
 5128 2ce4 FEFFFFEB 		bl	cmdSet
 5129              	.LVL585:
2462:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5130              		.loc 1 2462 0
 5131 2ce8 1C009BE5 		ldr	r0, [fp, #28]
 5132 2cec FEFFFFEB 		bl	_txe_mutex_put
 5133              	.LVL586:
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5134              		.loc 1 2465 0
 5135 2cf0 18C09DE5 		ldr	ip, [sp, #24]
 5136 2cf4 1C109DE5 		ldr	r1, [sp, #28]
2466:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5137              		.loc 1 2466 0
 5138 2cf8 20209DE5 		ldr	r2, [sp, #32]
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5139              		.loc 1 2465 0
 5140 2cfc 066088E0 		add	r6, r8, r6
 5141 2d00 86C18CE0 		add	ip, ip, r6, asl #3
2467:../uvc.c      **** 					  }else{
 5142              		.loc 1 2467 0
 5143 2d04 0130A0E3 		mov	r3, #1
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5144              		.loc 1 2465 0
 5145 2d08 E515CCE5 		strb	r1, [ip, #1509]
2466:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5146              		.loc 1 2466 0
 5147 2d0c E625CCE5 		strb	r2, [ip, #1510]
2467:../uvc.c      **** 					  }else{
 5148              		.loc 1 2467 0
 5149 2d10 E835CCE5 		strb	r3, [ip, #1512]
 5150              	.LVL587:
 5151              	.L481:
 5152 2d14 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5153 2d18 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2474:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5154              		.loc 1 2474 0
 5155 2d1c FF00A0E3 		mov	r0, #255
 5156 2d20 50FFFFEA 		b	.L465
 5157              	.LVL588:
 5158              	.L469:
2423:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5159              		.loc 1 2423 0
 5160 2d24 FD35D3E5 		ldrb	r3, [r3, #1533]	@ zero_extendqisi2
 5161 2d28 010053E3 		cmp	r3, #1
 5162 2d2c 04005313 		cmpne	r3, #4
 5163 2d30 2001001A 		bne	.L478
2422:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5164              		.loc 1 2422 0
 5165 2d34 1CC09DE5 		ldr	ip, [sp, #28]
 5166 2d38 20009DE5 		ldr	r0, [sp, #32]
 5167 2d3c 00348CE1 		orr	r3, ip, r0, asl #8
2424:../uvc.c      **** 					  {
 5168              		.loc 1 2424 0
 5169 2d40 F90053E3 		cmp	r3, #249
 5170 2d44 1B01008A 		bhi	.L478
 5171              	.LVL589:
2429:../uvc.c      **** 							}else{
 5172              		.loc 1 2429 0
 5173 2d48 C80043E2 		sub	r0, r3, #200
 5174 2d4c C80053E3 		cmp	r3, #200
2431:../uvc.c      **** 							}
 5175              		.loc 1 2431 0
 5176 2d50 C82063E2 		rsb	r2, r3, #200
 5177 2d54 C0149FE5 		ldr	r1, .L492+28
 5178 2d58 0208A091 		movls	r0, r2, asl #16
 5179 2d5c 0008A081 		movhi	r0, r0, asl #16
 5180 2d60 642063E2 		rsb	r2, r3, #100
 5181 2d64 640053E3 		cmp	r3, #100
2429:../uvc.c      **** 							}else{
 5182              		.loc 1 2429 0
 5183 2d68 64C043E2 		sub	ip, r3, #100
 5184 2d6c 2008A0E1 		mov	r0, r0, lsr #16
 5185 2d70 0C28A081 		movhi	r2, ip, asl #16
 5186 2d74 0228A091 		movls	r2, r2, asl #16
 5187 2d78 010050E1 		cmp	r0, r1
 5188 2d7c 00E0A031 		movcc	lr, r0
 5189 2d80 01E0A021 		movcs	lr, r1
 5190 2d84 010050E1 		cmp	r0, r1
 5191 2d88 27C043E2 		sub	ip, r3, #39
2431:../uvc.c      **** 							}
 5192              		.loc 1 2431 0
 5193 2d8c 271063E2 		rsb	r1, r3, #39
 5194 2d90 00B0A033 		movcc	fp, #0
 5195 2d94 01B0A023 		movcs	fp, #1
 5196 2d98 270053E3 		cmp	r3, #39
2429:../uvc.c      **** 							}else{
 5197              		.loc 1 2429 0
 5198 2d9c 140043E2 		sub	r0, r3, #20
 5199 2da0 01C8A091 		movls	ip, r1, asl #16
 5200 2da4 2228A0E1 		mov	r2, r2, lsr #16
2431:../uvc.c      **** 							}
 5201              		.loc 1 2431 0
 5202 2da8 141063E2 		rsb	r1, r3, #20
 5203 2dac 0CC8A081 		movhi	ip, ip, asl #16
 5204 2db0 140053E3 		cmp	r3, #20
 5205 2db4 0018A081 		movhi	r1, r0, asl #16
 5206 2db8 0118A091 		movls	r1, r1, asl #16
 5207 2dbc 0E0052E1 		cmp	r2, lr
2429:../uvc.c      **** 							}else{
 5208              		.loc 1 2429 0
 5209 2dc0 0A0043E2 		sub	r0, r3, #10
 5210 2dc4 01B0A033 		movcc	fp, #1
 5211 2dc8 2CC8A0E1 		mov	ip, ip, lsr #16
 5212 2dcc 02005EE1 		cmp	lr, r2
 5213 2dd0 0E20A031 		movcc	r2, lr
 5214 2dd4 0A0053E3 		cmp	r3, #10
 5215 2dd8 21E8A0E1 		mov	lr, r1, lsr #16
2431:../uvc.c      **** 							}
 5216              		.loc 1 2431 0
 5217 2ddc 0A1063E2 		rsb	r1, r3, #10
 5218 2de0 0118A091 		movls	r1, r1, asl #16
 5219 2de4 0018A081 		movhi	r1, r0, asl #16
 5220 2de8 0C0052E1 		cmp	r2, ip
 5221 2dec 02B0A083 		movhi	fp, #2
 5222 2df0 24B08DE5 		str	fp, [sp, #36]
2429:../uvc.c      **** 							}else{
 5223              		.loc 1 2429 0
 5224 2df4 050043E2 		sub	r0, r3, #5
 5225 2df8 02005CE1 		cmp	ip, r2
 5226 2dfc 0C20A031 		movcc	r2, ip
 5227 2e00 21B8A0E1 		mov	fp, r1, lsr #16
2431:../uvc.c      **** 							}
 5228              		.loc 1 2431 0
 5229 2e04 05C063E2 		rsb	ip, r3, #5
 5230 2e08 050053E3 		cmp	r3, #5
 5231 2e0c 24109DE5 		ldr	r1, [sp, #36]
 5232 2e10 00C8A081 		movhi	ip, r0, asl #16
 5233 2e14 0CC8A091 		movls	ip, ip, asl #16
 5234 2e18 0E0052E1 		cmp	r2, lr
 5235 2e1c 0310A083 		movhi	r1, #3
 5236 2e20 24108DE5 		str	r1, [sp, #36]
 5237 2e24 02005EE1 		cmp	lr, r2
 5238 2e28 0E00A031 		movcc	r0, lr
 5239 2e2c 0200A021 		movcs	r0, r2
 5240 2e30 021063E2 		rsb	r1, r3, #2
2429:../uvc.c      **** 							}else{
 5241              		.loc 1 2429 0
 5242 2e34 022043E2 		sub	r2, r3, #2
 5243 2e38 020053E3 		cmp	r3, #2
 5244 2e3c 0128A091 		movls	r2, r1, asl #16
 5245 2e40 0228A081 		movhi	r2, r2, asl #16
 5246 2e44 0B0050E1 		cmp	r0, fp
 5247 2e48 24E09DE5 		ldr	lr, [sp, #36]
 5248 2e4c 2CC8A0E1 		mov	ip, ip, lsr #16
 5249 2e50 04E0A083 		movhi	lr, #4
 5250 2e54 00005BE1 		cmp	fp, r0
 5251 2e58 0B00A031 		movcc	r0, fp
 5252 2e5c 00005CE1 		cmp	ip, r0
 5253 2e60 0C10A031 		movcc	r1, ip
 5254 2e64 0010A021 		movcs	r1, r0
 5255 2e68 0C0050E1 		cmp	r0, ip
 5256 2e6c 05E0A083 		movhi	lr, #5
 5257 2e70 01C043E2 		sub	ip, r3, #1
 5258 2e74 010053E3 		cmp	r3, #1
2431:../uvc.c      **** 							}
 5259              		.loc 1 2431 0
 5260 2e78 010063E2 		rsb	r0, r3, #1
 5261 2e7c 0C38A081 		movhi	r3, ip, asl #16
2441:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5262              		.loc 1 2441 0
 5263 2e80 8CC39FE5 		ldr	ip, .L492+20
 5264 2e84 2228A0E1 		mov	r2, r2, lsr #16
 5265 2e88 0038A091 		movls	r3, r0, asl #16
 5266 2e8c 010052E1 		cmp	r2, r1
 5267 2e90 0200A031 		movcc	r0, r2
 5268 2e94 0100A021 		movcs	r0, r1
 5269 2e98 020051E1 		cmp	r1, r2
 5270 2e9c 0E20A091 		movls	r2, lr
 5271 2ea0 0620A083 		movhi	r2, #6
 5272              	.LVL590:
 5273 2ea4 0010E0E3 		mvn	r1, #0
 5274              	.LVL591:
 5275 2ea8 230850E1 		cmp	r0, r3, lsr #16
 5276 2eac 1C009CE5 		ldr	r0, [ip, #28]
 5277 2eb0 02B0A091 		movls	fp, r2
 5278 2eb4 07B0A083 		movhi	fp, #7
 5279              	.LVL592:
 5280 2eb8 18C08DE5 		str	ip, [sp, #24]
 5281 2ebc FEFFFFEB 		bl	_txe_mutex_get
 5282              	.LVL593:
2442:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5283              		.loc 1 2442 0
 5284 2ec0 18C09DE5 		ldr	ip, [sp, #24]
2438:../uvc.c      **** 
 5285              		.loc 1 2438 0
 5286 2ec4 01B08BE2 		add	fp, fp, #1
 5287              	.LVL594:
2442:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5288              		.loc 1 2442 0
 5289 2ec8 0010A0E3 		mov	r1, #0
 5290 2ecc 0A20A0E1 		mov	r2, r10
 5291 2ed0 0930A0E1 		mov	r3, r9
 5292 2ed4 0C00A0E1 		mov	r0, ip
 5293 2ed8 04108DE5 		str	r1, [sp, #4]
 5294 2edc 00B08DE5 		str	fp, [sp]
 5295 2ee0 0310A0E3 		mov	r1, #3
 5296 2ee4 FEFFFFEB 		bl	cmdSet
 5297              	.LVL595:
2443:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5298              		.loc 1 2443 0
 5299 2ee8 18C09DE5 		ldr	ip, [sp, #24]
 5300 2eec 1C009CE5 		ldr	r0, [ip, #28]
 5301 2ef0 FEFFFFEB 		bl	_txe_mutex_put
 5302              	.LVL596:
2449:../uvc.c      **** 					  }else{
 5303              		.loc 1 2449 0
 5304 2ef4 08C39FE5 		ldr	ip, .L492+4
2446:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5305              		.loc 1 2446 0
 5306 2ef8 04239FE5 		ldr	r2, .L492+4
2449:../uvc.c      **** 					  }else{
 5307              		.loc 1 2449 0
 5308 2efc 79B3CCE5 		strb	fp, [ip, #889]
2446:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5309              		.loc 1 2446 0
 5310 2f00 1CC09DE5 		ldr	ip, [sp, #28]
 5311 2f04 063088E0 		add	r3, r8, r6
 5312 2f08 833182E0 		add	r3, r2, r3, asl #3
 5313 2f0c E5C5C3E5 		strb	ip, [r3, #1509]
2447:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5314              		.loc 1 2447 0
 5315 2f10 20C09DE5 		ldr	ip, [sp, #32]
2448:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5316              		.loc 1 2448 0
 5317 2f14 0120A0E3 		mov	r2, #1
2447:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5318              		.loc 1 2447 0
 5319 2f18 E6C5C3E5 		strb	ip, [r3, #1510]
2448:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5320              		.loc 1 2448 0
 5321 2f1c E825C3E5 		strb	r2, [r3, #1512]
2449:../uvc.c      **** 					  }else{
 5322              		.loc 1 2449 0
 5323 2f20 7BFFFFEA 		b	.L481
 5324              	.LVL597:
 5325              	.L467:
2380:../uvc.c      **** 						case 1:
 5326              		.loc 1 2380 0
 5327 2f24 1CC09DE5 		ldr	ip, [sp, #28]
2376:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5328              		.loc 1 2376 0
 5329 2f28 066088E0 		add	r6, r8, r6
 5330 2f2c 866183E0 		add	r6, r3, r6, asl #3
2377:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5331              		.loc 1 2377 0
 5332 2f30 0110A0E3 		mov	r1, #1
2380:../uvc.c      **** 						case 1:
 5333              		.loc 1 2380 0
 5334 2f34 01204CE2 		sub	r2, ip, #1
2376:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5335              		.loc 1 2376 0
 5336 2f38 E5C5C6E5 		strb	ip, [r6, #1509]
2377:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5337              		.loc 1 2377 0
 5338 2f3c E815C6E5 		strb	r1, [r6, #1512]
 5339              	.LVL598:
2380:../uvc.c      **** 						case 1:
 5340              		.loc 1 2380 0
 5341 2f40 070052E3 		cmp	r2, #7
 5342 2f44 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5343 2f48 960000EA 		b	.L472
 5344              	.L474:
 5345 2f4c 44310000 		.word	.L473
 5346 2f50 A8300000 		.word	.L475
 5347 2f54 A8310000 		.word	.L472
 5348 2f58 40300000 		.word	.L476
 5349 2f5c A8310000 		.word	.L472
 5350 2f60 A8310000 		.word	.L472
 5351 2f64 A8310000 		.word	.L472
 5352 2f68 A02F0000 		.word	.L477
 5353              	.LVL599:
 5354              	.L466:
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5355              		.loc 1 2495 0
 5356 2f6c 1CC09DE5 		ldr	ip, [sp, #28]
 5357 2f70 068088E0 		add	r8, r8, r6
 5358 2f74 888183E0 		add	r8, r3, r8, asl #3
2496:../uvc.c      **** 			  		 break;
 5359              		.loc 1 2496 0
 5360 2f78 0620A0E1 		mov	r2, r6
 5361 2f7c 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5362 2f80 0400A0E3 		mov	r0, #4
 5363 2f84 94129FE5 		ldr	r1, .L492+32
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5364              		.loc 1 2495 0
 5365 2f88 E5C5C8E5 		strb	ip, [r8, #1509]
2496:../uvc.c      **** 			  		 break;
 5366              		.loc 1 2496 0
 5367 2f8c FEFFFFEB 		bl	CyU3PDebugPrint
 5368              	.LVL600:
2497:../uvc.c      **** 			  }
 5369              		.loc 1 2497 0
 5370 2f90 FF00A0E3 		mov	r0, #255
 5371 2f94 0080A0E1 		mov	r8, r0
 5372 2f98 0060A0E1 		mov	r6, r0
 5373 2f9c B1FEFFEA 		b	.L465
 5374              	.LVL601:
 5375              	.L477:
2399:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5376              		.loc 1 2399 0
 5377 2fa0 6C629FE5 		ldr	r6, .L492+20
2397:../uvc.c      **** 			  		    	dataIdx = 0;
 5378              		.loc 1 2397 0
 5379 2fa4 0080A0E3 		mov	r8, #0
2399:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5380              		.loc 1 2399 0
 5381 2fa8 1C0096E5 		ldr	r0, [r6, #28]
 5382 2fac 0010E0E3 		mvn	r1, #0
2397:../uvc.c      **** 			  		    	dataIdx = 0;
 5383              		.loc 1 2397 0
 5384 2fb0 7983C3E5 		strb	r8, [r3, #889]
 5385              	.LVL602:
2399:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5386              		.loc 1 2399 0
 5387 2fb4 FEFFFFEB 		bl	_txe_mutex_get
 5388              	.LVL603:
2400:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5389              		.loc 1 2400 0
 5390 2fb8 0A20A0E1 		mov	r2, r10
 5391 2fbc 0930A0E1 		mov	r3, r9
 5392 2fc0 1010A0E3 		mov	r1, #16
 5393 2fc4 00808DE5 		str	r8, [sp]
 5394 2fc8 04808DE5 		str	r8, [sp, #4]
 5395 2fcc 0600A0E1 		mov	r0, r6
 5396 2fd0 FEFFFFEB 		bl	cmdSet
 5397              	.LVL604:
2401:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5398              		.loc 1 2401 0
 5399 2fd4 1C0096E5 		ldr	r0, [r6, #28]
 5400 2fd8 FEFFFFEB 		bl	_txe_mutex_put
 5401              	.LVL605:
 5402              	.LBB82:
 5403              	.LBB83:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5404              		.loc 1 1278 0
 5405 2fdc 1C0096E5 		ldr	r0, [r6, #28]
 5406 2fe0 0010E0E3 		mvn	r1, #0
 5407 2fe4 FEFFFFEB 		bl	_txe_mutex_get
 5408              	.LVL606:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5409              		.loc 1 1279 0
 5410 2fe8 0130A0E3 		mov	r3, #1
 5411 2fec 04808DE5 		str	r8, [sp, #4]
 5412 2ff0 0600A0E1 		mov	r0, r6
 5413 2ff4 00308DE5 		str	r3, [sp]
 5414 2ff8 2010A0E3 		mov	r1, #32
 5415 2ffc 2720A0E3 		mov	r2, #39
 5416 3000 3030A0E3 		mov	r3, #48
 5417 3004 FEFFFFEB 		bl	cmdSet
 5418              	.LVL607:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5419              		.loc 1 1280 0
 5420 3008 0230A0E3 		mov	r3, #2
 5421 300c 04808DE5 		str	r8, [sp, #4]
 5422 3010 0600A0E1 		mov	r0, r6
 5423 3014 00308DE5 		str	r3, [sp]
 5424 3018 2110A0E3 		mov	r1, #33
 5425 301c 2520A0E3 		mov	r2, #37
 5426 3020 3030A0E3 		mov	r3, #48
 5427 3024 FEFFFFEB 		bl	cmdSet
 5428              	.LVL608:
1281:../uvc.c      **** }
 5429              		.loc 1 1281 0
 5430 3028 1C0096E5 		ldr	r0, [r6, #28]
 5431 302c FEFFFFEB 		bl	_txe_mutex_put
 5432              	.LVL609:
 5433 3030 FF00A0E3 		mov	r0, #255
 5434 3034 0080A0E1 		mov	r8, r0
 5435 3038 0860A0E3 		mov	r6, #8
 5436 303c 89FEFFEA 		b	.L465
 5437              	.LVL610:
 5438              	.L476:
 5439              	.LBE83:
 5440              	.LBE82:
 5441              	.LBB84:
 5442              	.LBB85:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5443              		.loc 1 1278 0
 5444 3040 CC619FE5 		ldr	r6, .L492+20
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5445              		.loc 1 1279 0
 5446 3044 0080A0E3 		mov	r8, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5447              		.loc 1 1278 0
 5448 3048 0010E0E3 		mvn	r1, #0
 5449 304c 1C0096E5 		ldr	r0, [r6, #28]
 5450 3050 FEFFFFEB 		bl	_txe_mutex_get
 5451              	.LVL611:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5452              		.loc 1 1279 0
 5453 3054 0600A0E1 		mov	r0, r6
 5454 3058 00808DE5 		str	r8, [sp]
 5455 305c 04808DE5 		str	r8, [sp, #4]
 5456 3060 2010A0E3 		mov	r1, #32
 5457 3064 2720A0E3 		mov	r2, #39
 5458 3068 3030A0E3 		mov	r3, #48
 5459 306c FEFFFFEB 		bl	cmdSet
 5460              	.LVL612:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5461              		.loc 1 1280 0
 5462 3070 0130A0E3 		mov	r3, #1
 5463 3074 04808DE5 		str	r8, [sp, #4]
 5464 3078 0600A0E1 		mov	r0, r6
 5465 307c 00308DE5 		str	r3, [sp]
 5466 3080 2110A0E3 		mov	r1, #33
 5467 3084 2520A0E3 		mov	r2, #37
 5468 3088 3030A0E3 		mov	r3, #48
 5469 308c FEFFFFEB 		bl	cmdSet
 5470              	.LVL613:
1281:../uvc.c      **** }
 5471              		.loc 1 1281 0
 5472 3090 1C0096E5 		ldr	r0, [r6, #28]
 5473 3094 FEFFFFEB 		bl	_txe_mutex_put
 5474              	.LVL614:
 5475 3098 FF00A0E3 		mov	r0, #255
 5476 309c 0080A0E1 		mov	r8, r0
 5477 30a0 0460A0E3 		mov	r6, #4
 5478 30a4 6FFEFFEA 		b	.L465
 5479              	.LVL615:
 5480              	.L475:
 5481              	.LBE85:
 5482              	.LBE84:
2387:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5483              		.loc 1 2387 0
 5484 30a8 64619FE5 		ldr	r6, .L492+20
2385:../uvc.c      **** 							dataIdx = 0;
 5485              		.loc 1 2385 0
 5486 30ac 0080A0E3 		mov	r8, #0
2387:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5487              		.loc 1 2387 0
 5488 30b0 1C0096E5 		ldr	r0, [r6, #28]
 5489 30b4 0010E0E3 		mvn	r1, #0
2385:../uvc.c      **** 							dataIdx = 0;
 5490              		.loc 1 2385 0
 5491 30b8 7983C3E5 		strb	r8, [r3, #889]
 5492              	.LVL616:
2387:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5493              		.loc 1 2387 0
 5494 30bc FEFFFFEB 		bl	_txe_mutex_get
 5495              	.LVL617:
2388:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5496              		.loc 1 2388 0
 5497 30c0 0A20A0E1 		mov	r2, r10
 5498 30c4 0930A0E1 		mov	r3, r9
 5499 30c8 1010A0E3 		mov	r1, #16
 5500 30cc 00808DE5 		str	r8, [sp]
 5501 30d0 04808DE5 		str	r8, [sp, #4]
 5502 30d4 0600A0E1 		mov	r0, r6
 5503 30d8 FEFFFFEB 		bl	cmdSet
 5504              	.LVL618:
2389:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5505              		.loc 1 2389 0
 5506 30dc 1C0096E5 		ldr	r0, [r6, #28]
 5507 30e0 FEFFFFEB 		bl	_txe_mutex_put
 5508              	.LVL619:
 5509              	.LBB86:
 5510              	.LBB87:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5511              		.loc 1 1278 0
 5512 30e4 1C0096E5 		ldr	r0, [r6, #28]
 5513 30e8 0010E0E3 		mvn	r1, #0
 5514 30ec FEFFFFEB 		bl	_txe_mutex_get
 5515              	.LVL620:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5516              		.loc 1 1279 0
 5517 30f0 00808DE5 		str	r8, [sp]
 5518 30f4 04808DE5 		str	r8, [sp, #4]
 5519 30f8 0600A0E1 		mov	r0, r6
 5520 30fc 2010A0E3 		mov	r1, #32
 5521 3100 2720A0E3 		mov	r2, #39
 5522 3104 3030A0E3 		mov	r3, #48
 5523 3108 FEFFFFEB 		bl	cmdSet
 5524              	.LVL621:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5525              		.loc 1 1280 0
 5526 310c 0130A0E3 		mov	r3, #1
 5527 3110 04808DE5 		str	r8, [sp, #4]
 5528 3114 0600A0E1 		mov	r0, r6
 5529 3118 00308DE5 		str	r3, [sp]
 5530 311c 2110A0E3 		mov	r1, #33
 5531 3120 2520A0E3 		mov	r2, #37
 5532 3124 3030A0E3 		mov	r3, #48
 5533 3128 FEFFFFEB 		bl	cmdSet
 5534              	.LVL622:
1281:../uvc.c      **** }
 5535              		.loc 1 1281 0
 5536 312c 1C0096E5 		ldr	r0, [r6, #28]
 5537 3130 FEFFFFEB 		bl	_txe_mutex_put
 5538              	.LVL623:
 5539 3134 FF00A0E3 		mov	r0, #255
 5540 3138 0080A0E1 		mov	r8, r0
 5541 313c 0260A0E3 		mov	r6, #2
 5542 3140 48FEFFEA 		b	.L465
 5543              	.LVL624:
 5544              	.L473:
 5545              	.LBE87:
 5546              	.LBE86:
 5547              	.LBB88:
 5548              	.LBB89:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5549              		.loc 1 1278 0
 5550 3144 C8809FE5 		ldr	r8, .L492+20
 5551 3148 0010E0E3 		mvn	r1, #0
 5552 314c 1C0098E5 		ldr	r0, [r8, #28]
 5553 3150 FEFFFFEB 		bl	_txe_mutex_get
 5554              	.LVL625:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5555              		.loc 1 1279 0
 5556 3154 0090A0E3 		mov	r9, #0
 5557              	.LVL626:
 5558 3158 0160A0E3 		mov	r6, #1
 5559 315c 0800A0E1 		mov	r0, r8
 5560 3160 2010A0E3 		mov	r1, #32
 5561 3164 2720A0E3 		mov	r2, #39
 5562 3168 3030A0E3 		mov	r3, #48
 5563 316c 40028DE8 		stmia	sp, {r6, r9}
 5564 3170 FEFFFFEB 		bl	cmdSet
 5565              	.LVL627:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5566              		.loc 1 1280 0
 5567 3174 0230A0E3 		mov	r3, #2
 5568 3178 0800A0E1 		mov	r0, r8
 5569 317c 00308DE5 		str	r3, [sp]
 5570 3180 2110A0E3 		mov	r1, #33
 5571 3184 2520A0E3 		mov	r2, #37
 5572 3188 3030A0E3 		mov	r3, #48
 5573 318c 04908DE5 		str	r9, [sp, #4]
 5574 3190 FEFFFFEB 		bl	cmdSet
 5575              	.LVL628:
1281:../uvc.c      **** }
 5576              		.loc 1 1281 0
 5577 3194 1C0098E5 		ldr	r0, [r8, #28]
 5578 3198 FEFFFFEB 		bl	_txe_mutex_put
 5579              	.LVL629:
 5580 319c FF00A0E3 		mov	r0, #255
 5581 31a0 0080A0E1 		mov	r8, r0
 5582 31a4 2FFEFFEA 		b	.L465
 5583              	.LVL630:
 5584              	.L472:
 5585              	.LBE89:
 5586              	.LBE88:
2380:../uvc.c      **** 						case 1:
 5587              		.loc 1 2380 0
 5588 31a8 FF00A0E3 		mov	r0, #255
 5589 31ac 0C60A0E1 		mov	r6, ip
 5590 31b0 0080A0E1 		mov	r8, r0
 5591 31b4 2BFEFFEA 		b	.L465
 5592              	.LVL631:
 5593              	.L478:
2451:../uvc.c      **** 					  }
 5594              		.loc 1 2451 0
 5595 31b8 0000A0E3 		mov	r0, #0
 5596 31bc 0020A0E1 		mov	r2, r0
 5597 31c0 0110A0E3 		mov	r1, #1
 5598 31c4 FEFFFFEB 		bl	CyU3PUsbStall
 5599              	.LVL632:
 5600 31c8 D1FEFFEA 		b	.L481
 5601              	.LVL633:
 5602              	.L480:
2469:../uvc.c      **** 					  }
 5603              		.loc 1 2469 0
 5604 31cc 0020A0E1 		mov	r2, r0
 5605 31d0 0110A0E3 		mov	r1, #1
 5606 31d4 FEFFFFEB 		bl	CyU3PUsbStall
 5607              	.LVL634:
 5608 31d8 CDFEFFEA 		b	.L481
 5609              	.LVL635:
 5610              	.L491:
2484:../uvc.c      **** 					  else
 5611              		.loc 1 2484 0
 5612 31dc 0800A0E3 		mov	r0, #8
 5613              	.L488:
 5614 31e0 0010A0E3 		mov	r1, #0
 5615 31e4 03008DE8 		stmia	sp, {r0, r1}
 5616 31e8 0A20A0E1 		mov	r2, r10
 5617 31ec 0930A0E1 		mov	r3, r9
 5618 31f0 0600A0E1 		mov	r0, r6
 5619 31f4 2310A0E3 		mov	r1, #35
 5620 31f8 FEFFFFEB 		bl	cmdSet
 5621              	.LVL636:
 5622 31fc 97FEFFEA 		b	.L483
 5623              	.L493:
 5624              		.align	2
 5625              	.L492:
 5626 3200 00000000 		.word	bRequest
 5627 3204 00000000 		.word	.LANCHOR1
 5628 3208 00000000 		.word	.LANCHOR0
 5629 320c EC060000 		.word	.LC39
 5630 3210 C8060000 		.word	.LC38
 5631 3214 00000000 		.word	cmdQu
 5632 3218 7C060000 		.word	.LC36
 5633 321c FFFF0000 		.word	65535
 5634 3220 A4060000 		.word	.LC37
 5635              		.cfi_endproc
 5636              	.LFE4:
 5638              		.align	2
 5639              		.global	CamDefSet
 5641              	CamDefSet:
 5642              	.LFB5:
2512:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5643              		.loc 1 2512 0
 5644              		.cfi_startproc
 5645              		@ args = 0, pretend = 0, frame = 24
 5646              		@ frame_needed = 0, uses_anonymous_args = 0
 5647              	.LVL637:
 5648 3224 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5649              	.LCFI21:
 5650              		.cfi_def_cfa_offset 36
 5651              		.cfi_offset 4, -36
 5652              		.cfi_offset 5, -32
 5653              		.cfi_offset 6, -28
 5654              		.cfi_offset 7, -24
 5655              		.cfi_offset 8, -20
 5656              		.cfi_offset 9, -16
 5657              		.cfi_offset 10, -12
 5658              		.cfi_offset 11, -8
 5659              		.cfi_offset 14, -4
2519:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5660              		.loc 1 2519 0
 5661 3228 B0429FE5 		ldr	r4, .L497
2524:../uvc.c      ****     if(Data1&0x80){
 5662              		.loc 1 2524 0
 5663 322c B0229FE5 		ldr	r2, .L497+4
2521:../uvc.c      ****     Data1 = Data0;
 5664              		.loc 1 2521 0
 5665 3230 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2512:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5666              		.loc 1 2512 0
 5667 3234 2CD04DE2 		sub	sp, sp, #44
 5668              	.LCFI22:
 5669              		.cfi_def_cfa_offset 80
2524:../uvc.c      ****     if(Data1&0x80){
 5670              		.loc 1 2524 0
 5671 3238 1C0092E5 		ldr	r0, [r2, #28]
 5672 323c 0010E0E3 		mvn	r1, #0
2526:../uvc.c      ****     }else{
 5673              		.loc 1 2526 0
 5674 3240 2563A0E1 		mov	r6, r5, lsr #6
2520:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5675              		.loc 1 2520 0
 5676 3244 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2519:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5677              		.loc 1 2519 0
 5678 3248 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5679              	.LVL638:
2524:../uvc.c      ****     if(Data1&0x80){
 5680              		.loc 1 2524 0
 5681 324c FEFFFFEB 		bl	_txe_mutex_get
 5682              	.LVL639:
2525:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5683              		.loc 1 2525 0
 5684 3250 800015E3 		tst	r5, #128
2526:../uvc.c      ****     }else{
 5685              		.loc 1 2526 0
 5686 3254 01600612 		andne	r6, r6, #1
 5687 3258 0660E011 		mvnne	r6, r6
 5688 325c 3B600612 		andne	r6, r6, #59
 5689 3260 0660E011 		mvnne	r6, r6
 5690 3264 FF600612 		andne	r6, r6, #255
 5691              	.LVL640:
2528:../uvc.c      ****     }
 5692              		.loc 1 2528 0
 5693 3268 C6608603 		orreq	r6, r6, #198
 5694              	.LVL641:
2532:../uvc.c      **** 
 5695              		.loc 1 2532 0
 5696 326c 0080A0E3 		mov	r8, #0
2530:../uvc.c      **** 
 5697              		.loc 1 2530 0
 5698 3270 0551A0E1 		mov	r5, r5, asl #2
 5699              	.LVL642:
 5700 3274 FF5005E2 		and	r5, r5, #255
 5701              	.LVL643:
2535:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5702              		.loc 1 2535 0
 5703 3278 01A0A0E3 		mov	r10, #1
2532:../uvc.c      **** 
 5704              		.loc 1 2532 0
 5705 327c 00608DE5 		str	r6, [sp]
 5706 3280 0920A0E1 		mov	r2, r9
 5707 3284 0730A0E1 		mov	r3, r7
 5708 3288 04808DE5 		str	r8, [sp, #4]
 5709 328c 0110A0E3 		mov	r1, #1
 5710 3290 4C029FE5 		ldr	r0, .L497+4
 5711 3294 FEFFFFEB 		bl	cmdSet
 5712              	.LVL644:
2535:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5713              		.loc 1 2535 0
 5714 3298 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5715 329c 0730A0E1 		mov	r3, r7
 5716 32a0 0A10A0E1 		mov	r1, r10
 5717 32a4 00508DE5 		str	r5, [sp]
 5718 32a8 04A08DE5 		str	r10, [sp, #4]
 5719 32ac 30029FE5 		ldr	r0, .L497+4
 5720 32b0 FEFFFFEB 		bl	cmdSet
 5721              	.LVL645:
2538:../uvc.c      **** 
 5722              		.loc 1 2538 0
 5723 32b4 0620A0E1 		mov	r2, r6
 5724 32b8 0530A0E1 		mov	r3, r5
 5725 32bc 24129FE5 		ldr	r1, .L497+8
 5726 32c0 0400A0E3 		mov	r0, #4
2537:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5727              		.loc 1 2537 0
 5728 32c4 1262C4E5 		strb	r6, [r4, #530]
2536:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5729              		.loc 1 2536 0
 5730 32c8 1152C4E5 		strb	r5, [r4, #529]
2538:../uvc.c      **** 
 5731              		.loc 1 2538 0
 5732 32cc FEFFFFEB 		bl	CyU3PDebugPrint
 5733              	.LVL646:
2543:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5734              		.loc 1 2543 0
 5735 32d0 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5736              	.LVL647:
2544:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5737              		.loc 1 2544 0
 5738 32d4 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5739 32d8 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5740 32dc 40018DE8 		stmia	sp, {r6, r8}
 5741 32e0 FC019FE5 		ldr	r0, .L497+4
 5742 32e4 0210A0E3 		mov	r1, #2
 5743 32e8 FEFFFFEB 		bl	cmdSet
 5744              	.LVL648:
2547:../uvc.c      **** 
 5745              		.loc 1 2547 0
 5746 32ec 0620A0E1 		mov	r2, r6
 5747 32f0 0530A0E1 		mov	r3, r5
 5748 32f4 EC119FE5 		ldr	r1, .L497+8
 5749 32f8 0400A0E3 		mov	r0, #4
2545:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5750              		.loc 1 2545 0
 5751 32fc 2952C4E5 		strb	r5, [r4, #553]
2546:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5752              		.loc 1 2546 0
 5753 3300 6954C4E5 		strb	r5, [r4, #1129]
2547:../uvc.c      **** 
 5754              		.loc 1 2547 0
 5755 3304 FEFFFFEB 		bl	CyU3PDebugPrint
 5756              	.LVL649:
2552:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5757              		.loc 1 2552 0
 5758 3308 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2551:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5759              		.loc 1 2551 0
 5760 330c 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5761              	.LVL650:
2553:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5762              		.loc 1 2553 0
 5763 3310 80C047E2 		sub	ip, r7, #128
 5764 3314 FF300CE2 		and	r3, ip, #255
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5765              		.loc 1 2554 0
 5766 3318 76E047E2 		sub	lr, r7, #118
2553:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5767              		.loc 1 2553 0
 5768 331c 18308DE5 		str	r3, [sp, #24]
 5769 3320 08018DE8 		stmia	sp, {r3, r8}
 5770 3324 B8019FE5 		ldr	r0, .L497+4
 5771 3328 0630A0E1 		mov	r3, r6
 5772 332c 0510A0E3 		mov	r1, #5
 5773 3330 DF20A0E3 		mov	r2, #223
 5774 3334 14C08DE5 		str	ip, [sp, #20]
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5775              		.loc 1 2554 0
 5776 3338 1CE08DE5 		str	lr, [sp, #28]
2553:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5777              		.loc 1 2553 0
 5778 333c FEFFFFEB 		bl	cmdSet
 5779              	.LVL651:
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5780              		.loc 1 2554 0
 5781 3340 1C209DE5 		ldr	r2, [sp, #28]
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5782              		.loc 1 2555 0
 5783 3344 7EE087E2 		add	lr, r7, #126
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5784              		.loc 1 2554 0
 5785 3348 FF3002E2 		and	r3, r2, #255
 5786 334c 08048DE8 		stmia	sp, {r3, r10}
 5787 3350 8C019FE5 		ldr	r0, .L497+4
 5788 3354 0630A0E1 		mov	r3, r6
 5789 3358 0510A0E3 		mov	r1, #5
 5790 335c DC20A0E3 		mov	r2, #220
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5791              		.loc 1 2555 0
 5792 3360 20E08DE5 		str	lr, [sp, #32]
2554:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5793              		.loc 1 2554 0
 5794 3364 FEFFFFEB 		bl	cmdSet
 5795              	.LVL652:
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5796              		.loc 1 2555 0
 5797 3368 20209DE5 		ldr	r2, [sp, #32]
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5798              		.loc 1 2556 0
 5799 336c 72E087E2 		add	lr, r7, #114
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5800              		.loc 1 2555 0
 5801 3370 FF3002E2 		and	r3, r2, #255
 5802 3374 0220A0E3 		mov	r2, #2
 5803 3378 00308DE5 		str	r3, [sp]
 5804 337c 04208DE5 		str	r2, [sp, #4]
 5805 3380 0630A0E1 		mov	r3, r6
 5806 3384 0510A0E3 		mov	r1, #5
 5807 3388 DE20A0E3 		mov	r2, #222
 5808 338c 50019FE5 		ldr	r0, .L497+4
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5809              		.loc 1 2556 0
 5810 3390 24E08DE5 		str	lr, [sp, #36]
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5811              		.loc 1 2555 0
 5812 3394 FEFFFFEB 		bl	cmdSet
 5813              	.LVL653:
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5814              		.loc 1 2556 0
 5815 3398 24209DE5 		ldr	r2, [sp, #36]
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5816              		.loc 1 2557 0
 5817 339c 6FB047E2 		sub	fp, r7, #111
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5818              		.loc 1 2556 0
 5819 33a0 FF3002E2 		and	r3, r2, #255
 5820 33a4 0320A0E3 		mov	r2, #3
 5821 33a8 00308DE5 		str	r3, [sp]
 5822 33ac 04208DE5 		str	r2, [sp, #4]
 5823 33b0 0630A0E1 		mov	r3, r6
 5824 33b4 0510A0E3 		mov	r1, #5
 5825 33b8 E020A0E3 		mov	r2, #224
 5826 33bc 20019FE5 		ldr	r0, .L497+4
 5827 33c0 FEFFFFEB 		bl	cmdSet
 5828              	.LVL654:
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5829              		.loc 1 2557 0
 5830 33c4 0490A0E3 		mov	r9, #4
 5831 33c8 FF300BE2 		and	r3, fp, #255
2558:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5832              		.loc 1 2558 0
 5833 33cc 7F7087E2 		add	r7, r7, #127
 5834              	.LVL655:
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5835              		.loc 1 2557 0
 5836 33d0 00308DE5 		str	r3, [sp]
 5837 33d4 04908DE5 		str	r9, [sp, #4]
 5838 33d8 0630A0E1 		mov	r3, r6
 5839 33dc 0510A0E3 		mov	r1, #5
 5840 33e0 DD20A0E3 		mov	r2, #221
 5841 33e4 F8009FE5 		ldr	r0, .L497+4
 5842 33e8 FEFFFFEB 		bl	cmdSet
 5843              	.LVL656:
2558:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5844              		.loc 1 2558 0
 5845 33ec FF2007E2 		and	r2, r7, #255
 5846 33f0 0510A0E3 		mov	r1, #5
 5847 33f4 0630A0E1 		mov	r3, r6
 5848 33f8 00208DE5 		str	r2, [sp]
 5849 33fc 04108DE5 		str	r1, [sp, #4]
 5850 3400 E120A0E3 		mov	r2, #225
 5851 3404 D8009FE5 		ldr	r0, .L497+4
 5852 3408 FEFFFFEB 		bl	cmdSet
 5853              	.LVL657:
2560:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5854              		.loc 1 2560 0
 5855 340c 14C09DE5 		ldr	ip, [sp, #20]
 5856 3410 24E09DE5 		ldr	lr, [sp, #36]
 5857 3414 20309DE5 		ldr	r3, [sp, #32]
 5858 3418 0C20A0E1 		mov	r2, ip
2559:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5859              		.loc 1 2559 0
 5860 341c 18C09DE5 		ldr	ip, [sp, #24]
2560:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5861              		.loc 1 2560 0
 5862 3420 04E08DE5 		str	lr, [sp, #4]
 5863 3424 00308DE5 		str	r3, [sp]
 5864 3428 0C708DE5 		str	r7, [sp, #12]
 5865 342c 1C309DE5 		ldr	r3, [sp, #28]
 5866 3430 08B08DE5 		str	fp, [sp, #8]
 5867 3434 0900A0E1 		mov	r0, r9
 5868 3438 AC109FE5 		ldr	r1, .L497+12
2559:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5869              		.loc 1 2559 0
 5870 343c 71C2C4E5 		strb	ip, [r4, #625]
2560:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5871              		.loc 1 2560 0
 5872 3440 FEFFFFEB 		bl	CyU3PDebugPrint
 5873              	.LVL658:
2565:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5874              		.loc 1 2565 0
 5875 3444 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5876              	.LVL659:
2564:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5877              		.loc 1 2564 0
 5878 3448 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5879              	.LVL660:
2566:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5880              		.loc 1 2566 0
 5881 344c 00608DE5 		str	r6, [sp]
 5882 3450 0730A0E1 		mov	r3, r7
 5883 3454 04808DE5 		str	r8, [sp, #4]
 5884 3458 0610A0E3 		mov	r1, #6
 5885 345c 8520A0E3 		mov	r2, #133
 5886 3460 7C009FE5 		ldr	r0, .L497+4
 5887 3464 FEFFFFEB 		bl	cmdSet
 5888              	.LVL661:
2567:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5889              		.loc 1 2567 0
 5890 3468 40048DE8 		stmia	sp, {r6, r10}
 5891 346c 70009FE5 		ldr	r0, .L497+4
 5892 3470 0730A0E1 		mov	r3, r7
 5893 3474 0610A0E3 		mov	r1, #6
 5894 3478 8620A0E3 		mov	r2, #134
 5895 347c FEFFFFEB 		bl	cmdSet
 5896              	.LVL662:
2569:../uvc.c      **** 
 5897              		.loc 1 2569 0
 5898 3480 0620A0E1 		mov	r2, r6
 5899 3484 0530A0E1 		mov	r3, r5
 5900 3488 0900A0E1 		mov	r0, r9
 5901 348c 54109FE5 		ldr	r1, .L497+8
2568:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5902              		.loc 1 2568 0
 5903 3490 8962C4E5 		strb	r6, [r4, #649]
2569:../uvc.c      **** 
 5904              		.loc 1 2569 0
 5905 3494 FEFFFFEB 		bl	CyU3PDebugPrint
 5906              	.LVL663:
2574:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5907              		.loc 1 2574 0
 5908 3498 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5909              	.LVL664:
2575:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5910              		.loc 1 2575 0
 5911 349c 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5912 34a0 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5913 34a4 40018DE8 		stmia	sp, {r6, r8}
 5914 34a8 34009FE5 		ldr	r0, .L497+4
 5915 34ac 0710A0E3 		mov	r1, #7
 5916 34b0 FEFFFFEB 		bl	cmdSet
 5917              	.LVL665:
2577:../uvc.c      **** 
 5918              		.loc 1 2577 0
 5919 34b4 0620A0E1 		mov	r2, r6
 5920 34b8 0530A0E1 		mov	r3, r5
 5921 34bc 0900A0E1 		mov	r0, r9
 5922 34c0 20109FE5 		ldr	r1, .L497+8
2576:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5923              		.loc 1 2576 0
 5924 34c4 A152C4E5 		strb	r5, [r4, #673]
2577:../uvc.c      **** 
 5925              		.loc 1 2577 0
 5926 34c8 FEFFFFEB 		bl	CyU3PDebugPrint
 5927              	.LVL666:
2579:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5928              		.loc 1 2579 0
 5929 34cc 10209FE5 		ldr	r2, .L497+4
 5930 34d0 1C0092E5 		ldr	r0, [r2, #28]
2582:../uvc.c      **** 
 5931              		.loc 1 2582 0
 5932 34d4 2CD08DE2 		add	sp, sp, #44
 5933              		@ sp needed
 5934 34d8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5935              	.LVL667:
2579:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5936              		.loc 1 2579 0
 5937 34dc FEFFFFEA 		b	_txe_mutex_put
 5938              	.LVL668:
 5939              	.L498:
 5940              		.align	2
 5941              	.L497:
 5942 34e0 00000000 		.word	.LANCHOR1
 5943 34e4 00000000 		.word	statQu
 5944 34e8 50070000 		.word	.LC40
 5945 34ec 70070000 		.word	.LC41
 5946              		.cfi_endproc
 5947              	.LFE5:
 5949              		.align	2
 5950              		.global	CyFxUVCAddHeader
 5952              	CyFxUVCAddHeader:
 5953              	.LFB6:
2590:../uvc.c      ****     /* Copy header to buffer */
 5954              		.loc 1 2590 0
 5955              		.cfi_startproc
 5956              		@ args = 0, pretend = 0, frame = 0
 5957              		@ frame_needed = 0, uses_anonymous_args = 0
 5958              	.LVL669:
 5959 34f0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5960              	.LCFI23:
 5961              		.cfi_def_cfa_offset 16
 5962              		.cfi_offset 3, -16
 5963              		.cfi_offset 4, -12
 5964              		.cfi_offset 5, -8
 5965              		.cfi_offset 14, -4
2590:../uvc.c      ****     /* Copy header to buffer */
 5966              		.loc 1 2590 0
 5967 34f4 0040A0E1 		mov	r4, r0
 5968 34f8 0150A0E1 		mov	r5, r1
2592:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5969              		.loc 1 2592 0
 5970 34fc 30009FE5 		ldr	r0, .L504
 5971              	.LVL670:
 5972 3500 0010E0E3 		mvn	r1, #0
 5973              	.LVL671:
 5974 3504 FEFFFFEB 		bl	_txe_mutex_get
 5975              	.LVL672:
2593:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5976              		.loc 1 2593 0
 5977 3508 0400A0E1 		mov	r0, r4
 5978 350c 24109FE5 		ldr	r1, .L504+4
 5979 3510 0C20A0E3 		mov	r2, #12
 5980 3514 FEFFFFEB 		bl	CyU3PMemCopy
 5981              	.LVL673:
2594:../uvc.c      **** 
 5982              		.loc 1 2594 0
 5983 3518 14009FE5 		ldr	r0, .L504
 5984 351c FEFFFFEB 		bl	_txe_mutex_put
 5985              	.LVL674:
2597:../uvc.c      ****     {
 5986              		.loc 1 2597 0
 5987 3520 020015E3 		tst	r5, #2
2599:../uvc.c      ****     }
 5988              		.loc 1 2599 0
 5989 3524 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5990 3528 02308313 		orrne	r3, r3, #2
 5991 352c 0130C415 		strneb	r3, [r4, #1]
 5992 3530 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5993              	.L505:
 5994              		.align	2
 5995              	.L504:
 5996 3534 00000000 		.word	imgHdMux
 5997 3538 EC040000 		.word	.LANCHOR1+1260
 5998              		.cfi_endproc
 5999              	.LFE6:
 6001              		.align	2
 6002              		.global	CyFxAppErrorHandler
 6004              	CyFxAppErrorHandler:
 6005              	.LFB7:
2609:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6006              		.loc 1 2609 0
 6007              		.cfi_startproc
 6008              		@ Volatile: function does not return.
 6009              		@ args = 0, pretend = 0, frame = 0
 6010              		@ frame_needed = 0, uses_anonymous_args = 0
 6011              	.LVL675:
 6012 353c 08402DE9 		stmfd	sp!, {r3, lr}
 6013              	.LCFI24:
 6014              		.cfi_def_cfa_offset 8
 6015              		.cfi_offset 3, -8
 6016              		.cfi_offset 14, -4
 6017              	.LVL676:
 6018              	.L507:
2619:../uvc.c      ****         CyU3PThreadSleep (1000);
 6019              		.loc 1 2619 0 discriminator 1
 6020 3540 10109FE5 		ldr	r1, .L508
 6021 3544 0400A0E3 		mov	r0, #4
 6022 3548 FEFFFFEB 		bl	CyU3PDebugPrint
 6023              	.LVL677:
2620:../uvc.c      ****     }
 6024              		.loc 1 2620 0 discriminator 1
 6025 354c FA0FA0E3 		mov	r0, #1000
 6026 3550 FEFFFFEB 		bl	_tx_thread_sleep
 6027              	.LVL678:
 6028 3554 F9FFFFEA 		b	.L507
 6029              	.L509:
 6030              		.align	2
 6031              	.L508:
 6032 3558 A8070000 		.word	.LC42
 6033              		.cfi_endproc
 6034              	.LFE7:
 6036              		.align	2
 6037              		.global	UVCAppThread_Entry
 6039              	UVCAppThread_Entry:
 6040              	.LFB19:
3596:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6041              		.loc 1 3596 0
 6042              		.cfi_startproc
 6043              		@ args = 0, pretend = 0, frame = 128
 6044              		@ frame_needed = 0, uses_anonymous_args = 0
 6045              	.LVL679:
 6046 355c F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6047              	.LCFI25:
 6048              		.cfi_def_cfa_offset 32
 6049              		.cfi_offset 4, -32
 6050              		.cfi_offset 5, -28
 6051              		.cfi_offset 6, -24
 6052              		.cfi_offset 7, -20
 6053              		.cfi_offset 8, -16
 6054              		.cfi_offset 9, -12
 6055              		.cfi_offset 10, -8
 6056              		.cfi_offset 14, -4
 6057 3560 88D04DE2 		sub	sp, sp, #136
 6058              	.LCFI26:
 6059              		.cfi_def_cfa_offset 168
 6060              	.LBB98:
 6061              	.LBB99:
3052:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6062              		.loc 1 3052 0
 6063 3564 FEFFFFEB 		bl	CyU3PUartInit
 6064              	.LVL680:
3053:../uvc.c      ****     {
 6065              		.loc 1 3053 0
 6066 3568 004050E2 		subs	r4, r0, #0
 6067 356c 2902001A 		bne	.L591
3060:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6068              		.loc 1 3060 0
 6069 3570 582A9FE5 		ldr	r2, .L622
3061:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6070              		.loc 1 3061 0
 6071 3574 0130A0E3 		mov	r3, #1
3069:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6072              		.loc 1 3069 0
 6073 3578 0410A0E1 		mov	r1, r4
 6074 357c 60008DE2 		add	r0, sp, #96
 6075              	.LVL681:
3062:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6076              		.loc 1 3062 0
 6077 3580 7540CDE5 		strb	r4, [sp, #117]
3064:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6078              		.loc 1 3064 0
 6079 3584 64408DE5 		str	r4, [sp, #100]
3065:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6080              		.loc 1 3065 0
 6081 3588 68408DE5 		str	r4, [sp, #104]
3060:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6082              		.loc 1 3060 0
 6083 358c 70208DE5 		str	r2, [sp, #112]
3061:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6084              		.loc 1 3061 0
 6085 3590 7430CDE5 		strb	r3, [sp, #116]
3063:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6086              		.loc 1 3063 0
 6087 3594 60308DE5 		str	r3, [sp, #96]
3066:../uvc.c      **** 
 6088              		.loc 1 3066 0
 6089 3598 6C308DE5 		str	r3, [sp, #108]
3069:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6090              		.loc 1 3069 0
 6091 359c FEFFFFEB 		bl	CyU3PUartSetConfig
 6092              	.LVL682:
3070:../uvc.c      ****     {
 6093              		.loc 1 3070 0
 6094 35a0 000050E3 		cmp	r0, #0
 6095 35a4 B201001A 		bne	.L590
3076:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6096              		.loc 1 3076 0
 6097 35a8 0000E0E3 		mvn	r0, #0
 6098              	.LVL683:
 6099 35ac FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6100              	.LVL684:
3077:../uvc.c      ****     {
 6101              		.loc 1 3077 0
 6102 35b0 000050E3 		cmp	r0, #0
 6103 35b4 AE01001A 		bne	.L590
3083:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6104              		.loc 1 3083 0
 6105 35b8 0300A0E3 		mov	r0, #3
 6106              	.LVL685:
 6107 35bc 0410A0E3 		mov	r1, #4
 6108 35c0 FEFFFFEB 		bl	CyU3PDebugInit
 6109              	.LVL686:
3084:../uvc.c      ****     {
 6110              		.loc 1 3084 0
 6111 35c4 000050E3 		cmp	r0, #0
 6112 35c8 A901001A 		bne	.L590
3090:../uvc.c      **** }
 6113              		.loc 1 3090 0
 6114 35cc FEFFFFEB 		bl	CyU3PDebugPreamble
 6115              	.LVL687:
 6116 35d0 0640A0E3 		mov	r4, #6
 6117              	.LVL688:
 6118              	.L516:
 6119              	.LBE99:
 6120              	.LBE98:
3612:../uvc.c      **** 	}
 6121              		.loc 1 3612 0
 6122 35d4 7D0FA0E3 		mov	r0, #500
 6123 35d8 014044E2 		sub	r4, r4, #1
 6124 35dc FEFFFFEB 		bl	_tx_thread_sleep
 6125              	.LVL689:
3611:../uvc.c      **** 		CyU3PThreadSleep(500);
 6126              		.loc 1 3611 0
 6127 35e0 FF4014E2 		ands	r4, r4, #255
 6128 35e4 FAFFFF1A 		bne	.L516
 6129              	.LBB101:
 6130              	.LBB102:
3100:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6131              		.loc 1 3100 0
 6132 35e8 FEFFFFEB 		bl	CyU3PI2cInit
 6133              	.LVL690:
3101:../uvc.c      ****     {
 6134              		.loc 1 3101 0
 6135 35ec 005050E2 		subs	r5, r0, #0
 6136 35f0 3002001A 		bne	.L592
3108:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6137              		.loc 1 3108 0
 6138 35f4 D8299FE5 		ldr	r2, .L622+4
3110:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6139              		.loc 1 3110 0
 6140 35f8 0030E0E3 		mvn	r3, #0
3113:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6141              		.loc 1 3113 0
 6142 35fc 60008DE2 		add	r0, sp, #96
 6143              	.LVL691:
 6144 3600 0410A0E1 		mov	r1, r4
3109:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6145              		.loc 1 3109 0
 6146 3604 64408DE5 		str	r4, [sp, #100]
3108:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6147              		.loc 1 3108 0
 6148 3608 60208DE5 		str	r2, [sp, #96]
3110:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6149              		.loc 1 3110 0
 6150 360c 68308DE5 		str	r3, [sp, #104]
3111:../uvc.c      **** 
 6151              		.loc 1 3111 0
 6152 3610 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3113:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6153              		.loc 1 3113 0
 6154 3614 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6155              	.LVL692:
3114:../uvc.c      ****     {
 6156              		.loc 1 3114 0
 6157 3618 005050E2 		subs	r5, r0, #0
 6158 361c 2002001A 		bne	.L593
 6159              	.LBE102:
 6160              	.LBE101:
 6161              	.LBB104:
 6162              	.LBB105:
3187:../uvc.c      ****     if (apiRetStatus != 0)
 6163              		.loc 1 3187 0
 6164 3620 B0799FE5 		ldr	r7, .L622+8
 6165 3624 0410A0E1 		mov	r1, r4
 6166 3628 0700A0E1 		mov	r0, r7
 6167              	.LVL693:
 6168 362c 2820A0E3 		mov	r2, #40
 6169 3630 FEFFFFEB 		bl	_txe_event_flags_create
 6170              	.LVL694:
3188:../uvc.c      ****     {
 6171              		.loc 1 3188 0
 6172 3634 005050E2 		subs	r5, r0, #0
 6173              	.LVL695:
 6174 3638 1302001A 		bne	.L594
3202:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6175              		.loc 1 3202 0
 6176 363c 0230A0E3 		mov	r3, #2
3205:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6177              		.loc 1 3205 0
 6178 3640 0320A0E3 		mov	r2, #3
3209:../uvc.c      ****     if (apiRetStatus != 0)
 6179              		.loc 1 3209 0
 6180 3644 14008DE2 		add	r0, sp, #20
 6181              	.LVL696:
 6182 3648 0410A0E1 		mov	r1, r4
3198:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6183              		.loc 1 3198 0
 6184 364c 8C4087E5 		str	r4, [r7, #140]
3199:../uvc.c      **** 
 6185              		.loc 1 3199 0
 6186 3650 904087E5 		str	r4, [r7, #144]
3204:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6187              		.loc 1 3204 0
 6188 3654 1C40CDE5 		strb	r4, [sp, #28]
3206:../uvc.c      **** 
 6189              		.loc 1 3206 0
 6190 3658 18408DE5 		str	r4, [sp, #24]
3202:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6191              		.loc 1 3202 0
 6192 365c 1430CDE5 		strb	r3, [sp, #20]
3203:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6193              		.loc 1 3203 0
 6194 3660 1530CDE5 		strb	r3, [sp, #21]
3205:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6195              		.loc 1 3205 0
 6196 3664 1D20CDE5 		strb	r2, [sp, #29]
3209:../uvc.c      ****     if (apiRetStatus != 0)
 6197              		.loc 1 3209 0
 6198 3668 FEFFFFEB 		bl	CyU3PGpioInit
 6199              	.LVL697:
3210:../uvc.c      ****     {
 6200              		.loc 1 3210 0
 6201 366c 005050E2 		subs	r5, r0, #0
 6202 3670 FF01001A 		bne	.L595
3218:../uvc.c      ****     if (apiRetStatus != 0)
 6203              		.loc 1 3218 0
 6204 3674 1600A0E3 		mov	r0, #22
 6205              	.LVL698:
 6206 3678 0110A0E3 		mov	r1, #1
 6207 367c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6208              	.LVL699:
3219:../uvc.c      ****     {
 6209              		.loc 1 3219 0
 6210 3680 005050E2 		subs	r5, r0, #0
 6211 3684 3A02001A 		bne	.L596
3224:../uvc.c      ****     if (apiRetStatus != 0)
 6212              		.loc 1 3224 0
 6213 3688 1400A0E3 		mov	r0, #20
 6214              	.LVL700:
 6215 368c 0110A0E3 		mov	r1, #1
 6216 3690 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6217              	.LVL701:
3225:../uvc.c      ****     {
 6218              		.loc 1 3225 0
 6219 3694 005050E2 		subs	r5, r0, #0
 6220 3698 2F02001A 		bne	.L597
3230:../uvc.c      ****     if (apiRetStatus != 0)
 6221              		.loc 1 3230 0
 6222 369c 1800A0E3 		mov	r0, #24
 6223              	.LVL702:
 6224 36a0 0110A0E3 		mov	r1, #1
 6225 36a4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6226              	.LVL703:
3231:../uvc.c      ****     {
 6227              		.loc 1 3231 0
 6228 36a8 005050E2 		subs	r5, r0, #0
 6229 36ac 2402001A 		bne	.L598
3238:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6230              		.loc 1 3238 0
 6231 36b0 0150A0E3 		mov	r5, #1
3243:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6232              		.loc 1 3243 0
 6233 36b4 30108DE2 		add	r1, sp, #48
 6234 36b8 1600A0E3 		mov	r0, #22
 6235              	.LVL704:
3241:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6236              		.loc 1 3241 0
 6237 36bc 3C408DE5 		str	r4, [sp, #60]
3242:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6238              		.loc 1 3242 0
 6239 36c0 4040CDE5 		strb	r4, [sp, #64]
3238:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6240              		.loc 1 3238 0
 6241 36c4 30508DE5 		str	r5, [sp, #48]
3239:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6242              		.loc 1 3239 0
 6243 36c8 34508DE5 		str	r5, [sp, #52]
3240:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6244              		.loc 1 3240 0
 6245 36cc 38508DE5 		str	r5, [sp, #56]
3243:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6246              		.loc 1 3243 0
 6247 36d0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6248              	.LVL705:
3244:../uvc.c      ****     {
 6249              		.loc 1 3244 0
 6250 36d4 006050E2 		subs	r6, r0, #0
 6251 36d8 1302001A 		bne	.L599
3257:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6252              		.loc 1 3257 0
 6253 36dc 1400A0E3 		mov	r0, #20
 6254              	.LVL706:
 6255 36e0 30108DE2 		add	r1, sp, #48
3255:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6256              		.loc 1 3255 0
 6257 36e4 3C408DE5 		str	r4, [sp, #60]
3256:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6258              		.loc 1 3256 0
 6259 36e8 4040CDE5 		strb	r4, [sp, #64]
3252:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6260              		.loc 1 3252 0
 6261 36ec 30508DE5 		str	r5, [sp, #48]
3253:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6262              		.loc 1 3253 0
 6263 36f0 34508DE5 		str	r5, [sp, #52]
3254:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6264              		.loc 1 3254 0
 6265 36f4 38508DE5 		str	r5, [sp, #56]
3257:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6266              		.loc 1 3257 0
 6267 36f8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6268              	.LVL707:
3258:../uvc.c      ****     {
 6269              		.loc 1 3258 0
 6270 36fc 004050E2 		subs	r4, r0, #0
 6271 3700 0302001A 		bne	.L600
3266:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6272              		.loc 1 3266 0
 6273 3704 0030A0E3 		mov	r3, #0
3271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6274              		.loc 1 3271 0
 6275 3708 30108DE2 		add	r1, sp, #48
3269:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6276              		.loc 1 3269 0
 6277 370c 0150A0E3 		mov	r5, #1
3271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6278              		.loc 1 3271 0
 6279 3710 1800A0E3 		mov	r0, #24
 6280              	.LVL708:
3266:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6281              		.loc 1 3266 0
 6282 3714 30308DE5 		str	r3, [sp, #48]
3267:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6283              		.loc 1 3267 0
 6284 3718 34308DE5 		str	r3, [sp, #52]
3268:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6285              		.loc 1 3268 0
 6286 371c 38308DE5 		str	r3, [sp, #56]
3270:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6287              		.loc 1 3270 0
 6288 3720 4030CDE5 		strb	r3, [sp, #64]
3269:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6289              		.loc 1 3269 0
 6290 3724 3C508DE5 		str	r5, [sp, #60]
3271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6291              		.loc 1 3271 0
 6292 3728 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6293              	.LVL709:
3272:../uvc.c      ****     {
 6294              		.loc 1 3272 0
 6295 372c 004050E2 		subs	r4, r0, #0
 6296 3730 F101001A 		bne	.L601
3279:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6297              		.loc 1 3279 0
 6298 3734 0260A0E3 		mov	r6, #2
3280:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6299              		.loc 1 3280 0
 6300 3738 0380A0E3 		mov	r8, #3
3284:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6301              		.loc 1 3284 0
 6302 373c 0500A0E1 		mov	r0, r5
 6303              	.LVL710:
 6304 3740 20108DE2 		add	r1, sp, #32
3281:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6305              		.loc 1 3281 0
 6306 3744 28408DE5 		str	r4, [sp, #40]
3282:../uvc.c      **** 
 6307              		.loc 1 3282 0
 6308 3748 24408DE5 		str	r4, [sp, #36]
3279:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6309              		.loc 1 3279 0
 6310 374c B062CDE1 		strh	r6, [sp, #32]	@ movhi
3280:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6311              		.loc 1 3280 0
 6312 3750 2C80CDE5 		strb	r8, [sp, #44]
3284:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6313              		.loc 1 3284 0
 6314 3754 FEFFFFEB 		bl	CyU3PPibInit
 6315              	.LVL711:
3285:../uvc.c      ****     {
 6316              		.loc 1 3285 0
 6317 3758 004050E2 		subs	r4, r0, #0
 6318 375c E001001A 		bne	.L602
3292:../uvc.c      **** 
 6319              		.loc 1 3292 0
 6320 3760 74089FE5 		ldr	r0, .L622+12
 6321              	.LVL712:
 6322 3764 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6323              	.LVL713:
3300:../uvc.c      ****     CyU3PThreadSleep(5000);
 6324              		.loc 1 3300 0
 6325 3768 FEFFFFEB 		bl	SensorReset
 6326              	.LVL714:
3301:../uvc.c      ****     //SensorInit ();
 6327              		.loc 1 3301 0
 6328 376c 6C089FE5 		ldr	r0, .L622+16
 6329 3770 FEFFFFEB 		bl	_tx_thread_sleep
 6330              	.LVL715:
3305:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6331              		.loc 1 3305 0
 6332 3774 FEFFFFEB 		bl	CyU3PUsbStart
 6333              	.LVL716:
3306:../uvc.c      ****     {
 6334              		.loc 1 3306 0
 6335 3778 004050E2 		subs	r4, r0, #0
 6336 377c D201001A 		bne	.L603
3312:../uvc.c      **** 
 6337              		.loc 1 3312 0
 6338 3780 0410A0E1 		mov	r1, r4
 6339 3784 58089FE5 		ldr	r0, .L622+20
 6340              	.LVL717:
 6341 3788 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6342              	.LVL718:
3315:../uvc.c      **** 
 6343              		.loc 1 3315 0
 6344 378c 54089FE5 		ldr	r0, .L622+24
 6345 3790 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6346              	.LVL719:
3321:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6347              		.loc 1 3321 0
 6348 3794 0410A0E1 		mov	r1, r4
 6349 3798 4C289FE5 		ldr	r2, .L622+28
 6350 379c 0500A0E1 		mov	r0, r5
 6351 37a0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6352              	.LVL720:
3322:../uvc.c      **** 
 6353              		.loc 1 3322 0
 6354 37a4 0410A0E1 		mov	r1, r4
 6355 37a8 0400A0E1 		mov	r0, r4
 6356 37ac 3C289FE5 		ldr	r2, .L622+32
 6357 37b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6358              	.LVL721:
3325:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6359              		.loc 1 3325 0
 6360 37b4 0410A0E1 		mov	r1, r4
 6361 37b8 34289FE5 		ldr	r2, .L622+36
 6362 37bc 0600A0E1 		mov	r0, r6
 6363 37c0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6364              	.LVL722:
3326:../uvc.c      **** 
 6365              		.loc 1 3326 0
 6366 37c4 0410A0E1 		mov	r1, r4
 6367 37c8 28289FE5 		ldr	r2, .L622+40
 6368 37cc 0700A0E3 		mov	r0, #7
 6369 37d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6370              	.LVL723:
3329:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6371              		.loc 1 3329 0
 6372 37d4 0410A0E1 		mov	r1, r4
 6373 37d8 1C289FE5 		ldr	r2, .L622+44
 6374 37dc 0400A0E3 		mov	r0, #4
 6375 37e0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6376              	.LVL724:
3330:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6377              		.loc 1 3330 0
 6378 37e4 0410A0E1 		mov	r1, r4
 6379 37e8 10289FE5 		ldr	r2, .L622+48
 6380 37ec 0800A0E1 		mov	r0, r8
 6381 37f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6382              	.LVL725:
3331:../uvc.c      **** 
 6383              		.loc 1 3331 0
 6384 37f4 0410A0E1 		mov	r1, r4
 6385 37f8 04289FE5 		ldr	r2, .L622+52
 6386 37fc 0600A0E3 		mov	r0, #6
 6387 3800 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6388              	.LVL726:
3334:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6389              		.loc 1 3334 0
 6390 3804 0410A0E1 		mov	r1, r4
 6391 3808 F8279FE5 		ldr	r2, .L622+56
 6392 380c 0500A0E3 		mov	r0, #5
 6393 3810 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6394              	.LVL727:
3335:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6395              		.loc 1 3335 0
 6396 3814 0510A0E1 		mov	r1, r5
 6397 3818 EC279FE5 		ldr	r2, .L622+60
 6398 381c 0500A0E3 		mov	r0, #5
 6399 3820 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6400              	.LVL728:
3336:../uvc.c      **** 
 6401              		.loc 1 3336 0
 6402 3824 0610A0E1 		mov	r1, r6
 6403 3828 E0279FE5 		ldr	r2, .L622+64
 6404 382c 0500A0E3 		mov	r0, #5
 6405 3830 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6406              	.LVL729:
3345:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6407              		.loc 1 3345 0
 6408 3834 4030A0E3 		mov	r3, #64
3349:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6409              		.loc 1 3349 0
 6410 3838 08108DE2 		add	r1, sp, #8
 6411 383c 8200A0E3 		mov	r0, #130
3346:../uvc.c      ****     endPointConfig.streams  = 0;
 6412              		.loc 1 3346 0
 6413 3840 1340CDE5 		strb	r4, [sp, #19]
3347:../uvc.c      ****     endPointConfig.burstLen = 1;
 6414              		.loc 1 3347 0
 6415 3844 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3343:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6416              		.loc 1 3343 0
 6417 3848 08508DE5 		str	r5, [sp, #8]
3344:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6418              		.loc 1 3344 0
 6419 384c 0C80CDE5 		strb	r8, [sp, #12]
3348:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6420              		.loc 1 3348 0
 6421 3850 1250CDE5 		strb	r5, [sp, #18]
3345:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6422              		.loc 1 3345 0
 6423 3854 B031CDE1 		strh	r3, [sp, #16]	@ movhi
3349:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6424              		.loc 1 3349 0
 6425 3858 FEFFFFEB 		bl	CyU3PSetEpConfig
 6426              	.LVL730:
3350:../uvc.c      ****     {
 6427              		.loc 1 3350 0
 6428 385c 004050E2 		subs	r4, r0, #0
3353:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6429              		.loc 1 3353 0
 6430 3860 0400A013 		movne	r0, #4
 6431              	.LVL731:
3350:../uvc.c      ****     {
 6432              		.loc 1 3350 0
 6433 3864 7101001A 		bne	.L588
3358:../uvc.c      ****     dmaInterConfig.count          = 1;
 6434              		.loc 1 3358 0
 6435 3868 A4C79FE5 		ldr	ip, .L622+68
 6436 386c 413BA0E3 		mov	r3, #66560
3367:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6437              		.loc 1 3367 0
 6438 3870 1080A0E3 		mov	r8, #16
3369:../uvc.c      ****             &dmaInterConfig);
 6439              		.loc 1 3369 0
 6440 3874 9C079FE5 		ldr	r0, .L622+72
 6441 3878 0410A0E3 		mov	r1, #4
 6442 387c 44208DE2 		add	r2, sp, #68
3358:../uvc.c      ****     dmaInterConfig.count          = 1;
 6443              		.loc 1 3358 0
 6444 3880 4C408DE5 		str	r4, [sp, #76]
 6445 3884 50408DE5 		str	r4, [sp, #80]
3366:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6446              		.loc 1 3366 0
 6447 3888 5440CDE5 		strb	r4, [sp, #84]
3368:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6448              		.loc 1 3368 0
 6449 388c 5C408DE5 		str	r4, [sp, #92]
3358:../uvc.c      ****     dmaInterConfig.count          = 1;
 6450              		.loc 1 3358 0
 6451 3890 48C08DE5 		str	ip, [sp, #72]
 6452 3894 44308DE5 		str	r3, [sp, #68]
3367:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6453              		.loc 1 3367 0
 6454 3898 58808DE5 		str	r8, [sp, #88]
3369:../uvc.c      ****             &dmaInterConfig);
 6455              		.loc 1 3369 0
 6456 389c FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6457              	.LVL732:
3371:../uvc.c      ****     {
 6458              		.loc 1 3371 0
 6459 38a0 004050E2 		subs	r4, r0, #0
 6460 38a4 BE01001A 		bne	.L604
3378:../uvc.c      ****     if (glInterStaBuffer == 0)
 6461              		.loc 1 3378 0
 6462 38a8 010BA0E3 		mov	r0, #1024
 6463              	.LVL733:
 6464 38ac FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6465              	.LVL734:
 6466 38b0 64379FE5 		ldr	r3, .L622+76
3379:../uvc.c      ****     {
 6467              		.loc 1 3379 0
 6468 38b4 000050E3 		cmp	r0, #0
3378:../uvc.c      ****     if (glInterStaBuffer == 0)
 6469              		.loc 1 3378 0
 6470 38b8 000083E5 		str	r0, [r3]
3379:../uvc.c      ****     {
 6471              		.loc 1 3379 0
 6472 38bc BE01000A 		beq	.L605
3386:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6473              		.loc 1 3386 0
 6474 38c0 0410A0E1 		mov	r1, r4
 6475 38c4 0420A0E1 		mov	r2, r4
 6476 38c8 3830A0E3 		mov	r3, #56
 6477 38cc 4C079FE5 		ldr	r0, .L622+80
 6478 38d0 FEFFFFEB 		bl	_txe_mutex_create
 6479              	.LVL735:
3391:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6480              		.loc 1 3391 0
 6481 38d4 48179FE5 		ldr	r1, .L622+84
3392:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6482              		.loc 1 3392 0
 6483 38d8 48279FE5 		ldr	r2, .L622+88
3399:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6484              		.loc 1 3399 0
 6485 38dc 48A79FE5 		ldr	r10, .L622+92
3388:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6486              		.loc 1 3388 0
 6487 38e0 0480A0E3 		mov	r8, #4
3390:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6488              		.loc 1 3390 0
 6489 38e4 01ECA0E3 		mov	lr, #256
3394:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6490              		.loc 1 3394 0
 6491 38e8 0CC0A0E3 		mov	ip, #12
3398:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6492              		.loc 1 3398 0
 6493 38ec 1830A0E3 		mov	r3, #24
3391:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6494              		.loc 1 3391 0
 6495 38f0 B816CDE1 		strh	r1, [sp, #104]	@ movhi
3392:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6496              		.loc 1 3392 0
 6497 38f4 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3387:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6498              		.loc 1 3387 0
 6499 38f8 0199A0E3 		mov	r9, #16384
3400:../uvc.c      ****             &dmaMultiConfig);
 6500              		.loc 1 3400 0
 6501 38fc 2C079FE5 		ldr	r0, .L622+96
 6502 3900 0710A0E3 		mov	r1, #7
 6503 3904 60208DE2 		add	r2, sp, #96
3393:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6504              		.loc 1 3393 0
 6505 3908 B647CDE1 		strh	r4, [sp, #118]	@ movhi
3396:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6506              		.loc 1 3396 0
 6507 390c BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3397:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6508              		.loc 1 3397 0
 6509 3910 7E40CDE5 		strb	r4, [sp, #126]
3389:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6510              		.loc 1 3389 0
 6511 3914 B466CDE1 		strh	r6, [sp, #100]	@ movhi
3399:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6512              		.loc 1 3399 0
 6513 3918 84A08DE5 		str	r10, [sp, #132]
3387:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6514              		.loc 1 3387 0
 6515 391c B096CDE1 		strh	r9, [sp, #96]	@ movhi
3388:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6516              		.loc 1 3388 0
 6517 3920 B286CDE1 		strh	r8, [sp, #98]	@ movhi
3395:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6518              		.loc 1 3395 0
 6519 3924 BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3390:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6520              		.loc 1 3390 0
 6521 3928 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3394:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6522              		.loc 1 3394 0
 6523 392c B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3398:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6524              		.loc 1 3398 0
 6525 3930 80308DE5 		str	r3, [sp, #128]
3400:../uvc.c      ****             &dmaMultiConfig);
 6526              		.loc 1 3400 0
 6527 3934 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6528              	.LVL736:
3402:../uvc.c      ****     {
 6529              		.loc 1 3402 0
 6530 3938 004050E2 		subs	r4, r0, #0
 6531 393c 9201001A 		bne	.L606
3493:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6532              		.loc 1 3493 0
 6533 3940 0500A0E1 		mov	r0, r5
 6534              	.LVL737:
 6535 3944 0510A0E1 		mov	r1, r5
 6536 3948 FEFFFFEB 		bl	CyU3PConnectState
 6537              	.LVL738:
3494:../uvc.c      ****     {
 6538              		.loc 1 3494 0
 6539 394c 004050E2 		subs	r4, r0, #0
 6540 3950 3B01001A 		bne	.L607
3500:../uvc.c      **** 
 6541              		.loc 1 3500 0
 6542 3954 6400A0E3 		mov	r0, #100
 6543              	.LVL739:
 6544 3958 FEFFFFEB 		bl	CyFx3BusyWait
 6545              	.LVL740:
3502:../uvc.c      **** 
 6546              		.loc 1 3502 0
 6547 395c FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6548              	.LVL741:
3517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6549              		.loc 1 3517 0
 6550 3960 08108DE2 		add	r1, sp, #8
3516:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6551              		.loc 1 3516 0
 6552 3964 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3504:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6553              		.loc 1 3504 0
 6554 3968 08508DE5 		str	r5, [sp, #8]
3505:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6555              		.loc 1 3505 0
 6556 396c 0C60CDE5 		strb	r6, [sp, #12]
3509:../uvc.c      ****     }
 6557              		.loc 1 3509 0
 6558 3970 030050E3 		cmp	r0, #3
3502:../uvc.c      **** 
 6559              		.loc 1 3502 0
 6560 3974 0030A0E1 		mov	r3, r0
3509:../uvc.c      ****     }
 6561              		.loc 1 3509 0
 6562 3978 01C0A013 		movne	ip, #1
 6563 397c 10C0A003 		moveq	ip, #16
 6564 3980 022CA013 		movne	r2, #512
 6565 3984 012BA003 		moveq	r2, #1024
3517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6566              		.loc 1 3517 0
 6567 3988 8300A0E3 		mov	r0, #131
3502:../uvc.c      **** 
 6568              		.loc 1 3502 0
 6569 398c 4830C7E5 		strb	r3, [r7, #72]
 6570 3990 12C0CDE5 		strb	ip, [sp, #18]
 6571 3994 B021CDE1 		strh	r2, [sp, #16]	@ movhi
3517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6572              		.loc 1 3517 0
 6573 3998 FEFFFFEB 		bl	CyU3PSetEpConfig
 6574              	.LVL742:
3518:../uvc.c      ****     {
 6575              		.loc 1 3518 0
 6576 399c 004050E2 		subs	r4, r0, #0
 6577              	.LBE105:
 6578              	.LBE104:
3641:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6579              		.loc 1 3641 0
 6580 39a0 30469F05 		ldreq	r4, .L622+8
 6581              	.LBB110:
 6582              	.LBB106:
3518:../uvc.c      ****     {
 6583              		.loc 1 3518 0
 6584 39a4 0C00000A 		beq	.L567
 6585 39a8 1F0100EA 		b	.L621
 6586              	.LVL743:
 6587              	.L610:
 6588              	.LBE106:
 6589              	.LBE110:
3687:../uvc.c      ****             {
 6590              		.loc 1 3687 0
 6591 39ac 7C3094E5 		ldr	r3, [r4, #124]
 6592 39b0 050053E1 		cmp	r3, r5
 6593 39b4 0300000A 		beq	.L537
3687:../uvc.c      ****             {
 6594              		.loc 1 3687 0 is_stmt 0 discriminator 1
 6595 39b8 B028D4E1 		ldrh	r2, [r4, #128]
 6596 39bc B238D4E1 		ldrh	r3, [r4, #130]
 6597 39c0 030052E1 		cmp	r2, r3
 6598 39c4 3B00000A 		beq	.L609
 6599              	.L537:
3891:../uvc.c      **** 
 6600              		.loc 1 3891 0 is_stmt 1
 6601 39c8 4010A0E3 		mov	r1, #64
 6602 39cc 0020A0E3 		mov	r2, #0
 6603 39d0 00069FE5 		ldr	r0, .L622+8
 6604 39d4 FEFFFFEB 		bl	_txe_event_flags_set
 6605              	.LVL744:
3894:../uvc.c      ****     }
 6606              		.loc 1 3894 0
 6607 39d8 FEFFFFEB 		bl	_txe_thread_relinquish
 6608              	.LVL745:
 6609              	.L567:
3641:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6610              		.loc 1 3641 0
 6611 39dc 0050A0E3 		mov	r5, #0
 6612 39e0 00508DE5 		str	r5, [sp]
 6613 39e4 EC059FE5 		ldr	r0, .L622+8
 6614 39e8 0110A0E3 		mov	r1, #1
 6615 39ec 0220A0E3 		mov	r2, #2
 6616 39f0 60308DE2 		add	r3, sp, #96
 6617 39f4 FEFFFFEB 		bl	_txe_event_flags_get
 6618              	.LVL746:
 6619 39f8 006050E2 		subs	r6, r0, #0
 6620 39fc EAFFFF0A 		beq	.L610
3798:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6621              		.loc 1 3798 0
 6622 3a00 00508DE5 		str	r5, [sp]
 6623 3a04 CC059FE5 		ldr	r0, .L622+8
 6624 3a08 0210A0E3 		mov	r1, #2
 6625 3a0c 0320A0E3 		mov	r2, #3
 6626 3a10 60308DE2 		add	r3, sp, #96
 6627 3a14 FEFFFFEB 		bl	_txe_event_flags_get
 6628              	.LVL747:
 6629 3a18 000050E3 		cmp	r0, #0
 6630 3a1c 0B00001A 		bne	.L559
3813:../uvc.c      ****                 {
 6631              		.loc 1 3813 0
 6632 3a20 903094E5 		ldr	r3, [r4, #144]
3801:../uvc.c      ****                 prodCount = 0;
 6633              		.loc 1 3801 0
 6634 3a24 7C0084E5 		str	r0, [r4, #124]
3813:../uvc.c      ****                 {
 6635              		.loc 1 3813 0
 6636 3a28 000053E3 		cmp	r3, #0
3802:../uvc.c      ****                 consCount = 0;
 6637              		.loc 1 3802 0
 6638 3a2c B008C4E1 		strh	r0, [r4, #128]	@ movhi
3809:../uvc.c      ****                 pb=0;
 6639              		.loc 1 3809 0
 6640 3a30 B407C4E1 		strh	r0, [r4, #116]	@ movhi
3803:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6641              		.loc 1 3803 0
 6642 3a34 B208C4E1 		strh	r0, [r4, #130]	@ movhi
3810:../uvc.c      ****                 pbc=0;
 6643              		.loc 1 3810 0
 6644 3a38 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3811:../uvc.c      **** 
 6645              		.loc 1 3811 0
 6646 3a3c B807C4E1 		strh	r0, [r4, #120]	@ movhi
3813:../uvc.c      ****                 {
 6647              		.loc 1 3813 0
 6648 3a40 4600000A 		beq	.L611
 6649              	.L560:
3825:../uvc.c      ****             }
 6650              		.loc 1 3825 0
 6651 3a44 0030A0E3 		mov	r3, #0
 6652 3a48 903087E5 		str	r3, [r7, #144]
 6653 3a4c DDFFFFEA 		b	.L537
 6654              	.L559:
3830:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6655              		.loc 1 3830 0
 6656 3a50 0030E0E3 		mvn	r3, #0
 6657 3a54 00308DE5 		str	r3, [sp]
 6658 3a58 0110A0E3 		mov	r1, #1
 6659 3a5c 0220A0E3 		mov	r2, #2
 6660 3a60 60308DE2 		add	r3, sp, #96
 6661 3a64 6C059FE5 		ldr	r0, .L622+8
 6662 3a68 FEFFFFEB 		bl	_txe_event_flags_get
 6663              	.LVL748:
3834:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6664              		.loc 1 3834 0
 6665 3a6c 0510A0E1 		mov	r1, r5
 6666 3a70 0520A0E1 		mov	r2, r5
 6667 3a74 B4059FE5 		ldr	r0, .L622+96
 6668 3a78 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6669              	.LVL749:
3835:../uvc.c      ****                 {
 6670              		.loc 1 3835 0
 6671 3a7c 005050E2 		subs	r5, r0, #0
 6672 3a80 9D00001A 		bne	.L612
3843:../uvc.c      ****                 {
 6673              		.loc 1 3843 0
 6674 3a84 883094E5 		ldr	r3, [r4, #136]
 6675 3a88 000053E3 		cmp	r3, #0
 6676 3a8c 2B00001A 		bne	.L558
 6677              	.LVL750:
 6678              	.LBB111:
 6679              	.LBB112:
3546:../uvc.c      ****     {
 6680              		.loc 1 3546 0
 6681 3a90 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6682 3a94 030053E3 		cmp	r3, #3
 6683 3a98 5E00000A 		beq	.L613
3551:../uvc.c      ****     {
 6684              		.loc 1 3551 0
 6685 3a9c 020053E3 		cmp	r3, #2
 6686 3aa0 7400000A 		beq	.L614
 6687              	.LVL751:
 6688              	.L565:
 6689              	.LBE112:
 6690              	.LBE111:
3879:../uvc.c      ****                     CyU3PThreadSleep(200);
 6691              		.loc 1 3879 0
 6692 3aa4 0130A0E3 		mov	r3, #1
3880:../uvc.c      ****                     
 6693              		.loc 1 3880 0
 6694 3aa8 C800A0E3 		mov	r0, #200
3879:../uvc.c      ****                     CyU3PThreadSleep(200);
 6695              		.loc 1 3879 0
 6696 3aac 883087E5 		str	r3, [r7, #136]
3880:../uvc.c      ****                     
 6697              		.loc 1 3880 0
 6698 3ab0 FEFFFFEB 		bl	_tx_thread_sleep
 6699              	.LVL752:
 6700 3ab4 C3FFFFEA 		b	.L537
 6701              	.L609:
3713:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6702              		.loc 1 3713 0
 6703 3ab8 74559FE5 		ldr	r5, .L622+100
3712:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6704              		.loc 1 3712 0
 6705 3abc 5C059FE5 		ldr	r0, .L622+80
 6706 3ac0 0010E0E3 		mvn	r1, #0
3697:../uvc.c      ****                 consCount = 0;
 6707              		.loc 1 3697 0
 6708 3ac4 B068C4E1 		strh	r6, [r4, #128]	@ movhi
3694:../uvc.c      ****             	pb=0;
 6709              		.loc 1 3694 0
 6710 3ac8 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3698:../uvc.c      ****                 hitFV     = CyFalse;
 6711              		.loc 1 3698 0
 6712 3acc B268C4E1 		strh	r6, [r4, #130]	@ movhi
3695:../uvc.c      ****             	pbc=0;
 6713              		.loc 1 3695 0
 6714 3ad0 B667C4E1 		strh	r6, [r4, #118]	@ movhi
3696:../uvc.c      ****                 prodCount = 0;
 6715              		.loc 1 3696 0
 6716 3ad4 B867C4E1 		strh	r6, [r4, #120]	@ movhi
3699:../uvc.c      **** 
 6717              		.loc 1 3699 0
 6718 3ad8 7C6084E5 		str	r6, [r4, #124]
3712:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6719              		.loc 1 3712 0
 6720 3adc FEFFFFEB 		bl	_txe_mutex_get
 6721              	.LVL753:
3713:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6722              		.loc 1 3713 0
 6723 3ae0 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6724 3ae4 013023E2 		eor	r3, r3, #1
 6725 3ae8 ED34C5E5 		strb	r3, [r5, #1261]
3715:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6726              		.loc 1 3715 0
 6727 3aec 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6728 3af0 F00053E3 		cmp	r3, #240
 6729 3af4 3B00000A 		beq	.L615
 6730              	.L538:
3723:../uvc.c      **** 
 6731              		.loc 1 3723 0
 6732 3af8 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6733 3afc FF0053E3 		cmp	r3, #255
 6734 3b00 1D00000A 		beq	.L616
3735:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6735              		.loc 1 3735 0
 6736 3b04 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6737 3b08 AA0053E3 		cmp	r3, #170
 6738 3b0c 2700000A 		beq	.L617
 6739              	.L539:
3773:../uvc.c      ****                 /* Reset the DMA channel. */
 6740              		.loc 1 3773 0
 6741 3b10 08059FE5 		ldr	r0, .L622+80
 6742 3b14 FEFFFFEB 		bl	_txe_mutex_put
 6743              	.LVL754:
3775:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6744              		.loc 1 3775 0
 6745 3b18 10059FE5 		ldr	r0, .L622+96
 6746 3b1c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6747              	.LVL755:
3776:../uvc.c      ****                 {
 6748              		.loc 1 3776 0
 6749 3b20 005050E2 		subs	r5, r0, #0
 6750 3b24 7A00001A 		bne	.L618
3783:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6751              		.loc 1 3783 0
 6752 3b28 0510A0E1 		mov	r1, r5
 6753 3b2c 0520A0E1 		mov	r2, r5
 6754 3b30 F8049FE5 		ldr	r0, .L622+96
 6755              	.LVL756:
 6756 3b34 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6757              	.LVL757:
3784:../uvc.c      ****                 {
 6758              		.loc 1 3784 0
 6759 3b38 005050E2 		subs	r5, r0, #0
 6760 3b3c 6800001A 		bne	.L619
 6761              	.L558:
3792:../uvc.c      ****                 }
 6762              		.loc 1 3792 0
 6763 3b40 DC049FE5 		ldr	r0, .L622+84
 6764              	.LVL758:
 6765 3b44 0230A0E3 		mov	r3, #2
 6766 3b48 0010A0E3 		mov	r1, #0
 6767 3b4c 00308DE5 		str	r3, [sp]
 6768 3b50 0020A0E1 		mov	r2, r0
 6769 3b54 0130A0E1 		mov	r3, r1
 6770 3b58 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6771              	.LVL759:
 6772 3b5c 99FFFFEA 		b	.L537
 6773              	.LVL760:
 6774              	.L611:
3815:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6775              		.loc 1 3815 0
 6776 3b60 C8049FE5 		ldr	r0, .L622+96
 6777 3b64 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6778              	.LVL761:
3816:../uvc.c      ****                     {
 6779              		.loc 1 3816 0
 6780 3b68 000050E3 		cmp	r0, #0
 6781 3b6c 4000001A 		bne	.L590
3822:../uvc.c      ****                 }
 6782              		.loc 1 3822 0
 6783 3b70 8300A0E3 		mov	r0, #131
 6784              	.LVL762:
 6785 3b74 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6786              	.LVL763:
 6787 3b78 B1FFFFEA 		b	.L560
 6788              	.L616:
3725:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6789              		.loc 1 3725 0
 6790 3b7c A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6791 3b80 020053E3 		cmp	r3, #2
 6792 3b84 013083E2 		add	r3, r3, #1
 6793 3b88 A030C4E5 		strb	r3, [r4, #160]
 6794 3b8c DFFFFF9A 		bls	.L539
3726:../uvc.c      ****                 		stiflag = 0x0F;
 6795              		.loc 1 3726 0
 6796 3b90 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3727:../uvc.c      ****                 		IMcount = 0;
 6797              		.loc 1 3727 0
 6798 3b94 0F30A0E3 		mov	r3, #15
3726:../uvc.c      ****                 		stiflag = 0x0F;
 6799              		.loc 1 3726 0
 6800 3b98 201081E3 		orr	r1, r1, #32
3728:../uvc.c      ****                 		}
 6801              		.loc 1 3728 0
 6802 3b9c 0020A0E3 		mov	r2, #0
3726:../uvc.c      ****                 		stiflag = 0x0F;
 6803              		.loc 1 3726 0
 6804 3ba0 ED14C5E5 		strb	r1, [r5, #1261]
3728:../uvc.c      ****                 		}
 6805              		.loc 1 3728 0
 6806 3ba4 A020C4E5 		strb	r2, [r4, #160]
3727:../uvc.c      ****                 		IMcount = 0;
 6807              		.loc 1 3727 0
 6808 3ba8 7230C4E5 		strb	r3, [r4, #114]
 6809 3bac D7FFFFEA 		b	.L539
 6810              	.L617:
3741:../uvc.c      ****                 	{
 6811              		.loc 1 3741 0
 6812 3bb0 A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6813 3bb4 020053E3 		cmp	r3, #2
 6814 3bb8 013083E2 		add	r3, r3, #1
 6815 3bbc A030C4E5 		strb	r3, [r4, #160]
 6816 3bc0 D2FFFF9A 		bls	.L539
3743:../uvc.c      ****                      {
 6817              		.loc 1 3743 0
 6818 3bc4 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6819 3bc8 013043E2 		sub	r3, r3, #1
 6820 3bcc 030053E3 		cmp	r3, #3
 6821 3bd0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6822 3bd4 3E0000EA 		b	.L543
 6823              	.L545:
 6824 3bd8 943C0000 		.word	.L544
 6825 3bdc 803D0000 		.word	.L546
 6826 3be0 C43D0000 		.word	.L547
 6827 3be4 2C3D0000 		.word	.L548
 6828              	.L615:
3715:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6829              		.loc 1 3715 0 discriminator 1
 6830 3be8 00608DE5 		str	r6, [sp]
 6831 3bec E4039FE5 		ldr	r0, .L622+8
 6832 3bf0 8010A0E3 		mov	r1, #128
 6833 3bf4 0320A0E3 		mov	r2, #3
 6834 3bf8 60308DE2 		add	r3, sp, #96
 6835 3bfc FEFFFFEB 		bl	_txe_event_flags_get
 6836              	.LVL764:
 6837 3c00 000050E3 		cmp	r0, #0
 6838 3c04 BBFFFF1A 		bne	.L538
3720:../uvc.c      ****                 		IMcount = 0;
 6839              		.loc 1 3720 0
 6840 3c08 0030E0E3 		mvn	r3, #0
3721:../uvc.c      ****                 	}
 6841              		.loc 1 3721 0
 6842 3c0c A000C4E5 		strb	r0, [r4, #160]
3720:../uvc.c      ****                 		IMcount = 0;
 6843              		.loc 1 3720 0
 6844 3c10 7230C4E5 		strb	r3, [r4, #114]
3721:../uvc.c      ****                 	}
 6845              		.loc 1 3721 0
 6846 3c14 BDFFFFEA 		b	.L539
 6847              	.LVL765:
 6848              	.L613:
 6849              	.LBB115:
 6850              	.LBB113:
3548:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6851              		.loc 1 3548 0
 6852 3c18 18149FE5 		ldr	r1, .L622+104
 6853 3c1c 0100A0E3 		mov	r0, #1
 6854              	.LVL766:
 6855 3c20 FEFFFFEB 		bl	CyU3PDebugPrint
 6856              	.LVL767:
3549:../uvc.c      ****     }
 6857              		.loc 1 3549 0
 6858 3c24 10049FE5 		ldr	r0, .L622+108
 6859 3c28 FEFFFFEB 		bl	CyU3PGpifLoad
 6860              	.LVL768:
 6861 3c2c 0050A0E1 		mov	r5, r0
 6862              	.LVL769:
 6863              	.L564:
3556:../uvc.c      ****     {
 6864              		.loc 1 3556 0
 6865 3c30 000055E3 		cmp	r5, #0
 6866 3c34 8800001A 		bne	.L620
 6867              	.LVL770:
3568:../uvc.c      ****     {
 6868              		.loc 1 3568 0
 6869 3c38 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6870 3c3c 023043E2 		sub	r3, r3, #2
 6871 3c40 FF3003E2 		and	r3, r3, #255
 6872 3c44 010053E3 		cmp	r3, #1
 6873 3c48 95FFFF8A 		bhi	.L565
3566:../uvc.c      ****     }
 6874              		.loc 1 3566 0
 6875 3c4c 0500A0E1 		mov	r0, r5
 6876 3c50 0510A0E1 		mov	r1, r5
 6877 3c54 FEFFFFEB 		bl	CyU3PGpifSMStart
 6878              	.LVL771:
3572:../uvc.c      ****     {
 6879              		.loc 1 3572 0
 6880 3c58 005050E2 		subs	r5, r0, #0
 6881 3c5c 90FFFF0A 		beq	.L565
3575:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6882              		.loc 1 3575 0
 6883 3c60 0400A0E3 		mov	r0, #4
 6884              	.LVL772:
 6885 3c64 D4139FE5 		ldr	r1, .L622+112
 6886 3c68 0520A0E1 		mov	r2, r5
 6887 3c6c FEFFFFEB 		bl	CyU3PDebugPrint
 6888              	.LVL773:
3576:../uvc.c      ****     }
 6889              		.loc 1 3576 0
 6890 3c70 0500A0E1 		mov	r0, r5
 6891              	.LVL774:
 6892              	.L590:
3560:../uvc.c      ****     }
 6893              		.loc 1 3560 0
 6894 3c74 FEFFFFEB 		bl	CyFxAppErrorHandler
 6895              	.LVL775:
 6896              	.L614:
3553:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6897              		.loc 1 3553 0
 6898 3c78 C4139FE5 		ldr	r1, .L622+116
 6899 3c7c 0100A0E3 		mov	r0, #1
 6900              	.LVL776:
 6901 3c80 FEFFFFEB 		bl	CyU3PDebugPrint
 6902              	.LVL777:
3554:../uvc.c      ****     }
 6903              		.loc 1 3554 0
 6904 3c84 BC039FE5 		ldr	r0, .L622+120
 6905 3c88 FEFFFFEB 		bl	CyU3PGpifLoad
 6906              	.LVL778:
 6907 3c8c 0050A0E1 		mov	r5, r0
 6908              	.LVL779:
 6909 3c90 E6FFFFEA 		b	.L564
 6910              	.LVL780:
 6911              	.L544:
 6912              	.LBE113:
 6913              	.LBE115:
3746:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6914              		.loc 1 3746 0
 6915 3c94 6C2097E5 		ldr	r2, [r7, #108]
 6916 3c98 3010A0E3 		mov	r1, #48
 6917 3c9c 000052E3 		cmp	r2, #0
 6918 3ca0 A220A003 		moveq	r2, #162
 6919 3ca4 2220A013 		movne	r2, #34
 6920 3ca8 5230A0E3 		mov	r3, #82
 6921 3cac 0100A0E3 		mov	r0, #1
 6922 3cb0 FEFFFFEB 		bl	SensorSetIrisControl
 6923              	.LVL781:
3748:../uvc.c      ****                  		break;
 6924              		.loc 1 3748 0
 6925 3cb4 6C2097E5 		ldr	r2, [r7, #108]
 6926 3cb8 0400A0E3 		mov	r0, #4
 6927 3cbc 000052E3 		cmp	r2, #0
 6928 3cc0 6C3097E5 		ldr	r3, [r7, #108]
 6929 3cc4 A220A003 		moveq	r2, #162
 6930 3cc8 2220A013 		movne	r2, #34
 6931 3ccc 78139FE5 		ldr	r1, .L622+124
 6932 3cd0 FEFFFFEB 		bl	CyU3PDebugPrint
 6933              	.LVL782:
 6934              	.L543:
3768:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6935              		.loc 1 3768 0
 6936 3cd4 0030A0E3 		mov	r3, #0
 6937 3cd8 A030C7E5 		strb	r3, [r7, #160]
3770:../uvc.c      ****                 	}
 6938              		.loc 1 3770 0
 6939 3cdc 7230C7E5 		strb	r3, [r7, #114]
 6940 3ce0 8AFFFFEA 		b	.L539
 6941              	.LVL783:
 6942              	.L619:
3786:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6943              		.loc 1 3786 0
 6944 3ce4 0400A0E3 		mov	r0, #4
 6945              	.LVL784:
 6946 3ce8 60139FE5 		ldr	r1, .L622+128
 6947 3cec 0520A0E1 		mov	r2, r5
 6948 3cf0 FEFFFFEB 		bl	CyU3PDebugPrint
 6949              	.LVL785:
3787:../uvc.c      ****                 }
 6950              		.loc 1 3787 0
 6951 3cf4 0500A0E1 		mov	r0, r5
 6952 3cf8 FEFFFFEB 		bl	CyFxAppErrorHandler
 6953              	.LVL786:
 6954              	.L612:
3838:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6955              		.loc 1 3838 0
 6956 3cfc 0400A0E3 		mov	r0, #4
 6957              	.LVL787:
 6958 3d00 4C139FE5 		ldr	r1, .L622+132
 6959 3d04 0520A0E1 		mov	r2, r5
 6960 3d08 FEFFFFEB 		bl	CyU3PDebugPrint
 6961              	.LVL788:
3839:../uvc.c      ****                 }
 6962              		.loc 1 3839 0
 6963 3d0c 0500A0E1 		mov	r0, r5
 6964 3d10 FEFFFFEB 		bl	CyFxAppErrorHandler
 6965              	.LVL789:
 6966              	.L618:
3778:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6967              		.loc 1 3778 0
 6968 3d14 0400A0E3 		mov	r0, #4
 6969              	.LVL790:
 6970 3d18 38139FE5 		ldr	r1, .L622+136
 6971 3d1c 0520A0E1 		mov	r2, r5
 6972 3d20 FEFFFFEB 		bl	CyU3PDebugPrint
 6973              	.LVL791:
3779:../uvc.c      ****                 }
 6974              		.loc 1 3779 0
 6975 3d24 0500A0E1 		mov	r0, r5
 6976 3d28 FEFFFFEB 		bl	CyFxAppErrorHandler
 6977              	.LVL792:
 6978              	.L548:
3761:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6979              		.loc 1 3761 0
 6980 3d2c 6C2097E5 		ldr	r2, [r7, #108]
 6981 3d30 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6982 3d34 000052E3 		cmp	r2, #0
 6983 3d38 B020A003 		moveq	r2, #176
 6984 3d3c 3020A013 		movne	r2, #48
 6985 3d40 032082E1 		orr	r2, r2, r3
 6986 3d44 3010A0E3 		mov	r1, #48
 6987 3d48 5230A0E3 		mov	r3, #82
 6988 3d4c 0100A0E3 		mov	r0, #1
 6989 3d50 FEFFFFEB 		bl	SensorSetIrisControl
 6990              	.LVL793:
3763:../uvc.c      ****                  		break;
 6991              		.loc 1 3763 0
 6992 3d54 6C1097E5 		ldr	r1, [r7, #108]
 6993 3d58 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6994 3d5c 000051E3 		cmp	r1, #0
 6995 3d60 B010A003 		moveq	r1, #176
 6996 3d64 3010A013 		movne	r1, #48
 6997 3d68 022081E1 		orr	r2, r1, r2
 6998 3d6c 6C3097E5 		ldr	r3, [r7, #108]
 6999 3d70 D4129FE5 		ldr	r1, .L622+124
 7000 3d74 0400A0E3 		mov	r0, #4
 7001 3d78 FEFFFFEB 		bl	CyU3PDebugPrint
 7002              	.LVL794:
3764:../uvc.c      ****                  	default:
 7003              		.loc 1 3764 0
 7004 3d7c D4FFFFEA 		b	.L543
 7005              	.L546:
3751:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7006              		.loc 1 3751 0
 7007 3d80 6C2097E5 		ldr	r2, [r7, #108]
 7008 3d84 3010A0E3 		mov	r1, #48
 7009 3d88 000052E3 		cmp	r2, #0
 7010 3d8c 9220A003 		moveq	r2, #146
 7011 3d90 1220A013 		movne	r2, #18
 7012 3d94 5230A0E3 		mov	r3, #82
 7013 3d98 0100A0E3 		mov	r0, #1
 7014 3d9c FEFFFFEB 		bl	SensorSetIrisControl
 7015              	.LVL795:
3753:../uvc.c      ****                  		break;
 7016              		.loc 1 3753 0
 7017 3da0 6C2097E5 		ldr	r2, [r7, #108]
 7018 3da4 A0129FE5 		ldr	r1, .L622+124
 7019 3da8 000052E3 		cmp	r2, #0
 7020 3dac 6C3097E5 		ldr	r3, [r7, #108]
 7021 3db0 9220A003 		moveq	r2, #146
 7022 3db4 1220A013 		movne	r2, #18
 7023 3db8 0400A0E3 		mov	r0, #4
 7024 3dbc FEFFFFEB 		bl	CyU3PDebugPrint
 7025              	.LVL796:
3754:../uvc.c      ****                  	case 3: //720
 7026              		.loc 1 3754 0
 7027 3dc0 C3FFFFEA 		b	.L543
 7028              	.L547:
3756:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7029              		.loc 1 3756 0
 7030 3dc4 6C2097E5 		ldr	r2, [r7, #108]
 7031 3dc8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7032 3dcc 000052E3 		cmp	r2, #0
 7033 3dd0 8020A003 		moveq	r2, #128
 7034 3dd4 0020A013 		movne	r2, #0
 7035 3dd8 032082E1 		orr	r2, r2, r3
 7036 3ddc 3010A0E3 		mov	r1, #48
 7037 3de0 5230A0E3 		mov	r3, #82
 7038 3de4 0100A0E3 		mov	r0, #1
 7039 3de8 FEFFFFEB 		bl	SensorSetIrisControl
 7040              	.LVL797:
3758:../uvc.c      ****                  		break;
 7041              		.loc 1 3758 0
 7042 3dec 6C1097E5 		ldr	r1, [r7, #108]
 7043 3df0 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7044 3df4 000051E3 		cmp	r1, #0
 7045 3df8 8010A003 		moveq	r1, #128
 7046 3dfc 0010A013 		movne	r1, #0
 7047 3e00 022081E1 		orr	r2, r1, r2
 7048 3e04 6C3097E5 		ldr	r3, [r7, #108]
 7049 3e08 3C129FE5 		ldr	r1, .L622+124
 7050 3e0c 0400A0E3 		mov	r0, #4
 7051 3e10 FEFFFFEB 		bl	CyU3PDebugPrint
 7052              	.LVL798:
3759:../uvc.c      ****                  	case 4: //VGA
 7053              		.loc 1 3759 0
 7054 3e14 AEFFFFEA 		b	.L543
 7055              	.LVL799:
 7056              	.L591:
 7057              	.LBB116:
 7058              	.LBB100:
3055:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7059              		.loc 1 3055 0
 7060 3e18 0400A0E3 		mov	r0, #4
 7061              	.LVL800:
 7062 3e1c 38129FE5 		ldr	r1, .L622+140
 7063 3e20 FEFFFFEB 		bl	CyU3PDebugPrint
 7064              	.LVL801:
3056:../uvc.c      ****     }
 7065              		.loc 1 3056 0
 7066 3e24 0400A0E1 		mov	r0, r4
 7067 3e28 FEFFFFEB 		bl	CyFxAppErrorHandler
 7068              	.LVL802:
 7069              	.L621:
 7070              	.LBE100:
 7071              	.LBE116:
 7072              	.LBB117:
 7073              	.LBB107:
3521:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7074              		.loc 1 3521 0
 7075 3e2c 0800A0E1 		mov	r0, r8
 7076              	.LVL803:
 7077              	.L588:
 7078 3e30 28129FE5 		ldr	r1, .L622+144
 7079 3e34 0420A0E1 		mov	r2, r4
 7080 3e38 FEFFFFEB 		bl	CyU3PDebugPrint
 7081              	.LVL804:
3522:../uvc.c      ****     }
 7082              		.loc 1 3522 0
 7083 3e3c 0400A0E1 		mov	r0, r4
 7084 3e40 8BFFFFEA 		b	.L590
 7085              	.LVL805:
 7086              	.L607:
3496:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7087              		.loc 1 3496 0
 7088 3e44 0800A0E1 		mov	r0, r8
 7089              	.LVL806:
 7090 3e48 14129FE5 		ldr	r1, .L622+148
 7091 3e4c 0420A0E1 		mov	r2, r4
 7092 3e50 FEFFFFEB 		bl	CyU3PDebugPrint
 7093              	.LVL807:
3497:../uvc.c      ****     }
 7094              		.loc 1 3497 0
 7095 3e54 0400A0E1 		mov	r0, r4
 7096 3e58 FEFFFFEB 		bl	CyFxAppErrorHandler
 7097              	.LVL808:
 7098              	.L620:
 7099              	.LBE107:
 7100              	.LBE117:
 7101              	.LBB118:
 7102              	.LBB114:
3559:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7103              		.loc 1 3559 0
 7104 3e5c 0400A0E3 		mov	r0, #4
 7105              	.LVL809:
 7106 3e60 00129FE5 		ldr	r1, .L622+152
 7107 3e64 0520A0E1 		mov	r2, r5
 7108 3e68 FEFFFFEB 		bl	CyU3PDebugPrint
 7109              	.LVL810:
3560:../uvc.c      ****     }
 7110              		.loc 1 3560 0
 7111 3e6c 0500A0E1 		mov	r0, r5
 7112 3e70 7FFFFFEA 		b	.L590
 7113              	.LVL811:
 7114              	.L595:
 7115              	.LBE114:
 7116              	.LBE118:
 7117              	.LBB119:
 7118              	.LBB108:
3212:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7119              		.loc 1 3212 0
 7120 3e74 0400A0E3 		mov	r0, #4
 7121              	.LVL812:
 7122 3e78 EC119FE5 		ldr	r1, .L622+156
 7123 3e7c 0520A0E1 		mov	r2, r5
 7124 3e80 FEFFFFEB 		bl	CyU3PDebugPrint
 7125              	.LVL813:
3213:../uvc.c      ****     }
 7126              		.loc 1 3213 0
 7127 3e84 0500A0E1 		mov	r0, r5
 7128 3e88 FEFFFFEB 		bl	CyFxAppErrorHandler
 7129              	.LVL814:
 7130              	.L594:
3190:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7131              		.loc 1 3190 0
 7132 3e8c 0400A0E3 		mov	r0, #4
 7133              	.LVL815:
 7134 3e90 D8119FE5 		ldr	r1, .L622+160
 7135 3e94 0520A0E1 		mov	r2, r5
 7136 3e98 FEFFFFEB 		bl	CyU3PDebugPrint
 7137              	.LVL816:
3191:../uvc.c      ****     }
 7138              		.loc 1 3191 0
 7139 3e9c 0500A0E1 		mov	r0, r5
 7140 3ea0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7141              	.LVL817:
 7142              	.L593:
 7143              	.LBE108:
 7144              	.LBE119:
 7145              	.LBB120:
 7146              	.LBB103:
3116:../uvc.c      ****         CyFxAppErrorHandler (status);
 7147              		.loc 1 3116 0
 7148 3ea4 0400A0E3 		mov	r0, #4
 7149              	.LVL818:
 7150 3ea8 C4119FE5 		ldr	r1, .L622+164
 7151 3eac FEFFFFEB 		bl	CyU3PDebugPrint
 7152              	.LVL819:
3117:../uvc.c      ****     }
 7153              		.loc 1 3117 0
 7154 3eb0 0500A0E1 		mov	r0, r5
 7155 3eb4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7156              	.LVL820:
 7157              	.L592:
3103:../uvc.c      ****         CyFxAppErrorHandler (status);
 7158              		.loc 1 3103 0
 7159 3eb8 0400A0E3 		mov	r0, #4
 7160              	.LVL821:
 7161 3ebc B4119FE5 		ldr	r1, .L622+168
 7162 3ec0 FEFFFFEB 		bl	CyU3PDebugPrint
 7163              	.LVL822:
3104:../uvc.c      ****     }
 7164              		.loc 1 3104 0
 7165 3ec4 0500A0E1 		mov	r0, r5
 7166 3ec8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7167              	.LVL823:
 7168              	.L603:
 7169              	.LBE103:
 7170              	.LBE120:
 7171              	.LBB121:
 7172              	.LBB109:
3308:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7173              		.loc 1 3308 0
 7174 3ecc 0400A0E3 		mov	r0, #4
 7175              	.LVL824:
 7176 3ed0 A4119FE5 		ldr	r1, .L622+172
 7177 3ed4 0420A0E1 		mov	r2, r4
 7178 3ed8 FEFFFFEB 		bl	CyU3PDebugPrint
 7179              	.LVL825:
3309:../uvc.c      ****     }
 7180              		.loc 1 3309 0
 7181 3edc 0400A0E1 		mov	r0, r4
 7182 3ee0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7183              	.LVL826:
 7184              	.L602:
3287:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7185              		.loc 1 3287 0
 7186 3ee4 0400A0E3 		mov	r0, #4
 7187              	.LVL827:
 7188 3ee8 90119FE5 		ldr	r1, .L622+176
 7189 3eec 0420A0E1 		mov	r2, r4
 7190 3ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 7191              	.LVL828:
3288:../uvc.c      ****     }
 7192              		.loc 1 3288 0
 7193 3ef4 0400A0E1 		mov	r0, r4
 7194 3ef8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7195              	.LVL829:
 7196              	.L601:
3274:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7197              		.loc 1 3274 0
 7198 3efc 0400A0E3 		mov	r0, #4
 7199              	.LVL830:
 7200 3f00 7C119FE5 		ldr	r1, .L622+180
 7201 3f04 0420A0E1 		mov	r2, r4
 7202 3f08 FEFFFFEB 		bl	CyU3PDebugPrint
 7203              	.LVL831:
3275:../uvc.c      ****     }
 7204              		.loc 1 3275 0
 7205 3f0c 0400A0E1 		mov	r0, r4
 7206 3f10 FEFFFFEB 		bl	CyFxAppErrorHandler
 7207              	.LVL832:
 7208              	.L600:
3260:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7209              		.loc 1 3260 0
 7210 3f14 0400A0E3 		mov	r0, #4
 7211              	.LVL833:
 7212 3f18 68119FE5 		ldr	r1, .L622+184
 7213 3f1c 0420A0E1 		mov	r2, r4
 7214 3f20 FEFFFFEB 		bl	CyU3PDebugPrint
 7215              	.LVL834:
3261:../uvc.c      ****     }
 7216              		.loc 1 3261 0
 7217 3f24 0400A0E1 		mov	r0, r4
 7218 3f28 FEFFFFEB 		bl	CyFxAppErrorHandler
 7219              	.LVL835:
 7220              	.L599:
3246:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7221              		.loc 1 3246 0
 7222 3f2c 0400A0E3 		mov	r0, #4
 7223              	.LVL836:
 7224 3f30 54119FE5 		ldr	r1, .L622+188
 7225 3f34 0620A0E1 		mov	r2, r6
 7226 3f38 FEFFFFEB 		bl	CyU3PDebugPrint
 7227              	.LVL837:
3247:../uvc.c      ****     }
 7228              		.loc 1 3247 0
 7229 3f3c 0600A0E1 		mov	r0, r6
 7230 3f40 FEFFFFEB 		bl	CyFxAppErrorHandler
 7231              	.LVL838:
 7232              	.L598:
3233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7233              		.loc 1 3233 0
 7234 3f44 0400A0E3 		mov	r0, #4
 7235              	.LVL839:
 7236 3f48 40119FE5 		ldr	r1, .L622+192
 7237 3f4c 0520A0E1 		mov	r2, r5
 7238 3f50 FEFFFFEB 		bl	CyU3PDebugPrint
 7239              	.LVL840:
3234:../uvc.c      ****     }
 7240              		.loc 1 3234 0
 7241 3f54 0500A0E1 		mov	r0, r5
 7242 3f58 FEFFFFEB 		bl	CyFxAppErrorHandler
 7243              	.LVL841:
 7244              	.L597:
3227:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7245              		.loc 1 3227 0
 7246 3f5c 0400A0E3 		mov	r0, #4
 7247              	.LVL842:
 7248 3f60 2C119FE5 		ldr	r1, .L622+196
 7249 3f64 0520A0E1 		mov	r2, r5
 7250 3f68 FEFFFFEB 		bl	CyU3PDebugPrint
 7251              	.LVL843:
3228:../uvc.c      ****     }
 7252              		.loc 1 3228 0
 7253 3f6c 0500A0E1 		mov	r0, r5
 7254 3f70 FEFFFFEB 		bl	CyFxAppErrorHandler
 7255              	.LVL844:
 7256              	.L596:
3221:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7257              		.loc 1 3221 0
 7258 3f74 0400A0E3 		mov	r0, #4
 7259              	.LVL845:
 7260 3f78 18119FE5 		ldr	r1, .L622+200
 7261 3f7c 0520A0E1 		mov	r2, r5
 7262 3f80 FEFFFFEB 		bl	CyU3PDebugPrint
 7263              	.LVL846:
3222:../uvc.c      ****     }
 7264              		.loc 1 3222 0
 7265 3f84 0500A0E1 		mov	r0, r5
 7266 3f88 FEFFFFEB 		bl	CyFxAppErrorHandler
 7267              	.LVL847:
 7268              	.L606:
3405:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7269              		.loc 1 3405 0
 7270 3f8c 0800A0E1 		mov	r0, r8
 7271              	.LVL848:
 7272 3f90 04119FE5 		ldr	r1, .L622+204
 7273 3f94 0420A0E1 		mov	r2, r4
 7274 3f98 FEFFFFEB 		bl	CyU3PDebugPrint
 7275              	.LVL849:
3406:../uvc.c      ****     }
 7276              		.loc 1 3406 0
 7277 3f9c 0400A0E1 		mov	r0, r4
 7278 3fa0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7279              	.LVL850:
 7280              	.L604:
3374:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7281              		.loc 1 3374 0
 7282 3fa4 0400A0E3 		mov	r0, #4
 7283              	.LVL851:
 7284 3fa8 F0109FE5 		ldr	r1, .L622+208
 7285 3fac 0420A0E1 		mov	r2, r4
 7286 3fb0 FEFFFFEB 		bl	CyU3PDebugPrint
 7287              	.LVL852:
3375:../uvc.c      ****     }
 7288              		.loc 1 3375 0
 7289 3fb4 0400A0E1 		mov	r0, r4
 7290 3fb8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7291              	.LVL853:
 7292              	.L605:
3381:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7293              		.loc 1 3381 0
 7294 3fbc 0400A0E3 		mov	r0, #4
 7295 3fc0 DC109FE5 		ldr	r1, .L622+212
 7296 3fc4 FEFFFFEB 		bl	CyU3PDebugPrint
 7297              	.LVL854:
3382:../uvc.c      ****     }
 7298              		.loc 1 3382 0
 7299 3fc8 0800A0E1 		mov	r0, r8
 7300 3fcc FEFFFFEB 		bl	CyFxAppErrorHandler
 7301              	.LVL855:
 7302              	.L623:
 7303              		.align	2
 7304              	.L622:
 7305 3fd0 00C20100 		.word	115200
 7306 3fd4 A0860100 		.word	100000
 7307 3fd8 00000000 		.word	.LANCHOR0
 7308 3fdc 00000000 		.word	CyFxGpifCB
 7309 3fe0 88130000 		.word	5000
 7310 3fe4 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7311 3fe8 00000000 		.word	CyFxUVCApplnUSBEventCB
 7312 3fec 00000000 		.word	CyFxUSBDeviceDscr
 7313 3ff0 00000000 		.word	CyFxUSBDeviceDscrSS
 7314 3ff4 00000000 		.word	CyFxUSBDeviceQualDscr
 7315 3ff8 00000000 		.word	CyFxUSBBOSDscr
 7316 3ffc 00000000 		.word	CyFxUSBHSConfigDscr
 7317 4000 00000000 		.word	CyFxUSBFSConfigDscr
 7318 4004 00000000 		.word	CyFxUSBSSConfigDscr
 7319 4008 00000000 		.word	CyFxUSBStringLangIDDscr
 7320 400c 00000000 		.word	CyFxUSBManufactureDscr
 7321 4010 00000000 		.word	CyFxUSBProductDscr
 7322 4014 013F0203 		.word	50478849
 7323 4018 00000000 		.word	glChHandleInterStat
 7324 401c 00000000 		.word	glInterStaBuffer
 7325 4020 00000000 		.word	imgHdMux
 7326 4024 01010000 		.word	257
 7327 4028 03030000 		.word	771
 7328 402c 00000000 		.word	CyFxUvcApplnDmaCallback
 7329 4030 00000000 		.word	glChHandleUVCStream
 7330 4034 00000000 		.word	.LANCHOR1
 7331 4038 A00B0000 		.word	.LC65
 7332 403c A0010000 		.word	.LANCHOR2+416
 7333 4040 F80B0000 		.word	.LC68
 7334 4044 B00B0000 		.word	.LC66
 7335 4048 BC010000 		.word	.LANCHOR2+444
 7336 404c E80A0000 		.word	.LC61
 7337 4050 380B0000 		.word	.LC63
 7338 4054 6C0B0000 		.word	.LC64
 7339 4058 0C0B0000 		.word	.LC62
 7340 405c BC070000 		.word	.LC43
 7341 4060 E4090000 		.word	.LC56
 7342 4064 C00A0000 		.word	.LC60
 7343 4068 C00B0000 		.word	.LC67
 7344 406c 40080000 		.word	.LC47
 7345 4070 14080000 		.word	.LC46
 7346 4074 F8070000 		.word	.LC45
 7347 4078 DC070000 		.word	.LC44
 7348 407c B4090000 		.word	.LC55
 7349 4080 84090000 		.word	.LC54
 7350 4084 4C090000 		.word	.LC53
 7351 4088 18090000 		.word	.LC52
 7352 408c E4080000 		.word	.LC51
 7353 4090 B8080000 		.word	.LC50
 7354 4094 8C080000 		.word	.LC49
 7355 4098 64080000 		.word	.LC48
 7356 409c 900A0000 		.word	.LC59
 7357 40a0 180A0000 		.word	.LC57
 7358 40a4 580A0000 		.word	.LC58
 7359              	.LBE109:
 7360              	.LBE121:
 7361              		.cfi_endproc
 7362              	.LFE19:
 7364              		.align	2
 7365              		.global	UVCAppEP0Thread_Entry
 7367              	UVCAppEP0Thread_Entry:
 7368              	.LFB25:
4703:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7369              		.loc 1 4703 0
 7370              		.cfi_startproc
 7371              		@ args = 0, pretend = 0, frame = 64
 7372              		@ frame_needed = 0, uses_anonymous_args = 0
 7373              	.LVL856:
 7374 40a8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7375              	.LCFI27:
 7376              		.cfi_def_cfa_offset 36
 7377              		.cfi_offset 4, -36
 7378              		.cfi_offset 5, -32
 7379              		.cfi_offset 6, -28
 7380              		.cfi_offset 7, -24
 7381              		.cfi_offset 8, -20
 7382              		.cfi_offset 9, -16
 7383              		.cfi_offset 10, -12
 7384              		.cfi_offset 11, -8
 7385              		.cfi_offset 14, -4
 7386 40ac D87F9FE5 		ldr	r7, .L982
 7387 40b0 D8AF9FE5 		ldr	r10, .L982+4
 7388 40b4 D86F9FE5 		ldr	r6, .L982+8
4777:../uvc.c      ****                 {
 7389              		.loc 1 4777 0
 7390 40b8 D89F9FE5 		ldr	r9, .L982+12
 7391              	.LBB154:
 7392              	.LBB155:
4210:../uvc.c      ****     {
 7393              		.loc 1 4210 0
 7394 40bc D88F9FE5 		ldr	r8, .L982+16
 7395              	.LBE155:
 7396              	.LBE154:
4703:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7397              		.loc 1 4703 0
 7398 40c0 5CD04DE2 		sub	sp, sp, #92
 7399              	.LCFI28:
 7400              		.cfi_def_cfa_offset 128
 7401              	.LVL857:
4725:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7402              		.loc 1 4725 0
 7403 40c4 07B0A0E1 		mov	fp, r7
 7404              	.LVL858:
 7405              	.L889:
 7406 40c8 0030E0E3 		mvn	r3, #0
 7407 40cc 00308DE5 		str	r3, [sp]
 7408 40d0 B40F9FE5 		ldr	r0, .L982
 7409 40d4 4C10A0E3 		mov	r1, #76
 7410 40d8 0120A0E3 		mov	r2, #1
 7411 40dc 44308DE2 		add	r3, sp, #68
 7412 40e0 FEFFFFEB 		bl	_txe_event_flags_get
 7413              	.LVL859:
 7414 40e4 000050E3 		cmp	r0, #0
 7415 40e8 3B00001A 		bne	.L626
4729:../uvc.c      ****             {
 7416              		.loc 1 4729 0
 7417 40ec 8C309BE5 		ldr	r3, [fp, #140]
 7418 40f0 000053E3 		cmp	r3, #0
 7419 40f4 9600000A 		beq	.L943
 7420              	.L628:
4738:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7421              		.loc 1 4738 0
 7422 40f8 44309DE5 		ldr	r3, [sp, #68]
 7423 40fc 0C0013E3 		tst	r3, #12
 7424 4100 7E00001A 		bne	.L944
 7425              	.L630:
4745:../uvc.c      ****             {
 7426              		.loc 1 4745 0
 7427 4104 040013E3 		tst	r3, #4
 7428 4108 1F00000A 		beq	.L631
4747:../uvc.c      ****                 {
 7429              		.loc 1 4747 0
 7430 410c B020D9E1 		ldrh	r2, [r9]
 7431 4110 2224A0E1 		mov	r2, r2, lsr #8
 7432 4114 030052E3 		cmp	r2, #3
 7433 4118 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7434 411c 150000EA 		b	.L632
 7435              	.L634:
 7436 4120 78410000 		.word	.L632
 7437 4124 30410000 		.word	.L635
 7438 4128 E4410000 		.word	.L636
 7439 412c AC420000 		.word	.L637
 7440              	.L635:
 7441              	.LBB229:
 7442              	.LBB230:
3985:../uvc.c      ****     {
 7443              		.loc 1 3985 0
 7444 4130 B020D8E1 		ldrh	r2, [r8]
 7445 4134 060C52E3 		cmp	r2, #1536
 7446 4138 A901000A 		beq	.L670
 7447 413c EC00009A 		bls	.L945
 7448 4140 090C52E3 		cmp	r2, #2304
 7449 4144 4B02000A 		beq	.L678
 7450 4148 2201009A 		bls	.L946
 7451 414c 0B0C52E3 		cmp	r2, #2816
 7452 4150 B501000A 		beq	.L681
 7453 4154 030B52E3 		cmp	r2, #3072
 7454 4158 3E02000A 		beq	.L682
 7455 415c 0A0C52E3 		cmp	r2, #2560
 7456 4160 2002000A 		beq	.L947
 7457              	.L669:
4042:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7458              		.loc 1 4042 0
 7459 4164 683F9FE5 		ldr	r3, .L982+72
 7460 4168 0400A0E3 		mov	r0, #4
 7461 416c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7462 4170 281F9FE5 		ldr	r1, .L982+20
 7463 4174 FEFFFFEB 		bl	CyU3PDebugPrint
 7464              	.LVL860:
 7465              	.L632:
 7466              	.LBE230:
 7467              	.LBE229:
4768:../uvc.c      ****                         break;
 7468              		.loc 1 4768 0
 7469 4178 0000A0E3 		mov	r0, #0
 7470 417c 0020A0E1 		mov	r2, r0
 7471 4180 0110A0E3 		mov	r1, #1
 7472 4184 FEFFFFEB 		bl	CyU3PUsbStall
 7473              	.LVL861:
 7474 4188 44309DE5 		ldr	r3, [sp, #68]
 7475              	.L631:
4773:../uvc.c      ****             {
 7476              		.loc 1 4773 0
 7477 418c 080013E3 		tst	r3, #8
 7478 4190 0700000A 		beq	.L883
4777:../uvc.c      ****                 {
 7479              		.loc 1 4777 0
 7480 4194 B030D9E1 		ldrh	r3, [r9]
 7481 4198 010053E3 		cmp	r3, #1
 7482 419c 7200000A 		beq	.L884
4779:../uvc.c      ****                 }
 7483              		.loc 1 4779 0
 7484 41a0 0000A0E3 		mov	r0, #0
 7485 41a4 0020A0E1 		mov	r2, r0
 7486 41a8 0110A0E3 		mov	r1, #1
 7487 41ac FEFFFFEB 		bl	CyU3PUsbStall
 7488              	.LVL862:
 7489 41b0 44309DE5 		ldr	r3, [sp, #68]
 7490              	.L883:
4788:../uvc.c      ****             {
 7491              		.loc 1 4788 0
 7492 41b4 400013E3 		tst	r3, #64
 7493 41b8 0700000A 		beq	.L626
4793:../uvc.c      **** 
 7494              		.loc 1 4793 0
 7495 41bc 1800A0E3 		mov	r0, #24
 7496 41c0 48108DE2 		add	r1, sp, #72
 7497              	.LVL863:
 7498 41c4 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7499              	.LVL864:
4850:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7500              		.loc 1 4850 0
 7501 41c8 9237DAE5 		ldrb	r3, [r10, #1938]	@ zero_extendqisi2
 7502 41cc 0F0053E3 		cmp	r3, #15
 7503 41d0 8800000A 		beq	.L948
4877:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7504              		.loc 1 4877 0
 7505 41d4 000053E3 		cmp	r3, #0
 7506 41d8 6600000A 		beq	.L949
 7507              	.L626:
5001:../uvc.c      ****     }
 7508              		.loc 1 5001 0
 7509 41dc FEFFFFEB 		bl	_txe_thread_relinquish
 7510              	.LVL865:
5002:../uvc.c      **** }
 7511              		.loc 1 5002 0
 7512 41e0 B8FFFFEA 		b	.L889
 7513              	.L636:
 7514              	.LBB366:
 7515              	.LBB367:
3910:../uvc.c      ****     {
 7516              		.loc 1 3910 0
 7517 41e4 B020D8E1 		ldrh	r2, [r8]
 7518 41e8 060C52E3 		cmp	r2, #1536
 7519 41ec 3201000A 		beq	.L639
 7520 41f0 B200008A 		bhi	.L640
 7521 41f4 030C52E3 		cmp	r2, #768
 7522 41f8 2701000A 		beq	.L641
 7523 41fc E500008A 		bhi	.L642
 7524 4200 010C52E3 		cmp	r2, #256
 7525 4204 2001000A 		beq	.L643
 7526 4208 020C52E3 		cmp	r2, #512
 7527 420c D4FFFF1A 		bne	.L669
 7528              	.LVL866:
 7529              	.LBB368:
 7530              	.LBB369:
1359:../uvc.c      ****     /*
 7531              		.loc 1 1359 0
 7532 4210 BC3E9FE5 		ldr	r3, .L982+72
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7533              		.loc 1 1348 0
 7534 4214 4805DAE5 		ldrb	r0, [r10, #1352]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7535              		.loc 1 1359 0
 7536 4218 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7537              		.loc 1 1349 0
 7538 421c 4915DAE5 		ldrb	r1, [r10, #1353]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7539              		.loc 1 1350 0
 7540 4220 5725DAE5 		ldrb	r2, [r10, #1367]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7541              		.loc 1 1351 0
 7542 4224 4A35DAE5 		ldrb	r3, [r10, #1354]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7543              		.loc 1 1349 0
 7544 4228 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7545              		.loc 1 1350 0
 7546 422c FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7547              		.loc 1 1367 0
 7548 4230 830055E3 		cmp	r5, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7549              		.loc 1 1348 0
 7550 4234 FFC000E2 		and	ip, r0, #255
 7551              	.LVL867:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7552              		.loc 1 1349 0
 7553 4238 2C108DE5 		str	r1, [sp, #44]
 7554              	.LVL868:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7555              		.loc 1 1350 0
 7556 423c 28208DE5 		str	r2, [sp, #40]
 7557              	.LVL869:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7558              		.loc 1 1351 0
 7559 4240 FF3003E2 		and	r3, r3, #255
 7560              	.LVL870:
1367:../uvc.c      **** 		 {
 7561              		.loc 1 1367 0
 7562 4244 A405000A 		beq	.L653
 7563 4248 9802009A 		bls	.L950
 7564 424c 850055E3 		cmp	r5, #133
 7565 4250 8B05000A 		beq	.L658
 7566 4254 7905003A 		bcc	.L659
 7567 4258 860055E3 		cmp	r5, #134
 7568 425c 1F04000A 		beq	.L660
 7569 4260 870055E3 		cmp	r5, #135
 7570 4264 9205001A 		bne	.L652
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7571              		.loc 1 1802 0
 7572 4268 020053E3 		cmp	r3, #2
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7573              		.loc 1 1803 0
 7574 426c 53C5DAE5 		ldrb	ip, [r10, #1363]	@ zero_extendqisi2
 7575              	.LVL871:
1814:../uvc.c      **** 		 	 if(Len == 2){
 7576              		.loc 1 1814 0
 7577 4270 0300A0E1 		mov	r0, r3
 7578              	.LVL872:
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7579              		.loc 1 1804 0
 7580 4274 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7581              		.loc 1 1802 0
 7582 4278 7007000A 		beq	.L951
 7583              	.L665:
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7584              		.loc 1 1810 0
 7585 427c 0030A0E3 		mov	r3, #0
 7586              	.LVL873:
1814:../uvc.c      **** 		 	 if(Len == 2){
 7587              		.loc 1 1814 0
 7588 4280 701E9FE5 		ldr	r1, .L982+108
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7589              		.loc 1 1807 0
 7590 4284 28C0C7E5 		strb	ip, [r7, #40]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7591              		.loc 1 1809 0
 7592 4288 2920C7E5 		strb	r2, [r7, #41]
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7593              		.loc 1 1810 0
 7594 428c 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 7595              		.loc 1 1820 0
 7596 4290 0340A0E1 		mov	r4, r3
 7597 4294 24308DE5 		str	r3, [sp, #36]
1814:../uvc.c      **** 		 	 if(Len == 2){
 7598              		.loc 1 1814 0
 7599 4298 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7600              	.LVL874:
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7601              		.loc 1 1819 0
 7602 429c 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 7603              	.LVL875:
1820:../uvc.c      **** 		 	 }
 7604              		.loc 1 1820 0
 7605 42a0 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 7606              	.LVL876:
 7607 42a4 24C09DE5 		ldr	ip, [sp, #36]
 7608 42a8 B50200EA 		b	.L662
 7609              	.LVL877:
 7610              	.L637:
 7611              	.LBE369:
 7612              	.LBE368:
 7613              	.LBE367:
 7614              	.LBE366:
 7615              	.LBB385:
 7616              	.LBB218:
4210:../uvc.c      ****     {
 7617              		.loc 1 4210 0
 7618 42ac B030D8E1 		ldrh	r3, [r8]
 7619 42b0 E44D9FE5 		ldr	r4, .L982+16
 7620 42b4 0D0C53E3 		cmp	r3, #3328
 7621 42b8 B303000A 		beq	.L778
 7622 42bc 6F00008A 		bhi	.L779
 7623 42c0 060C53E3 		cmp	r3, #1536
 7624 42c4 AC03000A 		beq	.L780
 7625 42c8 A700009A 		bls	.L952
 7626 42cc 090C53E3 		cmp	r3, #2304
 7627 42d0 A503000A 		beq	.L788
 7628 42d4 3201009A 		bls	.L953
 7629 42d8 0B0C53E3 		cmp	r3, #2816
 7630 42dc 9E03000A 		beq	.L792
 7631 42e0 030B53E3 		cmp	r3, #3072
 7632 42e4 2202000A 		beq	.L793
 7633 42e8 0A0C53E3 		cmp	r3, #2560
 7634 42ec A1FFFF1A 		bne	.L632
 7635              	.LVL878:
4251:../uvc.c      ****     		}else/* no support for 1080p camera */
 7636              		.loc 1 4251 0
 7637 42f0 1900A0E3 		mov	r0, #25
 7638 42f4 FEFFFFEB 		bl	ControlHandle
 7639              	.LVL879:
 7640 42f8 44309DE5 		ldr	r3, [sp, #68]
 7641 42fc A2FFFFEA 		b	.L631
 7642              	.L944:
 7643              	.LBE218:
 7644              	.LBE385:
4739:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7645              		.loc 1 4739 0
 7646 4300 9C0D9FE5 		ldr	r0, .L982+24
 7647 4304 C81D9FE5 		ldr	r1, .L982+72
 7648 4308 982D9FE5 		ldr	r2, .L982+28
 7649 430c 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7650 4310 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7651 4314 B010D2E1 		ldrh	r1, [r2]
 7652 4318 B0C0D8E1 		ldrh	ip, [r8]
 7653 431c 00008DE5 		str	r0, [sp]
 7654 4320 B000D9E1 		ldrh	r0, [r9]
 7655 4324 10108DE5 		str	r1, [sp, #16]
 7656 4328 0010A0E3 		mov	r1, #0
 7657 432c 0C008DE5 		str	r0, [sp, #12]
 7658 4330 14108DE5 		str	r1, [sp, #20]
 7659 4334 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 7660 4338 04E08DE5 		str	lr, [sp, #4]
 7661 433c 08C08DE5 		str	ip, [sp, #8]
 7662 4340 0400A0E3 		mov	r0, #4
 7663 4344 601D9FE5 		ldr	r1, .L982+32
 7664 4348 FEFFFFEB 		bl	CyU3PDebugPrint
 7665              	.LVL880:
 7666 434c 44309DE5 		ldr	r3, [sp, #68]
 7667 4350 6BFFFFEA 		b	.L630
 7668              	.L943:
4731:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7669              		.loc 1 4731 0
 7670 4354 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7671              	.LVL881:
4732:../uvc.c      ****                 {
 7672              		.loc 1 4732 0
 7673 4358 000050E3 		cmp	r0, #0
4734:../uvc.c      ****                 }
 7674              		.loc 1 4734 0
 7675 435c 0130A013 		movne	r3, #1
4731:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7676              		.loc 1 4731 0
 7677 4360 4800CBE5 		strb	r0, [fp, #72]
4734:../uvc.c      ****                 }
 7678              		.loc 1 4734 0
 7679 4364 8C308B15 		strne	r3, [fp, #140]
 7680 4368 62FFFFEA 		b	.L628
 7681              	.L884:
4783:../uvc.c      ****                 }
 7682              		.loc 1 4783 0
 7683 436c 32EFFFEB 		bl	UVCHandleVideoStreamingRqts
 7684              	.LVL882:
 7685 4370 44309DE5 		ldr	r3, [sp, #68]
 7686 4374 8EFFFFEA 		b	.L883
 7687              	.L949:
4879:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7688              		.loc 1 4879 0
 7689 4378 002096E5 		ldr	r2, [r6]
 7690 437c 0210A0E3 		mov	r1, #2
 7691 4380 0010C2E5 		strb	r1, [r2]
4880:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7692              		.loc 1 4880 0
 7693 4384 002096E5 		ldr	r2, [r6]
 7694 4388 0140A0E3 		mov	r4, #1
 7695 438c 0140C2E5 		strb	r4, [r2, #1]
4881:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7696              		.loc 1 4881 0
 7697 4390 001096E5 		ldr	r1, [r6]
4885:../uvc.c      **** 					interStabuf.status = 0;
 7698              		.loc 1 4885 0
 7699 4394 012BA0E3 		mov	r2, #1024
4881:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7700              		.loc 1 4881 0
 7701 4398 0230C1E5 		strb	r3, [r1, #2]
4882:../uvc.c      **** 
 7702              		.loc 1 4882 0
 7703 439c 001096E5 		ldr	r1, [r6]
4888:../uvc.c      **** 
 7704              		.loc 1 4888 0
 7705 43a0 0450A0E3 		mov	r5, #4
4882:../uvc.c      **** 
 7706              		.loc 1 4882 0
 7707 43a4 0340C1E5 		strb	r4, [r1, #3]
4884:../uvc.c      **** 					interStabuf.size   = 1024;
 7708              		.loc 1 4884 0
 7709 43a8 001096E5 		ldr	r1, [r6]
4891:../uvc.c      **** 
 7710              		.loc 1 4891 0
 7711 43ac FC0C9FE5 		ldr	r0, .L982+36
4884:../uvc.c      **** 					interStabuf.size   = 1024;
 7712              		.loc 1 4884 0
 7713 43b0 4C108DE5 		str	r1, [sp, #76]
4891:../uvc.c      **** 
 7714              		.loc 1 4891 0
 7715 43b4 0010E0E3 		mvn	r1, #0
4886:../uvc.c      **** 
 7716              		.loc 1 4886 0
 7717 43b8 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4885:../uvc.c      **** 					interStabuf.status = 0;
 7718              		.loc 1 4885 0
 7719 43bc B225CDE1 		strh	r2, [sp, #82]	@ movhi
4888:../uvc.c      **** 
 7720              		.loc 1 4888 0
 7721 43c0 B055CDE1 		strh	r5, [sp, #80]	@ movhi
4891:../uvc.c      **** 
 7722              		.loc 1 4891 0
 7723 43c4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7724              	.LVL883:
4894:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7725              		.loc 1 4894 0
 7726 43c8 E00C9FE5 		ldr	r0, .L982+36
 7727 43cc 4C108DE2 		add	r1, sp, #76
 7728 43d0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7729              	.LVL884:
4896:../uvc.c      **** 					{
 7730              		.loc 1 4896 0
 7731 43d4 000050E3 		cmp	r0, #0
 7732 43d8 D201001A 		bne	.L954
4902:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7733              		.loc 1 4902 0
 7734 43dc 0500A0E3 		mov	r0, #5
 7735              	.LVL885:
 7736 43e0 3010A0E3 		mov	r1, #48
 7737 43e4 0420A0E1 		mov	r2, r4
 7738 43e8 FEFFFFEB 		bl	SensorSetControl
 7739              	.LVL886:
4903:../uvc.c      **** 				}
 7740              		.loc 1 4903 0
 7741 43ec 9CEC9FE5 		ldr	lr, .L982+4
 7742 43f0 9247CEE5 		strb	r4, [lr, #1938]
 7743 43f4 78FFFFEA 		b	.L626
 7744              	.L948:
4852:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7745              		.loc 1 4852 0
 7746 43f8 003096E5 		ldr	r3, [r6]
 7747 43fc 0220A0E3 		mov	r2, #2
 7748 4400 0020C3E5 		strb	r2, [r3]
4853:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7749              		.loc 1 4853 0
 7750 4404 003096E5 		ldr	r3, [r6]
 7751 4408 0140A0E3 		mov	r4, #1
 7752 440c 0140C3E5 		strb	r4, [r3, #1]
4854:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7753              		.loc 1 4854 0
 7754 4410 002096E5 		ldr	r2, [r6]
 7755 4414 0030A0E3 		mov	r3, #0
 7756 4418 0230C2E5 		strb	r3, [r2, #2]
4855:../uvc.c      **** 
 7757              		.loc 1 4855 0
 7758 441c 001096E5 		ldr	r1, [r6]
4861:../uvc.c      **** 
 7759              		.loc 1 4861 0
 7760 4420 04C0A0E3 		mov	ip, #4
4855:../uvc.c      **** 
 7761              		.loc 1 4855 0
 7762 4424 0330C1E5 		strb	r3, [r1, #3]
4857:../uvc.c      **** 					interStabuf.size   = 1024;
 7763              		.loc 1 4857 0
 7764 4428 001096E5 		ldr	r1, [r6]
4858:../uvc.c      **** 					interStabuf.status = 0;
 7765              		.loc 1 4858 0
 7766 442c 012BA0E3 		mov	r2, #1024
4857:../uvc.c      **** 					interStabuf.size   = 1024;
 7767              		.loc 1 4857 0
 7768 4430 4C108DE5 		str	r1, [sp, #76]
4864:../uvc.c      **** 
 7769              		.loc 1 4864 0
 7770 4434 740C9FE5 		ldr	r0, .L982+36
 7771 4438 0010E0E3 		mvn	r1, #0
4858:../uvc.c      **** 					interStabuf.status = 0;
 7772              		.loc 1 4858 0
 7773 443c B225CDE1 		strh	r2, [sp, #82]	@ movhi
4861:../uvc.c      **** 
 7774              		.loc 1 4861 0
 7775 4440 B0C5CDE1 		strh	ip, [sp, #80]	@ movhi
4864:../uvc.c      **** 
 7776              		.loc 1 4864 0
 7777 4444 1CC08DE5 		str	ip, [sp, #28]
4859:../uvc.c      **** 
 7778              		.loc 1 4859 0
 7779 4448 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4864:../uvc.c      **** 
 7780              		.loc 1 4864 0
 7781 444c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7782              	.LVL887:
4867:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7783              		.loc 1 4867 0
 7784 4450 580C9FE5 		ldr	r0, .L982+36
 7785 4454 4C108DE2 		add	r1, sp, #76
 7786 4458 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7787              	.LVL888:
4869:../uvc.c      **** 					{
 7788              		.loc 1 4869 0
 7789 445c 1CC09DE5 		ldr	ip, [sp, #28]
 7790 4460 002050E2 		subs	r2, r0, #0
 7791 4464 9703001A 		bne	.L955
4874:../uvc.c      **** 
 7792              		.loc 1 4874 0
 7793 4468 0500A0E3 		mov	r0, #5
 7794              	.LVL889:
 7795 446c 3010A0E3 		mov	r1, #48
 7796 4470 FEFFFFEB 		bl	SensorSetControl
 7797              	.LVL890:
4876:../uvc.c      **** 				}else if(!snapButFlag){
 7798              		.loc 1 4876 0
 7799 4474 14CC9FE5 		ldr	ip, .L982+4
 7800 4478 9247CCE5 		strb	r4, [ip, #1938]
 7801 447c 56FFFFEA 		b	.L626
 7802              	.L779:
 7803              	.LBB386:
 7804              	.LBB219:
4210:../uvc.c      ****     {
 7805              		.loc 1 4210 0
 7806 4480 150C53E3 		cmp	r3, #5376
 7807 4484 4403000A 		beq	.L795
 7808 4488 2400008A 		bhi	.L796
 7809 448c 110C53E3 		cmp	r3, #4352
 7810 4490 4F03000A 		beq	.L797
 7811 4494 CA00009A 		bls	.L956
 7812 4498 130C53E3 		cmp	r3, #4864
 7813 449c 4803000A 		beq	.L801
 7814 44a0 050B53E3 		cmp	r3, #5120
 7815 44a4 A801000A 		beq	.L802
 7816 44a8 120C53E3 		cmp	r3, #4608
 7817 44ac 31FFFF1A 		bne	.L632
 7818              	.LVL891:
4287:../uvc.c      ****     		break;
 7819              		.loc 1 4287 0
 7820 44b0 2500A0E3 		mov	r0, #37
 7821 44b4 FEFFFFEB 		bl	ControlHandle
 7822              	.LVL892:
 7823 44b8 44309DE5 		ldr	r3, [sp, #68]
 7824 44bc 32FFFFEA 		b	.L631
 7825              	.L640:
 7826              	.LBE219:
 7827              	.LBE386:
 7828              	.LBB387:
 7829              	.LBB378:
3910:../uvc.c      ****     {
 7830              		.loc 1 3910 0
 7831 44c0 0A0C52E3 		cmp	r2, #2560
 7832 44c4 6800000A 		beq	.L646
 7833 44c8 3A00009A 		bls	.L957
 7834 44cc 0D0C52E3 		cmp	r2, #3328
 7835 44d0 6500000A 		beq	.L646
 7836 44d4 0E0C52E3 		cmp	r2, #3584
 7837 44d8 6700000A 		beq	.L650
 7838 44dc 030B52E3 		cmp	r2, #3072
 7839 44e0 1FFFFF1A 		bne	.L669
 7840              	.LVL893:
3951:../uvc.c      ****     		break;
 7841              		.loc 1 3951 0
 7842 44e4 0B00A0E3 		mov	r0, #11
 7843 44e8 FEFFFFEB 		bl	ControlHandle
 7844              	.LVL894:
 7845 44ec 44309DE5 		ldr	r3, [sp, #68]
 7846 44f0 25FFFFEA 		b	.L631
 7847              	.L945:
 7848              	.LBE378:
 7849              	.LBE387:
 7850              	.LBB388:
 7851              	.LBB359:
3985:../uvc.c      ****     {
 7852              		.loc 1 3985 0
 7853 44f4 030C52E3 		cmp	r2, #768
 7854 44f8 0301000A 		beq	.L672
 7855 44fc 3A00008A 		bhi	.L673
 7856 4500 010C52E3 		cmp	r2, #256
 7857 4504 E400000A 		beq	.L674
 7858 4508 020C52E3 		cmp	r2, #512
 7859 450c 14FFFF1A 		bne	.L669
 7860              	.LVL895:
3993:../uvc.c      ****     		break;
 7861              		.loc 1 3993 0
 7862 4510 0100A0E3 		mov	r0, #1
 7863 4514 FEFFFFEB 		bl	CTControlHandle
 7864              	.LVL896:
 7865 4518 44309DE5 		ldr	r3, [sp, #68]
 7866 451c 1AFFFFEA 		b	.L631
 7867              	.L796:
 7868              	.LBE359:
 7869              	.LBE388:
 7870              	.LBB389:
 7871              	.LBB220:
4210:../uvc.c      ****     {
 7872              		.loc 1 4210 0
 7873 4520 060B53E3 		cmp	r3, #6144
 7874 4524 3C03000A 		beq	.L804
 7875 4528 6F00009A 		bls	.L958
 7876 452c 1B0C53E3 		cmp	r3, #6912
 7877 4530 2F03000A 		beq	.L808
 7878 4534 070B53E3 		cmp	r3, #7168
 7879 4538 D201000A 		beq	.L809
 7880 453c 1A0C53E3 		cmp	r3, #6656
 7881 4540 0CFFFF1A 		bne	.L632
4320:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7882              		.loc 1 4320 0
 7883 4544 2D00A0E3 		mov	r0, #45
 7884 4548 FEFFFFEB 		bl	ControlHandle
 7885              	.LVL897:
4321:../uvc.c      ****     		break;
 7886              		.loc 1 4321 0
 7887 454c 803B9FE5 		ldr	r3, .L982+72
 7888 4550 B020D4E1 		ldrh	r2, [r4]
 7889 4554 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7890 4558 0400A0E3 		mov	r0, #4
 7891 455c 501B9FE5 		ldr	r1, .L982+40
 7892 4560 FEFFFFEB 		bl	CyU3PDebugPrint
 7893              	.LVL898:
 7894 4564 44309DE5 		ldr	r3, [sp, #68]
 7895 4568 07FFFFEA 		b	.L631
 7896              	.L952:
4210:../uvc.c      ****     {
 7897              		.loc 1 4210 0
 7898 456c 030C53E3 		cmp	r3, #768
 7899 4570 1B03000A 		beq	.L782
 7900 4574 5400008A 		bhi	.L783
 7901 4578 010C53E3 		cmp	r3, #256
 7902 457c BD01000A 		beq	.L784
 7903 4580 020C53E3 		cmp	r3, #512
 7904 4584 FBFEFF1A 		bne	.L632
 7905              	.LVL899:
4218:../uvc.c      ****     		break;
 7906              		.loc 1 4218 0
 7907 4588 1100A0E3 		mov	r0, #17
 7908 458c FEFFFFEB 		bl	ControlHandle
 7909              	.LVL900:
 7910 4590 44309DE5 		ldr	r3, [sp, #68]
 7911 4594 FCFEFFEA 		b	.L631
 7912              	.L642:
 7913              	.LBE220:
 7914              	.LBE389:
 7915              	.LBB390:
 7916              	.LBB379:
3910:../uvc.c      ****     {
 7917              		.loc 1 3910 0
 7918 4598 010B52E3 		cmp	r2, #1024
 7919 459c FAFEFF0A 		beq	.L631
 7920 45a0 050C52E3 		cmp	r2, #1280
 7921 45a4 EEFEFF1A 		bne	.L669
 7922              	.LVL901:
3929:../uvc.c      ****       		break;
 7923              		.loc 1 3929 0
 7924 45a8 0400A0E3 		mov	r0, #4
 7925 45ac FEFFFFEB 		bl	ControlHandle
 7926              	.LVL902:
 7927 45b0 44309DE5 		ldr	r3, [sp, #68]
 7928 45b4 F4FEFFEA 		b	.L631
 7929              	.L957:
3910:../uvc.c      ****     {
 7930              		.loc 1 3910 0
 7931 45b8 070C52E3 		cmp	r2, #1792
 7932 45bc 3A00000A 		beq	.L648
 7933 45c0 020B52E3 		cmp	r2, #2048
 7934 45c4 E6FEFF1A 		bne	.L669
 7935              	.LVL903:
3941:../uvc.c      ****           		break;
 7936              		.loc 1 3941 0
 7937 45c8 0700A0E3 		mov	r0, #7
 7938 45cc FEFFFFEB 		bl	ControlHandle
 7939              	.LVL904:
 7940 45d0 44309DE5 		ldr	r3, [sp, #68]
 7941 45d4 ECFEFFEA 		b	.L631
 7942              	.L946:
 7943              	.LBE379:
 7944              	.LBE390:
 7945              	.LBB391:
 7946              	.LBB360:
3985:../uvc.c      ****     {
 7947              		.loc 1 3985 0
 7948 45d8 070C52E3 		cmp	r2, #1792
 7949 45dc E500000A 		beq	.L680
 7950 45e0 020B52E3 		cmp	r2, #2048
 7951 45e4 E8FEFF0A 		beq	.L631
 7952 45e8 DDFEFFEA 		b	.L669
 7953              	.L673:
 7954 45ec 010B52E3 		cmp	r2, #1024
 7955 45f0 1C01000A 		beq	.L676
 7956 45f4 050C52E3 		cmp	r2, #1280
 7957 45f8 D9FEFF1A 		bne	.L669
 7958              	.LVL905:
 7959              	.LBB231:
 7960              	.LBB232:
2292:../uvc.c      **** 
 7961              		.loc 1 2292 0
 7962 45fc D04A9FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 7963              		.loc 1 2287 0
 7964 4600 3A56DAE5 		ldrb	r5, [r10, #1594]	@ zero_extendqisi2
 7965              	.LVL906:
2292:../uvc.c      **** 
 7966              		.loc 1 2292 0
 7967 4604 24408DE5 		str	r4, [sp, #36]
 7968 4608 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 7969              	.LVL907:
2294:../uvc.c      **** 		 {
 7970              		.loc 1 2294 0
 7971 460c 830054E3 		cmp	r4, #131
 7972 4610 0105000A 		beq	.L707
 7973 4614 E301009A 		bls	.L959
 7974 4618 850054E3 		cmp	r4, #133
 7975 461c B902000A 		beq	.L769
 7976 4620 1D05003A 		bcc	.L713
 7977 4624 860054E3 		cmp	r4, #134
 7978 4628 5A03000A 		beq	.L714
 7979 462c 870054E3 		cmp	r4, #135
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 7980              		.loc 1 2356 0
 7981 4630 4316DA05 		ldreqb	r1, [r10, #1603]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7982              		.loc 1 2357 0
 7983 4634 4426DA05 		ldreqb	r2, [r10, #1604]	@ zero_extendqisi2
2294:../uvc.c      **** 		 {
 7984              		.loc 1 2294 0
 7985 4638 C400000A 		beq	.L932
 7986              	.L706:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7987              		.loc 1 2501 0
 7988 463c 0000A0E3 		mov	r0, #0
 7989 4640 0020A0E1 		mov	r2, r0
 7990 4644 0110A0E3 		mov	r1, #1
 7991 4648 FEFFFFEB 		bl	CyU3PUsbStall
 7992              	.LVL908:
2502:../uvc.c      **** 			  break;
 7993              		.loc 1 2502 0
 7994 464c 24C09DE5 		ldr	ip, [sp, #36]
 7995 4650 0400A0E3 		mov	r0, #4
 7996 4654 0020A0E1 		mov	r2, r0
 7997 4658 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7998 465c 881A9FE5 		ldr	r1, .L982+96
 7999 4660 FEFFFFEB 		bl	CyU3PDebugPrint
 8000              	.LVL909:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8001              		.loc 1 2288 0
 8002 4664 FF20A0E3 		mov	r2, #255
 8003              	.LVL910:
 8004 4668 AD0200EA 		b	.L773
 8005              	.LVL911:
 8006              	.L646:
 8007              	.LBE232:
 8008              	.LBE231:
 8009              	.LBE360:
 8010              	.LBE391:
 8011              	.LBB392:
 8012              	.LBB380:
3947:../uvc.c      ****     		break;
 8013              		.loc 1 3947 0
 8014 466c 0900A0E3 		mov	r0, #9
 8015 4670 FEFFFFEB 		bl	ControlHandle
 8016              	.LVL912:
 8017 4674 44309DE5 		ldr	r3, [sp, #68]
 8018 4678 C3FEFFEA 		b	.L631
 8019              	.L650:
 8020              	.LVL913:
3955:../uvc.c      ****     		break;
 8021              		.loc 1 3955 0
 8022 467c 0E00A0E3 		mov	r0, #14
 8023 4680 FEFFFFEB 		bl	ControlHandle
 8024              	.LVL914:
 8025 4684 44309DE5 		ldr	r3, [sp, #68]
 8026 4688 BFFEFFEA 		b	.L631
 8027              	.L643:
 8028              	.LVL915:
3914:../uvc.c      ****     		break;
 8029              		.loc 1 3914 0
 8030 468c 0000A0E3 		mov	r0, #0
 8031 4690 FEFFFFEB 		bl	ControlHandle
 8032              	.LVL916:
 8033 4694 44309DE5 		ldr	r3, [sp, #68]
 8034 4698 BBFEFFEA 		b	.L631
 8035              	.L641:
 8036              	.LVL917:
3922:../uvc.c      **** 			break;
 8037              		.loc 1 3922 0
 8038 469c 0200A0E3 		mov	r0, #2
 8039 46a0 FEFFFFEB 		bl	ControlHandle
 8040              	.LVL918:
 8041 46a4 44309DE5 		ldr	r3, [sp, #68]
 8042 46a8 B7FEFFEA 		b	.L631
 8043              	.L648:
 8044              	.LVL919:
3937:../uvc.c      ****           		break;
 8045              		.loc 1 3937 0
 8046 46ac 0600A0E3 		mov	r0, #6
 8047 46b0 FEFFFFEB 		bl	ControlHandle
 8048              	.LVL920:
 8049 46b4 44309DE5 		ldr	r3, [sp, #68]
 8050 46b8 B3FEFFEA 		b	.L631
 8051              	.L639:
 8052              	.LVL921:
3933:../uvc.c      ****      		break;
 8053              		.loc 1 3933 0
 8054 46bc 0500A0E3 		mov	r0, #5
 8055 46c0 FEFFFFEB 		bl	ControlHandle
 8056              	.LVL922:
 8057 46c4 44309DE5 		ldr	r3, [sp, #68]
 8058 46c8 AFFEFFEA 		b	.L631
 8059              	.L783:
 8060              	.LBE380:
 8061              	.LBE392:
 8062              	.LBB393:
 8063              	.LBB221:
4210:../uvc.c      ****     {
 8064              		.loc 1 4210 0
 8065 46cc 010B53E3 		cmp	r3, #1024
 8066 46d0 3501000A 		beq	.L786
 8067 46d4 050C53E3 		cmp	r3, #1280
 8068 46d8 A6FEFF1A 		bne	.L632
 8069              	.LVL923:
4230:../uvc.c      ****     		break;
 8070              		.loc 1 4230 0
 8071 46dc 1400A0E3 		mov	r0, #20
 8072 46e0 FEFFFFEB 		bl	ControlHandle
 8073              	.LVL924:
 8074 46e4 44309DE5 		ldr	r3, [sp, #68]
 8075 46e8 A7FEFFEA 		b	.L631
 8076              	.L958:
4210:../uvc.c      ****     {
 8077              		.loc 1 4210 0
 8078 46ec 160C53E3 		cmp	r3, #5632
 8079 46f0 2301000A 		beq	.L806
 8080 46f4 170C53E3 		cmp	r3, #5888
 8081 46f8 9EFEFF1A 		bne	.L632
 8082              	.LVL925:
 8083              	.LBB156:
 8084              	.LBB157:
1359:../uvc.c      ****     /*
 8085              		.loc 1 1359 0
 8086 46fc D0499FE5 		ldr	r4, .L982+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8087              		.loc 1 1341 0
 8088 4700 6C17DAE5 		ldrb	r1, [r10, #1900]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8089              		.loc 1 1359 0
 8090 4704 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 8091 4708 24408DE5 		str	r4, [sp, #36]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8092              		.loc 1 1342 0
 8093 470c 6D47DAE5 		ldrb	r4, [r10, #1901]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8094              		.loc 1 1343 0
 8095 4710 7B27DAE5 		ldrb	r2, [r10, #1915]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8096              		.loc 1 1344 0
 8097 4714 6E37DAE5 		ldrb	r3, [r10, #1902]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8098              		.loc 1 1341 0
 8099 4718 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8100              		.loc 1 1343 0
 8101 471c FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8102              		.loc 1 1367 0
 8103 4720 83005CE3 		cmp	ip, #131
1359:../uvc.c      ****     /*
 8104              		.loc 1 1359 0
 8105 4724 2CC08DE5 		str	ip, [sp, #44]
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8106              		.loc 1 1341 0
 8107 4728 34108DE5 		str	r1, [sp, #52]
 8108              	.LVL926:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8109              		.loc 1 1342 0
 8110 472c FF4004E2 		and	r4, r4, #255
 8111              	.LVL927:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8112              		.loc 1 1343 0
 8113 4730 30208DE5 		str	r2, [sp, #48]
 8114              	.LVL928:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8115              		.loc 1 1344 0
 8116 4734 FF3003E2 		and	r3, r3, #255
 8117              	.LVL929:
1367:../uvc.c      **** 		 {
 8118              		.loc 1 1367 0
 8119 4738 2D05000A 		beq	.L836
 8120 473c EE03009A 		bls	.L960
 8121 4740 2C409DE5 		ldr	r4, [sp, #44]
 8122              	.LVL930:
 8123 4744 850054E3 		cmp	r4, #133
 8124 4748 6E03000A 		beq	.L841
 8125 474c 4205003A 		bcc	.L842
 8126 4750 860054E3 		cmp	r4, #134
 8127 4754 3205000A 		beq	.L843
 8128 4758 870054E3 		cmp	r4, #135
 8129 475c AC05001A 		bne	.L835
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8130              		.loc 1 1789 0
 8131 4760 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8132              		.loc 1 1790 0
 8133 4764 77C7DAE5 		ldrb	ip, [r10, #1911]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 8134              		.loc 1 1814 0
 8135 4768 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8136              		.loc 1 1791 0
 8137 476c 7827DAE5 		ldrb	r2, [r10, #1912]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8138              		.loc 1 1789 0
 8139 4770 F705000A 		beq	.L942
 8140              	.L850:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8141              		.loc 1 1796 0
 8142 4774 0030A0E3 		mov	r3, #0
 8143              	.LVL931:
1814:../uvc.c      **** 		 	 if(Len == 2){
 8144              		.loc 1 1814 0
 8145 4778 78199FE5 		ldr	r1, .L982+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8146              		.loc 1 1795 0
 8147 477c 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8148              		.loc 1 1797 0
 8149 4780 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8150              		.loc 1 1796 0
 8151 4784 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8152              		.loc 1 1798 0
 8153 4788 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 8154              		.loc 1 1820 0
 8155 478c 28308DE5 		str	r3, [sp, #40]
1814:../uvc.c      **** 		 	 if(Len == 2){
 8156              		.loc 1 1814 0
 8157 4790 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8158              	.LVL932:
1820:../uvc.c      **** 		 	 }
 8159              		.loc 1 1820 0
 8160 4794 00C0A0E3 		mov	ip, #0
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8161              		.loc 1 1819 0
 8162 4798 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 8163              	.LVL933:
1820:../uvc.c      **** 		 	 }
 8164              		.loc 1 1820 0
 8165 479c 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 8166              	.LVL934:
 8167 47a0 620300EA 		b	.L845
 8168              	.LVL935:
 8169              	.L953:
 8170              	.LBE157:
 8171              	.LBE156:
4210:../uvc.c      ****     {
 8172              		.loc 1 4210 0
 8173 47a4 070C53E3 		cmp	r3, #1792
 8174 47a8 0701000A 		beq	.L790
 8175 47ac 020B53E3 		cmp	r3, #2048
 8176 47b0 70FEFF1A 		bne	.L632
 8177              	.LVL936:
4242:../uvc.c      ****     		break;
 8178              		.loc 1 4242 0
 8179 47b4 1700A0E3 		mov	r0, #23
 8180 47b8 FEFFFFEB 		bl	ControlHandle
 8181              	.LVL937:
 8182 47bc 44309DE5 		ldr	r3, [sp, #68]
 8183 47c0 71FEFFEA 		b	.L631
 8184              	.L956:
4210:../uvc.c      ****     {
 8185              		.loc 1 4210 0
 8186 47c4 0F0C53E3 		cmp	r3, #3840
 8187 47c8 FB00000A 		beq	.L799
 8188 47cc 010A53E3 		cmp	r3, #4096
 8189 47d0 68FEFF1A 		bne	.L632
 8190              	.LVL938:
4279:../uvc.c      ****     		break;
 8191              		.loc 1 4279 0
 8192 47d4 1F00A0E3 		mov	r0, #31
 8193 47d8 FEFFFFEB 		bl	ControlHandle
 8194              	.LVL939:
 8195 47dc 44309DE5 		ldr	r3, [sp, #68]
 8196 47e0 69FEFFEA 		b	.L631
 8197              	.L670:
 8198              	.LVL940:
 8199              	.LBE221:
 8200              	.LBE393:
 8201              	.LBB394:
 8202              	.LBB361:
 8203              	.LBB239:
 8204              	.LBB240:
2292:../uvc.c      **** 
 8205              		.loc 1 2292 0
 8206 47e4 E8489FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8207              		.loc 1 2287 0
 8208 47e8 5256DAE5 		ldrb	r5, [r10, #1618]	@ zero_extendqisi2
 8209              	.LVL941:
2292:../uvc.c      **** 
 8210              		.loc 1 2292 0
 8211 47ec 24408DE5 		str	r4, [sp, #36]
 8212 47f0 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8213              	.LVL942:
2294:../uvc.c      **** 		 {
 8214              		.loc 1 2294 0
 8215 47f4 830054E3 		cmp	r4, #131
 8216 47f8 9F04000A 		beq	.L718
 8217 47fc C901009A 		bls	.L961
 8218 4800 850054E3 		cmp	r4, #133
 8219 4804 3F02000A 		beq	.L769
 8220 4808 D704003A 		bcc	.L724
 8221 480c 860054E3 		cmp	r4, #134
 8222 4810 FC02000A 		beq	.L725
 8223 4814 870054E3 		cmp	r4, #135
 8224 4818 BC04001A 		bne	.L717
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8225              		.loc 1 2356 0
 8226 481c 6CE89FE5 		ldr	lr, .L982+4
 8227 4820 5B16DEE5 		ldrb	r1, [lr, #1627]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8228              		.loc 1 2357 0
 8229 4824 5C26DEE5 		ldrb	r2, [lr, #1628]	@ zero_extendqisi2
 8230 4828 480000EA 		b	.L932
 8231              	.LVL943:
 8232              	.L681:
 8233              	.LBE240:
 8234              	.LBE239:
 8235              	.LBB248:
 8236              	.LBB249:
2292:../uvc.c      **** 
 8237              		.loc 1 2292 0
 8238 482c A0489FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8239              		.loc 1 2287 0
 8240 4830 B256DAE5 		ldrb	r5, [r10, #1714]	@ zero_extendqisi2
 8241              	.LVL944:
2292:../uvc.c      **** 
 8242              		.loc 1 2292 0
 8243 4834 24408DE5 		str	r4, [sp, #36]
 8244 4838 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8245              	.LVL945:
2294:../uvc.c      **** 		 {
 8246              		.loc 1 2294 0
 8247 483c 830054E3 		cmp	r4, #131
 8248 4840 7904000A 		beq	.L764
 8249 4844 6A01009A 		bls	.L962
 8250 4848 850054E3 		cmp	r4, #133
 8251 484c 2D02000A 		beq	.L769
 8252 4850 8D04003A 		bcc	.L770
 8253 4854 860054E3 		cmp	r4, #134
 8254 4858 CC02000A 		beq	.L771
 8255 485c 870054E3 		cmp	r4, #135
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8256              		.loc 1 2356 0
 8257 4860 BB16DA05 		ldreqb	r1, [r10, #1723]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8258              		.loc 1 2357 0
 8259 4864 BC26DA05 		ldreqb	r2, [r10, #1724]	@ zero_extendqisi2
2294:../uvc.c      **** 		 {
 8260              		.loc 1 2294 0
 8261 4868 3800000A 		beq	.L932
 8262              	.L763:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8263              		.loc 1 2501 0
 8264 486c 0000A0E3 		mov	r0, #0
 8265 4870 0020A0E1 		mov	r2, r0
 8266 4874 0110A0E3 		mov	r1, #1
 8267 4878 FEFFFFEB 		bl	CyU3PUsbStall
 8268              	.LVL946:
2502:../uvc.c      **** 			  break;
 8269              		.loc 1 2502 0
 8270 487c 24C09DE5 		ldr	ip, [sp, #36]
 8271 4880 0920A0E3 		mov	r2, #9
 8272 4884 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8273 4888 0400A0E3 		mov	r0, #4
 8274 488c 58189FE5 		ldr	r1, .L982+96
 8275 4890 FEFFFFEB 		bl	CyU3PDebugPrint
 8276              	.LVL947:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8277              		.loc 1 2288 0
 8278 4894 FF20A0E3 		mov	r2, #255
 8279 4898 210200EA 		b	.L773
 8280              	.LVL948:
 8281              	.L674:
 8282              	.LBE249:
 8283              	.LBE248:
 8284              	.LBB260:
 8285              	.LBB261:
2292:../uvc.c      **** 
 8286              		.loc 1 2292 0
 8287 489c 30489FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8288              		.loc 1 2287 0
 8289 48a0 DA55DAE5 		ldrb	r5, [r10, #1498]	@ zero_extendqisi2
 8290              	.LVL949:
2292:../uvc.c      **** 
 8291              		.loc 1 2292 0
 8292 48a4 24408DE5 		str	r4, [sp, #36]
 8293 48a8 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8294              	.LVL950:
2294:../uvc.c      **** 		 {
 8295              		.loc 1 2294 0
 8296 48ac 830054E3 		cmp	r4, #131
 8297 48b0 6504000A 		beq	.L685
 8298 48b4 8801009A 		bls	.L963
 8299 48b8 850054E3 		cmp	r4, #133
 8300 48bc 1102000A 		beq	.L769
 8301 48c0 5104003A 		bcc	.L691
 8302 48c4 860054E3 		cmp	r4, #134
 8303 48c8 DE02000A 		beq	.L692
 8304 48cc 870054E3 		cmp	r4, #135
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8305              		.loc 1 2356 0
 8306 48d0 E315DA05 		ldreqb	r1, [r10, #1507]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8307              		.loc 1 2357 0
 8308 48d4 E425DA05 		ldreqb	r2, [r10, #1508]	@ zero_extendqisi2
2294:../uvc.c      **** 		 {
 8309              		.loc 1 2294 0
 8310 48d8 1C00000A 		beq	.L932
 8311              	.L684:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8312              		.loc 1 2501 0
 8313 48dc 0000A0E3 		mov	r0, #0
 8314 48e0 0020A0E1 		mov	r2, r0
 8315 48e4 0110A0E3 		mov	r1, #1
 8316 48e8 FEFFFFEB 		bl	CyU3PUsbStall
 8317              	.LVL951:
2502:../uvc.c      **** 			  break;
 8318              		.loc 1 2502 0
 8319 48ec 24C09DE5 		ldr	ip, [sp, #36]
 8320 48f0 0020A0E3 		mov	r2, #0
 8321 48f4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8322 48f8 0400A0E3 		mov	r0, #4
 8323 48fc E8179FE5 		ldr	r1, .L982+96
 8324 4900 FEFFFFEB 		bl	CyU3PDebugPrint
 8325              	.LVL952:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8326              		.loc 1 2288 0
 8327 4904 FF20A0E3 		mov	r2, #255
 8328              	.LVL953:
 8329 4908 050200EA 		b	.L773
 8330              	.LVL954:
 8331              	.L672:
 8332              	.LBE261:
 8333              	.LBE260:
 8334              	.LBB268:
 8335              	.LBB269:
2292:../uvc.c      **** 
 8336              		.loc 1 2292 0
 8337 490c C0479FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8338              		.loc 1 2287 0
 8339 4910 0A56DAE5 		ldrb	r5, [r10, #1546]	@ zero_extendqisi2
 8340              	.LVL955:
2292:../uvc.c      **** 
 8341              		.loc 1 2292 0
 8342 4914 24408DE5 		str	r4, [sp, #36]
 8343 4918 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8344              	.LVL956:
2294:../uvc.c      **** 		 {
 8345              		.loc 1 2294 0
 8346 491c 830054E3 		cmp	r4, #131
 8347 4920 4D04000A 		beq	.L696
 8348 4924 5801009A 		bls	.L964
 8349 4928 850054E3 		cmp	r4, #133
 8350 492c F501000A 		beq	.L769
 8351 4930 8904003A 		bcc	.L702
 8352 4934 860054E3 		cmp	r4, #134
 8353 4938 C402000A 		beq	.L703
 8354 493c 870054E3 		cmp	r4, #135
 8355 4940 EF03001A 		bne	.L695
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8356              		.loc 1 2356 0
 8357 4944 44E79FE5 		ldr	lr, .L982+4
 8358 4948 1316DEE5 		ldrb	r1, [lr, #1555]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8359              		.loc 1 2357 0
 8360 494c 1426DEE5 		ldrb	r2, [lr, #1556]	@ zero_extendqisi2
 8361              	.LVL957:
 8362              	.L932:
 8363              	.LBE269:
 8364              	.LBE268:
 8365              	.LBB277:
 8366              	.LBB250:
2335:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8367              		.loc 1 2335 0
 8368 4950 0030A0E3 		mov	r3, #0
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8369              		.loc 1 2332 0
 8370 4954 2810C7E5 		strb	r1, [r7, #40]
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8371              		.loc 1 2337 0
 8372 4958 0500A0E1 		mov	r0, r5
 8373 495c 94179FE5 		ldr	r1, .L982+108
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8374              		.loc 1 2333 0
 8375 4960 2920C7E5 		strb	r2, [r7, #41]
2335:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8376              		.loc 1 2335 0
 8377 4964 2A30C7E5 		strb	r3, [r7, #42]
2336:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8378              		.loc 1 2336 0
 8379 4968 2B30C7E5 		strb	r3, [r7, #43]
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8380              		.loc 1 2337 0
 8381 496c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8382              	.LVL958:
2338:../uvc.c      **** 			  break;
 8383              		.loc 1 2338 0
 8384 4970 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 8385              	.LVL959:
 8386 4974 EA0100EA 		b	.L773
 8387              	.LVL960:
 8388              	.L680:
 8389              	.LBE250:
 8390              	.LBE277:
 8391              	.LBB278:
 8392              	.LBB279:
2292:../uvc.c      **** 
 8393              		.loc 1 2292 0
 8394 4978 54479FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8395              		.loc 1 2287 0
 8396 497c 6A56DAE5 		ldrb	r5, [r10, #1642]	@ zero_extendqisi2
 8397              	.LVL961:
2292:../uvc.c      **** 
 8398              		.loc 1 2292 0
 8399 4980 24408DE5 		str	r4, [sp, #36]
 8400 4984 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8401              	.LVL962:
2294:../uvc.c      **** 		 {
 8402              		.loc 1 2294 0
 8403 4988 830054E3 		cmp	r4, #131
 8404 498c 3604000A 		beq	.L729
 8405 4990 2A01009A 		bls	.L965
 8406 4994 850054E3 		cmp	r4, #133
 8407 4998 DA01000A 		beq	.L769
 8408 499c 6704003A 		bcc	.L735
 8409 49a0 860054E3 		cmp	r4, #134
 8410 49a4 A502000A 		beq	.L736
 8411 49a8 870054E3 		cmp	r4, #135
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8412              		.loc 1 2356 0
 8413 49ac 7316DA05 		ldreqb	r1, [r10, #1651]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8414              		.loc 1 2357 0
 8415 49b0 7426DA05 		ldreqb	r2, [r10, #1652]	@ zero_extendqisi2
2294:../uvc.c      **** 		 {
 8416              		.loc 1 2294 0
 8417 49b4 E5FFFF0A 		beq	.L932
 8418              	.L728:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8419              		.loc 1 2501 0
 8420 49b8 0000A0E3 		mov	r0, #0
 8421 49bc 0020A0E1 		mov	r2, r0
 8422 49c0 0110A0E3 		mov	r1, #1
 8423 49c4 FEFFFFEB 		bl	CyU3PUsbStall
 8424              	.LVL963:
2502:../uvc.c      **** 			  break;
 8425              		.loc 1 2502 0
 8426 49c8 24C09DE5 		ldr	ip, [sp, #36]
 8427 49cc 0620A0E3 		mov	r2, #6
 8428 49d0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8429 49d4 0400A0E3 		mov	r0, #4
 8430 49d8 0C179FE5 		ldr	r1, .L982+96
 8431 49dc FEFFFFEB 		bl	CyU3PDebugPrint
 8432              	.LVL964:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8433              		.loc 1 2288 0
 8434 49e0 FF20A0E3 		mov	r2, #255
 8435              	.LVL965:
 8436 49e4 CE0100EA 		b	.L773
 8437              	.LVL966:
 8438              	.L947:
 8439              	.LBE279:
 8440              	.LBE278:
 8441              	.LBB286:
 8442              	.LBB287:
2292:../uvc.c      **** 
 8443              		.loc 1 2292 0
 8444 49e8 E4469FE5 		ldr	r4, .L982+72
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8445              		.loc 1 2287 0
 8446 49ec 9A56DAE5 		ldrb	r5, [r10, #1690]	@ zero_extendqisi2
 8447              	.LVL967:
2292:../uvc.c      **** 
 8448              		.loc 1 2292 0
 8449 49f0 24408DE5 		str	r4, [sp, #36]
 8450 49f4 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8451              	.LVL968:
2294:../uvc.c      **** 		 {
 8452              		.loc 1 2294 0
 8453 49f8 830054E3 		cmp	r4, #131
 8454 49fc 2904000A 		beq	.L753
 8455 4a00 5C01009A 		bls	.L966
 8456 4a04 850054E3 		cmp	r4, #133
 8457 4a08 BE01000A 		beq	.L769
 8458 4a0c 4F04003A 		bcc	.L759
 8459 4a10 860054E3 		cmp	r4, #134
 8460 4a14 5102000A 		beq	.L760
 8461 4a18 870054E3 		cmp	r4, #135
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8462              		.loc 1 2356 0
 8463 4a1c A316DA05 		ldreqb	r1, [r10, #1699]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8464              		.loc 1 2357 0
 8465 4a20 A426DA05 		ldreqb	r2, [r10, #1700]	@ zero_extendqisi2
2294:../uvc.c      **** 		 {
 8466              		.loc 1 2294 0
 8467 4a24 C9FFFF0A 		beq	.L932
 8468              	.L752:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8469              		.loc 1 2501 0
 8470 4a28 0000A0E3 		mov	r0, #0
 8471 4a2c 0020A0E1 		mov	r2, r0
 8472 4a30 0110A0E3 		mov	r1, #1
 8473 4a34 FEFFFFEB 		bl	CyU3PUsbStall
 8474              	.LVL969:
2502:../uvc.c      **** 			  break;
 8475              		.loc 1 2502 0
 8476 4a38 24C09DE5 		ldr	ip, [sp, #36]
 8477 4a3c 0820A0E3 		mov	r2, #8
 8478 4a40 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8479 4a44 0400A0E3 		mov	r0, #4
 8480 4a48 9C169FE5 		ldr	r1, .L982+96
 8481 4a4c FEFFFFEB 		bl	CyU3PDebugPrint
 8482              	.LVL970:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8483              		.loc 1 2288 0
 8484 4a50 FF20A0E3 		mov	r2, #255
 8485              	.LVL971:
 8486 4a54 B20100EA 		b	.L773
 8487              	.LVL972:
 8488              	.L682:
 8489              	.LBE287:
 8490              	.LBE286:
4034:../uvc.c      ****     		break;
 8491              		.loc 1 4034 0
 8492 4a58 0A00A0E3 		mov	r0, #10
 8493 4a5c FEFFFFEB 		bl	CTControlHandle
 8494              	.LVL973:
 8495 4a60 44309DE5 		ldr	r3, [sp, #68]
 8496 4a64 C8FDFFEA 		b	.L631
 8497              	.L676:
 8498              	.LVL974:
4002:../uvc.c      **** 			break;
 8499              		.loc 1 4002 0
 8500 4a68 0300A0E3 		mov	r0, #3
 8501 4a6c FEFFFFEB 		bl	CTControlHandle
 8502              	.LVL975:
 8503 4a70 44309DE5 		ldr	r3, [sp, #68]
 8504 4a74 C4FDFFEA 		b	.L631
 8505              	.L678:
 8506              	.LVL976:
 8507              	.LBB294:
 8508              	.LBB295:
2292:../uvc.c      **** 
 8509              		.loc 1 2292 0
 8510 4a78 54469FE5 		ldr	r4, .L982+72
2284:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8511              		.loc 1 2284 0
 8512 4a7c 8FC6DAE5 		ldrb	ip, [r10, #1679]	@ zero_extendqisi2
 8513              	.LVL977:
2292:../uvc.c      **** 
 8514              		.loc 1 2292 0
 8515 4a80 24408DE5 		str	r4, [sp, #36]
 8516 4a84 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
2285:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8517              		.loc 1 2285 0
 8518 4a88 8036DAE5 		ldrb	r3, [r10, #1664]	@ zero_extendqisi2
 8519              	.LVL978:
2294:../uvc.c      **** 		 {
 8520              		.loc 1 2294 0
 8521 4a8c 830054E3 		cmp	r4, #131
2287:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8522              		.loc 1 2287 0
 8523 4a90 8256DAE5 		ldrb	r5, [r10, #1666]	@ zero_extendqisi2
 8524              	.LVL979:
2294:../uvc.c      **** 		 {
 8525              		.loc 1 2294 0
 8526 4a94 E803000A 		beq	.L740
 8527 4a98 4901009A 		bls	.L967
 8528 4a9c 850054E3 		cmp	r4, #133
 8529 4aa0 1004000A 		beq	.L745
 8530 4aa4 0B04003A 		bcc	.L746
 8531 4aa8 860054E3 		cmp	r4, #134
 8532 4aac 5802000A 		beq	.L747
 8533 4ab0 870054E3 		cmp	r4, #135
 8534 4ab4 C003001A 		bne	.L739
2356:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8535              		.loc 1 2356 0
 8536 4ab8 D0E59FE5 		ldr	lr, .L982+4
 8537 4abc 8B16DEE5 		ldrb	r1, [lr, #1675]	@ zero_extendqisi2
2357:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8538              		.loc 1 2357 0
 8539 4ac0 8C26DEE5 		ldrb	r2, [lr, #1676]	@ zero_extendqisi2
 8540              	.L930:
2335:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8541              		.loc 1 2335 0
 8542 4ac4 0030A0E3 		mov	r3, #0
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8543              		.loc 1 2332 0
 8544 4ac8 2810C7E5 		strb	r1, [r7, #40]
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8545              		.loc 1 2337 0
 8546 4acc 0500A0E1 		mov	r0, r5
 8547 4ad0 20169FE5 		ldr	r1, .L982+108
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8548              		.loc 1 2333 0
 8549 4ad4 2920C7E5 		strb	r2, [r7, #41]
2335:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8550              		.loc 1 2335 0
 8551 4ad8 2A30C7E5 		strb	r3, [r7, #42]
2336:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8552              		.loc 1 2336 0
 8553 4adc 2B30C7E5 		strb	r3, [r7, #43]
2337:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8554              		.loc 1 2337 0
 8555 4ae0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8556              	.LVL980:
2338:../uvc.c      **** 			  break;
 8557              		.loc 1 2338 0
 8558 4ae4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8559              	.LVL981:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8560              		.loc 1 2288 0
 8561 4ae8 FF20A0E3 		mov	r2, #255
 8562 4aec 0230A0E1 		mov	r3, r2
 8563              	.LVL982:
 8564              	.L749:
2507:../uvc.c      **** }
 8565              		.loc 1 2507 0
 8566 4af0 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 8567 4af4 FF00A0E3 		mov	r0, #255
 8568 4af8 00208DE5 		str	r2, [sp]
 8569 4afc 04108DE5 		str	r1, [sp, #4]
 8570 4b00 10108DE5 		str	r1, [sp, #16]
 8571 4b04 0C008DE5 		str	r0, [sp, #12]
 8572 4b08 08C08DE5 		str	ip, [sp, #8]
 8573 4b0c 14508DE5 		str	r5, [sp, #20]
 8574 4b10 0420A0E1 		mov	r2, r4
 8575              	.LVL983:
 8576 4b14 0400A0E3 		mov	r0, #4
 8577 4b18 A8159FE5 		ldr	r1, .L982+60
 8578 4b1c FEFFFFEB 		bl	CyU3PDebugPrint
 8579              	.LVL984:
 8580 4b20 44309DE5 		ldr	r3, [sp, #68]
 8581 4b24 98FDFFEA 		b	.L631
 8582              	.LVL985:
 8583              	.L954:
 8584 4b28 0030A0E1 		mov	r3, r0
 8585              	.LBE295:
 8586              	.LBE294:
 8587              	.LBE361:
 8588              	.LBE394:
4898:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8589              		.loc 1 4898 0
 8590 4b2c 0320A0E1 		mov	r2, r3
 8591 4b30 0500A0E1 		mov	r0, r5
 8592              	.LVL986:
 8593 4b34 9C159FE5 		ldr	r1, .L982+76
 8594 4b38 20308DE5 		str	r3, [sp, #32]
 8595 4b3c FEFFFFEB 		bl	CyU3PDebugPrint
 8596              	.LVL987:
4899:../uvc.c      **** 					}
 8597              		.loc 1 4899 0
 8598 4b40 20309DE5 		ldr	r3, [sp, #32]
 8599 4b44 0300A0E1 		mov	r0, r3
 8600 4b48 FEFFFFEB 		bl	CyFxAppErrorHandler
 8601              	.LVL988:
 8602              	.L802:
 8603              	.LBB395:
 8604              	.LBB222:
4295:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
 8605              		.loc 1 4295 0
 8606 4b4c 2700A0E3 		mov	r0, #39
 8607 4b50 FEFFFFEB 		bl	ControlHandle
 8608              	.LVL989:
4296:../uvc.c      ****     		break;
 8609              		.loc 1 4296 0
 8610 4b54 78359FE5 		ldr	r3, .L982+72
 8611 4b58 B020D4E1 		ldrh	r2, [r4]
 8612 4b5c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8613 4b60 0400A0E3 		mov	r0, #4
 8614 4b64 4C159FE5 		ldr	r1, .L982+44
 8615 4b68 FEFFFFEB 		bl	CyU3PDebugPrint
 8616              	.LVL990:
 8617 4b6c 44309DE5 		ldr	r3, [sp, #68]
 8618 4b70 85FDFFEA 		b	.L631
 8619              	.L793:
 8620              	.LVL991:
4261:../uvc.c      ****     		break;
 8621              		.loc 1 4261 0
 8622 4b74 1B00A0E3 		mov	r0, #27
 8623 4b78 FEFFFFEB 		bl	ControlHandle
 8624              	.LVL992:
 8625 4b7c 44309DE5 		ldr	r3, [sp, #68]
 8626 4b80 81FDFFEA 		b	.L631
 8627              	.L806:
4305:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
 8628              		.loc 1 4305 0
 8629 4b84 2900A0E3 		mov	r0, #41
 8630 4b88 FEFFFFEB 		bl	ControlHandle
 8631              	.LVL993:
4306:../uvc.c      ****     		break;
 8632              		.loc 1 4306 0
 8633 4b8c 40359FE5 		ldr	r3, .L982+72
 8634 4b90 B020D4E1 		ldrh	r2, [r4]
 8635 4b94 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8636 4b98 0400A0E3 		mov	r0, #4
 8637 4b9c 18159FE5 		ldr	r1, .L982+48
 8638 4ba0 FEFFFFEB 		bl	CyU3PDebugPrint
 8639              	.LVL994:
 8640 4ba4 44309DE5 		ldr	r3, [sp, #68]
 8641 4ba8 77FDFFEA 		b	.L631
 8642              	.L786:
 8643              	.LVL995:
4226:../uvc.c      ****     		break;
 8644              		.loc 1 4226 0
 8645 4bac 1300A0E3 		mov	r0, #19
 8646 4bb0 FEFFFFEB 		bl	ControlHandle
 8647              	.LVL996:
 8648 4bb4 44309DE5 		ldr	r3, [sp, #68]
 8649 4bb8 73FDFFEA 		b	.L631
 8650              	.L799:
 8651              	.LVL997:
4275:../uvc.c      ****     		break;
 8652              		.loc 1 4275 0
 8653 4bbc 1E00A0E3 		mov	r0, #30
 8654 4bc0 FEFFFFEB 		bl	ControlHandle
 8655              	.LVL998:
 8656 4bc4 44309DE5 		ldr	r3, [sp, #68]
 8657 4bc8 6FFDFFEA 		b	.L631
 8658              	.L790:
 8659              	.LVL999:
 8660              	.LBB167:
 8661              	.LBB168:
1359:../uvc.c      ****     /*
 8662              		.loc 1 1359 0
 8663 4bcc 00359FE5 		ldr	r3, .L982+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8664              		.loc 1 1341 0
 8665 4bd0 5807DAE5 		ldrb	r0, [r10, #1880]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8666              		.loc 1 1359 0
 8667 4bd4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8668              		.loc 1 1342 0
 8669 4bd8 5917DAE5 		ldrb	r1, [r10, #1881]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8670              		.loc 1 1359 0
 8671 4bdc 28308DE5 		str	r3, [sp, #40]
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8672              		.loc 1 1343 0
 8673 4be0 6727DAE5 		ldrb	r2, [r10, #1895]	@ zero_extendqisi2
1367:../uvc.c      **** 		 {
 8674              		.loc 1 1367 0
 8675 4be4 28409DE5 		ldr	r4, [sp, #40]
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8676              		.loc 1 1344 0
 8677 4be8 5A37DAE5 		ldrb	r3, [r10, #1882]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8678              		.loc 1 1341 0
 8679 4bec FF0000E2 		and	r0, r0, #255
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8680              		.loc 1 1342 0
 8681 4bf0 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8682              		.loc 1 1343 0
 8683 4bf4 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8684              		.loc 1 1367 0
 8685 4bf8 830054E3 		cmp	r4, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8686              		.loc 1 1341 0
 8687 4bfc 30008DE5 		str	r0, [sp, #48]
 8688              	.LVL1000:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8689              		.loc 1 1342 0
 8690 4c00 34108DE5 		str	r1, [sp, #52]
 8691              	.LVL1001:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8692              		.loc 1 1343 0
 8693 4c04 2C208DE5 		str	r2, [sp, #44]
 8694              	.LVL1002:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8695              		.loc 1 1344 0
 8696 4c08 FF3003E2 		and	r3, r3, #255
 8697              	.LVL1003:
1367:../uvc.c      **** 		 {
 8698              		.loc 1 1367 0
 8699 4c0c 7604000A 		beq	.L812
 8700 4c10 8902009A 		bls	.L968
 8701 4c14 28C09DE5 		ldr	ip, [sp, #40]
 8702 4c18 85005CE3 		cmp	ip, #133
 8703 4c1c 0E02000A 		beq	.L817
 8704 4c20 B604003A 		bcc	.L818
 8705 4c24 86005CE3 		cmp	ip, #134
 8706 4c28 A604000A 		beq	.L819
 8707 4c2c 87005CE3 		cmp	ip, #135
 8708 4c30 3C04001A 		bne	.L811
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8709              		.loc 1 1789 0
 8710 4c34 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8711              		.loc 1 1790 0
 8712 4c38 63C7DAE5 		ldrb	ip, [r10, #1891]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 8713              		.loc 1 1814 0
 8714 4c3c 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8715              		.loc 1 1791 0
 8716 4c40 6427DAE5 		ldrb	r2, [r10, #1892]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8717              		.loc 1 1789 0
 8718 4c44 1904000A 		beq	.L935
 8719              	.L826:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8720              		.loc 1 1796 0
 8721 4c48 0030A0E3 		mov	r3, #0
 8722              	.LVL1004:
1814:../uvc.c      **** 		 	 if(Len == 2){
 8723              		.loc 1 1814 0
 8724 4c4c A4149FE5 		ldr	r1, .L982+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8725              		.loc 1 1795 0
 8726 4c50 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8727              		.loc 1 1797 0
 8728 4c54 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8729              		.loc 1 1796 0
 8730 4c58 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8731              		.loc 1 1798 0
 8732 4c5c 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 8733              		.loc 1 1820 0
 8734 4c60 0340A0E1 		mov	r4, r3
 8735 4c64 24308DE5 		str	r3, [sp, #36]
1814:../uvc.c      **** 		 	 if(Len == 2){
 8736              		.loc 1 1814 0
 8737 4c68 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8738              	.LVL1005:
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8739              		.loc 1 1819 0
 8740 4c6c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8741              	.LVL1006:
1820:../uvc.c      **** 		 	 }
 8742              		.loc 1 1820 0
 8743 4c70 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 8744              	.LVL1007:
 8745 4c74 020200EA 		b	.L821
 8746              	.LVL1008:
 8747              	.L784:
 8748              	.LBE168:
 8749              	.LBE167:
4214:../uvc.c      ****     		break;
 8750              		.loc 1 4214 0
 8751 4c78 1000A0E3 		mov	r0, #16
 8752 4c7c FEFFFFEB 		bl	ControlHandle
 8753              	.LVL1009:
 8754 4c80 44309DE5 		ldr	r3, [sp, #68]
 8755 4c84 40FDFFEA 		b	.L631
 8756              	.L809:
4330:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
 8757              		.loc 1 4330 0
 8758 4c88 2F00A0E3 		mov	r0, #47
 8759 4c8c FEFFFFEB 		bl	ControlHandle
 8760              	.LVL1010:
4331:../uvc.c      ****     		break;
 8761              		.loc 1 4331 0
 8762 4c90 3C349FE5 		ldr	r3, .L982+72
 8763 4c94 B020D4E1 		ldrh	r2, [r4]
 8764 4c98 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8765 4c9c 0400A0E3 		mov	r0, #4
 8766 4ca0 18149FE5 		ldr	r1, .L982+52
 8767 4ca4 FEFFFFEB 		bl	CyU3PDebugPrint
 8768              	.LVL1011:
 8769 4ca8 44309DE5 		ldr	r3, [sp, #68]
 8770 4cac 36FDFFEA 		b	.L631
 8771              	.LVL1012:
 8772              	.L950:
 8773              	.LBE222:
 8774              	.LBE395:
 8775              	.LBB396:
 8776              	.LBB381:
 8777              	.LBB374:
 8778              	.LBB370:
1367:../uvc.c      **** 		 {
 8779              		.loc 1 1367 0
 8780 4cb0 810055E3 		cmp	r5, #129
 8781 4cb4 C202000A 		beq	.L655
 8782 4cb8 9701008A 		bhi	.L656
 8783 4cbc 010055E3 		cmp	r5, #1
 8784 4cc0 FB02001A 		bne	.L652
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8785              		.loc 1 1824 0
 8786 4cc4 42208DE2 		add	r2, sp, #66
 8787 4cc8 2000A0E3 		mov	r0, #32
 8788 4ccc 24149FE5 		ldr	r1, .L982+108
 8789 4cd0 20308DE5 		str	r3, [sp, #32]
 8790 4cd4 1CC08DE5 		str	ip, [sp, #28]
 8791 4cd8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8792              	.LVL1013:
1826:../uvc.c      **** 			   {
 8793              		.loc 1 1826 0
 8794 4cdc 20309DE5 		ldr	r3, [sp, #32]
 8795 4ce0 1CC09DE5 		ldr	ip, [sp, #28]
 8796 4ce4 002050E2 		subs	r2, r0, #0
 8797 4ce8 D804001A 		bne	.L666
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8798              		.loc 1 1828 0
 8799 4cec 020053E3 		cmp	r3, #2
1830:../uvc.c      **** 				 }else{
 8800              		.loc 1 1830 0
 8801 4cf0 29E0DB05 		ldreqb	lr, [fp, #41]	@ zero_extendqisi2
1833:../uvc.c      **** 				 }
 8802              		.loc 1 1833 0
 8803 4cf4 2A00DB15 		ldrneb	r0, [fp, #42]	@ zero_extendqisi2
 8804              	.LVL1014:
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8805              		.loc 1 1829 0
 8806 4cf8 2840DBE5 		ldrb	r4, [fp, #40]	@ zero_extendqisi2
 8807              	.LVL1015:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8808              		.loc 1 1836 0
 8809 4cfc 28209DE5 		ldr	r2, [sp, #40]
 8810              	.LVL1016:
1830:../uvc.c      **** 				 }else{
 8811              		.loc 1 1830 0
 8812 4d00 24E08D05 		streq	lr, [sp, #36]
 8813              	.LVL1017:
1833:../uvc.c      **** 				 }
 8814              		.loc 1 1833 0
 8815 4d04 24008D15 		strne	r0, [sp, #36]
 8816              	.LVL1018:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8817              		.loc 1 1836 0
 8818 4d08 2C109DE5 		ldr	r1, [sp, #44]
 8819 4d0c 1C008DE9 		stmib	sp, {r2, r3, r4}
 8820 4d10 24309DE5 		ldr	r3, [sp, #36]
 8821 4d14 0120A0E3 		mov	r2, #1
 8822 4d18 00108DE5 		str	r1, [sp]
 8823 4d1c 10308DE5 		str	r3, [sp, #16]
 8824 4d20 D8139FE5 		ldr	r1, .L982+116
 8825 4d24 0C30A0E1 		mov	r3, ip
 8826 4d28 0400A0E3 		mov	r0, #4
 8827 4d2c FEFFFFEB 		bl	CyU3PDebugPrint
 8828              	.LVL1019:
2094:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 8829              		.loc 1 2094 0
 8830 4d30 CCC39FE5 		ldr	ip, .L982+120
 8831 4d34 0010E0E3 		mvn	r1, #0
 8832 4d38 1C009CE5 		ldr	r0, [ip, #28]
 8833 4d3c FEFFFFEB 		bl	_txe_mutex_get
 8834              	.LVL1020:
2103:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8835              		.loc 1 2103 0
 8836 4d40 0010A0E3 		mov	r1, #0
 8837 4d44 2C209DE5 		ldr	r2, [sp, #44]
 8838 4d48 28309DE5 		ldr	r3, [sp, #40]
 8839 4d4c 04108DE5 		str	r1, [sp, #4]
 8840 4d50 00408DE5 		str	r4, [sp]
 8841 4d54 0110A0E3 		mov	r1, #1
 8842 4d58 A4039FE5 		ldr	r0, .L982+120
 8843 4d5c FEFFFFEB 		bl	cmdSet
 8844              	.LVL1021:
2104:../uvc.c      **** 
 8845              		.loc 1 2104 0
 8846 4d60 9CE39FE5 		ldr	lr, .L982+120
 8847 4d64 1C009EE5 		ldr	r0, [lr, #28]
 8848 4d68 FEFFFFEB 		bl	_txe_mutex_put
 8849              	.LVL1022:
 8850 4d6c 24C09DE5 		ldr	ip, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8851              		.loc 1 1355 0
 8852 4d70 FF30A0E3 		mov	r3, #255
2107:../uvc.c      **** 							 break;
 8853              		.loc 1 2107 0
 8854 4d74 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8855              		.loc 1 1355 0
 8856 4d78 0320A0E1 		mov	r2, r3
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8857              		.loc 1 2106 0
 8858 4d7c 5545CAE5 		strb	r4, [r10, #1365]
2107:../uvc.c      **** 							 break;
 8859              		.loc 1 2107 0
 8860 4d80 5915CAE5 		strb	r1, [r10, #1369]
 8861              	.LVL1023:
 8862              	.L662:
2268:../uvc.c      **** }
 8863              		.loc 1 2268 0
 8864 4d84 0C008DE9 		stmib	sp, {r2, r3}
 8865 4d88 0520A0E1 		mov	r2, r5
 8866              	.LVL1024:
 8867 4d8c 00C08DE5 		str	ip, [sp]
 8868              	.LVL1025:
 8869              	.L939:
 8870              	.LBE370:
 8871              	.LBE374:
 8872              	.LBE381:
 8873              	.LBE396:
 8874              	.LBB397:
 8875              	.LBB223:
 8876              	.LBB177:
 8877              	.LBB169:
 8878 4d90 0430A0E1 		mov	r3, r4
 8879 4d94 0400A0E3 		mov	r0, #4
 8880 4d98 40139FE5 		ldr	r1, .L982+84
 8881 4d9c FEFFFFEB 		bl	CyU3PDebugPrint
 8882              	.LVL1026:
 8883 4da0 44309DE5 		ldr	r3, [sp, #68]
 8884 4da4 F8FCFFEA 		b	.L631
 8885              	.LVL1027:
 8886              	.L959:
 8887              	.LBE169:
 8888              	.LBE177:
 8889              	.LBE223:
 8890              	.LBE397:
 8891              	.LBB398:
 8892              	.LBB362:
 8893              	.LBB304:
 8894              	.LBB233:
2294:../uvc.c      **** 		 {
 8895              		.loc 1 2294 0
 8896 4da8 810054E3 		cmp	r4, #129
 8897 4dac 4503000A 		beq	.L709
 8898 4db0 9101008A 		bhi	.L710
 8899 4db4 010054E3 		cmp	r4, #1
 8900 4db8 1FFEFF1A 		bne	.L706
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8901              		.loc 1 2365 0
 8902 4dbc 34139FE5 		ldr	r1, .L982+108
 8903 4dc0 42208DE2 		add	r2, sp, #66
 8904 4dc4 2000A0E3 		mov	r0, #32
 8905 4dc8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8906              	.LVL1028:
2496:../uvc.c      **** 			  		 break;
 8907              		.loc 1 2496 0
 8908 4dcc 24109DE5 		ldr	r1, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8909              		.loc 1 2495 0
 8910 4dd0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2496:../uvc.c      **** 			  		 break;
 8911              		.loc 1 2496 0
 8912 4dd4 0400A0E3 		mov	r0, #4
 8913 4dd8 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8914 4ddc 0020A0E1 		mov	r2, r0
 8915 4de0 DC129FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8916              		.loc 1 2495 0
 8917 4de4 45C6CAE5 		strb	ip, [r10, #1605]
2496:../uvc.c      **** 			  		 break;
 8918              		.loc 1 2496 0
 8919 4de8 FEFFFFEB 		bl	CyU3PDebugPrint
 8920              	.LVL1029:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8921              		.loc 1 2288 0
 8922 4dec FF20A0E3 		mov	r2, #255
 8923 4df0 CB0000EA 		b	.L773
 8924              	.LVL1030:
 8925              	.L962:
 8926              	.LBE233:
 8927              	.LBE304:
 8928              	.LBB305:
 8929              	.LBB251:
2294:../uvc.c      **** 		 {
 8930              		.loc 1 2294 0
 8931 4df4 810054E3 		cmp	r4, #129
 8932 4df8 FF02000A 		beq	.L766
 8933 4dfc 6701008A 		bhi	.L767
 8934 4e00 010054E3 		cmp	r4, #1
 8935 4e04 98FEFF1A 		bne	.L763
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8936              		.loc 1 2365 0
 8937 4e08 E8129FE5 		ldr	r1, .L982+108
 8938 4e0c 42208DE2 		add	r2, sp, #66
 8939 4e10 2000A0E3 		mov	r0, #32
 8940 4e14 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8941              	.LVL1031:
2496:../uvc.c      **** 			  		 break;
 8942              		.loc 1 2496 0
 8943 4e18 24E09DE5 		ldr	lr, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8944              		.loc 1 2495 0
 8945 4e1c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2496:../uvc.c      **** 			  		 break;
 8946              		.loc 1 2496 0
 8947 4e20 0920A0E3 		mov	r2, #9
 8948 4e24 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8949 4e28 0400A0E3 		mov	r0, #4
 8950 4e2c 90129FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8951              		.loc 1 2495 0
 8952 4e30 BDC6CAE5 		strb	ip, [r10, #1725]
2496:../uvc.c      **** 			  		 break;
 8953              		.loc 1 2496 0
 8954 4e34 FEFFFFEB 		bl	CyU3PDebugPrint
 8955              	.LVL1032:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8956              		.loc 1 2288 0
 8957 4e38 FF20A0E3 		mov	r2, #255
 8958 4e3c B80000EA 		b	.L773
 8959              	.LVL1033:
 8960              	.L965:
 8961              	.LBE251:
 8962              	.LBE305:
 8963              	.LBB306:
 8964              	.LBB280:
2294:../uvc.c      **** 		 {
 8965              		.loc 1 2294 0
 8966 4e40 810054E3 		cmp	r4, #129
 8967 4e44 CA02000A 		beq	.L731
 8968 4e48 5C01008A 		bhi	.L732
 8969 4e4c 010054E3 		cmp	r4, #1
 8970 4e50 D8FEFF1A 		bne	.L728
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8971              		.loc 1 2365 0
 8972 4e54 9C129FE5 		ldr	r1, .L982+108
 8973 4e58 42208DE2 		add	r2, sp, #66
 8974 4e5c 2000A0E3 		mov	r0, #32
 8975 4e60 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8976              	.LVL1034:
2496:../uvc.c      **** 			  		 break;
 8977              		.loc 1 2496 0
 8978 4e64 24E09DE5 		ldr	lr, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8979              		.loc 1 2495 0
 8980 4e68 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2496:../uvc.c      **** 			  		 break;
 8981              		.loc 1 2496 0
 8982 4e6c 0620A0E3 		mov	r2, #6
 8983 4e70 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8984 4e74 0400A0E3 		mov	r0, #4
 8985 4e78 44129FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8986              		.loc 1 2495 0
 8987 4e7c 75C6CAE5 		strb	ip, [r10, #1653]
2496:../uvc.c      **** 			  		 break;
 8988              		.loc 1 2496 0
 8989 4e80 FEFFFFEB 		bl	CyU3PDebugPrint
 8990              	.LVL1035:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8991              		.loc 1 2288 0
 8992 4e84 FF20A0E3 		mov	r2, #255
 8993 4e88 A50000EA 		b	.L773
 8994              	.LVL1036:
 8995              	.L964:
 8996              	.LBE280:
 8997              	.LBE306:
 8998              	.LBB307:
 8999              	.LBB270:
2294:../uvc.c      **** 		 {
 9000              		.loc 1 2294 0
 9001 4e8c 810054E3 		cmp	r4, #129
 9002 4e90 C502000A 		beq	.L698
 9003 4e94 4D01008A 		bhi	.L699
 9004 4e98 010054E3 		cmp	r4, #1
 9005 4e9c 9802001A 		bne	.L695
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9006              		.loc 1 2365 0
 9007 4ea0 50129FE5 		ldr	r1, .L982+108
 9008 4ea4 42208DE2 		add	r2, sp, #66
 9009 4ea8 2000A0E3 		mov	r0, #32
 9010 4eac FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9011              	.LVL1037:
2496:../uvc.c      **** 			  		 break;
 9012              		.loc 1 2496 0
 9013 4eb0 24009DE5 		ldr	r0, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9014              		.loc 1 2495 0
 9015 4eb4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9016 4eb8 D0E19FE5 		ldr	lr, .L982+4
2496:../uvc.c      **** 			  		 break;
 9017              		.loc 1 2496 0
 9018 4ebc 0030D0E5 		ldrb	r3, [r0]	@ zero_extendqisi2
 9019 4ec0 0220A0E3 		mov	r2, #2
 9020 4ec4 0400A0E3 		mov	r0, #4
 9021 4ec8 F4119FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9022              		.loc 1 2495 0
 9023 4ecc 15C6CEE5 		strb	ip, [lr, #1557]
2496:../uvc.c      **** 			  		 break;
 9024              		.loc 1 2496 0
 9025 4ed0 FEFFFFEB 		bl	CyU3PDebugPrint
 9026              	.LVL1038:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9027              		.loc 1 2288 0
 9028 4ed4 FF20A0E3 		mov	r2, #255
 9029 4ed8 910000EA 		b	.L773
 9030              	.LVL1039:
 9031              	.L963:
 9032              	.LBE270:
 9033              	.LBE307:
 9034              	.LBB308:
 9035              	.LBB262:
2294:../uvc.c      **** 		 {
 9036              		.loc 1 2294 0
 9037 4edc 810054E3 		cmp	r4, #129
 9038 4ee0 F402000A 		beq	.L687
 9039 4ee4 3101008A 		bhi	.L688
 9040 4ee8 010054E3 		cmp	r4, #1
 9041 4eec 7AFEFF1A 		bne	.L684
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9042              		.loc 1 2365 0
 9043 4ef0 00129FE5 		ldr	r1, .L982+108
 9044 4ef4 42208DE2 		add	r2, sp, #66
 9045 4ef8 2000A0E3 		mov	r0, #32
 9046 4efc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9047              	.LVL1040:
2496:../uvc.c      **** 			  		 break;
 9048              		.loc 1 2496 0
 9049 4f00 24E09DE5 		ldr	lr, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9050              		.loc 1 2495 0
 9051 4f04 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2496:../uvc.c      **** 			  		 break;
 9052              		.loc 1 2496 0
 9053 4f08 0020A0E3 		mov	r2, #0
 9054 4f0c 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9055 4f10 0400A0E3 		mov	r0, #4
 9056 4f14 A8119FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9057              		.loc 1 2495 0
 9058 4f18 E5C5CAE5 		strb	ip, [r10, #1509]
2496:../uvc.c      **** 			  		 break;
 9059              		.loc 1 2496 0
 9060 4f1c FEFFFFEB 		bl	CyU3PDebugPrint
 9061              	.LVL1041:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9062              		.loc 1 2288 0
 9063 4f20 FF20A0E3 		mov	r2, #255
 9064 4f24 7E0000EA 		b	.L773
 9065              	.LVL1042:
 9066              	.L961:
 9067              	.LBE262:
 9068              	.LBE308:
 9069              	.LBB309:
 9070              	.LBB241:
2294:../uvc.c      **** 		 {
 9071              		.loc 1 2294 0
 9072 4f28 810054E3 		cmp	r4, #129
 9073 4f2c 1503000A 		beq	.L720
 9074 4f30 2D01008A 		bhi	.L721
 9075 4f34 010054E3 		cmp	r4, #1
 9076 4f38 F402001A 		bne	.L717
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9077              		.loc 1 2365 0
 9078 4f3c B4119FE5 		ldr	r1, .L982+108
 9079 4f40 42208DE2 		add	r2, sp, #66
 9080 4f44 2000A0E3 		mov	r0, #32
 9081 4f48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9082              	.LVL1043:
2496:../uvc.c      **** 			  		 break;
 9083              		.loc 1 2496 0
 9084 4f4c 24009DE5 		ldr	r0, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9085              		.loc 1 2495 0
 9086 4f50 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9087 4f54 34E19FE5 		ldr	lr, .L982+4
2496:../uvc.c      **** 			  		 break;
 9088              		.loc 1 2496 0
 9089 4f58 0030D0E5 		ldrb	r3, [r0]	@ zero_extendqisi2
 9090 4f5c 0520A0E3 		mov	r2, #5
 9091 4f60 0400A0E3 		mov	r0, #4
 9092 4f64 58119FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9093              		.loc 1 2495 0
 9094 4f68 5DC6CEE5 		strb	ip, [lr, #1629]
2496:../uvc.c      **** 			  		 break;
 9095              		.loc 1 2496 0
 9096 4f6c FEFFFFEB 		bl	CyU3PDebugPrint
 9097              	.LVL1044:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9098              		.loc 1 2288 0
 9099 4f70 FF20A0E3 		mov	r2, #255
 9100 4f74 6A0000EA 		b	.L773
 9101              	.LVL1045:
 9102              	.L966:
 9103              	.LBE241:
 9104              	.LBE309:
 9105              	.LBB310:
 9106              	.LBB288:
2294:../uvc.c      **** 		 {
 9107              		.loc 1 2294 0
 9108 4f78 810054E3 		cmp	r4, #129
 9109 4f7c FE02000A 		beq	.L755
 9110 4f80 1601008A 		bhi	.L756
 9111 4f84 010054E3 		cmp	r4, #1
 9112 4f88 A6FEFF1A 		bne	.L752
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9113              		.loc 1 2365 0
 9114 4f8c 64119FE5 		ldr	r1, .L982+108
 9115 4f90 42208DE2 		add	r2, sp, #66
 9116 4f94 2000A0E3 		mov	r0, #32
 9117 4f98 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9118              	.LVL1046:
2496:../uvc.c      **** 			  		 break;
 9119              		.loc 1 2496 0
 9120 4f9c 24E09DE5 		ldr	lr, [sp, #36]
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9121              		.loc 1 2495 0
 9122 4fa0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2496:../uvc.c      **** 			  		 break;
 9123              		.loc 1 2496 0
 9124 4fa4 0820A0E3 		mov	r2, #8
 9125 4fa8 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9126 4fac 0400A0E3 		mov	r0, #4
 9127 4fb0 0C119FE5 		ldr	r1, .L982+56
2495:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9128              		.loc 1 2495 0
 9129 4fb4 A5C6CAE5 		strb	ip, [r10, #1701]
2496:../uvc.c      **** 			  		 break;
 9130              		.loc 1 2496 0
 9131 4fb8 FEFFFFEB 		bl	CyU3PDebugPrint
 9132              	.LVL1047:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9133              		.loc 1 2288 0
 9134 4fbc FF20A0E3 		mov	r2, #255
 9135 4fc0 570000EA 		b	.L773
 9136              	.LVL1048:
 9137              	.L967:
 9138              	.LBE288:
 9139              	.LBE310:
 9140              	.LBB311:
 9141              	.LBB296:
2294:../uvc.c      **** 		 {
 9142              		.loc 1 2294 0
 9143 4fc4 810054E3 		cmp	r4, #129
 9144 4fc8 5902000A 		beq	.L742
 9145 4fcc EB00008A 		bhi	.L743
 9146 4fd0 010054E3 		cmp	r4, #1
 9147 4fd4 7802001A 		bne	.L739
2365:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9148              		.loc 1 2365 0
 9149 4fd8 18119FE5 		ldr	r1, .L982+108
 9150 4fdc 42208DE2 		add	r2, sp, #66
 9151 4fe0 2000A0E3 		mov	r0, #32
 9152 4fe4 20308DE5 		str	r3, [sp, #32]
 9153 4fe8 1CC08DE5 		str	ip, [sp, #28]
 9154 4fec FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9155              	.LVL1049:
2457:../uvc.c      **** 					  {
 9156              		.loc 1 2457 0
 9157 4ff0 98109FE5 		ldr	r1, .L982+4
2367:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9158              		.loc 1 2367 0
 9159 4ff4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
2457:../uvc.c      **** 					  {
 9160              		.loc 1 2457 0
 9161 4ff8 FD05D1E5 		ldrb	r0, [r1, #1533]	@ zero_extendqisi2
2368:../uvc.c      **** 			  value = Data1;
 9162              		.loc 1 2368 0
 9163 4ffc 29E0D7E5 		ldrb	lr, [r7, #41]	@ zero_extendqisi2
2457:../uvc.c      **** 					  {
 9164              		.loc 1 2457 0
 9165 5000 010050E3 		cmp	r0, #1
 9166 5004 08005013 		cmpne	r0, #8
2367:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9167              		.loc 1 2367 0
 9168 5008 24208DE5 		str	r2, [sp, #36]
 9169              	.LVL1050:
2457:../uvc.c      **** 					  {
 9170              		.loc 1 2457 0
 9171 500c 0000A013 		movne	r0, #0
 9172 5010 0100A003 		moveq	r0, #1
2368:../uvc.c      **** 			  value = Data1;
 9173              		.loc 1 2368 0
 9174 5014 28E08DE5 		str	lr, [sp, #40]
 9175              	.LVL1051:
2457:../uvc.c      **** 					  {
 9176              		.loc 1 2457 0
 9177 5018 F102001A 		bne	.L750
 9178              	.LVL1052:
2460:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9179              		.loc 1 2460 0
 9180 501c E0209FE5 		ldr	r2, .L982+120
 9181 5020 0010E0E3 		mvn	r1, #0
 9182 5024 1C0092E5 		ldr	r0, [r2, #28]
 9183 5028 FEFFFFEB 		bl	_txe_mutex_get
 9184              	.LVL1053:
2461:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9185              		.loc 1 2461 0
 9186 502c 24E09DE5 		ldr	lr, [sp, #36]
 9187 5030 1CC09DE5 		ldr	ip, [sp, #28]
 9188 5034 20309DE5 		ldr	r3, [sp, #32]
 9189 5038 0010A0E3 		mov	r1, #0
 9190 503c 00E08DE5 		str	lr, [sp]
 9191 5040 0320A0E1 		mov	r2, r3
 9192 5044 04108DE5 		str	r1, [sp, #4]
 9193 5048 0C30A0E1 		mov	r3, ip
 9194 504c 2210A0E3 		mov	r1, #34
 9195 5050 AC009FE5 		ldr	r0, .L982+120
 9196 5054 FEFFFFEB 		bl	cmdSet
 9197              	.LVL1054:
2462:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9198              		.loc 1 2462 0
 9199 5058 A4109FE5 		ldr	r1, .L982+120
 9200 505c 1C0091E5 		ldr	r0, [r1, #28]
 9201 5060 FEFFFFEB 		bl	_txe_mutex_put
 9202              	.LVL1055:
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9203              		.loc 1 2465 0
 9204 5064 24E09FE5 		ldr	lr, .L982+4
 9205 5068 24C09DE5 		ldr	ip, [sp, #36]
2467:../uvc.c      **** 					  }else{
 9206              		.loc 1 2467 0
 9207 506c 9046CEE5 		strb	r4, [lr, #1680]
2465:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9208              		.loc 1 2465 0
 9209 5070 8DC6CEE5 		strb	ip, [lr, #1677]
2466:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9210              		.loc 1 2466 0
 9211 5074 28C09DE5 		ldr	ip, [sp, #40]
 9212 5078 8EC6CEE5 		strb	ip, [lr, #1678]
 9213              	.LVL1056:
 9214              	.L751:
2471:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9215              		.loc 1 2471 0
 9216 507c 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9217              	.LVL1057:
2472:../uvc.c      **** 
 9218              		.loc 1 2472 0
 9219 5080 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 9220              	.LVL1058:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9221              		.loc 1 2288 0
 9222 5084 FFC0A0E3 		mov	ip, #255
 9223 5088 98FEFFEA 		b	.L749
 9224              	.L983:
 9225              		.align	2
 9226              	.L982:
 9227 508c 00000000 		.word	.LANCHOR0
 9228 5090 00000000 		.word	.LANCHOR1
 9229 5094 00000000 		.word	glInterStaBuffer
 9230 5098 00000000 		.word	wIndex
 9231 509c 00000000 		.word	wValue
 9232 50a0 AC0C0000 		.word	.LC70
 9233 50a4 00000000 		.word	bmReqType
 9234 50a8 00000000 		.word	wLength
 9235 50ac 300C0000 		.word	.LC69
 9236 50b0 00000000 		.word	glChHandleInterStat
 9237 50b4 880D0000 		.word	.LC76
 9238 50b8 D80C0000 		.word	.LC71
 9239 50bc 180D0000 		.word	.LC73
 9240 50c0 D00D0000 		.word	.LC78
 9241 50c4 A4060000 		.word	.LC37
 9242 50c8 EC060000 		.word	.LC39
 9243 50cc F80C0000 		.word	.LC72
 9244 50d0 B00D0000 		.word	.LC77
 9245 50d4 00000000 		.word	bRequest
 9246 50d8 F00D0000 		.word	.LC79
 9247 50dc 600D0000 		.word	.LC75
 9248 50e0 2C060000 		.word	.LC35
 9249 50e4 3C0D0000 		.word	.LC74
 9250 50e8 64050000 		.word	.LC31
 9251 50ec C8060000 		.word	.LC38
 9252 50f0 00000000 		.word	.LANCHOR1
 9253 50f4 38040000 		.word	.LC26
 9254 50f8 28000000 		.word	.LANCHOR0+40
 9255 50fc FC050000 		.word	.LC34
 9256 5100 68040000 		.word	.LC27
 9257 5104 00000000 		.word	cmdQu
 9258              	.LVL1059:
 9259              	.L769:
 9260              	.LBE296:
 9261              	.LBE311:
 9262              	.LBB312:
 9263              	.LBB252:
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9264              		.loc 1 2299 0
 9265 5108 0030A0E3 		mov	r3, #0
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9266              		.loc 1 2300 0
 9267 510c 0200A0E3 		mov	r0, #2
 9268 5110 20101FE5 		ldr	r1, .L982+108
2298:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9269              		.loc 1 2298 0
 9270 5114 2850C7E5 		strb	r5, [r7, #40]
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9271              		.loc 1 2299 0
 9272 5118 2930C7E5 		strb	r3, [r7, #41]
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9273              		.loc 1 2300 0
 9274 511c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9275              	.LVL1060:
2301:../uvc.c      **** 			  break;
 9276              		.loc 1 2301 0
 9277 5120 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9278              	.LVL1061:
 9279              	.L773:
2507:../uvc.c      **** }
 9280              		.loc 1 2507 0
 9281 5124 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9282 5128 FF30A0E3 		mov	r3, #255
 9283 512c 08208DE5 		str	r2, [sp, #8]
 9284 5130 04108DE5 		str	r1, [sp, #4]
 9285 5134 10108DE5 		str	r1, [sp, #16]
 9286 5138 00308DE5 		str	r3, [sp]
 9287 513c 0C308DE5 		str	r3, [sp, #12]
 9288 5140 14508DE5 		str	r5, [sp, #20]
 9289 5144 0420A0E1 		mov	r2, r4
 9290              	.LVL1062:
 9291 5148 0400A0E3 		mov	r0, #4
 9292 514c 8C101FE5 		ldr	r1, .L982+60
 9293 5150 FEFFFFEB 		bl	CyU3PDebugPrint
 9294              	.LVL1063:
 9295 5154 44309DE5 		ldr	r3, [sp, #68]
 9296 5158 0BFCFFEA 		b	.L631
 9297              	.LVL1064:
 9298              	.L792:
 9299              	.LBE252:
 9300              	.LBE312:
 9301              	.LBE362:
 9302              	.LBE398:
 9303              	.LBB399:
 9304              	.LBB224:
4257:../uvc.c      ****     		break;
 9305              		.loc 1 4257 0
 9306 515c 1A00A0E3 		mov	r0, #26
 9307 5160 FEFFFFEB 		bl	ControlHandle
 9308              	.LVL1065:
 9309 5164 44309DE5 		ldr	r3, [sp, #68]
 9310 5168 07FCFFEA 		b	.L631
 9311              	.L788:
 9312              	.LVL1066:
4246:../uvc.c      ****      		break;
 9313              		.loc 1 4246 0
 9314 516c 1800A0E3 		mov	r0, #24
 9315 5170 FEFFFFEB 		bl	ControlHandle
 9316              	.LVL1067:
 9317 5174 44309DE5 		ldr	r3, [sp, #68]
 9318 5178 03FCFFEA 		b	.L631
 9319              	.L780:
 9320              	.LVL1068:
4234:../uvc.c      ****      		break;
 9321              		.loc 1 4234 0
 9322 517c 1500A0E3 		mov	r0, #21
 9323 5180 FEFFFFEB 		bl	ControlHandle
 9324              	.LVL1069:
 9325 5184 44309DE5 		ldr	r3, [sp, #68]
 9326 5188 FFFBFFEA 		b	.L631
 9327              	.L778:
 9328              	.LVL1070:
4267:../uvc.c      ****     		break;
 9329              		.loc 1 4267 0
 9330 518c 1C00A0E3 		mov	r0, #28
 9331 5190 FEFFFFEB 		bl	ControlHandle
 9332              	.LVL1071:
 9333 5194 44309DE5 		ldr	r3, [sp, #68]
 9334 5198 FBFBFFEA 		b	.L631
 9335              	.L795:
4300:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9336              		.loc 1 4300 0
 9337 519c 2800A0E3 		mov	r0, #40
 9338 51a0 FEFFFFEB 		bl	ControlHandle
 9339              	.LVL1072:
4301:../uvc.c      ****     		break;
 9340              		.loc 1 4301 0
 9341 51a4 D8301FE5 		ldr	r3, .L982+72
 9342 51a8 B020D4E1 		ldrh	r2, [r4]
 9343 51ac 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9344 51b0 0400A0E3 		mov	r0, #4
 9345 51b4 F0101FE5 		ldr	r1, .L982+64
 9346 51b8 FEFFFFEB 		bl	CyU3PDebugPrint
 9347              	.LVL1073:
 9348 51bc 44309DE5 		ldr	r3, [sp, #68]
 9349 51c0 F1FBFFEA 		b	.L631
 9350              	.L801:
 9351              	.LVL1074:
4291:../uvc.c      ****     		break;
 9352              		.loc 1 4291 0
 9353 51c4 2600A0E3 		mov	r0, #38
 9354 51c8 FEFFFFEB 		bl	ControlHandle
 9355              	.LVL1075:
 9356 51cc 44309DE5 		ldr	r3, [sp, #68]
 9357 51d0 EDFBFFEA 		b	.L631
 9358              	.L797:
 9359              	.LVL1076:
4283:../uvc.c      ****     		break;
 9360              		.loc 1 4283 0
 9361 51d4 2400A0E3 		mov	r0, #36
 9362 51d8 FEFFFFEB 		bl	ControlHandle
 9363              	.LVL1077:
 9364 51dc 44309DE5 		ldr	r3, [sp, #68]
 9365 51e0 E9FBFFEA 		b	.L631
 9366              	.L782:
 9367              	.LVL1078:
4222:../uvc.c      ****      		break;
 9368              		.loc 1 4222 0
 9369 51e4 1200A0E3 		mov	r0, #18
 9370 51e8 FEFFFFEB 		bl	ControlHandle
 9371              	.LVL1079:
 9372 51ec 44309DE5 		ldr	r3, [sp, #68]
 9373 51f0 E5FBFFEA 		b	.L631
 9374              	.L808:
4325:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9375              		.loc 1 4325 0
 9376 51f4 2E00A0E3 		mov	r0, #46
 9377 51f8 FEFFFFEB 		bl	ControlHandle
 9378              	.LVL1080:
4326:../uvc.c      ****     		break;
 9379              		.loc 1 4326 0
 9380 51fc 30311FE5 		ldr	r3, .L982+72
 9381 5200 B020D4E1 		ldrh	r2, [r4]
 9382 5204 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9383 5208 0400A0E3 		mov	r0, #4
 9384 520c 44111FE5 		ldr	r1, .L982+68
 9385 5210 FEFFFFEB 		bl	CyU3PDebugPrint
 9386              	.LVL1081:
 9387 5214 44309DE5 		ldr	r3, [sp, #68]
 9388 5218 DBFBFFEA 		b	.L631
 9389              	.L804:
 9390              	.LVL1082:
 9391              	.LBB178:
 9392              	.LBB179:
1359:../uvc.c      ****     /*
 9393              		.loc 1 1359 0
 9394 521c 50C11FE5 		ldr	ip, .L982+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9395              		.loc 1 1341 0
 9396 5220 8017DAE5 		ldrb	r1, [r10, #1920]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 9397              		.loc 1 1359 0
 9398 5224 0040DCE5 		ldrb	r4, [ip]	@ zero_extendqisi2
 9399 5228 24C08DE5 		str	ip, [sp, #36]
 9400 522c 2C408DE5 		str	r4, [sp, #44]
1367:../uvc.c      **** 		 {
 9401              		.loc 1 1367 0
 9402 5230 2CC09DE5 		ldr	ip, [sp, #44]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9403              		.loc 1 1342 0
 9404 5234 8147DAE5 		ldrb	r4, [r10, #1921]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9405              		.loc 1 1343 0
 9406 5238 8F27DAE5 		ldrb	r2, [r10, #1935]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9407              		.loc 1 1344 0
 9408 523c 8237DAE5 		ldrb	r3, [r10, #1922]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9409              		.loc 1 1341 0
 9410 5240 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9411              		.loc 1 1343 0
 9412 5244 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 9413              		.loc 1 1367 0
 9414 5248 83005CE3 		cmp	ip, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9415              		.loc 1 1341 0
 9416 524c 34108DE5 		str	r1, [sp, #52]
 9417              	.LVL1083:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9418              		.loc 1 1342 0
 9419 5250 FF4004E2 		and	r4, r4, #255
 9420              	.LVL1084:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9421              		.loc 1 1343 0
 9422 5254 30208DE5 		str	r2, [sp, #48]
 9423              	.LVL1085:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9424              		.loc 1 1344 0
 9425 5258 FF3003E2 		and	r3, r3, #255
 9426              	.LVL1086:
1367:../uvc.c      **** 		 {
 9427              		.loc 1 1367 0
 9428 525c 4D02000A 		beq	.L860
 9429 5260 C300009A 		bls	.L969
 9430 5264 2C409DE5 		ldr	r4, [sp, #44]
 9431              	.LVL1087:
 9432 5268 850054E3 		cmp	r4, #133
 9433 526c 8A00000A 		beq	.L865
 9434 5270 CC02003A 		bcc	.L866
 9435 5274 860054E3 		cmp	r4, #134
 9436 5278 BC02000A 		beq	.L867
 9437 527c 870054E3 		cmp	r4, #135
 9438 5280 B102001A 		bne	.L859
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9439              		.loc 1 1789 0
 9440 5284 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9441              		.loc 1 1790 0
 9442 5288 8BC7DAE5 		ldrb	ip, [r10, #1931]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 9443              		.loc 1 1814 0
 9444 528c 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9445              		.loc 1 1791 0
 9446 5290 8C27DAE5 		ldrb	r2, [r10, #1932]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9447              		.loc 1 1789 0
 9448 5294 4A03000A 		beq	.L938
 9449              	.L874:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9450              		.loc 1 1796 0
 9451 5298 0030A0E3 		mov	r3, #0
 9452              	.LVL1088:
1814:../uvc.c      **** 		 	 if(Len == 2){
 9453              		.loc 1 1814 0
 9454 529c AC111FE5 		ldr	r1, .L982+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9455              		.loc 1 1795 0
 9456 52a0 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9457              		.loc 1 1797 0
 9458 52a4 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9459              		.loc 1 1796 0
 9460 52a8 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9461              		.loc 1 1798 0
 9462 52ac 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 9463              		.loc 1 1820 0
 9464 52b0 28308DE5 		str	r3, [sp, #40]
1814:../uvc.c      **** 		 	 if(Len == 2){
 9465              		.loc 1 1814 0
 9466 52b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9467              	.LVL1089:
1820:../uvc.c      **** 		 	 }
 9468              		.loc 1 1820 0
 9469 52b8 00C0A0E3 		mov	ip, #0
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 9470              		.loc 1 1819 0
 9471 52bc 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9472              	.LVL1090:
1820:../uvc.c      **** 		 	 }
 9473              		.loc 1 1820 0
 9474 52c0 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 9475              	.LVL1091:
 9476 52c4 7E0000EA 		b	.L869
 9477              	.LVL1092:
 9478              	.L955:
 9479 52c8 0250A0E1 		mov	r5, r2
 9480              	.LBE179:
 9481              	.LBE178:
 9482              	.LBE224:
 9483              	.LBE399:
4871:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9484              		.loc 1 4871 0
 9485 52cc 0C00A0E1 		mov	r0, ip
 9486              	.LVL1093:
 9487 52d0 00121FE5 		ldr	r1, .L982+76
 9488 52d4 FEFFFFEB 		bl	CyU3PDebugPrint
 9489              	.LVL1094:
4872:../uvc.c      **** 					}
 9490              		.loc 1 4872 0
 9491 52d8 0500A0E1 		mov	r0, r5
 9492 52dc FEFFFFEB 		bl	CyFxAppErrorHandler
 9493              	.LVL1095:
 9494              	.L660:
 9495              	.LBB400:
 9496              	.LBB382:
 9497              	.LBB375:
 9498              	.LBB371:
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9499              		.loc 1 1776 0
 9500 52e0 5125DAE5 		ldrb	r2, [r10, #1361]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9501              		.loc 1 1782 0
 9502 52e4 F4111FE5 		ldr	r1, .L982+108
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9503              		.loc 1 1777 0
 9504 52e8 0030A0E3 		mov	r3, #0
 9505              	.LVL1096:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9506              		.loc 1 1782 0
 9507 52ec 0100A0E3 		mov	r0, #1
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9508              		.loc 1 1776 0
 9509 52f0 2820C7E5 		strb	r2, [r7, #40]
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9510              		.loc 1 1777 0
 9511 52f4 2930C7E5 		strb	r3, [r7, #41]
1778:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9512              		.loc 1 1778 0
 9513 52f8 2A30C7E5 		strb	r3, [r7, #42]
1779:../uvc.c      **** 		 	 }
 9514              		.loc 1 1779 0
 9515 52fc 2B30C7E5 		strb	r3, [r7, #43]
 9516              	.LVL1097:
 9517              	.L923:
1744:../uvc.c      **** 				  }else{
 9518              		.loc 1 1744 0
 9519 5300 0040A0E3 		mov	r4, #0
 9520 5304 24408DE5 		str	r4, [sp, #36]
1741:../uvc.c      **** 				  if(Len == 2){
 9521              		.loc 1 1741 0
 9522 5308 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9523              	.LVL1098:
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9524              		.loc 1 1743 0
 9525 530c 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9526              	.LVL1099:
1744:../uvc.c      **** 				  }else{
 9527              		.loc 1 1744 0
 9528 5310 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 9529              	.LVL1100:
 9530 5314 24C09DE5 		ldr	ip, [sp, #36]
 9531 5318 99FEFFEA 		b	.L662
 9532              	.LVL1101:
 9533              	.L656:
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9534              		.loc 1 1693 0
 9535 531c 020053E3 		cmp	r3, #2
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9536              		.loc 1 1694 0
 9537 5320 4BC5DAE5 		ldrb	ip, [r10, #1355]	@ zero_extendqisi2
 9538              	.LVL1102:
1705:../uvc.c      **** 		 	 if(Len == 2){
 9539              		.loc 1 1705 0
 9540 5324 0300A0E1 		mov	r0, r3
 9541              	.LVL1103:
1695:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9542              		.loc 1 1695 0
 9543 5328 4C25DAE5 		ldrb	r2, [r10, #1356]	@ zero_extendqisi2
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9544              		.loc 1 1693 0
 9545 532c 7001000A 		beq	.L922
 9546              	.LVL1104:
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9547              		.loc 1 1701 0
 9548 5330 0030A0E3 		mov	r3, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 9549              		.loc 1 1705 0
 9550 5334 44121FE5 		ldr	r1, .L982+108
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9551              		.loc 1 1698 0
 9552 5338 28C0C7E5 		strb	ip, [r7, #40]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9553              		.loc 1 1700 0
 9554 533c 2920C7E5 		strb	r2, [r7, #41]
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9555              		.loc 1 1701 0
 9556 5340 2B30C7E5 		strb	r3, [r7, #43]
1711:../uvc.c      **** 			  }
 9557              		.loc 1 1711 0
 9558 5344 24308DE5 		str	r3, [sp, #36]
 9559 5348 0040A0E3 		mov	r4, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 9560              		.loc 1 1705 0
 9561 534c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9562              	.LVL1105:
1710:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
 9563              		.loc 1 1710 0
 9564 5350 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9565              	.LVL1106:
1711:../uvc.c      **** 			  }
 9566              		.loc 1 1711 0
 9567 5354 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 9568              	.LVL1107:
 9569 5358 24C09DE5 		ldr	ip, [sp, #36]
 9570 535c 88FEFFEA 		b	.L662
 9571              	.LVL1108:
 9572              	.L760:
 9573              	.LBE371:
 9574              	.LBE375:
 9575              	.LBE382:
 9576              	.LBE400:
 9577              	.LBB401:
 9578              	.LBB363:
 9579              	.LBB313:
 9580              	.LBB289:
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9581              		.loc 1 2350 0
 9582 5360 A136DAE5 		ldrb	r3, [r10, #1697]	@ zero_extendqisi2
 9583              	.LVL1109:
 9584              	.L941:
 9585              	.LBE289:
 9586              	.LBE313:
 9587              	.LBB314:
 9588              	.LBB253:
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9589              		.loc 1 2351 0
 9590 5364 0100A0E3 		mov	r0, #1
 9591 5368 78121FE5 		ldr	r1, .L982+108
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9592              		.loc 1 2350 0
 9593 536c 2830C7E5 		strb	r3, [r7, #40]
2353:../uvc.c      **** 			  break;
 9594              		.loc 1 2353 0
 9595 5370 0150A0E3 		mov	r5, #1
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9596              		.loc 1 2351 0
 9597 5374 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9598              	.LVL1110:
2352:../uvc.c      **** 			  Len = 1;
 9599              		.loc 1 2352 0
 9600 5378 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9601              	.LVL1111:
 9602 537c 68FFFFEA 		b	.L773
 9603              	.LVL1112:
 9604              	.L743:
 9605              	.LBE253:
 9606              	.LBE314:
 9607              	.LBB315:
 9608              	.LBB297:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9609              		.loc 1 2323 0
 9610 5380 98021FE5 		ldr	r0, .L982+100
 9611 5384 8316D0E5 		ldrb	r1, [r0, #1667]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9612              		.loc 1 2324 0
 9613 5388 8426D0E5 		ldrb	r2, [r0, #1668]	@ zero_extendqisi2
 9614 538c CCFDFFEA 		b	.L930
 9615              	.LVL1113:
 9616              	.L771:
 9617              	.LBE297:
 9618              	.LBE315:
 9619              	.LBB316:
 9620              	.LBB254:
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9621              		.loc 1 2350 0
 9622 5390 B936DAE5 		ldrb	r3, [r10, #1721]	@ zero_extendqisi2
 9623 5394 F2FFFFEA 		b	.L941
 9624              	.LVL1114:
 9625              	.L714:
 9626              	.LBE254:
 9627              	.LBE316:
 9628              	.LBB317:
 9629              	.LBB234:
 9630 5398 4136DAE5 		ldrb	r3, [r10, #1601]	@ zero_extendqisi2
 9631 539c F0FFFFEA 		b	.L941
 9632              	.LVL1115:
 9633              	.L767:
 9634              	.LBE234:
 9635              	.LBE317:
 9636              	.LBB318:
 9637              	.LBB255:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9638              		.loc 1 2323 0
 9639 53a0 B8E21FE5 		ldr	lr, .L982+100
 9640 53a4 B316DEE5 		ldrb	r1, [lr, #1715]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9641              		.loc 1 2324 0
 9642 53a8 B426DEE5 		ldrb	r2, [lr, #1716]	@ zero_extendqisi2
 9643 53ac 67FDFFEA 		b	.L932
 9644              	.LVL1116:
 9645              	.L688:
 9646              	.LBE255:
 9647              	.LBE318:
 9648              	.LBB319:
 9649              	.LBB263:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9650              		.loc 1 2323 0
 9651 53b0 C8E21FE5 		ldr	lr, .L982+100
 9652 53b4 DB15DEE5 		ldrb	r1, [lr, #1499]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9653              		.loc 1 2324 0
 9654 53b8 DC25DEE5 		ldrb	r2, [lr, #1500]	@ zero_extendqisi2
 9655 53bc 63FDFFEA 		b	.L932
 9656              	.LVL1117:
 9657              	.L732:
 9658              	.LBE263:
 9659              	.LBE319:
 9660              	.LBB320:
 9661              	.LBB281:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9662              		.loc 1 2323 0
 9663 53c0 D8E21FE5 		ldr	lr, .L982+100
 9664 53c4 6B16DEE5 		ldrb	r1, [lr, #1643]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9665              		.loc 1 2324 0
 9666 53c8 6C26DEE5 		ldrb	r2, [lr, #1644]	@ zero_extendqisi2
 9667 53cc 5FFDFFEA 		b	.L932
 9668              	.LVL1118:
 9669              	.L699:
 9670              	.LBE281:
 9671              	.LBE320:
 9672              	.LBB321:
 9673              	.LBB271:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9674              		.loc 1 2323 0
 9675 53d0 E8E21FE5 		ldr	lr, .L982+100
 9676 53d4 0B16DEE5 		ldrb	r1, [lr, #1547]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9677              		.loc 1 2324 0
 9678 53d8 0C26DEE5 		ldrb	r2, [lr, #1548]	@ zero_extendqisi2
 9679 53dc 5BFDFFEA 		b	.L932
 9680              	.LVL1119:
 9681              	.L756:
 9682              	.LBE271:
 9683              	.LBE321:
 9684              	.LBB322:
 9685              	.LBB290:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9686              		.loc 1 2323 0
 9687 53e0 9B16DAE5 		ldrb	r1, [r10, #1691]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9688              		.loc 1 2324 0
 9689 53e4 9C26DAE5 		ldrb	r2, [r10, #1692]	@ zero_extendqisi2
 9690 53e8 58FDFFEA 		b	.L932
 9691              	.LVL1120:
 9692              	.L721:
 9693              	.LBE290:
 9694              	.LBE322:
 9695              	.LBB323:
 9696              	.LBB242:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9697              		.loc 1 2323 0
 9698 53ec 04E31FE5 		ldr	lr, .L982+100
 9699 53f0 5316DEE5 		ldrb	r1, [lr, #1619]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9700              		.loc 1 2324 0
 9701 53f4 5426DEE5 		ldrb	r2, [lr, #1620]	@ zero_extendqisi2
 9702 53f8 54FDFFEA 		b	.L932
 9703              	.LVL1121:
 9704              	.L710:
 9705              	.LBE242:
 9706              	.LBE323:
 9707              	.LBB324:
 9708              	.LBB235:
2323:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9709              		.loc 1 2323 0
 9710 53fc 3B16DAE5 		ldrb	r1, [r10, #1595]	@ zero_extendqisi2
2324:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9711              		.loc 1 2324 0
 9712 5400 3C26DAE5 		ldrb	r2, [r10, #1596]	@ zero_extendqisi2
 9713 5404 51FDFFEA 		b	.L932
 9714              	.LVL1122:
 9715              	.L725:
 9716              	.LBE235:
 9717              	.LBE324:
 9718              	.LBB325:
 9719              	.LBB243:
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9720              		.loc 1 2350 0
 9721 5408 20C31FE5 		ldr	ip, .L982+100
 9722 540c 5936DCE5 		ldrb	r3, [ip, #1625]	@ zero_extendqisi2
 9723 5410 D3FFFFEA 		b	.L941
 9724              	.LVL1123:
 9725              	.L747:
 9726              	.LBE243:
 9727              	.LBE325:
 9728              	.LBB326:
 9729              	.LBB298:
 9730 5414 2CC31FE5 		ldr	ip, .L982+100
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9731              		.loc 1 2351 0
 9732 5418 0100A0E3 		mov	r0, #1
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9733              		.loc 1 2350 0
 9734 541c 8936DCE5 		ldrb	r3, [ip, #1673]	@ zero_extendqisi2
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9735              		.loc 1 2351 0
 9736 5420 30131FE5 		ldr	r1, .L982+108
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9737              		.loc 1 2350 0
 9738 5424 2830C7E5 		strb	r3, [r7, #40]
2351:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9739              		.loc 1 2351 0
 9740 5428 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9741              	.LVL1124:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9742              		.loc 1 2288 0
 9743 542c FF20A0E3 		mov	r2, #255
 9744 5430 0230A0E1 		mov	r3, r2
2352:../uvc.c      **** 			  Len = 1;
 9745              		.loc 1 2352 0
 9746 5434 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9747              	.LVL1125:
2353:../uvc.c      **** 			  break;
 9748              		.loc 1 2353 0
 9749 5438 0150A0E3 		mov	r5, #1
 9750 543c ABFDFFEA 		b	.L749
 9751              	.LVL1126:
 9752              	.L736:
 9753              	.LBE298:
 9754              	.LBE326:
 9755              	.LBB327:
 9756              	.LBB282:
2350:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9757              		.loc 1 2350 0
 9758 5440 7136DAE5 		ldrb	r3, [r10, #1649]	@ zero_extendqisi2
 9759 5444 C6FFFFEA 		b	.L941
 9760              	.LVL1127:
 9761              	.L692:
 9762              	.LBE282:
 9763              	.LBE327:
 9764              	.LBB328:
 9765              	.LBB264:
 9766 5448 E135DAE5 		ldrb	r3, [r10, #1505]	@ zero_extendqisi2
 9767 544c C4FFFFEA 		b	.L941
 9768              	.LVL1128:
 9769              	.L703:
 9770              	.LBE264:
 9771              	.LBE328:
 9772              	.LBB329:
 9773              	.LBB272:
 9774 5450 68C31FE5 		ldr	ip, .L982+100
 9775 5454 1136DCE5 		ldrb	r3, [ip, #1553]	@ zero_extendqisi2
 9776 5458 C1FFFFEA 		b	.L941
 9777              	.LVL1129:
 9778              	.L817:
 9779              	.LBE272:
 9780              	.LBE329:
 9781              	.LBE363:
 9782              	.LBE401:
 9783              	.LBB402:
 9784              	.LBB225:
 9785              	.LBB191:
 9786              	.LBB170:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9787              		.loc 1 1372 0
 9788 545c 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9789              		.loc 1 1373 0
 9790 5460 0200A0E3 		mov	r0, #2
 9791 5464 74131FE5 		ldr	r1, .L982+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9792              		.loc 1 1371 0
 9793 5468 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9794              		.loc 1 1372 0
 9795 546c 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9796              		.loc 1 1374 0
 9797 5470 0240A0E1 		mov	r4, r2
 9798 5474 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9799              		.loc 1 1373 0
 9800 5478 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9801              	.LVL1130:
1374:../uvc.c      **** 			  break;
 9802              		.loc 1 1374 0
 9803 547c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9804              	.LVL1131:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9805              		.loc 1 1355 0
 9806 5480 FF50A0E3 		mov	r5, #255
 9807              	.LVL1132:
 9808              	.L821:
2268:../uvc.c      **** }
 9809              		.loc 1 2268 0
 9810 5484 24E09DE5 		ldr	lr, [sp, #36]
 9811 5488 04C08DE5 		str	ip, [sp, #4]
 9812 548c 00E08DE5 		str	lr, [sp]
 9813 5490 08508DE5 		str	r5, [sp, #8]
 9814 5494 28209DE5 		ldr	r2, [sp, #40]
 9815 5498 3CFEFFEA 		b	.L939
 9816              	.LVL1133:
 9817              	.L865:
 9818              	.LBE170:
 9819              	.LBE191:
 9820              	.LBB192:
 9821              	.LBB180:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9822              		.loc 1 1372 0
 9823 549c 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9824              		.loc 1 1373 0
 9825 54a0 0200A0E3 		mov	r0, #2
 9826 54a4 B4131FE5 		ldr	r1, .L982+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9827              		.loc 1 1371 0
 9828 54a8 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9829              		.loc 1 1372 0
 9830 54ac 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9831              		.loc 1 1374 0
 9832 54b0 28208DE5 		str	r2, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9833              		.loc 1 1373 0
 9834 54b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9835              	.LVL1134:
1374:../uvc.c      **** 			  break;
 9836              		.loc 1 1374 0
 9837 54b8 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9838              	.LVL1135:
 9839 54bc 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9840              		.loc 1 1355 0
 9841 54c0 FF40A0E3 		mov	r4, #255
 9842              	.LVL1136:
 9843              	.L869:
2268:../uvc.c      **** }
 9844              		.loc 1 2268 0
 9845 54c4 28E09DE5 		ldr	lr, [sp, #40]
 9846 54c8 0C30A0E1 		mov	r3, ip
 9847 54cc 00E08DE5 		str	lr, [sp]
 9848 54d0 08408DE5 		str	r4, [sp, #8]
 9849 54d4 2C209DE5 		ldr	r2, [sp, #44]
 9850 54d8 00141FE5 		ldr	r1, .L982+84
 9851 54dc 04508DE5 		str	r5, [sp, #4]
 9852 54e0 0400A0E3 		mov	r0, #4
 9853 54e4 FEFFFFEB 		bl	CyU3PDebugPrint
 9854              	.LVL1137:
 9855              	.LBE180:
 9856              	.LBE192:
4316:../uvc.c      ****     		break;
 9857              		.loc 1 4316 0
 9858 54e8 24409DE5 		ldr	r4, [sp, #36]
 9859              	.LVL1138:
 9860 54ec 0400A0E3 		mov	r0, #4
 9861 54f0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9862 54f4 20141FE5 		ldr	r1, .L982+80
 9863 54f8 B020D8E1 		ldrh	r2, [r8]
 9864 54fc FEFFFFEB 		bl	CyU3PDebugPrint
 9865              	.LVL1139:
 9866 5500 44309DE5 		ldr	r3, [sp, #68]
 9867 5504 20FBFFEA 		b	.L631
 9868              	.LVL1140:
 9869              	.L841:
 9870              	.LBB193:
 9871              	.LBB158:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9872              		.loc 1 1372 0
 9873 5508 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9874              		.loc 1 1373 0
 9875 550c 0200A0E3 		mov	r0, #2
 9876 5510 20141FE5 		ldr	r1, .L982+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9877              		.loc 1 1371 0
 9878 5514 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9879              		.loc 1 1372 0
 9880 5518 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9881              		.loc 1 1374 0
 9882 551c 28208DE5 		str	r2, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9883              		.loc 1 1373 0
 9884 5520 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9885              	.LVL1141:
1374:../uvc.c      **** 			  break;
 9886              		.loc 1 1374 0
 9887 5524 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9888              	.LVL1142:
 9889 5528 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9890              		.loc 1 1355 0
 9891 552c FF40A0E3 		mov	r4, #255
 9892              	.LVL1143:
 9893              	.L845:
2268:../uvc.c      **** }
 9894              		.loc 1 2268 0
 9895 5530 28E09DE5 		ldr	lr, [sp, #40]
 9896 5534 0C30A0E1 		mov	r3, ip
 9897 5538 00E08DE5 		str	lr, [sp]
 9898 553c 08408DE5 		str	r4, [sp, #8]
 9899 5540 2C209DE5 		ldr	r2, [sp, #44]
 9900 5544 6C141FE5 		ldr	r1, .L982+84
 9901 5548 04508DE5 		str	r5, [sp, #4]
 9902 554c 0400A0E3 		mov	r0, #4
 9903 5550 FEFFFFEB 		bl	CyU3PDebugPrint
 9904              	.LVL1144:
 9905              	.LBE158:
 9906              	.LBE193:
4311:../uvc.c      ****    		break;
 9907              		.loc 1 4311 0
 9908 5554 24409DE5 		ldr	r4, [sp, #36]
 9909              	.LVL1145:
 9910 5558 0400A0E3 		mov	r0, #4
 9911 555c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9912 5560 84141FE5 		ldr	r1, .L982+88
 9913 5564 B020D8E1 		ldrh	r2, [r8]
 9914 5568 FEFFFFEB 		bl	CyU3PDebugPrint
 9915              	.LVL1146:
 9916 556c 44309DE5 		ldr	r3, [sp, #68]
 9917 5570 05FBFFEA 		b	.L631
 9918              	.LVL1147:
 9919              	.L969:
 9920              	.LBB194:
 9921              	.LBB181:
1367:../uvc.c      **** 		 {
 9922              		.loc 1 1367 0
 9923 5574 81005CE3 		cmp	ip, #129
 9924 5578 3A02000A 		beq	.L862
 9925 557c 2D02008A 		bhi	.L863
 9926 5580 01005CE3 		cmp	ip, #1
 9927 5584 F001001A 		bne	.L859
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9928              		.loc 1 1824 0
 9929 5588 2000A0E3 		mov	r0, #32
 9930 558c 9C141FE5 		ldr	r1, .L982+108
 9931 5590 42208DE2 		add	r2, sp, #66
 9932 5594 20308DE5 		str	r3, [sp, #32]
 9933 5598 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9934              	.LVL1148:
1826:../uvc.c      **** 			   {
 9935              		.loc 1 1826 0
 9936 559c 20309DE5 		ldr	r3, [sp, #32]
 9937 55a0 000050E3 		cmp	r0, #0
 9938 55a4 38008DE5 		str	r0, [sp, #56]
 9939 55a8 9B02001A 		bne	.L875
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9940              		.loc 1 1828 0
 9941 55ac 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 9942              		.loc 1 1829 0
 9943 55b0 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9944              		.loc 1 1828 0
 9945 55b4 AE02000A 		beq	.L970
 9946              	.LVL1149:
1833:../uvc.c      **** 				 }
 9947              		.loc 1 1833 0
 9948 55b8 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9949              		.loc 1 1836 0
 9950 55bc 30009DE5 		ldr	r0, [sp, #48]
 9951              	.LVL1150:
 9952 55c0 3C308DE5 		str	r3, [sp, #60]
 9953 55c4 08308DE5 		str	r3, [sp, #8]
 9954 55c8 04008DE5 		str	r0, [sp, #4]
 9955 55cc 0CC08DE5 		str	ip, [sp, #12]
 9956 55d0 D8141FE5 		ldr	r1, .L982+116
 9957 55d4 00408DE5 		str	r4, [sp]
 9958 55d8 10E08DE5 		str	lr, [sp, #16]
 9959 55dc 0400A0E3 		mov	r0, #4
 9960 55e0 2B20A0E3 		mov	r2, #43
 9961 55e4 34309DE5 		ldr	r3, [sp, #52]
 9962 55e8 1CC08DE5 		str	ip, [sp, #28]
1833:../uvc.c      **** 				 }
 9963              		.loc 1 1833 0
 9964 55ec 28E08DE5 		str	lr, [sp, #40]
 9965              	.LVL1151:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9966              		.loc 1 1836 0
 9967 55f0 FEFFFFEB 		bl	CyU3PDebugPrint
 9968              	.LVL1152:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 9969              		.loc 1 2047 0
 9970 55f4 3C109DE5 		ldr	r1, [sp, #60]
 9971 55f8 1CC09DE5 		ldr	ip, [sp, #28]
 9972 55fc 040051E3 		cmp	r1, #4
 9973 5600 6003000A 		beq	.L971
 9974              	.LVL1153:
 9975              	.L880:
2064:../uvc.c      **** 				 	 			 break;
 9976              		.loc 1 2064 0
 9977 5604 8E27DAE5 		ldrb	r2, [r10, #1934]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9978              		.loc 1 2063 0
 9979 5608 3C409DE5 		ldr	r4, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 9980              		.loc 1 2064 0
 9981 560c 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9982              		.loc 1 2063 0
 9983 5610 0400A0E3 		mov	r0, #4
 9984 5614 1C008DE8 		stmia	sp, {r2, r3, r4}
 9985 5618 38151FE5 		ldr	r1, .L982+92
 9986 561c 0C20A0E1 		mov	r2, ip
 9987 5620 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9988              		.loc 1 1355 0
 9989 5624 FF40A0E3 		mov	r4, #255
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9990              		.loc 1 2063 0
 9991 5628 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9992              		.loc 1 1355 0
 9993 562c 0450A0E1 		mov	r5, r4
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9994              		.loc 1 2063 0
 9995 5630 FEFFFFEB 		bl	CyU3PDebugPrint
 9996              	.LVL1154:
 9997 5634 1CC09DE5 		ldr	ip, [sp, #28]
 9998 5638 A1FFFFEA 		b	.L869
 9999              	.LVL1155:
 10000              	.L968:
 10001              	.LBE181:
 10002              	.LBE194:
 10003              	.LBB195:
 10004              	.LBB171:
1367:../uvc.c      **** 		 {
 10005              		.loc 1 1367 0
 10006 563c 810054E3 		cmp	r4, #129
 10007 5640 9E01000A 		beq	.L814
 10008 5644 9401008A 		bhi	.L815
 10009 5648 010054E3 		cmp	r4, #1
 10010 564c B501001A 		bne	.L811
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10011              		.loc 1 1824 0
 10012 5650 2000A0E3 		mov	r0, #32
 10013 5654 64151FE5 		ldr	r1, .L982+108
 10014 5658 42208DE2 		add	r2, sp, #66
 10015 565c 20308DE5 		str	r3, [sp, #32]
 10016 5660 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10017              	.LVL1156:
1826:../uvc.c      **** 			   {
 10018              		.loc 1 1826 0
 10019 5664 20309DE5 		ldr	r3, [sp, #32]
 10020 5668 000050E3 		cmp	r0, #0
 10021 566c 38008DE5 		str	r0, [sp, #56]
 10022 5670 6002001A 		bne	.L827
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10023              		.loc 1 1828 0
 10024 5674 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 10025              		.loc 1 1829 0
 10026 5678 2840DBE5 		ldrb	r4, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10027              		.loc 1 1828 0
 10028 567c D402000A 		beq	.L972
 10029              	.LVL1157:
1833:../uvc.c      **** 				 }
 10030              		.loc 1 1833 0
 10031 5680 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10032              		.loc 1 1836 0
 10033 5684 3C308DE5 		str	r3, [sp, #60]
1833:../uvc.c      **** 				 }
 10034              		.loc 1 1833 0
 10035 5688 24C08DE5 		str	ip, [sp, #36]
 10036              	.LVL1158:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10037              		.loc 1 1836 0
 10038 568c 34C09DE5 		ldr	ip, [sp, #52]
 10039 5690 08308DE5 		str	r3, [sp, #8]
 10040 5694 00C08DE5 		str	ip, [sp]
 10041 5698 2CC09DE5 		ldr	ip, [sp, #44]
 10042 569c 0C408DE5 		str	r4, [sp, #12]
 10043 56a0 04C08DE5 		str	ip, [sp, #4]
 10044 56a4 24C09DE5 		ldr	ip, [sp, #36]
 10045 56a8 0400A0E3 		mov	r0, #4
 10046              	.LVL1159:
 10047 56ac 10C08DE5 		str	ip, [sp, #16]
 10048 56b0 B8151FE5 		ldr	r1, .L982+116
 10049 56b4 1620A0E3 		mov	r2, #22
 10050 56b8 30309DE5 		ldr	r3, [sp, #48]
 10051 56bc FEFFFFEB 		bl	CyU3PDebugPrint
 10052              	.LVL1160:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10053              		.loc 1 2047 0
 10054 56c0 3CC09DE5 		ldr	ip, [sp, #60]
 10055 56c4 04005CE3 		cmp	ip, #4
 10056 56c8 EA02000A 		beq	.L973
 10057              	.LVL1161:
 10058              	.L832:
2064:../uvc.c      **** 				 	 			 break;
 10059              		.loc 1 2064 0
 10060 56cc 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10061              		.loc 1 2063 0
 10062 56d0 3CC09DE5 		ldr	ip, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 10063              		.loc 1 2064 0
 10064 56d4 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10065              		.loc 1 2063 0
 10066 56d8 0400A0E3 		mov	r0, #4
 10067 56dc 0C108DE8 		stmia	sp, {r2, r3, ip}
 10068 56e0 00161FE5 		ldr	r1, .L982+92
 10069 56e4 0420A0E1 		mov	r2, r4
 10070 56e8 24309DE5 		ldr	r3, [sp, #36]
 10071 56ec FEFFFFEB 		bl	CyU3PDebugPrint
 10072              	.LVL1162:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10073              		.loc 1 1355 0
 10074 56f0 FF50A0E3 		mov	r5, #255
 10075 56f4 05C0A0E1 		mov	ip, r5
 10076 56f8 61FFFFEA 		b	.L821
 10077              	.LVL1163:
 10078              	.L960:
 10079              	.LBE171:
 10080              	.LBE195:
 10081              	.LBB196:
 10082              	.LBB159:
1367:../uvc.c      **** 		 {
 10083              		.loc 1 1367 0
 10084 56fc 81005CE3 		cmp	ip, #129
 10085 5700 1702000A 		beq	.L838
 10086 5704 0D02008A 		bhi	.L839
 10087 5708 01005CE3 		cmp	ip, #1
 10088 570c C001001A 		bne	.L835
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10089              		.loc 1 1824 0
 10090 5710 2000A0E3 		mov	r0, #32
 10091 5714 24161FE5 		ldr	r1, .L982+108
 10092 5718 42208DE2 		add	r2, sp, #66
 10093 571c 20308DE5 		str	r3, [sp, #32]
 10094 5720 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10095              	.LVL1164:
1826:../uvc.c      **** 			   {
 10096              		.loc 1 1826 0
 10097 5724 20309DE5 		ldr	r3, [sp, #32]
 10098 5728 000050E3 		cmp	r0, #0
 10099 572c 38008DE5 		str	r0, [sp, #56]
 10100 5730 2702001A 		bne	.L851
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10101              		.loc 1 1828 0
 10102 5734 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 10103              		.loc 1 1829 0
 10104 5738 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10105              		.loc 1 1828 0
 10106 573c 7802000A 		beq	.L974
 10107              	.LVL1165:
1833:../uvc.c      **** 				 }
 10108              		.loc 1 1833 0
 10109 5740 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10110              		.loc 1 1836 0
 10111 5744 30009DE5 		ldr	r0, [sp, #48]
 10112              	.LVL1166:
 10113 5748 3C308DE5 		str	r3, [sp, #60]
 10114 574c 08308DE5 		str	r3, [sp, #8]
 10115 5750 04008DE5 		str	r0, [sp, #4]
 10116 5754 0CC08DE5 		str	ip, [sp, #12]
 10117 5758 60161FE5 		ldr	r1, .L982+116
 10118 575c 00408DE5 		str	r4, [sp]
 10119 5760 10E08DE5 		str	lr, [sp, #16]
 10120 5764 0400A0E3 		mov	r0, #4
 10121 5768 2A20A0E3 		mov	r2, #42
 10122 576c 34309DE5 		ldr	r3, [sp, #52]
 10123 5770 1CC08DE5 		str	ip, [sp, #28]
1833:../uvc.c      **** 				 }
 10124              		.loc 1 1833 0
 10125 5774 28E08DE5 		str	lr, [sp, #40]
 10126              	.LVL1167:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10127              		.loc 1 1836 0
 10128 5778 FEFFFFEB 		bl	CyU3PDebugPrint
 10129              	.LVL1168:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10130              		.loc 1 2047 0
 10131 577c 3C109DE5 		ldr	r1, [sp, #60]
 10132 5780 1CC09DE5 		ldr	ip, [sp, #28]
 10133 5784 040051E3 		cmp	r1, #4
 10134 5788 2B03000A 		beq	.L975
 10135              	.LVL1169:
 10136              	.L856:
2064:../uvc.c      **** 				 	 			 break;
 10137              		.loc 1 2064 0
 10138 578c 7A27DAE5 		ldrb	r2, [r10, #1914]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10139              		.loc 1 2063 0
 10140 5790 3C409DE5 		ldr	r4, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 10141              		.loc 1 2064 0
 10142 5794 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10143              		.loc 1 2063 0
 10144 5798 0400A0E3 		mov	r0, #4
 10145 579c 1C008DE8 		stmia	sp, {r2, r3, r4}
 10146 57a0 C0161FE5 		ldr	r1, .L982+92
 10147 57a4 0C20A0E1 		mov	r2, ip
 10148 57a8 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10149              		.loc 1 1355 0
 10150 57ac FF40A0E3 		mov	r4, #255
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10151              		.loc 1 2063 0
 10152 57b0 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10153              		.loc 1 1355 0
 10154 57b4 0450A0E1 		mov	r5, r4
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10155              		.loc 1 2063 0
 10156 57b8 FEFFFFEB 		bl	CyU3PDebugPrint
 10157              	.LVL1170:
 10158 57bc 1CC09DE5 		ldr	ip, [sp, #28]
 10159 57c0 5AFFFFEA 		b	.L845
 10160              	.LVL1171:
 10161              	.L655:
 10162              	.LBE159:
 10163              	.LBE196:
 10164              	.LBE225:
 10165              	.LBE402:
 10166              	.LBB403:
 10167              	.LBB383:
 10168              	.LBB376:
 10169              	.LBB372:
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10170              		.loc 1 1540 0
 10171 57c4 0C00A0E1 		mov	r0, ip
 10172 57c8 28109DE5 		ldr	r1, [sp, #40]
 10173 57cc 20308DE5 		str	r3, [sp, #32]
 10174 57d0 FEFFFFEB 		bl	SensorGetControl
 10175              	.LVL1172:
1672:../uvc.c      **** 
 10176              		.loc 1 1672 0
 10177 57d4 20309DE5 		ldr	r3, [sp, #32]
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10178              		.loc 1 1541 0
 10179 57d8 F0C61FE5 		ldr	ip, .L982+100
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10180              		.loc 1 1553 0
 10181 57dc 0020A0E3 		mov	r2, #0
1672:../uvc.c      **** 
 10182              		.loc 1 1672 0
 10183 57e0 F0161FE5 		ldr	r1, .L982+108
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10184              		.loc 1 1553 0
 10185 57e4 2920C7E5 		strb	r2, [r7, #41]
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10186              		.loc 1 1540 0
 10187 57e8 0040A0E1 		mov	r4, r0
 10188              	.LVL1173:
1672:../uvc.c      **** 
 10189              		.loc 1 1672 0
 10190 57ec 0300A0E1 		mov	r0, r3
 10191              	.LVL1174:
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10192              		.loc 1 1541 0
 10193 57f0 5545CCE5 		strb	r4, [ip, #1365]
 10194              	.LVL1175:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 10195              		.loc 1 1552 0
 10196 57f4 2840C7E5 		strb	r4, [r7, #40]
1672:../uvc.c      **** 
 10197              		.loc 1 1672 0
 10198 57f8 20308DE5 		str	r3, [sp, #32]
 10199 57fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10200              	.LVL1176:
1675:../uvc.c      **** //#endif
 10201              		.loc 1 1675 0
 10202 5800 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 10203 5804 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 10204 5808 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 10205 580c 20309DE5 		ldr	r3, [sp, #32]
 10206 5810 03008DE8 		stmia	sp, {r0, r1}
 10207 5814 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10208 5818 08308DE5 		str	r3, [sp, #8]
 10209 581c 0400A0E3 		mov	r0, #4
 10210 5820 0C30A0E1 		mov	r3, ip
 10211 5824 38171FE5 		ldr	r1, .L982+104
 10212 5828 FEFFFFEB 		bl	CyU3PDebugPrint
 10213              	.LVL1177:
 10214 582c 00C0A0E3 		mov	ip, #0
 10215 5830 24C08DE5 		str	ip, [sp, #36]
 10216 5834 0420A0E1 		mov	r2, r4
 10217 5838 FF30A0E3 		mov	r3, #255
 10218 583c 50FDFFEA 		b	.L662
 10219              	.LVL1178:
 10220              	.L659:
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10221              		.loc 1 1758 0
 10222 5840 4FC5DAE5 		ldrb	ip, [r10, #1359]	@ zero_extendqisi2
 10223              	.LVL1179:
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10224              		.loc 1 1763 0
 10225 5844 54171FE5 		ldr	r1, .L982+108
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10226              		.loc 1 1759 0
 10227 5848 5025DAE5 		ldrb	r2, [r10, #1360]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10228              		.loc 1 1763 0
 10229 584c 0300A0E1 		mov	r0, r3
 10230              	.LVL1180:
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10231              		.loc 1 1760 0
 10232 5850 0030A0E3 		mov	r3, #0
 10233              	.LVL1181:
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10234              		.loc 1 1758 0
 10235 5854 28C0C7E5 		strb	ip, [r7, #40]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10236              		.loc 1 1759 0
 10237 5858 2920C7E5 		strb	r2, [r7, #41]
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10238              		.loc 1 1760 0
 10239 585c 2A30C7E5 		strb	r3, [r7, #42]
1761:../uvc.c      **** 		 	 }
 10240              		.loc 1 1761 0
 10241 5860 2B30C7E5 		strb	r3, [r7, #43]
 10242              	.L924:
1817:../uvc.c      **** 		 	 }else{
 10243              		.loc 1 1817 0
 10244 5864 00C0A0E3 		mov	ip, #0
 10245 5868 24C08DE5 		str	ip, [sp, #36]
 10246 586c 0040A0E3 		mov	r4, #0
1814:../uvc.c      **** 		 	 if(Len == 2){
 10247              		.loc 1 1814 0
 10248 5870 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10249              	.LVL1182:
1816:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
 10250              		.loc 1 1816 0
 10251 5874 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10252              	.LVL1183:
1817:../uvc.c      **** 		 	 }else{
 10253              		.loc 1 1817 0
 10254 5878 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 10255              	.LVL1184:
 10256 587c 24C09DE5 		ldr	ip, [sp, #36]
 10257 5880 3FFDFFEA 		b	.L662
 10258              	.LVL1185:
 10259              	.L658:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10260              		.loc 1 1372 0
 10261 5884 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10262              		.loc 1 1373 0
 10263 5888 0200A0E3 		mov	r0, #2
 10264 588c 9C171FE5 		ldr	r1, .L982+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10265              		.loc 1 1371 0
 10266 5890 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10267              		.loc 1 1372 0
 10268 5894 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 10269              		.loc 1 1374 0
 10270 5898 0240A0E1 		mov	r4, r2
 10271 589c 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10272              		.loc 1 1373 0
 10273 58a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10274              	.LVL1186:
1374:../uvc.c      **** 			  break;
 10275              		.loc 1 1374 0
 10276 58a4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10277              	.LVL1187:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10278              		.loc 1 1355 0
 10279 58a8 FF30A0E3 		mov	r3, #255
 10280 58ac 24C09DE5 		ldr	ip, [sp, #36]
 10281 58b0 33FDFFEA 		b	.L662
 10282              	.LVL1188:
 10283              	.L652:
2265:../uvc.c      **** 			  break;
 10284              		.loc 1 2265 0
 10285 58b4 0000A0E3 		mov	r0, #0
 10286 58b8 0020A0E1 		mov	r2, r0
 10287 58bc 0110A0E3 		mov	r1, #1
 10288 58c0 FEFFFFEB 		bl	CyU3PUsbStall
 10289              	.LVL1189:
 10290 58c4 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10291              		.loc 1 1355 0
 10292 58c8 FF30A0E3 		mov	r3, #255
 10293 58cc 0320A0E1 		mov	r2, r3
2265:../uvc.c      **** 			  break;
 10294              		.loc 1 2265 0
 10295 58d0 24C08DE5 		str	ip, [sp, #36]
 10296 58d4 0C40A0E1 		mov	r4, ip
 10297 58d8 29FDFFEA 		b	.L662
 10298              	.LVL1190:
 10299              	.L653:
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10300              		.loc 1 1730 0
 10301 58dc F4E71FE5 		ldr	lr, .L982+100
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10302              		.loc 1 1729 0
 10303 58e0 020053E3 		cmp	r3, #2
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10304              		.loc 1 1730 0
 10305 58e4 4DC5DEE5 		ldrb	ip, [lr, #1357]	@ zero_extendqisi2
 10306              	.LVL1191:
1741:../uvc.c      **** 				  if(Len == 2){
 10307              		.loc 1 1741 0
 10308 58e8 0300A0E1 		mov	r0, r3
 10309              	.LVL1192:
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10310              		.loc 1 1731 0
 10311 58ec 4E25DEE5 		ldrb	r2, [lr, #1358]	@ zero_extendqisi2
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10312              		.loc 1 1729 0
 10313 58f0 61FAFF1A 		bne	.L665
 10314              	.LVL1193:
 10315              	.L922:
1741:../uvc.c      **** 				  if(Len == 2){
 10316              		.loc 1 1741 0
 10317 58f4 04181FE5 		ldr	r1, .L982+108
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10318              		.loc 1 1730 0
 10319 58f8 28C0C7E5 		strb	ip, [r7, #40]
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10320              		.loc 1 1731 0
 10321 58fc 2920C7E5 		strb	r2, [r7, #41]
 10322 5900 7EFEFFEA 		b	.L923
 10323              	.LVL1194:
 10324              	.L695:
 10325              	.LBE372:
 10326              	.LBE376:
 10327              	.LBE383:
 10328              	.LBE403:
 10329              	.LBB404:
 10330              	.LBB364:
 10331              	.LBB330:
 10332              	.LBB273:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10333              		.loc 1 2501 0
 10334 5904 0000A0E3 		mov	r0, #0
 10335 5908 0020A0E1 		mov	r2, r0
 10336 590c 0110A0E3 		mov	r1, #1
 10337 5910 FEFFFFEB 		bl	CyU3PUsbStall
 10338              	.LVL1195:
2502:../uvc.c      **** 			  break;
 10339              		.loc 1 2502 0
 10340 5914 24C09DE5 		ldr	ip, [sp, #36]
 10341 5918 0220A0E3 		mov	r2, #2
 10342 591c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10343 5920 0400A0E3 		mov	r0, #4
 10344 5924 40181FE5 		ldr	r1, .L982+96
 10345 5928 FEFFFFEB 		bl	CyU3PDebugPrint
 10346              	.LVL1196:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10347              		.loc 1 2288 0
 10348 592c FF20A0E3 		mov	r2, #255
 10349              	.LVL1197:
 10350 5930 FBFDFFEA 		b	.L773
 10351              	.LVL1198:
 10352              	.L742:
 10353              	.LBE273:
 10354              	.LBE330:
 10355              	.LBB331:
 10356              	.LBB299:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10357              		.loc 1 2308 0
 10358 5934 4CE81FE5 		ldr	lr, .L982+100
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10359              		.loc 1 2310 0
 10360 5938 0030A0E3 		mov	r3, #0
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10361              		.loc 1 2308 0
 10362 593c 8DC6DEE5 		ldrb	ip, [lr, #1677]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10363              		.loc 1 2309 0
 10364 5940 8E26DEE5 		ldrb	r2, [lr, #1678]	@ zero_extendqisi2
2316:../uvc.c      **** 
 10365              		.loc 1 2316 0
 10366 5944 0500A0E1 		mov	r0, r5
 10367 5948 58181FE5 		ldr	r1, .L982+108
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10368              		.loc 1 2308 0
 10369 594c 28C0C7E5 		strb	ip, [r7, #40]
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10370              		.loc 1 2309 0
 10371 5950 2920C7E5 		strb	r2, [r7, #41]
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10372              		.loc 1 2310 0
 10373 5954 2A30C7E5 		strb	r3, [r7, #42]
2311:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10374              		.loc 1 2311 0
 10375 5958 2B30C7E5 		strb	r3, [r7, #43]
 10376              	.LVL1199:
2316:../uvc.c      **** 
 10377              		.loc 1 2316 0
 10378 595c 1CC08DE5 		str	ip, [sp, #28]
 10379 5960 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10380              	.LVL1200:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10381              		.loc 1 2288 0
 10382 5964 FF20A0E3 		mov	r2, #255
 10383 5968 0230A0E1 		mov	r3, r2
 10384 596c 1CC09DE5 		ldr	ip, [sp, #28]
 10385 5970 5EFCFFEA 		b	.L749
 10386              	.LVL1201:
 10387              	.L731:
 10388              	.LBE299:
 10389              	.LBE331:
 10390              	.LBB332:
 10391              	.LBB283:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10392              		.loc 1 2308 0
 10393 5974 8CC81FE5 		ldr	ip, .L982+100
 10394 5978 7526DCE5 		ldrb	r2, [ip, #1653]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10395              		.loc 1 2309 0
 10396 597c 7616DCE5 		ldrb	r1, [ip, #1654]	@ zero_extendqisi2
 10397              	.LVL1202:
 10398              	.L940:
 10399              	.LBE283:
 10400              	.LBE332:
 10401              	.LBB333:
 10402              	.LBB256:
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10403              		.loc 1 2310 0
 10404 5980 0030A0E3 		mov	r3, #0
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10405              		.loc 1 2309 0
 10406 5984 2910C7E5 		strb	r1, [r7, #41]
2316:../uvc.c      **** 
 10407              		.loc 1 2316 0
 10408 5988 0500A0E1 		mov	r0, r5
 10409 598c 9C181FE5 		ldr	r1, .L982+108
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10410              		.loc 1 2308 0
 10411 5990 2820C7E5 		strb	r2, [r7, #40]
2316:../uvc.c      **** 
 10412              		.loc 1 2316 0
 10413 5994 20208DE5 		str	r2, [sp, #32]
2310:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10414              		.loc 1 2310 0
 10415 5998 2A30C7E5 		strb	r3, [r7, #42]
2311:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10416              		.loc 1 2311 0
 10417 599c 2B30C7E5 		strb	r3, [r7, #43]
 10418              	.LVL1203:
2316:../uvc.c      **** 
 10419              		.loc 1 2316 0
 10420 59a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10421              	.LVL1204:
 10422 59a4 20209DE5 		ldr	r2, [sp, #32]
 10423 59a8 DDFDFFEA 		b	.L773
 10424              	.LVL1205:
 10425              	.L698:
 10426              	.LBE256:
 10427              	.LBE333:
 10428              	.LBB334:
 10429              	.LBB274:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10430              		.loc 1 2308 0
 10431 59ac C4C81FE5 		ldr	ip, .L982+100
 10432 59b0 1526DCE5 		ldrb	r2, [ip, #1557]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10433              		.loc 1 2309 0
 10434 59b4 1616DCE5 		ldrb	r1, [ip, #1558]	@ zero_extendqisi2
 10435 59b8 F0FFFFEA 		b	.L940
 10436              	.LVL1206:
 10437              	.L739:
 10438              	.LBE274:
 10439              	.LBE334:
 10440              	.LBB335:
 10441              	.LBB300:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10442              		.loc 1 2501 0
 10443 59bc 0000A0E3 		mov	r0, #0
 10444 59c0 0020A0E1 		mov	r2, r0
 10445 59c4 0110A0E3 		mov	r1, #1
 10446 59c8 FEFFFFEB 		bl	CyU3PUsbStall
 10447              	.LVL1207:
2502:../uvc.c      **** 			  break;
 10448              		.loc 1 2502 0
 10449 59cc 24C09DE5 		ldr	ip, [sp, #36]
 10450 59d0 0720A0E3 		mov	r2, #7
 10451 59d4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10452 59d8 0400A0E3 		mov	r0, #4
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10453              		.loc 1 2288 0
 10454 59dc FFC0A0E3 		mov	ip, #255
2502:../uvc.c      **** 			  break;
 10455              		.loc 1 2502 0
 10456 59e0 FC181FE5 		ldr	r1, .L982+96
 10457 59e4 1CC08DE5 		str	ip, [sp, #28]
 10458 59e8 FEFFFFEB 		bl	CyU3PDebugPrint
 10459              	.LVL1208:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10460              		.loc 1 2288 0
 10461 59ec 1CC09DE5 		ldr	ip, [sp, #28]
 10462 59f0 0C20A0E1 		mov	r2, ip
 10463 59f4 0C30A0E1 		mov	r3, ip
 10464 59f8 3CFCFFEA 		b	.L749
 10465              	.LVL1209:
 10466              	.L766:
 10467              	.LBE300:
 10468              	.LBE335:
 10469              	.LBB336:
 10470              	.LBB257:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10471              		.loc 1 2308 0
 10472 59fc 14C91FE5 		ldr	ip, .L982+100
 10473 5a00 BD26DCE5 		ldrb	r2, [ip, #1725]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10474              		.loc 1 2309 0
 10475 5a04 BE16DCE5 		ldrb	r1, [ip, #1726]	@ zero_extendqisi2
 10476 5a08 DCFFFFEA 		b	.L940
 10477              	.LVL1210:
 10478              	.L691:
 10479              	.LBE257:
 10480              	.LBE336:
 10481              	.LBB337:
 10482              	.LBB265:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10483              		.loc 1 2341 0
 10484 5a0c 24291FE5 		ldr	r2, .L982+100
 10485 5a10 DF15D2E5 		ldrb	r1, [r2, #1503]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10486              		.loc 1 2342 0
 10487 5a14 E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 10488 5a18 CCFBFFEA 		b	.L932
 10489              	.LVL1211:
 10490              	.L707:
 10491              	.LBE265:
 10492              	.LBE337:
 10493              	.LBB338:
 10494              	.LBB236:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10495              		.loc 1 2332 0
 10496 5a1c 34E91FE5 		ldr	lr, .L982+100
 10497 5a20 3D16DEE5 		ldrb	r1, [lr, #1597]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10498              		.loc 1 2333 0
 10499 5a24 3E26DEE5 		ldrb	r2, [lr, #1598]	@ zero_extendqisi2
 10500 5a28 C8FBFFEA 		b	.L932
 10501              	.LVL1212:
 10502              	.L764:
 10503              	.LBE236:
 10504              	.LBE338:
 10505              	.LBB339:
 10506              	.LBB258:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10507              		.loc 1 2332 0
 10508 5a2c 44091FE5 		ldr	r0, .L982+100
 10509 5a30 B516D0E5 		ldrb	r1, [r0, #1717]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10510              		.loc 1 2333 0
 10511 5a34 B626D0E5 		ldrb	r2, [r0, #1718]	@ zero_extendqisi2
 10512 5a38 C4FBFFEA 		b	.L932
 10513              	.LVL1213:
 10514              	.L740:
 10515              	.LBE258:
 10516              	.LBE339:
 10517              	.LBB340:
 10518              	.LBB301:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10519              		.loc 1 2332 0
 10520 5a3c 54291FE5 		ldr	r2, .L982+100
 10521 5a40 8516D2E5 		ldrb	r1, [r2, #1669]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10522              		.loc 1 2333 0
 10523 5a44 8626D2E5 		ldrb	r2, [r2, #1670]	@ zero_extendqisi2
 10524 5a48 1DFCFFEA 		b	.L930
 10525              	.LVL1214:
 10526              	.L685:
 10527              	.LBE301:
 10528              	.LBE340:
 10529              	.LBB341:
 10530              	.LBB266:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10531              		.loc 1 2332 0
 10532 5a4c 64091FE5 		ldr	r0, .L982+100
 10533 5a50 DD15D0E5 		ldrb	r1, [r0, #1501]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10534              		.loc 1 2333 0
 10535 5a54 DE25D0E5 		ldrb	r2, [r0, #1502]	@ zero_extendqisi2
 10536 5a58 BCFBFFEA 		b	.L932
 10537              	.LVL1215:
 10538              	.L696:
 10539              	.LBE266:
 10540              	.LBE341:
 10541              	.LBB342:
 10542              	.LBB275:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10543              		.loc 1 2332 0
 10544 5a5c 74091FE5 		ldr	r0, .L982+100
 10545 5a60 0D16D0E5 		ldrb	r1, [r0, #1549]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10546              		.loc 1 2333 0
 10547 5a64 0E26D0E5 		ldrb	r2, [r0, #1550]	@ zero_extendqisi2
 10548 5a68 B8FBFFEA 		b	.L932
 10549              	.LVL1216:
 10550              	.L729:
 10551              	.LBE275:
 10552              	.LBE342:
 10553              	.LBB343:
 10554              	.LBB284:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10555              		.loc 1 2332 0
 10556 5a6c 84091FE5 		ldr	r0, .L982+100
 10557 5a70 6D16D0E5 		ldrb	r1, [r0, #1645]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10558              		.loc 1 2333 0
 10559 5a74 6E26D0E5 		ldrb	r2, [r0, #1646]	@ zero_extendqisi2
 10560 5a78 B4FBFFEA 		b	.L932
 10561              	.LVL1217:
 10562              	.L718:
 10563              	.LBE284:
 10564              	.LBE343:
 10565              	.LBB344:
 10566              	.LBB244:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10567              		.loc 1 2332 0
 10568 5a7c 94091FE5 		ldr	r0, .L982+100
 10569 5a80 5516D0E5 		ldrb	r1, [r0, #1621]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10570              		.loc 1 2333 0
 10571 5a84 5626D0E5 		ldrb	r2, [r0, #1622]	@ zero_extendqisi2
 10572 5a88 B0FBFFEA 		b	.L932
 10573              	.LVL1218:
 10574              	.L770:
 10575              	.LBE244:
 10576              	.LBE344:
 10577              	.LBB345:
 10578              	.LBB259:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10579              		.loc 1 2341 0
 10580 5a8c A4291FE5 		ldr	r2, .L982+100
 10581 5a90 B716D2E5 		ldrb	r1, [r2, #1719]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10582              		.loc 1 2342 0
 10583 5a94 B826D2E5 		ldrb	r2, [r2, #1720]	@ zero_extendqisi2
 10584 5a98 ACFBFFEA 		b	.L932
 10585              	.LVL1219:
 10586              	.L713:
 10587              	.LBE259:
 10588              	.LBE345:
 10589              	.LBB346:
 10590              	.LBB237:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10591              		.loc 1 2341 0
 10592 5a9c 3F16DAE5 		ldrb	r1, [r10, #1599]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10593              		.loc 1 2342 0
 10594 5aa0 4026DAE5 		ldrb	r2, [r10, #1600]	@ zero_extendqisi2
 10595 5aa4 A9FBFFEA 		b	.L932
 10596              	.LVL1220:
 10597              	.L753:
 10598              	.LBE237:
 10599              	.LBE346:
 10600              	.LBB347:
 10601              	.LBB291:
2332:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10602              		.loc 1 2332 0
 10603 5aa8 C0C91FE5 		ldr	ip, .L982+100
 10604 5aac 9D16DCE5 		ldrb	r1, [ip, #1693]	@ zero_extendqisi2
2333:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10605              		.loc 1 2333 0
 10606 5ab0 9E26DCE5 		ldrb	r2, [ip, #1694]	@ zero_extendqisi2
 10607 5ab4 A5FBFFEA 		b	.L932
 10608              	.LVL1221:
 10609              	.L687:
 10610              	.LBE291:
 10611              	.LBE347:
 10612              	.LBB348:
 10613              	.LBB267:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10614              		.loc 1 2308 0
 10615 5ab8 D0C91FE5 		ldr	ip, .L982+100
 10616 5abc E525DCE5 		ldrb	r2, [ip, #1509]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10617              		.loc 1 2309 0
 10618 5ac0 E615DCE5 		ldrb	r1, [ip, #1510]	@ zero_extendqisi2
 10619 5ac4 ADFFFFEA 		b	.L940
 10620              	.LVL1222:
 10621              	.L709:
 10622              	.LBE267:
 10623              	.LBE348:
 10624              	.LBB349:
 10625              	.LBB238:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10626              		.loc 1 2308 0
 10627 5ac8 E0C91FE5 		ldr	ip, .L982+100
 10628 5acc 4526DCE5 		ldrb	r2, [ip, #1605]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10629              		.loc 1 2309 0
 10630 5ad0 4616DCE5 		ldrb	r1, [ip, #1606]	@ zero_extendqisi2
 10631 5ad4 A9FFFFEA 		b	.L940
 10632              	.LVL1223:
 10633              	.L746:
 10634              	.LBE238:
 10635              	.LBE349:
 10636              	.LBB350:
 10637              	.LBB302:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10638              		.loc 1 2341 0
 10639 5ad8 F0391FE5 		ldr	r3, .L982+100
 10640 5adc 8716D3E5 		ldrb	r1, [r3, #1671]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10641              		.loc 1 2342 0
 10642 5ae0 8826D3E5 		ldrb	r2, [r3, #1672]	@ zero_extendqisi2
 10643 5ae4 F6FBFFEA 		b	.L930
 10644              	.L745:
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10645              		.loc 1 2299 0
 10646 5ae8 0030A0E3 		mov	r3, #0
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10647              		.loc 1 2300 0
 10648 5aec 0200A0E3 		mov	r0, #2
 10649 5af0 001A1FE5 		ldr	r1, .L982+108
2299:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10650              		.loc 1 2299 0
 10651 5af4 2930C7E5 		strb	r3, [r7, #41]
2298:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10652              		.loc 1 2298 0
 10653 5af8 2850C7E5 		strb	r5, [r7, #40]
2300:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10654              		.loc 1 2300 0
 10655 5afc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10656              	.LVL1224:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10657              		.loc 1 2288 0
 10658 5b00 FF20A0E3 		mov	r2, #255
 10659 5b04 0230A0E1 		mov	r3, r2
2301:../uvc.c      **** 			  break;
 10660              		.loc 1 2301 0
 10661 5b08 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10662              	.LVL1225:
 10663 5b0c F7FBFFEA 		b	.L749
 10664              	.LVL1226:
 10665              	.L717:
 10666              	.LBE302:
 10667              	.LBE350:
 10668              	.LBB351:
 10669              	.LBB245:
2501:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10670              		.loc 1 2501 0
 10671 5b10 0000A0E3 		mov	r0, #0
 10672 5b14 0020A0E1 		mov	r2, r0
 10673 5b18 0110A0E3 		mov	r1, #1
 10674 5b1c FEFFFFEB 		bl	CyU3PUsbStall
 10675              	.LVL1227:
2502:../uvc.c      **** 			  break;
 10676              		.loc 1 2502 0
 10677 5b20 24C09DE5 		ldr	ip, [sp, #36]
 10678 5b24 0520A0E3 		mov	r2, #5
 10679 5b28 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10680 5b2c 0400A0E3 		mov	r0, #4
 10681 5b30 4C1A1FE5 		ldr	r1, .L982+96
 10682 5b34 FEFFFFEB 		bl	CyU3PDebugPrint
 10683              	.LVL1228:
2288:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10684              		.loc 1 2288 0
 10685 5b38 FF20A0E3 		mov	r2, #255
 10686              	.LVL1229:
 10687 5b3c 78FDFFEA 		b	.L773
 10688              	.LVL1230:
 10689              	.L735:
 10690              	.LBE245:
 10691              	.LBE351:
 10692              	.LBB352:
 10693              	.LBB285:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10694              		.loc 1 2341 0
 10695 5b40 582A1FE5 		ldr	r2, .L982+100
 10696 5b44 6F16D2E5 		ldrb	r1, [r2, #1647]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10697              		.loc 1 2342 0
 10698 5b48 7026D2E5 		ldrb	r2, [r2, #1648]	@ zero_extendqisi2
 10699 5b4c 7FFBFFEA 		b	.L932
 10700              	.LVL1231:
 10701              	.L759:
 10702              	.LBE285:
 10703              	.LBE352:
 10704              	.LBB353:
 10705              	.LBB292:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10706              		.loc 1 2341 0
 10707 5b50 9F16DAE5 		ldrb	r1, [r10, #1695]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10708              		.loc 1 2342 0
 10709 5b54 A026DAE5 		ldrb	r2, [r10, #1696]	@ zero_extendqisi2
 10710 5b58 7CFBFFEA 		b	.L932
 10711              	.LVL1232:
 10712              	.L702:
 10713              	.LBE292:
 10714              	.LBE353:
 10715              	.LBB354:
 10716              	.LBB276:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10717              		.loc 1 2341 0
 10718 5b5c 742A1FE5 		ldr	r2, .L982+100
 10719 5b60 0F16D2E5 		ldrb	r1, [r2, #1551]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10720              		.loc 1 2342 0
 10721 5b64 1026D2E5 		ldrb	r2, [r2, #1552]	@ zero_extendqisi2
 10722 5b68 78FBFFEA 		b	.L932
 10723              	.LVL1233:
 10724              	.L724:
 10725              	.LBE276:
 10726              	.LBE354:
 10727              	.LBB355:
 10728              	.LBB246:
2341:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10729              		.loc 1 2341 0
 10730 5b6c 842A1FE5 		ldr	r2, .L982+100
 10731 5b70 5716D2E5 		ldrb	r1, [r2, #1623]	@ zero_extendqisi2
2342:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10732              		.loc 1 2342 0
 10733 5b74 5826D2E5 		ldrb	r2, [r2, #1624]	@ zero_extendqisi2
 10734 5b78 74FBFFEA 		b	.L932
 10735              	.LVL1234:
 10736              	.L755:
 10737              	.LBE246:
 10738              	.LBE355:
 10739              	.LBB356:
 10740              	.LBB293:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10741              		.loc 1 2308 0
 10742 5b7c A526DAE5 		ldrb	r2, [r10, #1701]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10743              		.loc 1 2309 0
 10744 5b80 A616DAE5 		ldrb	r1, [r10, #1702]	@ zero_extendqisi2
 10745 5b84 7DFFFFEA 		b	.L940
 10746              	.LVL1235:
 10747              	.L720:
 10748              	.LBE293:
 10749              	.LBE356:
 10750              	.LBB357:
 10751              	.LBB247:
2308:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10752              		.loc 1 2308 0
 10753 5b88 A0CA1FE5 		ldr	ip, .L982+100
 10754 5b8c 5D26DCE5 		ldrb	r2, [ip, #1629]	@ zero_extendqisi2
2309:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10755              		.loc 1 2309 0
 10756 5b90 5E16DCE5 		ldrb	r1, [ip, #1630]	@ zero_extendqisi2
 10757 5b94 79FFFFEA 		b	.L940
 10758              	.LVL1236:
 10759              	.L860:
 10760              	.LBE247:
 10761              	.LBE357:
 10762              	.LBE364:
 10763              	.LBE404:
 10764              	.LBB405:
 10765              	.LBB226:
 10766              	.LBB197:
 10767              	.LBB182:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10768              		.loc 1 1717 0
 10769 5b98 B0EA1FE5 		ldr	lr, .L982+100
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10770              		.loc 1 1716 0
 10771 5b9c 020053E3 		cmp	r3, #2
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10772              		.loc 1 1717 0
 10773 5ba0 85C7DEE5 		ldrb	ip, [lr, #1925]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 10774              		.loc 1 1741 0
 10775 5ba4 0300A0E1 		mov	r0, r3
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10776              		.loc 1 1718 0
 10777 5ba8 8627DEE5 		ldrb	r2, [lr, #1926]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10778              		.loc 1 1716 0
 10779 5bac 0401000A 		beq	.L938
 10780              	.LVL1237:
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10781              		.loc 1 1723 0
 10782 5bb0 0030A0E3 		mov	r3, #0
1747:../uvc.c      **** 				  }
 10783              		.loc 1 1747 0
 10784 5bb4 0340A0E1 		mov	r4, r3
 10785              	.LVL1238:
1741:../uvc.c      **** 				  if(Len == 2){
 10786              		.loc 1 1741 0
 10787 5bb8 C81A1FE5 		ldr	r1, .L982+108
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10788              		.loc 1 1722 0
 10789 5bbc 28C0C7E5 		strb	ip, [r7, #40]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10790              		.loc 1 1724 0
 10791 5bc0 2A20C7E5 		strb	r2, [r7, #42]
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10792              		.loc 1 1723 0
 10793 5bc4 2930C7E5 		strb	r3, [r7, #41]
1725:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10794              		.loc 1 1725 0
 10795 5bc8 2B30C7E5 		strb	r3, [r7, #43]
1747:../uvc.c      **** 				  }
 10796              		.loc 1 1747 0
 10797 5bcc 28308DE5 		str	r3, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 10798              		.loc 1 1741 0
 10799 5bd0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10800              	.LVL1239:
1747:../uvc.c      **** 				  }
 10801              		.loc 1 1747 0
 10802 5bd4 04C0A0E1 		mov	ip, r4
1746:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 10803              		.loc 1 1746 0
 10804 5bd8 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10805              	.LVL1240:
1747:../uvc.c      **** 				  }
 10806              		.loc 1 1747 0
 10807 5bdc 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 10808              	.LVL1241:
 10809 5be0 37FEFFEA 		b	.L869
 10810              	.LVL1242:
 10811              	.L750:
 10812              	.LBE182:
 10813              	.LBE197:
 10814              	.LBE226:
 10815              	.LBE405:
 10816              	.LBB406:
 10817              	.LBB365:
 10818              	.LBB358:
 10819              	.LBB303:
2469:../uvc.c      **** 					  }
 10820              		.loc 1 2469 0
 10821 5be4 0020A0E1 		mov	r2, r0
 10822 5be8 0410A0E1 		mov	r1, r4
 10823 5bec FEFFFFEB 		bl	CyU3PUsbStall
 10824              	.LVL1243:
 10825 5bf0 21FDFFEA 		b	.L751
 10826              	.LVL1244:
 10827              	.L836:
 10828              	.LBE303:
 10829              	.LBE358:
 10830              	.LBE365:
 10831              	.LBE406:
 10832              	.LBB407:
 10833              	.LBB227:
 10834              	.LBB198:
 10835              	.LBB160:
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10836              		.loc 1 1716 0
 10837 5bf4 020053E3 		cmp	r3, #2
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10838              		.loc 1 1722 0
 10839 5bf8 71C7DA15 		ldrneb	ip, [r10, #1905]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 10840              		.loc 1 1741 0
 10841 5bfc 0300A011 		movne	r0, r3
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10842              		.loc 1 1724 0
 10843 5c00 7227DA15 		ldrneb	r2, [r10, #1906]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10844              		.loc 1 1716 0
 10845 5c04 DAFAFF1A 		bne	.L850
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10846              		.loc 1 1717 0
 10847 5c08 7127DAE5 		ldrb	r2, [r10, #1905]	@ zero_extendqisi2
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10848              		.loc 1 1718 0
 10849 5c0c 7237DAE5 		ldrb	r3, [r10, #1906]	@ zero_extendqisi2
 10850              	.LVL1245:
1741:../uvc.c      **** 				  if(Len == 2){
 10851              		.loc 1 1741 0
 10852 5c10 0200A0E3 		mov	r0, #2
 10853 5c14 241B1FE5 		ldr	r1, .L982+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10854              		.loc 1 1717 0
 10855 5c18 2820C7E5 		strb	r2, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10856              		.loc 1 1718 0
 10857 5c1c 2930C7E5 		strb	r3, [r7, #41]
 10858 5c20 160000EA 		b	.L936
 10859              	.LVL1246:
 10860              	.L843:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10861              		.loc 1 1770 0
 10862 5c24 7527DAE5 		ldrb	r2, [r10, #1909]	@ zero_extendqisi2
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10863              		.loc 1 1771 0
 10864 5c28 0030A0E3 		mov	r3, #0
 10865              	.LVL1247:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10866              		.loc 1 1782 0
 10867 5c2c 0100A0E3 		mov	r0, #1
 10868 5c30 401B1FE5 		ldr	r1, .L982+108
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10869              		.loc 1 1770 0
 10870 5c34 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10871              		.loc 1 1771 0
 10872 5c38 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10873              		.loc 1 1772 0
 10874 5c3c 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 10875              		.loc 1 1773 0
 10876 5c40 2B30C7E5 		strb	r3, [r7, #43]
 10877              	.LVL1248:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10878              		.loc 1 1784 0
 10879 5c44 28308DE5 		str	r3, [sp, #40]
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10880              		.loc 1 1782 0
 10881 5c48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10882              	.LVL1249:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10883              		.loc 1 1784 0
 10884 5c4c 00C0A0E3 		mov	ip, #0
1783:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 10885              		.loc 1 1783 0
 10886 5c50 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10887              	.LVL1250:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10888              		.loc 1 1784 0
 10889 5c54 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10890              	.LVL1251:
 10891 5c58 34FEFFEA 		b	.L845
 10892              	.LVL1252:
 10893              	.L842:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10894              		.loc 1 1752 0
 10895 5c5c 73C7DAE5 		ldrb	ip, [r10, #1907]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10896              		.loc 1 1763 0
 10897 5c60 701B1FE5 		ldr	r1, .L982+108
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10898              		.loc 1 1753 0
 10899 5c64 7427DAE5 		ldrb	r2, [r10, #1908]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10900              		.loc 1 1763 0
 10901 5c68 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10902              		.loc 1 1754 0
 10903 5c6c 0030A0E3 		mov	r3, #0
 10904              	.LVL1253:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10905              		.loc 1 1752 0
 10906 5c70 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10907              		.loc 1 1753 0
 10908 5c74 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10909              		.loc 1 1754 0
 10910 5c78 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 10911              		.loc 1 1755 0
 10912 5c7c 2B30C7E5 		strb	r3, [r7, #43]
 10913              	.LVL1254:
 10914              	.L936:
1744:../uvc.c      **** 				  }else{
 10915              		.loc 1 1744 0
 10916 5c80 0040A0E3 		mov	r4, #0
 10917 5c84 28408DE5 		str	r4, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 10918              		.loc 1 1741 0
 10919 5c88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10920              	.LVL1255:
1744:../uvc.c      **** 				  }else{
 10921              		.loc 1 1744 0
 10922 5c8c 04C0A0E1 		mov	ip, r4
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10923              		.loc 1 1743 0
 10924 5c90 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10925              	.LVL1256:
1744:../uvc.c      **** 				  }else{
 10926              		.loc 1 1744 0
 10927 5c94 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10928              	.LVL1257:
 10929 5c98 24FEFFEA 		b	.L845
 10930              	.LVL1258:
 10931              	.L815:
 10932              	.LBE160:
 10933              	.LBE198:
 10934              	.LBB199:
 10935              	.LBB172:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10936              		.loc 1 1680 0
 10937 5c9c 020053E3 		cmp	r3, #2
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10938              		.loc 1 1681 0
 10939 5ca0 5BC7DAE5 		ldrb	ip, [r10, #1883]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 10940              		.loc 1 1705 0
 10941 5ca4 0300A0E1 		mov	r0, r3
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10942              		.loc 1 1682 0
 10943 5ca8 5C27DAE5 		ldrb	r2, [r10, #1884]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10944              		.loc 1 1680 0
 10945 5cac E5FBFF1A 		bne	.L826
 10946              	.LVL1259:
 10947              	.L935:
1705:../uvc.c      **** 		 	 if(Len == 2){
 10948              		.loc 1 1705 0
 10949 5cb0 C01B1FE5 		ldr	r1, .L982+108
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10950              		.loc 1 1681 0
 10951 5cb4 28C0C7E5 		strb	ip, [r7, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10952              		.loc 1 1682 0
 10953 5cb8 2920C7E5 		strb	r2, [r7, #41]
 10954 5cbc 980000EA 		b	.L933
 10955              	.LVL1260:
 10956              	.L814:
1498:../uvc.c      **** 			 	 			 {
 10957              		.loc 1 1498 0
 10958 5cc0 020053E3 		cmp	r3, #2
 10959 5cc4 A301000A 		beq	.L976
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10960              		.loc 1 1506 0
 10961 5cc8 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10962              		.loc 1 1355 0
 10963 5ccc FF50A013 		movne	r5, #255
 10964 5cd0 05C0A011 		movne	ip, r5
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10965              		.loc 1 1506 0
 10966 5cd4 8C01000A 		beq	.L977
 10967              	.LVL1261:
 10968              	.L823:
1672:../uvc.c      **** 
 10969              		.loc 1 1672 0
 10970 5cd8 0300A0E1 		mov	r0, r3
 10971 5cdc EC1B1FE5 		ldr	r1, .L982+108
 10972 5ce0 1CC08DE5 		str	ip, [sp, #28]
 10973 5ce4 20308DE5 		str	r3, [sp, #32]
 10974 5ce8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10975              	.LVL1262:
1675:../uvc.c      **** //#endif
 10976              		.loc 1 1675 0
 10977 5cec 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 10978 5cf0 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 10979 5cf4 20309DE5 		ldr	r3, [sp, #32]
 10980 5cf8 29E0D7E5 		ldrb	lr, [r7, #41]	@ zero_extendqisi2
 10981 5cfc 03008DE8 		stmia	sp, {r0, r1}
 10982 5d00 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10983 5d04 08308DE5 		str	r3, [sp, #8]
 10984 5d08 0400A0E3 		mov	r0, #4
 10985 5d0c 0E30A0E1 		mov	r3, lr
 10986 5d10 241C1FE5 		ldr	r1, .L982+104
 10987 5d14 FEFFFFEB 		bl	CyU3PDebugPrint
 10988              	.LVL1263:
 10989 5d18 0040A0E3 		mov	r4, #0
 10990 5d1c 24408DE5 		str	r4, [sp, #36]
 10991 5d20 1CC09DE5 		ldr	ip, [sp, #28]
 10992 5d24 D6FDFFEA 		b	.L821
 10993              	.LVL1264:
 10994              	.L811:
2265:../uvc.c      **** 			  break;
 10995              		.loc 1 2265 0
 10996 5d28 0000A0E3 		mov	r0, #0
 10997 5d2c 0020A0E1 		mov	r2, r0
 10998 5d30 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10999              		.loc 1 1355 0
 11000 5d34 FF50A0E3 		mov	r5, #255
2265:../uvc.c      **** 			  break;
 11001              		.loc 1 2265 0
 11002 5d38 0040A0E3 		mov	r4, #0
 11003 5d3c FEFFFFEB 		bl	CyU3PUsbStall
 11004              	.LVL1265:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11005              		.loc 1 1355 0
 11006 5d40 05C0A0E1 		mov	ip, r5
2265:../uvc.c      **** 			  break;
 11007              		.loc 1 2265 0
 11008 5d44 24408DE5 		str	r4, [sp, #36]
 11009 5d48 CDFDFFEA 		b	.L821
 11010              	.LVL1266:
 11011              	.L859:
 11012              	.LBE172:
 11013              	.LBE199:
 11014              	.LBB200:
 11015              	.LBB183:
 11016 5d4c 0000A0E3 		mov	r0, #0
 11017 5d50 0020A0E1 		mov	r2, r0
 11018 5d54 0110A0E3 		mov	r1, #1
 11019 5d58 FEFFFFEB 		bl	CyU3PUsbStall
 11020              	.LVL1267:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11021              		.loc 1 1355 0
 11022 5d5c FF40A0E3 		mov	r4, #255
2265:../uvc.c      **** 			  break;
 11023              		.loc 1 2265 0
 11024 5d60 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11025              		.loc 1 1355 0
 11026 5d64 0450A0E1 		mov	r5, r4
2265:../uvc.c      **** 			  break;
 11027              		.loc 1 2265 0
 11028 5d68 28C08DE5 		str	ip, [sp, #40]
 11029 5d6c D4FDFFEA 		b	.L869
 11030              	.LVL1268:
 11031              	.L867:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11032              		.loc 1 1770 0
 11033 5d70 8927DAE5 		ldrb	r2, [r10, #1929]	@ zero_extendqisi2
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11034              		.loc 1 1771 0
 11035 5d74 0030A0E3 		mov	r3, #0
 11036              	.LVL1269:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11037              		.loc 1 1782 0
 11038 5d78 0100A0E3 		mov	r0, #1
 11039 5d7c 8C1C1FE5 		ldr	r1, .L982+108
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11040              		.loc 1 1770 0
 11041 5d80 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11042              		.loc 1 1771 0
 11043 5d84 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11044              		.loc 1 1772 0
 11045 5d88 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 11046              		.loc 1 1773 0
 11047 5d8c 2B30C7E5 		strb	r3, [r7, #43]
 11048              	.LVL1270:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11049              		.loc 1 1784 0
 11050 5d90 28308DE5 		str	r3, [sp, #40]
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11051              		.loc 1 1782 0
 11052 5d94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11053              	.LVL1271:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11054              		.loc 1 1784 0
 11055 5d98 00C0A0E3 		mov	ip, #0
1783:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 11056              		.loc 1 1783 0
 11057 5d9c 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 11058              	.LVL1272:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11059              		.loc 1 1784 0
 11060 5da0 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 11061              	.LVL1273:
 11062 5da4 C6FDFFEA 		b	.L869
 11063              	.LVL1274:
 11064              	.L866:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11065              		.loc 1 1752 0
 11066 5da8 C0EC1FE5 		ldr	lr, .L982+100
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11067              		.loc 1 1763 0
 11068 5dac BC1C1FE5 		ldr	r1, .L982+108
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11069              		.loc 1 1752 0
 11070 5db0 87C7DEE5 		ldrb	ip, [lr, #1927]	@ zero_extendqisi2
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11071              		.loc 1 1753 0
 11072 5db4 8827DEE5 		ldrb	r2, [lr, #1928]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11073              		.loc 1 1763 0
 11074 5db8 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11075              		.loc 1 1754 0
 11076 5dbc 0030A0E3 		mov	r3, #0
 11077              	.LVL1275:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11078              		.loc 1 1752 0
 11079 5dc0 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11080              		.loc 1 1753 0
 11081 5dc4 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11082              		.loc 1 1754 0
 11083 5dc8 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 11084              		.loc 1 1755 0
 11085 5dcc 2B30C7E5 		strb	r3, [r7, #43]
 11086              	.LVL1276:
 11087              	.L937:
1744:../uvc.c      **** 				  }else{
 11088              		.loc 1 1744 0
 11089 5dd0 0040A0E3 		mov	r4, #0
 11090 5dd4 28408DE5 		str	r4, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 11091              		.loc 1 1741 0
 11092 5dd8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11093              	.LVL1277:
1744:../uvc.c      **** 				  }else{
 11094              		.loc 1 1744 0
 11095 5ddc 04C0A0E1 		mov	ip, r4
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11096              		.loc 1 1743 0
 11097 5de0 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 11098              	.LVL1278:
1744:../uvc.c      **** 				  }else{
 11099              		.loc 1 1744 0
 11100 5de4 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 11101              	.LVL1279:
 11102 5de8 B5FDFFEA 		b	.L869
 11103              	.LVL1280:
 11104              	.L812:
 11105              	.LBE183:
 11106              	.LBE200:
 11107              	.LBB201:
 11108              	.LBB173:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11109              		.loc 1 1717 0
 11110 5dec 04ED1FE5 		ldr	lr, .L982+100
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11111              		.loc 1 1716 0
 11112 5df0 020053E3 		cmp	r3, #2
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11113              		.loc 1 1717 0
 11114 5df4 5DC7DEE5 		ldrb	ip, [lr, #1885]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 11115              		.loc 1 1741 0
 11116 5df8 0300A0E1 		mov	r0, r3
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11117              		.loc 1 1718 0
 11118 5dfc 5E27DEE5 		ldrb	r2, [lr, #1886]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11119              		.loc 1 1716 0
 11120 5e00 90FBFF1A 		bne	.L826
 11121              	.LVL1281:
1741:../uvc.c      **** 				  if(Len == 2){
 11122              		.loc 1 1741 0
 11123 5e04 141D1FE5 		ldr	r1, .L982+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11124              		.loc 1 1717 0
 11125 5e08 28C0C7E5 		strb	ip, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11126              		.loc 1 1718 0
 11127 5e0c 2920C7E5 		strb	r2, [r7, #41]
 11128 5e10 340000EA 		b	.L934
 11129              	.LVL1282:
 11130              	.L835:
 11131              	.LBE173:
 11132              	.LBE201:
 11133              	.LBB202:
 11134              	.LBB161:
2265:../uvc.c      **** 			  break;
 11135              		.loc 1 2265 0
 11136 5e14 0000A0E3 		mov	r0, #0
 11137 5e18 0020A0E1 		mov	r2, r0
 11138 5e1c 0110A0E3 		mov	r1, #1
 11139 5e20 FEFFFFEB 		bl	CyU3PUsbStall
 11140              	.LVL1283:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11141              		.loc 1 1355 0
 11142 5e24 FF40A0E3 		mov	r4, #255
2265:../uvc.c      **** 			  break;
 11143              		.loc 1 2265 0
 11144 5e28 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11145              		.loc 1 1355 0
 11146 5e2c 0450A0E1 		mov	r5, r4
2265:../uvc.c      **** 			  break;
 11147              		.loc 1 2265 0
 11148 5e30 28C08DE5 		str	ip, [sp, #40]
 11149 5e34 BDFDFFEA 		b	.L845
 11150              	.LVL1284:
 11151              	.L863:
 11152              	.LBE161:
 11153              	.LBE202:
 11154              	.LBB203:
 11155              	.LBB184:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11156              		.loc 1 1680 0
 11157 5e38 020053E3 		cmp	r3, #2
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11158              		.loc 1 1686 0
 11159 5e3c 83C7DA15 		ldrneb	ip, [r10, #1923]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 11160              		.loc 1 1705 0
 11161 5e40 0300A011 		movne	r0, r3
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11162              		.loc 1 1688 0
 11163 5e44 8427DA15 		ldrneb	r2, [r10, #1924]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11164              		.loc 1 1680 0
 11165 5e48 12FDFF1A 		bne	.L874
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11166              		.loc 1 1681 0
 11167 5e4c 8327DAE5 		ldrb	r2, [r10, #1923]	@ zero_extendqisi2
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11168              		.loc 1 1682 0
 11169 5e50 8437DAE5 		ldrb	r3, [r10, #1924]	@ zero_extendqisi2
 11170              	.LVL1285:
1705:../uvc.c      **** 		 	 if(Len == 2){
 11171              		.loc 1 1705 0
 11172 5e54 0200A0E3 		mov	r0, #2
 11173 5e58 681D1FE5 		ldr	r1, .L982+108
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11174              		.loc 1 1681 0
 11175 5e5c 2820C7E5 		strb	r2, [r7, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11176              		.loc 1 1682 0
 11177 5e60 2930C7E5 		strb	r3, [r7, #41]
 11178 5e64 D9FFFFEA 		b	.L937
 11179              	.LVL1286:
 11180              	.L862:
1498:../uvc.c      **** 			 	 			 {
 11181              		.loc 1 1498 0
 11182 5e68 020053E3 		cmp	r3, #2
 11183 5e6c B201000A 		beq	.L978
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11184              		.loc 1 1506 0
 11185 5e70 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11186              		.loc 1 1355 0
 11187 5e74 FF40A013 		movne	r4, #255
 11188              	.LVL1287:
 11189 5e78 0450A011 		movne	r5, r4
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11190              		.loc 1 1506 0
 11191 5e7c C701000A 		beq	.L979
 11192              	.LVL1288:
 11193              	.L871:
1672:../uvc.c      **** 
 11194              		.loc 1 1672 0
 11195 5e80 0300A0E1 		mov	r0, r3
 11196 5e84 941D1FE5 		ldr	r1, .L982+108
 11197 5e88 20308DE5 		str	r3, [sp, #32]
 11198 5e8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11199              	.LVL1289:
1675:../uvc.c      **** //#endif
 11200              		.loc 1 1675 0
 11201 5e90 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 11202 5e94 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11203 5e98 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11204 5e9c 20309DE5 		ldr	r3, [sp, #32]
 11205 5ea0 03008DE8 		stmia	sp, {r0, r1}
 11206 5ea4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11207 5ea8 08308DE5 		str	r3, [sp, #8]
 11208 5eac 0400A0E3 		mov	r0, #4
 11209 5eb0 0C30A0E1 		mov	r3, ip
 11210 5eb4 C81D1FE5 		ldr	r1, .L982+104
 11211 5eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 11212              	.LVL1290:
 11213 5ebc 00C0A0E3 		mov	ip, #0
 11214 5ec0 28C08DE5 		str	ip, [sp, #40]
 11215 5ec4 7EFDFFEA 		b	.L869
 11216              	.LVL1291:
 11217              	.L819:
 11218              	.LBE184:
 11219              	.LBE203:
 11220              	.LBB204:
 11221              	.LBB174:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11222              		.loc 1 1770 0
 11223 5ec8 6127DAE5 		ldrb	r2, [r10, #1889]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11224              		.loc 1 1782 0
 11225 5ecc DC1D1FE5 		ldr	r1, .L982+108
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11226              		.loc 1 1771 0
 11227 5ed0 0030A0E3 		mov	r3, #0
 11228              	.LVL1292:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11229              		.loc 1 1782 0
 11230 5ed4 0100A0E3 		mov	r0, #1
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11231              		.loc 1 1770 0
 11232 5ed8 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11233              		.loc 1 1771 0
 11234 5edc 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11235              		.loc 1 1772 0
 11236 5ee0 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 11237              		.loc 1 1773 0
 11238 5ee4 2B30C7E5 		strb	r3, [r7, #43]
 11239              	.LVL1293:
 11240              	.L934:
1744:../uvc.c      **** 				  }else{
 11241              		.loc 1 1744 0
 11242 5ee8 0040A0E3 		mov	r4, #0
 11243 5eec 24408DE5 		str	r4, [sp, #36]
1741:../uvc.c      **** 				  if(Len == 2){
 11244              		.loc 1 1741 0
 11245 5ef0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11246              	.LVL1294:
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11247              		.loc 1 1743 0
 11248 5ef4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11249              	.LVL1295:
1744:../uvc.c      **** 				  }else{
 11250              		.loc 1 1744 0
 11251 5ef8 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11252              	.LVL1296:
 11253 5efc 60FDFFEA 		b	.L821
 11254              	.LVL1297:
 11255              	.L818:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11256              		.loc 1 1752 0
 11257 5f00 5FC7DAE5 		ldrb	ip, [r10, #1887]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11258              		.loc 1 1763 0
 11259 5f04 141E1FE5 		ldr	r1, .L982+108
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11260              		.loc 1 1753 0
 11261 5f08 6027DAE5 		ldrb	r2, [r10, #1888]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11262              		.loc 1 1763 0
 11263 5f0c 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11264              		.loc 1 1754 0
 11265 5f10 0030A0E3 		mov	r3, #0
 11266              	.LVL1298:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11267              		.loc 1 1752 0
 11268 5f14 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11269              		.loc 1 1753 0
 11270 5f18 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11271              		.loc 1 1754 0
 11272 5f1c 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 11273              		.loc 1 1755 0
 11274 5f20 2B30C7E5 		strb	r3, [r7, #43]
 11275              	.L933:
1708:../uvc.c      **** 		 	 }else{
 11276              		.loc 1 1708 0
 11277 5f24 00C0A0E3 		mov	ip, #0
 11278 5f28 24C08DE5 		str	ip, [sp, #36]
 11279 5f2c 0040A0E3 		mov	r4, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 11280              		.loc 1 1705 0
 11281 5f30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11282              	.LVL1299:
1707:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
 11283              		.loc 1 1707 0
 11284 5f34 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11285              	.LVL1300:
1708:../uvc.c      **** 		 	 }else{
 11286              		.loc 1 1708 0
 11287 5f38 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11288              	.LVL1301:
 11289 5f3c 50FDFFEA 		b	.L821
 11290              	.LVL1302:
 11291              	.L839:
 11292              	.LBE174:
 11293              	.LBE204:
 11294              	.LBB205:
 11295              	.LBB162:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11296              		.loc 1 1680 0
 11297 5f40 020053E3 		cmp	r3, #2
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11298              		.loc 1 1681 0
 11299 5f44 6FC7DAE5 		ldrb	ip, [r10, #1903]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 11300              		.loc 1 1705 0
 11301 5f48 0300A0E1 		mov	r0, r3
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11302              		.loc 1 1682 0
 11303 5f4c 7027DAE5 		ldrb	r2, [r10, #1904]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11304              		.loc 1 1680 0
 11305 5f50 07FAFF1A 		bne	.L850
 11306              	.LVL1303:
 11307              	.L942:
1814:../uvc.c      **** 		 	 if(Len == 2){
 11308              		.loc 1 1814 0
 11309 5f54 641E1FE5 		ldr	r1, .L982+108
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11310              		.loc 1 1790 0
 11311 5f58 28C0C7E5 		strb	ip, [r7, #40]
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 11312              		.loc 1 1791 0
 11313 5f5c 2920C7E5 		strb	r2, [r7, #41]
 11314 5f60 46FFFFEA 		b	.L936
 11315              	.LVL1304:
 11316              	.L838:
1498:../uvc.c      **** 			 	 			 {
 11317              		.loc 1 1498 0
 11318 5f64 020053E3 		cmp	r3, #2
 11319 5f68 8001000A 		beq	.L980
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11320              		.loc 1 1506 0
 11321 5f6c 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11322              		.loc 1 1355 0
 11323 5f70 FF40A013 		movne	r4, #255
 11324              	.LVL1305:
 11325 5f74 0450A011 		movne	r5, r4
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11326              		.loc 1 1506 0
 11327 5f78 5C01000A 		beq	.L981
 11328              	.LVL1306:
 11329              	.L847:
1672:../uvc.c      **** 
 11330              		.loc 1 1672 0
 11331 5f7c 0300A0E1 		mov	r0, r3
 11332 5f80 901E1FE5 		ldr	r1, .L982+108
 11333 5f84 20308DE5 		str	r3, [sp, #32]
 11334 5f88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11335              	.LVL1307:
1675:../uvc.c      **** //#endif
 11336              		.loc 1 1675 0
 11337 5f8c 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 11338 5f90 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11339 5f94 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11340 5f98 20309DE5 		ldr	r3, [sp, #32]
 11341 5f9c 03008DE8 		stmia	sp, {r0, r1}
 11342 5fa0 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11343 5fa4 08308DE5 		str	r3, [sp, #8]
 11344 5fa8 0400A0E3 		mov	r0, #4
 11345 5fac 0C30A0E1 		mov	r3, ip
 11346 5fb0 C41E1FE5 		ldr	r1, .L982+104
 11347 5fb4 FEFFFFEB 		bl	CyU3PDebugPrint
 11348              	.LVL1308:
 11349 5fb8 00C0A0E3 		mov	ip, #0
 11350 5fbc 28C08DE5 		str	ip, [sp, #40]
 11351 5fc0 5AFDFFEA 		b	.L845
 11352              	.LVL1309:
 11353              	.L938:
 11354              	.LBE162:
 11355              	.LBE205:
 11356              	.LBB206:
 11357              	.LBB185:
1741:../uvc.c      **** 				  if(Len == 2){
 11358              		.loc 1 1741 0
 11359 5fc4 D41E1FE5 		ldr	r1, .L982+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11360              		.loc 1 1717 0
 11361 5fc8 28C0C7E5 		strb	ip, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11362              		.loc 1 1718 0
 11363 5fcc 2920C7E5 		strb	r2, [r7, #41]
 11364 5fd0 7EFFFFEA 		b	.L937
 11365              	.LVL1310:
 11366              	.L851:
 11367              	.LBE185:
 11368              	.LBE206:
 11369              	.LBB207:
 11370              	.LBB163:
2257:../uvc.c      **** 			   }
 11371              		.loc 1 2257 0
 11372 5fd4 38209DE5 		ldr	r2, [sp, #56]
 11373 5fd8 0400A0E3 		mov	r0, #4
 11374              	.LVL1311:
 11375 5fdc E81E1FE5 		ldr	r1, .L982+112
 11376 5fe0 FEFFFFEB 		bl	CyU3PDebugPrint
 11377              	.LVL1312:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11378              		.loc 1 1355 0
 11379 5fe4 FF40A0E3 		mov	r4, #255
 11380              	.LVL1313:
2257:../uvc.c      **** 			   }
 11381              		.loc 1 2257 0
 11382 5fe8 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11383              		.loc 1 1355 0
 11384 5fec 0450A0E1 		mov	r5, r4
2257:../uvc.c      **** 			   }
 11385              		.loc 1 2257 0
 11386 5ff0 28C08DE5 		str	ip, [sp, #40]
 11387 5ff4 4DFDFFEA 		b	.L845
 11388              	.LVL1314:
 11389              	.L827:
 11390              	.LBE163:
 11391              	.LBE207:
 11392              	.LBB208:
 11393              	.LBB175:
 11394 5ff8 38209DE5 		ldr	r2, [sp, #56]
 11395 5ffc 0400A0E3 		mov	r0, #4
 11396              	.LVL1315:
 11397 6000 0C1F1FE5 		ldr	r1, .L982+112
 11398 6004 FEFFFFEB 		bl	CyU3PDebugPrint
 11399              	.LVL1316:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11400              		.loc 1 1355 0
 11401 6008 FF50A0E3 		mov	r5, #255
2257:../uvc.c      **** 			   }
 11402              		.loc 1 2257 0
 11403 600c 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11404              		.loc 1 1355 0
 11405 6010 05C0A0E1 		mov	ip, r5
2257:../uvc.c      **** 			   }
 11406              		.loc 1 2257 0
 11407 6014 24408DE5 		str	r4, [sp, #36]
 11408 6018 19FDFFEA 		b	.L821
 11409              	.LVL1317:
 11410              	.L875:
 11411              	.LBE175:
 11412              	.LBE208:
 11413              	.LBB209:
 11414              	.LBB186:
 11415 601c 38209DE5 		ldr	r2, [sp, #56]
 11416 6020 0400A0E3 		mov	r0, #4
 11417              	.LVL1318:
 11418 6024 301F1FE5 		ldr	r1, .L982+112
 11419 6028 FEFFFFEB 		bl	CyU3PDebugPrint
 11420              	.LVL1319:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11421              		.loc 1 1355 0
 11422 602c FF40A0E3 		mov	r4, #255
 11423              	.LVL1320:
2257:../uvc.c      **** 			   }
 11424              		.loc 1 2257 0
 11425 6030 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11426              		.loc 1 1355 0
 11427 6034 0450A0E1 		mov	r5, r4
2257:../uvc.c      **** 			   }
 11428              		.loc 1 2257 0
 11429 6038 28C08DE5 		str	ip, [sp, #40]
 11430 603c 20FDFFEA 		b	.L869
 11431              	.LVL1321:
 11432              	.L951:
 11433              	.LBE186:
 11434              	.LBE209:
 11435              	.LBE227:
 11436              	.LBE407:
 11437              	.LBB408:
 11438              	.LBB384:
 11439              	.LBB377:
 11440              	.LBB373:
1814:../uvc.c      **** 		 	 if(Len == 2){
 11441              		.loc 1 1814 0
 11442 6040 501F1FE5 		ldr	r1, .L982+108
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11443              		.loc 1 1803 0
 11444 6044 28C0C7E5 		strb	ip, [r7, #40]
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11445              		.loc 1 1804 0
 11446 6048 2920C7E5 		strb	r2, [r7, #41]
 11447 604c 04FEFFEA 		b	.L924
 11448              	.LVL1322:
 11449              	.L666:
2257:../uvc.c      **** 			   }
 11450              		.loc 1 2257 0
 11451 6050 0400A0E3 		mov	r0, #4
 11452              	.LVL1323:
 11453 6054 601F1FE5 		ldr	r1, .L982+112
 11454 6058 FEFFFFEB 		bl	CyU3PDebugPrint
 11455              	.LVL1324:
 11456 605c 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11457              		.loc 1 1355 0
 11458 6060 FF30A0E3 		mov	r3, #255
 11459 6064 0320A0E1 		mov	r2, r3
2257:../uvc.c      **** 			   }
 11460              		.loc 1 2257 0
 11461 6068 24408DE5 		str	r4, [sp, #36]
 11462 606c 04C0A0E1 		mov	ip, r4
 11463 6070 43FBFFEA 		b	.L662
 11464              	.LVL1325:
 11465              	.L970:
 11466              	.LBE373:
 11467              	.LBE377:
 11468              	.LBE384:
 11469              	.LBE408:
 11470              	.LBB409:
 11471              	.LBB228:
 11472              	.LBB210:
 11473              	.LBB187:
1830:../uvc.c      **** 				 }else{
 11474              		.loc 1 1830 0
 11475 6074 29E0DBE5 		ldrb	lr, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11476              		.loc 1 1836 0
 11477 6078 00408DE5 		str	r4, [sp]
 11478 607c 30409DE5 		ldr	r4, [sp, #48]
 11479              	.LVL1326:
 11480 6080 08308DE5 		str	r3, [sp, #8]
 11481 6084 0CC08DE5 		str	ip, [sp, #12]
 11482 6088 34309DE5 		ldr	r3, [sp, #52]
 11483 608c 04408DE5 		str	r4, [sp, #4]
 11484 6090 10E08DE5 		str	lr, [sp, #16]
 11485 6094 0400A0E3 		mov	r0, #4
 11486              	.LVL1327:
 11487 6098 A01F1FE5 		ldr	r1, .L982+116
 11488 609c 2B20A0E3 		mov	r2, #43
 11489 60a0 1CC08DE5 		str	ip, [sp, #28]
1830:../uvc.c      **** 				 }else{
 11490              		.loc 1 1830 0
 11491 60a4 28E08DE5 		str	lr, [sp, #40]
 11492              	.LVL1328:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11493              		.loc 1 1836 0
 11494 60a8 FEFFFFEB 		bl	CyU3PDebugPrint
 11495              	.LVL1329:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11496              		.loc 1 2039 0
 11497 60ac 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
 11498 60b0 1CC09DE5 		ldr	ip, [sp, #28]
 11499 60b4 03005CE1 		cmp	ip, r3
 11500 60b8 1400000A 		beq	.L878
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11501              		.loc 1 2040 0
 11502 60bc C04F1FE5 		ldr	r4, .L982+120
 11503 60c0 0010E0E3 		mvn	r1, #0
 11504 60c4 1C0094E5 		ldr	r0, [r4, #28]
 11505 60c8 1CC08DE5 		str	ip, [sp, #28]
 11506              	.LVL1330:
 11507 60cc FEFFFFEB 		bl	_txe_mutex_get
 11508              	.LVL1331:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11509              		.loc 1 2041 0
 11510 60d0 1CC09DE5 		ldr	ip, [sp, #28]
 11511 60d4 38209DE5 		ldr	r2, [sp, #56]
 11512 60d8 00C08DE5 		str	ip, [sp]
 11513 60dc 30309DE5 		ldr	r3, [sp, #48]
 11514 60e0 04208DE5 		str	r2, [sp, #4]
 11515 60e4 0400A0E1 		mov	r0, r4
 11516 60e8 34209DE5 		ldr	r2, [sp, #52]
 11517 60ec 2B10A0E3 		mov	r1, #43
 11518 60f0 FEFFFFEB 		bl	cmdSet
 11519              	.LVL1332:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11520              		.loc 1 2042 0
 11521 60f4 1C0094E5 		ldr	r0, [r4, #28]
 11522 60f8 FEFFFFEB 		bl	_txe_mutex_put
 11523              	.LVL1333:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11524              		.loc 1 2043 0
 11525 60fc 1CC09DE5 		ldr	ip, [sp, #28]
 11526 6100 E4349FE5 		ldr	r3, .L984
2044:../uvc.c      **** 									 }
 11527              		.loc 1 2044 0
 11528 6104 38409DE5 		ldr	r4, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11529              		.loc 1 2043 0
 11530 6108 8DC7C3E5 		strb	ip, [r3, #1933]
2044:../uvc.c      **** 									 }
 11531              		.loc 1 2044 0
 11532 610c 8E47C3E5 		strb	r4, [r3, #1934]
 11533              	.L878:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11534              		.loc 1 2046 0
 11535 6110 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11536              		.loc 1 1836 0
 11537 6114 0240A0E3 		mov	r4, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11538              		.loc 1 2046 0
 11539 6118 9137CAE5 		strb	r3, [r10, #1937]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11540              		.loc 1 1836 0
 11541 611c 3C408DE5 		str	r4, [sp, #60]
 11542 6120 37FDFFEA 		b	.L880
 11543              	.LVL1334:
 11544              	.L974:
 11545              	.LBE187:
 11546              	.LBE210:
 11547              	.LBB211:
 11548              	.LBB164:
1830:../uvc.c      **** 				 }else{
 11549              		.loc 1 1830 0
 11550 6124 29E0DBE5 		ldrb	lr, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11551              		.loc 1 1836 0
 11552 6128 00408DE5 		str	r4, [sp]
 11553 612c 30409DE5 		ldr	r4, [sp, #48]
 11554              	.LVL1335:
 11555 6130 08308DE5 		str	r3, [sp, #8]
 11556 6134 0CC08DE5 		str	ip, [sp, #12]
 11557 6138 34309DE5 		ldr	r3, [sp, #52]
 11558 613c 04408DE5 		str	r4, [sp, #4]
 11559 6140 10E08DE5 		str	lr, [sp, #16]
 11560 6144 0400A0E3 		mov	r0, #4
 11561              	.LVL1336:
 11562 6148 A0149FE5 		ldr	r1, .L984+4
 11563 614c 2A20A0E3 		mov	r2, #42
 11564 6150 1CC08DE5 		str	ip, [sp, #28]
1830:../uvc.c      **** 				 }else{
 11565              		.loc 1 1830 0
 11566 6154 28E08DE5 		str	lr, [sp, #40]
 11567              	.LVL1337:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11568              		.loc 1 1836 0
 11569 6158 FEFFFFEB 		bl	CyU3PDebugPrint
 11570              	.LVL1338:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11571              		.loc 1 2039 0
 11572 615c 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
 11573 6160 1CC09DE5 		ldr	ip, [sp, #28]
 11574 6164 03005CE1 		cmp	ip, r3
 11575 6168 1400000A 		beq	.L854
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11576              		.loc 1 2040 0
 11577 616c 80449FE5 		ldr	r4, .L984+8
 11578 6170 0010E0E3 		mvn	r1, #0
 11579 6174 1C0094E5 		ldr	r0, [r4, #28]
 11580 6178 1CC08DE5 		str	ip, [sp, #28]
 11581              	.LVL1339:
 11582 617c FEFFFFEB 		bl	_txe_mutex_get
 11583              	.LVL1340:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11584              		.loc 1 2041 0
 11585 6180 1CC09DE5 		ldr	ip, [sp, #28]
 11586 6184 38209DE5 		ldr	r2, [sp, #56]
 11587 6188 00C08DE5 		str	ip, [sp]
 11588 618c 30309DE5 		ldr	r3, [sp, #48]
 11589 6190 04208DE5 		str	r2, [sp, #4]
 11590 6194 0400A0E1 		mov	r0, r4
 11591 6198 34209DE5 		ldr	r2, [sp, #52]
 11592 619c 2A10A0E3 		mov	r1, #42
 11593 61a0 FEFFFFEB 		bl	cmdSet
 11594              	.LVL1341:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11595              		.loc 1 2042 0
 11596 61a4 1C0094E5 		ldr	r0, [r4, #28]
 11597 61a8 FEFFFFEB 		bl	_txe_mutex_put
 11598              	.LVL1342:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11599              		.loc 1 2043 0
 11600 61ac 1CC09DE5 		ldr	ip, [sp, #28]
 11601 61b0 34349FE5 		ldr	r3, .L984
2044:../uvc.c      **** 									 }
 11602              		.loc 1 2044 0
 11603 61b4 38409DE5 		ldr	r4, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11604              		.loc 1 2043 0
 11605 61b8 79C7C3E5 		strb	ip, [r3, #1913]
2044:../uvc.c      **** 									 }
 11606              		.loc 1 2044 0
 11607 61bc 7A47C3E5 		strb	r4, [r3, #1914]
 11608              	.L854:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11609              		.loc 1 2046 0
 11610 61c0 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11611              		.loc 1 1836 0
 11612 61c4 0240A0E3 		mov	r4, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11613              		.loc 1 2046 0
 11614 61c8 7D37CAE5 		strb	r3, [r10, #1917]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11615              		.loc 1 1836 0
 11616 61cc 3C408DE5 		str	r4, [sp, #60]
 11617 61d0 6DFDFFEA 		b	.L856
 11618              	.LVL1343:
 11619              	.L972:
 11620              	.LBE164:
 11621              	.LBE211:
 11622              	.LBB212:
 11623              	.LBB176:
1830:../uvc.c      **** 				 }else{
 11624              		.loc 1 1830 0
 11625 61d4 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11626              		.loc 1 1836 0
 11627 61d8 0400A0E3 		mov	r0, #4
 11628              	.LVL1344:
1830:../uvc.c      **** 				 }else{
 11629              		.loc 1 1830 0
 11630 61dc 24C08DE5 		str	ip, [sp, #36]
 11631              	.LVL1345:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11632              		.loc 1 1836 0
 11633 61e0 34C09DE5 		ldr	ip, [sp, #52]
 11634 61e4 08308DE5 		str	r3, [sp, #8]
 11635 61e8 00C08DE5 		str	ip, [sp]
 11636 61ec 2CC09DE5 		ldr	ip, [sp, #44]
 11637 61f0 30309DE5 		ldr	r3, [sp, #48]
 11638 61f4 04C08DE5 		str	ip, [sp, #4]
 11639 61f8 24C09DE5 		ldr	ip, [sp, #36]
 11640 61fc 0C408DE5 		str	r4, [sp, #12]
 11641 6200 10C08DE5 		str	ip, [sp, #16]
 11642 6204 E4139FE5 		ldr	r1, .L984+4
 11643 6208 1620A0E3 		mov	r2, #22
 11644 620c FEFFFFEB 		bl	CyU3PDebugPrint
 11645              	.LVL1346:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11646              		.loc 1 2039 0
 11647 6210 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 11648 6214 030054E1 		cmp	r4, r3
 11649 6218 1100000A 		beq	.L830
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11650              		.loc 1 2040 0
 11651 621c D0539FE5 		ldr	r5, .L984+8
 11652 6220 0010E0E3 		mvn	r1, #0
 11653 6224 1C0095E5 		ldr	r0, [r5, #28]
 11654 6228 FEFFFFEB 		bl	_txe_mutex_get
 11655              	.LVL1347:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11656              		.loc 1 2041 0
 11657 622c 38C09DE5 		ldr	ip, [sp, #56]
 11658 6230 30209DE5 		ldr	r2, [sp, #48]
 11659 6234 04C08DE5 		str	ip, [sp, #4]
 11660 6238 2C309DE5 		ldr	r3, [sp, #44]
 11661 623c 1610A0E3 		mov	r1, #22
 11662 6240 00408DE5 		str	r4, [sp]
 11663 6244 0500A0E1 		mov	r0, r5
 11664 6248 FEFFFFEB 		bl	cmdSet
 11665              	.LVL1348:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11666              		.loc 1 2042 0
 11667 624c 1C0095E5 		ldr	r0, [r5, #28]
 11668 6250 FEFFFFEB 		bl	_txe_mutex_put
 11669              	.LVL1349:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11670              		.loc 1 2043 0
 11671 6254 90E39FE5 		ldr	lr, .L984
2044:../uvc.c      **** 									 }
 11672              		.loc 1 2044 0
 11673 6258 38C09DE5 		ldr	ip, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11674              		.loc 1 2043 0
 11675 625c 6547CEE5 		strb	r4, [lr, #1893]
2044:../uvc.c      **** 									 }
 11676              		.loc 1 2044 0
 11677 6260 66C7CEE5 		strb	ip, [lr, #1894]
 11678              	.L830:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11679              		.loc 1 2046 0
 11680 6264 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11681              		.loc 1 1836 0
 11682 6268 02C0A0E3 		mov	ip, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11683              		.loc 1 2046 0
 11684 626c 6937CAE5 		strb	r3, [r10, #1897]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11685              		.loc 1 1836 0
 11686 6270 3CC08DE5 		str	ip, [sp, #60]
 11687 6274 14FDFFEA 		b	.L832
 11688              	.L973:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11689              		.loc 1 2048 0
 11690 6278 74539FE5 		ldr	r5, .L984+8
 11691 627c 0010E0E3 		mvn	r1, #0
 11692 6280 1C0095E5 		ldr	r0, [r5, #28]
 11693 6284 FEFFFFEB 		bl	_txe_mutex_get
 11694              	.LVL1350:
2049:../uvc.c      **** 									 {
 11695              		.loc 1 2049 0
 11696 6288 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 11697 628c 030054E1 		cmp	r4, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11698              		.loc 1 1835 0
 11699 6290 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11700              		.loc 1 2049 0
 11701 6294 0A00000A 		beq	.L833
2052:../uvc.c      **** 										 dataIdx++;
 11702              		.loc 1 2052 0
 11703 6298 38C09DE5 		ldr	ip, [sp, #56]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11704              		.loc 1 2051 0
 11705 629c 48E39FE5 		ldr	lr, .L984
2052:../uvc.c      **** 										 dataIdx++;
 11706              		.loc 1 2052 0
 11707 62a0 00408DE5 		str	r4, [sp]
 11708 62a4 04C08DE5 		str	ip, [sp, #4]
 11709 62a8 2C309DE5 		ldr	r3, [sp, #44]
 11710 62ac 30209DE5 		ldr	r2, [sp, #48]
 11711 62b0 0500A0E1 		mov	r0, r5
 11712 62b4 1610A0E3 		mov	r1, #22
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11713              		.loc 1 2051 0
 11714 62b8 6547CEE5 		strb	r4, [lr, #1893]
2052:../uvc.c      **** 										 dataIdx++;
 11715              		.loc 1 2052 0
 11716 62bc FEFFFFEB 		bl	cmdSet
 11717              	.LVL1351:
2053:../uvc.c      **** 									 }
 11718              		.loc 1 2053 0
 11719 62c0 28309DE5 		ldr	r3, [sp, #40]
 11720              	.LVL1352:
 11721              	.L833:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11722              		.loc 1 2055 0
 11723 62c4 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
 11724 62c8 24C09DE5 		ldr	ip, [sp, #36]
 11725 62cc 02005CE1 		cmp	ip, r2
 11726 62d0 0800000A 		beq	.L834
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11727              		.loc 1 2056 0
 11728 62d4 10E39FE5 		ldr	lr, .L984
2057:../uvc.c      **** 									 }
 11729              		.loc 1 2057 0
 11730 62d8 04308DE5 		str	r3, [sp, #4]
 11731 62dc 00C08DE5 		str	ip, [sp]
 11732 62e0 34209DE5 		ldr	r2, [sp, #52]
 11733 62e4 2C309DE5 		ldr	r3, [sp, #44]
 11734              	.LVL1353:
 11735 62e8 04039FE5 		ldr	r0, .L984+8
 11736 62ec 1610A0E3 		mov	r1, #22
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11737              		.loc 1 2056 0
 11738 62f0 66C7CEE5 		strb	ip, [lr, #1894]
2057:../uvc.c      **** 									 }
 11739              		.loc 1 2057 0
 11740 62f4 FEFFFFEB 		bl	cmdSet
 11741              	.LVL1354:
 11742              	.L834:
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11743              		.loc 1 2059 0
 11744 62f8 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11745              		.loc 1 2060 0
 11746 62fc 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11747              		.loc 1 2059 0
 11748 6300 6937CAE5 		strb	r3, [r10, #1897]
2060:../uvc.c      **** 
 11749              		.loc 1 2060 0
 11750 6304 FEFFFFEB 		bl	_txe_mutex_put
 11751              	.LVL1355:
 11752 6308 EFFCFFEA 		b	.L832
 11753              	.LVL1356:
 11754              	.L977:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11755              		.loc 1 1507 0
 11756 630c 2C109DE5 		ldr	r1, [sp, #44]
 11757 6310 34009DE5 		ldr	r0, [sp, #52]
 11758 6314 20308DE5 		str	r3, [sp, #32]
 11759 6318 FEFFFFEB 		bl	SensorGetControl
 11760              	.LVL1357:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11761              		.loc 1 1509 0
 11762 631c 2C109DE5 		ldr	r1, [sp, #44]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11763              		.loc 1 1507 0
 11764 6320 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11765              		.loc 1 1509 0
 11766 6324 30009DE5 		ldr	r0, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11767              		.loc 1 1507 0
 11768 6328 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11769              		.loc 1 1508 0
 11770 632c 6527CAE5 		strb	r2, [r10, #1893]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11771              		.loc 1 1509 0
 11772 6330 FEFFFFEB 		bl	SensorGetControl
 11773              	.LVL1358:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11774              		.loc 1 1511 0
 11775 6334 0020A0E3 		mov	r2, #0
 11776 6338 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11777              		.loc 1 1512 0
 11778 633c 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11779              		.loc 1 1513 0
 11780 6340 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11781              	.LVL1359:
 11782 6344 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11783              		.loc 1 1509 0
 11784 6348 0050A0E1 		mov	r5, r0
 11785              	.LVL1360:
 11786 634c 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11787              		.loc 1 1510 0
 11788 6350 6607CAE5 		strb	r0, [r10, #1894]
 11789 6354 5FFEFFEA 		b	.L823
 11790              	.LVL1361:
 11791              	.L976:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11792              		.loc 1 1500 0
 11793 6358 30009DE5 		ldr	r0, [sp, #48]
 11794 635c 2C109DE5 		ldr	r1, [sp, #44]
 11795 6360 20308DE5 		str	r3, [sp, #32]
 11796 6364 FEFFFFEB 		bl	SensorGetControl
 11797              	.LVL1362:
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11798              		.loc 1 1502 0
 11799 6368 0050A0E3 		mov	r5, #0
 11800 636c 2950C7E5 		strb	r5, [r7, #41]
 11801 6370 20309DE5 		ldr	r3, [sp, #32]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11802              		.loc 1 1501 0
 11803 6374 6507CAE5 		strb	r0, [r10, #1893]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11804              		.loc 1 1500 0
 11805 6378 00C0A0E1 		mov	ip, r0
 11806 637c 2800C7E5 		strb	r0, [r7, #40]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11807              		.loc 1 1503 0
 11808 6380 6657CAE5 		strb	r5, [r10, #1894]
 11809              	.LVL1363:
 11810 6384 53FEFFEA 		b	.L823
 11811              	.LVL1364:
 11812              	.L971:
 11813              	.LBE176:
 11814              	.LBE212:
 11815              	.LBB213:
 11816              	.LBB188:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11817              		.loc 1 2048 0
 11818 6388 64529FE5 		ldr	r5, .L984+8
 11819 638c 0010E0E3 		mvn	r1, #0
 11820 6390 1C0095E5 		ldr	r0, [r5, #28]
 11821 6394 1CC08DE5 		str	ip, [sp, #28]
 11822              	.LVL1365:
 11823 6398 FEFFFFEB 		bl	_txe_mutex_get
 11824              	.LVL1366:
2049:../uvc.c      **** 									 {
 11825              		.loc 1 2049 0
 11826 639c 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
 11827 63a0 1CC09DE5 		ldr	ip, [sp, #28]
 11828 63a4 03005CE1 		cmp	ip, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11829              		.loc 1 1835 0
 11830 63a8 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11831              		.loc 1 2049 0
 11832 63ac 0C00000A 		beq	.L881
2052:../uvc.c      **** 										 dataIdx++;
 11833              		.loc 1 2052 0
 11834 63b0 38E09DE5 		ldr	lr, [sp, #56]
 11835 63b4 00C08DE5 		str	ip, [sp]
 11836 63b8 04E08DE5 		str	lr, [sp, #4]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11837              		.loc 1 2051 0
 11838 63bc 28E29FE5 		ldr	lr, .L984
2052:../uvc.c      **** 										 dataIdx++;
 11839              		.loc 1 2052 0
 11840 63c0 30309DE5 		ldr	r3, [sp, #48]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11841              		.loc 1 2051 0
 11842 63c4 8DC7CEE5 		strb	ip, [lr, #1933]
2052:../uvc.c      **** 										 dataIdx++;
 11843              		.loc 1 2052 0
 11844 63c8 34209DE5 		ldr	r2, [sp, #52]
 11845 63cc 0500A0E1 		mov	r0, r5
 11846 63d0 2B10A0E3 		mov	r1, #43
 11847 63d4 1CC08DE5 		str	ip, [sp, #28]
 11848 63d8 FEFFFFEB 		bl	cmdSet
 11849              	.LVL1367:
 11850 63dc 1CC09DE5 		ldr	ip, [sp, #28]
2053:../uvc.c      **** 									 }
 11851              		.loc 1 2053 0
 11852 63e0 0130A0E3 		mov	r3, #1
 11853              	.LVL1368:
 11854              	.L881:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11855              		.loc 1 2055 0
 11856 63e4 8E27DAE5 		ldrb	r2, [r10, #1934]	@ zero_extendqisi2
 11857 63e8 28009DE5 		ldr	r0, [sp, #40]
 11858 63ec 020050E1 		cmp	r0, r2
 11859 63f0 0A00000A 		beq	.L882
2057:../uvc.c      **** 									 }
 11860              		.loc 1 2057 0
 11861 63f4 0420A0E1 		mov	r2, r4
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11862              		.loc 1 2056 0
 11863 63f8 ECE19FE5 		ldr	lr, .L984
 11864 63fc 28409DE5 		ldr	r4, [sp, #40]
 11865              	.LVL1369:
2057:../uvc.c      **** 									 }
 11866              		.loc 1 2057 0
 11867 6400 09008DE8 		stmia	sp, {r0, r3}
 11868 6404 30309DE5 		ldr	r3, [sp, #48]
 11869              	.LVL1370:
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11870              		.loc 1 2056 0
 11871 6408 8E47CEE5 		strb	r4, [lr, #1934]
2057:../uvc.c      **** 									 }
 11872              		.loc 1 2057 0
 11873 640c E0019FE5 		ldr	r0, .L984+8
 11874 6410 2B10A0E3 		mov	r1, #43
 11875 6414 1CC08DE5 		str	ip, [sp, #28]
 11876 6418 FEFFFFEB 		bl	cmdSet
 11877              	.LVL1371:
 11878 641c 1CC09DE5 		ldr	ip, [sp, #28]
 11879              	.L882:
2060:../uvc.c      **** 
 11880              		.loc 1 2060 0
 11881 6420 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11882              		.loc 1 2059 0
 11883 6424 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11884              		.loc 1 2060 0
 11885 6428 1CC08DE5 		str	ip, [sp, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11886              		.loc 1 2059 0
 11887 642c 9137CAE5 		strb	r3, [r10, #1937]
2060:../uvc.c      **** 
 11888              		.loc 1 2060 0
 11889 6430 FEFFFFEB 		bl	_txe_mutex_put
 11890              	.LVL1372:
 11891 6434 1CC09DE5 		ldr	ip, [sp, #28]
 11892 6438 71FCFFEA 		b	.L880
 11893              	.LVL1373:
 11894              	.L975:
 11895              	.LBE188:
 11896              	.LBE213:
 11897              	.LBB214:
 11898              	.LBB165:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11899              		.loc 1 2048 0
 11900 643c B0519FE5 		ldr	r5, .L984+8
 11901 6440 0010E0E3 		mvn	r1, #0
 11902 6444 1C0095E5 		ldr	r0, [r5, #28]
 11903 6448 1CC08DE5 		str	ip, [sp, #28]
 11904              	.LVL1374:
 11905 644c FEFFFFEB 		bl	_txe_mutex_get
 11906              	.LVL1375:
2049:../uvc.c      **** 									 {
 11907              		.loc 1 2049 0
 11908 6450 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
 11909 6454 1CC09DE5 		ldr	ip, [sp, #28]
 11910 6458 03005CE1 		cmp	ip, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11911              		.loc 1 1835 0
 11912 645c 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11913              		.loc 1 2049 0
 11914 6460 0C00000A 		beq	.L857
2052:../uvc.c      **** 										 dataIdx++;
 11915              		.loc 1 2052 0
 11916 6464 38E09DE5 		ldr	lr, [sp, #56]
 11917 6468 00C08DE5 		str	ip, [sp]
 11918 646c 04E08DE5 		str	lr, [sp, #4]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11919              		.loc 1 2051 0
 11920 6470 74E19FE5 		ldr	lr, .L984
2052:../uvc.c      **** 										 dataIdx++;
 11921              		.loc 1 2052 0
 11922 6474 30309DE5 		ldr	r3, [sp, #48]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11923              		.loc 1 2051 0
 11924 6478 79C7CEE5 		strb	ip, [lr, #1913]
2052:../uvc.c      **** 										 dataIdx++;
 11925              		.loc 1 2052 0
 11926 647c 34209DE5 		ldr	r2, [sp, #52]
 11927 6480 0500A0E1 		mov	r0, r5
 11928 6484 2A10A0E3 		mov	r1, #42
 11929 6488 1CC08DE5 		str	ip, [sp, #28]
 11930 648c FEFFFFEB 		bl	cmdSet
 11931              	.LVL1376:
2053:../uvc.c      **** 									 }
 11932              		.loc 1 2053 0
 11933 6490 2C309DE5 		ldr	r3, [sp, #44]
 11934 6494 1CC09DE5 		ldr	ip, [sp, #28]
 11935              	.LVL1377:
 11936              	.L857:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11937              		.loc 1 2055 0
 11938 6498 7A27DAE5 		ldrb	r2, [r10, #1914]	@ zero_extendqisi2
 11939 649c 28009DE5 		ldr	r0, [sp, #40]
 11940 64a0 020050E1 		cmp	r0, r2
 11941 64a4 0A00000A 		beq	.L858
2057:../uvc.c      **** 									 }
 11942              		.loc 1 2057 0
 11943 64a8 0420A0E1 		mov	r2, r4
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11944              		.loc 1 2056 0
 11945 64ac 38E19FE5 		ldr	lr, .L984
 11946 64b0 28409DE5 		ldr	r4, [sp, #40]
 11947              	.LVL1378:
2057:../uvc.c      **** 									 }
 11948              		.loc 1 2057 0
 11949 64b4 09008DE8 		stmia	sp, {r0, r3}
 11950 64b8 30309DE5 		ldr	r3, [sp, #48]
 11951              	.LVL1379:
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11952              		.loc 1 2056 0
 11953 64bc 7A47CEE5 		strb	r4, [lr, #1914]
2057:../uvc.c      **** 									 }
 11954              		.loc 1 2057 0
 11955 64c0 2C019FE5 		ldr	r0, .L984+8
 11956 64c4 2A10A0E3 		mov	r1, #42
 11957 64c8 1CC08DE5 		str	ip, [sp, #28]
 11958 64cc FEFFFFEB 		bl	cmdSet
 11959              	.LVL1380:
 11960 64d0 1CC09DE5 		ldr	ip, [sp, #28]
 11961              	.L858:
2060:../uvc.c      **** 
 11962              		.loc 1 2060 0
 11963 64d4 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11964              		.loc 1 2059 0
 11965 64d8 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11966              		.loc 1 2060 0
 11967 64dc 1CC08DE5 		str	ip, [sp, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11968              		.loc 1 2059 0
 11969 64e0 7D37CAE5 		strb	r3, [r10, #1917]
2060:../uvc.c      **** 
 11970              		.loc 1 2060 0
 11971 64e4 FEFFFFEB 		bl	_txe_mutex_put
 11972              	.LVL1381:
 11973 64e8 1CC09DE5 		ldr	ip, [sp, #28]
 11974 64ec A6FCFFEA 		b	.L856
 11975              	.LVL1382:
 11976              	.L981:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11977              		.loc 1 1507 0
 11978 64f0 0400A0E1 		mov	r0, r4
 11979 64f4 30109DE5 		ldr	r1, [sp, #48]
 11980 64f8 20308DE5 		str	r3, [sp, #32]
 11981 64fc FEFFFFEB 		bl	SensorGetControl
 11982              	.LVL1383:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11983              		.loc 1 1509 0
 11984 6500 30109DE5 		ldr	r1, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11985              		.loc 1 1507 0
 11986 6504 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11987              		.loc 1 1509 0
 11988 6508 34009DE5 		ldr	r0, [sp, #52]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11989              		.loc 1 1507 0
 11990 650c 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11991              		.loc 1 1508 0
 11992 6510 7927CAE5 		strb	r2, [r10, #1913]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11993              		.loc 1 1509 0
 11994 6514 FEFFFFEB 		bl	SensorGetControl
 11995              	.LVL1384:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11996              		.loc 1 1511 0
 11997 6518 0020A0E3 		mov	r2, #0
 11998 651c 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11999              		.loc 1 1512 0
 12000 6520 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12001              		.loc 1 1513 0
 12002 6524 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 12003              	.LVL1385:
 12004 6528 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12005              		.loc 1 1509 0
 12006 652c 0040A0E1 		mov	r4, r0
 12007              	.LVL1386:
 12008 6530 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12009              		.loc 1 1510 0
 12010 6534 7A07CAE5 		strb	r0, [r10, #1914]
 12011 6538 8FFEFFEA 		b	.L847
 12012              	.LVL1387:
 12013              	.L978:
 12014              	.LBE165:
 12015              	.LBE214:
 12016              	.LBB215:
 12017              	.LBB189:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12018              		.loc 1 1500 0
 12019 653c 34009DE5 		ldr	r0, [sp, #52]
 12020 6540 30109DE5 		ldr	r1, [sp, #48]
 12021 6544 20308DE5 		str	r3, [sp, #32]
 12022 6548 FEFFFFEB 		bl	SensorGetControl
 12023              	.LVL1388:
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12024              		.loc 1 1501 0
 12025 654c 98E09FE5 		ldr	lr, .L984
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12026              		.loc 1 1502 0
 12027 6550 0040A0E3 		mov	r4, #0
 12028              	.LVL1389:
 12029 6554 2940C7E5 		strb	r4, [r7, #41]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12030              		.loc 1 1501 0
 12031 6558 8D07CEE5 		strb	r0, [lr, #1933]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12032              		.loc 1 1503 0
 12033 655c 8E47CEE5 		strb	r4, [lr, #1934]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12034              		.loc 1 1500 0
 12035 6560 0050A0E1 		mov	r5, r0
 12036              	.LVL1390:
 12037 6564 2800C7E5 		strb	r0, [r7, #40]
 12038 6568 20309DE5 		ldr	r3, [sp, #32]
 12039 656c 43FEFFEA 		b	.L871
 12040              	.LVL1391:
 12041              	.L980:
 12042              	.LBE189:
 12043              	.LBE215:
 12044              	.LBB216:
 12045              	.LBB166:
 12046 6570 34009DE5 		ldr	r0, [sp, #52]
 12047 6574 30109DE5 		ldr	r1, [sp, #48]
 12048 6578 20308DE5 		str	r3, [sp, #32]
 12049 657c FEFFFFEB 		bl	SensorGetControl
 12050              	.LVL1392:
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12051              		.loc 1 1502 0
 12052 6580 0040A0E3 		mov	r4, #0
 12053              	.LVL1393:
 12054 6584 2940C7E5 		strb	r4, [r7, #41]
 12055 6588 20309DE5 		ldr	r3, [sp, #32]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12056              		.loc 1 1501 0
 12057 658c 7907CAE5 		strb	r0, [r10, #1913]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12058              		.loc 1 1500 0
 12059 6590 0050A0E1 		mov	r5, r0
 12060 6594 2800C7E5 		strb	r0, [r7, #40]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12061              		.loc 1 1503 0
 12062 6598 7A47CAE5 		strb	r4, [r10, #1914]
 12063              	.LVL1394:
 12064 659c 76FEFFEA 		b	.L847
 12065              	.LVL1395:
 12066              	.L979:
 12067              	.LBE166:
 12068              	.LBE216:
 12069              	.LBB217:
 12070              	.LBB190:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12071              		.loc 1 1507 0
 12072 65a0 0400A0E1 		mov	r0, r4
 12073 65a4 30109DE5 		ldr	r1, [sp, #48]
 12074 65a8 20308DE5 		str	r3, [sp, #32]
 12075 65ac FEFFFFEB 		bl	SensorGetControl
 12076              	.LVL1396:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12077              		.loc 1 1509 0
 12078 65b0 30109DE5 		ldr	r1, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12079              		.loc 1 1507 0
 12080 65b4 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12081              		.loc 1 1509 0
 12082 65b8 34009DE5 		ldr	r0, [sp, #52]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12083              		.loc 1 1507 0
 12084 65bc 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12085              		.loc 1 1508 0
 12086 65c0 8D27CAE5 		strb	r2, [r10, #1933]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12087              		.loc 1 1509 0
 12088 65c4 FEFFFFEB 		bl	SensorGetControl
 12089              	.LVL1397:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12090              		.loc 1 1511 0
 12091 65c8 0020A0E3 		mov	r2, #0
 12092 65cc 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12093              		.loc 1 1512 0
 12094 65d0 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12095              		.loc 1 1513 0
 12096 65d4 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 12097              	.LVL1398:
 12098 65d8 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12099              		.loc 1 1509 0
 12100 65dc 0040A0E1 		mov	r4, r0
 12101              	.LVL1399:
 12102 65e0 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12103              		.loc 1 1510 0
 12104 65e4 8E07CAE5 		strb	r0, [r10, #1934]
 12105 65e8 24FEFFEA 		b	.L871
 12106              	.L985:
 12107              		.align	2
 12108              	.L984:
 12109 65ec 00000000 		.word	.LANCHOR1
 12110 65f0 68040000 		.word	.LC27
 12111 65f4 00000000 		.word	cmdQu
 12112              	.LBE190:
 12113              	.LBE217:
 12114              	.LBE228:
 12115              	.LBE409:
 12116              		.cfi_endproc
 12117              	.LFE25:
 12119              		.align	2
 12120              		.global	CyFxGpifCB
 12122              	CyFxGpifCB:
 12123              	.LFB13:
3031:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12124              		.loc 1 3031 0
 12125              		.cfi_startproc
 12126              		@ args = 0, pretend = 0, frame = 0
 12127              		@ frame_needed = 0, uses_anonymous_args = 0
3032:../uvc.c      ****     {
 12128              		.loc 1 3032 0
 12129 65f8 010050E3 		cmp	r0, #1
3031:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12130              		.loc 1 3031 0
 12131 65fc 10402DE9 		stmfd	sp!, {r4, lr}
 12132              	.LCFI29:
 12133              		.cfi_def_cfa_offset 8
 12134              		.cfi_offset 4, -8
 12135              		.cfi_offset 14, -4
3032:../uvc.c      ****     {
 12136              		.loc 1 3032 0
 12137 6600 1080BD18 		ldmnefd	sp!, {r4, pc}
 12138              	.LBB414:
 12139              	.LBB415:
2929:../uvc.c      ****     {
 12140              		.loc 1 2929 0
 12141 6604 C4309FE5 		ldr	r3, .L1003
 12142 6608 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12143 660c 030053E3 		cmp	r3, #3
 12144 6610 1000000A 		beq	.L1002
2955:../uvc.c      ****     {
 12145              		.loc 1 2955 0
 12146 6614 020053E3 		cmp	r3, #2
 12147 6618 1080BD18 		ldmnefd	sp!, {r4, pc}
2957:../uvc.c      ****         {
 12148              		.loc 1 2957 0
 12149 661c 083041E2 		sub	r3, r1, #8
 12150 6620 0A0053E3 		cmp	r3, #10
 12151 6624 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12152 6628 200000EA 		b	.L995
 12153              	.L997:
 12154 662c A8660000 		.word	.L990
 12155 6630 B0660000 		.word	.L995
 12156 6634 B0660000 		.word	.L995
 12157 6638 78660000 		.word	.L986
 12158 663c B0660000 		.word	.L995
 12159 6640 B0660000 		.word	.L995
 12160 6644 B0660000 		.word	.L995
 12161 6648 7C660000 		.word	.L1001
 12162 664c B0660000 		.word	.L995
 12163 6650 B0660000 		.word	.L995
 12164 6654 78660000 		.word	.L986
 12165              	.L1002:
2931:../uvc.c      ****         {
 12166              		.loc 1 2931 0
 12167 6658 0B1041E2 		sub	r1, r1, #11
 12168 665c 030051E3 		cmp	r1, #3
 12169 6660 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12170 6664 150000EA 		b	.L989
 12171              	.L991:
 12172 6668 A8660000 		.word	.L990
 12173 666c 7C660000 		.word	.L1001
 12174 6670 78660000 		.word	.L986
 12175 6674 78660000 		.word	.L986
 12176              	.L986:
 12177 6678 1080BDE8 		ldmfd	sp!, {r4, pc}
 12178              	.L1001:
2957:../uvc.c      ****         {
 12179              		.loc 1 2957 0
 12180 667c 0110A0E3 		mov	r1, #1
 12181              	.L992:
3014:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12182              		.loc 1 3014 0
 12183 6680 4C009FE5 		ldr	r0, .L1003+4
 12184 6684 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3015:../uvc.c      ****         {
 12185              		.loc 1 3015 0
 12186 6688 004050E2 		subs	r4, r0, #0
 12187 668c 1080BD08 		ldmeqfd	sp!, {r4, pc}
3017:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12188              		.loc 1 3017 0
 12189 6690 0400A0E3 		mov	r0, #4
 12190 6694 3C109FE5 		ldr	r1, .L1003+8
 12191 6698 0420A0E1 		mov	r2, r4
 12192 669c FEFFFFEB 		bl	CyU3PDebugPrint
3018:../uvc.c      ****         }
 12193              		.loc 1 3018 0
 12194 66a0 0400A0E1 		mov	r0, r4
 12195 66a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 12196              	.L990:
2931:../uvc.c      ****         {
 12197              		.loc 1 2931 0
 12198 66a8 0010A0E3 		mov	r1, #0
 12199 66ac F3FFFFEA 		b	.L992
 12200              	.L995:
3003:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12201              		.loc 1 3003 0
 12202 66b0 0120A0E1 		mov	r2, r1
 12203 66b4 0100A0E3 		mov	r0, #1
 12204 66b8 1C109FE5 		ldr	r1, .L1003+12
 12205 66bc FEFFFFEB 		bl	CyU3PDebugPrint
 12206              	.L989:
 12207              	.LBE415:
 12208              	.LBE414:
 12209              	.LBB416:
 12210              	.LBB417:
3038:../uvc.c      ****     }
 12211              		.loc 1 3038 0
 12212 66c0 0400A0E3 		mov	r0, #4
 12213 66c4 14109FE5 		ldr	r1, .L1003+16
 12214              	.LBE417:
 12215              	.LBE416:
3041:../uvc.c      **** 
 12216              		.loc 1 3041 0
 12217 66c8 1040BDE8 		ldmfd	sp!, {r4, lr}
 12218              	.LBB419:
 12219              	.LBB418:
3038:../uvc.c      ****     }
 12220              		.loc 1 3038 0
 12221 66cc FEFFFFEA 		b	CyU3PDebugPrint
 12222              	.L1004:
 12223              		.align	2
 12224              	.L1003:
 12225 66d0 00000000 		.word	.LANCHOR0
 12226 66d4 00000000 		.word	glChHandleUVCStream
 12227 66d8 3C0E0000 		.word	.LC81
 12228 66dc 240E0000 		.word	.LC80
 12229 66e0 6C0E0000 		.word	.LC82
 12230              	.LBE418:
 12231              	.LBE419:
 12232              		.cfi_endproc
 12233              	.LFE13:
 12235              		.align	2
 12236              		.global	CyFxApplicationDefine
 12238              	CyFxApplicationDefine:
 12239              	.LFB27:
5268:../uvc.c      **** }
5269:../uvc.c      **** 
5270:../uvc.c      **** 
5271:../uvc.c      **** /*
5272:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5273:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5274:../uvc.c      ****  */
5275:../uvc.c      **** void
5276:../uvc.c      **** CyFxApplicationDefine (
5277:../uvc.c      ****         void)
5278:../uvc.c      **** {
 12240              		.loc 1 5278 0
 12241              		.cfi_startproc
 12242              		@ args = 0, pretend = 0, frame = 32
 12243              		@ frame_needed = 0, uses_anonymous_args = 0
 12244              	.LVL1400:
 12245 66e4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12246              	.LCFI30:
 12247              		.cfi_def_cfa_offset 32
 12248              		.cfi_offset 4, -32
 12249              		.cfi_offset 5, -28
 12250              		.cfi_offset 6, -24
 12251              		.cfi_offset 7, -20
 12252              		.cfi_offset 8, -16
 12253              		.cfi_offset 9, -12
 12254              		.cfi_offset 10, -8
 12255              		.cfi_offset 14, -4
5279:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5280:../uvc.c      ****     uint32_t retThrdCreate;
5281:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5282:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5283:../uvc.c      **** 
5284:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5285:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12256              		.loc 1 5285 0
 12257 66e8 010AA0E3 		mov	r0, #4096
5278:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12258              		.loc 1 5278 0
 12259 66ec 40D04DE2 		sub	sp, sp, #64
 12260              	.LCFI31:
 12261              		.cfi_def_cfa_offset 96
 12262              		.loc 1 5285 0
 12263 66f0 FEFFFFEB 		bl	CyU3PMemAlloc
 12264              	.LVL1401:
 12265 66f4 0070A0E1 		mov	r7, r0
 12266              	.LVL1402:
5286:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12267              		.loc 1 5286 0
 12268 66f8 010AA0E3 		mov	r0, #4096
 12269              	.LVL1403:
 12270 66fc FEFFFFEB 		bl	CyU3PMemAlloc
 12271              	.LVL1404:
 12272 6700 0060A0E1 		mov	r6, r0
 12273              	.LVL1405:
5287:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12274              		.loc 1 5287 0
 12275 6704 010AA0E3 		mov	r0, #4096
 12276              	.LVL1406:
 12277 6708 FEFFFFEB 		bl	CyU3PMemAlloc
 12278              	.LVL1407:
5288:../uvc.c      **** 
5289:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12279              		.loc 1 5289 0
 12280 670c 000056E3 		cmp	r6, #0
 12281 6710 00005713 		cmpne	r7, #0
 12282 6714 00A0A013 		movne	r10, #0
 12283 6718 01A0A003 		moveq	r10, #1
5287:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12284              		.loc 1 5287 0
 12285 671c 0090A0E1 		mov	r9, r0
 12286              	.LVL1408:
 12287              		.loc 1 5289 0
 12288 6720 0000001A 		bne	.L1016
 12289              	.LVL1409:
 12290              	.L1006:
 12291              	.L1008:
 12292 6724 FEFFFFEA 		b	.L1008
 12293              	.LVL1410:
 12294              	.L1016:
 12295              		.loc 1 5289 0 is_stmt 0 discriminator 1
 12296 6728 000050E3 		cmp	r0, #0
 12297 672c FCFFFF0A 		beq	.L1006
 12298              	.LVL1411:
5290:../uvc.c      ****         goto fatalErrorHandler;
5291:../uvc.c      **** 
5292:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5293:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5294:../uvc.c      ****     char *staName = "I2CstaQue";
5295:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12299              		.loc 1 5295 0 is_stmt 1
 12300 6730 F4309FE5 		ldr	r3, .L1017
 12301 6734 20008DE2 		add	r0, sp, #32
 12302              	.LVL1412:
 12303 6738 00308DE5 		str	r3, [sp]
 12304 673c 4010A0E3 		mov	r1, #64
 12305 6740 E8209FE5 		ldr	r2, .L1017+4
 12306 6744 0A30A0E1 		mov	r3, r10
 12307 6748 FEFFFFEB 		bl	cmdbufCreate
 12308              	.LVL1413:
 12309 674c 20E08DE2 		add	lr, sp, #32
 12310 6750 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12311 6754 D8C09FE5 		ldr	ip, .L1017+8
5296:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5297:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5298:../uvc.c      **** 
5299:../uvc.c      **** 	/****** initialize command descriptor ***********/
5300:../uvc.c      **** 	cmdquInit(cmdQuptr);
5301:../uvc.c      **** 	cmdquInit(statQuptr);
5302:../uvc.c      **** 
5303:../uvc.c      ****     /* Create the UVC application thread. */
5304:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12312              		.loc 1 5304 0
 12313 6758 0840A0E3 		mov	r4, #8
5295:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12314              		.loc 1 5295 0
 12315 675c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12316 6760 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12317              		.loc 1 5304 0
 12318 6764 0150A0E3 		mov	r5, #1
5295:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12319              		.loc 1 5295 0
 12320 6768 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5300:../uvc.c      **** 	cmdquInit(statQuptr);
 12321              		.loc 1 5300 0
 12322 676c 10004CE2 		sub	r0, ip, #16
 12323 6770 FEFFFFEB 		bl	cmdquInit
 12324              	.LVL1414:
5301:../uvc.c      **** 
 12325              		.loc 1 5301 0
 12326 6774 BC009FE5 		ldr	r0, .L1017+12
 12327 6778 FEFFFFEB 		bl	cmdquInit
 12328              	.LVL1415:
 12329              		.loc 1 5304 0
 12330 677c A880A0E3 		mov	r8, #168
 12331 6780 012AA0E3 		mov	r2, #4096
 12332 6784 0A30A0E1 		mov	r3, r10
 12333 6788 14008DE9 		stmib	sp, {r2, r4}
 12334 678c A8009FE5 		ldr	r0, .L1017+16
 12335 6790 00708DE5 		str	r7, [sp]
 12336 6794 10A08DE5 		str	r10, [sp, #16]
 12337 6798 0C408DE5 		str	r4, [sp, #12]
 12338 679c 14508DE5 		str	r5, [sp, #20]
 12339 67a0 18808DE5 		str	r8, [sp, #24]
 12340 67a4 94109FE5 		ldr	r1, .L1017+20
 12341 67a8 94209FE5 		ldr	r2, .L1017+24
 12342 67ac FEFFFFEB 		bl	_txe_thread_create
 12343              	.LVL1416:
5305:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5306:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5307:../uvc.c      ****             0,                                          /* No input parameter to thread */
5308:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5309:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5310:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5311:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5312:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5313:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5314:../uvc.c      ****             );
5315:../uvc.c      ****     if (retThrdCreate != 0)
 12344              		.loc 1 5315 0
 12345 67b0 003050E2 		subs	r3, r0, #0
 12346 67b4 DAFFFF1A 		bne	.L1006
5316:../uvc.c      ****     {
5317:../uvc.c      ****         goto fatalErrorHandler;
5318:../uvc.c      ****     }
5319:../uvc.c      **** 
5320:../uvc.c      ****     /* Create the control request handling thread. */
5321:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12347              		.loc 1 5321 0
 12348 67b8 027BA0E3 		mov	r7, #2048
 12349              	.LVL1417:
 12350 67bc 10308DE5 		str	r3, [sp, #16]
 12351 67c0 00608DE5 		str	r6, [sp]
 12352 67c4 08408DE5 		str	r4, [sp, #8]
 12353 67c8 0C408DE5 		str	r4, [sp, #12]
 12354 67cc 14508DE5 		str	r5, [sp, #20]
 12355 67d0 18808DE5 		str	r8, [sp, #24]
 12356 67d4 04708DE5 		str	r7, [sp, #4]
 12357 67d8 68009FE5 		ldr	r0, .L1017+28
 12358              	.LVL1418:
 12359 67dc 68109FE5 		ldr	r1, .L1017+32
 12360 67e0 68209FE5 		ldr	r2, .L1017+36
 12361 67e4 FEFFFFEB 		bl	_txe_thread_create
 12362              	.LVL1419:
5322:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5323:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5324:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5325:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5326:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5327:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5328:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5329:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5330:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5331:../uvc.c      ****             );
5332:../uvc.c      ****     if (retThrdCreate != 0)
 12363              		.loc 1 5332 0
 12364 67e8 003050E2 		subs	r3, r0, #0
 12365 67ec CCFFFF1A 		bne	.L1006
5333:../uvc.c      ****     {
5334:../uvc.c      ****         goto fatalErrorHandler;
5335:../uvc.c      ****     }
5336:../uvc.c      **** #if 1
5337:../uvc.c      ****     /* Create the I2C control command handling thread. */
5338:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12366              		.loc 1 5338 0
 12367 67f0 00908DE5 		str	r9, [sp]
 12368 67f4 04708DE5 		str	r7, [sp, #4]
 12369 67f8 08408DE5 		str	r4, [sp, #8]
 12370 67fc 0C408DE5 		str	r4, [sp, #12]
 12371 6800 10308DE5 		str	r3, [sp, #16]
 12372 6804 14508DE5 		str	r5, [sp, #20]
 12373 6808 18808DE5 		str	r8, [sp, #24]
 12374 680c 40009FE5 		ldr	r0, .L1017+40
 12375              	.LVL1420:
 12376 6810 40109FE5 		ldr	r1, .L1017+44
 12377 6814 40209FE5 		ldr	r2, .L1017+48
 12378 6818 FEFFFFEB 		bl	_txe_thread_create
 12379              	.LVL1421:
5339:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5340:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5341:../uvc.c      ****             0,                                          /* No input parameter to thread */
5342:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5343:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5344:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5345:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5346:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5347:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5348:../uvc.c      ****             );
5349:../uvc.c      ****     if (retThrdCreate != 0)
 12380              		.loc 1 5349 0
 12381 681c 000050E3 		cmp	r0, #0
 12382 6820 BFFFFF1A 		bne	.L1006
5350:../uvc.c      ****     {
5351:../uvc.c      ****         goto fatalErrorHandler;
5352:../uvc.c      ****     }
5353:../uvc.c      **** #endif
5354:../uvc.c      **** 
5355:../uvc.c      ****     return;
5356:../uvc.c      **** 
5357:../uvc.c      **** fatalErrorHandler:
5358:../uvc.c      ****     /* Add custom recovery or debug actions here */
5359:../uvc.c      ****     /* Loop indefinitely */
5360:../uvc.c      ****     while (1);
5361:../uvc.c      **** }
 12383              		.loc 1 5361 0
 12384 6824 40D08DE2 		add	sp, sp, #64
 12385              		@ sp needed
 12386 6828 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12387              	.LVL1422:
 12388              	.L1018:
 12389              		.align	2
 12390              	.L1017:
 12391 682c 00000000 		.word	cmdQuMux
 12392 6830 840E0000 		.word	.LC83
 12393 6834 00000000 		.word	cmdQu
 12394 6838 00000000 		.word	statQu
 12395 683c A4000000 		.word	.LANCHOR0+164
 12396 6840 900E0000 		.word	.LC84
 12397 6844 00000000 		.word	UVCAppThread_Entry
 12398 6848 4C010000 		.word	.LANCHOR0+332
 12399 684c A40E0000 		.word	.LC85
 12400 6850 00000000 		.word	UVCAppEP0Thread_Entry
 12401 6854 F4010000 		.word	.LANCHOR0+500
 12402 6858 BC0E0000 		.word	.LC86
 12403 685c 00000000 		.word	I2cAppThread_Entry
 12404              		.cfi_endproc
 12405              	.LFE27:
 12407              		.section	.text.startup,"ax",%progbits
 12408              		.align	2
 12409              		.global	main
 12411              	main:
 12412              	.LFB28:
5362:../uvc.c      **** 
5363:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5364:../uvc.c      ****  * the ThreadX RTOS here.
5365:../uvc.c      ****  */
5366:../uvc.c      **** int
5367:../uvc.c      **** main (
5368:../uvc.c      ****         void)
5369:../uvc.c      **** {
 12413              		.loc 1 5369 0
 12414              		.cfi_startproc
 12415              		@ args = 0, pretend = 0, frame = 56
 12416              		@ frame_needed = 0, uses_anonymous_args = 0
 12417 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12418              	.LCFI32:
 12419              		.cfi_def_cfa_offset 12
 12420              		.cfi_offset 4, -12
 12421              		.cfi_offset 5, -8
 12422              		.cfi_offset 14, -4
 12423 0004 3CD04DE2 		sub	sp, sp, #60
 12424              	.LCFI33:
 12425              		.cfi_def_cfa_offset 72
5370:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5371:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5372:../uvc.c      **** 
5373:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5374:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5375:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12426              		.loc 1 5375 0
 12427 0008 0230A0E3 		mov	r3, #2
5376:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5377:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5378:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12428              		.loc 1 5378 0
 12429 000c 0010A0E3 		mov	r1, #0
5379:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12430              		.loc 1 5379 0
 12431 0010 0320A0E3 		mov	r2, #3
5374:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12432              		.loc 1 5374 0
 12433 0014 0150A0E3 		mov	r5, #1
5380:../uvc.c      **** 
5381:../uvc.c      ****     /* Initialize the device */
5382:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12434              		.loc 1 5382 0
 12435 0018 0D00A0E1 		mov	r0, sp
5374:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12436              		.loc 1 5374 0
 12437 001c 00508DE5 		str	r5, [sp]
5375:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12438              		.loc 1 5375 0
 12439 0020 0430CDE5 		strb	r3, [sp, #4]
5376:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12440              		.loc 1 5376 0
 12441 0024 0530CDE5 		strb	r3, [sp, #5]
5377:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12442              		.loc 1 5377 0
 12443 0028 0630CDE5 		strb	r3, [sp, #6]
5378:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12444              		.loc 1 5378 0
 12445 002c 08108DE5 		str	r1, [sp, #8]
5379:../uvc.c      **** 
 12446              		.loc 1 5379 0
 12447 0030 0C20CDE5 		strb	r2, [sp, #12]
 12448              		.loc 1 5382 0
 12449 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12450              	.LVL1423:
5383:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12451              		.loc 1 5383 0
 12452 0038 004050E2 		subs	r4, r0, #0
 12453 003c 0000000A 		beq	.L1024
 12454              	.L1020:
 12455              	.L1021:
 12456 0040 FEFFFFEA 		b	.L1021
 12457              	.L1024:
5384:../uvc.c      ****     {
5385:../uvc.c      ****         goto handle_fatal_error;
5386:../uvc.c      ****     }
5387:../uvc.c      **** 
5388:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5389:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12458              		.loc 1 5389 0
 12459 0044 0410A0E1 		mov	r1, r4
 12460 0048 0420A0E1 		mov	r2, r4
 12461 004c 0500A0E1 		mov	r0, r5
 12462              	.LVL1424:
 12463 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12464              	.LVL1425:
5390:../uvc.c      **** 
5391:../uvc.c      ****     /* Configure the IO matrix for the device. */
5392:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5393:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5394:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5395:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5396:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5397:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5398:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5399:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5400:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5401:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5402:../uvc.c      **** 
5403:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12465              		.loc 1 5403 0
 12466 0054 10008DE2 		add	r0, sp, #16
5393:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12467              		.loc 1 5393 0
 12468 0058 2640CDE5 		strb	r4, [sp, #38]
5394:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12469              		.loc 1 5394 0
 12470 005c 28408DE5 		str	r4, [sp, #40]
5395:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12471              		.loc 1 5395 0
 12472 0060 2C408DE5 		str	r4, [sp, #44]
5396:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12473              		.loc 1 5396 0
 12474 0064 30408DE5 		str	r4, [sp, #48]
5397:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12475              		.loc 1 5397 0
 12476 0068 34408DE5 		str	r4, [sp, #52]
5400:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12477              		.loc 1 5400 0
 12478 006c 1C408DE5 		str	r4, [sp, #28]
5401:../uvc.c      **** 
 12479              		.loc 1 5401 0
 12480 0070 20408DE5 		str	r4, [sp, #32]
5392:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12481              		.loc 1 5392 0
 12482 0074 10508DE5 		str	r5, [sp, #16]
5398:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12483              		.loc 1 5398 0
 12484 0078 14508DE5 		str	r5, [sp, #20]
5399:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12485              		.loc 1 5399 0
 12486 007c 18508DE5 		str	r5, [sp, #24]
 12487              		.loc 1 5403 0
 12488 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12489              	.LVL1426:
5404:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12490              		.loc 1 5404 0
 12491 0084 004050E2 		subs	r4, r0, #0
 12492 0088 ECFFFF1A 		bne	.L1020
5405:../uvc.c      ****     {
5406:../uvc.c      ****         goto handle_fatal_error;
5407:../uvc.c      ****     }
5408:../uvc.c      **** 
5409:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5410:../uvc.c      ****     CyU3PKernelEntry ();
 12493              		.loc 1 5410 0
 12494 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12495              	.LVL1427:
5411:../uvc.c      **** 
5412:../uvc.c      ****     /* Dummy return to make the compiler happy */
5413:../uvc.c      ****     return 0;
5414:../uvc.c      **** 
5415:../uvc.c      **** handle_fatal_error:
5416:../uvc.c      ****     /* Cannot recover from this error. */
5417:../uvc.c      ****     while (1);
5418:../uvc.c      **** }
 12496              		.loc 1 5418 0
 12497 0090 0400A0E1 		mov	r0, r4
 12498 0094 3CD08DE2 		add	sp, sp, #60
 12499              		@ sp needed
 12500 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12501              		.cfi_endproc
 12502              	.LFE28:
 12504              		.comm	I2CCmdTimer,44,4
 12505              		.comm	posTick,4,4
 12506              		.global	glUVCHeader
 12507              		.global	glProbeStilCtrl20
 12508              		.global	glProbeCtrl20
 12509              		.global	glProbeStilCtrl
 12510              		.global	glProbeCtrlFull
 12511              		.global	glProbeCtrl
 12512              		.global	streamingStarted
 12513              		.global	clearFeatureRqtReceived
 12514              		.global	usbSpeed
 12515              		.global	isUsbConnected
 12516              		.global	pbcpbak
 12517              		.global	pbcbak
 12518              		.global	pbbak
 12519              		.global	fbbak
 12520              		.global	pbc
 12521              		.global	pb
 12522              		.global	fb
 12523              		.comm	wLength,2,2
 12524              		.comm	wIndex,2,2
 12525              		.comm	wValue,2,2
 12526              		.comm	bRequest,1,1
 12527              		.comm	bmReqType,1,1
 12528              		.comm	imgHdMux,56,4
 12529              		.comm	timMux,56,4
 12530              		.comm	staQuMux,56,4
 12531              		.comm	cmdQuMux,56,4
 12532              		.comm	statQu,32,4
 12533              		.comm	cmdQu,32,4
 12534              		.global	testSnap
 12535              		.global	snapButFlag
 12536              		.comm	glInterStaBuffer,4,4
 12537              		.comm	glChHandleInterStat,172,4
 12538              		.comm	glChHandleStillStream,232,4
 12539              		.comm	glChHandleUVCStream,232,4
 12540              		.global	CyFxGpifConfig_usb2
 12541              		.global	CyFxGpifRegValue_usb2
 12542              		.global	CyFxGpifWavedataPosition_usb2
 12543              		.global	CyFxGpifWavedata_usb2
 12544              		.global	CyFxGpifTransition_usb2
 12545              		.global	CyFxGpifConfig
 12546              		.global	CyFxGpifRegValue
 12547              		.global	CyFxGpifWavedataPosition
 12548              		.global	CyFxGpifWavedata
 12549              		.global	CyFxGpifTransition
 12550              		.section	.rodata
 12551              		.align	2
 12552              		.set	.LANCHOR2,. + 0
 12555              	ShutSp:
 12556 0000 3582     		.short	-32203
 12557 0002 1B41     		.short	16667
 12558 0004 8D20     		.short	8333
 12559 0006 A00F     		.short	4000
 12560 0008 D007     		.short	2000
 12561 000a E803     		.short	1000
 12562 000c F401     		.short	500
 12563 000e C800     		.short	200
 12564 0010 6400     		.short	100
 12565 0012 0A00     		.short	10
 12566 0014 0000     		.short	0
 12567 0016 00000000 		.space	10
 12567      00000000 
 12567      0000
 12570              	pEXTSenCtrl:
 12571 0020 B0050000 		.word	EXTShutter
 12572 0024 E8080000 		.word	EXTSensUp
 12573 0028 D4080000 		.word	EXTMirror
 12574 002c C0080000 		.word	EXT3DnoiseReduceMode
 12575 0030 AC080000 		.word	EXT3DNoiseLev
 12576 0034 98080000 		.word	EXTDayNightMode
 12577 0038 58070000 		.word	EXTDayNightdely
 12578 003c 84080000 		.word	EXTDayNightlev
 12579 0040 70080000 		.word	EXTNightDaylev
 12580 0044 0C050000 		.word	EXTAexModGainlev
 12581 0048 5C080000 		.word	EXTExpReflev
 12582 004c C4050000 		.word	EXTShutlev
 12583 0050 48080000 		.word	EXTCamMode
 12584 0054 00000000 		.word	0
 12585 0058 34080000 		.word	EXTSensorPare
 12586 005c 20080000 		.word	EXTI2Ccmd
 12587 0060 00000000 		.word	0
 12588 0064 00000000 		.word	0
 12589 0068 00000000 		.word	0
 12590 006c 00000000 		.word	0
 12591 0070 34050000 		.word	EXTBLCWinPos
 12592 0074 0C080000 		.word	EXTBLCWeight
 12593 0078 F8040000 		.word	EXTBLCGrid
 12594 007c F8070000 		.word	EXTExHyster
 12595 0080 20050000 		.word	EXTExCtrlSped
 12596 0084 E4070000 		.word	EXTEnhanceMode
 12597 0088 6C070000 		.word	EXTEnhanceGain
 12598 008c 80070000 		.word	EXTEnhanceSTED
 12599 0090 D0070000 		.word	EXT2DNRGain
 12600 0094 BC070000 		.word	EXT2DNRSTED
 12601 0098 A8070000 		.word	EXTGammaCor
 12602 009c 94070000 		.word	EXTAGCMaxLimit
 12603 00a0 00000000 		.word	0
 12604 00a4 00000000 		.space	124
 12604      00000000 
 12604      00000000 
 12604      00000000 
 12604      00000000 
 12607              	pPUCSenCtrl:
 12608 0120 9C050000 		.word	PUCBLC
 12609 0124 48050000 		.word	PUCBright
 12610 0128 4C090000 		.word	PUCContrast
 12611 012c 00000000 		.word	0
 12612 0130 70050000 		.word	PUCPLFreq
 12613 0134 5C050000 		.word	PUCHueC
 12614 0138 38090000 		.word	PUCSaturation
 12615 013c 88050000 		.word	PUCSharp
 12616 0140 00000000 		.word	0
 12617 0144 24090000 		.word	PUCWBMd
 12618 0148 00000000 		.word	0
 12619 014c 10090000 		.word	PUCWBLC
 12620 0150 00000000 		.word	0
 12621 0154 00000000 		.word	0
 12622 0158 FC080000 		.word	PUCDZoom
 12623 015c 00000000 		.word	0
 12626              	curFlag:
 12627 0160 00000000 		.space	64
 12627      00000000 
 12627      00000000 
 12627      00000000 
 12627      00000000 
 12630              	CyFxGpifConfig:
 12631 01a0 0F00     		.short	15
 12632 01a2 0000     		.space	2
 12633 01a4 00000000 		.word	CyFxGpifWavedata
 12634 01a8 00000000 		.word	CyFxGpifWavedataPosition
 12635 01ac 0500     		.short	5
 12636 01ae 0000     		.space	2
 12637 01b0 00000000 		.word	CyFxGpifTransition
 12638 01b4 4C00     		.short	76
 12639 01b6 0000     		.space	2
 12640 01b8 00000000 		.word	CyFxGpifRegValue
 12643              	CyFxGpifConfig_usb2:
 12644 01bc 9300     		.short	147
 12645 01be 0000     		.space	2
 12646 01c0 00000000 		.word	CyFxGpifWavedata_usb2
 12647 01c4 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12648 01c8 0800     		.short	8
 12649 01ca 0000     		.space	2
 12650 01cc 00000000 		.word	CyFxGpifTransition_usb2
 12651 01d0 4C00     		.short	76
 12652 01d2 0000     		.space	2
 12653 01d4 00000000 		.word	CyFxGpifRegValue_usb2
 12654              		.data
 12655              		.align	2
 12656              		.set	.LANCHOR1,. + 0
 12659              	glProbeCtrlFull:
 12660 0000 00       		.byte	0
 12661 0001 00       		.byte	0
 12662 0002 01       		.byte	1
 12663 0003 01       		.byte	1
 12664 0004 15       		.byte	21
 12665 0005 16       		.byte	22
 12666 0006 05       		.byte	5
 12667 0007 00       		.byte	0
 12668 0008 00       		.byte	0
 12669 0009 00       		.byte	0
 12670 000a 00       		.byte	0
 12671 000b 00       		.byte	0
 12672 000c 00       		.byte	0
 12673 000d 00       		.byte	0
 12674 000e 00       		.byte	0
 12675 000f 00       		.byte	0
 12676 0010 00       		.byte	0
 12677 0011 00       		.byte	0
 12678 0012 00       		.byte	0
 12679 0013 C6       		.byte	-58
 12680 0014 99       		.byte	-103
 12681 0015 00       		.byte	0
 12682 0016 00       		.byte	0
 12683 0017 40       		.byte	64
 12684 0018 00       		.byte	0
 12685 0019 00       		.byte	0
 12686 001a 0000     		.space	2
 12689              	glProbeCtrl20:
 12690 001c 00       		.byte	0
 12691 001d 00       		.byte	0
 12692 001e 01       		.byte	1
 12693 001f 01       		.byte	1
 12694 0020 80       		.byte	-128
 12695 0021 1A       		.byte	26
 12696 0022 06       		.byte	6
 12697 0023 00       		.byte	0
 12698 0024 00       		.byte	0
 12699 0025 00       		.byte	0
 12700 0026 00       		.byte	0
 12701 0027 00       		.byte	0
 12702 0028 00       		.byte	0
 12703 0029 00       		.byte	0
 12704 002a 00       		.byte	0
 12705 002b 00       		.byte	0
 12706 002c 00       		.byte	0
 12707 002d 00       		.byte	0
 12708 002e 00       		.byte	0
 12709 002f D2       		.byte	-46
 12710 0030 0F       		.byte	15
 12711 0031 00       		.byte	0
 12712 0032 00       		.byte	0
 12713 0033 40       		.byte	64
 12714 0034 00       		.byte	0
 12715 0035 00       		.byte	0
 12716 0036 0000     		.space	2
 12719              	glProbeCtrl:
 12720 0038 00       		.byte	0
 12721 0039 00       		.byte	0
 12722 003a 01       		.byte	1
 12723 003b 01       		.byte	1
 12724 003c 15       		.byte	21
 12725 003d 16       		.byte	22
 12726 003e 05       		.byte	5
 12727 003f 00       		.byte	0
 12728 0040 00       		.byte	0
 12729 0041 00       		.byte	0
 12730 0042 00       		.byte	0
 12731 0043 00       		.byte	0
 12732 0044 00       		.byte	0
 12733 0045 00       		.byte	0
 12734 0046 00       		.byte	0
 12735 0047 00       		.byte	0
 12736 0048 00       		.byte	0
 12737 0049 00       		.byte	0
 12738 004a 00       		.byte	0
 12739 004b 48       		.byte	72
 12740 004c 3F       		.byte	63
 12741 004d 00       		.byte	0
 12742 004e 00       		.byte	0
 12743 004f 40       		.byte	64
 12744 0050 00       		.byte	0
 12745 0051 00       		.byte	0
 12748              	ROIMode:
 12749 0052 01       		.byte	1
 12750 0053 00       		.space	1
 12753              	glProbeStilCtrl:
 12754 0054 01       		.byte	1
 12755 0055 02       		.byte	2
 12756 0056 00       		.byte	0
 12757 0057 00       		.byte	0
 12758 0058 C6       		.byte	-58
 12759 0059 99       		.byte	-103
 12760 005a 00       		.byte	0
 12761 005b 00       		.byte	0
 12762 005c 40       		.byte	64
 12763 005d 00       		.byte	0
 12764 005e 00       		.byte	0
 12765 005f 00       		.space	1
 12768              	glProbeStilCtrl20:
 12769 0060 01       		.byte	1
 12770 0061 01       		.byte	1
 12771 0062 00       		.byte	0
 12772 0063 00       		.byte	0
 12773 0064 D2       		.byte	-46
 12774 0065 0F       		.byte	15
 12775 0066 00       		.byte	0
 12776 0067 00       		.byte	0
 12777 0068 40       		.byte	64
 12778 0069 00       		.byte	0
 12779 006a 00       		.byte	0
 12780 006b 00       		.space	1
 12783              	ExUCtrlParArry:
 12784 006c 00       		.byte	0
 12785 006d 00       		.byte	0
 12786 006e 04       		.byte	4
 12787 006f 01       		.byte	1
 12788 0070 00       		.byte	0
 12789 0071 38       		.byte	56
 12790 0072 01       		.byte	1
 12791 0073 01       		.byte	1
 12792 0074 00       		.byte	0
 12793 0075 03       		.byte	3
 12794 0076 00       		.byte	0
 12795 0077 4E       		.byte	78
 12796 0078 00       		.byte	0
 12797 0079 4E       		.byte	78
 12798 007a 00       		.byte	0
 12799 007b 30       		.byte	48
 12800 007c 01       		.byte	1
 12801 007d 00       		.byte	0
 12802 007e 00       		.byte	0
 12803 007f 00000000 		.space	5
 12803      00
 12804 0084 00       		.byte	0
 12805 0085 00       		.byte	0
 12806 0086 01       		.byte	1
 12807 0087 00       		.byte	0
 12808 0088 00       		.byte	0
 12809 0089 00       		.byte	0
 12810 008a 00       		.byte	0
 12811 008b 01       		.byte	1
 12812 008c 00       		.byte	0
 12813 008d 03       		.byte	3
 12814 008e 00       		.byte	0
 12815 008f 00       		.byte	0
 12816 0090 00       		.byte	0
 12817 0091 00       		.byte	0
 12818 0092 00       		.byte	0
 12819 0093 30       		.byte	48
 12820 0094 01       		.byte	1
 12821 0095 00       		.byte	0
 12822 0096 00       		.byte	0
 12823 0097 00000000 		.space	5
 12823      00
 12824 009c 00       		.byte	0
 12825 009d 00       		.byte	0
 12826 009e 02       		.byte	2
 12827 009f 00       		.byte	0
 12828 00a0 00       		.byte	0
 12829 00a1 FF       		.byte	-1
 12830 00a2 00       		.byte	0
 12831 00a3 01       		.byte	1
 12832 00a4 00       		.byte	0
 12833 00a5 03       		.byte	3
 12834 00a6 00       		.byte	0
 12835 00a7 01       		.byte	1
 12836 00a8 00       		.byte	0
 12837 00a9 00       		.byte	0
 12838 00aa 00       		.byte	0
 12839 00ab 30       		.byte	48
 12840 00ac 01       		.byte	1
 12841 00ad 01       		.byte	1
 12842 00ae 00       		.byte	0
 12843 00af 00000000 		.space	5
 12843      00
 12844 00b4 00       		.byte	0
 12845 00b5 00       		.byte	0
 12846 00b6 02       		.byte	2
 12847 00b7 00       		.byte	0
 12848 00b8 00       		.byte	0
 12849 00b9 00       		.byte	0
 12850 00ba 00       		.byte	0
 12851 00bb 00       		.byte	0
 12852 00bc 00       		.byte	0
 12853 00bd 03       		.byte	3
 12854 00be 00       		.byte	0
 12855 00bf 00       		.byte	0
 12856 00c0 00       		.byte	0
 12857 00c1 00       		.byte	0
 12858 00c2 00       		.byte	0
 12859 00c3 30       		.byte	48
 12860 00c4 01       		.byte	1
 12861 00c5 01       		.byte	1
 12862 00c6 00       		.byte	0
 12863 00c7 00000000 		.space	5
 12863      00
 12864 00cc 13       		.byte	19
 12865 00cd 14       		.byte	20
 12866 00ce 02       		.byte	2
 12867 00cf 00       		.byte	0
 12868 00d0 00       		.byte	0
 12869 00d1 FF       		.byte	-1
 12870 00d2 FF       		.byte	-1
 12871 00d3 01       		.byte	1
 12872 00d4 00       		.byte	0
 12873 00d5 03       		.byte	3
 12874 00d6 00       		.byte	0
 12875 00d7 66       		.byte	102
 12876 00d8 66       		.byte	102
 12877 00d9 66       		.byte	102
 12878 00da 66       		.byte	102
 12879 00db 30       		.byte	48
 12880 00dc 01       		.byte	1
 12881 00dd 00       		.byte	0
 12882 00de 00       		.byte	0
 12883 00df 00000000 		.space	5
 12883      00
 12884 00e4 11       		.byte	17
 12885 00e5 00       		.byte	0
 12886 00e6 02       		.byte	2
 12887 00e7 01       		.byte	1
 12888 00e8 00       		.byte	0
 12889 00e9 03       		.byte	3
 12890 00ea 00       		.byte	0
 12891 00eb 01       		.byte	1
 12892 00ec 00       		.byte	0
 12893 00ed 03       		.byte	3
 12894 00ee 00       		.byte	0
 12895 00ef 80       		.byte	-128
 12896 00f0 00       		.byte	0
 12897 00f1 80       		.byte	-128
 12898 00f2 00       		.byte	0
 12899 00f3 30       		.byte	48
 12900 00f4 01       		.byte	1
 12901 00f5 01       		.byte	1
 12902 00f6 00       		.byte	0
 12903 00f7 00000000 		.space	5
 12903      00
 12904 00fc 10       		.byte	16
 12905 00fd 00       		.byte	0
 12906 00fe 01       		.byte	1
 12907 00ff 01       		.byte	1
 12908 0100 00       		.byte	0
 12909 0101 02       		.byte	2
 12910 0102 00       		.byte	0
 12911 0103 01       		.byte	1
 12912 0104 00       		.byte	0
 12913 0105 03       		.byte	3
 12914 0106 00       		.byte	0
 12915 0107 00       		.byte	0
 12916 0108 00       		.byte	0
 12917 0109 00       		.byte	0
 12918 010a 00       		.byte	0
 12919 010b 30       		.byte	48
 12920 010c 01       		.byte	1
 12921 010d 01       		.byte	1
 12922 010e 00       		.byte	0
 12923 010f 00000000 		.space	5
 12923      00
 12924 0114 00       		.byte	0
 12925 0115 00       		.byte	0
 12926 0116 04       		.byte	4
 12927 0117 01       		.byte	1
 12928 0118 00       		.byte	0
 12929 0119 38       		.byte	56
 12930 011a 01       		.byte	1
 12931 011b 01       		.byte	1
 12932 011c 00       		.byte	0
 12933 011d 03       		.byte	3
 12934 011e 00       		.byte	0
 12935 011f 4E       		.byte	78
 12936 0120 00       		.byte	0
 12937 0121 4E       		.byte	78
 12938 0122 00       		.byte	0
 12939 0123 30       		.byte	48
 12940 0124 01       		.byte	1
 12941 0125 00       		.byte	0
 12942 0126 00       		.byte	0
 12943 0127 00000000 		.space	5
 12943      00
 12944 012c 00       		.byte	0
 12945 012d 00       		.byte	0
 12946 012e 01       		.byte	1
 12947 012f 00       		.byte	0
 12948 0130 00       		.byte	0
 12949 0131 00       		.byte	0
 12950 0132 00       		.byte	0
 12951 0133 01       		.byte	1
 12952 0134 00       		.byte	0
 12953 0135 03       		.byte	3
 12954 0136 00       		.byte	0
 12955 0137 00       		.byte	0
 12956 0138 00       		.byte	0
 12957 0139 00       		.byte	0
 12958 013a 00       		.byte	0
 12959 013b 30       		.byte	48
 12960 013c 01       		.byte	1
 12961 013d 00       		.byte	0
 12962 013e 00       		.byte	0
 12963 013f 00000000 		.space	5
 12963      00
 12964 0144 00       		.byte	0
 12965 0145 00       		.byte	0
 12966 0146 02       		.byte	2
 12967 0147 00       		.byte	0
 12968 0148 00       		.byte	0
 12969 0149 05       		.byte	5
 12970 014a 00       		.byte	0
 12971 014b 01       		.byte	1
 12972 014c 00       		.byte	0
 12973 014d 03       		.byte	3
 12974 014e 00       		.byte	0
 12975 014f 00       		.byte	0
 12976 0150 00       		.byte	0
 12977 0151 00       		.byte	0
 12978 0152 00       		.byte	0
 12979 0153 30       		.byte	48
 12980 0154 01       		.byte	1
 12981 0155 00       		.byte	0
 12982 0156 00       		.byte	0
 12983 0157 00000000 		.space	5
 12983      00
 12984 015c 00       		.byte	0
 12985 015d 00       		.byte	0
 12986 015e 03       		.byte	3
 12987 015f 00       		.byte	0
 12988 0160 00       		.byte	0
 12989 0161 0A       		.byte	10
 12990 0162 00       		.byte	0
 12991 0163 01       		.byte	1
 12992 0164 00       		.byte	0
 12993 0165 03       		.byte	3
 12994 0166 00       		.byte	0
 12995 0167 00       		.byte	0
 12996 0168 00       		.byte	0
 12997 0169 00       		.byte	0
 12998 016a 00       		.byte	0
 12999 016b 30       		.byte	48
 13000 016c 01       		.byte	1
 13001 016d 00       		.byte	0
 13002 016e 00       		.byte	0
 13003 016f 00000000 		.space	5
 13003      00
 13004 0174 00       		.byte	0
 13005 0175 00       		.byte	0
 13006 0176 02       		.byte	2
 13007 0177 00       		.byte	0
 13008 0178 00       		.byte	0
 13009 0179 40       		.byte	64
 13010 017a 00       		.byte	0
 13011 017b 01       		.byte	1
 13012 017c 00       		.byte	0
 13013 017d 03       		.byte	3
 13014 017e 00       		.byte	0
 13015 017f 0F       		.byte	15
 13016 0180 11       		.byte	17
 13017 0181 00       		.byte	0
 13018 0182 00       		.byte	0
 13019 0183 30       		.byte	48
 13020 0184 01       		.byte	1
 13021 0185 00       		.byte	0
 13022 0186 00       		.byte	0
 13023 0187 00000000 		.space	5
 13023      00
 13024 018c 00       		.byte	0
 13025 018d 00       		.byte	0
 13026 018e 02       		.byte	2
 13027 018f 00       		.byte	0
 13028 0190 00       		.byte	0
 13029 0191 64       		.byte	100
 13030 0192 00       		.byte	0
 13031 0193 01       		.byte	1
 13032 0194 00       		.byte	0
 13033 0195 03       		.byte	3
 13034 0196 00       		.byte	0
 13035 0197 00       		.byte	0
 13036 0198 00       		.byte	0
 13037 0199 00       		.byte	0
 13038 019a 00       		.byte	0
 13039 019b 30       		.byte	48
 13040 019c 01       		.byte	1
 13041 019d 00       		.byte	0
 13042 019e 00       		.byte	0
 13043 019f 00000000 		.space	5
 13043      00
 13044 01a4 00       		.byte	0
 13045 01a5 00       		.byte	0
 13046 01a6 02       		.byte	2
 13047 01a7 00       		.byte	0
 13048 01a8 00       		.byte	0
 13049 01a9 64       		.byte	100
 13050 01aa 00       		.byte	0
 13051 01ab 01       		.byte	1
 13052 01ac 00       		.byte	0
 13053 01ad 03       		.byte	3
 13054 01ae 00       		.byte	0
 13055 01af 00       		.byte	0
 13056 01b0 00       		.byte	0
 13057 01b1 00       		.byte	0
 13058 01b2 00       		.byte	0
 13059 01b3 30       		.byte	48
 13060 01b4 01       		.byte	1
 13061 01b5 00       		.byte	0
 13062 01b6 00       		.byte	0
 13063 01b7 00000000 		.space	5
 13063      00
 13064 01bc 00       		.byte	0
 13065 01bd 00       		.byte	0
 13066 01be 02       		.byte	2
 13067 01bf 00       		.byte	0
 13068 01c0 00       		.byte	0
 13069 01c1 64       		.byte	100
 13070 01c2 00       		.byte	0
 13071 01c3 01       		.byte	1
 13072 01c4 00       		.byte	0
 13073 01c5 03       		.byte	3
 13074 01c6 00       		.byte	0
 13075 01c7 00       		.byte	0
 13076 01c8 00       		.byte	0
 13077 01c9 00       		.byte	0
 13078 01ca 00       		.byte	0
 13079 01cb 30       		.byte	48
 13080 01cc 01       		.byte	1
 13081 01cd 00       		.byte	0
 13082 01ce 00       		.byte	0
 13083 01cf 00000000 		.space	5
 13083      00
 13084 01d4 00       		.byte	0
 13085 01d5 00       		.byte	0
 13086 01d6 02       		.byte	2
 13087 01d7 00       		.byte	0
 13088 01d8 00       		.byte	0
 13089 01d9 64       		.byte	100
 13090 01da 00       		.byte	0
 13091 01db 01       		.byte	1
 13092 01dc 00       		.byte	0
 13093 01dd 03       		.byte	3
 13094 01de 00       		.byte	0
 13095 01df 00       		.byte	0
 13096 01e0 00       		.byte	0
 13097 01e1 00       		.byte	0
 13098 01e2 00       		.byte	0
 13099 01e3 30       		.byte	48
 13100 01e4 01       		.byte	1
 13101 01e5 00       		.byte	0
 13102 01e6 00       		.byte	0
 13103 01e7 00000000 		.space	5
 13103      00
 13106              	CtrlParArry:
 13107 01ec 10       		.byte	16
 13108 01ed 10       		.byte	16
 13109 01ee 02       		.byte	2
 13110 01ef 00       		.byte	0
 13111 01f0 00       		.byte	0
 13112 01f1 03       		.byte	3
 13113 01f2 00       		.byte	0
 13114 01f3 01       		.byte	1
 13115 01f4 00       		.byte	0
 13116 01f5 03       		.byte	3
 13117 01f6 00       		.byte	0
 13118 01f7 03       		.byte	3
 13119 01f8 00       		.byte	0
 13120 01f9 03       		.byte	3
 13121 01fa 00       		.byte	0
 13122 01fb 30       		.byte	48
 13123 01fc 01       		.byte	1
 13124 01fd 00       		.byte	0
 13125 01fe 00       		.byte	0
 13126 01ff 00000000 		.space	5
 13126      00
 13127 0204 15       		.byte	21
 13128 0205 15       		.byte	21
 13129 0206 02       		.byte	2
 13130 0207 00       		.byte	0
 13131 0208 00       		.byte	0
 13132 0209 FF       		.byte	-1
 13133 020a 00       		.byte	0
 13134 020b 01       		.byte	1
 13135 020c 00       		.byte	0
 13136 020d 03       		.byte	3
 13137 020e 00       		.byte	0
 13138 020f 76       		.byte	118
 13139 0210 00       		.byte	0
 13140 0211 76       		.byte	118
 13141 0212 C7       		.byte	-57
 13142 0213 30       		.byte	48
 13143 0214 01       		.byte	1
 13144 0215 01       		.byte	1
 13145 0216 00       		.byte	0
 13146 0217 00000000 		.space	5
 13146      00
 13147 021c 04       		.byte	4
 13148 021d 04       		.byte	4
 13149 021e 02       		.byte	2
 13150 021f 00       		.byte	0
 13151 0220 00       		.byte	0
 13152 0221 FF       		.byte	-1
 13153 0222 00       		.byte	0
 13154 0223 01       		.byte	1
 13155 0224 00       		.byte	0
 13156 0225 03       		.byte	3
 13157 0226 00       		.byte	0
 13158 0227 70       		.byte	112
 13159 0228 00       		.byte	0
 13160 0229 70       		.byte	112
 13161 022a 00       		.byte	0
 13162 022b 30       		.byte	48
 13163 022c 01       		.byte	1
 13164 022d 01       		.byte	1
 13165 022e 00       		.byte	0
 13166 022f 00000000 		.space	5
 13166      00
 13167 0234 00       		.byte	0
 13168 0235 00       		.byte	0
 13169 0236 02       		.byte	2
 13170 0237 00       		.byte	0
 13171 0238 00       		.byte	0
 13172 0239 64       		.byte	100
 13173 023a 00       		.byte	0
 13174 023b 01       		.byte	1
 13175 023c 00       		.byte	0
 13176 023d 03       		.byte	3
 13177 023e 00       		.byte	0
 13178 023f 00       		.byte	0
 13179 0240 00       		.byte	0
 13180 0241 00       		.byte	0
 13181 0242 00       		.byte	0
 13182 0243 30       		.byte	48
 13183 0244 01       		.byte	1
 13184 0245 00       		.byte	0
 13185 0246 00       		.byte	0
 13186 0247 00000000 		.space	5
 13186      00
 13187 024c 07       		.byte	7
 13188 024d 07       		.byte	7
 13189 024e 02       		.byte	2
 13190 024f 00       		.byte	0
 13191 0250 00       		.byte	0
 13192 0251 01       		.byte	1
 13193 0252 00       		.byte	0
 13194 0253 01       		.byte	1
 13195 0254 00       		.byte	0
 13196 0255 03       		.byte	3
 13197 0256 00       		.byte	0
 13198 0257 01       		.byte	1
 13199 0258 00       		.byte	0
 13200 0259 01       		.byte	1
 13201 025a 00       		.byte	0
 13202 025b 30       		.byte	48
 13203 025c 01       		.byte	1
 13204 025d 00       		.byte	0
 13205 025e 00       		.byte	0
 13206 025f 00000000 		.space	5
 13206      00
 13207 0264 DF       		.byte	-33
 13208 0265 E1       		.byte	-31
 13209 0266 02       		.byte	2
 13210 0267 00       		.byte	0
 13211 0268 00       		.byte	0
 13212 0269 FF       		.byte	-1
 13213 026a 00       		.byte	0
 13214 026b 01       		.byte	1
 13215 026c 00       		.byte	0
 13216 026d 03       		.byte	3
 13217 026e 00       		.byte	0
 13218 026f 80       		.byte	-128
 13219 0270 00       		.byte	0
 13220 0271 00       		.byte	0
 13221 0272 00       		.byte	0
 13222 0273 C6       		.byte	-58
 13223 0274 01       		.byte	1
 13224 0275 01       		.byte	1
 13225 0276 00       		.byte	0
 13226 0277 00000000 		.space	5
 13226      00
 13227 027c 85       		.byte	-123
 13228 027d 86       		.byte	-122
 13229 027e 02       		.byte	2
 13230 027f 00       		.byte	0
 13231 0280 00       		.byte	0
 13232 0281 64       		.byte	100
 13233 0282 00       		.byte	0
 13234 0283 01       		.byte	1
 13235 0284 00       		.byte	0
 13236 0285 03       		.byte	3
 13237 0286 00       		.byte	0
 13238 0287 32       		.byte	50
 13239 0288 00       		.byte	0
 13240 0289 32       		.byte	50
 13241 028a 00       		.byte	0
 13242 028b F2       		.byte	-14
 13243 028c 01       		.byte	1
 13244 028d 01       		.byte	1
 13245 028e 00       		.byte	0
 13246 028f 00000000 		.space	5
 13246      00
 13247 0294 06       		.byte	6
 13248 0295 07       		.byte	7
 13249 0296 02       		.byte	2
 13250 0297 00       		.byte	0
 13251 0298 00       		.byte	0
 13252 0299 FF       		.byte	-1
 13253 029a 00       		.byte	0
 13254 029b 01       		.byte	1
 13255 029c 00       		.byte	0
 13256 029d 03       		.byte	3
 13257 029e 00       		.byte	0
 13258 029f 20       		.byte	32
 13259 02a0 00       		.byte	0
 13260 02a1 20       		.byte	32
 13261 02a2 00       		.byte	0
 13262 02a3 30       		.byte	48
 13263 02a4 01       		.byte	1
 13264 02a5 01       		.byte	1
 13265 02a6 00       		.byte	0
 13266 02a7 00000000 		.space	5
 13266      00
 13267 02ac 00       		.byte	0
 13268 02ad 00       		.byte	0
 13269 02ae 02       		.byte	2
 13270 02af 00       		.byte	0
 13271 02b0 00       		.byte	0
 13272 02b1 64       		.byte	100
 13273 02b2 00       		.byte	0
 13274 02b3 01       		.byte	1
 13275 02b4 00       		.byte	0
 13276 02b5 03       		.byte	3
 13277 02b6 00       		.byte	0
 13278 02b7 00       		.byte	0
 13279 02b8 00       		.byte	0
 13280 02b9 00       		.byte	0
 13281 02ba 00       		.byte	0
 13282 02bb 30       		.byte	48
 13283 02bc 01       		.byte	1
 13284 02bd 00       		.byte	0
 13285 02be 00       		.byte	0
 13286 02bf 00000000 		.space	5
 13286      00
 13287 02c4 08       		.byte	8
 13288 02c5 08       		.byte	8
 13289 02c6 02       		.byte	2
 13290 02c7 00       		.byte	0
 13291 02c8 00       		.byte	0
 13292 02c9 05       		.byte	5
 13293 02ca 00       		.byte	0
 13294 02cb 01       		.byte	1
 13295 02cc 00       		.byte	0
 13296 02cd 03       		.byte	3
 13297 02ce 00       		.byte	0
 13298 02cf 00       		.byte	0
 13299 02d0 00       		.byte	0
 13300 02d1 00       		.byte	0
 13301 02d2 00       		.byte	0
 13302 02d3 30       		.byte	48
 13303 02d4 01       		.byte	1
 13304 02d5 00       		.byte	0
 13305 02d6 00       		.byte	0
 13306 02d7 00000000 		.space	5
 13306      00
 13307 02dc 00       		.byte	0
 13308 02dd 00       		.byte	0
 13309 02de 02       		.byte	2
 13310 02df 00       		.byte	0
 13311 02e0 00       		.byte	0
 13312 02e1 40       		.byte	64
 13313 02e2 00       		.byte	0
 13314 02e3 01       		.byte	1
 13315 02e4 00       		.byte	0
 13316 02e5 03       		.byte	3
 13317 02e6 00       		.byte	0
 13318 02e7 00       		.byte	0
 13319 02e8 00       		.byte	0
 13320 02e9 00       		.byte	0
 13321 02ea 00       		.byte	0
 13322 02eb 30       		.byte	48
 13323 02ec 01       		.byte	1
 13324 02ed 00       		.byte	0
 13325 02ee 00       		.byte	0
 13326 02ef 00000000 		.space	5
 13326      00
 13327 02f4 09       		.byte	9
 13328 02f5 0A       		.byte	10
 13329 02f6 04       		.byte	4
 13330 02f7 00       		.byte	0
 13331 02f8 00       		.byte	0
 13332 02f9 40       		.byte	64
 13333 02fa 00       		.byte	0
 13334 02fb 01       		.byte	1
 13335 02fc 00       		.byte	0
 13336 02fd 03       		.byte	3
 13337 02fe 00       		.byte	0
 13338 02ff 20       		.byte	32
 13339 0300 38       		.byte	56
 13340 0301 20       		.byte	32
 13341 0302 38       		.byte	56
 13342 0303 30       		.byte	48
 13343 0304 01       		.byte	1
 13344 0305 00       		.byte	0
 13345 0306 00       		.byte	0
 13346 0307 00000000 		.space	5
 13346      00
 13347 030c 00       		.byte	0
 13348 030d 00       		.byte	0
 13349 030e 02       		.byte	2
 13350 030f 00       		.byte	0
 13351 0310 00       		.byte	0
 13352 0311 64       		.byte	100
 13353 0312 00       		.byte	0
 13354 0313 01       		.byte	1
 13355 0314 00       		.byte	0
 13356 0315 03       		.byte	3
 13357 0316 00       		.byte	0
 13358 0317 00       		.byte	0
 13359 0318 00       		.byte	0
 13360 0319 00       		.byte	0
 13361 031a 00       		.byte	0
 13362 031b 30       		.byte	48
 13363 031c 01       		.byte	1
 13364 031d 00       		.byte	0
 13365 031e 00       		.byte	0
 13366 031f 00000000 		.space	5
 13366      00
 13367 0324 00       		.byte	0
 13368 0325 00       		.byte	0
 13369 0326 02       		.byte	2
 13370 0327 00       		.byte	0
 13371 0328 00       		.byte	0
 13372 0329 64       		.byte	100
 13373 032a 00       		.byte	0
 13374 032b 01       		.byte	1
 13375 032c 00       		.byte	0
 13376 032d 03       		.byte	3
 13377 032e 00       		.byte	0
 13378 032f 00       		.byte	0
 13379 0330 00       		.byte	0
 13380 0331 00       		.byte	0
 13381 0332 00       		.byte	0
 13382 0333 30       		.byte	48
 13383 0334 01       		.byte	1
 13384 0335 00       		.byte	0
 13385 0336 00       		.byte	0
 13386 0337 00000000 		.space	5
 13386      00
 13387 033c 2A       		.byte	42
 13388 033d 2A       		.byte	42
 13389 033e 02       		.byte	2
 13390 033f 00       		.byte	0
 13391 0340 00       		.byte	0
 13392 0341 1B       		.byte	27
 13393 0342 00       		.byte	0
 13394 0343 01       		.byte	1
 13395 0344 00       		.byte	0
 13396 0345 03       		.byte	3
 13397 0346 00       		.byte	0
 13398 0347 00       		.byte	0
 13399 0348 00       		.byte	0
 13400 0349 00       		.byte	0
 13401 034a 00       		.byte	0
 13402 034b 30       		.byte	48
 13403 034c 01       		.byte	1
 13404 034d 00       		.byte	0
 13405 034e 00       		.byte	0
 13406 034f 00000000 		.space	5
 13406      00
 13407 0354 00       		.byte	0
 13408 0355 00       		.byte	0
 13409 0356 02       		.byte	2
 13410 0357 00       		.byte	0
 13411 0358 00       		.byte	0
 13412 0359 64       		.byte	100
 13413 035a 00       		.byte	0
 13414 035b 01       		.byte	1
 13415 035c 00       		.byte	0
 13416 035d 03       		.byte	3
 13417 035e 00       		.byte	0
 13418 035f 00       		.byte	0
 13419 0360 00       		.byte	0
 13420 0361 00       		.byte	0
 13421 0362 00       		.byte	0
 13422 0363 30       		.byte	48
 13423 0364 01       		.byte	1
 13424 0365 00       		.byte	0
 13425 0366 00       		.byte	0
 13426 0367 00000000 		.space	5
 13426      00
 13427 036c 00       		.byte	0
 13428 036d 00       		.byte	0
 13429 036e 02       		.byte	2
 13430 036f 00       		.byte	0
 13431 0370 00       		.byte	0
 13432 0371 12       		.byte	18
 13433 0372 00       		.byte	0
 13434 0373 01       		.byte	1
 13435 0374 00       		.byte	0
 13436 0375 03       		.byte	3
 13437 0376 00       		.byte	0
 13438 0377 00       		.byte	0
 13439 0378 00       		.byte	0
 13440 0379 00       		.byte	0
 13441 037a 00       		.byte	0
 13442 037b 30       		.byte	48
 13443 037c 01       		.byte	1
 13444 037d 00       		.byte	0
 13445 037e 00       		.byte	0
 13446 037f 00000000 		.space	5
 13446      00
 13447 0384 01       		.byte	1
 13448 0385 01       		.byte	1
 13449 0386 02       		.byte	2
 13450 0387 00       		.byte	0
 13451 0388 00       		.byte	0
 13452 0389 09       		.byte	9
 13453 038a 00       		.byte	0
 13454 038b 01       		.byte	1
 13455 038c 00       		.byte	0
 13456 038d 03       		.byte	3
 13457 038e 00       		.byte	0
 13458 038f 00       		.byte	0
 13459 0390 00       		.byte	0
 13460 0391 01       		.byte	1
 13461 0392 00       		.byte	0
 13462 0393 30       		.byte	48
 13463 0394 01       		.byte	1
 13464 0395 00       		.byte	0
 13465 0396 00       		.byte	0
 13466 0397 00000000 		.space	5
 13466      00
 13467 039c 05       		.byte	5
 13468 039d 05       		.byte	5
 13469 039e 02       		.byte	2
 13470 039f 00       		.byte	0
 13471 03a0 00       		.byte	0
 13472 03a1 03       		.byte	3
 13473 03a2 00       		.byte	0
 13474 03a3 01       		.byte	1
 13475 03a4 00       		.byte	0
 13476 03a5 03       		.byte	3
 13477 03a6 00       		.byte	0
 13478 03a7 00       		.byte	0
 13479 03a8 00       		.byte	0
 13480 03a9 00       		.byte	0
 13481 03aa 00       		.byte	0
 13482 03ab 30       		.byte	48
 13483 03ac 01       		.byte	1
 13484 03ad 00       		.byte	0
 13485 03ae 00       		.byte	0
 13486 03af 00000000 		.space	5
 13486      00
 13487 03b4 18       		.byte	24
 13488 03b5 18       		.byte	24
 13489 03b6 02       		.byte	2
 13490 03b7 00       		.byte	0
 13491 03b8 00       		.byte	0
 13492 03b9 01       		.byte	1
 13493 03ba 00       		.byte	0
 13494 03bb 01       		.byte	1
 13495 03bc 00       		.byte	0
 13496 03bd 03       		.byte	3
 13497 03be 00       		.byte	0
 13498 03bf 00       		.byte	0
 13499 03c0 00       		.byte	0
 13500 03c1 00       		.byte	0
 13501 03c2 00       		.byte	0
 13502 03c3 30       		.byte	48
 13503 03c4 01       		.byte	1
 13504 03c5 00       		.byte	0
 13505 03c6 00       		.byte	0
 13506 03c7 00000000 		.space	5
 13506      00
 13507 03cc 19       		.byte	25
 13508 03cd 19       		.byte	25
 13509 03ce 01       		.byte	1
 13510 03cf 00       		.byte	0
 13511 03d0 00       		.byte	0
 13512 03d1 40       		.byte	64
 13513 03d2 00       		.byte	0
 13514 03d3 01       		.byte	1
 13515 03d4 00       		.byte	0
 13516 03d5 03       		.byte	3
 13517 03d6 00       		.byte	0
 13518 03d7 20       		.byte	32
 13519 03d8 00       		.byte	0
 13520 03d9 20       		.byte	32
 13521 03da 00       		.byte	0
 13522 03db 30       		.byte	48
 13523 03dc 01       		.byte	1
 13524 03dd 00       		.byte	0
 13525 03de 00       		.byte	0
 13526 03df 00000000 		.space	5
 13526      00
 13527 03e4 20       		.byte	32
 13528 03e5 20       		.byte	32
 13529 03e6 02       		.byte	2
 13530 03e7 00       		.byte	0
 13531 03e8 00       		.byte	0
 13532 03e9 02       		.byte	2
 13533 03ea 00       		.byte	0
 13534 03eb 01       		.byte	1
 13535 03ec 00       		.byte	0
 13536 03ed 03       		.byte	3
 13537 03ee 00       		.byte	0
 13538 03ef 00       		.byte	0
 13539 03f0 00       		.byte	0
 13540 03f1 00       		.byte	0
 13541 03f2 00       		.byte	0
 13542 03f3 30       		.byte	48
 13543 03f4 01       		.byte	1
 13544 03f5 00       		.byte	0
 13545 03f6 00       		.byte	0
 13546 03f7 00000000 		.space	5
 13546      00
 13547 03fc 22       		.byte	34
 13548 03fd 22       		.byte	34
 13549 03fe 02       		.byte	2
 13550 03ff 00       		.byte	0
 13551 0400 00       		.byte	0
 13552 0401 3F       		.byte	63
 13553 0402 00       		.byte	0
 13554 0403 01       		.byte	1
 13555 0404 00       		.byte	0
 13556 0405 03       		.byte	3
 13557 0406 00       		.byte	0
 13558 0407 00       		.byte	0
 13559 0408 00       		.byte	0
 13560 0409 00       		.byte	0
 13561 040a 00       		.byte	0
 13562 040b 30       		.byte	48
 13563 040c 01       		.byte	1
 13564 040d 00       		.byte	0
 13565 040e 00       		.byte	0
 13566 040f 00000000 		.space	5
 13566      00
 13567 0414 23       		.byte	35
 13568 0415 23       		.byte	35
 13569 0416 02       		.byte	2
 13570 0417 00       		.byte	0
 13571 0418 00       		.byte	0
 13572 0419 64       		.byte	100
 13573 041a 00       		.byte	0
 13574 041b 01       		.byte	1
 13575 041c 00       		.byte	0
 13576 041d 03       		.byte	3
 13577 041e 00       		.byte	0
 13578 041f 10       		.byte	16
 13579 0420 00       		.byte	0
 13580 0421 10       		.byte	16
 13581 0422 00       		.byte	0
 13582 0423 30       		.byte	48
 13583 0424 01       		.byte	1
 13584 0425 00       		.byte	0
 13585 0426 00       		.byte	0
 13586 0427 00000000 		.space	5
 13586      00
 13587 042c 24       		.byte	36
 13588 042d 24       		.byte	36
 13589 042e 02       		.byte	2
 13590 042f 00       		.byte	0
 13591 0430 00       		.byte	0
 13592 0431 64       		.byte	100
 13593 0432 00       		.byte	0
 13594 0433 01       		.byte	1
 13595 0434 00       		.byte	0
 13596 0435 03       		.byte	3
 13597 0436 00       		.byte	0
 13598 0437 10       		.byte	16
 13599 0438 00       		.byte	0
 13600 0439 10       		.byte	16
 13601 043a 00       		.byte	0
 13602 043b 30       		.byte	48
 13603 043c 01       		.byte	1
 13604 043d 00       		.byte	0
 13605 043e 00       		.byte	0
 13606 043f 00000000 		.space	5
 13606      00
 13607 0444 00       		.byte	0
 13608 0445 03       		.byte	3
 13609 0446 04       		.byte	4
 13610 0447 00       		.byte	0
 13611 0448 00       		.byte	0
 13612 0449 7F       		.byte	127
 13613 044a 00       		.byte	0
 13614 044b 01       		.byte	1
 13615 044c 00       		.byte	0
 13616 044d 03       		.byte	3
 13617 044e 00       		.byte	0
 13618 044f 00       		.byte	0
 13619 0450 20       		.byte	32
 13620 0451 00       		.byte	0
 13621 0452 20       		.byte	32
 13622 0453 30       		.byte	48
 13623 0454 01       		.byte	1
 13624 0455 00       		.byte	0
 13625 0456 00       		.byte	0
 13626 0457 00000000 		.space	5
 13626      00
 13627 045c 04       		.byte	4
 13628 045d 04       		.byte	4
 13629 045e 02       		.byte	2
 13630 045f 00       		.byte	0
 13631 0460 00       		.byte	0
 13632 0461 FF       		.byte	-1
 13633 0462 00       		.byte	0
 13634 0463 01       		.byte	1
 13635 0464 00       		.byte	0
 13636 0465 03       		.byte	3
 13637 0466 00       		.byte	0
 13638 0467 60       		.byte	96
 13639 0468 00       		.byte	0
 13640 0469 60       		.byte	96
 13641 046a 00       		.byte	0
 13642 046b 30       		.byte	48
 13643 046c 01       		.byte	1
 13644 046d 00       		.byte	0
 13645 046e 00       		.byte	0
 13646 046f 00000000 		.space	5
 13646      00
 13647 0474 00       		.byte	0
 13648 0475 00       		.byte	0
 13649 0476 02       		.byte	2
 13650 0477 00       		.byte	0
 13651 0478 00       		.byte	0
 13652 0479 19       		.byte	25
 13653 047a 00       		.byte	0
 13654 047b 01       		.byte	1
 13655 047c 00       		.byte	0
 13656 047d 03       		.byte	3
 13657 047e 00       		.byte	0
 13658 047f 00       		.byte	0
 13659 0480 00       		.byte	0
 13660 0481 00       		.byte	0
 13661 0482 00       		.byte	0
 13662 0483 30       		.byte	48
 13663 0484 01       		.byte	1
 13664 0485 00       		.byte	0
 13665 0486 00       		.byte	0
 13666 0487 00000000 		.space	5
 13666      00
 13667 048c 10       		.byte	16
 13668 048d 10       		.byte	16
 13669 048e 02       		.byte	2
 13670 048f 00       		.byte	0
 13671 0490 00       		.byte	0
 13672 0491 06       		.byte	6
 13673 0492 00       		.byte	0
 13674 0493 01       		.byte	1
 13675 0494 00       		.byte	0
 13676 0495 03       		.byte	3
 13677 0496 00       		.byte	0
 13678 0497 03       		.byte	3
 13679 0498 00       		.byte	0
 13680 0499 03       		.byte	3
 13681 049a 00       		.byte	0
 13682 049b 30       		.byte	48
 13683 049c 01       		.byte	1
 13684 049d 00       		.byte	0
 13685 049e 00       		.byte	0
 13686 049f 00000000 		.space	5
 13686      00
 13687 04a4 00       		.byte	0
 13688 04a5 00       		.byte	0
 13689 04a6 02       		.byte	2
 13690 04a7 00       		.byte	0
 13691 04a8 00       		.byte	0
 13692 04a9 03       		.byte	3
 13693 04aa 00       		.byte	0
 13694 04ab 01       		.byte	1
 13695 04ac 00       		.byte	0
 13696 04ad 03       		.byte	3
 13697 04ae 00       		.byte	0
 13698 04af 00       		.byte	0
 13699 04b0 00       		.byte	0
 13700 04b1 00       		.byte	0
 13701 04b2 00       		.byte	0
 13702 04b3 30       		.byte	48
 13703 04b4 01       		.byte	1
 13704 04b5 00       		.byte	0
 13705 04b6 00       		.byte	0
 13706 04b7 00000000 		.space	5
 13706      00
 13707 04bc 50       		.byte	80
 13708 04bd 50       		.byte	80
 13709 04be 01       		.byte	1
 13710 04bf 00       		.byte	0
 13711 04c0 00       		.byte	0
 13712 04c1 03       		.byte	3
 13713 04c2 00       		.byte	0
 13714 04c3 01       		.byte	1
 13715 04c4 00       		.byte	0
 13716 04c5 03       		.byte	3
 13717 04c6 00       		.byte	0
 13718 04c7 00       		.byte	0
 13719 04c8 00       		.byte	0
 13720 04c9 00       		.byte	0
 13721 04ca 00       		.byte	0
 13722 04cb 30       		.byte	48
 13723 04cc 01       		.byte	1
 13724 04cd 00       		.byte	0
 13725 04ce 00       		.byte	0
 13726 04cf 00000000 		.space	5
 13726      00
 13727 04d4 00       		.byte	0
 13728 04d5 00       		.byte	0
 13729 04d6 0B       		.byte	11
 13730 04d7 00       		.byte	0
 13731 04d8 00       		.byte	0
 13732 04d9 FF       		.byte	-1
 13733 04da FF       		.byte	-1
 13734 04db 01       		.byte	1
 13735 04dc 00       		.byte	0
 13736 04dd 03       		.byte	3
 13737 04de 00       		.byte	0
 13738 04df 00       		.byte	0
 13739 04e0 00       		.byte	0
 13740 04e1 00       		.byte	0
 13741 04e2 00       		.byte	0
 13742 04e3 00       		.byte	0
 13743 04e4 01       		.byte	1
 13744 04e5 00       		.byte	0
 13745 04e6 00       		.byte	0
 13746 04e7 00000000 		.space	5
 13746      00
 13749              	glUVCHeader:
 13750 04ec 0C       		.byte	12
 13751 04ed 8C       		.byte	-116
 13752 04ee 00       		.byte	0
 13753 04ef 00       		.byte	0
 13754 04f0 00       		.byte	0
 13755 04f1 00       		.byte	0
 13756 04f2 00       		.byte	0
 13757 04f3 00       		.byte	0
 13758 04f4 00       		.byte	0
 13759 04f5 00       		.byte	0
 13760 04f6 00       		.byte	0
 13761 04f7 00       		.byte	0
 13764              	EXTBLCGrid:
 13765 04f8 10       		.byte	16
 13766 04f9 10       		.byte	16
 13767 04fa 02       		.byte	2
 13768 04fb 01       		.byte	1
 13769 04fc 00       		.byte	0
 13770 04fd 02       		.byte	2
 13771 04fe 00       		.byte	0
 13772 04ff 01       		.byte	1
 13773 0500 00       		.byte	0
 13774 0501 03       		.byte	3
 13775 0502 00       		.byte	0
 13776 0503 00       		.byte	0
 13777 0504 00       		.byte	0
 13778 0505 00       		.byte	0
 13779 0506 00       		.byte	0
 13780 0507 30       		.byte	48
 13781 0508 01       		.byte	1
 13782 0509 00       		.byte	0
 13783 050a 0000     		.space	2
 13786              	EXTAexModGainlev:
 13787 050c 00       		.byte	0
 13788 050d 03       		.byte	3
 13789 050e 04       		.byte	4
 13790 050f 00       		.byte	0
 13791 0510 00       		.byte	0
 13792 0511 7F       		.byte	127
 13793 0512 00       		.byte	0
 13794 0513 01       		.byte	1
 13795 0514 00       		.byte	0
 13796 0515 03       		.byte	3
 13797 0516 00       		.byte	0
 13798 0517 00       		.byte	0
 13799 0518 3F       		.byte	63
 13800 0519 00       		.byte	0
 13801 051a 3F       		.byte	63
 13802 051b 30       		.byte	48
 13803 051c 01       		.byte	1
 13804 051d 00       		.byte	0
 13805 051e 0000     		.space	2
 13808              	EXTExCtrlSped:
 13809 0520 02       		.byte	2
 13810 0521 02       		.byte	2
 13811 0522 02       		.byte	2
 13812 0523 00       		.byte	0
 13813 0524 00       		.byte	0
 13814 0525 FF       		.byte	-1
 13815 0526 00       		.byte	0
 13816 0527 01       		.byte	1
 13817 0528 00       		.byte	0
 13818 0529 03       		.byte	3
 13819 052a 00       		.byte	0
 13820 052b 80       		.byte	-128
 13821 052c 00       		.byte	0
 13822 052d 80       		.byte	-128
 13823 052e 00       		.byte	0
 13824 052f 30       		.byte	48
 13825 0530 01       		.byte	1
 13826 0531 00       		.byte	0
 13827 0532 0000     		.space	2
 13830              	EXTBLCWinPos:
 13831 0534 14       		.byte	20
 13832 0535 13       		.byte	19
 13833 0536 02       		.byte	2
 13834 0537 00       		.byte	0
 13835 0538 00       		.byte	0
 13836 0539 FF       		.byte	-1
 13837 053a FF       		.byte	-1
 13838 053b 01       		.byte	1
 13839 053c 00       		.byte	0
 13840 053d 03       		.byte	3
 13841 053e 00       		.byte	0
 13842 053f 66       		.byte	102
 13843 0540 66       		.byte	102
 13844 0541 66       		.byte	102
 13845 0542 66       		.byte	102
 13846 0543 30       		.byte	48
 13847 0544 01       		.byte	1
 13848 0545 00       		.byte	0
 13849 0546 0000     		.space	2
 13852              	PUCBright:
 13853 0548 15       		.byte	21
 13854 0549 15       		.byte	21
 13855 054a 02       		.byte	2
 13856 054b 00       		.byte	0
 13857 054c 00       		.byte	0
 13858 054d FF       		.byte	-1
 13859 054e 00       		.byte	0
 13860 054f 01       		.byte	1
 13861 0550 00       		.byte	0
 13862 0551 03       		.byte	3
 13863 0552 00       		.byte	0
 13864 0553 76       		.byte	118
 13865 0554 00       		.byte	0
 13866 0555 76       		.byte	118
 13867 0556 77       		.byte	119
 13868 0557 30       		.byte	48
 13869 0558 01       		.byte	1
 13870 0559 00       		.byte	0
 13871 055a 0000     		.space	2
 13874              	PUCHueC:
 13875 055c DF       		.byte	-33
 13876 055d E1       		.byte	-31
 13877 055e 02       		.byte	2
 13878 055f 00       		.byte	0
 13879 0560 00       		.byte	0
 13880 0561 FF       		.byte	-1
 13881 0562 00       		.byte	0
 13882 0563 01       		.byte	1
 13883 0564 00       		.byte	0
 13884 0565 03       		.byte	3
 13885 0566 00       		.byte	0
 13886 0567 80       		.byte	-128
 13887 0568 00       		.byte	0
 13888 0569 00       		.byte	0
 13889 056a 00       		.byte	0
 13890 056b 30       		.byte	48
 13891 056c 01       		.byte	1
 13892 056d 00       		.byte	0
 13893 056e 0000     		.space	2
 13896              	PUCPLFreq:
 13897 0570 07       		.byte	7
 13898 0571 07       		.byte	7
 13899 0572 02       		.byte	2
 13900 0573 00       		.byte	0
 13901 0574 00       		.byte	0
 13902 0575 01       		.byte	1
 13903 0576 00       		.byte	0
 13904 0577 01       		.byte	1
 13905 0578 00       		.byte	0
 13906 0579 03       		.byte	3
 13907 057a 00       		.byte	0
 13908 057b 01       		.byte	1
 13909 057c 00       		.byte	0
 13910 057d 01       		.byte	1
 13911 057e 00       		.byte	0
 13912 057f 30       		.byte	48
 13913 0580 01       		.byte	1
 13914 0581 00       		.byte	0
 13915 0582 0000     		.space	2
 13918              	WBMenuCmpArry:
 13919 0584 20       		.byte	32
 13920 0585 0F       		.byte	15
 13921 0586 38       		.byte	56
 13922 0587 F0       		.byte	-16
 13925              	PUCSharp:
 13926 0588 06       		.byte	6
 13927 0589 07       		.byte	7
 13928 058a 02       		.byte	2
 13929 058b 00       		.byte	0
 13930 058c 00       		.byte	0
 13931 058d FF       		.byte	-1
 13932 058e 00       		.byte	0
 13933 058f 01       		.byte	1
 13934 0590 00       		.byte	0
 13935 0591 03       		.byte	3
 13936 0592 00       		.byte	0
 13937 0593 00       		.byte	0
 13938 0594 00       		.byte	0
 13939 0595 00       		.byte	0
 13940 0596 00       		.byte	0
 13941 0597 30       		.byte	48
 13942 0598 01       		.byte	1
 13943 0599 00       		.byte	0
 13944 059a 0000     		.space	2
 13947              	PUCBLC:
 13948 059c 10       		.byte	16
 13949 059d 11       		.byte	17
 13950 059e 02       		.byte	2
 13951 059f 00       		.byte	0
 13952 05a0 00       		.byte	0
 13953 05a1 03       		.byte	3
 13954 05a2 00       		.byte	0
 13955 05a3 01       		.byte	1
 13956 05a4 00       		.byte	0
 13957 05a5 03       		.byte	3
 13958 05a6 00       		.byte	0
 13959 05a7 03       		.byte	3
 13960 05a8 00       		.byte	0
 13961 05a9 03       		.byte	3
 13962 05aa 00       		.byte	0
 13963 05ab 30       		.byte	48
 13964 05ac 01       		.byte	1
 13965 05ad 00       		.byte	0
 13966 05ae 0000     		.space	2
 13969              	EXTShutter:
 13970 05b0 00       		.byte	0
 13971 05b1 02       		.byte	2
 13972 05b2 02       		.byte	2
 13973 05b3 00       		.byte	0
 13974 05b4 00       		.byte	0
 13975 05b5 08       		.byte	8
 13976 05b6 00       		.byte	0
 13977 05b7 01       		.byte	1
 13978 05b8 00       		.byte	0
 13979 05b9 03       		.byte	3
 13980 05ba 00       		.byte	0
 13981 05bb 00       		.byte	0
 13982 05bc 00       		.byte	0
 13983 05bd 00       		.byte	0
 13984 05be 00       		.byte	0
 13985 05bf 30       		.byte	48
 13986 05c0 01       		.byte	1
 13987 05c1 00       		.byte	0
 13988 05c2 0000     		.space	2
 13991              	EXTShutlev:
 13992 05c4 12       		.byte	18
 13993 05c5 12       		.byte	18
 13994 05c6 02       		.byte	2
 13995 05c7 00       		.byte	0
 13996 05c8 00       		.byte	0
 13997 05c9 FF       		.byte	-1
 13998 05ca 7F       		.byte	127
 13999 05cb 01       		.byte	1
 14000 05cc 00       		.byte	0
 14001 05cd 03       		.byte	3
 14002 05ce 00       		.byte	0
 14003 05cf 3F       		.byte	63
 14004 05d0 00       		.byte	0
 14005 05d1 3F       		.byte	63
 14006 05d2 00       		.byte	0
 14007 05d3 30       		.byte	48
 14008 05d4 01       		.byte	1
 14009 05d5 00       		.byte	0
 14010 05d6 0000     		.space	2
 14013              	CTCtrlParArry:
 14014 05d8 00       		.byte	0
 14015 05d9 00       		.byte	0
 14016 05da 01       		.byte	1
 14017 05db 00       		.byte	0
 14018 05dc 00       		.byte	0
 14019 05dd 03       		.byte	3
 14020 05de 00       		.byte	0
 14021 05df 01       		.byte	1
 14022 05e0 00       		.byte	0
 14023 05e1 03       		.byte	3
 14024 05e2 00       		.byte	0
 14025 05e3 03       		.byte	3
 14026 05e4 00       		.byte	0
 14027 05e5 03       		.byte	3
 14028 05e6 00       		.byte	0
 14029 05e7 30       		.byte	48
 14030 05e8 01       		.byte	1
 14031 05e9 00       		.byte	0
 14032 05ea 00       		.byte	0
 14033 05eb 00000000 		.space	5
 14033      00
 14034 05f0 00       		.byte	0
 14035 05f1 00       		.byte	0
 14036 05f2 01       		.byte	1
 14037 05f3 01       		.byte	1
 14038 05f4 00       		.byte	0
 14039 05f5 0F       		.byte	15
 14040 05f6 00       		.byte	0
 14041 05f7 0F       		.byte	15
 14042 05f8 00       		.byte	0
 14043 05f9 03       		.byte	3
 14044 05fa 00       		.byte	0
 14045 05fb 02       		.byte	2
 14046 05fc 00       		.byte	0
 14047 05fd 02       		.byte	2
 14048 05fe 00       		.byte	0
 14049 05ff 30       		.byte	48
 14050 0600 01       		.byte	1
 14051 0601 01       		.byte	1
 14052 0602 00       		.byte	0
 14053 0603 00000000 		.space	5
 14053      00
 14054 0608 02       		.byte	2
 14055 0609 00       		.byte	0
 14056 060a 01       		.byte	1
 14057 060b 00       		.byte	0
 14058 060c 00       		.byte	0
 14059 060d 01       		.byte	1
 14060 060e 00       		.byte	0
 14061 060f 01       		.byte	1
 14062 0610 00       		.byte	0
 14063 0611 03       		.byte	3
 14064 0612 00       		.byte	0
 14065 0613 00       		.byte	0
 14066 0614 00       		.byte	0
 14067 0615 00       		.byte	0
 14068 0616 00       		.byte	0
 14069 0617 30       		.byte	48
 14070 0618 01       		.byte	1
 14071 0619 01       		.byte	1
 14072 061a 00       		.byte	0
 14073 061b 00000000 		.space	5
 14073      00
 14074 0620 00       		.byte	0
 14075 0621 00       		.byte	0
 14076 0622 04       		.byte	4
 14077 0623 01       		.byte	1
 14078 0624 00       		.byte	0
 14079 0625 38       		.byte	56
 14080 0626 01       		.byte	1
 14081 0627 01       		.byte	1
 14082 0628 00       		.byte	0
 14083 0629 03       		.byte	3
 14084 062a 00       		.byte	0
 14085 062b 4E       		.byte	78
 14086 062c 00       		.byte	0
 14087 062d 4E       		.byte	78
 14088 062e 00       		.byte	0
 14089 062f 30       		.byte	48
 14090 0630 01       		.byte	1
 14091 0631 00       		.byte	0
 14092 0632 00       		.byte	0
 14093 0633 00000000 		.space	5
 14093      00
 14094 0638 04       		.byte	4
 14095 0639 00       		.byte	0
 14096 063a 01       		.byte	1
 14097 063b 00       		.byte	0
 14098 063c 00       		.byte	0
 14099 063d 00       		.byte	0
 14100 063e 00       		.byte	0
 14101 063f 01       		.byte	1
 14102 0640 00       		.byte	0
 14103 0641 03       		.byte	3
 14104 0642 00       		.byte	0
 14105 0643 00       		.byte	0
 14106 0644 00       		.byte	0
 14107 0645 00       		.byte	0
 14108 0646 00       		.byte	0
 14109 0647 30       		.byte	48
 14110 0648 01       		.byte	1
 14111 0649 00       		.byte	0
 14112 064a 00       		.byte	0
 14113 064b 00000000 		.space	5
 14113      00
 14114 0650 05       		.byte	5
 14115 0651 00       		.byte	0
 14116 0652 02       		.byte	2
 14117 0653 00       		.byte	0
 14118 0654 00       		.byte	0
 14119 0655 FF       		.byte	-1
 14120 0656 00       		.byte	0
 14121 0657 01       		.byte	1
 14122 0658 00       		.byte	0
 14123 0659 03       		.byte	3
 14124 065a 00       		.byte	0
 14125 065b 01       		.byte	1
 14126 065c 00       		.byte	0
 14127 065d 00       		.byte	0
 14128 065e 00       		.byte	0
 14129 065f 30       		.byte	48
 14130 0660 01       		.byte	1
 14131 0661 01       		.byte	1
 14132 0662 00       		.byte	0
 14133 0663 00000000 		.space	5
 14133      00
 14134 0668 06       		.byte	6
 14135 0669 00       		.byte	0
 14136 066a 02       		.byte	2
 14137 066b 00       		.byte	0
 14138 066c 00       		.byte	0
 14139 066d 00       		.byte	0
 14140 066e 00       		.byte	0
 14141 066f 00       		.byte	0
 14142 0670 00       		.byte	0
 14143 0671 03       		.byte	3
 14144 0672 00       		.byte	0
 14145 0673 00       		.byte	0
 14146 0674 00       		.byte	0
 14147 0675 00       		.byte	0
 14148 0676 00       		.byte	0
 14149 0677 30       		.byte	48
 14150 0678 01       		.byte	1
 14151 0679 01       		.byte	1
 14152 067a 00       		.byte	0
 14153 067b 00000000 		.space	5
 14153      00
 14154 0680 23       		.byte	35
 14155 0681 00       		.byte	0
 14156 0682 02       		.byte	2
 14157 0683 00       		.byte	0
 14158 0684 00       		.byte	0
 14159 0685 30       		.byte	48
 14160 0686 00       		.byte	0
 14161 0687 01       		.byte	1
 14162 0688 00       		.byte	0
 14163 0689 03       		.byte	3
 14164 068a 0A       		.byte	10
 14165 068b 00       		.byte	0
 14166 068c 00       		.byte	0
 14167 068d 0A       		.byte	10
 14168 068e 00       		.byte	0
 14169 068f 30       		.byte	48
 14170 0690 01       		.byte	1
 14171 0691 01       		.byte	1
 14172 0692 00       		.byte	0
 14173 0693 00000000 		.space	5
 14173      00
 14174 0698 08       		.byte	8
 14175 0699 00       		.byte	0
 14176 069a 01       		.byte	1
 14177 069b 00       		.byte	0
 14178 069c 00       		.byte	0
 14179 069d 7F       		.byte	127
 14180 069e 00       		.byte	0
 14181 069f 01       		.byte	1
 14182 06a0 00       		.byte	0
 14183 06a1 03       		.byte	3
 14184 06a2 00       		.byte	0
 14185 06a3 00       		.byte	0
 14186 06a4 00       		.byte	0
 14187 06a5 00       		.byte	0
 14188 06a6 00       		.byte	0
 14189 06a7 30       		.byte	48
 14190 06a8 01       		.byte	1
 14191 06a9 00       		.byte	0
 14192 06aa 00       		.byte	0
 14193 06ab 00000000 		.space	5
 14193      00
 14194 06b0 09       		.byte	9
 14195 06b1 00       		.byte	0
 14196 06b2 02       		.byte	2
 14197 06b3 00       		.byte	0
 14198 06b4 00       		.byte	0
 14199 06b5 05       		.byte	5
 14200 06b6 00       		.byte	0
 14201 06b7 01       		.byte	1
 14202 06b8 00       		.byte	0
 14203 06b9 03       		.byte	3
 14204 06ba 00       		.byte	0
 14205 06bb 00       		.byte	0
 14206 06bc 00       		.byte	0
 14207 06bd 00       		.byte	0
 14208 06be 00       		.byte	0
 14209 06bf 30       		.byte	48
 14210 06c0 01       		.byte	1
 14211 06c1 00       		.byte	0
 14212 06c2 00       		.byte	0
 14213 06c3 00000000 		.space	5
 14213      00
 14214 06c8 10       		.byte	16
 14215 06c9 00       		.byte	0
 14216 06ca 03       		.byte	3
 14217 06cb 00       		.byte	0
 14218 06cc 00       		.byte	0
 14219 06cd 00       		.byte	0
 14220 06ce 00       		.byte	0
 14221 06cf 00       		.byte	0
 14222 06d0 00       		.byte	0
 14223 06d1 03       		.byte	3
 14224 06d2 00       		.byte	0
 14225 06d3 00       		.byte	0
 14226 06d4 00       		.byte	0
 14227 06d5 00       		.byte	0
 14228 06d6 00       		.byte	0
 14229 06d7 30       		.byte	48
 14230 06d8 01       		.byte	1
 14231 06d9 00       		.byte	0
 14232 06da 00       		.byte	0
 14233 06db 00000000 		.space	5
 14233      00
 14234 06e0 00       		.byte	0
 14235 06e1 00       		.byte	0
 14236 06e2 02       		.byte	2
 14237 06e3 00       		.byte	0
 14238 06e4 00       		.byte	0
 14239 06e5 40       		.byte	64
 14240 06e6 00       		.byte	0
 14241 06e7 01       		.byte	1
 14242 06e8 00       		.byte	0
 14243 06e9 03       		.byte	3
 14244 06ea 00       		.byte	0
 14245 06eb 0F       		.byte	15
 14246 06ec 11       		.byte	17
 14247 06ed 00       		.byte	0
 14248 06ee 00       		.byte	0
 14249 06ef 30       		.byte	48
 14250 06f0 01       		.byte	1
 14251 06f1 00       		.byte	0
 14252 06f2 00       		.byte	0
 14253 06f3 00000000 		.space	5
 14253      00
 14254 06f8 00       		.byte	0
 14255 06f9 00       		.byte	0
 14256 06fa 02       		.byte	2
 14257 06fb 00       		.byte	0
 14258 06fc 00       		.byte	0
 14259 06fd 64       		.byte	100
 14260 06fe 00       		.byte	0
 14261 06ff 01       		.byte	1
 14262 0700 00       		.byte	0
 14263 0701 03       		.byte	3
 14264 0702 00       		.byte	0
 14265 0703 00       		.byte	0
 14266 0704 00       		.byte	0
 14267 0705 00       		.byte	0
 14268 0706 00       		.byte	0
 14269 0707 30       		.byte	48
 14270 0708 01       		.byte	1
 14271 0709 00       		.byte	0
 14272 070a 00       		.byte	0
 14273 070b 00000000 		.space	5
 14273      00
 14274 0710 00       		.byte	0
 14275 0711 00       		.byte	0
 14276 0712 02       		.byte	2
 14277 0713 00       		.byte	0
 14278 0714 00       		.byte	0
 14279 0715 64       		.byte	100
 14280 0716 00       		.byte	0
 14281 0717 01       		.byte	1
 14282 0718 00       		.byte	0
 14283 0719 03       		.byte	3
 14284 071a 00       		.byte	0
 14285 071b 00       		.byte	0
 14286 071c 00       		.byte	0
 14287 071d 00       		.byte	0
 14288 071e 00       		.byte	0
 14289 071f 30       		.byte	48
 14290 0720 01       		.byte	1
 14291 0721 00       		.byte	0
 14292 0722 00       		.byte	0
 14293 0723 00000000 		.space	5
 14293      00
 14294 0728 00       		.byte	0
 14295 0729 00       		.byte	0
 14296 072a 02       		.byte	2
 14297 072b 00       		.byte	0
 14298 072c 00       		.byte	0
 14299 072d 64       		.byte	100
 14300 072e 00       		.byte	0
 14301 072f 01       		.byte	1
 14302 0730 00       		.byte	0
 14303 0731 03       		.byte	3
 14304 0732 00       		.byte	0
 14305 0733 00       		.byte	0
 14306 0734 00       		.byte	0
 14307 0735 00       		.byte	0
 14308 0736 00       		.byte	0
 14309 0737 30       		.byte	48
 14310 0738 01       		.byte	1
 14311 0739 00       		.byte	0
 14312 073a 00       		.byte	0
 14313 073b 00000000 		.space	5
 14313      00
 14314 0740 00       		.byte	0
 14315 0741 00       		.byte	0
 14316 0742 02       		.byte	2
 14317 0743 00       		.byte	0
 14318 0744 00       		.byte	0
 14319 0745 64       		.byte	100
 14320 0746 00       		.byte	0
 14321 0747 01       		.byte	1
 14322 0748 00       		.byte	0
 14323 0749 03       		.byte	3
 14324 074a 00       		.byte	0
 14325 074b 00       		.byte	0
 14326 074c 00       		.byte	0
 14327 074d 00       		.byte	0
 14328 074e 00       		.byte	0
 14329 074f 30       		.byte	48
 14330 0750 01       		.byte	1
 14331 0751 00       		.byte	0
 14332 0752 00       		.byte	0
 14333 0753 00000000 		.space	5
 14333      00
 14336              	EXTDayNightdely:
 14337 0758 22       		.byte	34
 14338 0759 22       		.byte	34
 14339 075a 02       		.byte	2
 14340 075b 00       		.byte	0
 14341 075c 00       		.byte	0
 14342 075d 3F       		.byte	63
 14343 075e 00       		.byte	0
 14344 075f 01       		.byte	1
 14345 0760 00       		.byte	0
 14346 0761 03       		.byte	3
 14347 0762 00       		.byte	0
 14348 0763 00       		.byte	0
 14349 0764 00       		.byte	0
 14350 0765 00       		.byte	0
 14351 0766 00       		.byte	0
 14352 0767 30       		.byte	48
 14353 0768 01       		.byte	1
 14354 0769 00       		.byte	0
 14355 076a 0000     		.space	2
 14358              	EXTEnhanceGain:
 14359 076c 07       		.byte	7
 14360 076d 07       		.byte	7
 14361 076e 02       		.byte	2
 14362 076f 00       		.byte	0
 14363 0770 00       		.byte	0
 14364 0771 FF       		.byte	-1
 14365 0772 00       		.byte	0
 14366 0773 01       		.byte	1
 14367 0774 00       		.byte	0
 14368 0775 03       		.byte	3
 14369 0776 00       		.byte	0
 14370 0777 80       		.byte	-128
 14371 0778 00       		.byte	0
 14372 0779 80       		.byte	-128
 14373 077a 00       		.byte	0
 14374 077b 30       		.byte	48
 14375 077c 01       		.byte	1
 14376 077d 00       		.byte	0
 14377 077e 0000     		.space	2
 14380              	EXTEnhanceSTED:
 14381 0780 08       		.byte	8
 14382 0781 09       		.byte	9
 14383 0782 04       		.byte	4
 14384 0783 00       		.byte	0
 14385 0784 00       		.byte	0
 14386 0785 FF       		.byte	-1
 14387 0786 00       		.byte	0
 14388 0787 01       		.byte	1
 14389 0788 00       		.byte	0
 14390 0789 03       		.byte	3
 14391 078a 00       		.byte	0
 14392 078b 80       		.byte	-128
 14393 078c 00       		.byte	0
 14394 078d 80       		.byte	-128
 14395 078e 00       		.byte	0
 14396 078f 30       		.byte	48
 14397 0790 01       		.byte	1
 14398 0791 00       		.byte	0
 14401              	snapButFlag:
 14402 0792 01       		.byte	1
 14403 0793 00       		.space	1
 14406              	EXTAGCMaxLimit:
 14407 0794 0C       		.byte	12
 14408 0795 0C       		.byte	12
 14409 0796 02       		.byte	2
 14410 0797 00       		.byte	0
 14411 0798 00       		.byte	0
 14412 0799 10       		.byte	16
 14413 079a 00       		.byte	0
 14414 079b 01       		.byte	1
 14415 079c 00       		.byte	0
 14416 079d 03       		.byte	3
 14417 079e 00       		.byte	0
 14418 079f 00       		.byte	0
 14419 07a0 00       		.byte	0
 14420 07a1 00       		.byte	0
 14421 07a2 00       		.byte	0
 14422 07a3 30       		.byte	48
 14423 07a4 01       		.byte	1
 14424 07a5 00       		.byte	0
 14425 07a6 0000     		.space	2
 14428              	EXTGammaCor:
 14429 07a8 17       		.byte	23
 14430 07a9 17       		.byte	23
 14431 07aa 02       		.byte	2
 14432 07ab 00       		.byte	0
 14433 07ac 00       		.byte	0
 14434 07ad 10       		.byte	16
 14435 07ae 00       		.byte	0
 14436 07af 01       		.byte	1
 14437 07b0 00       		.byte	0
 14438 07b1 03       		.byte	3
 14439 07b2 00       		.byte	0
 14440 07b3 00       		.byte	0
 14441 07b4 00       		.byte	0
 14442 07b5 00       		.byte	0
 14443 07b6 00       		.byte	0
 14444 07b7 30       		.byte	48
 14445 07b8 01       		.byte	1
 14446 07b9 00       		.byte	0
 14447 07ba 0000     		.space	2
 14450              	EXT2DNRSTED:
 14451 07bc 1A       		.byte	26
 14452 07bd 1B       		.byte	27
 14453 07be 04       		.byte	4
 14454 07bf 00       		.byte	0
 14455 07c0 00       		.byte	0
 14456 07c1 FF       		.byte	-1
 14457 07c2 00       		.byte	0
 14458 07c3 01       		.byte	1
 14459 07c4 00       		.byte	0
 14460 07c5 03       		.byte	3
 14461 07c6 00       		.byte	0
 14462 07c7 80       		.byte	-128
 14463 07c8 00       		.byte	0
 14464 07c9 80       		.byte	-128
 14465 07ca 00       		.byte	0
 14466 07cb 30       		.byte	48
 14467 07cc 01       		.byte	1
 14468 07cd 00       		.byte	0
 14469 07ce 0000     		.space	2
 14472              	EXT2DNRGain:
 14473 07d0 18       		.byte	24
 14474 07d1 19       		.byte	25
 14475 07d2 02       		.byte	2
 14476 07d3 00       		.byte	0
 14477 07d4 00       		.byte	0
 14478 07d5 FF       		.byte	-1
 14479 07d6 00       		.byte	0
 14480 07d7 01       		.byte	1
 14481 07d8 00       		.byte	0
 14482 07d9 03       		.byte	3
 14483 07da 00       		.byte	0
 14484 07db 80       		.byte	-128
 14485 07dc 00       		.byte	0
 14486 07dd 80       		.byte	-128
 14487 07de 00       		.byte	0
 14488 07df 30       		.byte	48
 14489 07e0 01       		.byte	1
 14490 07e1 00       		.byte	0
 14491 07e2 0000     		.space	2
 14494              	EXTEnhanceMode:
 14495 07e4 06       		.byte	6
 14496 07e5 06       		.byte	6
 14497 07e6 02       		.byte	2
 14498 07e7 00       		.byte	0
 14499 07e8 00       		.byte	0
 14500 07e9 FF       		.byte	-1
 14501 07ea 00       		.byte	0
 14502 07eb 01       		.byte	1
 14503 07ec 00       		.byte	0
 14504 07ed 03       		.byte	3
 14505 07ee 00       		.byte	0
 14506 07ef 80       		.byte	-128
 14507 07f0 00       		.byte	0
 14508 07f1 80       		.byte	-128
 14509 07f2 00       		.byte	0
 14510 07f3 30       		.byte	48
 14511 07f4 01       		.byte	1
 14512 07f5 00       		.byte	0
 14513 07f6 0000     		.space	2
 14516              	EXTExHyster:
 14517 07f8 0B       		.byte	11
 14518 07f9 0B       		.byte	11
 14519 07fa 02       		.byte	2
 14520 07fb 00       		.byte	0
 14521 07fc 00       		.byte	0
 14522 07fd FF       		.byte	-1
 14523 07fe 00       		.byte	0
 14524 07ff 01       		.byte	1
 14525 0800 00       		.byte	0
 14526 0801 03       		.byte	3
 14527 0802 00       		.byte	0
 14528 0803 80       		.byte	-128
 14529 0804 00       		.byte	0
 14530 0805 80       		.byte	-128
 14531 0806 00       		.byte	0
 14532 0807 30       		.byte	48
 14533 0808 01       		.byte	1
 14534 0809 00       		.byte	0
 14535 080a 0000     		.space	2
 14538              	EXTBLCWeight:
 14539 080c 11       		.byte	17
 14540 080d 11       		.byte	17
 14541 080e 02       		.byte	2
 14542 080f 00       		.byte	0
 14543 0810 00       		.byte	0
 14544 0811 FF       		.byte	-1
 14545 0812 00       		.byte	0
 14546 0813 01       		.byte	1
 14547 0814 00       		.byte	0
 14548 0815 03       		.byte	3
 14549 0816 00       		.byte	0
 14550 0817 80       		.byte	-128
 14551 0818 00       		.byte	0
 14552 0819 80       		.byte	-128
 14553 081a 00       		.byte	0
 14554 081b 30       		.byte	48
 14555 081c 01       		.byte	1
 14556 081d 00       		.byte	0
 14557 081e 0000     		.space	2
 14560              	EXTI2Ccmd:
 14561 0820 00       		.byte	0
 14562 0821 00       		.byte	0
 14563 0822 0B       		.byte	11
 14564 0823 00       		.byte	0
 14565 0824 00       		.byte	0
 14566 0825 FF       		.byte	-1
 14567 0826 FF       		.byte	-1
 14568 0827 01       		.byte	1
 14569 0828 00       		.byte	0
 14570 0829 03       		.byte	3
 14571 082a 00       		.byte	0
 14572 082b 00       		.byte	0
 14573 082c 00       		.byte	0
 14574 082d 00       		.byte	0
 14575 082e 00       		.byte	0
 14576 082f 00       		.byte	0
 14577 0830 01       		.byte	1
 14578 0831 00       		.byte	0
 14579 0832 0000     		.space	2
 14582              	EXTSensorPare:
 14583 0834 50       		.byte	80
 14584 0835 50       		.byte	80
 14585 0836 02       		.byte	2
 14586 0837 00       		.byte	0
 14587 0838 00       		.byte	0
 14588 0839 03       		.byte	3
 14589 083a 00       		.byte	0
 14590 083b 01       		.byte	1
 14591 083c 00       		.byte	0
 14592 083d 03       		.byte	3
 14593 083e 00       		.byte	0
 14594 083f 00       		.byte	0
 14595 0840 00       		.byte	0
 14596 0841 00       		.byte	0
 14597 0842 00       		.byte	0
 14598 0843 30       		.byte	48
 14599 0844 01       		.byte	1
 14600 0845 00       		.byte	0
 14601 0846 0000     		.space	2
 14604              	EXTCamMode:
 14605 0848 10       		.byte	16
 14606 0849 10       		.byte	16
 14607 084a 02       		.byte	2
 14608 084b 00       		.byte	0
 14609 084c 00       		.byte	0
 14610 084d 06       		.byte	6
 14611 084e 00       		.byte	0
 14612 084f 01       		.byte	1
 14613 0850 00       		.byte	0
 14614 0851 03       		.byte	3
 14615 0852 00       		.byte	0
 14616 0853 03       		.byte	3
 14617 0854 00       		.byte	0
 14618 0855 03       		.byte	3
 14619 0856 00       		.byte	0
 14620 0857 30       		.byte	48
 14621 0858 01       		.byte	1
 14622 0859 00       		.byte	0
 14623 085a 0000     		.space	2
 14626              	EXTExpReflev:
 14627 085c 04       		.byte	4
 14628 085d 04       		.byte	4
 14629 085e 02       		.byte	2
 14630 085f 00       		.byte	0
 14631 0860 00       		.byte	0
 14632 0861 FF       		.byte	-1
 14633 0862 00       		.byte	0
 14634 0863 01       		.byte	1
 14635 0864 00       		.byte	0
 14636 0865 03       		.byte	3
 14637 0866 00       		.byte	0
 14638 0867 3C       		.byte	60
 14639 0868 00       		.byte	0
 14640 0869 3C       		.byte	60
 14641 086a 00       		.byte	0
 14642 086b 30       		.byte	48
 14643 086c 01       		.byte	1
 14644 086d 00       		.byte	0
 14645 086e 0000     		.space	2
 14648              	EXTNightDaylev:
 14649 0870 24       		.byte	36
 14650 0871 24       		.byte	36
 14651 0872 02       		.byte	2
 14652 0873 00       		.byte	0
 14653 0874 00       		.byte	0
 14654 0875 64       		.byte	100
 14655 0876 00       		.byte	0
 14656 0877 01       		.byte	1
 14657 0878 00       		.byte	0
 14658 0879 03       		.byte	3
 14659 087a 00       		.byte	0
 14660 087b 10       		.byte	16
 14661 087c 00       		.byte	0
 14662 087d 10       		.byte	16
 14663 087e 00       		.byte	0
 14664 087f 30       		.byte	48
 14665 0880 01       		.byte	1
 14666 0881 00       		.byte	0
 14667 0882 0000     		.space	2
 14670              	EXTDayNightlev:
 14671 0884 23       		.byte	35
 14672 0885 23       		.byte	35
 14673 0886 02       		.byte	2
 14674 0887 00       		.byte	0
 14675 0888 00       		.byte	0
 14676 0889 64       		.byte	100
 14677 088a 00       		.byte	0
 14678 088b 01       		.byte	1
 14679 088c 00       		.byte	0
 14680 088d 03       		.byte	3
 14681 088e 00       		.byte	0
 14682 088f 10       		.byte	16
 14683 0890 00       		.byte	0
 14684 0891 10       		.byte	16
 14685 0892 00       		.byte	0
 14686 0893 30       		.byte	48
 14687 0894 01       		.byte	1
 14688 0895 00       		.byte	0
 14689 0896 0000     		.space	2
 14692              	EXTDayNightMode:
 14693 0898 20       		.byte	32
 14694 0899 20       		.byte	32
 14695 089a 02       		.byte	2
 14696 089b 00       		.byte	0
 14697 089c 00       		.byte	0
 14698 089d 02       		.byte	2
 14699 089e 00       		.byte	0
 14700 089f 01       		.byte	1
 14701 08a0 00       		.byte	0
 14702 08a1 03       		.byte	3
 14703 08a2 00       		.byte	0
 14704 08a3 00       		.byte	0
 14705 08a4 00       		.byte	0
 14706 08a5 00       		.byte	0
 14707 08a6 00       		.byte	0
 14708 08a7 30       		.byte	48
 14709 08a8 01       		.byte	1
 14710 08a9 00       		.byte	0
 14711 08aa 0000     		.space	2
 14714              	EXT3DNoiseLev:
 14715 08ac 19       		.byte	25
 14716 08ad 19       		.byte	25
 14717 08ae 02       		.byte	2
 14718 08af 00       		.byte	0
 14719 08b0 00       		.byte	0
 14720 08b1 40       		.byte	64
 14721 08b2 00       		.byte	0
 14722 08b3 01       		.byte	1
 14723 08b4 00       		.byte	0
 14724 08b5 03       		.byte	3
 14725 08b6 00       		.byte	0
 14726 08b7 20       		.byte	32
 14727 08b8 00       		.byte	0
 14728 08b9 20       		.byte	32
 14729 08ba 00       		.byte	0
 14730 08bb 30       		.byte	48
 14731 08bc 01       		.byte	1
 14732 08bd 00       		.byte	0
 14733 08be 0000     		.space	2
 14736              	EXT3DnoiseReduceMode:
 14737 08c0 18       		.byte	24
 14738 08c1 18       		.byte	24
 14739 08c2 02       		.byte	2
 14740 08c3 00       		.byte	0
 14741 08c4 00       		.byte	0
 14742 08c5 01       		.byte	1
 14743 08c6 00       		.byte	0
 14744 08c7 01       		.byte	1
 14745 08c8 00       		.byte	0
 14746 08c9 03       		.byte	3
 14747 08ca 00       		.byte	0
 14748 08cb 00       		.byte	0
 14749 08cc 00       		.byte	0
 14750 08cd 00       		.byte	0
 14751 08ce 00       		.byte	0
 14752 08cf 30       		.byte	48
 14753 08d0 01       		.byte	1
 14754 08d1 00       		.byte	0
 14755 08d2 0000     		.space	2
 14758              	EXTMirror:
 14759 08d4 05       		.byte	5
 14760 08d5 05       		.byte	5
 14761 08d6 02       		.byte	2
 14762 08d7 00       		.byte	0
 14763 08d8 00       		.byte	0
 14764 08d9 03       		.byte	3
 14765 08da 00       		.byte	0
 14766 08db 01       		.byte	1
 14767 08dc 00       		.byte	0
 14768 08dd 03       		.byte	3
 14769 08de 00       		.byte	0
 14770 08df 00       		.byte	0
 14771 08e0 00       		.byte	0
 14772 08e1 00       		.byte	0
 14773 08e2 00       		.byte	0
 14774 08e3 30       		.byte	48
 14775 08e4 01       		.byte	1
 14776 08e5 00       		.byte	0
 14777 08e6 0000     		.space	2
 14780              	EXTSensUp:
 14781 08e8 01       		.byte	1
 14782 08e9 01       		.byte	1
 14783 08ea 02       		.byte	2
 14784 08eb 00       		.byte	0
 14785 08ec 00       		.byte	0
 14786 08ed 09       		.byte	9
 14787 08ee 00       		.byte	0
 14788 08ef 01       		.byte	1
 14789 08f0 00       		.byte	0
 14790 08f1 03       		.byte	3
 14791 08f2 00       		.byte	0
 14792 08f3 00       		.byte	0
 14793 08f4 00       		.byte	0
 14794 08f5 01       		.byte	1
 14795 08f6 00       		.byte	0
 14796 08f7 30       		.byte	48
 14797 08f8 01       		.byte	1
 14798 08f9 00       		.byte	0
 14799 08fa 0000     		.space	2
 14802              	PUCDZoom:
 14803 08fc 2A       		.byte	42
 14804 08fd 2A       		.byte	42
 14805 08fe 02       		.byte	2
 14806 08ff 00       		.byte	0
 14807 0900 00       		.byte	0
 14808 0901 1B       		.byte	27
 14809 0902 00       		.byte	0
 14810 0903 01       		.byte	1
 14811 0904 00       		.byte	0
 14812 0905 03       		.byte	3
 14813 0906 00       		.byte	0
 14814 0907 00       		.byte	0
 14815 0908 00       		.byte	0
 14816 0909 00       		.byte	0
 14817 090a 00       		.byte	0
 14818 090b 30       		.byte	48
 14819 090c 01       		.byte	1
 14820 090d 00       		.byte	0
 14821 090e 0000     		.space	2
 14824              	PUCWBLC:
 14825 0910 09       		.byte	9
 14826 0911 0A       		.byte	10
 14827 0912 04       		.byte	4
 14828 0913 00       		.byte	0
 14829 0914 00       		.byte	0
 14830 0915 40       		.byte	64
 14831 0916 00       		.byte	0
 14832 0917 01       		.byte	1
 14833 0918 00       		.byte	0
 14834 0919 03       		.byte	3
 14835 091a 00       		.byte	0
 14836 091b 20       		.byte	32
 14837 091c 00       		.byte	0
 14838 091d 38       		.byte	56
 14839 091e 00       		.byte	0
 14840 091f 30       		.byte	48
 14841 0920 01       		.byte	1
 14842 0921 00       		.byte	0
 14843 0922 0000     		.space	2
 14846              	PUCWBMd:
 14847 0924 08       		.byte	8
 14848 0925 08       		.byte	8
 14849 0926 02       		.byte	2
 14850 0927 00       		.byte	0
 14851 0928 00       		.byte	0
 14852 0929 05       		.byte	5
 14853 092a 00       		.byte	0
 14854 092b 01       		.byte	1
 14855 092c 00       		.byte	0
 14856 092d 03       		.byte	3
 14857 092e 00       		.byte	0
 14858 092f 00       		.byte	0
 14859 0930 00       		.byte	0
 14860 0931 00       		.byte	0
 14861 0932 00       		.byte	0
 14862 0933 30       		.byte	48
 14863 0934 01       		.byte	1
 14864 0935 00       		.byte	0
 14865 0936 0000     		.space	2
 14868              	PUCSaturation:
 14869 0938 85       		.byte	-123
 14870 0939 86       		.byte	-122
 14871 093a 02       		.byte	2
 14872 093b 00       		.byte	0
 14873 093c 00       		.byte	0
 14874 093d 64       		.byte	100
 14875 093e 00       		.byte	0
 14876 093f 01       		.byte	1
 14877 0940 00       		.byte	0
 14878 0941 03       		.byte	3
 14879 0942 00       		.byte	0
 14880 0943 32       		.byte	50
 14881 0944 00       		.byte	0
 14882 0945 32       		.byte	50
 14883 0946 00       		.byte	0
 14884 0947 30       		.byte	48
 14885 0948 01       		.byte	1
 14886 0949 00       		.byte	0
 14887 094a 0000     		.space	2
 14890              	PUCContrast:
 14891 094c 0D       		.byte	13
 14892 094d 0D       		.byte	13
 14893 094e 02       		.byte	2
 14894 094f 00       		.byte	0
 14895 0950 00       		.byte	0
 14896 0951 FF       		.byte	-1
 14897 0952 00       		.byte	0
 14898 0953 01       		.byte	1
 14899 0954 00       		.byte	0
 14900 0955 03       		.byte	3
 14901 0956 00       		.byte	0
 14902 0957 70       		.byte	112
 14903 0958 00       		.byte	0
 14904 0959 70       		.byte	112
 14905 095a 00       		.byte	0
 14906 095b 30       		.byte	48
 14907 095c 01       		.byte	1
 14908 095d 00       		.byte	0
 14909 095e 0000     		.space	2
 14912              	CyFxGpifRegValue_usb2:
 14913 0960 08830080 		.word	-2147450104
 14914 0964 67000000 		.word	103
 14915 0968 01000000 		.word	1
 14916 096c 46000000 		.word	70
 14917 0970 00000000 		.word	0
 14918 0974 00000000 		.word	0
 14919 0978 02000000 		.word	2
 14920 097c 82000000 		.word	130
 14921 0980 82070000 		.word	1922
 14922 0984 40040000 		.word	1088
 14923 0988 FCFF0000 		.word	65532
 14924 098c 28000000 		.word	40
 14925 0990 00000000 		.word	0
 14926 0994 00000000 		.word	0
 14927 0998 00000000 		.word	0
 14928 099c 00000000 		.word	0
 14929 09a0 01000000 		.word	1
 14930 09a4 00000000 		.word	0
 14931 09a8 00000000 		.word	0
 14932 09ac 00000000 		.word	0
 14933 09b0 00000000 		.word	0
 14934 09b4 00000000 		.word	0
 14935 09b8 00000000 		.word	0
 14936 09bc 00000000 		.word	0
 14937 09c0 00000000 		.word	0
 14938 09c4 00000000 		.word	0
 14939 09c8 00000000 		.word	0
 14940 09cc 00000000 		.word	0
 14941 09d0 00000000 		.word	0
 14942 09d4 06000000 		.word	6
 14943 09d8 00000000 		.word	0
 14944 09dc FFFF0000 		.word	65535
 14945 09e0 09010000 		.word	265
 14946 09e4 00000000 		.word	0
 14947 09e8 F71F0000 		.word	8183
 14948 09ec 00000000 		.word	0
 14949 09f0 FFFF0000 		.word	65535
 14950 09f4 09010000 		.word	265
 14951 09f8 00000000 		.word	0
 14952 09fc F71F0000 		.word	8183
 14953 0a00 00000000 		.word	0
 14954 0a04 00000000 		.word	0
 14955 0a08 00000000 		.word	0
 14956 0a0c 00000000 		.word	0
 14957 0a10 00000000 		.word	0
 14958 0a14 00000000 		.word	0
 14959 0a18 00000000 		.word	0
 14960 0a1c 00000000 		.word	0
 14961 0a20 00000000 		.word	0
 14962 0a24 00000000 		.word	0
 14963 0a28 00000000 		.word	0
 14964 0a2c 00000000 		.word	0
 14965 0a30 00000000 		.word	0
 14966 0a34 00000000 		.word	0
 14967 0a38 00000000 		.word	0
 14968 0a3c 00000000 		.word	0
 14969 0a40 00000000 		.word	0
 14970 0a44 00000000 		.word	0
 14971 0a48 00000000 		.word	0
 14972 0a4c 00000000 		.word	0
 14973 0a50 00000000 		.word	0
 14974 0a54 00000000 		.word	0
 14975 0a58 00000000 		.word	0
 14976 0a5c 00040180 		.word	-2147417088
 14977 0a60 01040180 		.word	-2147417087
 14978 0a64 02040180 		.word	-2147417086
 14979 0a68 03040180 		.word	-2147417085
 14980 0a6c 00000000 		.word	0
 14981 0a70 00000000 		.word	0
 14982 0a74 00000000 		.word	0
 14983 0a78 00000000 		.word	0
 14984 0a7c 00000000 		.word	0
 14985 0a80 00000000 		.word	0
 14986 0a84 00000000 		.word	0
 14987 0a88 00000000 		.word	0
 14988 0a8c C1FFFFFF 		.word	-63
 14991              	CyFxGpifWavedataPosition_usb2:
 14992 0a90 00       		.byte	0
 14993 0a91 01       		.byte	1
 14994 0a92 02       		.byte	2
 14995 0a93 03       		.byte	3
 14996 0a94 04       		.byte	4
 14997 0a95 05       		.byte	5
 14998 0a96 06       		.byte	6
 14999 0a97 07       		.byte	7
 15000 0a98 08       		.byte	8
 15001 0a99 09       		.byte	9
 15002 0a9a 0A       		.byte	10
 15003 0a9b 08       		.byte	8
 15004 0a9c 0B       		.byte	11
 15005 0a9d 0C       		.byte	12
 15006 0a9e 0D       		.byte	13
 15007 0a9f 08       		.byte	8
 15008 0aa0 0E       		.byte	14
 15009 0aa1 0F       		.byte	15
 15010 0aa2 08       		.byte	8
 15011 0aa3 08       		.byte	8
 15012 0aa4 08       		.byte	8
 15013 0aa5 08       		.byte	8
 15014 0aa6 08       		.byte	8
 15015 0aa7 08       		.byte	8
 15016 0aa8 08       		.byte	8
 15017 0aa9 08       		.byte	8
 15018 0aaa 08       		.byte	8
 15019 0aab 08       		.byte	8
 15020 0aac 08       		.byte	8
 15021 0aad 08       		.byte	8
 15022 0aae 08       		.byte	8
 15023 0aaf 08       		.byte	8
 15024 0ab0 08       		.byte	8
 15025 0ab1 08       		.byte	8
 15026 0ab2 08       		.byte	8
 15027 0ab3 08       		.byte	8
 15028 0ab4 08       		.byte	8
 15029 0ab5 08       		.byte	8
 15030 0ab6 08       		.byte	8
 15031 0ab7 08       		.byte	8
 15032 0ab8 08       		.byte	8
 15033 0ab9 08       		.byte	8
 15034 0aba 08       		.byte	8
 15035 0abb 08       		.byte	8
 15036 0abc 08       		.byte	8
 15037 0abd 08       		.byte	8
 15038 0abe 08       		.byte	8
 15039 0abf 08       		.byte	8
 15040 0ac0 08       		.byte	8
 15041 0ac1 08       		.byte	8
 15042 0ac2 08       		.byte	8
 15043 0ac3 08       		.byte	8
 15044 0ac4 08       		.byte	8
 15045 0ac5 08       		.byte	8
 15046 0ac6 08       		.byte	8
 15047 0ac7 08       		.byte	8
 15048 0ac8 08       		.byte	8
 15049 0ac9 08       		.byte	8
 15050 0aca 08       		.byte	8
 15051 0acb 08       		.byte	8
 15052 0acc 08       		.byte	8
 15053 0acd 08       		.byte	8
 15054 0ace 08       		.byte	8
 15055 0acf 08       		.byte	8
 15056 0ad0 08       		.byte	8
 15057 0ad1 08       		.byte	8
 15058 0ad2 08       		.byte	8
 15059 0ad3 08       		.byte	8
 15060 0ad4 08       		.byte	8
 15061 0ad5 08       		.byte	8
 15062 0ad6 08       		.byte	8
 15063 0ad7 08       		.byte	8
 15064 0ad8 08       		.byte	8
 15065 0ad9 08       		.byte	8
 15066 0ada 08       		.byte	8
 15067 0adb 08       		.byte	8
 15068 0adc 08       		.byte	8
 15069 0add 08       		.byte	8
 15070 0ade 08       		.byte	8
 15071 0adf 08       		.byte	8
 15072 0ae0 08       		.byte	8
 15073 0ae1 08       		.byte	8
 15074 0ae2 08       		.byte	8
 15075 0ae3 08       		.byte	8
 15076 0ae4 08       		.byte	8
 15077 0ae5 08       		.byte	8
 15078 0ae6 08       		.byte	8
 15079 0ae7 08       		.byte	8
 15080 0ae8 08       		.byte	8
 15081 0ae9 08       		.byte	8
 15082 0aea 08       		.byte	8
 15083 0aeb 08       		.byte	8
 15084 0aec 08       		.byte	8
 15085 0aed 08       		.byte	8
 15086 0aee 08       		.byte	8
 15087 0aef 08       		.byte	8
 15088 0af0 08       		.byte	8
 15089 0af1 08       		.byte	8
 15090 0af2 08       		.byte	8
 15091 0af3 08       		.byte	8
 15092 0af4 08       		.byte	8
 15093 0af5 08       		.byte	8
 15094 0af6 08       		.byte	8
 15095 0af7 08       		.byte	8
 15096 0af8 08       		.byte	8
 15097 0af9 08       		.byte	8
 15098 0afa 08       		.byte	8
 15099 0afb 08       		.byte	8
 15100 0afc 08       		.byte	8
 15101 0afd 08       		.byte	8
 15102 0afe 08       		.byte	8
 15103 0aff 08       		.byte	8
 15104 0b00 08       		.byte	8
 15105 0b01 08       		.byte	8
 15106 0b02 08       		.byte	8
 15107 0b03 08       		.byte	8
 15108 0b04 08       		.byte	8
 15109 0b05 08       		.byte	8
 15110 0b06 08       		.byte	8
 15111 0b07 08       		.byte	8
 15112 0b08 08       		.byte	8
 15113 0b09 08       		.byte	8
 15114 0b0a 08       		.byte	8
 15115 0b0b 08       		.byte	8
 15116 0b0c 08       		.byte	8
 15117 0b0d 08       		.byte	8
 15118 0b0e 08       		.byte	8
 15119 0b0f 08       		.byte	8
 15120 0b10 00       		.byte	0
 15121 0b11 01       		.byte	1
 15122 0b12 02       		.byte	2
 15123 0b13 10       		.byte	16
 15124 0b14 04       		.byte	4
 15125 0b15 05       		.byte	5
 15126 0b16 06       		.byte	6
 15127 0b17 07       		.byte	7
 15128 0b18 08       		.byte	8
 15129 0b19 09       		.byte	9
 15130 0b1a 0A       		.byte	10
 15131 0b1b 08       		.byte	8
 15132 0b1c 11       		.byte	17
 15133 0b1d 0C       		.byte	12
 15134 0b1e 0D       		.byte	13
 15135 0b1f 08       		.byte	8
 15136 0b20 0E       		.byte	14
 15137 0b21 0F       		.byte	15
 15138 0b22 08       		.byte	8
 15139 0b23 00       		.space	1
 15142              	CyFxGpifWavedata_usb2:
 15143 0b24 0181731E 		.word	510886145
 15144 0b28 00000000 		.word	0
 15145 0b2c 00000080 		.word	-2147483648
 15146 0b30 00000000 		.word	0
 15147 0b34 00000000 		.word	0
 15148 0b38 00000000 		.word	0
 15149 0b3c 0201703E 		.word	1047527682
 15150 0b40 00010000 		.word	256
 15151 0b44 A00000C0 		.word	-1073741664
 15152 0b48 00000000 		.word	0
 15153 0b4c 00000000 		.word	0
 15154 0b50 00000000 		.word	0
 15155 0b54 0394731E 		.word	510891011
 15156 0b58 04000020 		.word	536870916
 15157 0b5c 60004080 		.word	-2143289248
 15158 0b60 00000000 		.word	0
 15159 0b64 00000000 		.word	0
 15160 0b68 00000000 		.word	0
 15161 0b6c 0620702E 		.word	779100166
 15162 0b70 0C000000 		.word	12
 15163 0b74 00000080 		.word	-2147483648
 15164 0b78 0620702E 		.word	779100166
 15165 0b7c 0C000000 		.word	12
 15166 0b80 00000080 		.word	-2147483648
 15167 0b84 0394731E 		.word	510891011
 15168 0b88 04000020 		.word	536870916
 15169 0b8c 60004080 		.word	-2143289248
 15170 0b90 0620702E 		.word	779100166
 15171 0b94 0C000000 		.word	12
 15172 0b98 00000080 		.word	-2147483648
 15173 0b9c 0C93731E 		.word	510890764
 15174 0ba0 04000024 		.word	603979780
 15175 0ba4 90004080 		.word	-2143289200
 15176 0ba8 0D20702E 		.word	779100173
 15177 0bac 0C000000 		.word	12
 15178 0bb0 00000080 		.word	-2147483648
 15179 0bb4 0780724E 		.word	1316126727
 15180 0bb8 0A000000 		.word	10
 15181 0bbc 00000080 		.word	-2147483648
 15182 0bc0 08000000 		.word	8
 15183 0bc4 00000000 		.word	0
 15184 0bc8 00010080 		.word	-2147483392
 15185 0bcc 0920702E 		.word	779100169
 15186 0bd0 0C010000 		.word	268
 15187 0bd4 00000080 		.word	-2147483648
 15188 0bd8 0A01701E 		.word	510656778
 15189 0bdc 0E000100 		.word	65550
 15190 0be0 00000080 		.word	-2147483648
 15191 0be4 00000000 		.word	0
 15192 0be8 00000000 		.word	0
 15193 0bec 00000000 		.word	0
 15194 0bf0 00000000 		.word	0
 15195 0bf4 00000000 		.word	0
 15196 0bf8 00000000 		.word	0
 15197 0bfc 0394731E 		.word	510891011
 15198 0c00 04000020 		.word	536870916
 15199 0c04 60004080 		.word	-2143289248
 15200 0c08 08000000 		.word	8
 15201 0c0c 00000000 		.word	0
 15202 0c10 00010080 		.word	-2147483392
 15203 0c14 0B000000 		.word	11
 15204 0c18 00000000 		.word	0
 15205 0c1c 00010080 		.word	-2147483392
 15206 0c20 0C93731E 		.word	510890764
 15207 0c24 04000024 		.word	603979780
 15208 0c28 90004080 		.word	-2143289200
 15209 0c2c 0D20702E 		.word	779100173
 15210 0c30 0C000000 		.word	12
 15211 0c34 00000080 		.word	-2147483648
 15212 0c38 0D20702E 		.word	779100173
 15213 0c3c 0C000000 		.word	12
 15214 0c40 00000080 		.word	-2147483648
 15215 0c44 0E60724E 		.word	1316118542
 15216 0c48 0A000000 		.word	10
 15217 0c4c 00000080 		.word	-2147483648
 15218 0c50 0F000000 		.word	15
 15219 0c54 00000000 		.word	0
 15220 0c58 00010080 		.word	-2147483392
 15221 0c5c 1020702E 		.word	779100176
 15222 0c60 0C010000 		.word	268
 15223 0c64 00000080 		.word	-2147483648
 15224 0c68 1101701E 		.word	510656785
 15225 0c6c 0E000100 		.word	65550
 15226 0c70 00000080 		.word	-2147483648
 15227 0c74 0C93731E 		.word	510890764
 15228 0c78 04000024 		.word	603979780
 15229 0c7c 90004080 		.word	-2143289200
 15230 0c80 0F000000 		.word	15
 15231 0c84 00000000 		.word	0
 15232 0c88 00010080 		.word	-2147483392
 15233 0c8c 12000000 		.word	18
 15234 0c90 00000000 		.word	0
 15235 0c94 00010080 		.word	-2147483392
 15236 0c98 0394731E 		.word	510891011
 15237 0c9c 04000020 		.word	536870916
 15238 0ca0 60004080 		.word	-2143289248
 15239 0ca4 0480732E 		.word	779321348
 15240 0ca8 02010000 		.word	258
 15241 0cac 0000C0C0 		.word	-1061158912
 15242 0cb0 0580732E 		.word	779321349
 15243 0cb4 02010000 		.word	258
 15244 0cb8 0000C0C0 		.word	-1061158912
 15245 0cbc 0580732E 		.word	779321349
 15246 0cc0 02010000 		.word	258
 15247 0cc4 0000C0C0 		.word	-1061158912
 15248 0cc8 0480732E 		.word	779321348
 15249 0ccc 02010000 		.word	258
 15250 0cd0 0000C0C0 		.word	-1061158912
 15253              	CyFxGpifTransition_usb2:
 15254 0cd4 0000     		.short	0
 15255 0cd6 5555     		.short	21845
 15256 0cd8 AAAA     		.short	-21846
 15257 0cda 8888     		.short	-30584
 15258 0cdc 1111     		.short	4369
 15259 0cde 4444     		.short	17476
 15260 0ce0 3333     		.short	13107
 15261 0ce2 CCCC     		.short	-13108
 15264              	CyFxGpifRegValue:
 15265 0ce4 08830080 		.word	-2147450104
 15266 0ce8 67000000 		.word	103
 15267 0cec 00000000 		.word	0
 15268 0cf0 46000000 		.word	70
 15269 0cf4 00000000 		.word	0
 15270 0cf8 00000000 		.word	0
 15271 0cfc 02000000 		.word	2
 15272 0d00 82000000 		.word	130
 15273 0d04 82070000 		.word	1922
 15274 0d08 40040000 		.word	1088
 15275 0d0c FCFF0000 		.word	65532
 15276 0d10 28000000 		.word	40
 15277 0d14 00000000 		.word	0
 15278 0d18 00000000 		.word	0
 15279 0d1c 00000000 		.word	0
 15280 0d20 00000000 		.word	0
 15281 0d24 01000000 		.word	1
 15282 0d28 00000000 		.word	0
 15283 0d2c 00000000 		.word	0
 15284 0d30 00000000 		.word	0
 15285 0d34 00000000 		.word	0
 15286 0d38 00000000 		.word	0
 15287 0d3c 00000000 		.word	0
 15288 0d40 00000000 		.word	0
 15289 0d44 00000000 		.word	0
 15290 0d48 00000000 		.word	0
 15291 0d4c 00000000 		.word	0
 15292 0d50 00000000 		.word	0
 15293 0d54 00000000 		.word	0
 15294 0d58 06000000 		.word	6
 15295 0d5c 00000000 		.word	0
 15296 0d60 FFFF0000 		.word	65535
 15297 0d64 09010000 		.word	265
 15298 0d68 00000000 		.word	0
 15299 0d6c F71F0000 		.word	8183
 15300 0d70 00000000 		.word	0
 15301 0d74 FFFF0000 		.word	65535
 15302 0d78 09010000 		.word	265
 15303 0d7c 00000000 		.word	0
 15304 0d80 F71F0000 		.word	8183
 15305 0d84 00000000 		.word	0
 15306 0d88 00000000 		.word	0
 15307 0d8c 00000000 		.word	0
 15308 0d90 00000000 		.word	0
 15309 0d94 00000000 		.word	0
 15310 0d98 00000000 		.word	0
 15311 0d9c 00000000 		.word	0
 15312 0da0 00000000 		.word	0
 15313 0da4 00000000 		.word	0
 15314 0da8 00000000 		.word	0
 15315 0dac 00000000 		.word	0
 15316 0db0 00000000 		.word	0
 15317 0db4 00000000 		.word	0
 15318 0db8 00000000 		.word	0
 15319 0dbc 00000000 		.word	0
 15320 0dc0 00000000 		.word	0
 15321 0dc4 00000000 		.word	0
 15322 0dc8 00000000 		.word	0
 15323 0dcc 00000000 		.word	0
 15324 0dd0 00000000 		.word	0
 15325 0dd4 00000000 		.word	0
 15326 0dd8 00000000 		.word	0
 15327 0ddc 00000000 		.word	0
 15328 0de0 00040180 		.word	-2147417088
 15329 0de4 01040180 		.word	-2147417087
 15330 0de8 02040180 		.word	-2147417086
 15331 0dec 03040180 		.word	-2147417085
 15332 0df0 00000000 		.word	0
 15333 0df4 00000000 		.word	0
 15334 0df8 00000000 		.word	0
 15335 0dfc 00000000 		.word	0
 15336 0e00 00000000 		.word	0
 15337 0e04 00000000 		.word	0
 15338 0e08 00000000 		.word	0
 15339 0e0c 00000000 		.word	0
 15340 0e10 C1FFFFFF 		.word	-63
 15343              	CyFxGpifWavedataPosition:
 15344 0e14 00       		.byte	0
 15345 0e15 01       		.byte	1
 15346 0e16 02       		.byte	2
 15347 0e17 03       		.byte	3
 15348 0e18 04       		.byte	4
 15349 0e19 05       		.byte	5
 15350 0e1a 06       		.byte	6
 15351 0e1b 07       		.byte	7
 15352 0e1c 08       		.byte	8
 15353 0e1d 09       		.byte	9
 15354 0e1e 0A       		.byte	10
 15355 0e1f 0B       		.byte	11
 15356 0e20 0B       		.byte	11
 15357 0e21 0B       		.byte	11
 15358 0e22 0B       		.byte	11
 15359 0e23 00       		.space	1
 15362              	CyFxGpifWavedata:
 15363 0e24 0181731E 		.word	510886145
 15364 0e28 00000000 		.word	0
 15365 0e2c 00000080 		.word	-2147483648
 15366 0e30 00000000 		.word	0
 15367 0e34 00000000 		.word	0
 15368 0e38 00000000 		.word	0
 15369 0e3c 0201702E 		.word	779092226
 15370 0e40 00010000 		.word	256
 15371 0e44 A0000080 		.word	-2147483488
 15372 0e48 00000000 		.word	0
 15373 0e4c 00000000 		.word	0
 15374 0e50 00000000 		.word	0
 15375 0e54 0380722E 		.word	779255811
 15376 0e58 02010020 		.word	536871170
 15377 0e5c 60000080 		.word	-2147483552
 15378 0e60 00000000 		.word	0
 15379 0e64 00000000 		.word	0
 15380 0e68 00000000 		.word	0
 15381 0e6c 0460722E 		.word	779247620
 15382 0e70 02010024 		.word	603980034
 15383 0e74 90000080 		.word	-2147483504
 15384 0e78 0594731E 		.word	510891013
 15385 0e7c 06000000 		.word	6
 15386 0e80 00000080 		.word	-2147483648
 15387 0e84 0380722E 		.word	779255811
 15388 0e88 02010020 		.word	536871170
 15389 0e8c 60000080 		.word	-2147483552
 15390 0e90 0693731E 		.word	510890758
 15391 0e94 06000000 		.word	6
 15392 0e98 00000080 		.word	-2147483648
 15393 0e9c 0720703E 		.word	1047535623
 15394 0ea0 08010000 		.word	264
 15395 0ea4 00000080 		.word	-2147483648
 15396 0ea8 0820703E 		.word	1047535624
 15397 0eac 08010000 		.word	264
 15398 0eb0 00000080 		.word	-2147483648
 15399 0eb4 0920703E 		.word	1047535625
 15400 0eb8 08010000 		.word	264
 15401 0ebc 00000080 		.word	-2147483648
 15402 0ec0 0A20703E 		.word	1047535626
 15403 0ec4 08010000 		.word	264
 15404 0ec8 00000080 		.word	-2147483648
 15405 0ecc 0380722E 		.word	779255811
 15406 0ed0 02010020 		.word	536871170
 15407 0ed4 60000080 		.word	-2147483552
 15408 0ed8 0B000000 		.word	11
 15409 0edc 00000000 		.word	0
 15410 0ee0 00010080 		.word	-2147483392
 15411 0ee4 0460722E 		.word	779247620
 15412 0ee8 02010024 		.word	603980034
 15413 0eec 90000080 		.word	-2147483504
 15414 0ef0 0D000000 		.word	13
 15415 0ef4 00000000 		.word	0
 15416 0ef8 00010080 		.word	-2147483392
 15417 0efc 0460722E 		.word	779247620
 15418 0f00 02010024 		.word	603980034
 15419 0f04 90000080 		.word	-2147483504
 15420 0f08 0C000000 		.word	12
 15421 0f0c 00000000 		.word	0
 15422 0f10 00010080 		.word	-2147483392
 15423 0f14 0380722E 		.word	779255811
 15424 0f18 02010020 		.word	536871170
 15425 0f1c 60000080 		.word	-2147483552
 15426 0f20 0E000000 		.word	14
 15427 0f24 00000000 		.word	0
 15428 0f28 00010080 		.word	-2147483392
 15429 0f2c 00000000 		.word	0
 15430 0f30 00000000 		.word	0
 15431 0f34 00000000 		.word	0
 15432 0f38 00000000 		.word	0
 15433 0f3c 00000000 		.word	0
 15434 0f40 00000000 		.word	0
 15437              	CyFxGpifTransition:
 15438 0f44 0000     		.short	0
 15439 0f46 5555     		.short	21845
 15440 0f48 8888     		.short	-30584
 15441 0f4a AAAA     		.short	-21846
 15442 0f4c 3333     		.short	13107
 15443 0f4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15444              		.align	2
 15445              	.LC0:
 15446 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15446      706F732D 
 15446      74696D65 
 15446      72202564 
 15446      2025640D 
 15447 0016 0000     		.space	2
 15448              	.LC1:
 15449 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15449      6F207374 
 15449      7265616D 
 15449      20474554 
 15449      20726571 
 15450 003d 000000   		.space	3
 15451              	.LC2:
 15452 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15452      74686520 
 15452      76696465 
 15452      6F206D6F 
 15452      64652066 
 15453 0061 000000   		.space	3
 15454              	.LC3:
 15455 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15455      74686520 
 15455      76696465 
 15455      6F206D6F 
 15455      64652066 
 15456 0089 000000   		.space	3
 15457              	.LC4:
 15458 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15458      43595F46 
 15458      585F5556 
 15458      435F5354 
 15458      5245414D 
 15459 00b2 0000     		.space	2
 15460              	.LC5:
 15461 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15461      55564320 
 15461      7374696C 
 15461      6C205072 
 15461      6F622873 
 15462 00df 00       		.space	1
 15463              	.LC6:
 15464 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15464      74686520 
 15464      7374696C 
 15464      6C206D6F 
 15464      64652066 
 15465 0101 000000   		.space	3
 15466              	.LC7:
 15467 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15467      7374696C 
 15467      6C20636F 
 15467      6D6D6974 
 15467      20636F6E 
 15468              	.LC8:
 15469 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15469      43595F46 
 15469      585F5556 
 15469      435F5354 
 15469      494C5F45 
 15470              	.LC9:
 15471 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15471      55564320 
 15471      7374696C 
 15471      6C207472 
 15471      69676765 
 15472 0179 000000   		.space	3
 15473              	.LC10:
 15474 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15474      7374696C 
 15474      6C207472 
 15474      69676765 
 15474      7220636F 
 15475 01a3 00       		.space	1
 15476              	.LC11:
 15477 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15477      7065722D 
 15477      74696D65 
 15477      72202564 
 15477      0D0A00
 15478 01b7 00       		.space	1
 15479              	.LC12:
 15480 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15480      636F6D6D 
 15480      616E6420 
 15480      71756575 
 15480      65206973 
 15481 01db 00       		.space	1
 15482              	.LC13:
 15483 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15483      7220696E 
 15483      206D756C 
 15483      74696368 
 15483      616E6E65 
 15484 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15484      2025782C 
 15484      20646D61 
 15484      446F6E65 
 15484      20256420 
 15485              	.LC14:
 15486 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15486      5420656E 
 15486      636F756E 
 15486      74657265 
 15486      642E2E2E 
 15487              	.LC15:
 15488 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15488      454E4420 
 15488      656E636F 
 15488      756E7465 
 15488      7265642E 
 15489 026a 0000     		.space	2
 15490              	.LC16:
 15491 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15491      64697363 
 15491      6F6E6E65 
 15491      63746564 
 15491      2E2E2E30 
 15492 028b 00       		.space	1
 15493              	.LC17:
 15494 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15494      43595F46 
 15494      585F5556 
 15494      435F5649 
 15494      44454F5F 
 15495 02bf 0A00     		.ascii	"\012\000"
 15496 02c1 000000   		.space	3
 15497              	.LC18:
 15498 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15498      43595F46 
 15498      585F5556 
 15498      435F5649 
 15498      44454F5F 
 15499 02f7 00       		.ascii	"\000"
 15500              	.LC19:
 15501 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15501      726E6174 
 15501      65207365 
 15501      7474696E 
 15501      6720302E 
 15502              	.LC20:
 15503 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15503      72206665 
 15503      61747572 
 15503      65207265 
 15503      71756573 
 15504 0333 00       		.space	1
 15505              	.LC21:
 15506 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15506      49324320 
 15506      636F6D6D 
 15506      616E6420 
 15506      69732030 
 15507 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15507      78257820 
 15507      30782578 
 15507      20307825 
 15507      78203078 
 15508              	.LC22:
 15509 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15509      49324320 
 15509      636F6D6D 
 15509      616E6420 
 15509      73657474 
 15510 03a6 0000     		.space	2
 15511              	.LC23:
 15512 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15512      73687574 
 15512      74657220 
 15512      73657420 
 15512      76616C75 
 15513 03d2 0000     		.space	2
 15514              	.LC24:
 15515 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15515      26414743 
 15515      2073656E 
 15515      7420746F 
 15515      20686F73 
 15516 03fa 0000     		.space	2
 15517              	.LC25:
 15518 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15518      49324320 
 15518      63757272 
 15518      656E7420 
 15518      64617461 
 15519 042f 64202564 		.ascii	"d %d\015\012\000"
 15519      0D0A00
 15520 0436 0000     		.space	2
 15521              	.LC26:
 15522 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 15522      63757272 
 15522      656E7420 
 15522      76616C75 
 15522      65203078 
 15523 0465 000000   		.space	3
 15524              	.LC27:
 15525 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 15525      73657420 
 15525      636F6E74 
 15525      726F6C20 
 15525      6374726C 
 15526 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x Data0: 0x%x Data1: 0x%x\015\012"
 15526      443A2030 
 15526      78257820 
 15526      4C656E3A 
 15526      20307825 
 15527 04ca 00       		.ascii	"\000"
 15528 04cb 00       		.space	1
 15529              	.LC28:
 15530 04cc 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15530      26414743 
 15530      20676F74 
 15530      74656E20 
 15530      66726F6D 
 15531 04fd 0A00     		.ascii	"\012\000"
 15532 04ff 00       		.space	1
 15533              	.LC29:
 15534 0500 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15534      73687574 
 15534      74657226 
 15534      6578706F 
 15534      73757265 
 15535 052b 00       		.space	1
 15536              	.LC30:
 15537 052c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15537      74657220 
 15537      6C657665 
 15537      6C20676F 
 15537      7474656E 
 15538 055f 25640D0A 		.ascii	"%d\015\012\000"
 15538      00
 15539              	.LC31:
 15540 0564 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 15540      64617461 
 15540      20676574 
 15540      73206672 
 15540      6F6D2068 
 15541 0597 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 15541      78206375 
 15541      7248693A 
 15541      20307825 
 15541      78204C65 
 15542 05b5 000000   		.space	3
 15543              	.LC32:
 15544 05b8 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15544      75656E63 
 15544      79207365 
 15544      7474696E 
 15544      67206973 
 15545 05d6 0000     		.space	2
 15546              	.LC33:
 15547 05d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15547      20746865 
 15547      20766964 
 15547      656F206D 
 15547      6F646520 
 15548 05fa 0000     		.space	2
 15549              	.LC34:
 15550 05fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15550      67657420 
 15550      64617461 
 15550      2066726F 
 15550      6D20686F 
 15551 0629 000000   		.space	3
 15552              	.LC35:
 15553 062c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15553      52657175 
 15553      65737420 
 15553      30782578 
 15553      20706172 
 15554 065f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15554      6E642074 
 15554      6F20686F 
 15554      73742030 
 15554      78257820 
 15555 067a 0000     		.space	2
 15556              	.LC36:
 15557 067c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15557      204F7020 
 15557      72656365 
 15557      69766573 
 15557      20284354 
 15558 06a3 00       		.space	1
 15559              	.LC37:
 15560 06a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15560      756C7420 
 15560      73656C65 
 15560      63746F72 
 15560      20284354 
 15561 06c6 0000     		.space	2
 15562              	.LC38:
 15563 06c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15563      756C7420 
 15563      72657175 
 15563      65737420 
 15563      28435429 
 15564 06e9 000000   		.space	3
 15565              	.LC39:
 15566 06ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15566      52657175 
 15566      65737420 
 15566      30782578 
 15566      20706172 
 15567 071f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15567      20307825 
 15567      78202F20 
 15567      73656E64 
 15567      20746F20 
 15568 074c 00       		.ascii	"\000"
 15569 074d 000000   		.space	3
 15570              	.LC40:
 15571 0750 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15571      73657420 
 15571      64656620 
 15571      64617461 
 15571      20307825 
 15572 076f 00       		.space	1
 15573              	.LC41:
 15574 0770 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15574      73657420 
 15574      64656620 
 15574      64617461 
 15574      20307825 
 15575 07a3 2E0D0A00 		.ascii	".\015\012\000"
 15576 07a7 00       		.space	1
 15577              	.LC42:
 15578 07a8 4572726F 		.ascii	"Error handler...\015\012\000"
 15578      72206861 
 15578      6E646C65 
 15578      722E2E2E 
 15578      0D0A00
 15579 07bb 00       		.space	1
 15580              	.LC43:
 15581 07bc 55415254 		.ascii	"UART initialization failed!\012\000"
 15581      20696E69 
 15581      7469616C 
 15581      697A6174 
 15581      696F6E20 
 15582 07d9 000000   		.space	3
 15583              	.LC44:
 15584 07dc 49324320 		.ascii	"I2C initialization failed!\012\000"
 15584      696E6974 
 15584      69616C69 
 15584      7A617469 
 15584      6F6E2066 
 15585              	.LC45:
 15586 07f8 49324320 		.ascii	"I2C configuration failed!\012\000"
 15586      636F6E66 
 15586      69677572 
 15586      6174696F 
 15586      6E206661 
 15587 0813 00       		.space	1
 15588              	.LC46:
 15589 0814 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15589      43726561 
 15589      74652045 
 15589      76656E74 
 15589      20666169 
 15590 083e 0000     		.space	2
 15591              	.LC47:
 15592 0840 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15592      20496E69 
 15592      74206661 
 15592      696C6564 
 15592      2C204572 
 15593 0863 00       		.space	1
 15594              	.LC48:
 15595 0864 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15595      204F7665 
 15595      72726964 
 15595      65206661 
 15595      696C6564 
 15596 088b 00       		.space	1
 15597              	.LC49:
 15598 088c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15598      28323029 
 15598      204F7665 
 15598      72726964 
 15598      65206661 
 15599 08b7 00       		.space	1
 15600              	.LC50:
 15601 08b8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15601      28323429 
 15601      204F7665 
 15601      72726964 
 15601      65206661 
 15602 08e3 00       		.space	1
 15603              	.LC51:
 15604 08e4 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15604      20536574 
 15604      20287265 
 15604      73657420 
 15604      32322920 
 15605 0916 00       		.ascii	"\000"
 15606 0917 00       		.space	1
 15607              	.LC52:
 15608 0918 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15608      20536574 
 15608      2028706F 
 15608      77657220 
 15608      32302920 
 15609 094a 00       		.ascii	"\000"
 15610 094b 00       		.space	1
 15611              	.LC53:
 15612 094c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15612      20536574 
 15612      2028736E 
 15612      61702073 
 15612      686F7420 
 15613 097f 25640A00 		.ascii	"%d\012\000"
 15614 0983 00       		.space	1
 15615              	.LC54:
 15616 0984 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15616      46756E63 
 15616      74696F6E 
 15616      20466169 
 15616      6C656420 
 15617 09b3 00       		.space	1
 15618              	.LC55:
 15619 09b4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15619      46756E63 
 15619      74696F6E 
 15619      20466169 
 15619      6C656420 
 15620 09e3 00       		.space	1
 15621              	.LC56:
 15622 09e4 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15622      53657420 
 15622      456E6470 
 15622      6F696E74 
 15622      20636F6E 
 15623 0a14 00       		.ascii	"\000"
 15624 0a15 000000   		.space	3
 15625              	.LC57:
 15626 0a18 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15626      496E7465 
 15626      72727570 
 15626      74205374 
 15626      61747573 
 15627 0a4b 20436F64 		.ascii	" Code = %d\012\000"
 15627      65203D20 
 15627      25640A00 
 15628 0a57 00       		.space	1
 15629              	.LC58:
 15630 0a58 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15630      65642074 
 15630      6F20616C 
 15630      6C6F6361 
 15630      7465206D 
 15631 0a8b 65720D0A 		.ascii	"er\015\012\000"
 15631      00
 15632              	.LC59:
 15633 0a90 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15633      4368616E 
 15633      6E656C20 
 15633      43726561 
 15633      74696F6E 
 15634 0abe 0000     		.space	2
 15635              	.LC60:
 15636 0ac0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15636      436F6E6E 
 15636      65637420 
 15636      6661696C 
 15636      65642C20 
 15637 0ae5 000000   		.space	3
 15638              	.LC61:
 15639 0ae8 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15639      74686520 
 15639      76696465 
 15639      6F206D6F 
 15639      64652066 
 15640 0b0a 0000     		.space	2
 15641              	.LC62:
 15642 0b0c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15642      4368616E 
 15642      6E656C20 
 15642      52657365 
 15642      74204661 
 15643 0b37 00       		.space	1
 15644              	.LC63:
 15645 0b38 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15645      4368616E 
 15645      6E656C20 
 15645      53657420 
 15645      5472616E 
 15646 0b69 00       		.ascii	"\000"
 15647 0b6a 0000     		.space	2
 15648              	.LC64:
 15649 0b6c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15649      4368616E 
 15649      6E656C20 
 15649      53657420 
 15649      5472616E 
 15650 0b9d 0A00     		.ascii	"\012\000"
 15651 0b9f 00       		.space	1
 15652              	.LC65:
 15653 0ba0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15653      75706572 
 15653      20677069 
 15653      6600
 15654 0bae 0000     		.space	2
 15655              	.LC66:
 15656 0bb0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15656      69676820 
 15656      67706966 
 15656      00
 15657 0bbd 000000   		.space	3
 15658              	.LC67:
 15659 0bc0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15659      696E6720 
 15659      47504946 
 15659      20436F6E 
 15659      66696775 
 15660 0bf3 0A00     		.ascii	"\012\000"
 15661 0bf5 000000   		.space	3
 15662              	.LC68:
 15663 0bf8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15663      74696E67 
 15663      20475049 
 15663      46207374 
 15663      61746520 
 15664 0c2b 0D0A00   		.ascii	"\015\012\000"
 15665 0c2e 0000     		.space	2
 15666              	.LC69:
 15667 0c30 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15667      73706565 
 15667      64203D20 
 15667      25642065 
 15667      76656E66 
 15668 0c60 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15668      71756573 
 15668      74203D20 
 15668      30782578 
 15668      20775661 
 15669 0c90 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15669      203D2030 
 15669      78257820 
 15669      6973666C 
 15669      61672030 
 15670 0caa 0000     		.space	2
 15671              	.LC70:
 15672 0cac 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15672      64656661 
 15672      756C7420 
 15672      73657475 
 15672      70207265 
 15673              	.LC71:
 15674 0cd8 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 15674      68797374 
 15674      65722063 
 15674      6F6D6D61 
 15674      6E642030 
 15675 0cf7 00       		.space	1
 15676              	.LC72:
 15677 0cf8 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 15677      6374726C 
 15677      73706420 
 15677      636F6D6D 
 15677      616E6420 
 15678              	.LC73:
 15679 0d18 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 15679      65646765 
 15679      4D6F6465 
 15679      20636F6D 
 15679      6D616E64 
 15680 0d39 000000   		.space	3
 15681              	.LC74:
 15682 0d3c 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 15682      65646765 
 15682      6761696E 
 15682      20636F6D 
 15682      6D616E64 
 15683 0d5d 000000   		.space	3
 15684              	.LC75:
 15685 0d60 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 15685      65646765 
 15685      20737461 
 15685      72742F65 
 15685      6E642063 
 15686 0d87 00       		.space	1
 15687              	.LC76:
 15688 0d88 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 15688      32444E52 
 15688      20737461 
 15688      72742F65 
 15688      6E642063 
 15689 0daf 00       		.space	1
 15690              	.LC77:
 15691 0db0 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 15691      67616D6D 
 15691      6120636F 
 15691      6D6D616E 
 15691      64203078 
 15692 0dce 0000     		.space	2
 15693              	.LC78:
 15694 0dd0 54686520 		.ascii	"The AGC Max command 0x%x 0x%x\015\012\000"
 15694      41474320 
 15694      4D617820 
 15694      636F6D6D 
 15694      616E6420 
 15695              	.LC79:
 15696 0df0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15696      65642074 
 15696      6F207365 
 15696      6E642069 
 15696      6E746572 
 15697 0e21 0A00     		.ascii	"\012\000"
 15698 0e23 00       		.space	1
 15699              	.LC80:
 15700 0e24 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15700      6F6D6D69 
 15700      74656F66 
 15700      20737461 
 15700      7465203D 
 15701              	.LC81:
 15702 0e3c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15702      6E656C20 
 15702      53657420 
 15702      57726170 
 15702      55702066 
 15703 0e69 000000   		.space	3
 15704              	.LC82:
 15705 0e6c 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15705      69742045 
 15705      4F462066 
 15705      61696C65 
 15705      64210D0A 
 15706 0e81 000000   		.space	3
 15707              	.LC83:
 15708 0e84 49324363 		.ascii	"I2CcmdQue\000"
 15708      6D645175 
 15708      6500
 15709 0e8e 0000     		.space	2
 15710              	.LC84:
 15711 0e90 33303A55 		.ascii	"30:UVC App Thread\000"
 15711      56432041 
 15711      70702054 
 15711      68726561 
 15711      6400
 15712 0ea2 0000     		.space	2
 15713              	.LC85:
 15714 0ea4 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15714      56432041 
 15714      70702045 
 15714      50302054 
 15714      68726561 
 15715 0eba 0000     		.space	2
 15716              	.LC86:
 15717 0ebc 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15717      32432041 
 15717      70702043 
 15717      54524C20 
 15717      54687265 
 15718 0ed3 00       		.bss
 15719              		.align	2
 15720              		.set	.LANCHOR0,. + 0
 15723              	glFxUVCEvent:
 15724 0000 00000000 		.space	40
 15724      00000000 
 15724      00000000 
 15724      00000000 
 15724      00000000 
 15727              	glEp0Buffer:
 15728 0028 00000000 		.space	32
 15728      00000000 
 15728      00000000 
 15728      00000000 
 15728      00000000 
 15731              	usbSpeed:
 15732 0048 00       		.space	1
 15733 0049 000000   		.space	3
 15736              	glCommitCtrl:
 15737 004c 00000000 		.space	32
 15737      00000000 
 15737      00000000 
 15737      00000000 
 15737      00000000 
 15740              	is60Hz:
 15741 006c 00000000 		.space	4
 15744              	setRes:
 15745 0070 00       		.space	1
 15748              	setstilRes:
 15749 0071 00       		.space	1
 15752              	stiflag:
 15753 0072 00       		.space	1
 15754 0073 00       		.space	1
 15757              	fb:
 15758 0074 0000     		.space	2
 15761              	pb:
 15762 0076 0000     		.space	2
 15765              	pbc:
 15766 0078 0000     		.space	2
 15767 007a 0000     		.space	2
 15770              	hitFV:
 15771 007c 00000000 		.space	4
 15774              	prodCount:
 15775 0080 0000     		.space	2
 15778              	consCount:
 15779 0082 0000     		.space	2
 15782              	streamingStarted:
 15783 0084 00000000 		.space	4
 15786              	gpif_initialized:
 15787 0088 00000000 		.space	4
 15790              	isUsbConnected:
 15791 008c 00000000 		.space	4
 15794              	clearFeatureRqtReceived:
 15795 0090 00000000 		.space	4
 15798              	I2CCMDArry:
 15799 0094 00000000 		.space	12
 15799      00000000 
 15799      00000000 
 15802              	IMcount.8243:
 15803 00a0 00       		.space	1
 15804 00a1 000000   		.space	3
 15807              	uvcAppThread:
 15808 00a4 00000000 		.space	168
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15808      00000000 
 15811              	uvcAppEP0Thread:
 15812 014c 00000000 		.space	168
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15812      00000000 
 15815              	i2cAppThread:
 15816 01f4 00000000 		.space	168
 15816      00000000 
 15816      00000000 
 15816      00000000 
 15816      00000000 
 15819              	pbcpbak:
 15820 029c 0000     		.space	2
 15823              	pbcbak:
 15824 029e 0000     		.space	2
 15827              	pbbak:
 15828 02a0 0000     		.space	2
 15831              	fbbak:
 15832 02a2 0000     		.space	2
 15835              	testSnap:
 15836 02a4 00       		.space	1
 15837 02a5 000000   		.text
 15838              	.Letext0:
 15839              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15840              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15841              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15842              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15843              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15844              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15845              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15846              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15847              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15848              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15849              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15850              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15851              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15852              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15853              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15854              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15855              		.file 18 "../sensor.h"
 15856              		.file 19 "../cmdqu.h"
 15857              		.file 20 "../uvc.h"
 15858              		.file 21 "../cyfxgpif2config.h"
 15859              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15860              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2550   .text:000014dc $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2578   .text:00001540 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2664   .text:00001600 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2682   .text:00001640 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2804   .text:00001744 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2817   .text:00001770 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2876   .text:000017f0 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:2891   .text:00001820 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4087   .text:00002310 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4109   .text:0000235c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4421   .text:00002654 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4427   .text:00002664 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4769   .text:000029cc CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4916   .text:00002af4 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:4929   .text:00002b1c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5345   .text:00002f4c $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5356   .text:00002f6c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5626   .text:00003200 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5638   .text:00003224 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5641   .text:00003224 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5942   .text:000034e0 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5949   .text:000034f0 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5952   .text:000034f0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:5996   .text:00003534 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6001   .text:0000353c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6004   .text:0000353c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6032   .text:00003558 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6036   .text:0000355c $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6039   .text:0000355c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6824   .text:00003bd8 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:6830   .text:00003be8 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:7305   .text:00003fd0 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12122  .text:000065f8 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:7364   .text:000040a8 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:7367   .text:000040a8 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:7436   .text:00004120 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:7444   .text:00004130 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:9227   .text:0000508c $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:9265   .text:00005108 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12109  .text:000065ec $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12119  .text:000065f8 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12154  .text:0000662c $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12167  .text:00006658 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12172  .text:00006668 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12177  .text:00006678 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12225  .text:000066d0 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12235  .text:000066e4 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12238  .text:000066e4 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12391  .text:0000682c $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12408  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12411  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13749  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12768  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12689  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12753  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12659  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12719  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15782  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15794  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15731  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15790  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15819  .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15823  .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15827  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15831  .bss:000002a2 fbbak
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15765  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15761  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15757  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15835  .bss:000002a4 testSnap
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14401  .data:00000792 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12643  .rodata:000001bc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14912  .data:00000960 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14991  .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15142  .data:00000b24 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15253  .data:00000cd4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12630  .rodata:000001a0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15264  .data:00000ce4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15343  .data:00000e14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15362  .data:00000e24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15437  .data:00000f44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12551  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12555  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12570  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13969  .data:000005b0 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14780  .data:000008e8 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14758  .data:000008d4 EXTMirror
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14736  .data:000008c0 EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14714  .data:000008ac EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14692  .data:00000898 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14336  .data:00000758 EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14670  .data:00000884 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14648  .data:00000870 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13786  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14626  .data:0000085c EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13991  .data:000005c4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14604  .data:00000848 EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14582  .data:00000834 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14560  .data:00000820 EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13830  .data:00000534 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14538  .data:0000080c EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13764  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14516  .data:000007f8 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13808  .data:00000520 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14494  .data:000007e4 EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14358  .data:0000076c EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14380  .data:00000780 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14472  .data:000007d0 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14450  .data:000007bc EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14428  .data:000007a8 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14406  .data:00000794 EXTAGCMaxLimit
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12607  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13947  .data:0000059c PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13852  .data:00000548 PUCBright
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14890  .data:0000094c PUCContrast
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13896  .data:00000570 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13874  .data:0000055c PUCHueC
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14868  .data:00000938 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13925  .data:00000588 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14846  .data:00000924 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14824  .data:00000910 PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14802  .data:000008fc PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12626  .rodata:00000160 curFlag
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12655  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12748  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:12783  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13106  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:13918  .data:00000584 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:14013  .data:000005d8 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15444  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15719  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15723  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15727  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15736  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15740  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15744  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15748  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15752  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15770  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15774  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15778  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15786  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15798  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15802  .bss:000000a0 IMcount.8243
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15807  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15811  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cceGI9Ut.s:15815  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
SensorGetControl
memcpy
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
